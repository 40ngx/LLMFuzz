[
    "bool safe_tiffgetfield(string_view name, int tag, void* dest)\n    {\n        void* ptr = NULL;  // dummy -- expect it to stay NULL\n        bool ok   = TIFFGetField(m_tif, tag, dest, &ptr);\n        if (ptr) {\n#ifndef NDEBUG\n            std::cerr << \"Error safe_tiffgetfield : did not expect ptr set on \"\n                      << name << \" \" << (void*)ptr << \"\\n\";\n#endif\n            return false;\n        }\n        return ok;\n    }",
    "bool tiff_get_string_field(int tag, string_view& result)\n    {\n        char* s   = NULL;\n        void* ptr = NULL;  // dummy -- expect it to stay NULL\n        bool ok   = TIFFGetField(m_tif, tag, &s, &ptr);\n        if (ok && ptr) {\n            // Oy, some tags need 2 args, which are count, then ptr.\n            // There's no way to know ahead of time which ones, so we send\n            // a second pointer. If it gets overwritten, then we understand\n            // and try it again with 2 args, first one is count.\n            unsigned short count;\n            ok     = TIFFGetField(m_tif, tag, &count, &s);\n            result = string_view(s, count);\n        } else if (ok && s && *s)\n            result = string_view(s);\n        return ok;\n    }",
    "void\nTIFFInput::readspec(bool read_meta)\n{\n    uint32 width = 0, height = 0, depth = 0;\n    TIFFGetField(m_tif, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(m_tif, TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_IMAGEDEPTH, &depth);\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_SAMPLESPERPIXEL, &m_inputchannels);\n\n    if (read_meta) {\n        // clear the whole m_spec and start fresh\n        m_spec = ImageSpec((int)width, (int)height, (int)m_inputchannels);\n    } else {\n        // assume m_spec is valid, except for things that might differ\n        // between MIP levels\n        m_spec.width     = (int)width;\n        m_spec.height    = (int)height;\n        m_spec.depth     = (int)depth;\n        m_spec.nchannels = (int)m_inputchannels;\n    }\n\n    float xpos = 0, ypos = 0;\n    TIFFGetField(m_tif, TIFFTAG_XPOSITION, &xpos);\n    TIFFGetField(m_tif, TIFFTAG_YPOSITION, &ypos);\n    if (xpos || ypos) {\n        // In the TIFF files, the positions are in resolutionunit. But we\n        // didn't used to interpret it that way, hence the mess below.\n        float xres = 1, yres = 1;\n        TIFFGetField(m_tif, TIFFTAG_XRESOLUTION, &xres);\n        TIFFGetField(m_tif, TIFFTAG_YRESOLUTION, &yres);\n        // See if the 'Software' field has a clue about what version of OIIO\n        // wrote the TIFF file. This can save us from embarrassing mistakes\n        // misinterpreting the image offset.\n        int oiio_write_version = 0;\n        string_view software;\n        if (tiff_get_string_field(TIFFTAG_SOFTWARE, software)\n            && Strutil::parse_prefix(software, \"OpenImageIO\")) {\n            int major = 0, minor = 0, patch = 0;\n            if (Strutil::parse_int(software, major)\n                && Strutil::parse_char(software, '.')\n                && Strutil::parse_int(software, minor)\n                && Strutil::parse_char(software, '.')\n                && Strutil::parse_int(software, patch)) {\n                oiio_write_version = major * 10000 + minor * 100 + patch;\n            }\n        }\n        // Old version of OIIO did not write the field correctly, so try\n        // to compensate.\n        if (oiio_write_version && oiio_write_version < 10803) {\n            xres = yres = 1.0f;\n        }\n        m_spec.x = (int)(xpos * xres);\n        m_spec.y = (int)(ypos * yres);\n    } else {\n        m_spec.x = 0;\n        m_spec.y = 0;\n    }\n    m_spec.z = 0;\n\n    // Start by assuming the \"full\" (aka display) window is the same as the\n    // data window. That's what we'll stick to if there is no further\n    // information in the file. But if the file has tags for hte \"full\"\n    // size, assume a display window with origin (0,0) and those dimensions.\n    // (Unfortunately, there are no TIFF tags for \"full\" origin.)\n    m_spec.full_x      = m_spec.x;\n    m_spec.full_y      = m_spec.y;\n    m_spec.full_z      = m_spec.z;\n    m_spec.full_width  = m_spec.width;\n    m_spec.full_height = m_spec.height;\n    m_spec.full_depth  = m_spec.depth;\n    if (TIFFGetField(m_tif, TIFFTAG_PIXAR_IMAGEFULLWIDTH, &width) == 1\n        && TIFFGetField(m_tif, TIFFTAG_PIXAR_IMAGEFULLLENGTH, &height) == 1\n        && width > 0 && height > 0) {\n        m_spec.full_width  = width;\n        m_spec.full_height = height;\n        m_spec.full_x      = 0;\n        m_spec.full_y      = 0;\n    }\n\n    if (TIFFIsTiled(m_tif)) {\n        TIFFGetField(m_tif, TIFFTAG_TILEWIDTH, &m_spec.tile_width);\n        TIFFGetField(m_tif, TIFFTAG_TILELENGTH, &m_spec.tile_height);\n        TIFFGetFieldDefaulted(m_tif, TIFFTAG_TILEDEPTH, &m_spec.tile_depth);\n    } else {\n        m_spec.tile_width  = 0;\n        m_spec.tile_height = 0;\n        m_spec.tile_depth  = 0;\n    }\n\n    m_bitspersample = 8;\n    TIFFGetField(m_tif, TIFFTAG_BITSPERSAMPLE, &m_bitspersample);\n    m_spec.attribute(\"oiio:BitsPerSample\", (int)m_bitspersample);\n\n    unsigned short sampleformat = SAMPLEFORMAT_UINT;\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_SAMPLEFORMAT, &sampleformat);\n    switch (m_bitspersample) {\n    case 1:\n    case 2:\n    case 4:\n    case 6:\n        // Make 1, 2, 4, 6 bpp look like byte images\n    case 8:\n        if (sampleformat == SAMPLEFORMAT_UINT)\n            m_spec.set_format(TypeDesc::UINT8);\n        else if (sampleformat == SAMPLEFORMAT_INT)\n            m_spec.set_format(TypeDesc::INT8);\n        else\n            m_spec.set_format(TypeDesc::UINT8);  // punt\n        break;\n    case 10:\n    case 12:\n    case 14:\n        // Make 10, 12, 14 bpp look like 16 bit images\n    case 16:\n        if (sampleformat == SAMPLEFORMAT_UINT)\n            m_spec.set_format(TypeDesc::UINT16);\n        else if (sampleformat == SAMPLEFORMAT_INT)\n            m_spec.set_format(TypeDesc::INT16);\n        else if (sampleformat == SAMPLEFORMAT_IEEEFP) {\n            m_spec.set_format(TypeDesc::HALF);\n            // Adobe extension, see http://chriscox.org/TIFFTN3d1.pdf\n        } else\n            m_spec.set_format(TypeDesc::UNKNOWN);\n        break;\n    case 24:\n        // Make 24 bit look like 32 bit\n    case 32:\n        if (sampleformat == SAMPLEFORMAT_IEEEFP)\n            m_spec.set_format(TypeDesc::FLOAT);\n        else if (sampleformat == SAMPLEFORMAT_UINT)\n            m_spec.set_format(TypeDesc::UINT32);\n        else if (sampleformat == SAMPLEFORMAT_INT)\n            m_spec.set_format(TypeDesc::INT32);\n        else\n            m_spec.set_format(TypeDesc::UNKNOWN);\n        break;\n    case 64:\n        if (sampleformat == SAMPLEFORMAT_IEEEFP)\n            m_spec.set_format(TypeDesc::DOUBLE);\n        else\n            m_spec.set_format(TypeDesc::UNKNOWN);\n        break;\n    default: m_spec.set_format(TypeDesc::UNKNOWN); break;\n    }\n\n    // Use the table for all the obvious things that can be mindlessly\n    // shoved into the image spec.\n    if (read_meta) {\n        for (const auto& tag : tag_table(\"TIFF\"))\n            find_tag(tag.tifftag, tag.tifftype, tag.name);\n        for (const auto& tag : tag_table(\"Exif\"))\n            find_tag(tag.tifftag, tag.tifftype, tag.name);\n    }\n\n    // Now we need to get fields \"by hand\" for anything else that is less\n    // straightforward...\n\n    readspec_photometric();\n\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_PLANARCONFIG, &m_planarconfig);\n    m_separate = (m_planarconfig == PLANARCONFIG_SEPARATE\n                  && m_spec.nchannels > 1\n                  && m_photometric != PHOTOMETRIC_PALETTE);\n    m_spec.attribute(\"tiff:PlanarConfiguration\", (int)m_planarconfig);\n    if (m_planarconfig == PLANARCONFIG_SEPARATE)\n        m_spec.attribute(\"planarconfig\", \"separate\");\n    else\n        m_spec.attribute(\"planarconfig\", \"contig\");\n\n    m_compression = 0;\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_COMPRESSION, &m_compression);\n    m_spec.attribute(\"tiff:Compression\", (int)m_compression);\n    if (const char* compressname = tiff_compression_name(m_compression))\n        m_spec.attribute(\"compression\", compressname);\n    m_predictor = PREDICTOR_NONE;\n    if (!safe_tiffgetfield(\"Predictor\", TIFFTAG_PREDICTOR, &m_predictor))\n        m_predictor = PREDICTOR_NONE;\n\n    m_rowsperstrip = -1;\n    if (!m_spec.tile_width) {\n        TIFFGetField(m_tif, TIFFTAG_ROWSPERSTRIP, &m_rowsperstrip);\n        if (m_rowsperstrip > 0)\n            m_spec.attribute(\"tiff:RowsPerStrip\", m_rowsperstrip);\n    }\n\n    // The libtiff docs say that only uncompressed images, or those with\n    // rowsperstrip==1, support random access to scanlines.\n    m_no_random_access = (m_compression != COMPRESSION_NONE\n                          && m_rowsperstrip != 1);\n\n    // Do we care about fillorder?  No, the TIFF spec says, \"We\n    // recommend that FillOrder=2 (lsb-to-msb) be used only in\n    // special-purpose applications\".  So OIIO will assume msb-to-lsb\n    // convention until somebody finds a TIFF file in the wild that\n    // breaks this assumption.\n\n    unsigned short* sampleinfo  = NULL;\n    unsigned short extrasamples = 0;\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_EXTRASAMPLES, &extrasamples,\n                          &sampleinfo);\n    // std::cerr << \"Extra samples = \" << extrasamples << \"\\n\";\n    bool alpha_is_unassociated = false;  // basic assumption\n    if (extrasamples) {\n        // If the TIFF ExtraSamples tag was specified, use that to figure\n        // out the meaning of alpha.\n        int colorchannels = 3;\n        if (m_photometric == PHOTOMETRIC_MINISWHITE\n            || m_photometric == PHOTOMETRIC_MINISBLACK\n            || m_photometric == PHOTOMETRIC_PALETTE\n            || m_photometric == PHOTOMETRIC_MASK)\n            colorchannels = 1;\n        for (int i = 0, c = colorchannels;\n             i < extrasamples && c < m_inputchannels; ++i, ++c) {\n            // std::cerr << \"   extra \" << i << \" \" << sampleinfo[i] << \"\\n\";\n            if (sampleinfo[i] == EXTRASAMPLE_ASSOCALPHA) {\n                // This is the alpha channel, associated as usual\n                m_spec.alpha_channel = c;\n            } else if (sampleinfo[i] == EXTRASAMPLE_UNASSALPHA) {\n                // This is the alpha channel, but color is unassociated\n                m_spec.alpha_channel  = c;\n                alpha_is_unassociated = true;\n                if (m_keep_unassociated_alpha)\n                    m_spec.attribute(\"oiio:UnassociatedAlpha\", 1);\n            } else {\n                DASSERT(sampleinfo[i] == EXTRASAMPLE_UNSPECIFIED);\n                // This extra channel is not alpha at all.  Undo any\n                // assumptions we previously made about this channel.\n                if (m_spec.alpha_channel == c) {\n                    m_spec.channelnames[c] = Strutil::sprintf(\"channel%d\", c);\n                    m_spec.alpha_channel   = -1;\n                }\n            }\n        }\n        if (m_spec.alpha_channel >= 0) {\n            m_spec.channelnames[m_spec.alpha_channel] = \"A\";\n            // Special case: \"R\",\"A\" should really be named \"Y\",\"A\", since\n            // the first channel is luminance, not red.\n            if (m_spec.nchannels == 2 && m_spec.alpha_channel == 1)\n                m_spec.channelnames[0] = \"Y\";\n        }\n    }\n    if (alpha_is_unassociated)\n        m_spec.attribute(\"tiff:UnassociatedAlpha\", 1);\n    // Will we need to do alpha conversions?\n    m_convert_alpha = (m_spec.alpha_channel >= 0 && alpha_is_unassociated\n                       && !m_keep_unassociated_alpha);\n\n    // N.B. we currently ignore the following TIFF fields:\n    // GrayResponseCurve GrayResponseUnit\n    // MaxSampleValue MinSampleValue\n    // NewSubfileType SubfileType(deprecated)\n    // Colorimetry fields\n\n    // If we've been instructed to skip reading metadata, because it is\n    // assumed to be identical to what we already have in m_spec,\n    // skip everything following.\n    if (!read_meta)\n        return;\n\n    short resunit = -1;\n    TIFFGetField(m_tif, TIFFTAG_RESOLUTIONUNIT, &resunit);\n    switch (resunit) {\n    case RESUNIT_NONE: m_spec.attribute(\"ResolutionUnit\", \"none\"); break;\n    case RESUNIT_INCH: m_spec.attribute(\"ResolutionUnit\", \"in\"); break;\n    case RESUNIT_CENTIMETER: m_spec.attribute(\"ResolutionUnit\", \"cm\"); break;\n    }\n    float xdensity = m_spec.get_float_attribute(\"XResolution\", 0.0f);\n    float ydensity = m_spec.get_float_attribute(\"YResolution\", 0.0f);\n    if (xdensity && ydensity)\n        m_spec.attribute(\"PixelAspectRatio\", ydensity / xdensity);\n\n    get_matrix_attribute(\"worldtocamera\", TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA);\n    get_matrix_attribute(\"worldtoscreen\", TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN);\n    get_int_attribute(\"tiff:subfiletype\", TIFFTAG_SUBFILETYPE);\n    // FIXME -- should subfiletype be \"conventionized\" and used for all\n    // plugins uniformly?\n\n    // Special names for shadow maps\n    char* s = NULL;\n    TIFFGetField(m_tif, TIFFTAG_PIXAR_TEXTUREFORMAT, &s);\n    if (s)\n        m_emulate_mipmap = true;\n    if (s && !strcmp(s, \"Shadow\")) {\n        for (int c = 0; c < m_spec.nchannels; ++c)\n            m_spec.channelnames[c] = \"z\";\n    }\n\n    /// read color profile\n    unsigned int icc_datasize = 0;\n    unsigned char* icc_buf    = NULL;\n    TIFFGetField(m_tif, TIFFTAG_ICCPROFILE, &icc_datasize, &icc_buf);\n    if (icc_datasize && icc_buf)\n        m_spec.attribute(ICC_PROFILE_ATTR,\n                         TypeDesc(TypeDesc::UINT8, icc_datasize), icc_buf);\n\n        // Search for an EXIF IFD in the TIFF file, and if found, rummage\n        // around for Exif fields.\n#if TIFFLIB_VERSION > 20050912 /* compat with old TIFF libs - skip Exif */\n    toff_t exifoffset = 0;\n    if (TIFFGetField(m_tif, TIFFTAG_EXIFIFD, &exifoffset)\n        && TIFFReadEXIFDirectory(m_tif, exifoffset)) {\n        for (const auto& tag : tag_table(\"Exif\"))\n            find_tag(tag.tifftag, tag.tifftype, tag.name);\n        // Look for a Makernote\n        auto makerfield = find_field(EXIF_MAKERNOTE, TIFF_UNDEFINED);\n        // std::unique_ptr<uint32_t[]> buf (new uint32_t[]);\n        if (makerfield) {\n            // bool ok = TIFFGetField (m_tif, tag, dest, &ptr);\n            unsigned int mn_datasize = 0;\n            unsigned char* mn_buf    = NULL;\n            TIFFGetField(m_tif, EXIF_MAKERNOTE, &mn_datasize, &mn_buf);\n        }\n        // I'm not sure what state TIFFReadEXIFDirectory leaves us.\n        // So to be safe, close and re-seek.\n        TIFFClose(m_tif);\n#    ifdef _WIN32\n        std::wstring wfilename = Strutil::utf8_to_utf16(m_filename);\n        m_tif                  = TIFFOpenW(wfilename.c_str(), \"rm\");\n#    else\n        m_tif = TIFFOpen(m_filename.c_str(), \"rm\");\n#    endif\n        if (m_subimage)\n            TIFFSetDirectory(m_tif, m_subimage);\n\n        // A few tidbits to look for\n        ParamValue* p;\n        if ((p = m_spec.find_attribute(\"Exif:ColorSpace\", TypeDesc::INT))) {\n            // Exif spec says that anything other than 0xffff==uncalibrated\n            // should be interpreted to be sRGB.\n            if (*(const int*)p->data() != 0xffff)\n                m_spec.attribute(\"oiio:ColorSpace\", \"sRGB\");\n        }\n    }\n#endif\n\n#if TIFFLIB_VERSION >= 20051230\n    // Search for IPTC metadata in IIM form -- but older versions of\n    // libtiff botch the size, so ignore it for very old libtiff.\n    int iptcsize         = 0;\n    const void* iptcdata = NULL;\n    if (TIFFGetField(m_tif, TIFFTAG_RICHTIFFIPTC, &iptcsize, &iptcdata)) {\n        std::vector<uint32> iptc((uint32*)iptcdata,\n                                 (uint32*)iptcdata + iptcsize);\n        if (TIFFIsByteSwapped(m_tif))\n            TIFFSwabArrayOfLong((uint32*)&iptc[0], iptcsize);\n        decode_iptc_iim(&iptc[0], iptcsize * 4, m_spec);\n    }\n#endif\n\n    // Search for an XML packet containing XMP (IPTC, Exif, etc.)\n    int xmlsize         = 0;\n    const void* xmldata = NULL;\n    if (TIFFGetField(m_tif, TIFFTAG_XMLPACKET, &xmlsize, &xmldata)) {\n        // std::cerr << \"Found XML data, size \" << xmlsize << \"\\n\";\n        if (xmldata && xmlsize) {\n            std::string xml((const char*)xmldata, xmlsize);\n            decode_xmp(xml, m_spec);\n        }\n    }\n\n#if 0\n    // Experimental -- look for photoshop data\n    int photoshopsize = 0;\n    const void *photoshopdata = NULL;\n    if (TIFFGetField (m_tif, TIFFTAG_PHOTOSHOP, &photoshopsize, &photoshopdata)) {\n        std::cerr << \"Found PHOTOSHOP data, size \" << photoshopsize << \"\\n\";\n        if (photoshopdata && photoshopsize) {\n//            std::string photoshop ((const char *)photoshopdata, photoshopsize);\n//            std::cerr << \"PHOTOSHOP:\\n\" << photoshop << \"\\n---\\n\";\n        }\n    }\n#endif\n\n    // If Software and IPTC:OriginatingProgram are identical, kill the latter\n    if (m_spec.get_string_attribute(\"Software\")\n        == m_spec.get_string_attribute(\"IPTC:OriginatingProgram\"))\n        m_spec.erase_attribute(\"IPTC:OriginatingProgram\");\n\n    std::string desc = m_spec.get_string_attribute(\"ImageDescription\");\n    // If ImageDescription and IPTC:Caption are identical, kill the latter\n    if (desc == m_spec.get_string_attribute(\"IPTC:Caption\"))\n        m_spec.erase_attribute(\"IPTC:Caption\");\n\n    // Because TIFF doesn't support arbitrary metadata, we look for certain\n    // hints in the ImageDescription and turn them into metadata, also\n    // removing them from the ImageDescrption.\n    bool updatedDesc = false;\n    auto cc = Strutil::excise_string_after_head(desc, \"oiio:ConstantColor=\");\n    if (cc.size()) {\n        m_spec.attribute(\"oiio:ConstantColor\", cc);\n        updatedDesc = true;\n    }\n    auto ac = Strutil::excise_string_after_head(desc, \"oiio:AverageColor=\");\n    if (ac.size()) {\n        m_spec.attribute(\"oiio:AverageColor\", ac);\n        updatedDesc = true;\n    }\n    std::string sha = Strutil::excise_string_after_head(desc, \"oiio:SHA-1=\");\n    if (sha.empty())  // back compatibility with OIIO < 1.5\n        sha = Strutil::excise_string_after_head(desc, \"SHA-1=\");\n    if (sha.size()) {\n        m_spec.attribute(\"oiio:SHA-1\", sha);\n        updatedDesc = true;\n    }\n\n    if (updatedDesc) {\n        string_view d(desc);\n        Strutil::skip_whitespace(d);  // erase if it's only whitespace\n        if (d.size())\n            m_spec.attribute(\"ImageDescription\", desc);\n        else\n            m_spec.erase_attribute(\"ImageDescription\");\n    }\n\n    // Squash some problematic texture metadata if we suspect it's wrong\n    pvt::check_texture_metadata_sanity(m_spec);\n\n    if (m_testopenconfig)  // open-with-config debugging\n        m_spec.attribute(\"oiio:DebugOpenConfig!\", 42);\n}",
    "void\nTIFFInput::readspec_photometric()\n{\n    m_photometric = (m_spec.nchannels == 1 ? PHOTOMETRIC_MINISBLACK\n                                           : PHOTOMETRIC_RGB);\n    TIFFGetField(m_tif, TIFFTAG_PHOTOMETRIC, &m_photometric);\n    m_spec.attribute(\"tiff:PhotometricInterpretation\", (int)m_photometric);\n    switch (m_photometric) {\n    case PHOTOMETRIC_SEPARATED: {\n        // Photometric \"separated\" is \"usually CMYK\".\n        m_spec.channelnames.clear();\n        short inkset       = INKSET_CMYK;\n        short numberofinks = 0;\n        TIFFGetFieldDefaulted(m_tif, TIFFTAG_INKSET, &inkset);\n        TIFFGetFieldDefaulted(m_tif, TIFFTAG_NUMBEROFINKS, &numberofinks);\n        if (inkset == INKSET_CMYK && m_spec.nchannels == 4) {\n            // True CMYK\n            m_spec.attribute(\"tiff:ColorSpace\", \"CMYK\");\n            if (m_raw_color) {\n                m_spec.channelnames.resize(4);\n                m_spec.channelnames[0] = \"C\";\n                m_spec.channelnames[1] = \"M\";\n                m_spec.channelnames[2] = \"Y\";\n                m_spec.channelnames[3] = \"K\";\n                m_spec.attribute(\"oiio:ColorSpace\", \"CMYK\");\n            } else {\n                // Silently convert to RGB\n                m_spec.nchannels = 3;\n                m_spec.default_channel_names();\n            }\n        } else {\n            // Non-CMYK ink set\n            m_spec.attribute(\"tiff:ColorSpace\", \"color separated\");\n            m_spec.attribute(\"oiio:ColorSpace\", \"color separated\");\n            m_raw_color = true;  // Conversion to RGB doesn't make sense\n            const char* inknames = NULL;\n            safe_tiffgetfield(\"tiff:InkNames\", TIFFTAG_INKNAMES, &inknames);\n            if (inknames && inknames[0] && numberofinks) {\n                m_spec.channelnames.clear();\n                // Decode the ink names, which are all concatenated together.\n                for (int i = 0; i < int(numberofinks); ++i) {\n                    string_view ink(inknames);\n                    if (ink.size()) {\n                        m_spec.channelnames.emplace_back(ink);\n                        inknames += ink.size() + 1;\n                    } else {\n                        // Run out of road\n                        numberofinks = i;\n                    }\n                }\n            } else {\n                numberofinks = 0;\n            }\n            // No ink names. Make it up.\n            for (int i = numberofinks; i < m_spec.nchannels; ++i)\n                m_spec.channelnames.emplace_back(Strutil::sprintf(\"ink%d\", i));\n        }\n        break;\n    }\n    case PHOTOMETRIC_YCBCR: m_spec.attribute(\"tiff:ColorSpace\", \"YCbCr\"); break;\n    case PHOTOMETRIC_CIELAB:\n        m_spec.attribute(\"tiff:ColorSpace\", \"CIELAB\");\n        break;\n    case PHOTOMETRIC_ICCLAB:\n        m_spec.attribute(\"tiff:ColorSpace\", \"ICCLAB\");\n        break;\n    case PHOTOMETRIC_ITULAB:\n        m_spec.attribute(\"tiff:ColorSpace\", \"ITULAB\");\n        break;\n    case PHOTOMETRIC_LOGL: m_spec.attribute(\"tiff:ColorSpace\", \"LOGL\"); break;\n    case PHOTOMETRIC_LOGLUV:\n        m_spec.attribute(\"tiff:ColorSpace\", \"LOGLUV\");\n        break;\n    case PHOTOMETRIC_PALETTE: {\n        m_spec.attribute(\"tiff:ColorSpace\", \"palette\");\n        // Read the color map\n        unsigned short *r = NULL, *g = NULL, *b = NULL;\n        TIFFGetField(m_tif, TIFFTAG_COLORMAP, &r, &g, &b);\n        ASSERT(r != NULL && g != NULL && b != NULL);\n        m_colormap.clear();\n        m_colormap.insert(m_colormap.end(), r, r + (1 << m_bitspersample));\n        m_colormap.insert(m_colormap.end(), g, g + (1 << m_bitspersample));\n        m_colormap.insert(m_colormap.end(), b, b + (1 << m_bitspersample));\n        // Palette TIFF images are always 3 channels (to the client)\n        m_spec.nchannels = 3;\n        m_spec.default_channel_names();\n        if (m_bitspersample != m_spec.format.size() * 8) {\n            // For palette images with unusual bits per sample, set\n            // oiio:BitsPerSample to the \"full\" version, to avoid problems\n            // when copying the file back to a TIFF file (we don't write\n            // palette images), but do leave \"tiff:BitsPerSample\" to reflect\n            // the original file.\n            m_spec.attribute(\"tiff:BitsPerSample\", (int)m_bitspersample);\n            m_spec.attribute(\"oiio:BitsPerSample\",\n                             (int)m_spec.format.size() * 8);\n        }\n        // FIXME - what about palette + extra (alpha?) channels?  Is that\n        // allowed?  And if so, ever encountered in the wild?\n        break;\n    }\n    }\n}",
    "int TIFFGetField1(TIFF* tif, uint32_t tag, void* param) {\n  return TIFFGetField(tif, tag, param);\n}",
    "int TIFFGetField2(TIFF* tif, uint32_t tag, void* param1, void* param2) {\n  return TIFFGetField(tif, tag, param1, param2);\n}",
    "int TIFFGetField3(TIFF* tif, uint32_t tag, void* param1, void* param2,\n                  void* param3) {\n  return TIFFGetField(tif, tag, param1, param2, param3);\n}",
    "OIIO_NODISCARD\n    bool safe_tiffgetfield(string_view name OIIO_MAYBE_UNUSED, int tag,\n                           TypeDesc expected, void* dest)\n    {\n        TypeDesc type = tiffgetfieldtype(tag);\n        // Caller expects a specific type and the tag doesn't match? Punt.\n        if (expected != TypeUnknown && !equivalent(expected, type))\n            return false;\n        auto field = find_field(tag);\n        if (!field)\n            return false;\n\n        // TIFFDataType tiffdatatype = TIFFFieldDataType(field);\n        int passcount = TIFFFieldPassCount(field);\n        int readcount = TIFFFieldReadCount(field);\n        if (!passcount && readcount > 0) {\n            return TIFFGetField(m_tif, tag, dest);\n        }\n        // OIIO::debugfmt(\" stgf {} tag {} {} datatype {} passcount {} readcount {}\\n\",\n        //                name, tag, type, int(TIFFFieldDataType(field)), passcount, readcount);\n        return false;\n    }",
    "OIIO_NODISCARD\n    bool tiff_get_string_field(int tag, string_view name OIIO_MAYBE_UNUSED,\n                               string_view& result)\n    {\n        auto field = find_field(tag);\n        if (!field)\n            return false;\n        TIFFDataType tiffdatatype = TIFFFieldDataType(field);\n        int passcount             = TIFFFieldPassCount(field);\n        int readcount             = TIFFFieldReadCount(field);\n        // Strutil::printf(\" tgsf %s tag %d datatype %d passcount %d readcount %d\\n\",\n        //                 name, tag, int(tiffdatatype), passcount, readcount);\n        char* s        = nullptr;\n        uint32_t count = 0;\n        bool ok        = false;\n        if (tiffdatatype == TIFF_ASCII && passcount\n            && readcount == TIFF_VARIABLE) {\n            uint16_t shortcount = 0;\n            ok                  = TIFFGetField(m_tif, tag, &shortcount, &s);\n            count               = shortcount;\n        } else if (tiffdatatype == TIFF_ASCII && passcount\n                   && readcount == TIFF_VARIABLE2) {\n            ok = TIFFGetField(m_tif, tag, &count, &s);\n        } else if (readcount > 0) {\n            ok    = TIFFGetField(m_tif, tag, &s);\n            count = readcount;\n        } else if (tiffdatatype == TIFF_ASCII) {\n            ok = TIFFGetField(m_tif, tag, &s);\n            if (ok && s && *s)\n                count = Strutil::safe_strlen(s, 64 * 1024);\n        } else {\n            // Some other type, we should not have been asking for this\n            // as ASCII, or maybe the tag is just the wrong data type in\n            // the file. Punt.\n        }\n        if (ok && s && *s) {\n            result = Strutil::safe_string_view(s, count);\n        }\n        return ok;\n    }",
    "bool\nTIFFInput::readspec(bool read_meta)\n{\n    uint32_t width = 0, height = 0, depth = 0;\n    TIFFGetField(m_tif, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(m_tif, TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_IMAGEDEPTH, &depth);\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_SAMPLESPERPIXEL, &m_inputchannels);\n\n    if (read_meta) {\n        // clear the whole m_spec and start fresh\n        m_spec = ImageSpec((int)width, (int)height, (int)m_inputchannels);\n    } else {\n        // assume m_spec is valid, except for things that might differ\n        // between MIP levels\n        m_spec.width     = (int)width;\n        m_spec.height    = (int)height;\n        m_spec.depth     = (int)depth;\n        m_spec.nchannels = (int)m_inputchannels;\n    }\n\n    float xpos = 0, ypos = 0;\n    TIFFGetField(m_tif, TIFFTAG_XPOSITION, &xpos);\n    TIFFGetField(m_tif, TIFFTAG_YPOSITION, &ypos);\n    if (xpos || ypos) {\n        // In the TIFF files, the positions are in resolutionunit. But we\n        // didn't used to interpret it that way, hence the mess below.\n        float xres = 1, yres = 1;\n        TIFFGetField(m_tif, TIFFTAG_XRESOLUTION, &xres);\n        TIFFGetField(m_tif, TIFFTAG_YRESOLUTION, &yres);\n        // See if the 'Software' field has a clue about what version of OIIO\n        // wrote the TIFF file. This can save us from embarrassing mistakes\n        // misinterpreting the image offset.\n        int oiio_write_version = 0;\n        string_view software;\n        if (tiff_get_string_field(TIFFTAG_SOFTWARE, \"Software\", software)\n            && Strutil::parse_prefix(software, \"OpenImageIO\")) {\n            int major = 0, minor = 0, patch = 0;\n            if (Strutil::parse_int(software, major)\n                && Strutil::parse_char(software, '.')\n                && Strutil::parse_int(software, minor)\n                && Strutil::parse_char(software, '.')\n                && Strutil::parse_int(software, patch)) {  // NOSONAR\n                oiio_write_version = major * 10000 + minor * 100 + patch;\n            }\n        }\n        // Old version of OIIO did not write the field correctly, so try\n        // to compensate.\n        if (oiio_write_version && oiio_write_version < 10803) {\n            xres = yres = 1.0f;\n        }\n        m_spec.x = (int)(xpos * xres);\n        m_spec.y = (int)(ypos * yres);\n    } else {\n        m_spec.x = 0;\n        m_spec.y = 0;\n    }\n    m_spec.z = 0;\n\n    // Start by assuming the \"full\" (aka display) window is the same as the\n    // data window. That's what we'll stick to if there is no further\n    // information in the file. But if the file has tags for the \"full\"\n    // size, assume a display window with origin (0,0) and those dimensions.\n    // (Unfortunately, there are no TIFF tags for \"full\" origin.)\n    m_spec.full_x      = m_spec.x;\n    m_spec.full_y      = m_spec.y;\n    m_spec.full_z      = m_spec.z;\n    m_spec.full_width  = m_spec.width;\n    m_spec.full_height = m_spec.height;\n    m_spec.full_depth  = m_spec.depth;\n    if (TIFFGetField(m_tif, TIFFTAG_PIXAR_IMAGEFULLWIDTH, &width) == 1\n        && TIFFGetField(m_tif, TIFFTAG_PIXAR_IMAGEFULLLENGTH, &height) == 1\n        && width > 0 && height > 0) {\n        m_spec.full_width  = width;\n        m_spec.full_height = height;\n        m_spec.full_x      = 0;\n        m_spec.full_y      = 0;\n    }\n\n    if (TIFFIsTiled(m_tif)) {\n        TIFFGetField(m_tif, TIFFTAG_TILEWIDTH, &m_spec.tile_width);\n        TIFFGetField(m_tif, TIFFTAG_TILELENGTH, &m_spec.tile_height);\n        TIFFGetFieldDefaulted(m_tif, TIFFTAG_TILEDEPTH, &m_spec.tile_depth);\n    } else {\n        m_spec.tile_width  = 0;\n        m_spec.tile_height = 0;\n        m_spec.tile_depth  = 0;\n    }\n\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_BITSPERSAMPLE, &m_bitspersample);\n    m_spec.attribute(\"oiio:BitsPerSample\", (int)m_bitspersample);\n\n    unsigned short sampleformat = SAMPLEFORMAT_UINT;\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_SAMPLEFORMAT, &sampleformat);\n    switch (m_bitspersample) {\n    case 1:\n    case 2:\n    case 4:\n    case 6:\n        // Make 1, 2, 4, 6 bpp look like byte images\n    case 8:\n        if (sampleformat == SAMPLEFORMAT_UINT)\n            m_spec.set_format(TypeDesc::UINT8);\n        else if (sampleformat == SAMPLEFORMAT_INT)\n            m_spec.set_format(TypeDesc::INT8);\n        else\n            m_spec.set_format(TypeDesc::UINT8);  // punt\n        break;\n    case 10:\n    case 12:\n    case 14:\n        // Make 10, 12, 14 bpp look like 16 bit images\n    case 16:\n        if (sampleformat == SAMPLEFORMAT_UINT)\n            m_spec.set_format(TypeDesc::UINT16);\n        else if (sampleformat == SAMPLEFORMAT_INT)\n            m_spec.set_format(TypeDesc::INT16);\n        else if (sampleformat == SAMPLEFORMAT_IEEEFP) {\n            m_spec.set_format(TypeDesc::HALF);\n            // Adobe extension, see http://chriscox.org/TIFFTN3d1.pdf\n        } else\n            m_spec.set_format(TypeDesc::UNKNOWN);\n        break;\n    case 24:\n        // Make 24 bit look like 32 bit\n    case 32:\n        if (sampleformat == SAMPLEFORMAT_IEEEFP)\n            m_spec.set_format(TypeDesc::FLOAT);\n        else if (sampleformat == SAMPLEFORMAT_UINT)\n            m_spec.set_format(TypeDesc::UINT32);\n        else if (sampleformat == SAMPLEFORMAT_INT)\n            m_spec.set_format(TypeDesc::INT32);\n        else\n            m_spec.set_format(TypeDesc::UNKNOWN);\n        break;\n    case 64:\n        if (sampleformat == SAMPLEFORMAT_IEEEFP)\n            m_spec.set_format(TypeDesc::DOUBLE);\n        else\n            m_spec.set_format(TypeDesc::UNKNOWN);\n        break;\n    default: m_spec.set_format(TypeDesc::UNKNOWN); break;\n    }\n\n    // Use the table for all the obvious things that can be mindlessly\n    // shoved into the image spec.\n    if (read_meta) {\n        for (const auto& tag : tag_table(\"TIFF\"))\n            find_tag(tag.tifftag, tag.tifftype, tag.name);\n        for (const auto& tag : tag_table(\"Exif\"))\n            find_tag(tag.tifftag, tag.tifftype, tag.name);\n    }\n\n    // Now we need to get fields \"by hand\" for anything else that is less\n    // straightforward...\n\n    m_compression = 0;\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_COMPRESSION, &m_compression);\n    m_spec.attribute(\"tiff:Compression\", (int)m_compression);\n\n    m_photometric = (m_spec.nchannels == 1 ? PHOTOMETRIC_MINISBLACK\n                                           : PHOTOMETRIC_RGB);\n    TIFFGetField(m_tif, TIFFTAG_PHOTOMETRIC, &m_photometric);\n    m_spec.attribute(\"tiff:PhotometricInterpretation\", (int)m_photometric);\n\n    readspec_photometric();\n\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_PLANARCONFIG, &m_planarconfig);\n    m_separate = (m_planarconfig == PLANARCONFIG_SEPARATE\n                  && m_spec.nchannels > 1\n                  && m_photometric != PHOTOMETRIC_PALETTE);\n    m_spec.attribute(\"tiff:PlanarConfiguration\", (int)m_planarconfig);\n    if (m_planarconfig == PLANARCONFIG_SEPARATE)\n        m_spec.attribute(\"planarconfig\", \"separate\");\n    else\n        m_spec.attribute(\"planarconfig\", \"contig\");\n\n    if (const char* compressname = tiff_compression_name(m_compression))\n        m_spec.attribute(\"compression\", compressname);\n    m_predictor = PREDICTOR_NONE;\n    if (!safe_tiffgetfield(\"Predictor\", TIFFTAG_PREDICTOR, TypeUInt16,\n                           &m_predictor))\n        m_predictor = PREDICTOR_NONE;\n\n    m_rowsperstrip = -1;\n    if (!m_spec.tile_width) {\n        TIFFGetField(m_tif, TIFFTAG_ROWSPERSTRIP, &m_rowsperstrip);\n        if (m_rowsperstrip > 0)\n            m_spec.attribute(\"tiff:RowsPerStrip\", m_rowsperstrip);\n    }\n\n    // The libtiff docs say that only uncompressed images, or those with\n    // rowsperstrip==1, support random access to scanlines.\n    m_no_random_access = (m_compression != COMPRESSION_NONE\n                          && m_rowsperstrip != 1);\n\n    // Do we care about fillorder?  No, the TIFF spec says, \"We\n    // recommend that FillOrder=2 (lsb-to-msb) be used only in\n    // special-purpose applications\".  So OIIO will assume msb-to-lsb\n    // convention until somebody finds a TIFF file in the wild that\n    // breaks this assumption.\n\n    unsigned short* sampleinfo  = NULL;\n    unsigned short extrasamples = 0;\n    TIFFGetField(m_tif, TIFFTAG_EXTRASAMPLES, &extrasamples, &sampleinfo);\n    // std::cerr << \"Extra samples = \" << extrasamples << \"\\n\";\n    bool alpha_is_unassociated = false;  // basic assumption\n    if (extrasamples) {\n        // If the TIFF ExtraSamples tag was specified, use that to figure\n        // out the meaning of alpha.\n        int colorchannels = 3;\n        if (m_photometric == PHOTOMETRIC_MINISWHITE\n            || m_photometric == PHOTOMETRIC_MINISBLACK\n            || m_photometric == PHOTOMETRIC_PALETTE\n            || m_photometric == PHOTOMETRIC_MASK)\n            colorchannels = 1;\n        for (int i = 0, c = colorchannels;\n             i < extrasamples && c < m_inputchannels; ++i, ++c) {\n            // std::cerr << \"   extra \" << i << \" \" << sampleinfo[i] << \"\\n\";\n            if (sampleinfo[i] == EXTRASAMPLE_ASSOCALPHA) {\n                // This is the alpha channel, associated as usual\n                m_spec.alpha_channel = c;\n            } else if (sampleinfo[i] == EXTRASAMPLE_UNASSALPHA) {\n                // This is the alpha channel, but color is unassociated\n                m_spec.alpha_channel  = c;\n                alpha_is_unassociated = true;\n                if (m_keep_unassociated_alpha)\n                    m_spec.attribute(\"oiio:UnassociatedAlpha\", 1);\n            } else {\n                OIIO_DASSERT(sampleinfo[i] == EXTRASAMPLE_UNSPECIFIED);\n                // This extra channel is not alpha at all.  Undo any\n                // assumptions we previously made about this channel.\n                if (m_spec.alpha_channel == c) {\n                    m_spec.channelnames[c] = Strutil::fmt::format(\"channel{}\",\n                                                                  c);\n                    m_spec.alpha_channel   = -1;\n                }\n            }\n        }\n        if (m_photometric == PHOTOMETRIC_SEPARATED)\n            m_spec.alpha_channel = -1;  // ignore alpha in CMYK\n        if (m_spec.alpha_channel >= 0\n            && m_spec.alpha_channel < m_spec.nchannels) {\n            while (m_spec.channelnames.size() < size_t(m_spec.nchannels))\n                m_spec.channelnames.push_back(\n                    Strutil::fmt::format(\"channel{}\", m_spec.nchannels));\n            m_spec.channelnames[m_spec.alpha_channel] = \"A\";\n            // Special case: \"R\",\"A\" should really be named \"Y\",\"A\", since\n            // the first channel is luminance, not red.\n            if (m_spec.nchannels == 2 && m_spec.alpha_channel == 1)\n                m_spec.channelnames[0] = \"Y\";\n        }\n    }\n    if (alpha_is_unassociated)\n        m_spec.attribute(\"tiff:UnassociatedAlpha\", 1);\n    // Will we need to do alpha conversions?\n    m_convert_alpha = (m_spec.alpha_channel >= 0 && alpha_is_unassociated\n                       && !m_keep_unassociated_alpha);\n\n    // N.B. we currently ignore the following TIFF fields:\n    // GrayResponseCurve GrayResponseUnit\n    // MaxSampleValue MinSampleValue\n    // NewSubfileType SubfileType(deprecated)\n    // Colorimetry fields\n\n    // If we've been instructed to skip reading metadata, because it is\n    // assumed to be identical to what we already have in m_spec,\n    // skip everything following.\n    if (!read_meta)\n        return true;\n\n    short resunit = -1;\n    TIFFGetField(m_tif, TIFFTAG_RESOLUTIONUNIT, &resunit);\n    switch (resunit) {\n    case RESUNIT_NONE: m_spec.attribute(\"ResolutionUnit\", \"none\"); break;\n    case RESUNIT_INCH: m_spec.attribute(\"ResolutionUnit\", \"in\"); break;\n    case RESUNIT_CENTIMETER: m_spec.attribute(\"ResolutionUnit\", \"cm\"); break;\n    }\n    float xdensity = m_spec.get_float_attribute(\"XResolution\", 0.0f);\n    float ydensity = m_spec.get_float_attribute(\"YResolution\", 0.0f);\n    if (xdensity && ydensity)\n        m_spec.attribute(\"PixelAspectRatio\", ydensity / xdensity);\n\n    get_matrix_attribute(\"worldtocamera\", TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA);\n    get_matrix_attribute(\"worldtoscreen\", TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN);\n    get_int_attribute(\"tiff:subfiletype\", TIFFTAG_SUBFILETYPE);\n    // FIXME -- should subfiletype be \"conventionized\" and used for all\n    // plugins uniformly?\n\n    // Special names for shadow maps\n    char* s = NULL;\n    TIFFGetField(m_tif, TIFFTAG_PIXAR_TEXTUREFORMAT, &s);\n    if (s)\n        m_emulate_mipmap = true;\n    if (s && !strcmp(s, \"Shadow\")) {\n        for (int c = 0; c < m_spec.nchannels; ++c)\n            m_spec.channelnames[c] = \"z\";\n    }\n\n    /// read color profile\n    unsigned int icc_datasize = 0;\n    uint8_t* icc_buf          = NULL;\n    TIFFGetField(m_tif, TIFFTAG_ICCPROFILE, &icc_datasize, &icc_buf);\n    if (icc_datasize && icc_buf) {\n        m_spec.attribute(ICC_PROFILE_ATTR,\n                         TypeDesc(TypeDesc::UINT8, icc_datasize), icc_buf);\n        std::string errormsg;\n        bool ok = decode_icc_profile(cspan<uint8_t>(icc_buf, icc_datasize),\n                                     m_spec, errormsg);\n        if (!ok && OIIO::get_int_attribute(\"imageinput:strict\")) {\n            errorfmt(\"Possible corrupt file, could not decode ICC profile: {}\\n\",\n                     errormsg);\n            return false;\n        }\n    }\n\n    // Search for an EXIF IFD in the TIFF file, and if found, rummage\n    // around for Exif fields.\n    toff_t exifoffset = 0;\n    if (TIFFGetField(m_tif, TIFFTAG_EXIFIFD, &exifoffset)) {\n        if (TIFFReadEXIFDirectory(m_tif, exifoffset)) {\n            for (const auto& tag : tag_table(\"Exif\"))\n                find_tag(tag.tifftag, tag.tifftype, tag.name);\n            // Look for a Makernote\n            auto makerfield = find_field(EXIF_MAKERNOTE, TIFF_UNDEFINED);\n            // std::unique_ptr<uint32_t[]> buf (new uint32_t[]);\n            if (makerfield) {\n                // bool ok = TIFFGetField (m_tif, tag, dest, &ptr);\n                unsigned int mn_datasize = 0;\n                unsigned char* mn_buf    = NULL;\n                TIFFGetField(m_tif, EXIF_MAKERNOTE, &mn_datasize, &mn_buf);\n            }\n            // Exif spec says that anything other than 0xffff==uncalibrated\n            // should be interpreted to be sRGB.\n            if (m_spec.get_int_attribute(\"Exif:ColorSpace\") != 0xffff)\n                m_spec.attribute(\"oiio:ColorSpace\", \"sRGB\");\n            // NOTE: We must set \"oiio:ColorSpace\" explicitly, not call\n            // set_colorspace, or it will erase several other TIFF attribs we\n            // need to preserve.\n        }\n        // TIFFReadEXIFDirectory seems to do something to the internal state\n        // that requires a TIFFSetDirectory to set things straight again.\n        TIFFSetDirectory(m_tif, m_subimage);\n    }\n\n    // Search for IPTC metadata in IIM form -- but older versions of\n    // libtiff botch the size, so ignore it for very old libtiff.\n    int iptcsize         = 0;\n    const char* iptcdata = nullptr;\n    TypeDesc iptctype    = tiffgetfieldtype(TIFFTAG_RICHTIFFIPTC);\n    if (TIFFGetField(m_tif, TIFFTAG_RICHTIFFIPTC, &iptcsize, &iptcdata)\n        && iptcsize > 0) {\n        std::vector<char> iptc;\n        if (iptctype.size() == 4) {\n            // Some TIFF files in the wild inexplicably think their IPTC\n            // data are stored as longs, and we have to undo any byte\n            // swapping that may have occurred.\n            iptcsize *= 4;\n            iptc.assign(iptcdata, iptcdata + iptcsize);\n            if (TIFFIsByteSwapped(m_tif))\n                TIFFSwabArrayOfLong((uint32_t*)&iptc[0], iptcsize / 4);\n        } else {\n            iptc.assign(iptcdata, iptcdata + iptcsize);\n        }\n        decode_iptc_iim(&iptc[0], iptcsize, m_spec);\n    }\n\n    // Search for an XML packet containing XMP (IPTC, Exif, etc.)\n    int xmlsize         = 0;\n    const void* xmldata = NULL;\n    if (TIFFGetField(m_tif, TIFFTAG_XMLPACKET, &xmlsize, &xmldata)) {\n        // std::cerr << \"Found XML data, size \" << xmlsize << \"\\n\";\n        if (xmldata && xmlsize) {\n            std::string xml((const char*)xmldata, xmlsize);\n            decode_xmp(xml, m_spec);\n        }\n    }\n\n#if 0\n    // Experimental -- look for photoshop data\n    int photoshopsize = 0;\n    const void *photoshopdata = NULL;\n    if (TIFFGetField (m_tif, TIFFTAG_PHOTOSHOP, &photoshopsize, &photoshopdata)) {\n        std::cerr << \"Found PHOTOSHOP data, size \" << photoshopsize << \"\\n\";\n        if (photoshopdata && photoshopsize) {\n//            std::string photoshop ((const char *)photoshopdata, photoshopsize);\n//            std::cerr << \"PHOTOSHOP:\\n\" << photoshop << \"\\n---\\n\";\n        }\n    }\n#endif\n\n    // If Software and IPTC:OriginatingProgram are identical, kill the latter\n    if (m_spec.get_string_attribute(\"Software\")\n        == m_spec.get_string_attribute(\"IPTC:OriginatingProgram\"))\n        m_spec.erase_attribute(\"IPTC:OriginatingProgram\");\n\n    std::string desc = m_spec.get_string_attribute(\"ImageDescription\");\n    // If ImageDescription and IPTC:Caption are identical, kill the latter\n    if (desc == m_spec.get_string_attribute(\"IPTC:Caption\"))\n        m_spec.erase_attribute(\"IPTC:Caption\");\n\n    // Because TIFF doesn't support arbitrary metadata, we look for certain\n    // hints in the ImageDescription and turn them into metadata, also\n    // removing them from the ImageDescrption.\n    bool updatedDesc = false;\n    auto cc = Strutil::excise_string_after_head(desc, \"oiio:ConstantColor=\");\n    if (cc.size()) {\n        m_spec.attribute(\"oiio:ConstantColor\", cc);\n        updatedDesc = true;\n    }\n    auto ac = Strutil::excise_string_after_head(desc, \"oiio:AverageColor=\");\n    if (ac.size()) {\n        m_spec.attribute(\"oiio:AverageColor\", ac);\n        updatedDesc = true;\n    }\n    std::string sha = Strutil::excise_string_after_head(desc, \"oiio:SHA-1=\");\n    if (sha.empty())  // back compatibility with OIIO < 1.5\n        sha = Strutil::excise_string_after_head(desc, \"SHA-1=\");\n    if (sha.size()) {\n        m_spec.attribute(\"oiio:SHA-1\", sha);\n        updatedDesc = true;\n    }\n    std::string handed = Strutil::excise_string_after_head(desc,\n                                                           \"oiio:handed=\");\n    if (handed.size() && (handed == \"left\" || handed == \"right\")) {\n        m_spec.attribute(\"handed\", handed);\n        updatedDesc = true;\n    }\n\n    if (updatedDesc) {\n        string_view d(desc);\n        Strutil::skip_whitespace(d);  // erase if it's only whitespace\n        if (d.size())\n            m_spec.attribute(\"ImageDescription\", desc);\n        else\n            m_spec.erase_attribute(\"ImageDescription\");\n    }\n\n    // Squash some problematic texture metadata if we suspect it's wrong\n    pvt::check_texture_metadata_sanity(m_spec);\n\n    if (m_testopenconfig)  // open-with-config debugging\n        m_spec.attribute(\"oiio:DebugOpenConfig!\", 42);\n\n    return true;\n}",
    "void\nTIFFInput::readspec_photometric()\n{\n    switch (m_photometric) {\n    case PHOTOMETRIC_SEPARATED: {\n        // Photometric \"separated\" is \"usually CMYK\".\n        m_spec.channelnames.clear();\n        short inkset       = INKSET_CMYK;\n        short numberofinks = 0;\n        TIFFGetFieldDefaulted(m_tif, TIFFTAG_INKSET, &inkset);\n        TIFFGetFieldDefaulted(m_tif, TIFFTAG_NUMBEROFINKS, &numberofinks);\n        if (inkset == INKSET_CMYK && m_spec.nchannels == 4) {\n            // True CMYK\n            m_spec.attribute(\"tiff:ColorSpace\", \"CMYK\");\n            if (m_raw_color) {\n                m_spec.channelnames.resize(4);\n                m_spec.channelnames[0] = \"C\";\n                m_spec.channelnames[1] = \"M\";\n                m_spec.channelnames[2] = \"Y\";\n                m_spec.channelnames[3] = \"K\";\n                m_spec.attribute(\"oiio:ColorSpace\", \"CMYK\");\n            } else {\n                // Silently convert to RGB\n                m_spec.nchannels = 3;\n                m_spec.default_channel_names();\n            }\n        } else {\n            // Non-CMYK ink set\n            m_spec.attribute(\"tiff:ColorSpace\", \"color separated\");\n            m_spec.attribute(\"oiio:ColorSpace\", \"color separated\");\n            m_raw_color = true;  // Conversion to RGB doesn't make sense\n            const char* inknames = NULL;\n            if (safe_tiffgetfield(\"tiff:InkNames\", TIFFTAG_INKNAMES,\n                                  TypeUnknown, &inknames)\n                && inknames && inknames[0] && numberofinks) {\n                m_spec.channelnames.clear();\n                // Decode the ink names, which are all concatenated together.\n                for (int i = 0; i < int(numberofinks); ++i) {\n                    string_view ink(inknames);\n                    if (ink.size()) {\n                        m_spec.channelnames.emplace_back(ink);\n                        inknames += ink.size() + 1;\n                    } else {\n                        // Run out of road\n                        numberofinks = i;\n                    }\n                }\n            } else {\n                numberofinks = 0;\n            }\n            // No ink names. Make it up.\n            for (int i = numberofinks; i < m_spec.nchannels; ++i)\n                m_spec.channelnames.emplace_back(\n                    Strutil::fmt::format(\"ink{}\", i));\n        }\n        break;\n    }\n    case PHOTOMETRIC_YCBCR: m_spec.attribute(\"tiff:ColorSpace\", \"YCbCr\"); break;\n    case PHOTOMETRIC_CIELAB:\n        m_spec.attribute(\"tiff:ColorSpace\", \"CIELAB\");\n        break;\n    case PHOTOMETRIC_ICCLAB:\n        m_spec.attribute(\"tiff:ColorSpace\", \"ICCLAB\");\n        break;\n    case PHOTOMETRIC_ITULAB:\n        m_spec.attribute(\"tiff:ColorSpace\", \"ITULAB\");\n        break;\n    case PHOTOMETRIC_LOGL: m_spec.attribute(\"tiff:ColorSpace\", \"LOGL\"); break;\n    case PHOTOMETRIC_LOGLUV:\n        m_spec.attribute(\"tiff:ColorSpace\", \"LOGLUV\");\n        break;\n    case PHOTOMETRIC_PALETTE: {\n        m_spec.attribute(\"tiff:ColorSpace\", \"palette\");\n        // Read the color map\n        unsigned short *r = NULL, *g = NULL, *b = NULL;\n        TIFFGetField(m_tif, TIFFTAG_COLORMAP, &r, &g, &b);\n        OIIO_ASSERT(r != NULL && g != NULL && b != NULL);\n        m_colormap.clear();\n        m_colormap.reserve(3 * (1 << m_bitspersample));\n        m_colormap.insert(m_colormap.end(), r, r + (1 << m_bitspersample));\n        m_colormap.insert(m_colormap.end(), g, g + (1 << m_bitspersample));\n        m_colormap.insert(m_colormap.end(), b, b + (1 << m_bitspersample));\n        // Palette TIFF images are always 3 channels, uint8 (to the client)\n        m_spec.nchannels = 3;\n        m_spec.set_format(TypeUInt8);\n        m_spec.default_channel_names();\n        if (m_bitspersample < m_spec.format.size() * 8) {\n            // For palette images with unusual bits per sample, set\n            // oiio:BitsPerSample to the \"full\" version, to avoid problems\n            // when copying the file back to a TIFF file (we don't write\n            // palette images), but do leave \"tiff:BitsPerSample\" to reflect\n            // the original file.\n            m_spec.attribute(\"tiff:BitsPerSample\", (int)m_bitspersample);\n            m_spec.attribute(\"oiio:BitsPerSample\",\n                             (int)m_spec.format.size() * 8);\n        }\n        // FIXME - what about palette + extra (alpha?) channels?  Is that\n        // allowed?  And if so, ever encountered in the wild?\n        break;\n    }\n    }\n\n    // For some PhotometricInterpretation modes that are both rare and hairy\n    // to handle, we use libtiff's TIFFRGBA interface and have it give us 8\n    // bit RGB values.\n    bool is_jpeg         = (m_compression == COMPRESSION_JPEG\n                    || m_compression == COMPRESSION_OJPEG);\n    bool is_nonspectral  = (m_photometric == PHOTOMETRIC_YCBCR\n                           || m_photometric == PHOTOMETRIC_CIELAB\n                           || m_photometric == PHOTOMETRIC_ICCLAB\n                           || m_photometric == PHOTOMETRIC_ITULAB\n                           || m_photometric == PHOTOMETRIC_LOGL\n                           || m_photometric == PHOTOMETRIC_LOGLUV);\n    m_use_rgba_interface = false;\n    m_rgbadata.clear();\n    if ((is_jpeg && m_spec.nchannels != 3)\n        || (is_nonspectral && !m_raw_color)) {\n        m_use_rgba_interface = true;\n        // This falls back to looking like uint8 images\n        m_spec.format = TypeDesc::UINT8;\n        m_spec.channelformats.clear();\n        m_photometric = PHOTOMETRIC_RGB;\n    }\n\n    // If we're not using the RGBA interface, but we have one of these\n    // non-spectral color spaces, set the OIIO color space attribute to\n    // the tiff:colorspace value.\n    if (is_nonspectral && !m_use_rgba_interface) {\n        m_spec.attribute(\"oiio:ColorSpace\",\n                         m_spec.get_string_attribute(\"tiff:ColorSpace\"));\n    }\n}",
    "opj_image_t* tiftoimage(const char *filename, opj_cparameters_t *parameters,\n                        const unsigned int target_bitdepth)\n{\n    int subsampling_dx = parameters->subsampling_dx;\n    int subsampling_dy = parameters->subsampling_dy;\n    TIFF *tif;\n    tdata_t buf;\n    tstrip_t strip;\n    int64_t strip_size, rowStride, TIFF_MAX;\n    int j, currentPlane, numcomps = 0, w, h;\n    OPJ_COLOR_SPACE color_space = OPJ_CLRSPC_UNKNOWN;\n    opj_image_cmptparm_t cmptparm[4]; /* RGBA */\n    opj_image_t *image = NULL;\n    uint16_t tiBps, tiPhoto, tiSf, tiSpp, tiPC;\n    uint32_t tiWidth, tiHeight;\n    OPJ_BOOL is_cinema = OPJ_IS_CINEMA(parameters->rsiz);\n    convert_XXx32s_C1R cvtTifTo32s = NULL;\n    convert_32s_CXPX cvtCxToPx = NULL;\n    OPJ_INT32* buffer32s = NULL;\n    OPJ_INT32* planes[4];\n\n    tif = TIFFOpen(filename, \"r\");\n\n    if (!tif) {\n        fprintf(stderr, \"tiftoimage:Failed to open %s for reading\\n\", filename);\n        return 0;\n    }\n    tiBps = tiPhoto = tiSf = tiSpp = tiPC = 0;\n    tiWidth = tiHeight = 0;\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &tiWidth);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &tiHeight);\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &tiBps);\n    TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &tiSf);\n    TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &tiSpp);\n    TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &tiPhoto);\n    TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &tiPC);\n\n    if (tiSpp == 0 || tiSpp > 4) { /* should be 1 ... 4 */\n        fprintf(stderr, \"tiftoimage: Bad value for samples per pixel == %d.\\n\"\n                \"\\tAborting.\\n\", tiSpp);\n        TIFFClose(tif);\n        return NULL;\n    }\n    if (tiBps > 16U || tiBps == 0) {\n        fprintf(stderr, \"tiftoimage: Bad values for Bits == %d.\\n\"\n                \"\\tMax. 16 Bits are allowed here.\\n\\tAborting.\\n\", tiBps);\n        TIFFClose(tif);\n        return NULL;\n    }\n    if (tiPhoto != PHOTOMETRIC_MINISBLACK && tiPhoto != PHOTOMETRIC_RGB) {\n        fprintf(stderr,\n                \"tiftoimage: Bad color format %d.\\n\\tOnly RGB(A) and GRAY(A) has been implemented\\n\\tAborting.\\n\",\n                (int) tiPhoto);\n        TIFFClose(tif);\n        return NULL;\n    }\n    if (tiWidth == 0 || tiHeight == 0) {\n        fprintf(stderr, \"tiftoimage: Bad values for width(%u) \"\n                \"and/or height(%u)\\n\\tAborting.\\n\", tiWidth, tiHeight);\n        TIFFClose(tif);\n        return NULL;\n    }\n    w = (int)tiWidth;\n    h = (int)tiHeight;\n\n    switch (tiBps) {\n    case 1:\n    case 2:\n    case 4:\n    case 6:\n    case 8:\n        cvtTifTo32s = convert_XXu32s_C1R_LUT[tiBps];\n        break;\n    /* others are specific to TIFF */\n    case 3:\n        cvtTifTo32s = tif_3uto32s;\n        break;\n    case 5:\n        cvtTifTo32s = tif_5uto32s;\n        break;\n    case 7:\n        cvtTifTo32s = tif_7uto32s;\n        break;\n    case 9:\n        cvtTifTo32s = tif_9uto32s;\n        break;\n    case 10:\n        cvtTifTo32s = tif_10uto32s;\n        break;\n    case 11:\n        cvtTifTo32s = tif_11uto32s;\n        break;\n    case 12:\n        cvtTifTo32s = tif_12uto32s;\n        break;\n    case 13:\n        cvtTifTo32s = tif_13uto32s;\n        break;\n    case 14:\n        cvtTifTo32s = tif_14uto32s;\n        break;\n    case 15:\n        cvtTifTo32s = tif_15uto32s;\n        break;\n    case 16:\n        cvtTifTo32s = (convert_XXx32s_C1R)tif_16uto32s;\n        break;\n    default:\n        /* never here */\n        break;\n    }\n\n    /* initialize image components */\n    memset(&cmptparm[0], 0, 4 * sizeof(opj_image_cmptparm_t));\n\n    if ((tiPhoto == PHOTOMETRIC_RGB) && (is_cinema) && (tiBps != 12U)) {\n        fprintf(stdout, \"WARNING:\\n\"\n                \"Input image bitdepth is %d bits\\n\"\n                \"TIF conversion has automatically rescaled to 12-bits\\n\"\n                \"to comply with cinema profiles.\\n\",\n                tiBps);\n    } else {\n        is_cinema = 0U;\n    }\n\n    numcomps = tiSpp;\n    if (tiPhoto == PHOTOMETRIC_RGB) { /* RGB(A) */\n        color_space = OPJ_CLRSPC_SRGB;\n    } else if (tiPhoto == PHOTOMETRIC_MINISBLACK) { /* GRAY(A) */\n        color_space = OPJ_CLRSPC_GRAY;\n    }\n\n    cvtCxToPx = convert_32s_CXPX_LUT[numcomps];\n    if (tiPC == PLANARCONFIG_SEPARATE) {\n        cvtCxToPx = convert_32s_CXPX_LUT[1]; /* override */\n        tiSpp = 1U; /* consider only one sample per plane */\n    }\n\n    for (j = 0; j < numcomps; j++) {\n        cmptparm[j].prec = tiBps;\n        cmptparm[j].dx = (OPJ_UINT32)subsampling_dx;\n        cmptparm[j].dy = (OPJ_UINT32)subsampling_dy;\n        cmptparm[j].w = (OPJ_UINT32)w;\n        cmptparm[j].h = (OPJ_UINT32)h;\n    }\n\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);\n    if (!image) {\n        TIFFClose(tif);\n        return NULL;\n    }\n    /* set image offset and reference grid */\n    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    image->x1 = !image->x0 ? (OPJ_UINT32)(w - 1) * (OPJ_UINT32)subsampling_dx + 1 :\n                image->x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)subsampling_dx + 1;\n    if (image->x1 <= image->x0) {\n        fprintf(stderr, \"tiftoimage: Bad value for image->x1(%d) vs. \"\n                \"image->x0(%d)\\n\\tAborting.\\n\", image->x1, image->x0);\n        TIFFClose(tif);\n        opj_image_destroy(image);\n        return NULL;\n    }\n    image->y1 = !image->y0 ? (OPJ_UINT32)(h - 1) * (OPJ_UINT32)subsampling_dy + 1 :\n                image->y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)subsampling_dy + 1;\n    if (image->y1 <= image->y0) {\n        fprintf(stderr, \"tiftoimage: Bad value for image->y1(%d) vs. \"\n                \"image->y0(%d)\\n\\tAborting.\\n\", image->y1, image->y0);\n        TIFFClose(tif);\n        opj_image_destroy(image);\n        return NULL;\n    }\n\n    for (j = 0; j < numcomps; j++) {\n        planes[j] = image->comps[j].data;\n    }\n    image->comps[numcomps - 1].alpha = (OPJ_UINT16)(1 - (numcomps & 1));\n\n    strip_size = (int64_t)TIFFStripSize(tif);\n\n    buf = malloc((OPJ_SIZE_T)strip_size);\n    if (buf == NULL) {\n        TIFFClose(tif);\n        opj_image_destroy(image);\n        return NULL;\n    }\n    if (sizeof(tsize_t) == 4) {\n        TIFF_MAX = INT_MAX;\n    } else {\n        TIFF_MAX = UINT_MAX;\n    }\n    if ((int64_t)tiWidth > (int64_t)(TIFF_MAX / tiSpp) ||\n            (int64_t)(tiWidth * tiSpp) > (int64_t)(TIFF_MAX / tiBps) ||\n            (int64_t)(tiWidth * tiSpp) > (int64_t)(TIFF_MAX / (int64_t)sizeof(OPJ_INT32))) {\n        fprintf(stderr, \"Buffer overflow\\n\");\n        _TIFFfree(buf);\n        TIFFClose(tif);\n        opj_image_destroy(image);\n        return NULL;\n    }\n\n    rowStride = (int64_t)((tiWidth * tiSpp * tiBps + 7U) / 8U);\n    buffer32s = (OPJ_INT32 *)malloc(sizeof(OPJ_INT32) * tiWidth * tiSpp);\n    if (buffer32s == NULL) {\n        _TIFFfree(buf);\n        TIFFClose(tif);\n        opj_image_destroy(image);\n        return NULL;\n    }\n\n    strip = 0;\n    currentPlane = 0;\n    do {\n        planes[0] = image->comps[currentPlane].data; /* to manage planar data */\n        h = (int)tiHeight;\n        /* Read the Image components */\n        for (; (h > 0) && (strip < TIFFNumberOfStrips(tif)); strip++) {\n            const OPJ_UINT8 *dat8;\n            int64_t ssize;\n\n            ssize = (int64_t)TIFFReadEncodedStrip(tif, strip, buf, (tsize_t)strip_size);\n\n            if (ssize < 1 || ssize > strip_size) {\n                fprintf(stderr, \"tiftoimage: Bad value for ssize(%\" PRId64 \") \"\n                        \"vs. strip_size(%\" PRId64 \").\\n\\tAborting.\\n\", ssize, strip_size);\n                _TIFFfree(buf);\n                _TIFFfree(buffer32s);\n                TIFFClose(tif);\n                opj_image_destroy(image);\n                return NULL;\n            }\n            dat8 = (const OPJ_UINT8*)buf;\n\n            while (ssize >= rowStride) {\n                cvtTifTo32s(dat8, buffer32s, (OPJ_SIZE_T)w * tiSpp);\n                cvtCxToPx(buffer32s, planes, (OPJ_SIZE_T)w);\n                planes[0] += w;\n                planes[1] += w;\n                planes[2] += w;\n                planes[3] += w;\n                dat8  += rowStride;\n                ssize -= rowStride;\n                h--;\n            }\n        }\n        currentPlane++;\n    } while ((tiPC == PLANARCONFIG_SEPARATE) && (currentPlane < numcomps));\n\n    free(buffer32s);\n    _TIFFfree(buf);\n    TIFFClose(tif);\n\n    if (is_cinema) {\n        for (j = 0; j < numcomps; ++j) {\n            scale_component(&(image->comps[j]), 12);\n        }\n\n    } else if ((target_bitdepth > 0) && (target_bitdepth != tiBps)) {\n        for (j = 0; j < numcomps; ++j) {\n            scale_component(&(image->comps[j]), target_bitdepth);\n        }\n    }\n    return image;\n\n}",
    "Frame ImageTif::decodeImage(const void* buffer, const size_t size)\n{\n\t// currently we limited support for 24bit Windows bitmaps (not OS/2 bitmaps) without compression only\n\n\tocean_assert(buffer != nullptr && size > 0);\n\n\tconst uint8_t* byteBuffer = (const uint8_t*)(buffer);\n\n\tif (size <= 4)\n\t{\n\t\treturn Frame();\n\t}\n\n\t// Magic number little endian: 0x49 0x49 0x2a 0x00\n\t// Magic number big endian:    0x4d 0x4d 0x00 0x2a (e.g., Mac encoding)\n\n\tconst bool hasMagicNumberLittleEndian = byteBuffer[0] == 0x49u && byteBuffer[1] == 0x49u && byteBuffer[2] == 0x2Au && byteBuffer[3] == 0x00u;\n\tconst bool hasMagicNumberBigEndian = byteBuffer[0] == 0x4Du && byteBuffer[1] == 0x4Du && byteBuffer[2] == 0x00u && byteBuffer[3] == 0x2Au;\n\n\tif (!hasMagicNumberLittleEndian && !hasMagicNumberBigEndian)\n\t{\n\t\treturn Frame();\n\t}\n\n\t// first we need to ensure that we have a little endian system\n\n\tInputDataTriple inputDataTriple(byteBuffer, size, 0);\n\n\tusing ScopedTiffObject = ScopedObjectCompileTimeVoidT<TIFF*, &TIFFClose>;\n\n\tTIFF* tiff = TIFFClientOpen(\"tiffmemoryclient\", \"r\", (thandle_t)&inputDataTriple, imageTifReadData_Load, imageTifDataInvalid, imageTifSeekData_Load, imageTifCloseData, imageTifSizeData_Load, imageTifMapData, imageTifUnmapData);\n\n\tif (tiff == nullptr)\n\t{\n\t\treturn Frame();\n\t}\n\n\tconst ScopedTiffObject scopedTiff(tiff);\n\n\tstatic_assert(sizeof(unsigned int) == 4u, \"Invalid data type!\");\n\n\tunsigned int width = 0u;\n\tunsigned int height = 0u;\n\tunsigned int samplesPerPixel = 0u;\n\tif (TIFFGetField(*scopedTiff, TIFFTAG_IMAGEWIDTH, &width) != 1 || TIFFGetField(*scopedTiff, TIFFTAG_IMAGELENGTH, &height) != 1 || TIFFGetField(*scopedTiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel) != 1 || width == 0u || height == 0u || samplesPerPixel == 0u)\n\t{\n\t\treturn Frame();\n\t}\n\n\tunsigned short orientation = (unsigned short)(-1);\n\tif (TIFFGetField(*scopedTiff, TIFFTAG_ORIENTATION, &orientation) != 1 || (orientation != ORIENTATION_TOPLEFT && orientation != ORIENTATION_BOTLEFT))\n\t{\n\t\treturn Frame();\n\t}\n\n\tocean_assert(orientation == ORIENTATION_TOPLEFT || orientation == ORIENTATION_BOTLEFT);\n\tconst FrameType::PixelOrigin pixelOrigin = (orientation == ORIENTATION_TOPLEFT) ? FrameType::ORIGIN_UPPER_LEFT : FrameType::ORIGIN_LOWER_LEFT;\n\n\t// **TODO** hot fix to ensure that images cannot be larger than 2^32 bytes\n\n\tif (uint64_t(width) * uint64_t(height) >= uint64_t(1073741823ull)) // width * height * 4 < 2^32\n\t{\n\t\treturn Frame();\n\t}\n\n\tFrame result(FrameType(width, height, FrameType::FORMAT_RGBA32, pixelOrigin));\n\n\t// currently we keep it quite simple, we request an RGBA frame independent of the acutal data stored\n\t// this can be improved if necessary - however, tiff images seem not to have a high impact\n\n\tocean_assert(result.isContinuous());\n\tif (TIFFReadRGBAImageOriented(*scopedTiff, width, height, result.data<uint32_t>(), orientation, 1) != 1)\n\t{\n\t\treturn Frame();\n\t}\n\n\tswitch (samplesPerPixel)\n\t{\n\t\tcase 1u:\n\t\t\tCV::FrameConverter::Comfort::change(result, FrameType::FORMAT_Y8, true, WorkerPool::get().conditionalScopedWorker(result.pixels() >= 400u * 400u)());\n\t\t\tbreak;\n\n\t\tcase 3u:\n\t\t\tCV::FrameConverter::Comfort::change(result, FrameType::FORMAT_RGB24, true, WorkerPool::get().conditionalScopedWorker(result.pixels() >= 400u * 400u)());\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn result;\n}",
    "std::unique_ptr<ExifTags> ExifTags::Parse(TIFF* tif) {\n  toff_t exif_offset;\n  if (!TIFFGetField(tif, TIFFTAG_EXIFIFD, &exif_offset)) {\n    // Image doesn't contain EXIF data.\n    return nullptr;\n  }\n\n  if (!seekTIFF(tif, exif_offset, SEEK_SET)) {\n    return nullptr;\n  }\n\n  uint16_t count;\n  if (!readTIFFUint16(tif, &count)) {\n    return nullptr;\n  }\n\n  if (count == 0) {\n    return nullptr;\n  }\n\n  std::unique_ptr<ExifTags> tags(new ExifTags(count));\n  for (uint16_t i = 0; i < count; i++) {\n    std::unique_ptr<Tag> tag(new Tag());\n    if (!readTIFFUint16(tif, &tag->tag)) {\n      return nullptr;\n    }\n\n    if (!readTIFFUint16(tif, &tag->type) || tag->type > TIFF_IFD8) {\n      return nullptr;\n    }\n\n    if (TIFFDataWidth(static_cast<TIFFDataType>(tag->type)) == 0) {\n      return nullptr;\n    }\n\n    if (!readTIFFUint32(tif, &tag->len)) {\n      return nullptr;\n    }\n\n    if (!readTIFFUint32(tif, &tag->offset)) {\n      return nullptr;\n    }\n\n    tags->tags_.push_back(std::move(tag));\n  }\n\n  for (const auto& tag : tags->tags_) {\n    size_t size = tag->len * TIFFDataWidth(static_cast<TIFFDataType>(tag->type));\n    if (size <= 4) {\n      continue;\n    }\n\n    if (!seekTIFF(tif, tag->offset, SEEK_SET)) {\n      return nullptr;\n    }\n\n    tag->data.resize(size);\n    if (!readTIFF(tif, tag->data.data(), size)) {\n      return nullptr;\n    }\n  }\n\n  return tags;\n}",
    "heif_error getImageWidthAndHeight(TIFF *tif, uint32_t &width, uint32_t &height)\n{\n  if (!TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width) ||\n      !TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height))\n  {\n    struct heif_error err = {\n      .code = heif_error_Invalid_input,\n      .subcode = heif_suberror_Unspecified,\n      .message = \"Can not read width and/or height from TIFF image.\"};\n    return err;\n  }\n  return heif_error_ok;\n}",
    "heif_error loadTIFF(const char* filename, InputImage *input_image) {\n  TIFFSetWarningHandler(suppress_warnings);\n\n  std::unique_ptr<TIFF, void(*)(TIFF*)> tifPtr(TIFFOpen(filename, \"r\"), [](TIFF* tif) { TIFFClose(tif); });\n  if (!tifPtr) {\n    struct heif_error err = {\n      .code = heif_error_Invalid_input,\n      .subcode = heif_suberror_Unspecified,\n      .message = \"Cannot open TIFF ile\"};\n    return err;\n  }\n\n  TIFF* tif = tifPtr.get();\n  if (TIFFIsTiled(tif)) {\n    struct heif_error err = {\n      .code = heif_error_Unsupported_feature,\n      .subcode = heif_suberror_Unspecified,\n      .message = \"Tiled TIFF images are not supported yet\"};\n    return err;\n  }\n\n  uint16_t shortv, samplesPerPixel, bps, config, format;\n  if (TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &shortv) && shortv == PHOTOMETRIC_PALETTE) {\n    struct heif_error err = {\n      .code = heif_error_Unsupported_feature,\n      .subcode = heif_suberror_Unspecified,\n      .message = \"Palette TIFF images are not supported yet\"};\n    return err;\n  }\n\n  TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n  TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);\n  if (samplesPerPixel != 1 && samplesPerPixel != 3 && samplesPerPixel != 4) {\n    struct heif_error err = {\n      .code = heif_error_Invalid_input,\n      .subcode = heif_suberror_Unspecified,\n      .message = \"Only 1, 3 and 4 samples per pixel are supported.\"};\n    return err;\n  }\n\n  TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n  if (bps != 8) {    \n    struct heif_error err = {\n      .code = heif_error_Invalid_input,\n      .subcode = heif_suberror_Unspecified,\n      .message = \"Only 8 bits per sample are supported.\"};\n    return err;\n  }\n\n  if (TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &format) && format != SAMPLEFORMAT_UINT) {\n    struct heif_error err = {\n      .code = heif_error_Invalid_input,\n      .subcode = heif_suberror_Unspecified,\n      .message = \"Only UINT sample format is supported.\"};\n    return err;\n  }\n\n  struct heif_error err;\n  struct heif_image* image = nullptr;\n\n  switch (config) {\n    case PLANARCONFIG_CONTIG:\n      err = readPixelInterleave(tif, samplesPerPixel, &image);\n      break;\n    case PLANARCONFIG_SEPARATE:\n      err = readBandInterleave(tif, samplesPerPixel, &image);\n      break;\n    default:\n      struct heif_error err = {\n        .code = heif_error_Invalid_input,\n        .subcode = heif_suberror_Unspecified,\n        .message = \"Unsupported planar configuration\"};\n      return err;\n  }\n  if (err.code != heif_error_Ok) {\n    return err;\n  }\n\n  input_image->image = std::shared_ptr<heif_image>(image,\n                                          [](heif_image* img) { heif_image_release(img); });\n\n  // Unfortunately libtiff doesn't provide a way to read a raw dictionary.\n  // Therefore we manually parse the EXIF data, extract the tags and encode\n  // them for use in the HEIF image.\n  std::unique_ptr<ExifTags> tags = ExifTags::Parse(tif);\n  if (tags) {\n    tags->Encode(&(input_image->exif));\n  }\n  return heif_error_ok;\n}",
    "void load_tiff(Image &img, std::string file)\n    {\n        if (!std::filesystem::exists(file))\n            return;\n\n        TIFF *tif = TIFFOpen(file.c_str(), \"r\");\n        if (tif)\n        {\n            uint32_t w, h;\n            int16_t bit_depth, channels_number;\n\n            TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n            TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n            TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels_number);\n            TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bit_depth);\n\n            proj::projection_t pro;\n            if (geotiff::try_read_geotiff(&pro, tif))\n            {\n                nlohmann::json meta;\n                meta[\"proj_cfg\"] = pro;\n                set_metadata(img, meta);\n            }\n\n            if (bit_depth != 8 && bit_depth != 16)\n            {\n                logger->error(\"Unsupported TIFF bit depth %d\", bit_depth);\n                return;\n            }\n\n            img.init(bit_depth, w, h, channels_number);\n\n            int d_channels = channels_number;\n            size_t d_width = w;\n            size_t d_height = h;\n            int d_depth = bit_depth;\n\n            tsize_t linebytes = d_channels * d_width * (bit_depth == 16 ? sizeof(uint16_t) : sizeof(uint8_t));\n            unsigned char *buf = NULL;\n            if (TIFFScanlineSize(tif) == linebytes)\n                buf = (unsigned char *)_TIFFmalloc(linebytes);\n            else\n                buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n\n            for (size_t y = 0; y < d_height; y++)\n            {\n                TIFFReadScanline(tif, buf, y, 0);\n\n                if (d_depth == 16)\n                {\n                    for (size_t x = 0; x < d_width; x++)\n                        for (int i = 0; i < d_channels; i++)\n                            img.set(i, y * d_width + x, ((uint16_t *)buf)[x * channels_number + i]);\n                }\n                else if (d_depth == 8)\n                {\n                    for (size_t x = 0; x < d_width; x++)\n                    {\n                        for (int i = 0; i < d_channels; i++)\n                            img.set(i, y * d_width + x, ((uint8_t *)buf)[x * channels_number + i]);\n                    }\n                }\n            }\n\n            _TIFFfree(buf);\n\n            TIFFClose(tif);\n        }\n\n        printf(\"Done Loading TIFF\\n\");\n    }",
    "bool try_read_geotiff(proj::projection_t *proj, TIFF *tif)\n    {\n        bool has_tiepoint = false, has_pixelscale = false, has_geokeys = false;\n        *proj = proj::projection_t();\n\n        bool debug = true;\n\n        uint32_t geokeys_c;\n        uint16_t *geokeys;\n        if (TIFFGetField(tif, GEOTIFFTAG_GeoKeyDirectoryTag, &geokeys_c, &geokeys))\n        { // Attempt to parse the rest\n            if (debug)\n                printf(\"GeoTIFF Tags :\\n\");\n\n            // First, check if we have a reference point\n            uint32_t tiepoints_c;\n            double *tiepoints;\n            if (TIFFGetField(tif, GEOTIFFTAG_ModelTiepointTag, &tiepoints_c, &tiepoints))\n            {\n                if (tiepoints_c >= 6)\n                {\n                    proj->proj_offset_x = tiepoints[3];\n                    proj->proj_offset_y = tiepoints[4];\n                    has_tiepoint = true;\n                }\n\n                if (debug)\n                {\n                    printf(\" - ModelTiepointTag : \");\n                    for (uint32_t i = 0; i < tiepoints_c; i++)\n                        printf(\"%f, \", tiepoints[i]);\n                    printf(\"\\n\");\n                }\n            }\n\n            // Secondly, check if have a pixel scale\n            // First, check if we have a reference point\n            uint32_t pixelscale_c;\n            double *pixelscale;\n            if (TIFFGetField(tif, GEOTIFFTAG_ModelPixelScaleTag, &pixelscale_c, &pixelscale))\n            {\n                if (pixelscale_c >= 2)\n                {\n                    proj->proj_scalar_x = pixelscale[0];\n                    proj->proj_scalar_y = -pixelscale[1];\n                    has_pixelscale = true;\n                }\n\n                if (debug)\n                {\n                    printf(\" - ModelPixelScaleTag : \");\n                    for (uint32_t i = 0; i < pixelscale_c; i++)\n                        printf(\"%f, \", pixelscale[i]);\n                    printf(\"\\n\");\n                }\n            }\n\n            // Finally, we need to parse the GeoKeys\n            if (geokeys_c >= 4)\n            {\n                if (debug)\n                {\n                    printf(\" - GeoKeyDirectoryTag :\\n\");\n                    printf(\" --- KeyDirectoryVersion : %d\\n\", geokeys[0]);\n                    printf(\" --- KeyRevision : %d\\n\", geokeys[1]);\n                    printf(\" --- MinorRevision : %d\\n\", geokeys[2]);\n                    printf(\" --- NumberOfKeys : %d\\n\", geokeys[3]);\n                }\n\n                for (uint16_t i = 0; i < geokeys[3]; i++)\n                { // We assume KeyIDs are in order!\n                    int KeyID = geokeys[4 + i * 4 + 0];\n                    int TIFFTagLocation = geokeys[4 + i * 4 + 1];\n                    // int Count = geokeys[4 + i * 4 + 2];\n                    int Value_Offset = geokeys[4 + i * 4 + 3];\n\n                    if (TIFFTagLocation == 0)\n                    { // These are directly in Value_Offset\n                        if (KeyID == GTModelTypeGeoKey)\n                        { // Model Type\n                            if (Value_Offset == ModelTypeGeographic)\n                                proj->type = proj::ProjType_Equirectangular;\n\n                            if (debug)\n                            {\n                                const char *GTModelTypeGeoKey_v[] = {\"Unknown\", \"ModelTypeProjected\", \"ModelTypeGeographic\", \"ModelTypeGeocentric\"};\n                                printf(\" --- [GTModelTypeGeoKey] : %s\\n\", GTModelTypeGeoKey_v[Value_Offset]);\n                            }\n                        }\n                        else if (KeyID == GeogAngularUnitsGeoKey)\n                        { // Units. Mainly to switch between degs/rads in equirectangular\n                            if (proj->type == proj::ProjType_Equirectangular)\n                            {\n                                if (Value_Offset == Angular_Radian) // Radians, all good\n                                {\n                                    if (has_pixelscale && has_tiepoint)\n                                    {\n                                        proj->proj_offset_x *= RAD2DEG;\n                                        proj->proj_offset_y *= RAD2DEG;\n                                        proj->proj_scalar_x *= RAD2DEG;\n                                        proj->proj_scalar_y *= RAD2DEG;\n                                    }\n                                    if (debug)\n                                        printf(\" --- [GeogAngularUnitsGeoKey] : Radians\\n\");\n                                }\n                                else if (Value_Offset == Angular_Degree)\n                                {\n                                    if (debug)\n                                        printf(\" --- [GeogAngularUnitsGeoKey] : Degrees\\n\");\n                                }\n                                else\n                                {\n                                    if (debug)\n                                        printf(\" --- [GeogAngularUnitsGeoKey] : Unsupported!\\n\");\n                                }\n                            }\n                        }\n                        else if (KeyID == ProjectedCSTypeGeoKey)\n                        { // Projected Model Type. Used to cover UTM and such\n                            if (Value_Offset >= PCS_WGS84_UTM_zone_1N && Value_Offset <= PCS_WGS84_UTM_zone_60N)\n                            {\n                                proj->type = proj::ProjType_UniversalTransverseMercator;\n                                proj->params.zone = Value_Offset - PCS_WGS84_UTM_zone_1N + 1;\n                                proj->params.south = false;\n                            }\n                            else if (Value_Offset >= PCS_WGS84_UTM_zone_1S && Value_Offset <= PCS_WGS84_UTM_zone_60S)\n                            {\n                                proj->type = proj::ProjType_UniversalTransverseMercator;\n                                proj->params.zone = Value_Offset - PCS_WGS84_UTM_zone_1S + 1;\n                                proj->params.south = true;\n                            }\n                            else if (Value_Offset == 3857) // WGS 84 / Pseudo-Mercator\n                            {\n                                proj->type = proj::ProjType_WebMerc;\n                            }\n\n                            if (debug)\n                                printf(\" --- [ProjectedCSTypeGeoKey] : %d\\n\", Value_Offset);\n                        }\n                        else if (KeyID == ProjCoordTransGeoKey)\n                        { // Projection type\n                            if (Value_Offset == CT_Stereographic)\n                                proj->type = proj::ProjType_Stereographic;\n\n                            if (debug)\n                            {\n                                const char *ProjCoordTransGeoKey_v[] = {\"Unknown\", \"CT_TransverseMercator\", \"CT_TransvMercator_Modified_Alaska\", \"CT_ObliqueMercator\", \"CT_ObliqueMercator_Laborde\", \"CT_ObliqueMercator_Rosenmund\", \"CT_ObliqueMercator_Spherical\", \"CT_Mercator\", \"CT_LambertConfConic_2SP\", \"CT_LambertConfConic_Helmert\", \"CT_LambertAzimEqualArea\", \"CT_AlbersEqualArea\", \"CT_AzimuthalEquidistant\", \"CT_EquidistantConic\", \"CT_Stereographic\", \"CT_PolarStereographic\", \"CT_ObliqueStereographic\", \"CT_Equirectangular\", \"CT_CassiniSoldner\", \"CT_Gnomonic\", \"CT_MillerCylindrical\", \"CT_Orthographic\", \"CT_Polyconic\", \"CT_Robinson\", \"CT_Sinusoidal\", \"CT_VanDerGrinten\", \"CT_NewZealandMapGrid\", \"CT_TransvMercator_SouthOriented\"};\n                                printf(\" --- [ProjCoordTransGeoKey] : %s\\n\", ProjCoordTransGeoKey_v[Value_Offset]);\n                            }\n                        }\n                    }\n                    else\n                    { // Stored somewhere else as a TIFF tag!\n                        if (KeyID == ProjCenterLongGeoKey || KeyID == ProjCenterLatGeoKey)\n                        { // Doubles only\n                            uint32_t count;\n                            double *value;\n                            TIFFGetField(tif, TIFFTagLocation, &count, &value);\n\n                            double val = value[Value_Offset];\n\n                            if (KeyID == ProjCenterLongGeoKey) // Center lon\n                                proj->lam0 = val * DEG2RAD;\n                            if (KeyID == ProjCenterLatGeoKey) // Center lat\n                                proj->phi0 = val * DEG2RAD;\n\n                            if (debug)\n                                printf(\" --- [%d] : %f\\n\", KeyID, val);\n                        }\n                        else\n                        {\n                            if (debug)\n                                printf(\" --- [%d] : NOT_READ\\n\", KeyID);\n                        }\n                    }\n                }\n\n                has_geokeys = true;\n            }\n        }\n        else\n        { // GeoTIFF needs GeoKeyDirectoryTag\n            return false;\n        }\n\n        // Bunch of checks\n        if (!has_tiepoint)\n        {\n            if (debug)\n                printf(\"No tiepoint!\\n\");\n            return false;\n        }\n        if (!has_pixelscale)\n        {\n            if (debug)\n                printf(\"No pixel scale!\\n\");\n            return false;\n        }\n        if (!has_geokeys)\n        {\n            if (debug)\n                printf(\"No Geokeys!\\n\");\n            return false;\n        }\n        if (proj->type == proj::ProjType_Invalid)\n        {\n            if (debug)\n                printf(\"Projection not set!\\n\");\n            return false;\n        }\n\n        if (debug)\n            printf(\"End of GeoTIFF\\n\");\n\n        // If we get there, it's valid\n        return true;\n    }",
    "BOOL\ntiff_read_geotiff_profile(TIFF *tif, FIBITMAP *dib) {\n\tchar defaultKey[16];\n\n\t// first check for a mandatory tag\n\t{\n\t\tshort tag_count = 0;\n\t\tvoid* data = NULL;\n\t\t\n\t\tif(!TIFFGetField(tif, TIFFTAG_GEOKEYDIRECTORY, &tag_count, &data)) {\n\t\t\t// no GeoTIFF tag here\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\t// next, read GeoTIFF tags\n\n\tconst size_t tag_size = sizeof(xtiffFieldInfo) / sizeof(xtiffFieldInfo[0]);\n\n\tTagLib& tag_lib = TagLib::instance();\n\n\tfor(size_t i = 0; i < tag_size; i++) {\n\n\t\tconst TIFFFieldInfo *fieldInfo = &xtiffFieldInfo[i];\n\n\t\tif(fieldInfo->field_type == TIFF_ASCII) {\n\t\t\tchar *params = NULL;\n\n\t\t\tif(TIFFGetField(tif, fieldInfo->field_tag, &params)) {\n\t\t\t\t// create a tag\n\t\t\t\tFITAG *tag = FreeImage_CreateTag();\n\t\t\t\tif(!tag) {\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tWORD tag_id = (WORD)fieldInfo->field_tag;\n\n\t\t\t\tFreeImage_SetTagType(tag, (FREE_IMAGE_MDTYPE)fieldInfo->field_type);\n\t\t\t\tFreeImage_SetTagID(tag, tag_id);\n\t\t\t\tFreeImage_SetTagKey(tag, tag_lib.getTagFieldName(TagLib::GEOTIFF, tag_id, defaultKey));\n\t\t\t\tFreeImage_SetTagDescription(tag, tag_lib.getTagDescription(TagLib::GEOTIFF, tag_id));\n\t\t\t\tFreeImage_SetTagLength(tag, (DWORD)strlen(params) + 1);\n\t\t\t\tFreeImage_SetTagCount(tag, FreeImage_GetTagLength(tag));\n\t\t\t\tFreeImage_SetTagValue(tag, params);\n\t\t\t\tFreeImage_SetMetadata(FIMD_GEOTIFF, dib, FreeImage_GetTagKey(tag), tag);\n\n\t\t\t\t// delete the tag\n\t\t\t\tFreeImage_DeleteTag(tag);\n\t\t\t}\n\t\t} else {\n\t\t\tshort tag_count = 0;\n\t\t\tvoid* data = NULL;\n\n\t\t\tif(TIFFGetField(tif, fieldInfo->field_tag, &tag_count, &data)) {\n\t\t\t\t// create a tag\n\t\t\t\tFITAG *tag = FreeImage_CreateTag();\n\t\t\t\tif(!tag) {\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tWORD tag_id = (WORD)fieldInfo->field_tag;\n\t\t\t\tFREE_IMAGE_MDTYPE tag_type = (FREE_IMAGE_MDTYPE)fieldInfo->field_type;\n\n\t\t\t\tFreeImage_SetTagType(tag, tag_type);\n\t\t\t\tFreeImage_SetTagID(tag, tag_id);\n\t\t\t\tFreeImage_SetTagKey(tag, tag_lib.getTagFieldName(TagLib::GEOTIFF, tag_id, defaultKey));\n\t\t\t\tFreeImage_SetTagDescription(tag, tag_lib.getTagDescription(TagLib::GEOTIFF, tag_id));\n\t\t\t\tFreeImage_SetTagLength(tag, FreeImage_TagDataWidth(tag_type) * tag_count);\n\t\t\t\tFreeImage_SetTagCount(tag, tag_count);\n\t\t\t\tFreeImage_SetTagValue(tag, data);\n\t\t\t\tFreeImage_SetMetadata(FIMD_GEOTIFF, dib, FreeImage_GetTagKey(tag), tag);\n\n\t\t\t\t// delete the tag\n\t\t\t\tFreeImage_DeleteTag(tag);\n\t\t\t}\n\t\t}\n\t} // for(tag_size)\n\n\treturn TRUE;\n}",
    "static BOOL \ntiff_read_exif_tag(TIFF *tif, uint32 tag_id, FIBITMAP *dib, TagLib::MDMODEL md_model) {\n\tuint32 value_count = 0;\n\tint mem_alloc = 0;\n\tvoid *raw_data = NULL;\n\n\tif(tag_id == TIFFTAG_EXIFIFD) {\n\t\t// Exif IFD offset - skip this tag\n\t\t// md_model should be EXIF_MAIN, the Exif IFD is processed later using the EXIF_EXIF metadata model\n\t\treturn TRUE;\n\t}\n\tif((tag_id == TIFFTAG_GPSIFD) && (md_model == TagLib::EXIF_MAIN)) {\n\t\t// Exif GPS IFD offset - skip this tag\n\t\t// should be processed in another way ...\n\t\treturn TRUE;\n\t}\n\t\n\tTagLib& tagLib = TagLib::instance();\n\n\t// get the tag key - use NULL to avoid reading GeoTIFF tags\n\tconst char *key = tagLib.getTagFieldName(md_model, (WORD)tag_id, NULL);\n\tif(key == NULL) {\n\t\treturn TRUE;\n\t}\n\n\tconst TIFFField *fip = TIFFFieldWithTag(tif, tag_id);\n\tif(fip == NULL) {\n\t\treturn TRUE;\n\t}\n\n\tif(TIFFFieldPassCount(fip)) { \n\t\t// a count value is required for 'TIFFGetField'\n\n\t\tif (TIFFFieldReadCount(fip) != TIFF_VARIABLE2) {\n\t\t\t// a count is required, it will be of type uint16\n\t\t\tuint16 value_count16 = 0;\n\t\t\tif(TIFFGetField(tif, tag_id, &value_count16, &raw_data) != 1) {\n\t\t\t\t// stop, ignore error\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\tvalue_count = value_count16;\n\t\t} else {\n\t\t\t// a count is required, it will be of type uint32\n\t\t\tuint32 value_count32 = 0;\n\t\t\tif(TIFFGetField(tif, tag_id, &value_count32, &raw_data) != 1) {\n\t\t\t\t// stop, ignore error\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\tvalue_count = value_count32;\n\t\t}\n\n\t} else {\n\t\t// determine count\n\n\t\tif (TIFFFieldReadCount(fip) == TIFF_VARIABLE || TIFFFieldReadCount(fip) == TIFF_VARIABLE2) {\n\t\t\tvalue_count = 1;\n\t\t} else if (TIFFFieldReadCount(fip) == TIFF_SPP) {\n\t\t\tuint16 spp;\n\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n\t\t\tvalue_count = spp;\n\t\t} else {\n\t\t\tvalue_count = TIFFFieldReadCount(fip);\n\t\t}\n\n\t\t// access fields as pointers to data\n\t\t// (### determining this is NOT robust... and hardly can be. It is implemented looking the _TIFFVGetField code)\n\n\t\tif(TIFFFieldTag(fip) == TIFFTAG_TRANSFERFUNCTION) {\n\t\t\t// reading this tag cause a bug probably located somewhere inside libtiff\n\t\t\treturn TRUE;\n\t\t}\n\n\t\tif ((TIFFFieldDataType(fip) == TIFF_ASCII\n\t\t     || TIFFFieldReadCount(fip) == TIFF_VARIABLE\n\t\t     || TIFFFieldReadCount(fip) == TIFF_VARIABLE2\n\t\t     || TIFFFieldReadCount(fip) == TIFF_SPP\n\t\t\t || value_count > 1)\n\t\t\t \n\t\t\t && TIFFFieldTag(fip) != TIFFTAG_PAGENUMBER\n\t\t\t && TIFFFieldTag(fip) != TIFFTAG_HALFTONEHINTS\n\t\t\t && TIFFFieldTag(fip) != TIFFTAG_YCBCRSUBSAMPLING\n\t\t\t && TIFFFieldTag(fip) != TIFFTAG_DOTRANGE\n\n\t\t\t && TIFFFieldTag(fip) != TIFFTAG_BITSPERSAMPLE\t//<- these two are tricky - \n\t\t\t && TIFFFieldTag(fip) != TIFFTAG_COMPRESSION\t//<- they are defined as TIFF_VARIABLE but in reality return a single value\n\t\t\t ) {\n\t\t\t\t if(TIFFGetField(tif, tag_id, &raw_data) != 1) {\n\t\t\t\t\t // stop, ignore error\n\t\t\t\t\t return TRUE;\n\t\t\t\t }\n\t\t} else {\n\t\t\tint value_size = 0;\n\n\t\t\t// access fields as values\n\n\t\t\t// Note: \n\t\t\t// For TIFF_RATIONAL values, TIFFDataWidth() returns 8, but LibTIFF use internaly 4-byte float to represent rationals.\n\t\t\t{\n\t\t\t\tTIFFDataType tag_type = TIFFFieldDataType(fip);\n\t\t\t\tswitch(tag_type) {\n\t\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\t\t\tvalue_size = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tvalue_size = TIFFDataWidth(tag_type);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\traw_data = _TIFFmalloc(value_size * value_count);\n\t\t\tmem_alloc = 1;\n\t\t\tint ok = FALSE;\n\t\t\t\n\t\t\t// ### if value_count > 1, tag is PAGENUMBER or HALFTONEHINTS or YCBCRSUBSAMPLING or DOTRANGE, \n\t\t\t// all off which are value_count == 2 (see tif_dirinfo.c)\n\t\t\tswitch(value_count)\n\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tok = TIFFGetField(tif, tag_id, raw_data);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tok = TIFFGetField(tif, tag_id, raw_data, (BYTE*)(raw_data) + value_size*1);\n\t\t\t\t\tbreak;\n/* # we might need more in the future:\n\t\t\t\tcase 3:\n\t\t\t\t\tok = TIFFGetField(tif, tag_id, raw_data, (BYTE*)(raw_data) + value_size*1, (BYTE*)(raw_data) + value_size*2);\n\t\t\t\t\tbreak;\n*/\n\t\t\t\tdefault:\n\t\t\t\t\tFreeImage_OutputMessageProc(FIF_TIFF, \"Unimplemented variable number of parameters for Tiff Tag %s\", TIFFFieldName(fip));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(ok != 1) {\n\t\t\t\t_TIFFfree(raw_data);\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// build FreeImage tag from Tiff Tag data we collected\n\n\tFITAG *fitag = FreeImage_CreateTag();\n\tif(!fitag) {\n\t\tif(mem_alloc) {\n\t\t\t_TIFFfree(raw_data);\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\tFreeImage_SetTagID(fitag, (WORD)tag_id);\n\tFreeImage_SetTagKey(fitag, key);\n\n\tswitch(TIFFFieldDataType(fip)) {\n\t\tcase TIFF_BYTE:\n\t\t\tFreeImage_SetTagType(fitag, FIDT_BYTE);\n\t\t\tFreeImage_SetTagLength(fitag, TIFFDataWidth( TIFFFieldDataType(fip) ) * value_count);\n\t\t\tFreeImage_SetTagCount(fitag, value_count);\n\t\t\tFreeImage_SetTagValue(fitag, raw_data);\n\t\t\tbreak;\n\n\t\tcase TIFF_UNDEFINED:\n\t\t\tFreeImage_SetTagType(fitag, FIDT_UNDEFINED);\n\t\t\tFreeImage_SetTagLength(fitag, TIFFDataWidth( TIFFFieldDataType(fip) ) * value_count);\n\t\t\tFreeImage_SetTagCount(fitag, value_count);\n\t\t\tFreeImage_SetTagValue(fitag, raw_data);\n\t\t\tbreak;\n\n\t\tcase TIFF_SBYTE:\n\t\t\tFreeImage_SetTagType(fitag, FIDT_SBYTE);\n\t\t\tFreeImage_SetTagLength(fitag, TIFFDataWidth( TIFFFieldDataType(fip) ) * value_count);\n\t\t\tFreeImage_SetTagCount(fitag, value_count);\n\t\t\tFreeImage_SetTagValue(fitag, raw_data);\n\t\t\tbreak;\n\n\t\tcase TIFF_SHORT:\n\t\t\tFreeImage_SetTagType(fitag, FIDT_SHORT);\n\t\t\tFreeImage_SetTagLength(fitag, TIFFDataWidth( TIFFFieldDataType(fip) ) * value_count);\n\t\t\tFreeImage_SetTagCount(fitag, value_count);\n\t\t\tFreeImage_SetTagValue(fitag, raw_data);\n\t\t\tbreak;\n\n\t\tcase TIFF_SSHORT:\n\t\t\tFreeImage_SetTagType(fitag, FIDT_SSHORT);\n\t\t\tFreeImage_SetTagLength(fitag, TIFFDataWidth( TIFFFieldDataType(fip) ) * value_count);\n\t\t\tFreeImage_SetTagCount(fitag, value_count);\n\t\t\tFreeImage_SetTagValue(fitag, raw_data);\n\t\t\tbreak;\n\n\t\tcase TIFF_LONG:\n\t\t\tFreeImage_SetTagType(fitag, FIDT_LONG);\n\t\t\tFreeImage_SetTagLength(fitag, TIFFDataWidth( TIFFFieldDataType(fip) ) * value_count);\n\t\t\tFreeImage_SetTagCount(fitag, value_count);\n\t\t\tFreeImage_SetTagValue(fitag, raw_data);\n\t\t\tbreak;\n\n\t\tcase TIFF_IFD:\n\t\t\tFreeImage_SetTagType(fitag, FIDT_IFD);\n\t\t\tFreeImage_SetTagLength(fitag, TIFFDataWidth( TIFFFieldDataType(fip) ) * value_count);\n\t\t\tFreeImage_SetTagCount(fitag, value_count);\n\t\t\tFreeImage_SetTagValue(fitag, raw_data);\n\t\t\tbreak;\n\n\t\tcase TIFF_SLONG:\n\t\t\tFreeImage_SetTagType(fitag, FIDT_SLONG);\n\t\t\tFreeImage_SetTagLength(fitag, TIFFDataWidth( TIFFFieldDataType(fip) ) * value_count);\n\t\t\tFreeImage_SetTagCount(fitag, value_count);\n\t\t\tFreeImage_SetTagValue(fitag, raw_data);\n\t\t\tbreak;\n\n\t\tcase TIFF_RATIONAL: {\n\t\t\t// LibTIFF converts rational to floats : reconvert floats to rationals\n\t\t\tDWORD *rvalue = (DWORD*)malloc(2 * value_count * sizeof(DWORD));\n\t\t\tfor(uint32 i = 0; i < value_count; i++) {\n\t\t\t\tfloat *fv = (float*)raw_data;\n\t\t\t\tFIRational rational(fv[i]);\n\t\t\t\trvalue[2*i] = rational.getNumerator();\n\t\t\t\trvalue[2*i+1] = rational.getDenominator();\n\t\t\t}\n\t\t\tFreeImage_SetTagType(fitag, FIDT_RATIONAL);\n\t\t\tFreeImage_SetTagLength(fitag, TIFFDataWidth( TIFFFieldDataType(fip) ) * value_count);\n\t\t\tFreeImage_SetTagCount(fitag, value_count);\n\t\t\tFreeImage_SetTagValue(fitag, rvalue);\n\t\t\tfree(rvalue);\n\t\t}\n\t\tbreak;\n\n\t\tcase TIFF_SRATIONAL: {\n\t\t\t// LibTIFF converts rational to floats : reconvert floats to rationals\n\t\t\tLONG *rvalue = (LONG*)malloc(2 * value_count * sizeof(LONG));\n\t\t\tfor(uint32 i = 0; i < value_count; i++) {\n\t\t\t\tfloat *fv = (float*)raw_data;\n\t\t\t\tFIRational rational(fv[i]);\n\t\t\t\trvalue[2*i] = rational.getNumerator();\n\t\t\t\trvalue[2*i+1] = rational.getDenominator();\n\t\t\t}\n\t\t\tFreeImage_SetTagType(fitag, FIDT_RATIONAL);\n\t\t\tFreeImage_SetTagLength(fitag, TIFFDataWidth( TIFFFieldDataType(fip) ) * value_count);\n\t\t\tFreeImage_SetTagCount(fitag, value_count);\n\t\t\tFreeImage_SetTagValue(fitag, rvalue);\n\t\t\tfree(rvalue);\n\t\t}\n\t\tbreak;\n\n\t\tcase TIFF_FLOAT:\n\t\t\tFreeImage_SetTagType(fitag, FIDT_FLOAT);\n\t\t\tFreeImage_SetTagLength(fitag, TIFFDataWidth( TIFFFieldDataType(fip) ) * value_count);\n\t\t\tFreeImage_SetTagCount(fitag, value_count);\n\t\t\tFreeImage_SetTagValue(fitag, raw_data);\n\t\t\tbreak;\n\n\t\tcase TIFF_DOUBLE:\n\t\t\tFreeImage_SetTagType(fitag, FIDT_DOUBLE);\n\t\t\tFreeImage_SetTagLength(fitag, TIFFDataWidth( TIFFFieldDataType(fip) ) * value_count);\n\t\t\tFreeImage_SetTagCount(fitag, value_count);\n\t\t\tFreeImage_SetTagValue(fitag, raw_data);\n\t\t\tbreak;\n\n\t\tcase TIFF_LONG8:\t// BigTIFF 64-bit unsigned integer \n\t\t\tFreeImage_SetTagType(fitag, FIDT_LONG8);\n\t\t\tFreeImage_SetTagLength(fitag, TIFFDataWidth( TIFFFieldDataType(fip) ) * value_count);\n\t\t\tFreeImage_SetTagCount(fitag, value_count);\n\t\t\tFreeImage_SetTagValue(fitag, raw_data);\n\t\t\tbreak;\n\n\t\tcase TIFF_IFD8:\t\t// BigTIFF 64-bit unsigned integer (offset) \n\t\t\tFreeImage_SetTagType(fitag, FIDT_IFD8);\n\t\t\tFreeImage_SetTagLength(fitag, TIFFDataWidth( TIFFFieldDataType(fip) ) * value_count);\n\t\t\tFreeImage_SetTagCount(fitag, value_count);\n\t\t\tFreeImage_SetTagValue(fitag, raw_data);\n\t\t\tbreak;\n\n\t\tcase TIFF_SLONG8:\t\t// BigTIFF 64-bit signed integer \n\t\t\tFreeImage_SetTagType(fitag, FIDT_SLONG8);\n\t\t\tFreeImage_SetTagLength(fitag, TIFFDataWidth( TIFFFieldDataType(fip) ) * value_count);\n\t\t\tFreeImage_SetTagCount(fitag, value_count);\n\t\t\tFreeImage_SetTagValue(fitag, raw_data);\n\t\t\tbreak;\n\n\t\tcase TIFF_ASCII:\n\t\tdefault: {\n\t\t\tsize_t length = 0;\n\t\t\tif(!mem_alloc && (TIFFFieldDataType(fip) == TIFF_ASCII) && (TIFFFieldReadCount(fip) == TIFF_VARIABLE)) {\n\t\t\t\t// when metadata tag is of type ASCII and it's value is of variable size (TIFF_VARIABLE),\n\t\t\t\t// tiff_read_exif_tag function gives length of 1 so all strings are truncated ...\n\t\t\t\t// ... try to avoid this by using an explicit calculation for 'length'\n\t\t\t\tlength = strlen((char*)raw_data) + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// remember that raw_data = _TIFFmalloc(value_size * value_count);\n\t\t\t\tconst int value_size = TIFFDataWidth( TIFFFieldDataType(fip) );\n\t\t\t\tlength = value_size * value_count;\n\t\t\t}\n\t\t\tFreeImage_SetTagType(fitag, FIDT_ASCII);\n\t\t\tFreeImage_SetTagLength(fitag, (DWORD)length);\n\t\t\tFreeImage_SetTagCount(fitag, (DWORD)length);\n\t\t\tFreeImage_SetTagValue(fitag, raw_data);\n\t\t}\n\t\tbreak;\n\t}\n\n\tconst char *description = tagLib.getTagDescription(md_model, (WORD)tag_id);\n\tif(description) {\n\t\tFreeImage_SetTagDescription(fitag, description);\n\t}\n\t// store the tag\n\tFreeImage_SetMetadata(tagLib.getFreeImageModel(md_model), dib, FreeImage_GetTagKey(fitag), fitag);\n\n\t// destroy the tag\n\tFreeImage_DeleteTag(fitag);\n\n\tif(mem_alloc) {\n\t\t_TIFFfree(raw_data);\n\t}\n\treturn TRUE;\n}",
    "static BOOL \nskip_write_field(TIFF* tif, uint32 tag) {\n\tswitch (tag) {\n\t\tcase TIFFTAG_SUBFILETYPE:\n\t\tcase TIFFTAG_OSUBFILETYPE:\n\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\tcase TIFFTAG_IMAGELENGTH:\n\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\tcase TIFFTAG_COMPRESSION:\n\t\tcase TIFFTAG_PHOTOMETRIC:\n\t\tcase TIFFTAG_THRESHHOLDING:\n\t\tcase TIFFTAG_CELLWIDTH:\n\t\tcase TIFFTAG_CELLLENGTH:\n\t\tcase TIFFTAG_FILLORDER:\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_ORIENTATION:\n\t\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\tcase TIFFTAG_XRESOLUTION:\n\t\tcase TIFFTAG_YRESOLUTION:\n\t\tcase TIFFTAG_PLANARCONFIG:\n\t\tcase TIFFTAG_FREEOFFSETS:\n\t\tcase TIFFTAG_FREEBYTECOUNTS:\n\t\tcase TIFFTAG_GRAYRESPONSEUNIT:\n\t\tcase TIFFTAG_GRAYRESPONSECURVE:\n\t\tcase TIFFTAG_GROUP3OPTIONS:\n\t\tcase TIFFTAG_GROUP4OPTIONS:\n\t\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\tcase TIFFTAG_PAGENUMBER:\n\t\tcase TIFFTAG_COLORRESPONSEUNIT:\n\t\tcase TIFFTAG_PREDICTOR:\n\t\tcase TIFFTAG_COLORMAP:\n\t\tcase TIFFTAG_HALFTONEHINTS:\n\t\tcase TIFFTAG_TILEWIDTH:\n\t\tcase TIFFTAG_TILELENGTH:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\t// skip always, values have been set in SaveOneTIFF()\n\t\t\treturn TRUE;\n\t\t\tbreak;\n\t\t\n\t\tcase TIFFTAG_RICHTIFFIPTC:\n\t\t\t// skip always, IPTC metadata model is set in tiff_write_iptc_profile()\n\t\t\treturn TRUE;\n\t\t\tbreak;\n\n\t\tcase TIFFTAG_YCBCRCOEFFICIENTS:\n\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\t// skip as they cannot be filled yet\n\t\t\treturn TRUE;\n\t\t\tbreak;\n\t\t\t\n\t\tcase TIFFTAG_PAGENAME:\n\t\t{\n\t\t\tchar *value = NULL;\n\t\t\tTIFFGetField(tif, TIFFTAG_PAGENAME, &value);\n\t\t\t// only skip if no value has been set\n\t\t\tif(value == NULL) {\n\t\t\t\treturn FALSE;\n\t\t\t} else {\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t\tdefault:\n\t\t\treturn FALSE;\n\t\t\tbreak;\n\t}\n}",
    "static void \nReadResolution(TIFF *tiff, FIBITMAP *dib) {\n\tfloat fResX = 300.0;\n\tfloat fResY = 300.0;\n\tuint16 resUnit = RESUNIT_INCH;\n\n\tTIFFGetField(tiff, TIFFTAG_RESOLUTIONUNIT, &resUnit);\n\tTIFFGetField(tiff, TIFFTAG_XRESOLUTION, &fResX);\n\tTIFFGetField(tiff, TIFFTAG_YRESOLUTION, &fResY);\n\t\n\t// If we don't have a valid resolution unit and valid resolution is specified then assume inch\n\tif (resUnit == RESUNIT_NONE && fResX > 0.0 && fResY > 0.0) {\n\t\tresUnit = RESUNIT_INCH;\n\t}\n\tif (resUnit == RESUNIT_INCH) {\n\t\tFreeImage_SetDotsPerMeterX(dib, (unsigned) (fResX/0.0254000 + 0.5));\n\t\tFreeImage_SetDotsPerMeterY(dib, (unsigned) (fResY/0.0254000 + 0.5));\n\t} else if(resUnit == RESUNIT_CENTIMETER) {\n\t\tFreeImage_SetDotsPerMeterX(dib, (unsigned) (fResX*100.0 + 0.5));\n\t\tFreeImage_SetDotsPerMeterY(dib, (unsigned) (fResY*100.0 + 0.5));\n\t}\n}",
    "static void \nReadPalette(TIFF *tiff, uint16 photometric, uint16 bitspersample, FIBITMAP *dib) {\n\tRGBQUAD *pal = FreeImage_GetPalette(dib);\n\n\tswitch(photometric) {\n\t\tcase PHOTOMETRIC_MINISBLACK:\t// bitmap and greyscale image types\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\t\t// Monochrome image\n\n\t\t\tif (bitspersample == 1) {\n\t\t\t\tif (photometric == PHOTOMETRIC_MINISWHITE) {\n\t\t\t\t\tpal[0].rgbRed = pal[0].rgbGreen = pal[0].rgbBlue = 255;\n\t\t\t\t\tpal[1].rgbRed = pal[1].rgbGreen = pal[1].rgbBlue = 0;\n\t\t\t\t} else {\n\t\t\t\t\tpal[0].rgbRed = pal[0].rgbGreen = pal[0].rgbBlue = 0;\n\t\t\t\t\tpal[1].rgbRed = pal[1].rgbGreen = pal[1].rgbBlue = 255;\n\t\t\t\t}\n\n\t\t\t} else if ((bitspersample == 4) ||(bitspersample == 8)) {\n\t\t\t\t// need to build the scale for greyscale images\n\t\t\t\tint ncolors = FreeImage_GetColorsUsed(dib);\n\n\t\t\t\tif (photometric == PHOTOMETRIC_MINISBLACK) {\n\t\t\t\t\tfor (int i = 0; i < ncolors; i++) {\n\t\t\t\t\t\tpal[i].rgbRed\t=\n\t\t\t\t\t\tpal[i].rgbGreen =\n\t\t\t\t\t\tpal[i].rgbBlue\t= (BYTE)(i*(255/(ncolors-1)));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < ncolors; i++) {\n\t\t\t\t\t\tpal[i].rgbRed\t=\n\t\t\t\t\t\tpal[i].rgbGreen =\n\t\t\t\t\t\tpal[i].rgbBlue\t= (BYTE)(255-i*(255/(ncolors-1)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase PHOTOMETRIC_PALETTE:\t// color map indexed\n\t\t\tuint16 *red;\n\t\t\tuint16 *green;\n\t\t\tuint16 *blue;\n\t\t\t\n\t\t\tTIFFGetField(tiff, TIFFTAG_COLORMAP, &red, &green, &blue); \n\n\t\t\t// load the palette in the DIB\n\n\t\t\tif (CheckColormap(1<<bitspersample, red, green, blue) == 16) {\n\t\t\t\tfor (int i = (1 << bitspersample) - 1; i >= 0; i--) {\n\t\t\t\t\tpal[i].rgbRed =(BYTE) CVT(red[i]);\n\t\t\t\t\tpal[i].rgbGreen = (BYTE) CVT(green[i]);\n\t\t\t\t\tpal[i].rgbBlue = (BYTE) CVT(blue[i]);           \n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = (1 << bitspersample) - 1; i >= 0; i--) {\n\t\t\t\t\tpal[i].rgbRed = (BYTE) red[i];\n\t\t\t\t\tpal[i].rgbGreen = (BYTE) green[i];\n\t\t\t\t\tpal[i].rgbBlue = (BYTE) blue[i];        \n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t}\n}",
    "static FREE_IMAGE_TYPE \nReadImageType(TIFF *tiff, uint16 bitspersample, uint16 samplesperpixel) {\n\tuint16 sampleformat = 0;\n\tFREE_IMAGE_TYPE fit = FIT_BITMAP ; \n\n\tuint16 bpp = bitspersample * samplesperpixel;\n\n\t// try the sampleformat tag\n    if(TIFFGetField(tiff, TIFFTAG_SAMPLEFORMAT, &sampleformat)) {\n\n        switch (sampleformat) {\n\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\tswitch (bpp) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\tcase 4:\n\t\t\t\t\tcase 8:\n\t\t\t\t\tcase 24:\n\t\t\t\t\t\tfit = FIT_BITMAP;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\t// 8-bit + alpha or 16-bit greyscale\n\t\t\t\t\t\tif(samplesperpixel == 2) {\n\t\t\t\t\t\t\tfit = FIT_BITMAP;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfit = FIT_UINT16;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\tif(samplesperpixel == 4) {\n\t\t\t\t\t\t\tfit = FIT_BITMAP;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfit = FIT_UINT32;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 48:\n\t\t\t\t\t\tif(samplesperpixel == 3) {\n\t\t\t\t\t\t\tfit = FIT_RGB16;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 64:\n\t\t\t\t\t\tif(samplesperpixel == 4) {\n\t\t\t\t\t\t\tfit = FIT_RGBA16;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\tswitch (bpp) {\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\tif(samplesperpixel == 3) {\n\t\t\t\t\t\t\tfit = FIT_BITMAP;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfit = FIT_INT16;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\tfit = FIT_INT32;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\tswitch (bpp) {\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\tfit = FIT_FLOAT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 48:\n\t\t\t\t\t\t// 3 x half float => convert to RGBF\n\t\t\t\t\t\tif((samplesperpixel == 3) && (bitspersample == 16)) {\n\t\t\t\t\t\t\tfit = FIT_RGBF;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 64:\n\t\t\t\t\t\tif(samplesperpixel == 2) {\n\t\t\t\t\t\t\tfit = FIT_FLOAT;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfit = FIT_DOUBLE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 96:\n\t\t\t\t\t\tfit = FIT_RGBF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif(bpp >= 128) {\n\t\t\t\t\t\t\tfit = FIT_RGBAF;\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SAMPLEFORMAT_COMPLEXIEEEFP:\n\t\t\t\tswitch (bpp) {\n\t\t\t\t\tcase 64:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 128:\n\t\t\t\t\t\tfit = FIT_COMPLEX;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t}\n    }\n\t// no sampleformat tag : assume SAMPLEFORMAT_UINT\n\telse {\n\t\tif(samplesperpixel == 1) {\n\t\t\tswitch (bpp) {\n\t\t\t\tcase 16:\n\t\t\t\t\tfit = FIT_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 32:\n\t\t\t\t\tfit = FIT_UINT32;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if(samplesperpixel == 3) {\n\t\t\tif(bpp == 48) fit = FIT_RGB16;\n\t\t}\n\t\telse if(samplesperpixel >= 4) { \n\t\t\tif(bitspersample == 16) {\n\t\t\t\tfit = FIT_RGBA16;\n\t\t\t}\n\t\t}\n\n\t}\n\n    return fit;\n}",
    "static void \nWriteCompression(TIFF *tiff, uint16 bitspersample, uint16 samplesperpixel, uint16 photometric, int flags) {\n\tuint16 compression;\n\tuint16 bitsperpixel = bitspersample * samplesperpixel;\n\n\tif(photometric == PHOTOMETRIC_LOGLUV) {\n\t\tcompression = COMPRESSION_SGILOG;\n\t} else if ((flags & TIFF_PACKBITS) == TIFF_PACKBITS) {\n\t\tcompression = COMPRESSION_PACKBITS;\n\t} else if ((flags & TIFF_DEFLATE) == TIFF_DEFLATE) {\n\t\tcompression = COMPRESSION_DEFLATE;\n\t} else if ((flags & TIFF_ADOBE_DEFLATE) == TIFF_ADOBE_DEFLATE) {\n\t\tcompression = COMPRESSION_ADOBE_DEFLATE;\n\t} else if ((flags & TIFF_NONE) == TIFF_NONE) {\n\t\tcompression = COMPRESSION_NONE;\n\t} else if ((bitsperpixel == 1) && ((flags & TIFF_CCITTFAX3) == TIFF_CCITTFAX3)) {\n\t\tcompression = COMPRESSION_CCITTFAX3;\n\t} else if ((bitsperpixel == 1) && ((flags & TIFF_CCITTFAX4) == TIFF_CCITTFAX4)) {\n\t\tcompression = COMPRESSION_CCITTFAX4;\n\t} else if ((flags & TIFF_LZW) == TIFF_LZW) {\n\t\tcompression = COMPRESSION_LZW;\n\t} else if ((flags & TIFF_JPEG) == TIFF_JPEG) {\n\t\tif(((bitsperpixel == 8) && (photometric != PHOTOMETRIC_PALETTE)) || (bitsperpixel == 24)) {\n\t\t\tcompression = COMPRESSION_JPEG;\n\t\t\t// RowsPerStrip must be multiple of 8 for JPEG\n\t\t\tuint32 rowsperstrip = (uint32) -1;\n\t\t\trowsperstrip = TIFFDefaultStripSize(tiff, rowsperstrip);\n            rowsperstrip = rowsperstrip + (8 - (rowsperstrip % 8));\n\t\t\t// overwrite previous RowsPerStrip\n\t\t\tTIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\t\t} else {\n\t\t\t// default to LZW\n\t\t\tcompression = COMPRESSION_LZW;\n\t\t}\n\t}\n\telse {\n\t\t// default compression scheme\n\n\t\tswitch(bitsperpixel) {\n\t\t\tcase 1:\n\t\t\t\tcompression = COMPRESSION_CCITTFAX4;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\tcase 8:\n\t\t\tcase 16:\n\t\t\tcase 24:\n\t\t\tcase 32:\n\t\t\t\tcompression = COMPRESSION_LZW;\n\t\t\t\tbreak;\n\t\t\tcase 48:\n\t\t\tcase 64:\n\t\t\tcase 96:\n\t\t\tcase 128:\n\t\t\t\tcompression = COMPRESSION_LZW;\n\t\t\t\tbreak;\n\n\t\t\tdefault :\n\t\t\t\tcompression = COMPRESSION_NONE;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tTIFFSetField(tiff, TIFFTAG_COMPRESSION, compression);\n\n\tif(compression == COMPRESSION_LZW) {\n\t\t// This option is only meaningful with LZW compression: a predictor value of 2 \n\t\t// causes each scanline of the output image to undergo horizontal differencing \n\t\t// before it is encoded; a value of 1 forces each scanline to be encoded without differencing.\n\n\t\t// Found on LibTIFF mailing list : \n\t\t// LZW without differencing works well for 1-bit images, 4-bit grayscale images, \n\t\t// and many palette-color images. But natural 24-bit color images and some 8-bit \n\t\t// grayscale images do much better with differencing.\n\n\t\tif((bitspersample == 8) || (bitspersample == 16)) {\n\t\t\tif ((bitsperpixel >= 8) && (photometric != PHOTOMETRIC_PALETTE)) {\n\t\t\t\tTIFFSetField(tiff, TIFFTAG_PREDICTOR, 2);\n\t\t\t} else {\n\t\t\t\tTIFFSetField(tiff, TIFFTAG_PREDICTOR, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tTIFFSetField(tiff, TIFFTAG_PREDICTOR, 1);\n\t\t}\n\t}\n\telse if((compression == COMPRESSION_CCITTFAX3) || (compression == COMPRESSION_CCITTFAX4)) {\n\t\tuint32 imageLength = 0;\n\t\tTIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &imageLength);\n\t\t// overwrite previous RowsPerStrip\n\t\tTIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, imageLength);\n\n\t\tif(compression == COMPRESSION_CCITTFAX3) {\n\t\t\t// try to be compliant with the TIFF Class F specification\n\t\t\t// that documents the TIFF tags specific to FAX applications\n\t\t\t// see http://palimpsest.stanford.edu/bytopic/imaging/std/tiff-f.html\n\t\t\tuint32 group3options = GROUP3OPT_2DENCODING | GROUP3OPT_FILLBITS;\t\n\t\t\tTIFFSetField(tiff, TIFFTAG_GROUP3OPTIONS, group3options);\t// 2d-encoded, has aligned EOL\n\t\t\tTIFFSetField(tiff, TIFFTAG_FILLORDER, FILLORDER_LSB2MSB);\t// lsb-to-msb fillorder\n\t\t}\n\t}\n}",
    "static BOOL \ntiff_read_iptc_profile(TIFF *tiff, FIBITMAP *dib) {\n\tBYTE *profile = NULL;\n\tuint32 profile_size = 0;\n\n    if(TIFFGetField(tiff,TIFFTAG_RICHTIFFIPTC, &profile_size, &profile) == 1) {\n\t\tif (TIFFIsByteSwapped(tiff) != 0) {\n\t\t\tTIFFSwabArrayOfLong((uint32 *) profile, (unsigned long)profile_size);\n\t\t}\n\n\t\treturn read_iptc_profile(dib, profile, 4 * profile_size);\n\t}\n\n\treturn FALSE;\n}",
    "static BOOL  \ntiff_read_xmp_profile(TIFF *tiff, FIBITMAP *dib) {\n\tBYTE *profile = NULL;\n\tuint32 profile_size = 0;\n\n\tif (TIFFGetField(tiff, TIFFTAG_XMLPACKET, &profile_size, &profile) == 1) {\n\t\t// create a tag\n\t\tFITAG *tag = FreeImage_CreateTag();\n\t\tif(!tag) return FALSE;\n\n\t\tFreeImage_SetTagID(tag, TIFFTAG_XMLPACKET);\t// 700\n\t\tFreeImage_SetTagKey(tag, g_TagLib_XMPFieldName);\n\t\tFreeImage_SetTagLength(tag, profile_size);\n\t\tFreeImage_SetTagCount(tag, profile_size);\n\t\tFreeImage_SetTagType(tag, FIDT_ASCII);\n\t\tFreeImage_SetTagValue(tag, profile);\n\n\t\t// store the tag\n\t\tFreeImage_SetMetadata(FIMD_XMP, dib, FreeImage_GetTagKey(tag), tag);\n\n\t\t// destroy the tag\n\t\tFreeImage_DeleteTag(tag);\n\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}",
    "static BOOL \ntiff_read_exif_profile(FreeImageIO *io, fi_handle handle, TIFF *tiff, FIBITMAP *dib) {\n\tBOOL bResult = FALSE;\n\ttoff_t exif_offset = 0;\n\n\t// read EXIF-TIFF tags\n\tbResult = tiff_read_exif_tags(tiff, TagLib::EXIF_MAIN, dib);\n\n\t// get the IFD offset\n\tif(TIFFGetField(tiff, TIFFTAG_EXIFIFD, &exif_offset)) {\n\n\t\tconst long tell_pos = io->tell_proc(handle);\n\t\tconst uint16 cur_dir = TIFFCurrentDirectory(tiff);\n\n\t\t// read EXIF tags\n\t\tif (TIFFReadEXIFDirectory(tiff, exif_offset)) {\n\t\t\t// read all known exif tags\n\t\t\tbResult = tiff_read_exif_tags(tiff, TagLib::EXIF_EXIF, dib);\n\t\t}\n\n\t\tio->seek_proc(handle, tell_pos, SEEK_SET);\n\t\tTIFFSetDirectory(tiff, cur_dir);\n\t}\n\n\treturn bResult;\n}",
    "static TIFFLoadMethod  \nFindLoadMethod(TIFF *tif, FREE_IMAGE_TYPE image_type, int flags) {\n\tuint16 bitspersample\t= (uint16)-1;\n\tuint16 samplesperpixel\t= (uint16)-1;\n\tuint16 photometric\t\t= (uint16)-1;\n\tuint16 planar_config\t= (uint16)-1;\n\n\tTIFFLoadMethod loadMethod = LoadAsGenericStrip;\n\n\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planar_config);\n\n\tBOOL bIsTiled = (TIFFIsTiled(tif) == 0) ? FALSE:TRUE;\n\n\tswitch(photometric) {\n\t\t// convert to 24 or 32 bits RGB if the image is full color\n\t\tcase PHOTOMETRIC_RGB:\n\t\t\tif((image_type == FIT_RGB16) || (image_type == FIT_RGBA16)) {\n\t\t\t\t// load 48-bit RGB and 64-bit RGBA without conversion \n\t\t\t\tloadMethod = LoadAsGenericStrip;\n\t\t\t} \n\t\t\telse if(image_type == FIT_RGBF) {\n\t\t\t\tif((samplesperpixel == 3) && (bitspersample == 16)) {\n\t\t\t\t\t// load 3 x 16-bit half as RGBF\n\t\t\t\t\tloadMethod = LoadAsHalfFloat;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_YCBCR:\n\t\tcase PHOTOMETRIC_CIELAB:\n\t\tcase PHOTOMETRIC_ICCLAB:\n\t\tcase PHOTOMETRIC_ITULAB:\n\t\t\tloadMethod = LoadAsRBGA;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\tloadMethod = LoadAsLogLuv;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_SEPARATED:\n\t\t\t// if image is PHOTOMETRIC_SEPARATED _and_ comes with an ICC profile, \n\t\t\t// then the image should preserve its original (CMYK) colour model and \n\t\t\t// should be read as CMYK (to keep the match of pixel and profile and \n\t\t\t// to avoid multiple conversions. Conversion can be done by changing \n\t\t\t// the profile from it's original CMYK to an RGB profile with an \n\t\t\t// apropriate color management system. Works with non-tiled TIFFs.\n\t\t\tif(!bIsTiled) {\n\t\t\t\tloadMethod = LoadAsCMYK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\tcase PHOTOMETRIC_MINISBLACK:\n\t\tcase PHOTOMETRIC_PALETTE:\n\t\t\t// When samplesperpixel = 2 and bitspersample = 8, set the image as a\n\t\t\t// 8-bit indexed image + 8-bit alpha layer image\n\t\t\t// and convert to a 8-bit image with a transparency table\n\t\t\tif((samplesperpixel > 1) && (bitspersample == 8)) {\n\t\t\t\tloadMethod = LoadAs8BitTrns;\n\t\t\t} else {\n\t\t\t\tloadMethod = LoadAsGenericStrip;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tloadMethod = LoadAsGenericStrip;\n\t\t\tbreak;\n\t}\n\n\tif((loadMethod == LoadAsGenericStrip) && bIsTiled) {\n\t\tloadMethod = LoadAsTiled;\n\t}\n\n\treturn loadMethod;\n}",
    "static void \nReadThumbnail(FreeImageIO *io, fi_handle handle, void *data, TIFF *tiff, FIBITMAP *dib) {\n\tFIBITMAP* thumbnail = NULL;\n\t\n\t// read exif thumbnail (IFD 1) ...\n\t\n\t/*\n\t// this code can cause unwanted recursion causing an overflow, it is thus disabled until we have a better solution\n\t// do we really need to read a thumbnail from the Exif segment ? knowing that TIFF store the thumbnail in the subIFD ...\n\t// \n\ttoff_t exif_offset = 0;\n\tif(TIFFGetField(tiff, TIFFTAG_EXIFIFD, &exif_offset)) {\n\t\t\n\t\tif(!TIFFLastDirectory(tiff)) {\n\t\t\t// save current position\n\t\t\tconst long tell_pos = io->tell_proc(handle);\n\t\t\tconst uint16 cur_dir = TIFFCurrentDirectory(tiff);\n\t\t\t\n\t\t\t// load the thumbnail\n\t\t\tint page = 1;\n\t\t\tint flags = TIFF_DEFAULT;\n\t\t\tthumbnail = Load(io, handle, page, flags, data);\n\t\t\t// store the thumbnail (remember to release it before return)\n\t\t\tFreeImage_SetThumbnail(dib, thumbnail);\n\t\t\t\n\t\t\t// restore current position\n\t\t\tio->seek_proc(handle, tell_pos, SEEK_SET);\n\t\t\tTIFFSetDirectory(tiff, cur_dir);\n\t\t}\n\t}\n\t*/\n\t\n\t// ... or read the first subIFD\n\t\n\tif(!thumbnail) {\n\t\tuint16 subIFD_count = 0;\n\t\ttoff_t* subIFD_offsets = NULL;\n\t\t\n\t\t// This will also read the first (and only) subIFD from a Photoshop-created \"pyramid\" file.\n\t\t// Subsequent, smaller images are 'nextIFD' in that subIFD. Currently we only load the first one. \n\t\t\n\t\tif(TIFFGetField(tiff, TIFFTAG_SUBIFD, &subIFD_count, &subIFD_offsets)) {\n\t\t\tif(subIFD_count > 0) {\n\t\t\t\t// save current position\n\t\t\t\tconst long tell_pos = io->tell_proc(handle);\n\t\t\t\tconst uint16 cur_dir = TIFFCurrentDirectory(tiff);\n\t\t\t\t\n\t\t\t\tif(TIFFSetSubDirectory(tiff, subIFD_offsets[0])) {\n\t\t\t\t\t// load the thumbnail\n\t\t\t\t\tint page = -1; \n\t\t\t\t\tint flags = TIFF_DEFAULT;\n\t\t\t\t\tthumbnail = Load(io, handle, page, flags, data);\n\t\t\t\t\t// store the thumbnail (remember to release it before return)\n\t\t\t\t\tFreeImage_SetThumbnail(dib, thumbnail);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// restore current position\n\t\t\t\tio->seek_proc(handle, tell_pos, SEEK_SET);\n\t\t\t\tTIFFSetDirectory(tiff, cur_dir);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ... or read Photoshop thumbnail\n\t\n\tif(!thumbnail) {\n\t\tuint32 ps_size = 0;\n\t\tvoid *ps_data = NULL;\n\t\t\n\t\tif(TIFFGetField(tiff, TIFFTAG_PHOTOSHOP, &ps_size, &ps_data)) {\n\t\t\tFIMEMORY *handle = FreeImage_OpenMemory((BYTE*)ps_data, ps_size);\n\t\t\t\n\t\t\tFreeImageIO io;\n\t\t\tSetMemoryIO(&io);\n\t\t\t\n\t\t\tpsdParser parser;\n\t\t\tparser.ReadImageResources(&io, handle, ps_size);\n\n\t\t\tFreeImage_SetThumbnail(dib, parser.GetThumbnail());\n\t\t\t\n\t\t\tFreeImage_CloseMemory(handle);\n\t\t}\n\t}\n\t\n\t// release thumbnail\n\tFreeImage_Unload(thumbnail);\n}",
    "static FIBITMAP * DLL_CALLCONV\nLoad(FreeImageIO *io, fi_handle handle, int page, int flags, void *data) {\n\tif (!handle || !data ) {\n\t\treturn NULL;\n\t}\n\t\n\tTIFF   *tif = NULL;\n\tuint32 height = 0; \n\tuint32 width = 0; \n\tuint16 bitspersample = 1;\n\tuint16 samplesperpixel = 1;\n\tuint32 rowsperstrip = (uint32)-1;  \n\tuint16 photometric = PHOTOMETRIC_MINISWHITE;\n\tuint16 compression = (uint16)-1;\n\tuint16 planar_config;\n\n\tFIBITMAP *dib = NULL;\n\tuint32 iccSize = 0;\t\t// ICC profile length\n\tvoid *iccBuf = NULL;\t// ICC profile data\t\t\n\n\tconst BOOL header_only = (flags & FIF_LOAD_NOPIXELS) == FIF_LOAD_NOPIXELS;\n\t\n\ttry {\t\n\t\tfi_TIFFIO *fio = (fi_TIFFIO*)data;\n\t\ttif = fio->tif;\n\n\t\tif (page != -1) {\n\t\t\tif (!tif || !TIFFSetDirectory(tif, (uint16)page)) {\n\t\t\t\tthrow \"Error encountered while opening TIFF file\";\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tconst BOOL asCMYK = (flags & TIFF_CMYK) == TIFF_CMYK;\n\n\t\t// first, get the photometric, the compression and basic metadata\n\t\t// ---------------------------------------------------------------------------------\n\n\t\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric);\n\t\tTIFFGetField(tif, TIFFTAG_COMPRESSION, &compression);\n\n\t\t// check for HDR formats\n\t\t// ---------------------------------------------------------------------------------\n\n\t\tif(photometric == PHOTOMETRIC_LOGLUV) {\n\t\t\t// check the compression\n\t\t\tif(compression != COMPRESSION_SGILOG && compression != COMPRESSION_SGILOG24) {\n\t\t\t\tthrow \"Only support SGILOG compressed LogLuv data\";\n\t\t\t}\n\t\t\t// set decoder to output in IEEE 32-bit float XYZ values\n\t\t\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n\t\t}\n\n\t\t// ---------------------------------------------------------------------------------\n\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);   \t\t\t\n\t\tTIFFGetField(tif, TIFFTAG_ICCPROFILE, &iccSize, &iccBuf);\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planar_config);\n\n\t\t// check for unsupported formats\n\t\t// ---------------------------------------------------------------------------------\n\n\t\tif(IsValidBitsPerSample(photometric, bitspersample, samplesperpixel) == FALSE) {\n\t\t\tFreeImage_OutputMessageProc(s_format_id, \n\t\t\t\t\"Unable to handle this format: bitspersample = %d, samplesperpixel = %d, photometric = %d\", \n\t\t\t\t(int)bitspersample, (int)samplesperpixel, (int)photometric);\n\t\t\tthrow (char*)NULL;\n\t\t}\n\n\t\t// ---------------------------------------------------------------------------------\n\n\t\t// get image data type\n\n\t\tFREE_IMAGE_TYPE image_type = ReadImageType(tif, bitspersample, samplesperpixel);\n\n\t\t// get the most appropriate loading method\n\n\t\tTIFFLoadMethod loadMethod = FindLoadMethod(tif, image_type, flags);\n\n\t\t// ---------------------------------------------------------------------------------\n\n\t\tif(loadMethod == LoadAsRBGA) {\n\t\t\t// ---------------------------------------------------------------------------------\n\t\t\t// RGB[A] loading using the TIFFReadRGBAImage() API\n\t\t\t// ---------------------------------------------------------------------------------\n\n\t\t\tBOOL has_alpha = FALSE;   \n\n\t\t\t// Read the whole image into one big RGBA buffer and then \n\t\t\t// convert it to a DIB. This is using the traditional\n\t\t\t// TIFFReadRGBAImage() API that we trust.\n\t\t\t\n\t\t\tuint32 *raster = NULL;\n\n\t\t\tif(!header_only) {\n\n\t\t\t\traster = (uint32*)_TIFFmalloc(width * height * sizeof(uint32));\n\t\t\t\tif (raster == NULL) {\n\t\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t\t}\n\n\t\t\t\t// read the image in one chunk into an RGBA array\n\n\t\t\t\tif (!TIFFReadRGBAImage(tif, width, height, raster, 1)) {\n\t\t\t\t\t_TIFFfree(raster);\n\t\t\t\t\tthrow FI_MSG_ERROR_UNSUPPORTED_FORMAT;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TIFFReadRGBAImage always deliveres 3 or 4 samples per pixel images\n\t\t\t// (RGB or RGBA, see below). Cut-off possibly present channels (additional \n\t\t\t// alpha channels) from e.g. Photoshop. Any CMYK(A..) is now treated as RGB,\n\t\t\t// any additional alpha channel on RGB(AA..) is lost on conversion to RGB(A)\n\n\t\t\tif(samplesperpixel > 4) { // TODO Write to Extra Channels\n\t\t\t\tFreeImage_OutputMessageProc(s_format_id, \"Warning: %d additional alpha channel(s) ignored\", samplesperpixel-4);\n\t\t\t\tsamplesperpixel = 4;\n\t\t\t}\n\n\t\t\t// create a new DIB (take care of different samples-per-pixel in case \n\t\t\t// of converted CMYK image (RGB conversion is on sample per pixel less)\n\n\t\t\tif (photometric == PHOTOMETRIC_SEPARATED && samplesperpixel == 4) {\n\t\t\t\tsamplesperpixel = 3;\n\t\t\t}\n\n\t\t\tdib = CreateImageType(header_only, image_type, width, height, bitspersample, samplesperpixel);\n\t\t\tif (dib == NULL) {\n\t\t\t\t// free the raster pointer and output an error if allocation failed\n\t\t\t\tif(raster) {\n\t\t\t\t\t_TIFFfree(raster);\n\t\t\t\t}\n\t\t\t\tthrow FI_MSG_ERROR_DIB_MEMORY;\n\t\t\t}\n\t\t\t\n\t\t\t// fill in the resolution (english or universal)\n\n\t\t\tReadResolution(tif, dib);\n\n\t\t\tif(!header_only) {\n\n\t\t\t\t// read the raster lines and save them in the DIB\n\t\t\t\t// with RGB mode, we have to change the order of the 3 samples RGB\n\t\t\t\t// We use macros for extracting components from the packed ABGR \n\t\t\t\t// form returned by TIFFReadRGBAImage.\n\n\t\t\t\tuint32 *row = &raster[0];\n\n\t\t\t\tif (samplesperpixel == 4) {\n\t\t\t\t\t// 32-bit RGBA\n\t\t\t\t\tfor (uint32 y = 0; y < height; y++) {\n\t\t\t\t\t\tBYTE *bits = FreeImage_GetScanLine(dib, y);\n\t\t\t\t\t\tfor (uint32 x = 0; x < width; x++) {\n\t\t\t\t\t\t\tbits[FI_RGBA_BLUE]\t= (BYTE)TIFFGetB(row[x]);\n\t\t\t\t\t\t\tbits[FI_RGBA_GREEN] = (BYTE)TIFFGetG(row[x]);\n\t\t\t\t\t\t\tbits[FI_RGBA_RED]\t= (BYTE)TIFFGetR(row[x]);\n\t\t\t\t\t\t\tbits[FI_RGBA_ALPHA] = (BYTE)TIFFGetA(row[x]);\n\n\t\t\t\t\t\t\tif (bits[FI_RGBA_ALPHA] != 0) {\n\t\t\t\t\t\t\t\thas_alpha = TRUE;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbits += 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trow += width;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// 24-bit RGB\n\t\t\t\t\tfor (uint32 y = 0; y < height; y++) {\n\t\t\t\t\t\tBYTE *bits = FreeImage_GetScanLine(dib, y);\n\t\t\t\t\t\tfor (uint32 x = 0; x < width; x++) {\n\t\t\t\t\t\t\tbits[FI_RGBA_BLUE]\t= (BYTE)TIFFGetB(row[x]);\n\t\t\t\t\t\t\tbits[FI_RGBA_GREEN] = (BYTE)TIFFGetG(row[x]);\n\t\t\t\t\t\t\tbits[FI_RGBA_RED]\t= (BYTE)TIFFGetR(row[x]);\n\n\t\t\t\t\t\t\tbits += 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trow += width;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t_TIFFfree(raster);\n\t\t\t}\n\t\t\t\n\t\t\t// ### Not correct when header only\n\t\t\tFreeImage_SetTransparent(dib, has_alpha);\n\n\t\t} else if(loadMethod == LoadAs8BitTrns) {\n\t\t\t// ---------------------------------------------------------------------------------\n\t\t\t// 8-bit + 8-bit alpha layer loading\n\t\t\t// ---------------------------------------------------------------------------------\n\n\t\t\t// create a new 8-bit DIB\n\t\t\tdib = CreateImageType(header_only, image_type, width, height, bitspersample, MIN<uint16>(2, samplesperpixel));\n\t\t\tif (dib == NULL) {\n\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t}\n\n\t\t\t// fill in the resolution (english or universal)\n\n\t\t\tReadResolution(tif, dib);\n\n\t\t\t// set up the colormap based on photometric\t\n\n\t\t\tReadPalette(tif, photometric, bitspersample, dib);\n\n\t\t\t// calculate the line + pitch (separate for scr & dest)\n\n\t\t\tconst tmsize_t src_line = TIFFScanlineSize(tif);\n\t\t\t// here, the pitch is 2x less than the original as we only keep the first layer\t\t\t\t\n\t\t\tint dst_pitch = FreeImage_GetPitch(dib);\n\n\t\t\t// transparency table for 8-bit + 8-bit alpha images\n\n\t\t\tBYTE trns[256]; \n\t\t\t// clear the transparency table\n\t\t\tmemset(trns, 0xFF, 256 * sizeof(BYTE));\n\n\t\t\t// In the tiff file the lines are saved from up to down \n\t\t\t// In a DIB the lines must be saved from down to up\n\n\t\t\tBYTE *bits = FreeImage_GetScanLine(dib, height - 1);\n\n\t\t\t// read the tiff lines and save them in the DIB\n\n\t\t\tif(planar_config == PLANARCONFIG_CONTIG && !header_only) {\n\n\t\t\t\tBYTE *buf = (BYTE*)malloc(TIFFStripSize(tif) * sizeof(BYTE));\n\t\t\t\tif(buf == NULL) {\n\t\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t\t}\n\n\t\t\t\tfor (uint32 y = 0; y < height; y += rowsperstrip) {\n\t\t\t\t\tint32 nrow = (y + rowsperstrip > height ? height - y : rowsperstrip);\n\n\t\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, 0), buf, nrow * src_line) == -1) {\n\t\t\t\t\t\tfree(buf);\n\t\t\t\t\t\tthrow FI_MSG_ERROR_PARSING;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int l = 0; l < nrow; l++) {\n\t\t\t\t\t\tBYTE *p = bits;\n\t\t\t\t\t\tBYTE *b = buf + l * src_line;\n\n\t\t\t\t\t\tfor(uint32 x = 0; x < (uint32)(src_line / samplesperpixel); x++) {\n\t\t\t\t\t\t\t// copy the 8-bit layer\n\t\t\t\t\t\t\t*p = b[0];\n\t\t\t\t\t\t\t// convert the 8-bit alpha layer to a trns table\n\t\t\t\t\t\t\ttrns[ b[0] ] = b[1];\n\n\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\tb += samplesperpixel;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbits -= dst_pitch;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfree(buf);\n\t\t\t}\n\t\t\telse if(planar_config == PLANARCONFIG_SEPARATE && !header_only) {\n\t\t\t\ttmsize_t stripsize = TIFFStripSize(tif) * sizeof(BYTE);\n\t\t\t\tBYTE *buf = (BYTE*)malloc(2 * stripsize);\n\t\t\t\tif(buf == NULL) {\n\t\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t\t}\n\t\t\t\tBYTE *grey = buf;\n\t\t\t\tBYTE *alpha = buf + stripsize;\n\n\t\t\t\tfor (uint32 y = 0; y < height; y += rowsperstrip) {\n\t\t\t\t\tint32 nrow = (y + rowsperstrip > height ? height - y : rowsperstrip);\n\n\t\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, 0), grey, nrow * src_line) == -1) {\n\t\t\t\t\t\tfree(buf);\n\t\t\t\t\t\tthrow FI_MSG_ERROR_PARSING;\n\t\t\t\t\t} \n\t\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, 1), alpha, nrow * src_line) == -1) {\n\t\t\t\t\t\tfree(buf);\n\t\t\t\t\t\tthrow FI_MSG_ERROR_PARSING;\n\t\t\t\t\t} \n\n\t\t\t\t\tfor (int l = 0; l < nrow; l++) {\n\t\t\t\t\t\tBYTE *p = bits;\n\t\t\t\t\t\tBYTE *g = grey + l * src_line;\n\t\t\t\t\t\tBYTE *a = alpha + l * src_line;\n\n\t\t\t\t\t\tfor(uint32 x = 0; x < (uint32)(src_line); x++) {\n\t\t\t\t\t\t\t// copy the 8-bit layer\n\t\t\t\t\t\t\t*p = g[0];\n\t\t\t\t\t\t\t// convert the 8-bit alpha layer to a trns table\n\t\t\t\t\t\t\ttrns[ g[0] ] = a[0];\n\n\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\tg++;\n\t\t\t\t\t\t\ta++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbits -= dst_pitch;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfree(buf);\n\n\t\t\t}\n\t\t\t\n\t\t\tFreeImage_SetTransparencyTable(dib, &trns[0], 256);\n\t\t\tFreeImage_SetTransparent(dib, TRUE);\n\n\t\t} else if(loadMethod == LoadAsCMYK) {\n\t\t\t// ---------------------------------------------------------------------------------\n\t\t\t// CMYK loading\n\t\t\t// ---------------------------------------------------------------------------------\n\n\t\t\t// At this place, samplesperpixel could be > 4, esp. when a CMYK(A) format\n\t\t\t// is recognized. Where all other formats are handled straight-forward, this\n\t\t\t// format has to be handled special \n\n\t\t\tBOOL isCMYKA = (photometric == PHOTOMETRIC_SEPARATED) && (samplesperpixel > 4);\n\n\t\t\t// We use a temp dib to store the alpha for the CMYKA to RGBA conversion\n\t\t\t// NOTE this is until we have Extra channels implementation.\n\t\t\t// Also then it will be possible to merge LoadAsCMYK with LoadAsGenericStrip\n\t\t\t\n\t\t\tFIBITMAP *alpha = NULL;\n\t\t\tunsigned alpha_pitch = 0;\n\t\t\tBYTE *alpha_bits = NULL;\n\t\t\tunsigned alpha_Bpp = 0;\n\n\t\t\tif(isCMYKA && !asCMYK && !header_only) {\n\t\t\t\tif(bitspersample == 16) {\n\t\t\t\t\talpha = FreeImage_AllocateT(FIT_UINT16, width, height);\n\t\t\t\t} else if (bitspersample == 8) {\n\t\t\t\t\talpha = FreeImage_Allocate(width, height, 8);\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tif(!alpha) {\n\t\t\t\t\tFreeImage_OutputMessageProc(s_format_id, \"Failed to allocate temporary alpha channel\");\n\t\t\t\t} else {\n\t\t\t\t\talpha_bits = FreeImage_GetScanLine(alpha, height - 1);\n\t\t\t\t\talpha_pitch = FreeImage_GetPitch(alpha);\n\t\t\t\t\talpha_Bpp = FreeImage_GetBPP(alpha) / 8;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// create a new DIB\n\t\t\tconst uint16 chCount = MIN<uint16>(samplesperpixel, 4);\n\t\t\tdib = CreateImageType(header_only, image_type, width, height, bitspersample, chCount);\n\t\t\tif (dib == NULL) {\n\t\t\t\tFreeImage_Unload(alpha);\n\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t}\n\n\t\t\t// fill in the resolution (english or universal)\n\n\t\t\tReadResolution(tif, dib);\n\n\t\t\tif(!header_only) {\n\n\t\t\t\t// calculate the line + pitch (separate for scr & dest)\n\n\t\t\t\tconst tmsize_t src_line = TIFFScanlineSize(tif);\n\t\t\t\tconst tmsize_t dst_line = FreeImage_GetLine(dib);\n\t\t\t\tconst unsigned dib_pitch = FreeImage_GetPitch(dib);\n\t\t\t\tconst unsigned dibBpp = FreeImage_GetBPP(dib) / 8;\n\t\t\t\tconst unsigned Bpc = dibBpp / chCount;\n\t\t\t\tconst unsigned srcBpp = bitspersample * samplesperpixel / 8;\n\n\t\t\t\tassert(Bpc <= 2); //< CMYK is only BYTE or SHORT \n\t\t\t\t\n\t\t\t\t// In the tiff file the lines are save from up to down \n\t\t\t\t// In a DIB the lines must be saved from down to up\n\n\t\t\t\tBYTE *bits = FreeImage_GetScanLine(dib, height - 1);\n\n\t\t\t\t// read the tiff lines and save them in the DIB\n\n\t\t\t\tBYTE *buf = (BYTE*)malloc(TIFFStripSize(tif) * sizeof(BYTE));\n\t\t\t\tif(buf == NULL) {\n\t\t\t\t\tFreeImage_Unload(alpha);\n\t\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t\t}\n\n\t\t\t\tif(planar_config == PLANARCONFIG_CONTIG) {\n\t\t\t\t\t\n\t\t\t\t\t// - loop for strip blocks -\n\t\t\t\t\t\n\t\t\t\t\tfor (uint32 y = 0; y < height; y += rowsperstrip) {\n\t\t\t\t\t\tconst int32 strips = (y + rowsperstrip > height ? height - y : rowsperstrip);\n\n\t\t\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, 0), buf, strips * src_line) == -1) {\n\t\t\t\t\t\t\tfree(buf);\n\t\t\t\t\t\t\tFreeImage_Unload(alpha);\n\t\t\t\t\t\t\tthrow FI_MSG_ERROR_PARSING;\n\t\t\t\t\t\t} \n\t\t\t\t\t\t\n\t\t\t\t\t\t// - loop for strips -\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(src_line != dst_line) {\n\t\t\t\t\t\t\t// CMYKA+\n\t\t\t\t\t\t\tif(alpha) {\n\t\t\t\t\t\t\t\tfor (int l = 0; l < strips; l++) {\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tfor(BYTE *pixel = bits, *al_pixel = alpha_bits, *src_pixel =  buf + l * src_line; pixel < bits + dib_pitch; pixel += dibBpp, al_pixel += alpha_Bpp, src_pixel += srcBpp) {\n\t\t\t\t\t\t\t\t\t\t// copy pixel byte by byte\n\t\t\t\t\t\t\t\t\t\tBYTE b = 0;\n\t\t\t\t\t\t\t\t\t\tfor( ; b < dibBpp; ++b) {\n\t\t\t\t\t\t\t\t\t\t\tpixel[b] =  src_pixel[b];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// TODO write the remaining bytes to extra channel(s)\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t// HACK write the first alpha to a separate dib (assume BYTE or WORD)\n\t\t\t\t\t\t\t\t\t\tal_pixel[0] = src_pixel[b];\n\t\t\t\t\t\t\t\t\t\tif(Bpc > 1) {\n\t\t\t\t\t\t\t\t\t\t\tal_pixel[1] = src_pixel[b + 1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbits -= dib_pitch;\n\t\t\t\t\t\t\t\t\talpha_bits -= alpha_pitch;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// alpha/extra channels alloc failed\n\t\t\t\t\t\t\t\tfor (int l = 0; l < strips; l++) {\n\t\t\t\t\t\t\t\t\tfor(BYTE* pixel = bits, * src_pixel =  buf + l * src_line; pixel < bits + dst_line; pixel += dibBpp, src_pixel += srcBpp) {\n\t\t\t\t\t\t\t\t\t\tAssignPixel(pixel, src_pixel, dibBpp);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbits -= dib_pitch;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { \n\t\t\t\t\t\t\t// CMYK to CMYK\n\t\t\t\t\t\t\tfor (int l = 0; l < strips; l++) {\n\t\t\t\t\t\t\t\tBYTE *b = buf + l * src_line;\n\t\t\t\t\t\t\t\tmemcpy(bits, b, src_line);\n\t\t\t\t\t\t\t\tbits -= dib_pitch;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // height\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if(planar_config == PLANARCONFIG_SEPARATE) {\n\n\t\t\t\t\tBYTE *dib_strip = bits;\n\t\t\t\t\tBYTE *al_strip = alpha_bits;\n\n\t\t\t\t\t// - loop for strip blocks -\n\t\t\t\t\t\n\t\t\t\t\tfor (uint32 y = 0; y < height; y += rowsperstrip) {\n\t\t\t\t\t\tconst int32 strips = (y + rowsperstrip > height ? height - y : rowsperstrip);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// - loop for channels (planes) -\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(uint16 sample = 0; sample < samplesperpixel; sample++) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, sample), buf, strips * src_line) == -1) {\n\t\t\t\t\t\t\t\tfree(buf);\n\t\t\t\t\t\t\t\tFreeImage_Unload(alpha);\n\t\t\t\t\t\t\t\tthrow FI_MSG_ERROR_PARSING;\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tBYTE *dst_strip = dib_strip;\n\t\t\t\t\t\t\tunsigned dst_pitch = dib_pitch;\n\t\t\t\t\t\t\tuint16 ch = sample;\n\t\t\t\t\t\t\tunsigned Bpp = dibBpp;\n\n\t\t\t\t\t\t\tif(sample >= chCount) {\n\t\t\t\t\t\t\t\t// TODO Write to Extra Channel\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// HACK redirect write to temp alpha\n\t\t\t\t\t\t\t\tif(alpha && sample == chCount) {\n\n\t\t\t\t\t\t\t\t\tdst_strip = al_strip;\n\t\t\t\t\t\t\t\t\tdst_pitch = alpha_pitch;\n\n\t\t\t\t\t\t\t\t\tch = 0;\n\t\t\t\t\t\t\t\t\tBpp = alpha_Bpp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tbreak; \n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tconst unsigned channelOffset = ch * Bpc;\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// - loop for strips in block -\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tBYTE *src_line_begin = buf;\n\t\t\t\t\t\t\tBYTE *dst_line_begin = dst_strip;\n\t\t\t\t\t\t\tfor (int l = 0; l < strips; l++, src_line_begin += src_line, dst_line_begin -= dst_pitch ) {\n\t\t\t\t\t\t\t\t// - loop for pixels in strip -\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tconst BYTE* const src_line_end = src_line_begin + src_line;\n\t\t\t\t\t\t\t\tfor (BYTE *src_bits = src_line_begin, * dst_bits = dst_line_begin; src_bits < src_line_end; src_bits += Bpc, dst_bits += Bpp) {\n\t\t\t\t\t\t\t\t\tAssignPixel(dst_bits + channelOffset, src_bits, Bpc);\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t} // line\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} // strips\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t} // channels\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t// done with a strip block, incr to the next\n\t\t\t\t\t\tdib_strip -= strips * dib_pitch;\n\t\t\t\t\t\tal_strip -= strips * alpha_pitch;\n\t\t\t\t\t\t\t\n\t\t\t\t\t} //< height\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\tfree(buf);\n\t\t\t\n\t\t\t\tif(!asCMYK) {\n\t\t\t\t\tConvertCMYKtoRGBA(dib);\n\t\t\t\t\t\n\t\t\t\t\t// The ICC Profile is invalid, clear it\n\t\t\t\t\ticcSize = 0;\n\t\t\t\t\ticcBuf = NULL;\n\t\t\t\t\t\n\t\t\t\t\tif(isCMYKA) {\n\t\t\t\t\t\t// HACK until we have Extra channels. (ConvertCMYKtoRGBA will then do the work)\n\t\t\t\t\t\t\n\t\t\t\t\t\tFreeImage_SetChannel(dib, alpha, FICC_ALPHA);\n\t\t\t\t\t\tFreeImage_Unload(alpha);\n\t\t\t\t\t\talpha = NULL;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tFIBITMAP *t = RemoveAlphaChannel(dib);\n\t\t\t\t\t\tif(t) {\n\t\t\t\t\t\t\tFreeImage_Unload(dib);\n\t\t\t\t\t\t\tdib = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tFreeImage_OutputMessageProc(s_format_id, \"Cannot allocate memory for buffer. CMYK image converted to RGB + pending Alpha\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} // !header_only\n\t\t\t\n\t\t} else if(loadMethod == LoadAsGenericStrip) {\n\t\t\t// ---------------------------------------------------------------------------------\n\t\t\t// Generic loading\n\t\t\t// ---------------------------------------------------------------------------------\n\n\t\t\t// create a new DIB\n\t\t\tconst uint16 chCount = MIN<uint16>(samplesperpixel, 4);\n\t\t\tdib = CreateImageType(header_only, image_type, width, height, bitspersample, chCount);\n\t\t\tif (dib == NULL) {\n\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t}\n\n\t\t\t// fill in the resolution (english or universal)\n\n\t\t\tReadResolution(tif, dib);\n\n\t\t\t// set up the colormap based on photometric\t\n\n\t\t\tReadPalette(tif, photometric, bitspersample, dib);\n\t\n\t\t\tif(!header_only) {\n\t\t\t\t// calculate the line + pitch (separate for scr & dest)\n\n\t\t\t\tconst tmsize_t src_line = TIFFScanlineSize(tif);\n\t\t\t\tconst tmsize_t dst_line = FreeImage_GetLine(dib);\n\t\t\t\tconst unsigned dst_pitch = FreeImage_GetPitch(dib);\n\t\t\t\tconst unsigned Bpp = FreeImage_GetBPP(dib) / 8;\n\t\t\t\tconst unsigned srcBpp = bitspersample * samplesperpixel / 8;\n\n\t\t\t\t// In the tiff file the lines are save from up to down \n\t\t\t\t// In a DIB the lines must be saved from down to up\n\n\t\t\t\tBYTE *bits = FreeImage_GetScanLine(dib, height - 1);\n\n\t\t\t\t// read the tiff lines and save them in the DIB\n\n\t\t\t\tBYTE *buf = (BYTE*)malloc(TIFFStripSize(tif) * sizeof(BYTE));\n\t\t\t\tif(buf == NULL) {\n\t\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t\t}\n\t\t\t\tmemset(buf, 0, TIFFStripSize(tif) * sizeof(BYTE));\n\t\t\t\t\n\t\t\t\tBOOL bThrowMessage = FALSE;\n\t\t\t\t\n\t\t\t\tif(planar_config == PLANARCONFIG_CONTIG) {\n\n\t\t\t\t\tfor (uint32 y = 0; y < height; y += rowsperstrip) {\n\t\t\t\t\t\tint32 strips = (y + rowsperstrip > height ? height - y : rowsperstrip);\n\n\t\t\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, 0), buf, strips * src_line) == -1) {\n\t\t\t\t\t\t\t// ignore errors as they can be frequent and not really valid errors, especially with fax images\n\t\t\t\t\t\t\tbThrowMessage = TRUE;\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tfree(buf);\n\t\t\t\t\t\t\tthrow FI_MSG_ERROR_PARSING;\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t} \n\t\t\t\t\t\tif(src_line == dst_line) {\n\t\t\t\t\t\t\t// channel count match\n\t\t\t\t\t\t\tfor (int l = 0; l < strips; l++) {\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tmemcpy(bits, buf + l * src_line, src_line);\n\t\t\t\t\t\t\t\tbits -= dst_pitch;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfor (int l = 0; l < strips; l++) {\n\t\t\t\t\t\t\t\tfor(BYTE *pixel = bits, *src_pixel =  buf + l * src_line; pixel < bits + dst_pitch; pixel += Bpp, src_pixel += srcBpp) {\n\t\t\t\t\t\t\t\t\tAssignPixel(pixel, src_pixel, Bpp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbits -= dst_pitch;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(planar_config == PLANARCONFIG_SEPARATE) {\n\t\t\t\t\t\n\t\t\t\t\tconst unsigned Bpc = bitspersample / 8;\n\t\t\t\t\tBYTE* dib_strip = bits;\n\t\t\t\t\t// - loop for strip blocks -\n\t\t\t\t\t\n\t\t\t\t\tfor (uint32 y = 0; y < height; y += rowsperstrip) {\n\t\t\t\t\t\tconst int32 strips = (y + rowsperstrip > height ? height - y : rowsperstrip);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// - loop for channels (planes) -\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(uint16 sample = 0; sample < samplesperpixel; sample++) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, sample), buf, strips * src_line) == -1) {\n\t\t\t\t\t\t\t\t// ignore errors as they can be frequent and not really valid errors, especially with fax images\n\t\t\t\t\t\t\t\tbThrowMessage = TRUE;\t\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(sample >= chCount) {\n\t\t\t\t\t\t\t\t// TODO Write to Extra Channel\n\t\t\t\t\t\t\t\tbreak; \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tconst unsigned channelOffset = sample * Bpc;\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// - loop for strips in block -\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tBYTE* src_line_begin = buf;\n\t\t\t\t\t\t\tBYTE* dst_line_begin = dib_strip;\n\t\t\t\t\t\t\tfor (int l = 0; l < strips; l++, src_line_begin += src_line, dst_line_begin -= dst_pitch ) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// - loop for pixels in strip -\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tconst BYTE* const src_line_end = src_line_begin + src_line;\n\n\t\t\t\t\t\t\t\tfor (BYTE* src_bits = src_line_begin, * dst_bits = dst_line_begin; src_bits < src_line_end; src_bits += Bpc, dst_bits += Bpp) {\n\t\t\t\t\t\t\t\t\t// actually assigns channel\n\t\t\t\t\t\t\t\t\tAssignPixel(dst_bits + channelOffset, src_bits, Bpc); \n\t\t\t\t\t\t\t\t} // line\n\n\t\t\t\t\t\t\t} // strips\n\n\t\t\t\t\t\t} // channels\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t// done with a strip block, incr to the next\n\t\t\t\t\t\tdib_strip -= strips * dst_pitch;\n\t\t\t\t\t\t\t\n\t\t\t\t\t} // height\n\n\t\t\t\t}\n\t\t\t\tfree(buf);\n\t\t\t\t\n\t\t\t\tif(bThrowMessage) {\n\t\t\t\t\tFreeImage_OutputMessageProc(s_format_id, \"Warning: parsing error. Image may be incomplete or contain invalid data !\");\n\t\t\t\t}\n\t\t\t\t\n#if FREEIMAGE_COLORORDER == FREEIMAGE_COLORORDER_BGR\n\t\t\t\tSwapRedBlue32(dib);\n#endif\n\n\t\t\t} // !header only\n\t\t\t\n\t\t} else if(loadMethod == LoadAsTiled) {\n\t\t\t// ---------------------------------------------------------------------------------\n\t\t\t// Tiled image loading\n\t\t\t// ---------------------------------------------------------------------------------\n\n\t\t\tuint32 tileWidth, tileHeight;\n\t\t\tuint32 src_line = 0;\n\n\t\t\t// create a new DIB\n\t\t\tdib = CreateImageType( header_only, image_type, width, height, bitspersample, samplesperpixel);\n\t\t\tif (dib == NULL) {\n\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t}\n\n\t\t\t// fill in the resolution (english or universal)\n\n\t\t\tReadResolution(tif, dib);\n\n\t\t\t// set up the colormap based on photometric\t\n\n\t\t\tReadPalette(tif, photometric, bitspersample, dib);\n\n\t\t\t// get the tile geometry\n\t\t\tif(!TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tileWidth) || !TIFFGetField(tif, TIFFTAG_TILELENGTH, &tileHeight)) {\n\t\t\t\tthrow \"Invalid tiled TIFF image\";\n\t\t\t}\n\n\t\t\t// read the tiff lines and save them in the DIB\n\n\t\t\tif(planar_config == PLANARCONFIG_CONTIG && !header_only) {\n\t\t\t\t\n\t\t\t\t// get the maximum number of bytes required to contain a tile\n\t\t\t\ttmsize_t tileSize = TIFFTileSize(tif);\n\n\t\t\t\t// allocate tile buffer\n\t\t\t\tBYTE *tileBuffer = (BYTE*)malloc(tileSize * sizeof(BYTE));\n\t\t\t\tif(tileBuffer == NULL) {\n\t\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t\t}\n\n\t\t\t\t// calculate src line and dst pitch\n\t\t\t\tint dst_pitch = FreeImage_GetPitch(dib);\n\t\t\t\tuint32 tileRowSize = (uint32)TIFFTileRowSize(tif);\n\t\t\t\tuint32 imageRowSize = (uint32)TIFFScanlineSize(tif);\n\n\n\t\t\t\t// In the tiff file the lines are saved from up to down \n\t\t\t\t// In a DIB the lines must be saved from down to up\n\n\t\t\t\tBYTE *bits = FreeImage_GetScanLine(dib, height - 1);\n\t\t\t\t\n\t\t\t\tfor (uint32 y = 0; y < height; y += tileHeight) {\t\t\t\t\t\t\n\t\t\t\t\tint32 nrows = (y + tileHeight > height ? height - y : tileHeight);\t\t\t\t\t\n\n\t\t\t\t\tfor (uint32 x = 0, rowSize = 0; x < width; x += tileWidth, rowSize += tileRowSize) {\n\t\t\t\t\t\tmemset(tileBuffer, 0, tileSize);\n\n\t\t\t\t\t\t// read one tile\n\t\t\t\t\t\tif (TIFFReadTile(tif, tileBuffer, x, y, 0, 0) < 0) {\n\t\t\t\t\t\t\tfree(tileBuffer);\n\t\t\t\t\t\t\tthrow \"Corrupted tiled TIFF file\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// convert to strip\n\t\t\t\t\t\tif(x + tileWidth > width) {\n\t\t\t\t\t\t\tsrc_line = imageRowSize - rowSize;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsrc_line = tileRowSize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tBYTE *src_bits = tileBuffer;\n\t\t\t\t\t\tBYTE *dst_bits = bits + rowSize;\n\t\t\t\t\t\tfor(int k = 0; k < nrows; k++) {\n\t\t\t\t\t\t\tmemcpy(dst_bits, src_bits, src_line);\n\t\t\t\t\t\t\tsrc_bits += tileRowSize;\n\t\t\t\t\t\t\tdst_bits -= dst_pitch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbits -= nrows * dst_pitch;\n\t\t\t\t}\n\n#if FREEIMAGE_COLORORDER == FREEIMAGE_COLORORDER_BGR\n\t\t\t\tSwapRedBlue32(dib);\n#endif\n\t\t\t\tfree(tileBuffer);\n\t\t\t}\n\t\t\telse if(planar_config == PLANARCONFIG_SEPARATE) {\n\t\t\t\tthrow \"Separated tiled TIFF images are not supported\"; \n\t\t\t}\n\n\n\t\t} else if(loadMethod == LoadAsLogLuv) {\n\t\t\t// ---------------------------------------------------------------------------------\n\t\t\t// RGBF LogLuv compressed loading\n\t\t\t// ---------------------------------------------------------------------------------\n\n\t\t\tdouble\tstonits;\t// input conversion to nits\n\t\t\tif (!TIFFGetField(tif, TIFFTAG_STONITS, &stonits)) {\n\t\t\t\tstonits = 1;\n\t\t\t}\n\t\t\t\n\t\t\t// create a new DIB\n\t\t\tdib = CreateImageType(header_only, image_type, width, height, bitspersample, samplesperpixel);\n\t\t\tif (dib == NULL) {\n\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t}\n\n\t\t\t// fill in the resolution (english or universal)\n\n\t\t\tReadResolution(tif, dib);\n\n\t\t\tif(planar_config == PLANARCONFIG_CONTIG && !header_only) {\n\t\t\t\t// calculate the line + pitch (separate for scr & dest)\n\n\t\t\t\ttmsize_t src_line = TIFFScanlineSize(tif);\n\t\t\t\tint dst_pitch = FreeImage_GetPitch(dib);\n\n\t\t\t\t// In the tiff file the lines are save from up to down \n\t\t\t\t// In a DIB the lines must be saved from down to up\n\n\t\t\t\tBYTE *bits = FreeImage_GetScanLine(dib, height - 1);\n\n\t\t\t\t// read the tiff lines and save them in the DIB\n\n\t\t\t\tBYTE *buf = (BYTE*)malloc(TIFFStripSize(tif) * sizeof(BYTE));\n\t\t\t\tif(buf == NULL) {\n\t\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t\t}\n\n\t\t\t\tfor (uint32 y = 0; y < height; y += rowsperstrip) {\n\t\t\t\t\tint32 nrow = (y + rowsperstrip > height ? height - y : rowsperstrip);\n\n\t\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, 0), buf, nrow * src_line) == -1) {\n\t\t\t\t\t\tfree(buf);\n\t\t\t\t\t\tthrow FI_MSG_ERROR_PARSING;\n\t\t\t\t\t} \n\t\t\t\t\t// convert from XYZ to RGB\n\t\t\t\t\tfor (int l = 0; l < nrow; l++) {\t\t\t\t\t\t\n\t\t\t\t\t\ttiff_ConvertLineXYZToRGB(bits, buf + l * src_line, stonits, width);\n\t\t\t\t\t\tbits -= dst_pitch;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfree(buf);\n\t\t\t}\n\t\t\telse if(planar_config == PLANARCONFIG_SEPARATE) {\n\t\t\t\t// this cannot happen according to the LogLuv specification\n\t\t\t\tthrow \"Unable to handle PLANARCONFIG_SEPARATE LogLuv images\";\n\t\t\t}\n\n\t\t} else if(loadMethod == LoadAsHalfFloat) {\n\t\t\t// ---------------------------------------------------------------------------------\n\t\t\t// RGBF loading from a half format\n\t\t\t// ---------------------------------------------------------------------------------\n\n\t\t\t// create a new DIB\n\t\t\tdib = CreateImageType(header_only, image_type, width, height, bitspersample, samplesperpixel);\n\t\t\tif (dib == NULL) {\n\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t}\n\n\t\t\t// fill in the resolution (english or universal)\n\n\t\t\tReadResolution(tif, dib);\n\n\t\t\tif(!header_only) {\n\n\t\t\t\t// calculate the line + pitch (separate for scr & dest)\n\n\t\t\t\ttmsize_t src_line = TIFFScanlineSize(tif);\n\t\t\t\tunsigned dst_pitch = FreeImage_GetPitch(dib);\n\n\t\t\t\t// In the tiff file the lines are save from up to down \n\t\t\t\t// In a DIB the lines must be saved from down to up\n\n\t\t\t\tBYTE *bits = FreeImage_GetScanLine(dib, height - 1);\n\n\t\t\t\t// read the tiff lines and save them in the DIB\n\n\t\t\t\tif(planar_config == PLANARCONFIG_CONTIG) {\n\n\t\t\t\t\tBYTE *buf = (BYTE*)malloc(TIFFStripSize(tif) * sizeof(BYTE));\n\t\t\t\t\tif(buf == NULL) {\n\t\t\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (uint32 y = 0; y < height; y += rowsperstrip) {\n\t\t\t\t\t\tuint32 nrow = (y + rowsperstrip > height ? height - y : rowsperstrip);\n\n\t\t\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, 0), buf, nrow * src_line) == -1) {\n\t\t\t\t\t\t\tfree(buf);\n\t\t\t\t\t\t\tthrow FI_MSG_ERROR_PARSING;\n\t\t\t\t\t\t} \n\n\t\t\t\t\t\t// convert from half (16-bit) to float (32-bit)\n\t\t\t\t\t\t// !!! use OpenEXR half helper class\n\n\t\t\t\t\t\thalf half_value;\n\n\t\t\t\t\t\tfor (uint32 l = 0; l < nrow; l++) {\n\t\t\t\t\t\t\tWORD *src_pixel = (WORD*)(buf + l * src_line);\n\t\t\t\t\t\t\tfloat *dst_pixel = (float*)bits;\n\n\t\t\t\t\t\t\tfor(tmsize_t x = 0; x < (tmsize_t)(src_line / sizeof(WORD)); x++) {\n\t\t\t\t\t\t\t\thalf_value.setBits(src_pixel[x]);\n\t\t\t\t\t\t\t\tdst_pixel[x] = half_value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbits -= dst_pitch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfree(buf);\n\t\t\t\t}\n\t\t\t\telse if(planar_config == PLANARCONFIG_SEPARATE) {\n\t\t\t\t\t// this use case was never encountered yet\n\t\t\t\t\tthrow \"Unable to handle PLANARCONFIG_SEPARATE RGB half float images\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} // !header only\n\n\t\t} else {\n\t\t\t// ---------------------------------------------------------------------------------\n\t\t\t// Unknown or unsupported format\n\t\t\t// ---------------------------------------------------------------------------------\n\n\t\t\tthrow FI_MSG_ERROR_UNSUPPORTED_FORMAT;\n\t\t}\n\t\t\n\t\t// copy TIFF metadata (must be done after FreeImage_Allocate)\n\n\t\tReadMetadata(io, handle, tif, dib);\n\n\t\t// copy ICC profile data (must be done after FreeImage_Allocate)\n\t\t\n\t\tFreeImage_CreateICCProfile(dib, iccBuf, iccSize);\n\t\tif (photometric == PHOTOMETRIC_SEPARATED) {\n\t\t\tif (asCMYK) {\n\t\t\t\t// set the ICC profile as CMYK\n\t\t\t\tFreeImage_GetICCProfile(dib)->flags |= FIICC_COLOR_IS_CMYK;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// if original image is CMYK but is converted to RGB, remove ICC profile from Exif-TIFF metadata\n\t\t\t\tFreeImage_SetMetadata(FIMD_EXIF_MAIN, dib, \"InterColorProfile\", NULL);\n\t\t\t}\n\t\t}\n\n\t\t// copy TIFF thumbnail (must be done after FreeImage_Allocate)\n\t\t\n\t\tReadThumbnail(io, handle, data, tif, dib);\n\n\t\treturn dib;\n\n\t} catch (const char *message) {\t\t\t\n\t\tif(dib)\t{\n\t\t\tFreeImage_Unload(dib);\n\t\t}\n\t\tif(message) {\n\t\t\tFreeImage_OutputMessageProc(s_format_id, message);\n\t\t}\n\t\treturn NULL;\n\t}\n  \n}",
    "void EERRenderer::read(FileName _fn_movie, int eer_upsampling)\n{\n\tif (ready)\n\t\tREPORT_ERROR(\"Logic error: you cannot recycle EERRenderer for multiple files (now)\");\n\n\tif (eer_upsampling == -1 || eer_upsampling == 1 || eer_upsampling == 2 || eer_upsampling == 3)\n\t\tthis->eer_upsampling = eer_upsampling;\n\telse\n\t{\n\t\tstd::cerr << \"EERRenderer::read: eer_upsampling = \" << eer_upsampling << std::endl;\n\t\tREPORT_ERROR(\"EERRenderer::read: eer_upsampling must be -1, 1, 2 or 3.\");\n\t}\n\n\tfn_movie = _fn_movie;\n\n\t// First of all, check the file size\n\tFILE *fh = fopen(fn_movie.c_str(), \"r\");\n\tif (fh == NULL)\n\t\tREPORT_ERROR(\"Failed to open \" + fn_movie);\n\n\tfseek(fh, 0, SEEK_END);\n\tfile_size = ftell(fh);\n\tfseek(fh, 0, SEEK_SET);\n\n\tsilenceTIFFWarnings();\n\n\t// Try reading as TIFF\n\tTIFF *ftiff = TIFFOpen(fn_movie.c_str(), \"r\");\n\n\tif (ftiff == NULL)\n\t{\n\t\tis_legacy = true;\n\t\treadLegacy(fh);\n\t}\n\telse\n\t{\n\t\tis_legacy = false;\n\n\t\t// Check width & size\n\t\tuint16_t compression = 0;\n\t\tTIFFGetField(ftiff, TIFFTAG_IMAGEWIDTH, &width);\n\t\tTIFFGetField(ftiff, TIFFTAG_IMAGELENGTH, &height);\n\t\tTIFFGetField(ftiff, TIFFTAG_COMPRESSION, &compression);\n\n#ifdef DEBUG_EER\n\t\tprintf(\"EER in TIFF: %s size = %lld, width = %d, height = %d, compression = %d\\n\", fn_movie.c_str(), file_size, width, height, compression);\n#endif\n\n\t\t// TIA can write an EER file whose first page is a sum and compressoin == 1.\n\t\t// This is not supported (yet). EPU never writes such movies.\n\t\tif (compression == EERRenderer::TIFF_COMPRESSION_EER8bit)\n\t\t{\n\t\t\trle_bits = 8;\n\t\t\tsubpixel_bits = 4;\n\t\t}\n\t\telse if (compression == EERRenderer::TIFF_COMPRESSION_EER7bit)\n\t\t{\n\t\t\trle_bits = 7;\n\t\t\tsubpixel_bits = 4;\n\t\t}\n\t\telse if (compression == EERRenderer::TIFF_COMPRESSION_EERDetailed)\n\t\t{\n\t\t\t// See https://stackoverflow.com/questions/33522589/how-to-read-custom-tiff-tags-w-o-tifffieldinfo\n\t\t\t// and \"AUTOREGISTERED TAGS\" in https://manpages.debian.org/testing/libtiff-dev/TIFFGetField.3tiff.en.html.\n\t\t\tuint32_t count;\n\t\t\tuint16_t *rle, *subpix_h, *subpix_v;\n\n\t\t\tTIFFGetField(ftiff, EERRenderer::TIFFTAG_EER_RLE_DEPTH, &count, (void*)&rle);\n\t\t\trle_bits = *rle;\n\t\t\tTIFFGetField(ftiff, EERRenderer::TIFFTAG_EER_SUBPIXEL_H_DEPTH, &count, (void*)&subpix_h);\n\t\t\t// Prototype images apparently don't have TIFFTAG_EER_SUBPIXEL_V_DEPTH\n\t\t\tif (TIFFGetField(ftiff, EERRenderer::TIFFTAG_EER_SUBPIXEL_V_DEPTH, &count, (void*)&subpix_v) == 0)\n\t\t\t\tsubpix_v = subpix_h;\n\n\t\t\tif (rle_bits != 7 || *subpix_h != *subpix_v || *subpix_h != 1)\n\t\t\t{\n\t\t\t\tREPORT_ERROR(\"Unsupported compression scheme: type = \" + integerToString(compression) +\n\t\t\t\t             \", rle_bits = \" + integerToString(rle_bits) + \", subpix_h = \" + integerToString(*subpix_h) +\n\t\t\t\t             \", subpix_v = \" + integerToString(*subpix_v));\n\t\t\t}\n\t\t\tsubpixel_bits = 1 << *subpix_h;\n\n\t\t\tif (subpixel_bits == 2 && (eer_upsampling == -1 || eer_upsampling >= 3))\n\t\t\t{\n\t\t\t\tREPORT_ERROR(\"For subpixel_bits = 2, eer_upsamling must be 1 or 2.\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tREPORT_ERROR(\"Unknown compression scheme for EER: \" + integerToString(compression));\n\n\t\tif (width != height || (width != EER_4K && width != EER_2K))\n\t\t\tREPORT_ERROR(\"Currently we support only 4096x4096 or 2048x2048 pixel EER movies.\");\n\n\t\ttotal_pixels = (long long)width * height;\n\n\t\t// Find the number of frames\n\t\t// TODO: FIXME: an EER movie might contain a summed frame\n\t\tnframes = TIFFNumberOfDirectories(ftiff);\n\t\tTIFFClose(ftiff);\n#ifdef DEBUG_EER\n\t\tprintf(\"EER in TIFF: %s rle_bits = %d, subpixel_bits = %d, nframes = %d\\n\", fn_movie.c_str(), rle_bits, subpixel_bits, nframes);\n#endif\n\t}\n\n\tfclose(fh);\n\tready = true;\n}",
    "string read_acquisition_metadata(TIFF *tiff) {\n\tchar *metadata_c = nullptr;\n\tuint32_t count = 0;\n\n\tTIFFSetDirectory(tiff, 0);\n\tTIFFGetField(tiff, 65001, &count, &metadata_c);\n\n\treturn string(metadata_c, count);\n}",
    "auto read_compression(TIFF *tiff) {\n\tuint16_t compression = 0;\n\n\tTIFFGetField(tiff, TIFFTAG_COMPRESSION, &compression);\n\n\treturn compression;\n}",
    "int EerIO::read_header(Dict & dict, int image_index, const Region * area, bool is_3d)\n{\n\tTIFFSetDirectory(tiff_file, image_index);\n\n\tint nx = 0;\n\tint ny = 0;\n\n\tTIFFGetField(tiff_file, TIFFTAG_IMAGEWIDTH, &nx);\n\tTIFFGetField(tiff_file, TIFFTAG_IMAGELENGTH, &ny);\n\n\tdict[\"nx\"] = decoder.num_pix();\n\tdict[\"ny\"] = decoder.num_pix();\n\tdict[\"nz\"] = 1;\n\n\tdict[\"EER.compression\"] = read_compression(tiff_file);\n\n\tfor(auto &d : acquisition_data_dict)\n\t\tdict[d.first] = d.second;\n\n\tif(auto it = dict.find(\"EER.sensor_pixel_size.width\"); it != dict.end()) {\n\t\tif ((float)it->second == 0.0)\n\t\t\tdict[\"apix_x\"] = 1.0f;\n\t\telse\n\t\t\tdict[\"apix_x\"] = (float)it->second * (float)1.0e10;\n\t}\n\n\tif(auto it = dict.find(\"EER.sensor_pixel_size.height\"); it != dict.end()) {\n\t\tif ((float)it->second == 0.0)\n\t\t\tdict[\"apix_y\"] = 1.0f;\n\t\telse\n\t\t\tdict[\"apix_y\"] = (float)it->second * (float)1.0e10;\n\t}\n\n\tdict[\"apix_z\"] = dict[\"apix_x\"];\n\n\treturn 0;\n}",
    "void TiffIO::init()\n{\n\tENTERFUNC;\n\n\tif (initialized) {\n\t\treturn;\n\t}\n\n\tinitialized = true;\n\n\tbool is_new_file = false;\n\n\tFILE * tmp_in = sfopen(filename, rw_mode, & is_new_file, true);\n\n\tif (! tmp_in) {\n\t\tthrow ImageReadException(filename, \"open TIFF\");\n\t}\n\n\tif (! is_new_file) {\n\t\tchar buf[64];\n\n\t\tif (fread(buf, sizeof(buf), 1, tmp_in) != 1) {\n\t\t\tthrow ImageReadException(filename, \"first block\");\n\t\t}\n\n\t\tif (!is_valid(&buf)) {\n\t\t\tthrow ImageReadException(filename, \"invalid TIFF\");\n\t\t}\n\n        is_big_endian = (buf[0] == TIFF_BIG_ENDIAN);\n\t}\n\n\tfclose(tmp_in);\n\ttmp_in = 0;\n\n\tTIFFSetWarningHandler(0);\n\n\tif (rw_mode == ImageIO::READ_ONLY) {\n\t\ttiff_file = TIFFOpen(filename.c_str(), \"r\");\n\n\t\tif (! tiff_file) {\n\t\t\tthrow ImageReadException(filename, \"open TIFF\");\n\t\t}\n\n\t\tTIFFGetField(tiff_file, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\n\t\tif (bitspersample != CHAR_BIT &&\n\t\t\tbitspersample != (CHAR_BIT * sizeof(short)) &&\n\t\t\tbitspersample != (CHAR_BIT * sizeof(float)) ) {\n\n\t\t\tchar desc[256];\n\t\t\tsprintf(desc, \"invalid %d bits. only %d-bit and %d-bit TIFF are supported\",\n\t\t\t\t\tbitspersample, CHAR_BIT, (int)(CHAR_BIT * sizeof(short)));\n\t\t\tthrow ImageReadException(filename, desc);\n\t\t}\n\t}\n\telse {\n\t\ttiff_file = TIFFOpen(filename.c_str(), \"w\");\n\n\t\tif (! tiff_file) {\n\t\t\tthrow ImageReadException(filename, \"open TIFF\");\n\t\t}\n\t}\n\n\tif (tiff_file) {\n\t\tnimg = 0;\n\n\t\tdo {\n\t\t\tnimg++;\n\t\t} while (TIFFReadDirectory(tiff_file));\n\t}\n\n\tEXITFUNC;\n}",
    "int TiffIO::read_header(Dict & dict, int image_index, const Region * area, bool)\n{\n\tENTERFUNC;\n\n\tinit();\n\n\tif (image_index == -1) {\n\t\timage_index = 0;\n\t}\n\n\tTIFFSetDirectory(tiff_file, image_index);\n\n\tint nx = 0;\n\tint ny = 0;\n\n\tTIFFGetField(tiff_file, TIFFTAG_IMAGEWIDTH, &nx);\n\tTIFFGetField(tiff_file, TIFFTAG_IMAGELENGTH, &ny);\n\n\tcheck_region(area, IntSize(nx, ny));\n\n\tfloat min = 0;\n\tfloat max = 0;\n\n\tTIFFDataType data_type = TIFF_NOTYPE;\n\n\tfloat resolution_x = 0;\n\tfloat resolution_y = 0;\n\n\tTIFFGetField(tiff_file, TIFFTAG_MINSAMPLEVALUE, &min);\n\tTIFFGetField(tiff_file, TIFFTAG_MAXSAMPLEVALUE, &max);\n\n\tTIFFGetField(tiff_file, TIFFTAG_PHOTOMETRIC, &photometric);\n\n\tTIFFGetField(tiff_file, TIFFTAG_SAMPLEFORMAT, &data_type);\n\tTIFFGetField(tiff_file, TIFFTAG_XRESOLUTION, &resolution_x);\n\tTIFFGetField(tiff_file, TIFFTAG_YRESOLUTION, &resolution_y);\n\n\tint xlen = 0, ylen = 0;\n\n\tEMUtil::get_region_dims(area, nx, &xlen, ny, &ylen);\n\n\tdict[\"nx\"] = xlen;\n\tdict[\"ny\"] = ylen;\n\tdict[\"nz\"] = 1;\n\n\tdict[\"nimg\"] = nimg;\n\tdict[\"minimum\"] = min;\n\tdict[\"maximum\"] = max;\n\n\tif (bitspersample == CHAR_BIT) {\n\t\tdict[\"datatype\"] = EMUtil::EM_UCHAR;\n\t}\n\telse if (bitspersample == sizeof(unsigned short) * CHAR_BIT) {\n\t\tdict[\"datatype\"] = EMUtil::EM_USHORT;\n\t}\n\telse if (bitspersample == sizeof(float) * CHAR_BIT) {\n\t\tdict[\"datatype\"] = EMUtil::EM_FLOAT;\n\t}\n\n\tdict[\"TIFF.bitspersample\"] = bitspersample;\n\tdict[\"TIFF.resolution_x\"] = resolution_x;\n\tdict[\"TIFF.resolution_y\"] = resolution_y;\n\n\tEXITFUNC;\n\treturn 0;\n}",
    "int TiffIO::read_data(float *rdata, int image_index, const Region * area, bool)\n{\n\tENTERFUNC;\n\n\tcheck_read_access(image_index, rdata);\n\n\tTIFFSetDirectory(tiff_file, image_index);\n\n\tint nx = 0;\n\tint ny = 0;\n\n\tTIFFGetField(tiff_file, TIFFTAG_IMAGEWIDTH,  & nx);\n\tTIFFGetField(tiff_file, TIFFTAG_IMAGELENGTH, & ny);\n\n\tint err = 0;\n\n\t/* for grey scale image, use TIFFReadEncodedStrip() and TIFFReadEncodedTile()\n\t * because the reading of strip image is twice time faster than TIFFReadRGBAImage -Grant */\n\n\tif (photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK) {\n\t\tunsigned char *cdata;\t//buffer for strip or tile\n\n\t\tif (TIFFIsTiled(tiff_file)) {\n\t\t\ttsize_t tileSize = TIFFTileSize(tiff_file);\n\t\t\ttsize_t tileMax = TIFFNumberOfTiles(tiff_file);\n\t\t\ttsize_t tileCount;\n\n\t\t\tuint32 tileWidth, tileLength;\n\t\t\tTIFFGetField(tiff_file, TIFFTAG_TILEWIDTH, &tileWidth);\n\t\t\tTIFFGetField(tiff_file, TIFFTAG_TILELENGTH, &tileLength);\n\n\t\t\tif ((cdata=(unsigned char*)_TIFFmalloc(tileSize))==NULL){\n\t\t\t\tfprintf(stderr,\"Error: Could not allocate enough memory\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tint tilePerLine = nx/tileWidth + 1;\n\t\t\tint NX, NY;\t// (NX, NY) is the cordinates of tile\n\t\t\tint xpos, ypos; // (xpos, ypos) is the actual coordinates of pixel (j,i) in image\n\n\t\t\tfor (tileCount=0; tileCount<tileMax; tileCount++) {\n\t\t\t\tif (TIFFReadEncodedTile(tiff_file, tileCount, cdata, tileSize) == -1) {\n\t\t\t\t\tfprintf(stderr,\"Error reading tiled image\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tNX = tileCount%tilePerLine;\n\t\t\t\t\tNY = tileCount/tilePerLine;\n\t\t\t\t\tuint32 i, j;\n\n\t\t\t\t\tfor (i=0; i<tileLength; i++) {\n\t\t\t\t\t\tfor (j=0; j<tileWidth; j++) {\n\t\t\t\t\t\t\txpos = NX*tileWidth + j;\n\t\t\t\t\t\t\typos = NY*tileLength + i;\n\n\t\t\t\t\t\t\tif (bitspersample == CHAR_BIT) {\n\t\t\t\t\t\t\t\tif (xpos<nx && ypos<ny) {\t// discard those pixel in tile which is out of actual image's boundary\n\t\t\t\t\t\t\t\t\tphotometric == PHOTOMETRIC_MINISWHITE ?\n\t\t\t\t\t\t\t\t\t\trdata[nx*(ny-1)-(ypos*nx)+xpos] = -(float) ((unsigned char*)cdata)[i*tileWidth+j] :\n\t\t\t\t\t\t\t\t\t\trdata[nx*(ny-1)-(ypos*nx)+xpos] = (float) ((unsigned char*)cdata)[i*tileWidth+j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (bitspersample == sizeof(unsigned short) * CHAR_BIT) {\n\t\t\t\t\t\t\t\tif(xpos<nx && ypos<ny) {\t// discard those pixel in tile which is out of actual image's boundary\n\t\t\t\t\t\t\t\t\tphotometric == PHOTOMETRIC_MINISWHITE ?\n\t\t\t\t\t\t\t\t\t\trdata[nx*(ny-1)-(ypos*nx)+xpos] = -(float) ((unsigned short*)cdata)[i*tileWidth+j] :\n\t\t\t\t\t\t\t\t\t\trdata[nx*(ny-1)-(ypos*nx)+xpos] = (float) ((unsigned short*)cdata)[i*tileWidth+j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (bitspersample == sizeof(float) * CHAR_BIT) {\n\t\t\t\t\t\t\t\tphotometric == PHOTOMETRIC_MINISWHITE ?\n\t\t\t\t\t\t\t\t\t\trdata[nx*(ny-1)-(ypos*nx)+xpos] = -((float*)cdata)[i*tileWidth+j] :\n\t\t\t\t\t\t\t\t\t\trdata[nx*(ny-1)-(ypos*nx)+xpos] = ((float*)cdata)[i*tileWidth+j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tfprintf(stderr,\"BAILING OUT:Allow only 8- or 16-bits image\\n\");\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\tcheck_region(area, IntSize(nx, ny));\n\t\t\tint xlen = 0, ylen = 0, x0 = 0, y0 = 0;\n\n\t\t\tEMUtil::get_region_dims(area, nx, &xlen, ny, &ylen);\n\t\t\tEMUtil::get_region_origins(area, &x0, &y0);\n\n\t\t\tint strip_size = TIFFStripSize(tiff_file);\n\t\t\tuint32 num_strips = TIFFNumberOfStrips(tiff_file);\n\n\t\t\tif ((cdata = static_cast < unsigned char *>(_TIFFmalloc(strip_size)))==NULL) {\n\t\t\t\tfprintf(stderr,\"Error: Could not allocate enough memory\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tint k = 0;\n\t\t\tint num_read = 0;\n\t\t\tint mode_size = bitspersample / CHAR_BIT;\n\t\t\tint total_rows = 0;\n\n\t\t\tfor (uint32 i = 0; i < num_strips; i++) {\n\t\t\t\tif ((num_read = TIFFReadEncodedStrip(tiff_file, i, cdata, strip_size)) == -1) {\n\t\t\t\t\tLOGERR(\"reading stripped TiFF image '%s' failed\", filename.c_str());\n\t\t\t\t\terr = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint nitems = num_read / mode_size;\n\t\t\t\tint nrows = nitems / nx;\n\t\t\t\ttotal_rows += nrows;\n\n\t\t\t\tint y_start = 0;\n\t\t\t\tint y_end = nrows;\n\n\t\t\t\tif (area) {\n\t\t\t\t\tif (total_rows >= y0 && total_rows < y0 + nrows) {\n\t\t\t\t\t\ty_start = nrows - (total_rows - y0);\n\t\t\t\t\t}\n\t\t\t\t\telse if (total_rows >= (y0 + ylen) && total_rows < (y0 + ylen + nrows)) {\n\t\t\t\t\t\ty_end = y0 + ylen - total_rows + nrows;\n\t\t\t\t\t}\n\t\t\t\t\telse if (total_rows >= (y0 + ylen + nrows)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int l = y_start; l < y_end; l++) {\n\t\t\t\t\tfor (int j = x0; j < x0 + xlen; j++) {\n\t\t\t\t\t\tif (bitspersample == CHAR_BIT) {\n\t\t\t\t\t\t\tphotometric == PHOTOMETRIC_MINISWHITE ?\n\t\t\t\t\t\t\t\trdata[k] = -(float) ((unsigned char*)cdata)[l * nx + j] :\n\t\t\t\t\t\t\t\trdata[k] = (float) ((unsigned char*)cdata)[l * nx + j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (bitspersample == sizeof(unsigned short) * CHAR_BIT) {\n\t\t\t\t\t\t\tphotometric == PHOTOMETRIC_MINISWHITE ?\n\t\t\t\t\t\t\t\trdata[k] = -(float)((unsigned short*)cdata)[l * nx + j] :\n\t\t\t\t\t\t\t\trdata[k] = (float)((unsigned short*)cdata)[l * nx + j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (bitspersample == sizeof(float) * CHAR_BIT) {\n\t\t\t\t\t\t\tphotometric == PHOTOMETRIC_MINISWHITE ?\n\t\t\t\t\t\t\t\trdata[k] = -((float*)cdata)[l * nx + j] :\n\t\t\t\t\t\t\t\trdata[k] = ((float*)cdata)[l * nx + j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUtil::flip_image(rdata, xlen, ylen);\n\t\t}\n\n\t\t_TIFFfree(cdata);\n\t}\n\telse { // process color image, convert to greyscale\n\t\tsize_t npixels = nx * ny;\n\t\tuint32 * raster = (uint32*) _TIFFmalloc(npixels * sizeof(uint32));\n\n\t\tif (raster != NULL) {\n\t\t\tif (TIFFReadRGBAImage(tiff_file, nx, ny, raster, 0)) {\n\t\t\t\tint abgr = 0;\t// raw ABGR pixel value\n\t\t\t\tint red=0, green=0, blue=0;\n\n\t\t\t\tfor (int i=0; i<nx; ++i) {\n\t\t\t\t\tfor (int j=0; j<ny; ++j) {\n\t\t\t\t\t\tabgr \t= raster[j+ny*i];\n\t\t\t\t\t\tred \t= TIFFGetR(abgr);\n\t\t\t\t\t\tgreen \t= TIFFGetG(abgr);\n\t\t\t\t\t\tblue \t= TIFFGetB(abgr);\n\t\t\t\t\t\trdata[j+ny*i] = static_cast<float>(red*RED+green*GREEN+blue*BLUE);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t_TIFFfree(raster);\n\t\t\t}\n\t\t}\n\t}\n\n\tEXITFUNC;\n\treturn err;\n}",
    "bool  GrFmtTiffReader::ReadHeader()\n{\n\tchar errmsg[1024];\n\tbool result = false;\n\n\tClose();\n\tTIFF* tif = TIFFOpen( m_filename, \"r\" );\n\n\tif( tif )\n\t{\n\t\tint width = 0, height = 0, photometric = 0, compression = 0;\n\t\tm_tif = tif;\n\n\t\tif( TIFFRGBAImageOK( tif, errmsg ) &&\n\t\t\tTIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &width ) &&\n\t\t\tTIFFGetField( tif, TIFFTAG_IMAGELENGTH, &height ) &&\n\t\t\tTIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ) &&\n\t\t\t(!TIFFGetField( tif, TIFFTAG_COMPRESSION, &compression ) ||\n\t\t\t(compression != COMPRESSION_LZW &&\n\t\t\t compression != COMPRESSION_OJPEG)))\n\t\t{\n\t\t\tm_width = width;\n\t\t\tm_height = height;\n\t\t\tm_iscolor = photometric > 1;\n\n\t\t\tresult = true;\n\t\t}\n\t}\n\n\tif( !result )\n\t\tClose();\n\n\treturn result;\n}",
    "bool  GrFmtTiffReader::ReadData( uchar* data, int step, int color )\n{\n\tbool result = false;\n\tuchar* buffer = 0;\n\n\tcolor = color > 0 || (color < 0 && m_iscolor);\n\n\tif( m_tif && m_width && m_height )\n\t{\n\t\tTIFF* tif = (TIFF*)m_tif;\n\t\tint tile_width0 = m_width, tile_height0 = 0;\n\t\tint x, y, i;\n\t\tint is_tiled = TIFFIsTiled(tif);\n\n\t\tif( !is_tiled &&\n\t\t\tTIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 ) ||\n\t\t\tis_tiled &&\n\t\t\tTIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n\t\t\tTIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 ))\n\t\t{\n\t\t\tif( tile_width0 <= 0 )\n\t\t\t\ttile_width0 = m_width;\n\n\t\t\tif( tile_height0 <= 0 )\n\t\t\t\ttile_height0 = m_height;\n\n\t\t\tbuffer = new uchar[tile_height0*tile_width0*4];\n\n\t\t\tfor( y = 0; y < m_height; y += tile_height0, data += step*tile_height0 )\n\t\t\t{\n\t\t\t\tint tile_height = tile_height0;\n\n\t\t\t\tif( y + tile_height > m_height )\n\t\t\t\t\ttile_height = m_height - y;\n\n\t\t\t\tfor( x = 0; x < m_width; x += tile_width0 )\n\t\t\t\t{\n\t\t\t\t\tint tile_width = tile_width0, ok;\n\n\t\t\t\t\tif( x + tile_width > m_width )\n\t\t\t\t\t\ttile_width = m_width - x;\n\n\t\t\t\t\tif( !is_tiled )\n\t\t\t\t\t\tok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n\t\t\t\t\telse\n\t\t\t\t\t\tok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n\n\t\t\t\t\tif( !ok )\n\t\t\t\t\t\tgoto exit_func;\n\n\t\t\t\t\tfor( i = 0; i < tile_height; i++ )\n\t\t\t\t\t\tif( color )\n\t\t\t\t\t\t\ticvCvt_BGRA2BGR_8u_C4C3R( buffer + i*tile_width*4, 0,\n\t\t\t\t\t\t\t\t\t\t  data + x*3 + step*(tile_height - i - 1), 0,\n\t\t\t\t\t\t\t\t\t\t  cvSize(tile_width,1), 2 );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ticvCvt_BGRA2Gray_8u_C4C1R( buffer + i*tile_width*4, 0,\n\t\t\t\t\t\t\t\t\t\t\tdata + x + step*(tile_height - i - 1), 0,\n\t\t\t\t\t\t\t\t\t\t\tcvSize(tile_width,1), 2 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult = true;\n\t\t}\n\t}\n\nexit_func:\n\n\tClose();\n\tdelete[] buffer;\n\n\treturn result;\n}",
    "void GetField(uint32_t tag, int &value_r) {\n    TIFFGetField(tiff, tag, &value_r);\n  }",
    "static cmsHPROFILE GetTIFFProfile(TIFF *in, uint16 bps) {\n    cmsHPROFILE hProfile;\n    void *iccProfilePtr;\n    cmsUInt32Number iccProfileSize;\n\n    if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &iccProfileSize, &iccProfilePtr)) {\n        PRINT_DEBUG(\"iccProfileSize: \" << iccProfileSize);\n        hProfile = cmsOpenProfileFromMem(iccProfilePtr, iccProfileSize);\n\n        if (hProfile) return hProfile;\n    }\n\n    PRINT_DEBUG(\"No color profile\");\n\n    // Try to see if \"colorimetric\" tiff.data()\n    cmsCIExyYTRIPLE primaries;\n    cmsCIExyY whitePoint;\n    cmsToneCurve *curve[3];\n\n    cmsFloat32Number *chr;\n    if (!TIFFGetField(in, TIFFTAG_PRIMARYCHROMATICITIES, &chr)) {\n        return 0;\n    }\n    primaries.Red.x = chr[0];\n    primaries.Red.y = chr[1];\n    primaries.Green.x = chr[2];\n    primaries.Green.y = chr[3];\n    primaries.Blue.x = chr[4];\n    primaries.Blue.y = chr[5];\n\n    PRINT_DEBUG(primaries.Red.x);\n    PRINT_DEBUG(primaries.Red.y);\n    PRINT_DEBUG(primaries.Green.x);\n    PRINT_DEBUG(primaries.Green.y);\n    PRINT_DEBUG(primaries.Blue.x);\n    PRINT_DEBUG(primaries.Blue.y);\n\n    primaries.Red.Y = primaries.Green.Y = primaries.Blue.Y = 1.0;\n\n    cmsFloat32Number *wp;\n    if (!TIFFGetField(in, TIFFTAG_WHITEPOINT, &wp)) {\n        return 0;\n    }\n\n    whitePoint.x = wp[0];\n    whitePoint.y = wp[1];\n    whitePoint.Y = 1.0;\n\n    PRINT_DEBUG(whitePoint.x);\n    PRINT_DEBUG(whitePoint.y);\n\n    // Transferfunction is a bit harder....\n    // cmsUInt16Number gmr[1 << bps];\n    // cmsUInt16Number gmg[1 << bps];\n    // cmsUInt16Number gmb[1 << bps];\n\n    std::vector<cmsUInt16Number> gmr(1 << bps);\n    std::vector<cmsUInt16Number> gmg(1 << bps);\n    std::vector<cmsUInt16Number> gmb(1 << bps);\n\n    // TIFFGetFieldDefaulted(in, TIFFTAG_TRANSFERFUNCTION, gmr, gmg, gmb);\n    TIFFGetFieldDefaulted(in, TIFFTAG_TRANSFERFUNCTION, gmr.data(), gmg.data(),\n                          gmb.data());\n\n    // curve[0] = cmsBuildTabulatedToneCurve16(nullptr, 1 << bps, gmr);\n    // curve[1] = cmsBuildTabulatedToneCurve16(nullptr, 1 << bps, gmg);\n    // curve[2] = cmsBuildTabulatedToneCurve16(nullptr, 1 << bps, gmb);\n    curve[0] = cmsBuildTabulatedToneCurve16(nullptr, 1 << bps, gmr.data());\n    curve[1] = cmsBuildTabulatedToneCurve16(nullptr, 1 << bps, gmg.data());\n    curve[2] = cmsBuildTabulatedToneCurve16(nullptr, 1 << bps, gmb.data());\n\n    hProfile = cmsCreateRGBProfile(&whitePoint, &primaries, curve);\n\n    cmsFreeToneCurve(curve[0]);\n    cmsFreeToneCurve(curve[1]);\n    cmsFreeToneCurve(curve[2]);\n\n    return hProfile;\n}",
    "void TiffReader::open() {\n    m_data->file_.reset(TIFFOpen(filename().c_str(), \"r\"));\n    if (!m_data->file_) {\n        throw pfs::io::InvalidFile(\"TiffReader: cannot open file \" +\n                                   filename());\n    }\n\n    TIFFGetField(m_data->handle(), TIFFTAG_IMAGEWIDTH, &m_data->width_);\n    TIFFGetField(m_data->handle(), TIFFTAG_IMAGELENGTH, &m_data->height_);\n\n    if (m_data->width_ <= 0 || m_data->height_ <= 0) {\n        throw pfs::io::InvalidHeader(\"TiffReader: invalid image size\");\n    }\n    setWidth(m_data->width_);\n    setHeight(m_data->height_);\n\n    // check if planar... maybe in the future we can add support for tiled\n    // images?\n    uint16 planarConfig;\n    TIFFGetField(m_data->handle(), TIFFTAG_PLANARCONFIG, &planarConfig);\n    if (planarConfig != PLANARCONFIG_CONTIG) {\n        throw pfs::io::InvalidHeader(\n            \"TiffReader: Unsopported planar configuration\");\n    }\n\n    // compression type\n    if (!TIFFGetField(m_data->handle(), TIFFTAG_COMPRESSION,\n                      &m_data->compressionType_)) {\n        m_data->compressionType_ = COMPRESSION_NONE;\n    }\n    // photometric type\n    if (!TIFFGetFieldDefaulted(m_data->handle(), TIFFTAG_PHOTOMETRIC,\n                               &m_data->photometricType_)) {\n        throw pfs::io::InvalidHeader(\n            \"TiffReader: unspecified photometric type\");\n    }\n\n    if (!TIFFGetField(m_data->handle(), TIFFTAG_STONITS, &m_data->stonits_)) {\n        m_data->stonits_ = 1.;\n    }\n\n    // bits per sample\n    if (!TIFFGetField(m_data->handle(), TIFFTAG_BITSPERSAMPLE,\n                      &m_data->bitsPerSample_)) {\n        throw pfs::io::InvalidHeader(\"TiffReader: unspecified bits per sample\");\n    }\n    if (m_data->bitsPerSample_ != 8 && m_data->bitsPerSample_ != 16 &&\n        m_data->bitsPerSample_ != 32) {\n        throw pfs::io::InvalidHeader(\n            \"TiffReader: invalid bits per sample (read: \" +\n            boost::lexical_cast<std::string>(m_data->bitsPerSample_) + \")\");\n    }\n\n    // samples per pixel\n    if (!TIFFGetField(m_data->handle(), TIFFTAG_SAMPLESPERPIXEL,\n                      &m_data->samplesPerPixel_)) {\n        throw pfs::io::InvalidHeader(\n            \"TiffReader: unspecified samples per pixel\");\n    }\n\n    // parse photometric type\n    switch (m_data->photometricType_) {\n        case PHOTOMETRIC_LOGLUV: {\n            if (m_data->compressionType_ != COMPRESSION_SGILOG &&\n                m_data->compressionType_ != COMPRESSION_SGILOG24) {\n                throw pfs::io::InvalidHeader(\n                    \"TiffReader: only support SGILOG compressed LogLuv data\");\n            }\n            TIFFSetField(m_data->handle(), TIFFTAG_SGILOGDATAFMT,\n                         SGILOGDATAFMT_FLOAT);\n        } break;\n        case PHOTOMETRIC_RGB: {\n            uint16 *extraSamplesTypes = 0;\n            uint16 extraSamplesPerPixel = 0;\n\n            // read extra samples (# of alpha channels)\n            if (!TIFFGetField(m_data->handle(), TIFFTAG_EXTRASAMPLES,\n                              &extraSamplesPerPixel, &extraSamplesTypes)) {\n                if (m_data->samplesPerPixel_ == 4) {\n                    extraSamplesPerPixel = 1;\n                }\n            }\n            uint16 colorSamples =\n                m_data->samplesPerPixel_ - extraSamplesPerPixel;\n            m_data->hasAlpha_ = (extraSamplesPerPixel == 1);\n            if (colorSamples != 3) {\n                throw pfs::io::InvalidHeader(\n                    \"TIFF: unsupported samples per pixel for RGB\");\n            }\n        } break;\n        case PHOTOMETRIC_SEPARATED: {\n            if (m_data->samplesPerPixel_ != 4) {\n                throw pfs::io::InvalidHeader(\n                    \"TIFF: unsupported samples per pixel for CMYK\");\n            }\n        } break;\n        default: {\n            throw pfs::io::InvalidHeader(\n                \"TiffReader: unsupported photometric type\");\n        } break;\n    }\n\n    // ...based on photometric type and bits per samples, will make ready the\n    // right callback to read the data\n    m_data->initReader();\n    m_data->hIn_.reset(\n        GetTIFFProfile(m_data->handle(), m_data->bitsPerSample_));\n}",
    "void TIFFImageIO::loadHeader(const char *name, long &width, long &height, int &depth) const\n{\n  TIFF *tif=TIFFOpen(name, \"r\");\n\n  if (tif == 0)\n  {\n    throw gutil::IOException(\"Can only load TIFF image (\"+std::string(name)+\")\");\n  }\n\n  uint32_t w, h;\n  uint16_t d;\n\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n  TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &d);\n\n  width=w;\n  height=h;\n  depth=d;\n\n  TIFFClose(tif);\n}",
    "TiffImage(const char *name)\n    {\n      tif=TIFFOpen(name, \"r\");\n\n      if (tif)\n      {\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &depth);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n\n        uint16_t format;\n        uint16_t planar;\n\n        TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &format);\n        TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planar);\n\n        is_float=(format == SAMPLEFORMAT_IEEEFP);\n        is_planar=(planar == PLANARCONFIG_SEPARATE);\n\n        raw_size=TIFFScanlineSize(tif);\n        TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric);\n      }\n      else\n      {\n        throw gutil::IOException(\"Can only load TIFF image (\"+std::string(name)+\")\");\n      }\n    }",
    "TiffImporter::TiffImporter(FileName inputName) : ImageImporter(inputName) {\n\n    // Open the TIFF image\n    m_image = NULL;\n    if ((m_image = XTIFFOpen(inputName.expanded().toLatin1().data(), \"r\")) == NULL) {\n      throw IException(IException::Programmer,\n          QString(\"Could not open TIFF image [\") + inputName.expanded().toLatin1().data() + \"]\", _FILEINFO_);\n    }\n\n    // Get its constant dimensions.  Note, height seems to get reset to 0 if\n    // called before setting width.\n    uint32_t height;\n    TIFFGetField(m_image, TIFFTAG_IMAGELENGTH, &height);\n    setLines(height);\n\n    uint32_t width;\n    TIFFGetField(m_image, TIFFTAG_IMAGEWIDTH, &width);\n    setSamples(width);\n\n    TIFFGetField(m_image, TIFFTAG_SAMPLESPERPIXEL, &m_samplesPerPixel);\n\n    // Setup the width and height of the image\n    unsigned long imagesize = lines() * samples();\n    m_raster = NULL;\n    if ((m_raster = (uint32_t *) malloc(sizeof(uint32_t) * imagesize)) == NULL) {\n      throw IException(IException::Programmer,\n          \"Could not allocate enough memory\", _FILEINFO_);\n    }\n\n    // Read the image into the memory buffer\n    if (TIFFReadRGBAImage(m_image, samples(), lines(), m_raster, 0) == 0) {\n      throw IException(IException::Programmer,\n          \"Could not read image\", _FILEINFO_);\n    }\n\n    // Deal with photometric interpretations\n    if (TIFFGetField(m_image, TIFFTAG_PHOTOMETRIC, &m_photo) == 0) {\n      throw IException(IException::Programmer,\n          \"Image has an undefined photometric interpretation\", _FILEINFO_);\n    }\n\n    // Get the geotiff info (if available)\n    m_geotiff = NULL;\n    m_geotiff = GTIFNew(m_image);\n\n    setDefaultBands();\n  }",
    "Pvl TiffImporter::gdalItems(const Pvl &inLab) const {\n\n    Pvl newLab = inLab;\n    PvlGroup &map = newLab.findGroup(\"Mapping\");\n\n    // Get the GDALMetadata tag (42112) to get the lat/lon boundry\n    char *gdalMetadataBuf;\n    short int gdalMetadataCount = 0;\n\n    if (TIFFGetField(m_image, 42112, &gdalMetadataCount, &gdalMetadataBuf) == 1) {\n\n      QString gdalMetadataQstring(gdalMetadataBuf);\n\n      QDomDocument gdalDoc(\"GDALMetaData\");\n      if (gdalDoc.setContent(gdalMetadataQstring)) {\n        QDomElement gdalRoot = gdalDoc.documentElement();\n        if (gdalRoot.tagName() == \"GDALMetadata\") {\n\n          QDomNode gdalNode = gdalRoot.firstChild();\n          while (!gdalNode.isNull()) {\n            QDomElement gdalElement = gdalNode.toElement();\n            if (!gdalElement.isNull() ) {\n              if (gdalElement.tagName() == \"Item\") {\n                if (gdalElement.attribute(\"name\", \"\") == \"WEST_LONGITUDE\") {\n                  QString westLon = gdalElement.text();\n                  map += PvlKeyword(\"MinimumLongitude\", toString(Angle(westLon).degrees()));\n                }\n                else if (gdalElement.attribute(\"name\", \"\") == \"EAST_LONGITUDE\") {\n                  QString eastLon = gdalElement.text();\n                  map += PvlKeyword(\"MaximumLongitude\", toString(Angle(eastLon).degrees()));\n                }\n                else if (gdalElement.attribute(\"name\", \"\") == \"SOUTH_LATITUDE\") {\n                  QString southLat = gdalElement.text();\n                  map += PvlKeyword(\"MinimumLatitude\", toString(Angle(southLat).degrees()));\n                }\n                else if (gdalElement.attribute(\"name\", \"\") == \"NORTH_LATITUDE\") {\n                  QString northLat = gdalElement.text();\n                  map += PvlKeyword(\"MaximumLatitude\", toString(Angle(northLat).degrees()));\n                }\n              }\n            }\n\n            gdalNode = gdalNode.nextSibling();\n          }\n        }\n      }\n    }\n\n    return newLab;\n  }",
    "Pvl TiffImporter::upperLeftXY(const Pvl &inLab) const {\n\n    Pvl newLab = inLab;\n    PvlGroup &map = newLab.findGroup(\"Mapping\");\n\n    double *tiePoints = NULL;\n    short int tieCount = 0;\n    if (TIFFGetField(m_image, TIFFTAG_GEOTIEPOINTS, &tieCount, &tiePoints) == 1) {\n\n      // The expected tiepoints are TIFF(i, j, k, x, y, z) = ISIS(sample, line, 0, X, Y, 0)\n      // Make sure the (x, y) refer to the (0, 0)\n      if (tiePoints[0] == 0.0 && tiePoints[1] == 0.0) {\n        double x = 0.0;\n        if (map.hasKeyword(\"FalseEasting\")) {\n          x = (double)map[\"FalseEasting\"] + tiePoints[3];\n          map.deleteKeyword(\"FalseEasting\");\n        }\n\n        double y = 0.0;\n        if (map.hasKeyword(\"FalseNorthing\")) {\n          y = (double)map[\"FalseNorthing\"] + tiePoints[4];\n          map.deleteKeyword(\"FalseNorthing\");\n        }\n\n        map += PvlKeyword(\"UpperLeftCornerX\", toString(x), \"meters\");\n        map += PvlKeyword(\"UpperLeftCornerY\", toString(y), \"meters\");\n      }\n      else {\n        QString msg = \"The upper left X and Y can not be calculated. Unsupported tiepoint \"\n                      \"type in Tiff file (i.e., not ( 0.0, 0.0))\";\n        throw IException(IException::User, msg, _FILEINFO_);\n      }\n    }\n\n    return newLab;\n  }",
    "Pvl TiffImporter::resolution(const Pvl &inLab) const {\n\n    Pvl newLab = inLab;\n    PvlGroup &map = newLab.findGroup(\"Mapping\");\n\n    // Get the Tiff PixelScale tag and convert it to resolution\n    double *scales = NULL;\n    short int scaleCount = 0;\n    if (TIFFGetField(m_image, TIFFTAG_GEOPIXELSCALE, &scaleCount, &scales) == 1) {\n\n      // The expected scales are TIFF(x, y, z) = ISIS(sample, line, 0)\n      // Make sure the (x, y) are the same but not zero (0) for ISIS\n      if ((scaleCount == 3) && (scales[0] > 0.0 && scales[1] > 0.0) && (scales[0] == scales[1])) {\n        map += PvlKeyword(\"PixelResolution\", toString(scales[0]), \"meters\");\n      }\n      else {\n        QString msg = \"The pixel resolution could not be retrieved from the TIFF file. Unsupported \"\n                      \"PixelScale tag values.\";\n        throw IException(IException::User, msg, _FILEINFO_);\n      }\n    }\n\n    return newLab;\n  }",
    "int ReadTiff(const char * filename,\n  std::vector<unsigned char> * ptr,\n  int * w,\n  int * h,\n  int * depth)\n{\n  TIFF* tiff = TIFFOpen(filename, \"r\");\n  if (!tiff) {\n    OPENMVG_LOG_ERROR << \"Couldn't open \" << filename << \" fopen returned 0\";\n    return 0;\n  }\n  uint16 bps, spp;\n\n  TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, w);\n  TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, h);\n  TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  *depth = bps * spp / 8;\n\n  ptr->resize((*h)*(*w)*(*depth));\n\n  if (*depth==4) {\n    if (ptr != nullptr) {\n      if (!TIFFReadRGBAImageOriented(tiff, *w, *h, (uint32*)&((*ptr)[0]), ORIENTATION_TOPLEFT, 0)) {\n        TIFFClose(tiff);\n        return 0;\n      }\n    }\n  } else {\n    for (size_t i=0; i<TIFFNumberOfStrips(tiff); ++i) {\n      if (TIFFReadEncodedStrip(tiff, i, ((uint8*)&((*ptr)[0]))+i*TIFFStripSize(tiff),(tsize_t)-1) ==\n        std::numeric_limits<tsize_t>::max()) {\n        TIFFClose(tiff);\n        return 0;\n      }\n    }\n  }\n  TIFFClose(tiff);\n  return 1;\n}",
    "bool Read_TIFF_ImageHeader(const char * filename, ImageHeader * imgheader)\n{\n  bool bStatus = false;\n\n  TIFF* tiff = TIFFOpen(filename, \"r\");\n  if (!tiff) {\n    OPENMVG_LOG_ERROR << \"Cannot open TIFF image: \" << filename << \".\";\n    return false;\n  }\n\n  if (imgheader)\n  {\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &imgheader->width);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &imgheader->height);\n    bStatus = true;\n  }\n\n  TIFFClose(tiff);\n  return bStatus;\n}",
    "BEGIN_POV_NAMESPACE\n\n/*****************************************************************************\n*\n* FUNCTION      : Read_Tiff_Image\n*\n* ARGUMENTS     : IMAGE *Image; char *name;\n*\n* MODIFIED ARGS : Image\n*\n* RETURN VALUE  : none\n*\n* AUTHOR        : Alexander Enzmann\n*\n* DESCRIPTION\n*\n*   Reads a TIFF image into an RGB image buffer\n*\n* CHANGES\n*\n* New - 6/2000\n*\n******************************************************************************/\n\nvoid Read_Tiff_Image(IMAGE *Image, char *name)\n{\n\tunsigned int width, height;\n\tchar *filename = Locate_Filename(name, POV_File_Image_TIFF, 1);\n\t\n    long LineSize;\n    uint16 BitsPerSample, PhotometricInterpretation;\n\tuint16 SamplePerPixel, Orientation;\n\tuint32 RowsPerStrip;\n    int row, nrow, i, j, l;\n    TIFF* tif;\n\tint result = 0;\n\t\n\tif (filename == NULL)\n\t\tError(\"Cannot read TIFF image.\");\n\t\n\t// Rather than have libTIFF complain about tags it doesn't understand,\n\t// we just suppress all the warnings.\n\tTIFFSetWarningHandler(SuppressTIFFWarnings);\n\tTIFFSetErrorHandler(SuppressTIFFWarnings);\n\t\n\t// Open and do initial processing\n\ttif = TIFFClientOpen(filename, \"r\", Tiff_Open(filename),\n\t                     Tiff_Read, Tiff_Write, Tiff_Seek, Tiff_Close,\n\t                     Tiff_Size, Tiff_Map, Tiff_Unmap);\n\tif (!tif)\n\t\treturn;\n\t\n\t// Get basic information about the image\n\tint ExtraSamples, ExtraSampleInfo;\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);  \n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);   \n\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\tTIFFGetField(tif, TIFFTAG_ORIENTATION, &Orientation);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &ExtraSamples, &ExtraSampleInfo);\n\t\n\tImage->iwidth = width;\n\tImage->iheight = height;\n\tImage->width = (DBL)width;\n\tImage->height = (DBL)height;\n\t\n    LineSize = TIFFScanlineSize(tif);\n\tassert(SamplePerPixel == (int)(LineSize / width));\n    // SamplePerPixel = (int)(LineSize / width);\n\t\n#if 0\n\t// For now we are ignoring the orientation of the image...\n\tswitch (Orientation)\n\t{\n\t\tcase ORIENTATION_TOPLEFT:\n\t\t\tbreak;\n\t\tcase ORIENTATION_TOPRIGHT:\n\t\t\tbreak;\n\t\tcase ORIENTATION_BOTRIGHT:\n\t\t\tbreak;\n\t\tcase ORIENTATION_BOTLEFT:\n\t\t\tbreak;\n\t\tcase ORIENTATION_LEFTTOP:\n\t\t\tbreak;\n\t\tcase ORIENTATION_RIGHTTOP:\n\t\t\tbreak;\n\t\tcase ORIENTATION_RIGHTBOT:\n\t\t\tbreak;\n\t\tcase ORIENTATION_LEFTBOT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n#endif\n\t\n\t//PhotometricInterpretation = 2 image is RGB\n\t//PhotometricInterpretation = 3 image have a color palette              \n\tif (PhotometricInterpretation == PHOTOMETRIC_PALETTE)\n\t{\n\t\tuint16 *red, *green, *blue;\n\t\tint16 i;\n\t\tint Palette16Bits;\n\t\tIMAGE_COLOUR *cmap;\n\n\t\t//load the palette\n\t\tImage->data.rgb8_lines = NULL;\n\t\tint cmap_len = (1 << BitsPerSample);\n\t\tImage->Colour_Map_Size = cmap_len;\n\n\t\tcmap = (IMAGE_COLOUR *)POV_MALLOC(cmap_len*sizeof(IMAGE_COLOUR), \"TIFF image color map\");\n\t\tImage->Colour_Map = cmap;\n\n\t\tTIFFGetField(tif, TIFFTAG_COLORMAP, &red, &green, &blue); \n\n\t\t// Is the palette 16 or 8 bits ?\n\t\tif (checkcmap(cmap_len, red, green, blue) == 16) \n\t\t\tPalette16Bits = true;\n\t\telse\n\t\t\tPalette16Bits = false;\n\n\t\t// Read the palette\n\t\tfor (i=0,j=0;i<cmap_len;i++)\n\t\t{\n\t\t\tif (Palette16Bits)\n\t\t\t{\n\t\t\t\tcmap[i].Red   = CVT(red[i]);\n\t\t\t\tcmap[i].Green = CVT(green[i]);\n\t\t\t\tcmap[i].Blue  = CVT(blue[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcmap[i].Red   = red[i];\n\t\t\t\tcmap[i].Green = green[i];\n\t\t\t\tcmap[i].Blue  = blue[i];\n\t\t\t}\n\t\t\t// I may be mistaken, but it appears that alpha/opacity information doesn't\n\t\t\t// appear in a Paletted Tiff image.  Well - if it does, it's not as easy to\n\t\t\t// get at as RGB.\n\t\t\tcmap[i].Filter   = 0;\n\t\t\tcmap[i].Transmit = 0;\n\t\t}\n\n\t\tImage->data.map_lines = (unsigned char **)POV_MALLOC(height * sizeof(unsigned char *), \"TIFF image\");\n\t\tunsigned char *buf = (unsigned char *)POV_MALLOC(sizeof(unsigned char) * TIFFStripSize(tif), \"TIFF row\");\n\n\t\t//read the tiff lines and save them in the image\n\t\t//with RGB mode, we have to change the order of the 3 samples RGB <=> BGR\n\t\tfor (row=0;row<height;row+=RowsPerStrip)\n\t\t{     \n\t\t\tnrow = (row + (int)RowsPerStrip > height ? height - row : RowsPerStrip);\n\t\t\tTIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 0), buf, nrow * LineSize);\n\t\t\tfor (l=0;l<nrow;l++)\n\t\t\t{\n\t\t\t\tImage->data.map_lines[row+l] = (unsigned char *)POV_MALLOC(width, \"TIFF Image line\");\n\t\t\t\tPOV_MEMCPY(Image->data.map_lines[row+l], &buf[l*LineSize], (int)width); \n\t\t\t}\n\t\t}\n\n\t\tPOV_FREE(buf);\n\t}\n\telse\n\t{\n\t\t// Allocate the row buffers for the image\n\t\tImage->Colour_Map_Size = 0;\n\t\tImage->Colour_Map = NULL;\n\t\tImage->data.rgb8_lines = (IMAGE8_LINE *)POV_MALLOC(height * sizeof(IMAGE8_LINE), \"TIFF image\");\n\t\tuint32 *buf = (uint32 *)POV_MALLOC(sizeof(uint32) * width * height, \"TIIF image data\");\n\n\t\tTIFFReadRGBAImage(tif, width, height, buf, 0);\n\t\tuint32 abgr, *tbuf = buf;\n\t\tfor (i=height-1;i>=0;i--)\n\t\t{\n\t\t\tImage->data.rgb8_lines[i].blue   = (unsigned char *)POV_MALLOC(width, \"TIFF Image line\");\n\t\t\tImage->data.rgb8_lines[i].green  = (unsigned char *)POV_MALLOC(width, \"TIFF Image line\");\n\t\t\tImage->data.rgb8_lines[i].red    = (unsigned char *)POV_MALLOC(width, \"TIFF Image line\");\n\t\t\tImage->data.rgb8_lines[i].transm = (unsigned char *)POV_MALLOC(width, \"TIFF Image line\");\n\t\t\tfor (j=0,l=0;j<width;j++)\n\t\t\t{\n\t\t\t\tabgr = *tbuf++;\n\t\t\t\tImage->data.rgb8_lines[i].blue[j]   = (unsigned char)TIFFGetB(abgr);\n\t\t\t\tImage->data.rgb8_lines[i].green[j]  = (unsigned char)TIFFGetG(abgr);\n\t\t\t\tImage->data.rgb8_lines[i].red[j]    = (unsigned char)TIFFGetR(abgr);\n\t\t\t\tImage->data.rgb8_lines[i].transm[j] = 255 - (unsigned char)TIFFGetA(abgr);\n\t\t\t}\n\t\t}\n        POV_FREE(buf);\n\t}\n\t\n\tTIFFClose(tif);\n}",
    "bool wxTIFFHandler::LoadFile( wxImage *image, wxInputStream& stream, bool verbose, int index )\n{\n    if (index == -1)\n        index = 0;\n\n    image->Destroy();\n\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"r\" );\n\n    if (!tif)\n    {\n        if (verbose)\n        {\n            wxLogError( _(\"TIFF: Error loading image.\") );\n        }\n\n        return false;\n    }\n\n    if (!TIFFSetDirectory( tif, (tdir_t)index ))\n    {\n        if (verbose)\n        {\n            wxLogError( _(\"Invalid TIFF image index.\") );\n        }\n\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    uint32 w, h;\n    uint32 *raster;\n\n    TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &w );\n    TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &h );\n\n    uint16 samplesPerPixel = 0;\n    (void) TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);\n\n    uint16 bitsPerSample = 0;\n    (void) TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n\n    uint16 extraSamples;\n    uint16* samplesInfo;\n    TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,\n                          &extraSamples, &samplesInfo);\n\n    uint16 photometric;\n    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric))\n    {\n        photometric = PHOTOMETRIC_MINISWHITE;\n    }\n    const bool hasAlpha = (extraSamples >= 1\n        && ((samplesInfo[0] == EXTRASAMPLE_UNSPECIFIED)\n            || samplesInfo[0] == EXTRASAMPLE_ASSOCALPHA\n            || samplesInfo[0] == EXTRASAMPLE_UNASSALPHA))\n        || (extraSamples == 0 && samplesPerPixel == 4\n            && photometric == PHOTOMETRIC_RGB);\n\n    // guard against integer overflow during multiplication which could result\n    // in allocating a too small buffer and then overflowing it\n    const double bytesNeeded = (double)w * (double)h * sizeof(uint32);\n    if ( bytesNeeded >= wxUINT32_MAX )\n    {\n        if ( verbose )\n        {\n            wxLogError( _(\"TIFF: Image size is abnormally big.\") );\n        }\n\n        TIFFClose(tif);\n\n        return false;\n    }\n\n    raster = (uint32*) _TIFFmalloc( (uint32)bytesNeeded );\n\n    if (!raster)\n    {\n        if (verbose)\n        {\n            wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n        }\n\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    image->Create( (int)w, (int)h );\n    if (!image->IsOk())\n    {\n        if (verbose)\n        {\n            wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n        }\n\n        _TIFFfree( raster );\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    if ( hasAlpha )\n        image->SetAlpha();\n\n    uint16 planarConfig = PLANARCONFIG_CONTIG;\n    (void) TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planarConfig);\n\n    bool ok = true;\n    char msg[1024] = \"\";\n    if\n    (\n        (planarConfig == PLANARCONFIG_CONTIG && samplesPerPixel == 2\n            && extraSamples == 1)\n        &&\n        (\n            ( !TIFFRGBAImageOK(tif, msg) )\n            || (bitsPerSample == 8)\n        )\n    )\n    {\n        const bool isGreyScale = (bitsPerSample == 8);\n        unsigned char *buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n        uint32 pos = 0;\n        const bool minIsWhite = (photometric == PHOTOMETRIC_MINISWHITE);\n        const int minValue =  minIsWhite ? 255 : 0;\n        const int maxValue = 255 - minValue;\n\n        /*\n        Decode to ABGR format as that is what the code, that converts to\n        wxImage, later on expects (normally TIFFReadRGBAImageOriented is\n        used to decode which uses an ABGR layout).\n        */\n        for (uint32 y = 0; y < h; ++y)\n        {\n            if (TIFFReadScanline(tif, buf, y, 0) != 1)\n            {\n                ok = false;\n                break;\n            }\n\n            if (isGreyScale)\n            {\n                for (uint32 x = 0; x < w; ++x)\n                {\n                    uint8 val = minIsWhite ? 255 - buf[x*2] : buf[x*2];\n                    uint8 alpha = minIsWhite ? 255 - buf[x*2+1] : buf[x*2+1];\n                    raster[pos] = val + (val << 8) + (val << 16)\n                        + (alpha << 24);\n                    pos++;\n                }\n            }\n            else\n            {\n                for (uint32 x = 0; x < w; ++x)\n                {\n                    int mask = buf[x*2/8] << ((x*2)%8);\n\n                    uint8 val = mask & 128 ? maxValue : minValue;\n                    raster[pos] = val + (val << 8) + (val << 16)\n                        + ((mask & 64 ? maxValue : minValue) << 24);\n                    pos++;\n                }\n            }\n        }\n\n        _TIFFfree(buf);\n    }\n    else\n    {\n        ok = TIFFReadRGBAImageOriented( tif, w, h, raster,\n            ORIENTATION_TOPLEFT, 0 ) != 0;\n    }\n\n\n    if (!ok)\n    {\n        if (verbose)\n        {\n            wxLogError( _(\"TIFF: Error reading image.\") );\n        }\n\n        _TIFFfree( raster );\n        image->Destroy();\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    unsigned char *ptr = image->GetData();\n\n    unsigned char *alpha = image->GetAlpha();\n\n    uint32 pos = 0;\n\n    for (uint32 i = 0; i < h; i++)\n    {\n        for (uint32 j = 0; j < w; j++)\n        {\n            *(ptr++) = (unsigned char)TIFFGetR(raster[pos]);\n            *(ptr++) = (unsigned char)TIFFGetG(raster[pos]);\n            *(ptr++) = (unsigned char)TIFFGetB(raster[pos]);\n            if ( hasAlpha )\n                *(alpha++) = (unsigned char)TIFFGetA(raster[pos]);\n\n            pos++;\n        }\n    }\n\n\n    image->SetOption(wxIMAGE_OPTION_TIFF_PHOTOMETRIC, photometric);\n\n    uint16 compression;\n    /*\n    Copy some baseline TIFF tags which helps when re-saving a TIFF\n    to be similar to the original image.\n    */\n    if (samplesPerPixel)\n    {\n        image->SetOption(wxIMAGE_OPTION_TIFF_SAMPLESPERPIXEL, samplesPerPixel);\n    }\n\n    if (bitsPerSample)\n    {\n        image->SetOption(wxIMAGE_OPTION_TIFF_BITSPERSAMPLE, bitsPerSample);\n    }\n\n    if ( TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &compression) )\n    {\n        image->SetOption(wxIMAGE_OPTION_TIFF_COMPRESSION, compression);\n    }\n\n    // Set the resolution unit.\n    wxImageResolution resUnit = wxIMAGE_RESOLUTION_NONE;\n    uint16 tiffRes;\n    if ( TIFFGetFieldDefaulted(tif, TIFFTAG_RESOLUTIONUNIT, &tiffRes) )\n    {\n        switch (tiffRes)\n        {\n            default:\n                wxLogWarning(_(\"Unknown TIFF resolution unit %d ignored\"),\n                    tiffRes);\n                wxFALLTHROUGH;\n\n            case RESUNIT_NONE:\n                resUnit = wxIMAGE_RESOLUTION_NONE;\n                break;\n\n            case RESUNIT_INCH:\n                resUnit = wxIMAGE_RESOLUTION_INCHES;\n                break;\n\n            case RESUNIT_CENTIMETER:\n                resUnit = wxIMAGE_RESOLUTION_CM;\n                break;\n        }\n    }\n\n    image->SetOption(wxIMAGE_OPTION_RESOLUTIONUNIT, resUnit);\n\n    /*\n    Set the image resolution if it's available. Resolution tag is not\n    dependent on RESOLUTIONUNIT != RESUNIT_NONE (according to TIFF spec).\n    */\n    float resX, resY;\n\n    if ( TIFFGetField(tif, TIFFTAG_XRESOLUTION, &resX) )\n    {\n        /*\n        Use a string value to not lose precision.\n        rounding to int as cm and then converting to inch may\n        result in whole integer rounding error, eg. 201 instead of 200 dpi.\n        If an app wants an int, GetOptionInt will convert and round down.\n        */\n        image->SetOption(wxIMAGE_OPTION_RESOLUTIONX,\n            wxString::FromCDouble((double) resX));\n    }\n\n    if ( TIFFGetField(tif, TIFFTAG_YRESOLUTION, &resY) )\n    {\n        image->SetOption(wxIMAGE_OPTION_RESOLUTIONY,\n            wxString::FromCDouble((double) resY));\n    }\n\n    _TIFFfree( raster );\n\n    TIFFClose( tif );\n\n    return true;\n}",
    "int ImageIO::getTIFFSampleFormat (const Glib::ustring &fname, IIOSampleFormat &sFormat, IIOSampleArrangement &sArrangement)\n{\n#ifdef _WIN32\n    wchar_t *wfilename = (wchar_t*)g_utf8_to_utf16 (fname.c_str(), -1, NULL, NULL, NULL);\n    TIFF* in = TIFFOpenW (wfilename, \"r\");\n    g_free (wfilename);\n#else\n    TIFF* in = TIFFOpen(fname.c_str(), \"r\");\n#endif\n\n    if (in == nullptr) {\n        return IMIO_CANNOTREADFILE;\n    }\n\n    std::uint16_t bitspersample = 0, samplesperpixel = 0, sampleformat = 0;\n    int hasTag = TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n    hasTag &= TIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\n    if (!hasTag) {\n        // These are needed\n        TIFFClose(in);\n        sFormat = IIOSF_UNKNOWN;\n        return IMIO_VARIANTNOTSUPPORTED;\n    }\n\n    if (!TIFFGetField(in, TIFFTAG_SAMPLEFORMAT, &sampleformat)) {\n        /*\n         * WARNING: This is a dirty hack!\n         * We assume that files which doesn't contain the TIFFTAG_SAMPLEFORMAT tag\n         * (which is the case with uncompressed TIFFs produced by RT!) are RGB files,\n         * but that may be not true.   --- Hombre\n         */\n        sampleformat = SAMPLEFORMAT_UINT;\n    } else if (sampleformat == SAMPLEFORMAT_VOID) {\n        // according to https://www.awaresystems.be/imaging/tiff/tifftags/sampleformat.html\n        // we assume SAMPLEFORMAT_UINT if SAMPLEFORMAT_VOID is set\n        sampleformat = SAMPLEFORMAT_UINT;\n    }\n\n    std::uint16_t config;\n    TIFFGetField(in, TIFFTAG_PLANARCONFIG, &config);\n\n    if (config == PLANARCONFIG_CONTIG) {\n        sArrangement = IIOSA_CHUNKY;\n    } else {\n        sFormat = IIOSF_UNKNOWN;\n        sArrangement = IIOSA_UNKNOWN;\n        TIFFClose(in);\n        return IMIO_VARIANTNOTSUPPORTED;\n    }\n\n    std::uint16_t photometric;\n\n    if (!TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric)) {\n        TIFFClose(in);\n        return IMIO_VARIANTNOTSUPPORTED;\n    }\n\n    std::uint16_t compression;\n\n    if (photometric == PHOTOMETRIC_LOGLUV)\n        if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &compression)) {\n            compression = COMPRESSION_NONE;\n        }\n\n    TIFFClose(in);\n\n    if (photometric == PHOTOMETRIC_RGB || photometric == PHOTOMETRIC_MINISBLACK) {\n        if ((samplesperpixel == 1 || samplesperpixel == 3 || samplesperpixel == 4) && sampleformat == SAMPLEFORMAT_UINT) {\n            if (bitspersample == 8) {\n                sFormat = IIOSF_UNSIGNED_CHAR;\n                return IMIO_SUCCESS;\n            }\n\n            if (bitspersample == 16) {\n                sFormat = IIOSF_UNSIGNED_SHORT;\n                return IMIO_SUCCESS;\n            }\n        } else if ((samplesperpixel == 3 || samplesperpixel == 4) && sampleformat == SAMPLEFORMAT_IEEEFP) {\n            if (bitspersample==16) {\n                sFormat = IIOSF_FLOAT16;\n                return IMIO_SUCCESS;\n            }\n            if (bitspersample == 24) {\n                sFormat = IIOSF_FLOAT24;\n                return IMIO_SUCCESS;\n            }\n            if (bitspersample == 32) {\n                sFormat = IIOSF_FLOAT32;\n                return IMIO_SUCCESS;\n            }\n        }\n    } else if ((samplesperpixel == 3 || samplesperpixel == 4) && photometric == PHOTOMETRIC_LOGLUV) {\n        if (compression == COMPRESSION_SGILOG24) {\n            sFormat = IIOSF_LOGLUV24;\n            return IMIO_SUCCESS;\n        } else if (compression == COMPRESSION_SGILOG) {\n            sFormat = IIOSF_LOGLUV32;\n            return IMIO_SUCCESS;\n        }\n    }\n\n    return IMIO_VARIANTNOTSUPPORTED;\n}",
    "int ImageIO::loadTIFF (const Glib::ustring &fname)\n{\n\n    static MyMutex thumbMutex;\n    MyMutex::MyLock lock(thumbMutex);\n\n    if(!options.serializeTiffRead) {\n        lock.release();\n    }\n\n#ifdef _WIN32\n    wchar_t *wfilename = (wchar_t*)g_utf8_to_utf16 (fname.c_str(), -1, NULL, NULL, NULL);\n    TIFF* in = TIFFOpenW (wfilename, \"r\");\n    g_free (wfilename);\n#else\n    TIFF* in = TIFFOpen(fname.c_str(), \"r\");\n#endif\n\n    if (in == nullptr) {\n        return IMIO_CANNOTREADFILE;\n    }\n\n    if (pl) {\n        pl->setProgressStr (\"PROGRESSBAR_LOADTIFF\");\n        pl->setProgress (0.0);\n    }\n\n    int width, height;\n    TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(in, TIFFTAG_IMAGELENGTH, &height);\n\n    std::uint16_t bitspersample, samplesperpixel;\n    int hasTag = TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n    hasTag &= TIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\n    if (!hasTag) {\n        // These are needed\n        TIFFClose(in);\n        fprintf(stderr, \"Error 1 loading %s\\n\", fname.c_str());\n        fflush(stderr);\n        return IMIO_VARIANTNOTSUPPORTED;\n    }\n\n    std::uint16_t config;\n    TIFFGetField(in, TIFFTAG_PLANARCONFIG, &config);\n\n    if (config != PLANARCONFIG_CONTIG) {\n        TIFFClose(in);\n        fprintf(stderr, \"Error 2 loading %s\\n\", fname.c_str());\n        fflush(stderr);\n        return IMIO_VARIANTNOTSUPPORTED;\n    }\n\n    if (sampleFormat & (IIOSF_LOGLUV24 | IIOSF_LOGLUV32)) {\n        TIFFSetField(in, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    }\n\n    /*\n     * We could use the min/max values set in TIFFTAG_SMINSAMPLEVALUE and\n     * TIFFTAG_SMAXSAMPLEVALUE, but for now, we normalize the image to the\n     * effective minimum and maximum values\n     */\n    if (settings->verbose) {\n        printf(\"Information of \\\"%s\\\":\\n\", fname.c_str());\n        std::uint16_t tiffDefaultScale, tiffBaselineExposure, tiffLinearResponseLimit;\n        if (TIFFGetField(in, TIFFTAG_DEFAULTSCALE, &tiffDefaultScale)) {\n            printf(\"   DefaultScale: %d\\n\", tiffDefaultScale);\n        }\n        else\n            printf(\"   No DefaultScale value!\\n\");\n        if (TIFFGetField(in, TIFFTAG_BASELINEEXPOSURE, &tiffBaselineExposure)) {\n            printf(\"   BaselineExposure: %d\\n\", tiffBaselineExposure);\n        }\n        else\n            printf(\"   No BaselineExposure value!\\n\");\n        if (TIFFGetField(in, TIFFTAG_LINEARRESPONSELIMIT, &tiffLinearResponseLimit)) {\n            printf(\"   LinearResponseLimit: %d\\n\", tiffLinearResponseLimit);\n        }\n        else\n            printf(\"   No LinearResponseLimit value!\\n\");\n\n        std::uint16_t tiffMinValue, tiffMaxValue;\n        if (TIFFGetField(in, TIFFTAG_SMINSAMPLEVALUE, &tiffMinValue)) {\n            printf(\"   MinValue: %d\\n\", tiffMinValue);\n        }\n        else\n            printf(\"   No minimum value!\\n\");\n        if (TIFFGetField(in, TIFFTAG_SMAXSAMPLEVALUE, &tiffMaxValue)) {\n            printf(\"   MaxValue: %d\\n\\n\", tiffMaxValue);\n        }\n        else\n            printf(\"   No maximum value!\\n\\n\");\n        printf(\"   Those values are not taken into account, the image data are normalized to a [0;1] range\\n\\n\");\n    }\n\n    char* profdata;\n    deleteLoadedProfileData();\n\n    if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &loadedProfileLength, &profdata)) {\n        embProfile = cmsOpenProfileFromMem (profdata, loadedProfileLength);\n        loadedProfileData = new char [loadedProfileLength];\n        memcpy (loadedProfileData, profdata, loadedProfileLength);\n    } else {\n        embProfile = nullptr;\n    }\n\n    allocate (width, height);\n\n    std::unique_ptr<unsigned char[]> linebuffer(new unsigned char[TIFFScanlineSize(in) * (samplesperpixel == 1 ? 3 : 1)]);\n\n    for (int row = 0; row < height; row++) {\n        if (TIFFReadScanline(in, linebuffer.get(), row, 0) < 0) {\n            TIFFClose(in);\n            fprintf(stderr, \"Error 3 loading %s\\n\", fname.c_str());\n            fflush(stderr);\n            return IMIO_READERROR;\n        }\n\n        if (samplesperpixel > 3) {\n            for (int i = 0; i < width; i++) {\n                memmove(linebuffer.get() + i * 3 * bitspersample / 8, linebuffer.get() + i * samplesperpixel * bitspersample / 8, 3 * bitspersample / 8);\n            }\n        }\n        else if (samplesperpixel == 1) {\n            const size_t bytes = bitspersample / 8;\n            for (int i = width - 1; i >= 0; --i) {\n                const unsigned char* const src = linebuffer.get() + i * bytes;\n                unsigned char* const dest = linebuffer.get() + i * 3 * bytes;\n                memcpy(dest + 2 * bytes, src, bytes);\n                memcpy(dest + 1 * bytes, src, bytes);\n                memcpy(dest + 0 * bytes, src, bytes);\n            }\n        }\n\n        setScanline (row, linebuffer.get(), bitspersample);\n\n        if (pl && !(row % 100)) {\n            pl->setProgress ((double)(row + 1) / height);\n        }\n    }\n\n    TIFFClose(in);\n\n    if (pl) {\n        pl->setProgressStr (\"PROGRESSBAR_READY\");\n        pl->setProgress (1.0);\n    }\n\n    return IMIO_SUCCESS;\n}",
    "static int\nreadTiffNumScenes(TIFF* tiff, const std::string& filepath)\n{\n  int numscenes = 1;\n\n  char* imagedescription = nullptr;\n  // metadata is in ImageDescription of first IFD in the file.\n  if (TIFFGetField(tiff, TIFFTAG_IMAGEDESCRIPTION, &imagedescription) != 1) {\n    imagedescription = nullptr;\n    LOG_WARNING << \"Failed to read imagedescription of TIFF: '\" << filepath << \"';  interpreting as single channel.\";\n  }\n\n  std::string simagedescription = trim(imagedescription ? imagedescription : \"\");\n\n  // check for plain tiff with ImageJ imagedescription:\n  if (startsWith(simagedescription, \"ImageJ=\")) {\n    numscenes = 1;\n  } else if (startsWith(simagedescription, \"{\\\"shape\\\":\")) {\n    numscenes = 1;\n  } else if ((startsWith(simagedescription, \"<?xml version\") || startsWith(simagedescription, \"<OME xmlns\")) &&\n             endsWith(simagedescription, \"OME>\")) {\n    // convert c to xml doc.  if this fails then we don't have an ome tif.\n    pugi_agave::xml_document omexml;\n    pugi_agave::xml_parse_result parseOk = omexml.load_string(simagedescription.c_str());\n    if (!parseOk) {\n      LOG_ERROR << \"Bad OME xml metadata content\";\n      return false;\n    }\n\n    pugi_agave::xml_node omenode = omexml.child(\"OME\");\n\n    // count how many <Image> tags and that is our number of scenes.\n    numscenes = 0;\n    pugi_agave::xml_node imageEl;\n    pugi_agave::xml_node pixelsEl;\n    for (pugi_agave::xml_node imagenode : omenode.children(\"Image\")) {\n      numscenes++;\n    }\n  } else {\n    numscenes = 1;\n  }\n\n  return numscenes;\n}",
    "bool\nreadTiffDimensions(TIFF* tiff, const std::string filepath, VolumeDimensions& dims, uint32_t scene)\n{\n  char* imagedescription = nullptr;\n  // metadata is in ImageDescription of first IFD in the file.\n  if (TIFFGetField(tiff, TIFFTAG_IMAGEDESCRIPTION, &imagedescription) != 1) {\n    imagedescription = nullptr;\n    LOG_WARNING << \"Failed to read imagedescription of TIFF: '\" << filepath << \"';  interpreting as single channel.\";\n  }\n\n  // Temporary variables\n  uint32_t width, height;\n  //  tsize_t scanlength;\n\n  // Read dimensions of image\n  if (TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width) != 1) {\n    LOG_ERROR << \"Failed to read width of TIFF: '\" << filepath << \"'\";\n    return false;\n  }\n  if (TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height) != 1) {\n    LOG_ERROR << \"Failed to read height of TIFF: '\" << filepath << \"'\";\n    return false;\n  }\n\n  uint32_t bpp = 0;\n  if (TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bpp) != 1) {\n    LOG_ERROR << \"Failed to read bpp of TIFF: '\" << filepath << \"'\";\n    return false;\n  }\n\n  uint16_t sampleFormat = SAMPLEFORMAT_UINT;\n  if (TIFFGetField(tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat) != 1) {\n    LOG_WARNING << \"Failed to read sampleformat of TIFF: '\" << filepath << \"'\";\n  }\n  if (sampleFormat != SAMPLEFORMAT_UINT && sampleFormat != SAMPLEFORMAT_IEEEFP && sampleFormat != SAMPLEFORMAT_INT) {\n    LOG_ERROR << \"Unsupported tiff SAMPLEFORMAT \" << sampleFormat << \" for '\" << filepath << \"'\";\n    return false;\n  }\n\n  uint32_t sizeT = 1;\n  uint32_t sizeX = width;\n  uint32_t sizeY = height;\n  uint32_t sizeZ = 1;\n  uint32_t sizeC = 1;\n  float physicalSizeX = 1.0f;\n  float physicalSizeY = 1.0f;\n  float physicalSizeZ = 1.0f;\n  std::string units = \"units\";\n  // see if we can glean xy resolution from the tiff tags\n  float tiffXResolution = 1.0f;\n  if (TIFFGetField(tiff, TIFFTAG_XRESOLUTION, &tiffXResolution) == 1) {\n    physicalSizeX = 1.0f / tiffXResolution;\n  }\n  float tiffYResolution = 1.0f;\n  if (TIFFGetField(tiff, TIFFTAG_YRESOLUTION, &tiffYResolution) == 1) {\n    physicalSizeY = 1.0f / tiffYResolution;\n  }\n\n  std::vector<std::string> channelNames;\n  std::string dimensionOrder = \"XYCZT\";\n\n  std::string simagedescription = trim(imagedescription ? imagedescription : \"\");\n\n  // check for plain tiff with ImageJ imagedescription:\n  if (startsWith(simagedescription, \"ImageJ=\")) {\n    // \"ImageJ=\\nhyperstack=true\\nimages=7900\\nchannels=1\\nslices=50\\nframes=158\"\n    // \"ImageJ=1.52i\\nimages=126\\nchannels=2\\nslices=63\\nhyperstack=true\\nmode=composite\\nunit=\n    //      micron\\nfinterval=299.2315368652344\\nspacing=0.2245383462882669\\nloop=false\\nmin=9768.0\\nmax=\n    //        14591.0\\n\"\n    std::map<std::string, std::string> imagejmetadata = splitToNameValuePairs(simagedescription);\n    if (imagejmetadata.empty()) {\n      LOG_ERROR << \"Unexpected bad or empty TIFF ImageJ metadata\";\n      return false;\n    }\n\n    auto iter = imagejmetadata.find(\"channels\");\n    if (iter != imagejmetadata.end()) {\n      sizeC = std::stoi((*iter).second);\n    } else {\n      LOG_WARNING << \"Failed to read number of channels of ImageJ TIFF: '\" << filepath << \"'\";\n    }\n\n    iter = imagejmetadata.find(\"slices\");\n    if (iter != imagejmetadata.end()) {\n      sizeZ = std::stoi((*iter).second);\n    } else {\n      LOG_WARNING << \"Failed to read number of slices of ImageJ TIFF: '\" << filepath << \"'\";\n    }\n\n    iter = imagejmetadata.find(\"frames\");\n    if (iter != imagejmetadata.end()) {\n      sizeT = std::stoi((*iter).second);\n    } else {\n      LOG_WARNING << \"Failed to read number of frames of ImageJ TIFF: '\" << filepath << \"'\";\n    }\n\n    iter = imagejmetadata.find(\"spacing\");\n    if (iter != imagejmetadata.end()) {\n      try {\n        physicalSizeZ = std::stof((*iter).second);\n        if (physicalSizeZ < 0.0f) {\n          physicalSizeZ = -physicalSizeZ;\n        }\n      } catch (...) {\n        LOG_WARNING << \"Failed to read spacing of ImageJ TIFF: '\" << filepath << \"'\";\n        physicalSizeZ = 1.0f;\n      }\n    }\n\n    iter = imagejmetadata.find(\"unit\");\n    if (iter != imagejmetadata.end()) {\n      units = (*iter).second;\n    } else {\n      LOG_WARNING << \"Failed to read spatial units of ImageJ TIFF: '\" << filepath << \"'\";\n    }\n\n    for (uint32_t i = 0; i < sizeC; ++i) {\n      channelNames.push_back(std::to_string(i));\n    }\n  } else if (startsWith(simagedescription, \"SCIFIO=\")) {\n    // SCIFIO=0.41.0\n    // axes=X,Y,Unknown\n    // lengths=725,694,906\n    // scales=1.0,1.0,1.0\n    // units=null,null,null\n    // bitsPerPixel=8\n    // images=906\n    // channels=1\n    // slices=1\n    // frames=1\n    // hyperstack=true\n    // mode=composite\n    // unit=null\n\n    std::map<std::string, std::string> scifiometadata = splitToNameValuePairs(simagedescription);\n    if (scifiometadata.empty()) {\n      LOG_ERROR << \"Unexpected bad or empty TIFF SCIFIO metadata\";\n      return false;\n    }\n\n    std::vector<std::string> axes;\n    auto iter = scifiometadata.find(\"axes\");\n    if (iter != scifiometadata.end()) {\n      split((*iter).second, ',', axes);\n    } else {\n      LOG_WARNING << \"Failed to read axes of SCIFIO TIFF: '\" << filepath << \"'\";\n    }\n    std::vector<std::string> scales;\n    iter = scifiometadata.find(\"scales\");\n    if (iter != scifiometadata.end()) {\n      split((*iter).second, ',', scales);\n    } else {\n      LOG_WARNING << \"Failed to read scales of SCIFIO TIFF: '\" << filepath << \"'\";\n    }\n    std::vector<std::string> lengths;\n    iter = scifiometadata.find(\"lengths\");\n    if (iter != scifiometadata.end()) {\n      split((*iter).second, ',', lengths);\n    } else {\n      LOG_WARNING << \"Failed to read lengths of SCIFIO TIFF: '\" << filepath << \"'\";\n    }\n    std::vector<std::string> unitsArray;\n    iter = scifiometadata.find(\"units\");\n    if (iter != scifiometadata.end()) {\n      split((*iter).second, ',', unitsArray);\n      // just take the first one for now?\n      units = unitsArray[0];\n      if (units == \"null\") {\n        units = \"units\";\n      }\n    } else {\n      LOG_WARNING << \"Failed to read units of SCIFIO TIFF: '\" << filepath << \"'\";\n    }\n\n    if (lengths.size() != unitsArray.size() || scales.size() != axes.size() || scales.size() != unitsArray.size()) {\n      LOG_ERROR << \"SCIFIO TIFF metadata has inconsistent counts of lengths,units,axes,scales\";\n    }\n\n    for (size_t i = 0; i < axes.size(); ++i) {\n      std::string axis = axes[i];\n      double scale = std::stod(scales[i]);\n      std::string unit = unitsArray[i];\n      int length = std::stoi(lengths[i]);\n      if (axis == \"X\") {\n        // check consistency.\n        if (sizeX != length) {\n          LOG_WARNING << \"Inconsistent X size \" << length << \" in SCIFIO TIFF: '\" << filepath << \"'\";\n        }\n        physicalSizeX = scale;\n      } else if (axis == \"Y\") {\n        if (sizeY != length) {\n          LOG_WARNING << \"Inconsistent Y size \" << length << \" in SCIFIO TIFF: '\" << filepath << \"'\";\n        }\n        physicalSizeY = scale;\n      } else if (axis == \"Z\") {\n        sizeZ = length;\n        physicalSizeZ = scale;\n      } else if (axis == \"Channel\") {\n        sizeC = length;\n      } else if (axis == \"Time\") {\n        sizeT = length;\n      } else if (axis == \"Unknown\" && axes.size() == 3) {\n        // make a guess and use the last axis as Z\n        sizeZ = length;\n        physicalSizeZ = scale;\n      }\n    }\n    iter = scifiometadata.find(\"channels\");\n    if (iter != scifiometadata.end()) {\n      int nch = std::stoi((*iter).second);\n      if (sizeC != nch) {\n        LOG_WARNING << \"Inconsistent number of channels \" << nch << \" in SCIFIO TIFF: '\" << filepath << \"'\";\n      }\n    } else {\n      LOG_WARNING << \"Failed to read number of channels of SCIFIO TIFF: '\" << filepath << \"'\";\n    }\n\n    for (uint32_t i = 0; i < sizeC; ++i) {\n      channelNames.push_back(std::to_string(i));\n    }\n\n  } else if (startsWith(simagedescription, \"{\\\"shape\\\":\")) {\n    // expect a 4d shape array of C,Z,Y,X or 5d T,C,Z,Y,X\n    size_t firstBracket = simagedescription.find('[');\n    size_t lastBracket = simagedescription.rfind(']');\n    std::string shape = simagedescription.substr(firstBracket + 1, lastBracket - firstBracket - 1);\n    LOG_INFO << shape;\n    std::vector<std::string> shapelist;\n    split(shape, ',', shapelist);\n    if ((shapelist.size() != 4) && (shapelist.size() != 5)) {\n      LOG_ERROR << \"Expected shape to be 4D or 5D TIFF: '\" << filepath << \"'\";\n      return false;\n    }\n    dimensionOrder = \"XYZCT\";\n    bool hasT = (shapelist.size() == 5);\n    int shapeIndex = 0;\n    if (hasT) {\n      sizeT = std::stoi(shapelist[shapeIndex++]);\n    }\n    sizeC = std::stoi(shapelist[shapeIndex++]);\n    sizeZ = std::stoi(shapelist[shapeIndex++]);\n    sizeY = std::stoi(shapelist[shapeIndex++]);\n    sizeX = std::stoi(shapelist[shapeIndex++]);\n    for (uint32_t i = 0; i < sizeC; ++i) {\n      channelNames.push_back(std::to_string(i));\n    }\n\n  } else if ((startsWith(simagedescription, \"<?xml version\") || startsWith(simagedescription, \"<OME xmlns\")) &&\n             endsWith(simagedescription, \"OME>\")) {\n    // convert c to xml doc.  if this fails then we don't have an ome tif.\n    pugi_agave::xml_document omexml;\n    pugi_agave::xml_parse_result parseOk = omexml.load_string(simagedescription.c_str());\n    if (!parseOk) {\n      LOG_ERROR << \"Bad OME xml metadata content\";\n      return false;\n    }\n\n    pugi_agave::xml_node omenode = omexml.child(\"OME\");\n\n    auto binaryonlynode = omenode.child(\"BinaryOnly\");\n    if (binaryonlynode) {\n      // try to get metadata from the MetadataFile attribute\n      std::string metadatafile = binaryonlynode.attribute(\"MetadataFile\").as_string(\"\");\n      if (metadatafile.empty()) {\n        LOG_ERROR << \"BinaryOnly OME TIFFs is missing a MetadataFile attribute: '\" << filepath << \"'\";\n        return false;\n      }\n      // try to load the metadata file.\n      // try prefixing the metadatafile with the directory of the tiff.\n      std::filesystem::path tiffpath(filepath);\n      std::filesystem::path tiffdir = tiffpath.parent_path();\n      std::string metadatapath = (tiffdir / metadatafile).string();\n\n      pugi_agave::xml_document metadataxml;\n      pugi_agave::xml_parse_result parseOk = metadataxml.load_file(metadatapath.c_str());\n      if (!parseOk) {\n        LOG_ERROR << \"Failed to load metadata file: '\" << metadatafile << \"' for OME TIFF: '\" << filepath << \"'\";\n        return false;\n      }\n      omenode = metadataxml.child(\"OME\");\n      // then continue with the metadata in the metadata file.\n    }\n\n    // extract some necessary info from the xml:\n\n    // count how many <Image> tags and that is our number of scenes.\n    uint32_t numScenes = 0;\n    pugi_agave::xml_node imageEl;\n    pugi_agave::xml_node pixelsEl;\n    auto imagenodes = omenode.children(\"Image\");\n    numScenes = std::distance(imagenodes.begin(), imagenodes.end());\n    if (scene >= numScenes) {\n      LOG_ERROR << \"Requested invalid scene index \" << scene << \" in OME TIFF; returning scene 0\";\n      scene = 0;\n    }\n    auto imageElIterator = imagenodes.begin();\n    for (uint32_t i = 0; i < scene; ++i) {\n      ++imageElIterator;\n    }\n    imageEl = *imageElIterator;\n    pixelsEl = imageEl.child(\"Pixels\");\n    // for (pugi_agave::xml_node imagenode : imagenodes) {\n    //   // get the Image and Pixels element of scene\n    //   if (numScenes == scene) {\n    //     imageEl = imagenode;\n    //     pixelsEl = imagenode.child(\"Pixels\");\n    //   }\n    // }\n\n    if (!imageEl || !pixelsEl) {\n      LOG_ERROR << \"No <Pixels> element in ome xml for scene \" << scene;\n      return false;\n    }\n\n    // skipping \"complex\", \"double-complex\", and \"bit\".\n    std::map<std::string, uint32_t> mapPixelTypeBPP = { { \"uint8\", 8 },  { \"uint16\", 16 }, { \"uint32\", 32 },\n                                                        { \"int8\", 8 },   { \"int16\", 16 },  { \"int32\", 32 },\n                                                        { \"float\", 32 }, { \"double\", 64 } };\n\n    std::string pixelType = pixelsEl.attribute(\"Type\").as_string(\"uint16\");\n    std::transform(\n      pixelType.begin(), pixelType.end(), pixelType.begin(), [](unsigned char c) { return std::tolower(c); });\n    LOG_INFO << \"pixel type: \" << pixelType;\n    bpp = mapPixelTypeBPP[pixelType];\n    if (bpp != 32 && bpp != 16 && bpp != 8) {\n      LOG_ERROR << \"Image must be 8 or 16-bit integer, or 32-bit float typed\";\n      return false;\n    }\n    sizeX = requireUint32Attr(pixelsEl, \"SizeX\", 0);\n    sizeY = requireUint32Attr(pixelsEl, \"SizeY\", 0);\n    sizeZ = requireUint32Attr(pixelsEl, \"SizeZ\", 0);\n    sizeC = requireUint32Attr(pixelsEl, \"SizeC\", 0);\n    sizeT = requireUint32Attr(pixelsEl, \"SizeT\", 0);\n    // one of : \"XYZCT\", \"XYZTC\",\"XYCTZ\",\"XYCZT\",\"XYTCZ\",\"XYTZC\"\n    dimensionOrder = pixelsEl.attribute(\"DimensionOrder\").as_string(dimensionOrder.c_str());\n    physicalSizeX = requireFloatAttr(pixelsEl, \"PhysicalSizeX\", 1.0f);\n    physicalSizeY = requireFloatAttr(pixelsEl, \"PhysicalSizeY\", 1.0f);\n    physicalSizeZ = requireFloatAttr(pixelsEl, \"PhysicalSizeZ\", 1.0f);\n    std::string physicalSizeXunit = pixelsEl.attribute(\"PhysicalSizeXUnit\").as_string(\"\");\n    std::string physicalSizeYunit = pixelsEl.attribute(\"PhysicalSizeYUnit\").as_string(\"\");\n    std::string physicalSizeZunit = pixelsEl.attribute(\"PhysicalSizeZUnit\").as_string(\"\");\n    units = physicalSizeXunit;\n    if (physicalSizeYunit != units || physicalSizeZunit != units) {\n      LOG_WARNING << \"Inconsistent physical size units in OME TIFF: '\" << filepath << \"' \" << physicalSizeXunit << \" \"\n                  << physicalSizeYunit << \" \" << physicalSizeZunit;\n    }\n    // this is the documented ome-xml default.\n    if (units == \"\") {\n      units = \"um\";\n    }\n\n    // find channel names\n    int i = 0;\n    for (pugi_agave::xml_node node : pixelsEl.children(\"Channel\")) {\n      std::string chid = node.attribute(\"ID\").value();\n      std::string chname = node.attribute(\"Name\").value();\n      if (!chname.empty()) {\n        channelNames.push_back(chname);\n      } else if (!chid.empty()) {\n        channelNames.push_back(chid);\n      } else {\n        channelNames.push_back(std::to_string(i));\n      }\n      i++;\n    }\n  } else {\n    // unrecognized string / no metadata.\n    // walk the file and count the directories and assume that is Z\n    // sizeZ was initialized to 1.\n    sizeZ = 0;\n    while (TIFFSetDirectory(tiff, sizeZ)) {\n      sizeZ++;\n    };\n    channelNames.push_back(\"0\");\n  }\n\n  assert(sizeX == width);\n  assert(sizeY == height);\n\n  // allocate the destination buffer!!!!\n  assert(sizeT >= 1);\n  assert(sizeC >= 1);\n  assert(sizeX >= 1);\n  assert(sizeY >= 1);\n  assert(sizeZ >= 1);\n\n  dims.sizeX = sizeX;\n  dims.sizeY = sizeY;\n  dims.sizeZ = sizeZ;\n  dims.sizeC = sizeC;\n  dims.sizeT = sizeT;\n  dims.dimensionOrder = dimensionOrder;\n  dims.physicalSizeX = physicalSizeX;\n  dims.physicalSizeY = physicalSizeY;\n  dims.physicalSizeZ = physicalSizeZ;\n  dims.spatialUnits = VolumeDimensions::sanitizeUnitsString(units);\n  dims.bitsPerPixel = bpp;\n  dims.channelNames = channelNames;\n  dims.sampleFormat = sampleFormat;\n\n  dims.log();\n\n  return dims.validate();\n}",
    "std::shared_ptr<ImageXYZC>\nFileReaderTIFF::loadFromFile(const LoadSpec& loadSpec)\n{\n  std::string filepath = loadSpec.filepath;\n  uint32_t time = loadSpec.time;\n  uint32_t scene = loadSpec.scene;\n  VolumeDimensions outDims;\n\n  std::shared_ptr<ImageXYZC> emptyimage;\n\n  auto tStart = std::chrono::high_resolution_clock::now();\n\n  // Loads tiff file\n  ScopedTiffReader tiffreader(filepath);\n  TIFF* tiff = tiffreader.reader();\n  if (!tiff) {\n    return emptyimage;\n  }\n\n  VolumeDimensions dims;\n  bool dims_ok = readTiffDimensions(tiff, filepath, dims, scene);\n  if (!dims_ok) {\n    return emptyimage;\n  }\n\n  if (time > (int32_t)(dims.sizeT - 1)) {\n    LOG_ERROR << \"Time \" << time << \" exceeds time samples in file: \" << dims.sizeT;\n    return emptyimage;\n  }\n\n  LOG_DEBUG << \"Reading \" << (TIFFIsTiled(tiff) ? \"tiled\" : \"stripped\") << \" tiff...\";\n\n  uint32_t rowsPerStrip = 0;\n  if (TIFFGetField(tiff, TIFFTAG_ROWSPERSTRIP, &rowsPerStrip)) {\n    LOG_DEBUG << \"ROWSPERSTRIP: \" << rowsPerStrip;\n    uint32_t StripsPerImage = ((dims.sizeY + rowsPerStrip - 1) / rowsPerStrip);\n    LOG_DEBUG << \"Strips per image: \" << StripsPerImage;\n  }\n  uint32_t samplesPerPixel = 0;\n  if (TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel)) {\n    LOG_DEBUG << \"SamplesPerPixel: \" << samplesPerPixel;\n  }\n  if (samplesPerPixel != 1) {\n    LOG_WARNING << \"\" << samplesPerPixel\n                << \" samples per pixel is not supported in tiff. Attempting to ignore and use 1 sample\";\n    samplesPerPixel = 1;\n    // return emptyimage;\n  }\n\n  uint32_t planarConfig = 0;\n  if (TIFFGetField(tiff, TIFFTAG_PLANARCONFIG, &planarConfig)) {\n    LOG_DEBUG << \"PlanarConfig: \" << (planarConfig == 1 ? \"PLANARCONFIG_CONTIG\" : \"PLANARCONFIG_SEPARATE\");\n  }\n\n  uint32_t nch = loadSpec.channels.empty() ? dims.sizeC : loadSpec.channels.size();\n\n  size_t planesize_bytes = dims.sizeX * dims.sizeY * (ImageXYZC::IN_MEMORY_BPP / 8);\n  size_t channelsize_bytes = planesize_bytes * dims.sizeZ;\n  uint8_t* data = new uint8_t[channelsize_bytes * nch];\n  memset(data, 0, channelsize_bytes * nch);\n  // stash it here in case of early exit, it will be deleted\n  std::unique_ptr<uint8_t[]> smartPtr(data);\n\n  uint8_t* destptr = data;\n\n  // still assuming 1 sample per pixel (scalar data) here.\n  size_t rawPlanesize = dims.sizeX * dims.sizeY * (dims.bitsPerPixel / 8);\n  // allocate temp data for one channel\n  uint8_t* channelRawMem = new uint8_t[dims.sizeZ * rawPlanesize];\n  memset(channelRawMem, 0, dims.sizeZ * rawPlanesize);\n\n  // stash it here in case of early exit, it will be deleted\n  std::unique_ptr<uint8_t[]> smartPtrTemp(channelRawMem);\n\n  // now ready to read channels one by one.\n  for (uint32_t channel = 0; channel < nch; ++channel) {\n    uint32_t channelToLoad = channel;\n    if (!loadSpec.channels.empty()) {\n      channelToLoad = loadSpec.channels[channel];\n    }\n\n    // read entire channel into its native size\n    for (uint32_t slice = 0; slice < dims.sizeZ; ++slice) {\n      uint32_t planeIndex = dims.getPlaneIndex(slice, channelToLoad, time);\n      destptr = channelRawMem + slice * rawPlanesize;\n      if (!readTiffPlane(tiff, planeIndex, dims, destptr)) {\n        return emptyimage;\n      }\n    }\n\n    // convert to our internal format (IN_MEMORY_BPP)\n    if (!convertChannelData(data + channel * channelsize_bytes, channelRawMem, dims)) {\n      return emptyimage;\n    }\n  }\n\n  auto tEnd = std::chrono::high_resolution_clock::now();\n  std::chrono::duration<double> elapsed = tEnd - tStart;\n  LOG_DEBUG << \"TIFF loaded in \" << (elapsed.count() * 1000.0) << \"ms\";\n\n  auto tStartImage = std::chrono::high_resolution_clock::now();\n\n  // TODO: convert data to uint16_t pixels if not already.\n  // we can release the smartPtr because ImageXYZC will now own the raw data memory\n  ImageXYZC* im = new ImageXYZC(dims.sizeX,\n                                dims.sizeY,\n                                dims.sizeZ,\n                                nch,\n                                ImageXYZC::IN_MEMORY_BPP, // dims.bitsPerPixel,\n                                smartPtr.release(),\n                                dims.physicalSizeX,\n                                dims.physicalSizeY,\n                                dims.physicalSizeZ,\n                                dims.spatialUnits);\n\n  std::vector<std::string> channelNames = dims.getChannelNames(loadSpec.channels);\n  im->setChannelNames(channelNames);\n\n  tEnd = std::chrono::high_resolution_clock::now();\n  elapsed = tEnd - tStartImage;\n  LOG_DEBUG << \"ImageXYZC prepared in \" << (elapsed.count() * 1000.0) << \"ms\";\n\n  elapsed = tEnd - tStart;\n  LOG_DEBUG << \"Loaded \" << filepath << \" in \" << (elapsed.count() * 1000.0) << \"ms\";\n\n  std::shared_ptr<ImageXYZC> sharedImage(im);\n  outDims = dims;\n\n  return sharedImage;\n}",
    "bool height_tif::load(ll_t lat, ll_t lon)\n{\n\tauto lat_dec = lat_start(lat);\n\tauto lon_dec = lon_start(lon);\n\n#if USE_TIFF\n\n\t// COMPLETELY WRONG!!!\n\n\t//DUMP(lat_dec, lon_dec);\n\tif (ok(lat, lon)) {\n\t\treturn true;\n\t}\n\tconst auto lock = std::unique_lock(mutex);\n\n\tif (lat >= 90 || lat <= -90 || lon >= 180 || lon <= -180)\n\t\treturn false;\n\n\t//DUMP(lat_dec, lon_dec);\n\tif (ok(lat, lon)) {\n\t\treturn true;\n\t}\n\n\tif (lat_loading == lat_dec && lon_loading == lon_dec) {\n\t\t//DUMP(lat_dec, lon_dec);\n\t\treturn false;\n\t}\n\tDUMP((long long)this, lat_dec, lon_dec, lat_loading, lon_loading, lat_loaded,\n\t\t\tlon_loaded);\n\tTimeTaker timer(\"hgt load\");\n\n\tlat_loading = lat_dec;\n\tlon_loading = lon_dec;\n\n\t//if (srtmTile.empty())\n\t{\n\t\tconst auto zipname = gen_zip_name_15(lat_dec, lon_dec);\n\t\t//zipname = \"15-J\";\n\t\t//zipname = \"15-O\";\n\t\tconst auto zipfile = zipname + \".zip\";\n\t\tconst auto zipfull = folder + \"/\" + zipname;\n\t\tconst auto tifname = folder + \"/\" + zipname + \".tif\";\n\t\tDUMP(zipname, zipfile, tifname);\n\t\tif (!std::filesystem::exists(tifname)) {\n\t\t\tmulti_http_to_file(zipfile,\n\t\t\t\t\t{\"http://cdn.freeminer.org/earth/\" + zipfile,\n\t\t\t\t\t\t\t\"http://www.viewfinderpanoramas.org/DEM/TIF15/\" + zipfile},\n\t\t\t\t\tzipfull);\n\t\t}\n\n\t\tif (!std::filesystem::exists(tifname) && std::filesystem::exists(zipfull) &&\n\t\t\t\tstd::filesystem::file_size(zipfull)) {\n\t\t\tconst auto cmd = \"unzip \" + zipfull + \" -d \" + folder;\n\t\t\texec_to_string(cmd); // TODO just exec\n\t\t}\n\n\t\tif (std::filesystem::exists(tifname)) {\n\t\t\tif (auto tif = TIFFOpen(tifname.c_str(), \"r\"); tif) {\n\t\t\t\tuint32_t w = 0, h = 0;\n\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\t\t\tsize_t npixels = w * h;\n\t\t\t\tif (!npixels)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (auto raster = (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n\t\t\t\t\t\traster) {\n\t\t\t\t\tif (TIFFReadRGBAImage(tif, w, h, raster, 0)) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tDUMP(raster[0]);\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint8_t *bytes = (uint8_t *)&raster[0];\n\t\t\t\t\t\t\tDUMP(bytes[0], bytes[2], bytes[3], bytes[4]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*/\n\t\t\t\t\t\theights.resize(npixels);\n\n\t\t\t\t\t\tfor (size_t i = 0; i < npixels; ++i) {\n\t\t\t\t\t\t\tuint8_t *bytes = (uint8_t *)&raster[i];\n\n\t\t\t\t\t\t\tconst auto gray =\n\t\t\t\t\t\t\t\t\tfloor(((bytes[0] * 0.299) + (bytes[1] * 0.587) +\n\t\t\t\t\t\t\t\t\t\t\t(bytes[3] * 0.144) + 0.5)) -\n\t\t\t\t\t\t\t\t\t37; // Wrong?\n\t\t\t\t\t\t\tif (!(i % 100000))\n\t\t\t\t\t\t\t\tDUMP(i, raster[i], bytes[0], bytes[2], bytes[3], bytes[4],\n\t\t\t\t\t\t\t\t\t\tgray);\n\t\t\t\t\t\t\theights[i] = gray;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlat_loaded = lat_dec;\n\t\t\t\t\t\tlon_loaded = lon_dec;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDUMP(\"read fail\");\n\t\t\t\t\t}\n\t\t\t\t\t_TIFFfree(raster);\n\t\t\t\t} else {\n\t\t\t\t\tDUMP(\"malloc fail\");\n\t\t\t\t}\n\t\t\t\tTIFFClose(tif);\n\n\t\t\t\t//DUMP(w, h, npixels);\n\n\t\t\t\tif (lat_loaded == lat_dec && lon_loaded == lon_dec) {\n\t\t\t\t\tseconds_per_px_y = seconds_per_px_x = 15;\n\t\t\t\t\tside_length_x = w;\n\t\t\t\t\tside_length_y = h;\n\t\t\t\t\tDUMP(\"tif ok\", seconds_per_px_x, side_length_x, side_length_y);\n\n\t\t\t\t\tlat_loaded = lat_dec;\n\t\t\t\t\tlon_loaded = lon_dec;\n\n\t\t\t\t\tpixel_per_deg_x = (ll_t)side_length_x / tile_deg_x;\n\t\t\t\t\tpixel_per_deg_y = (ll_t)side_length_y / tile_deg_y;\n\n\t\t\t\t\tDUMP(\"loadok\", (long long)this, heights.size(), lat_loaded,\n\t\t\t\t\t\t\tlon_loaded, zipname, tifname, seconds_per_px_x,\n\t\t\t\t\t\t\tget(lat_dec, lon_dec));\n\t\t\t\t\tDUMP(\"ppd\", pixel_per_deg_x, pixel_per_deg_y);\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#endif\n\n\t//lat_loaded = lat_dec;\n\t//lon_loaded = lon_dec;\n\t// DUMP(\"loadok\", (long)this, heights.size(), lat_loaded, lon_loaded, filesize, zipname, filename, seconds_per_px, get(lat_dec, lon_dec));\n\treturn false;\n}",
    "bool height_gebco_tif::load(ll_t lat, ll_t lon)\n{\n\tconst auto lat_dec = lat90_start(lat);\n\tconst auto lon_dec = lon90_start(lon);\n#if TEST\n\tstatic int once = 0;\n\tif (!once++)\n\t\tfor (const auto &t : std::vector<std::tuple<int, int, std::string>>{\n\t\t\t\t\t {0, 0, \"n90.0_s0.0_w0.0_e90.0\"}, {1, 1, \"n90.0_s0.0_w0.0_e90.0\"},\n\t\t\t\t\t {-1, 1, \"n0.0_s-90.0_w0.0_e90.0\"}, {1, -1, \"n90.0_s0.0_w-90.0_e0.0\"},\n\t\t\t\t\t {-1, -1, \"n0.0_s-90.0_w-90.0_e0.0\"},\n\t\t\t\t\t {1, 100, \"n90.0_s0.0_w90.0_e180.0\"},\n\t\t\t\t\t {-1, -100, \"n0.0_s-90.0_w-180.0_e-90.0\"}, {-300, 0, \"\"},\n\t\t\t\t\t {0, 300, \"\"}}) {\n\t\t\tconst auto fn = folder + \"/\" + \"gebco_2023_sub_ice_\" +\n\t\t\t\t\t\t\tfile_name(get<0>(t), get<1>(t)) + \".tif\";\n\t\t\tDUMP(\"testname\", get<0>(t), get<1>(t), file_name(get<0>(t), get<1>(t)),\n\t\t\t\t\tget<2>(t), std::filesystem::exists(fn));\n\t\t\tif (!get<2>(t).empty() && get<2>(t) != file_name(get<0>(t), get<1>(t))) {\n\t\t\t\tDUMP(\"testfail\");\n\t\t\t\t//exit(1);\n\t\t\t}\n\t\t}\n#endif\n\n#if USE_TIFF\n\n\t//DUMP(lat_dec, lon_dec);\n\tif (ok(lat, lon)) {\n\t\treturn true;\n\t}\n\tconst auto lock = std::unique_lock(mutex);\n\t//DUMP(lat_dec, lon_dec);\n\tif (ok(lat, lon)) {\n\t\treturn true;\n\t}\n\tif (lat_loading == lat_dec && lon_loading == lon_dec) {\n\t\t//DUMP(lat_dec, lon_dec);\n\t\treturn false;\n\t}\n\t//DUMP(\"loadstart\", (long long)this, lat, lon, lat_dec, lon_dec, lat_loading, lon_loading, lat_loaded, lon_loaded, floor(lat / 90.0 + 1) * 90);\n\tTimeTaker timer(\"tiff load\");\n\n\tlat_loading = lat_dec;\n\tlon_loading = lon_dec;\n\n\t{\n\t\tconst auto name = file_name(lat, lon);\n\t\tauto tifname = folder + \"/\" + \"gebco_2023_sub_ice_\" + name + \".tif\";\n\t\t//DUMP(name, tifname);\n\t\tif (0) // too big zips\n\t\t{\n\t\t\tstd::string zipfile = \"gebco_2023_sub_ice_topo_geotiff.zip\";\n\t\t\tstd::string zipfull = folder + \"/\" + zipfile;\n\t\t\tif (!std::filesystem::exists(tifname)) {\n\t\t\t\tif (multi_http_to_file(zipfile,\n\t\t\t\t\t\t\t{\"https://www.bodc.ac.uk/data/open_download/gebco/gebco_2023_sub_ice_topo/geotiff/\"},\n\t\t\t\t\t\t\tzipfull)) {\n\t\t\t\t\texec_to_string(\n\t\t\t\t\t\t\t\"unzip \" + zipfull + \" -d \" + folder); // TODO just exec\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!std::filesystem::exists(tifname) && !std::filesystem::exists(zipfull)) {\n\t\t\t\tzipfile = \"gebco_2023_geotiff.zip\";\n\t\t\t\tzipfull = folder + \"/\" + zipfile;\n\t\t\t\ttifname = folder + \"/\" + \"gebco_2023_\" + name + \".tif\";\n\t\t\t\tif (multi_http_to_file(zipfile,\n\t\t\t\t\t\t\t{\"https://www.bodc.ac.uk/data/open_download/gebco/gebco_2023_tid/geotiff/\"},\n\t\t\t\t\t\t\tzipfull)) {\n\t\t\t\t\texec_to_string(\n\t\t\t\t\t\t\t\"unzip \" + zipfull + \" -d \" + folder); // TODO just exec\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstd::cerr\n\t\t\t\t\t<< \"Want \" << tifname << \" from \"\n\t\t\t\t\t<< \"https://www.bodc.ac.uk/data/open_download/gebco/gebco_2023_sub_ice_topo/geotiff/\"\n\t\t\t\t\t<< \" or \"\n\t\t\t\t\t<< \"https://www.bodc.ac.uk/data/open_download/gebco/gebco_2023_tid/geotiff/\"\n\t\t\t\t\t<< \" in \" << porting::path_cache + DIR_DELIM + \"earth\" << \"\\n\";\n\t\t}\n\n\t\t//DUMP(tifname, std::filesystem::exists(tifname));\n\n\t\tif (!std::filesystem::exists(tifname)) {\n\t\t\ttifname = folder + \"/\" + \"gebco_2023_\" + name + \".tif\";\n\t\t}\n\t\t//DUMP(\"loadtifname\", tifname, std::filesystem::exists(tifname));\n\t\tif (std::filesystem::exists(tifname)) {\n\t\t\tDUMP(\"open tif\", tifname, std::filesystem::file_size(tifname));\n\t\t\tif (const auto tif = TIFFOpen(tifname.c_str(), \"r\"); tif) {\n\t\t\t\tuint32_t w = 0;\n\t\t\t\tuint32_t h = 0;\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\t\t\tif (!w || !h) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst size_t npixels = (w + 1) * (h + 1);\n\t\t\t\t//DUMP(\"tiff size\", w, h, npixels);\n\t\t\t\theights.resize(npixels);\n\n\t\t\t\t//w = TIFFScanlineSize(tif) >> 1;\n\t\t\t\tconst tdata_t buf = _TIFFmalloc(TIFFScanlineSize(tif));\n\t\t\t\tfor (uint32_t row = 0; row < h; ++row) {\n\t\t\t\t\tTIFFReadScanline(tif, buf, row, 0);\n\n#if HGT_DEBUG\n\t\t\t\t\tif (!(row % 10000))\n\t\t\t\t\t\tDUMP(row, TIFFNumberOfStrips(tif), TIFFStripSize(tif),\n\t\t\t\t\t\t\t\t((uint8_t *)buf)[0], ((uint8_t *)buf)[2],\n\t\t\t\t\t\t\t\t((uint8_t *)buf)[3], ((uint8_t *)buf)[4]);\n#endif\n\n\t\t\t\t\tint16_t height;\n\t\t\t\t\tfor (uint32_t i = 0; i < w; ++i) {\n\t\t\t\t\t\theight = (((uint8_t *)buf)[i << 1]) |\n\t\t\t\t\t\t\t\t (((uint8_t *)buf)[(i << 1) + 1] << 8);\n\t\t\t\t\t\tif (height == -32768 || height == 31727) {\n\t\t\t\t\t\t\theight = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst auto dest = i + row * (w + 1);\n#if HGT_DEBUG\n\t\t\t\t\t\tif (!(i % 10000) && !(row % 10000))\n\t\t\t\t\t\t\tDUMP(\"fill\", i, w, h, row, dest, height, //height2,\n\t\t\t\t\t\t\t\t\t((uint8_t *)buf)[(i << 1)],\n\t\t\t\t\t\t\t\t\t((uint8_t *)buf)[(i << 1) + 1],\n\t\t\t\t\t\t\t\t\t((uint8_t *)buf)[(i << 1) + 2],\n\t\t\t\t\t\t\t\t\t((uint8_t *)buf)[(i << 1) + 3]);\n#endif\n\n\t\t\t\t\t\theights[dest] = height;\n\t\t\t\t\t}\n\t\t\t\t\tconst auto dest = w + row * (w + 1);\n\t\t\t\t\theights[dest] = height; // hack for  interpolation x+1 get\n\t\t\t\t\t\t\t\t\t\t\t//DUMP(\"xhck\", w, dest, height);\n\t\t\t\t}\n\n\t\t\t\t// hack for interpolation y+1 get\n\t\t\t\tfor (uint32_t i = 0; i <= w; ++i) {\n\t\t\t\t\tconst auto src = i + (h - 1) * (w + 1);\n\t\t\t\t\tconst auto dest = i + h * (w + 1);\n\t\t\t\t\t//DUMP(\"yhck\", i, src, dest, heights[src]);\n\t\t\t\t\theights[dest] = heights[src];\n\t\t\t\t}\n\n\t\t\t\t_TIFFfree(buf);\n\t\t\t\tTIFFClose(tif);\n\n\t\t\t\tlat_loaded = lat_dec;\n\t\t\t\tlon_loaded = lon_dec;\n\n\t\t\t\tside_length_x = w;\n\t\t\t\tside_length_y = h;\n\n\t\t\t\tseconds_per_px_x =\n\t\t\t\t\t\ttile_deg_x * 3600 / ((float)side_length_x - side_length_x_extra);\n\t\t\t\tseconds_per_px_y = tile_deg_y * 3600 / ((float)side_length_y);\n\n\t\t\t\tpixel_per_deg_x = (ll_t)side_length_x / tile_deg_x;\n\t\t\t\tpixel_per_deg_y = (ll_t)side_length_y / tile_deg_y;\n\n#if HGT_DEBUG\n\t\t\t\tDUMP(\"tif ok\", seconds_per_px_x, side_length_x, side_length_y,\n\t\t\t\t\t\tseconds_per_px_x, seconds_per_px_y);\n\t\t\t\tDUMP(\"loadok\", (long)this, heights.size(), lat_loaded, lon_loaded,\n\t\t\t\t\t\ttifname, seconds_per_px_x, get(lat_dec, lon_dec));\n\t\t\t\tDUMP(\"testread\", read(0, 0), read(0, side_length_x - 1),\n\t\t\t\t\t\tread(side_length_y - 1, side_length_x - 1),\n\t\t\t\t\t\tread(side_length_y - 1, 0));\n#endif\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n#endif\n\n\t// DUMP(\"load not ok\", (long long)this, heights.size(), lat_loaded, lon_loaded, seconds_per_px_x, get(lat_dec, lon_dec));\n\treturn false;\n}",
    "void tif_in::open(const char* filename)\n  {\n    tiff_handle = NULL;\n    if ((tiff_handle = TIFFOpen(filename, \"r\")) == NULL)\n      OJPH_ERROR(0x03000091, \"Unable to open file %s\", filename);\n    fname = filename;\n\n    ui32 tiff_width = 0;\n    ui32 tiff_height = 0; \n    TIFFGetField(tiff_handle, TIFFTAG_IMAGEWIDTH, &tiff_width);\n    TIFFGetField(tiff_handle, TIFFTAG_IMAGELENGTH, &tiff_height);\n\n    ui16 tiff_bits_per_sample = 0;\n    ui16 tiff_samples_per_pixel = 0;\n    TIFFGetField(tiff_handle, TIFFTAG_BITSPERSAMPLE, &tiff_bits_per_sample);\n    TIFFGetField(tiff_handle, TIFFTAG_SAMPLESPERPIXEL, &tiff_samples_per_pixel);\n    // some TIFs have tiff_samples_per_pixel=0 when it is a single channel \n    // image - set to 1\n    tiff_samples_per_pixel = \n      (tiff_samples_per_pixel < 1) ? 1 : tiff_samples_per_pixel;\n\n    ui16 tiff_planar_configuration = 0;\n    ui16 tiff_photometric = 0;\n    TIFFGetField(tiff_handle, TIFFTAG_PLANARCONFIG, &tiff_planar_configuration);\n    TIFFGetField(tiff_handle, TIFFTAG_PHOTOMETRIC, &tiff_photometric);\n\n    planar_configuration = tiff_planar_configuration;\n\n    ui16 tiff_compression = 0;\n    ui32 tiff_rows_per_strip = 0;\n    TIFFGetField(tiff_handle, TIFFTAG_COMPRESSION, &tiff_compression);\n    TIFFGetField(tiff_handle, TIFFTAG_ROWSPERSTRIP, &tiff_rows_per_strip);\n\n    if (tiff_planar_configuration == PLANARCONFIG_SEPARATE)\n    {\n      bytes_per_line = tiff_samples_per_pixel * TIFFScanlineSize64(tiff_handle);\n    }\n    else\n    {\n      bytes_per_line = TIFFScanlineSize64(tiff_handle);\n    }\n    // allocate linebuffer to hold a line of image data\n    line_buffer = malloc(bytes_per_line);\n    if (NULL == line_buffer)\n      OJPH_ERROR(0x03000092, \"Unable to allocate %d bytes for line_buffer[] \"\n        \"for file %s\", bytes_per_line, filename);\n      \n    cur_line = 0;\n\n    // Error on known incompatilbe input formats\n    if( tiff_bits_per_sample != 8 && tiff_bits_per_sample != 16 )\n    {\n      OJPH_ERROR(0x03000093, \"\\nTIFF IO is currently limited\"\n        \" to files with TIFFTAG_BITSPERSAMPLE=8 and TIFFTAG_BITSPERSAMPLE=16 \\n\"\n        \"input file = %s has TIFFTAG_BITSPERSAMPLE=%d\", \n        filename, tiff_bits_per_sample);\n    }\n\n    if( TIFFIsTiled( tiff_handle ) )\n    {\n      OJPH_ERROR(0x03000094, \"\\nTIFF IO is currently limited to TIF files \"\n        \"without tiles. \\nInput file %s has been detected as tiled\", filename);\n    }\n\n    if(PHOTOMETRIC_RGB != tiff_photometric && \n       PHOTOMETRIC_MINISBLACK != tiff_photometric )\n    {\n      OJPH_ERROR(0x03000095, \"\\nTIFF IO is currently limited to \"\n        \"TIFFTAG_PHOTOMETRIC=PHOTOMETRIC_MINISBLACK=%d and \"\n        \"PHOTOMETRIC_RGB=%d. \\nInput file %s has been detected \"\n        \"TIFFTAG_PHOTOMETRIC=%d\", \n      PHOTOMETRIC_MINISBLACK, PHOTOMETRIC_RGB, filename, tiff_photometric);\n    }\n\n    if( tiff_samples_per_pixel > 4 )\n    {\n      OJPH_ERROR(0x03000096, \"\\nTIFF IO is currently limited to \"\n        \"TIFFTAG_SAMPLESPERPIXEL=4 \\nInput file %s has been detected with \"\n        \"TIFFTAG_SAMPLESPERPIXEL=%d\",\n        filename, tiff_samples_per_pixel);\n    }\n\n    // set number of components based on tiff_samples_per_pixel\n    width = tiff_width;\n    height = tiff_height;\n    num_comps = tiff_samples_per_pixel;\n    bytes_per_sample = (tiff_bits_per_sample + 7) / 8;\n    for (ui32 comp_num = 0; comp_num < num_comps; comp_num++)\n      bit_depth[comp_num] = tiff_bits_per_sample;\n\n    // allocate intermediate linebuffers to hold a line of a single component \n    // of image data\n    if (tiff_planar_configuration == PLANARCONFIG_SEPARATE && \n        bytes_per_sample == 1)\n    {\n      line_buffer_for_planar_support_uint8 = \n        (uint8_t*)calloc(width, sizeof(uint8_t));\n      if (NULL == line_buffer_for_planar_support_uint8)\n        OJPH_ERROR(0x03000097, \"Unable to allocate %d bytes for \"\n          \"line_buffer_for_planar_support_uint8[] for file %s\", \n          width * sizeof(uint8_t), filename);\n    }\n    if (tiff_planar_configuration == PLANARCONFIG_SEPARATE && \n        bytes_per_sample == 2)\n    {\n      line_buffer_for_planar_support_uint16 = \n        (uint16_t*)calloc(width, sizeof(uint16_t));\n      if (NULL == line_buffer_for_planar_support_uint16)\n        OJPH_ERROR(0x03000098, \"Unable to allocate %d bytes for \"\n          \"line_buffer_for_planar_support_uint16[] for file %s\", \n          width * sizeof(uint16_t), filename);\n    }\n  }",
    "void LavaVu::readVolumeTIFF(const FilePath& fn)\n{\n#ifdef HAVE_LIBTIFF\n  TIFF* tif = TIFFOpen(fn.full.c_str(), \"r\");\n  if (tif)\n  {\n    unsigned int width, height;\n    size_t npixels;\n    int channels = 4;\n    GLubyte* imageData;\n    int count = 0;\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n    npixels = width * height;\n    imageData = (GLubyte*)_TIFFmalloc(npixels * channels * sizeof(GLubyte));\n    if (imageData)\n    {\n      json volss = session.global(\"volsubsample\");\n      int d = TIFFNumberOfDirectories(tif);\n      int ds = volss[2];\n      if (d > 1) std::cout << \"TIFF contains \" << d << \" pages, sub-sampling z \" << ds << std::endl;\n      do\n      {\n        if (TIFFReadRGBAImage(tif, width, height, (uint32_t*)imageData, 0))\n        {\n          //Subsample\n          if (count % ds != 0) {count++; continue;}\n          readVolumeSlice(fn.base, imageData, width, height, channels, true);\n        }\n        count++;\n      }\n      while (TIFFReadDirectory(tif));\n      _TIFFfree(imageData);\n    }\n    TIFFClose(tif);\n  }\n#else\n  abort_program(\"Require libTIFF to load TIFF images\\n\");\n#endif\n}",
    "void ImageLoader::loadTIFF()\r\n{\r\n  newSource();\r\n#ifdef HAVE_LIBTIFF\r\n  TIFF* tif = TIFFOpen(fn.full.c_str(), \"r\");\r\n  if (tif)\r\n  {\r\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &source->width);\r\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &source->height);\r\n    TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &source->channels);\r\n    //source->channels = 4;\r\n    source->allocate();   // Reserve Memory\r\n    if (source->pixels)\r\n    {\r\n      if (TIFFReadRGBAImage(tif, source->width, source->height, (uint32_t*)source->pixels, 0))\r\n      {\r\n        //Succeeded\r\n      }\r\n      else\r\n        clear();\r\n    }\r\n    TIFFClose(tif);\r\n  }\r\n#else\r\n  abort_program(\"[Load Texture] Require libTIFF to load TIFF images\\n\");\r\n#endif\r\n}",
    "bool CxImageTIF::Decode(CxFile * hFile)\n{\n\t//Comment this line if you need more information on errors\n\t// TIFFSetErrorHandler(NULL);\t//<Patrick Hoffmann>\n\n\t//Open file and fill the TIFF structure\n\t// m_tif = TIFFOpen(imageFileName,\"rb\");\n\tTIFF* m_tif = _TIFFOpenEx(hFile, \"rb\");\n\n\tuint32 height=0;\n\tuint32 width=0;\n\tuint16 bitspersample=1;\n\tuint16 samplesperpixel=1;\n\tuint32 rowsperstrip=(uint32_t)-1;\n\tuint16 photometric=0;\n\tuint16 compression=1;\n\tuint16 orientation=ORIENTATION_TOPLEFT; //<vho>\n\tuint16 res_unit; //<Trifon>\n\tuint32 x, y;\n\tfloat resolution, offset;\n\tBOOL isRGB;\n\tuint8_t *bits;\t\t//pointer to source data\n\tuint8_t *bits2;\t//pointer to destination data\n\n  cx_try\n  {\n\t//check if it's a tiff file\n\tif (!m_tif)\n\t\tcx_throw(\"Error encountered while opening TIFF file\");\n\n\t// <Robert Abram> - 12/2002 : get NumFrames directly, instead of looping\n\t// info.nNumFrames=0;\n\t// while(TIFFSetDirectory(m_tif,(uint16)info.nNumFrames)) info.nNumFrames++;\n\tinfo.nNumFrames = TIFFNumberOfDirectories(m_tif);\n\n\tif (!TIFFSetDirectory(m_tif, (uint16)info.nFrame))\n\t\tcx_throw(\"Error: page not present in TIFF file\");\t\t\t\n\n\t//get image info\n\tTIFFGetField(m_tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(m_tif, TIFFTAG_IMAGELENGTH, &height);\n\tTIFFGetField(m_tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\tTIFFGetField(m_tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\tTIFFGetField(m_tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);   \n\tTIFFGetField(m_tif, TIFFTAG_PHOTOMETRIC, &photometric);\n\tTIFFGetField(m_tif, TIFFTAG_ORIENTATION, &orientation);\n\n\tif (info.nEscape == -1) {\n\t\t// Return output dimensions only\n\t\thead.biWidth = width;\n\t\thead.biHeight = height;\n\t\tinfo.dwType = CXIMAGE_FORMAT_TIF;\n\t\tcx_throw(\"output dimensions returned\");\n\t}\n\n\tTIFFGetFieldDefaulted(m_tif, TIFFTAG_RESOLUTIONUNIT, &res_unit);\n\tif (TIFFGetField(m_tif, TIFFTAG_XRESOLUTION, &resolution))\n\t{\n\t\tif (res_unit == RESUNIT_CENTIMETER) resolution = (float)(resolution*2.54f + 0.5f);\n\t\tSetXDPI((int32_t)resolution);\n\t}\n\tif (TIFFGetField(m_tif, TIFFTAG_YRESOLUTION, &resolution))\n\t{\n\t\tif (res_unit == RESUNIT_CENTIMETER) resolution = (float)(resolution*2.54f + 0.5f);\n\t\tSetYDPI((int32_t)resolution);\n\t}\n\n\tif (TIFFGetField(m_tif, TIFFTAG_XPOSITION, &offset))\tinfo.xOffset = (int32_t)offset;\n\tif (TIFFGetField(m_tif, TIFFTAG_YPOSITION, &offset))\tinfo.yOffset = (int32_t)offset;\n\n\thead.biClrUsed=0;\n\tinfo.nBkgndIndex =-1;\n\n\tif (rowsperstrip>height){\n\t\trowsperstrip=height;\n\t\tTIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\t}\n\n\tisRGB = /*(bitspersample >= 8) && (VK: it is possible so for RGB to have < 8 bpp!)*/\n\t\t(photometric == PHOTOMETRIC_RGB) ||\n\t\t(photometric == PHOTOMETRIC_YCBCR) ||\n\t\t(photometric == PHOTOMETRIC_SEPARATED) ||\n\t\t(photometric == PHOTOMETRIC_LOGL) ||\n\t\t(photometric == PHOTOMETRIC_LOGLUV);\n\n\tif (isRGB){\n\t\thead.biBitCount=24;\n\t}else{\n\t\tif ((photometric==PHOTOMETRIC_MINISBLACK)||(photometric==PHOTOMETRIC_MINISWHITE)||(photometric==PHOTOMETRIC_PALETTE)){\n\t\t\tif\t(bitspersample == 1){\n\t\t\t\thead.biBitCount=1;\t\t//B&W image\n\t\t\t\thead.biClrUsed =2;\n\t\t\t} else if (bitspersample == 4) {\n\t\t\t\thead.biBitCount=4;\t\t//16 colors gray scale\n\t\t\t\thead.biClrUsed =16;\n\t\t\t} else {\n\t\t\t\thead.biBitCount=8;\t\t//gray scale\n\t\t\t\thead.biClrUsed =256;\n\t\t\t}\n\t\t} else if (bitspersample == 4) {\n\t\t\thead.biBitCount=4;\t\t\t// 16 colors\n\t\t\thead.biClrUsed=16;\n\t\t} else {\n\t\t\thead.biBitCount=8;\t\t\t//256 colors\n\t\t\thead.biClrUsed=256;\n\t\t}\n\n\t\tif ((bitspersample > 8) && (photometric==PHOTOMETRIC_PALETTE))\t// + VK + (BIG palette! => convert to RGB)\n\t\t{\thead.biBitCount=24;\n\t\t\thead.biClrUsed =0;\n\t\t}\n\t}\n\n\tif (info.nEscape) cx_throw(\"Cancelled\"); // <vho> - cancel decoding\n\n\tCreate(width,height,head.biBitCount,CXIMAGE_FORMAT_TIF);\t//image creation\n\tif (!pDib) cx_throw(\"CxImageTIF can't create image\");\n\n#if CXIMAGE_SUPPORT_ALPHA\n\tif (samplesperpixel==4) AlphaCreate();\t//add alpha support for 32bpp tiffs\n\tif (samplesperpixel==2 && bitspersample==8) AlphaCreate();\t//add alpha support for 8bpp + alpha\n#endif //CXIMAGE_SUPPORT_ALPHA\n\n\tTIFFGetField(m_tif, TIFFTAG_COMPRESSION, &compression);\n\tSetCodecOption(compression); // <DPR> save original compression type\n\n\tif (isRGB) {\n\t\t// Read the whole image into one big RGBA buffer using\n\t\t// the traditional TIFFReadRGBAImage() API that we trust.\n\t\tuint32* raster;\t\t// retrieve RGBA image\n\t\tuint32 *row;\n\n\t\traster = (uint32*)_TIFFmalloc(width * height * sizeof (uint32));\n\t\tif (raster == NULL) cx_throw(\"No space for raster buffer\");\n\t\t\t\n\t\t// Read the image in one chunk into an RGBA array\n\t\tif(!TIFFReadRGBAImage(m_tif, width, height, raster, 1)) {\n\t\t\t\t_TIFFfree(raster);\n\t\t\t\tcx_throw(\"Corrupted TIFF file!\");\n\t\t}\n\n\t\t// read the raster lines and save them in the DIB\n\t\t// with RGB mode, we have to change the order of the 3 samples RGB\n\t\trow = &raster[0];\n\t\tbits2 = info.pImage;\n\t\tfor (y = 0; y < height; y++) {\n\n\t\t\tif (info.nEscape){ // <vho> - cancel decoding\n\t\t\t\t_TIFFfree(raster);\n\t\t\t\tcx_throw(\"Cancelled\");\n\t\t\t}\n\n\t\t\tbits = bits2;\n\t\t\tfor (x = 0; x < width; x++) {\n\t\t\t\t*bits++ = (uint8_t)TIFFGetB(row[x]);\n\t\t\t\t*bits++ = (uint8_t)TIFFGetG(row[x]);\n\t\t\t\t*bits++ = (uint8_t)TIFFGetR(row[x]);\n#if CXIMAGE_SUPPORT_ALPHA\n\t\t\t\tif (samplesperpixel==4) AlphaSet(x,y,(uint8_t)TIFFGetA(row[x]));\n#endif //CXIMAGE_SUPPORT_ALPHA\n\t\t\t}\n\t\t\trow += width;\n\t\t\tbits2 += info.dwEffWidth;\n\t\t}\n\t\t_TIFFfree(raster);\n\t} else {\n\t\tint32_t BIG_palette = (bitspersample > 8) &&\t// + VK\n\t\t\t\t\t\t  (photometric==PHOTOMETRIC_PALETTE);\t\t\n\t\tif (BIG_palette && (bitspersample > 24))\t// + VK\n\t\t\tcx_throw(\"Too big palette to handle\");\t\t// + VK\n\n\t\tRGBQUAD *pal;\n\t\tpal=(RGBQUAD*)calloc(BIG_palette ? 1<<bitspersample : 256,sizeof(RGBQUAD)); \n\t\t\t// ! VK: it coasts nothing but more correct to use 256 as temp palette storage\n\t\t\t// ! VK: but for case of BIG palette it just copied\n\t\tif (pal==NULL) cx_throw(\"Unable to allocate TIFF palette\");\n\n\t\tint32_t bpp = bitspersample <= 8 ? bitspersample : 8; // + VK (to use instead of bitspersample for case of > 8)\n\n\t\t// set up the colormap based on photometric\t\n\t\tswitch(photometric) {\n\t\t\tcase PHOTOMETRIC_MINISBLACK:\t// bitmap and greyscale image types\n\t\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\t\t\tif (bitspersample == 1) {\t// Monochrome image\n\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISBLACK) {\n\t\t\t\t\t\tpal[1].rgbRed = pal[1].rgbGreen = pal[1].rgbBlue = 255;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpal[0].rgbRed = pal[0].rgbGreen = pal[0].rgbBlue = 255;\n\t\t\t\t\t}\n\t\t\t\t} else {\t\t// need to build the scale for greyscale images\n\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISBLACK) {\n\t\t\t\t\t\tfor (int32_t i=0; i<(1<<bpp); i++){\n\t\t\t\t\t\t\tpal[i].rgbRed = pal[i].rgbGreen = pal[i].rgbBlue = (uint8_t)(i*(255/((1<<bpp)-1)));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (int32_t i=0; i<(1<<bpp); i++){\n\t\t\t\t\t\t\tpal[i].rgbRed = pal[i].rgbGreen = pal[i].rgbBlue = (uint8_t)(255-i*(255/((1<<bpp)-1)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_PALETTE:\t// color map indexed\n\t\t\t\tuint16 *red;\n\t\t\t\tuint16 *green;\n\t\t\t\tuint16 *blue;\n\t\t\t\tTIFFGetField(m_tif, TIFFTAG_COLORMAP, &red, &green, &blue); \n\n\t\t\t\t// Is the palette 16 or 8 bits ?\n\t\t\t\tBOOL Palette16Bits = /*FALSE*/ BIG_palette;\n\t\t\t\tif (!BIG_palette) {\n\t\t\t\t\tint32_t n= 1<<bpp;\n\t\t\t\t\twhile (n-- > 0) {\n\t\t\t\t\t\tif (red[n] >= 256 || green[n] >= 256 || blue[n] >= 256) {\n\t\t\t\t\t\t\tPalette16Bits=TRUE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// load the palette in the DIB\n\t\t\t\tfor (int32_t i = (1 << ( BIG_palette ? bitspersample : bpp )) - 1; i >= 0; i--) {\n\t\t\t\t\tif (Palette16Bits) {\n\t\t\t\t\t\tpal[i].rgbRed =(uint8_t) CVT(red[i]);\n\t\t\t\t\t\tpal[i].rgbGreen = (uint8_t) CVT(green[i]);\n\t\t\t\t\t\tpal[i].rgbBlue = (uint8_t) CVT(blue[i]);           \n\t\t\t\t\t} else {\n\t\t\t\t\t\tpal[i].rgbRed = (uint8_t) red[i];\n\t\t\t\t\t\tpal[i].rgbGreen = (uint8_t) green[i];\n\t\t\t\t\t\tpal[i].rgbBlue = (uint8_t) blue[i];        \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!BIG_palette) { // + VK (BIG palette is stored until image is ready)\n\t\t\tSetPalette(pal,/*head.biClrUsed*/ 1<<bpp);\t//palette assign // * VK\n\t\t\tfree(pal); \n\t\t\tpal = NULL; \n\t\t}\n\n\t\t// read the tiff lines and save them in the DIB\n\t\tuint32 nrow;\n\t\tuint32 ys;\n\t\tint32_t line = CalculateLine(width, bitspersample * samplesperpixel);\n\t\t\n\t\tint32_t bitsize = TIFFStripSize(m_tif);\n\t\t//verify bitsize: could be wrong if StripByteCounts is missing.\n\t\tif (bitsize>(int32_t)(head.biSizeImage*samplesperpixel))\n\t\t\tbitsize = head.biSizeImage*samplesperpixel;\n\t\tif (bitsize<(int32_t)(info.dwEffWidth*rowsperstrip))\n\t\t\tbitsize = info.dwEffWidth*rowsperstrip;\n\n\t\tif ((bitspersample > 8) && (bitspersample != 16))\t// + VK (for bitspersample == 9..15,17..32..64\n\t\t\tbitsize *= (bitspersample + 7)/8; \n\n\t\tint32_t tiled_image = TIFFIsTiled(m_tif);\n\t\tuint32 tw=0, tl=0;\n\t\tuint8_t* tilebuf=NULL;\n\t\tif (tiled_image){\n\t\t\tTIFFGetField(m_tif, TIFFTAG_TILEWIDTH, &tw);\n\t\t\tTIFFGetField(m_tif, TIFFTAG_TILELENGTH, &tl);\n\t\t\trowsperstrip = tl;\n\t\t\tbitsize = TIFFTileSize(m_tif) * (int32_t)(1+width/tw);\n\t\t\ttilebuf = (uint8_t*)malloc(TIFFTileSize(m_tif));\n\t\t}\n\t\t\n\t\tbits = (uint8_t*)malloc(bitspersample==16? bitsize*2 : bitsize); // * VK\n\t\tuint8_t * bits16 = NULL;\t\t\t\t\t\t\t\t\t\t  // + VK\n\t\tint32_t line16    = 0;\t\t\t\t\t\t\t\t\t\t\t  // + VK\n\n\t\tif (!tiled_image && bitspersample==16) {\t\t\t\t\t  // + VK +\n\t\t\tline16 = line;\n\t\t\tline   = CalculateLine(width, 8 * samplesperpixel);\n\t\t\tbits16 = bits;\n\t\t\tbits   = (uint8_t*)malloc(bitsize);\n\t\t}\n\n\t\tif (bits==NULL){\n\t\t\tif (bits16) free(bits16);\t\t\t\t\t\t\t\t  // + VK\n\t\t\tif (pal)\tfree(pal);\t\t\t\t\t\t\t\t\t  // + VK\n\t\t\tif (tilebuf)free(tilebuf);\t\t\t\t\t\t\t\t  // + VK\t\n\t\t\tcx_throw(\"CxImageTIF can't allocate memory\");\n\t\t}\n\n#ifdef FIX_16BPP_DARKIMG // + VK: for each line, store shift count bits used to fix it\n\t\tuint8_t* row_shifts = NULL;\n\t\tif (bits16) row_shifts = (uint8_t*)malloc(height); \n#endif\n\n\t\tfor (ys = 0; ys < height; ys += rowsperstrip) {\n\n\t\t\tif (info.nEscape){ // <vho> - cancel decoding\n\t\t\t\tfree(bits);\n\t\t\t\tcx_throw(\"Cancelled\");\n\t\t\t}\n\n\t\t\tnrow = (ys + rowsperstrip > height ? height - ys : rowsperstrip);\n\n\t\t\tif (tiled_image){\n\t\t\t\tuint32 imagew = TIFFScanlineSize(m_tif);\n\t\t\t\tuint32 tilew  = TIFFTileRowSize(m_tif);\n\t\t\t\tint32_t iskew = imagew - tilew;\n\t\t\t\tuint8* bufp = (uint8*) bits;\n\n\t\t\t\tuint32 colb = 0;\n\t\t\t\tfor (uint32 col = 0; col < width; col += tw) {\n\t\t\t\t\tif (TIFFReadTile(m_tif, tilebuf, col, ys, 0, 0) < 0){\n\t\t\t\t\t\tfree(tilebuf);\n\t\t\t\t\t\tfree(bits);\n\t\t\t\t\t\tcx_throw(\"Corrupted tiled TIFF file!\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (colb + tw > imagew) {\n\t\t\t\t\t\tuint32 owidth = imagew - colb;\n\t\t\t\t\t\tuint32 oskew = tilew - owidth;\n\t\t\t\t\t\tTileToStrip(bufp + colb, tilebuf, nrow, owidth, oskew + iskew, oskew );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tTileToStrip(bufp + colb, tilebuf, nrow, tilew, iskew, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcolb += tilew;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tif (TIFFReadEncodedStrip(m_tif, TIFFComputeStrip(m_tif, ys, 0), \n\t\t\t\t\t(bits16? bits16 : bits), nrow * (bits16 ? line16 : line)) == -1) { // * VK\n\n#ifdef NOT_IGNORE_CORRUPTED\n\t\t\t\t\tfree(bits);\n\t\t\t\t\tif (bits16) free(bits16);  // + VK\n\t\t\t\t\tcx_throw(\"Corrupted TIFF file!\");\n#else\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (y = 0; y < nrow; y++) {\n\t\t\t\tint32_t offset=(nrow-y-1)*line;\n\t\t\t\tif ((bitspersample==16) && !BIG_palette) {\t// * VK\n\t\t\t\t\tint32_t offset16 = (nrow-y-1)*line16;\t\t// + VK\n\t\t\t\t\tif (bits16)\t{\t\t\t\t\t\t\t// + VK +\n#ifdef FIX_16BPP_DARKIMG\n\t\t\t\t\t\tint32_t the_shift;\n\t\t\t\t\t\tuint8_t hi_byte, hi_max=0;\n\t\t\t\t\t\tuint32_t xi;\n\t\t\t\t\t\tfor (xi=0;xi<(uint32)line;xi++) {\n\t\t\t\t\t\t\thi_byte = bits16[xi*2+offset16+1];\n\t\t\t\t\t\t\tif(hi_byte>hi_max)\n\t\t\t\t\t\t\t\thi_max = hi_byte;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthe_shift = (hi_max == 0) ? 8 : 0;\n\t\t\t\t\t\tif (!the_shift)\n\t\t\t\t\t\t\twhile( ! (hi_max & 0x80) ) {\n\t\t\t\t\t\t\t\tthe_shift++;\n\t\t\t\t\t\t\t\thi_max <<= 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\trow_shifts[height-ys-nrow+y] = the_shift;\n\t\t\t\t\t\tthe_shift = 8 - the_shift;\n\t\t\t\t\t\tfor (xi=0;xi<(uint32)line;xi++) \n\t\t\t\t\t\t\tbits[xi+offset]= ((bits16[xi*2+offset16+1]<<8) | bits16[xi*2+offset16]) >> the_shift;\n#else\n\t\t\t\t\t\tfor (uint32_t xi=0;xi<(uint32)line;xi++) \n\t\t\t\t\t\t\tbits[xi+offset]=bits16[xi*2+offset16+1];\n#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (uint32_t xi=0;xi<width;xi++)\n\t\t\t\t\t\t\tbits[xi+offset]=bits[xi*2+offset+1];\n\t\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (samplesperpixel==1) { \n\t\t\t\t\tif (BIG_palette)\n\t\t\t\t\t\tif (bits16) {\n\t\t\t\t\t\t\tint32_t offset16 = (nrow-y-1)*line16;\t\t// + VK\n\t\t\t\t\t\t\tMoveBitsPal( info.pImage + info.dwEffWidth * (height-ys-nrow+y),\n\t\t\t\t\t\t\t\t\t bits16 + offset16, width, bitspersample, pal );\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tMoveBitsPal( info.pImage + info.dwEffWidth * (height-ys-nrow+y),\n\t\t\t\t\t\t\t\t\t bits + offset, width, bitspersample, pal );\n\t\t\t\t\telse if ((bitspersample == head.biBitCount) || \n\t\t\t\t\t\t(bitspersample == 16))\t//simple 8bpp, 4bpp image or 16bpp\n\t\t\t\t\t\tmemcpy(info.pImage+info.dwEffWidth*(height-ys-nrow+y),bits+offset,min((unsigned)line, info.dwEffWidth));\n\t\t\t\t\telse\n\t\t\t\t\t\tMoveBits( info.pImage + info.dwEffWidth * (height-ys-nrow+y),\n\t\t\t\t\t\t\t\t  bits + offset, width, bitspersample );\n\t\t\t\t} else if (samplesperpixel==2) { //8bpp image with alpha layer\n\t\t\t\t\tint32_t xi=0;\n\t\t\t\t\tint32_t ii=0;\n\t\t\t\t\tint32_t yi=height-ys-nrow+y;\n#if CXIMAGE_SUPPORT_ALPHA\n\t\t\t\t\tif (!pAlpha) AlphaCreate();\t\t\t// + VK\n#endif //CXIMAGE_SUPPORT_ALPHA\n\t\t\t\t\twhile (ii<line){\n\t\t\t\t\t\tSetPixelIndex(xi,yi,bits[ii+offset]);\n#if CXIMAGE_SUPPORT_ALPHA\n\t\t\t\t\t\tAlphaSet(xi,yi,bits[ii+offset+1]);\n#endif //CXIMAGE_SUPPORT_ALPHA\n\t\t\t\t\t\tii+=2;\n\t\t\t\t\t\txi++;\n\t\t\t\t\t\tif (xi>=(int32_t)width){\n\t\t\t\t\t\t\tyi--;\n\t\t\t\t\t\t\txi=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else { //photometric==PHOTOMETRIC_CIELAB\n\t\t\t\t\tif (head.biBitCount!=24){ //fix image\n\t\t\t\t\t\tCreate(width,height,24,CXIMAGE_FORMAT_TIF);\n#if CXIMAGE_SUPPORT_ALPHA\n\t\t\t\t\t\tif (samplesperpixel==4) AlphaCreate();\n#endif //CXIMAGE_SUPPORT_ALPHA\n\t\t\t\t\t}\n\n\t\t\t\t\tint32_t xi=0;\n\t\t\t\t\tuint32 ii=0;\n\t\t\t\t\tint32_t yi=height-ys-nrow+y;\n\t\t\t\t\tRGBQUAD c;\n\t\t\t\t\tint32_t l,a,b,bitsoffset;\n\t\t\t\t\tdouble p,cx,cy,cz,cr,cg,cb;\n\t\t\t\t\twhile (ii</*line*/width){\t\t// * VK\n\t\t\t\t\t\tbitsoffset = ii*samplesperpixel+offset;\n\t\t\t\t\t\tl=bits[bitsoffset];\n\t\t\t\t\t\ta=bits[bitsoffset+1];\n\t\t\t\t\t\tb=bits[bitsoffset+2];\n\t\t\t\t\t\tif (a>127) a-=256;\n\t\t\t\t\t\tif (b>127) b-=256;\n\t\t\t\t\t\t// lab to xyz\n\t\t\t\t\t\tp = (l/2.55 + 16) / 116.0;\n\t\t\t\t\t\tcx = pow( p + a * 0.002, 3);\n\t\t\t\t\t\tcy = pow( p, 3);\n\t\t\t\t\t\tcz = pow( p - b * 0.005, 3);\n\t\t\t\t\t\t// white point\n\t\t\t\t\t\tcx*=0.95047;\n\t\t\t\t\t\t//cy*=1.000;\n\t\t\t\t\t\tcz*=1.0883;\n\t\t\t\t\t\t// xyz to rgb\n\t\t\t\t\t\tcr =  3.240479 * cx - 1.537150 * cy - 0.498535 * cz;\n\t\t\t\t\t\tcg = -0.969256 * cx + 1.875992 * cy + 0.041556 * cz;\n\t\t\t\t\t\tcb =  0.055648 * cx - 0.204043 * cy + 1.057311 * cz;\n\n\t\t\t\t\t\tif ( cr > 0.00304 ) cr = 1.055 * pow(cr,0.41667) - 0.055;\n\t\t\t\t\t\t\telse            cr = 12.92 * cr;\n\t\t\t\t\t\tif ( cg > 0.00304 ) cg = 1.055 * pow(cg,0.41667) - 0.055;\n\t\t\t\t\t\t\telse            cg = 12.92 * cg;\n\t\t\t\t\t\tif ( cb > 0.00304 ) cb = 1.055 * pow(cb,0.41667) - 0.055;\n\t\t\t\t\t\t\telse            cb = 12.92 * cb;\n\n\t\t\t\t\t\tc.rgbRed  =(uint8_t)max(0,min(255,(int32_t)(cr*255)));\n\t\t\t\t\t\tc.rgbGreen=(uint8_t)max(0,min(255,(int32_t)(cg*255)));\n\t\t\t\t\t\tc.rgbBlue =(uint8_t)max(0,min(255,(int32_t)(cb*255)));\n\n\t\t\t\t\t\tSetPixelColor(xi,yi,c);\n#if CXIMAGE_SUPPORT_ALPHA\n\t\t\t\t\t\tif (samplesperpixel==4) AlphaSet(xi,yi,bits[bitsoffset+3]);\n#endif //CXIMAGE_SUPPORT_ALPHA\n\t\t\t\t\t\tii++;\n\t\t\t\t\t\txi++;\n\t\t\t\t\t\tif (xi>=(int32_t)width){\n\t\t\t\t\t\t\tyi--;\n\t\t\t\t\t\t\txi=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(bits);\n\t\tif (bits16) free(bits16);\n\n#ifdef FIX_16BPP_DARKIMG\n\t\tif (row_shifts && (samplesperpixel == 1) && (bitspersample==16) && !BIG_palette) {\n\t\t\t// 1. calculate maximum necessary shift\n\t\t\tint32_t min_row_shift = 8;\n\t\t\tfor( y=0; y<height; y++ ) {\n\t\t\t\tif (min_row_shift > row_shifts[y]) min_row_shift = row_shifts[y];\n\t\t\t}\n\t\t\t// 2. for rows having less shift value, correct such rows:\n\t\t\tfor( y=0; y<height; y++ ) {\n\t\t\t\tif (min_row_shift < row_shifts[y]) {\n\t\t\t\t\tint32_t need_shift = row_shifts[y] - min_row_shift;\n\t\t\t\t\tuint8_t* data = info.pImage + info.dwEffWidth * y;\n\t\t\t\t\tfor( x=0; x<width; x++, data++ )\n\t\t\t\t\t\t*data >>= need_shift;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (row_shifts)\tfree( row_shifts );\n#endif\n\n\t\tif (tiled_image) free(tilebuf);\n\t\tif (pal)\t\t free(pal);\n\n\t\tswitch(orientation){\n\t\tcase ORIENTATION_TOPRIGHT: /* row 0 top, col 0 rhs */\n\t\t\tMirror();\n\t\t\tbreak;\n\t\tcase ORIENTATION_BOTRIGHT: /* row 0 bottom, col 0 rhs */\n\t\t\tFlip();\n\t\t\tMirror();\n\t\t\tbreak;\n\t\tcase ORIENTATION_BOTLEFT: /* row 0 bottom, col 0 lhs */\n\t\t\tFlip();\n\t\t\tbreak;\n\t\tcase ORIENTATION_LEFTTOP: /* row 0 lhs, col 0 top */\n\t\t\tRotateRight();\n\t\t\tMirror();\n\t\t\tbreak;\n\t\tcase ORIENTATION_RIGHTTOP: /* row 0 rhs, col 0 top */\n\t\t\tRotateLeft();\n\t\t\tbreak;\n\t\tcase ORIENTATION_RIGHTBOT: /* row 0 rhs, col 0 bottom */\n\t\t\tRotateLeft();\n\t\t\tMirror();\n\t\t\tbreak;\n\t\tcase ORIENTATION_LEFTBOT: /* row 0 lhs, col 0 bottom */\n\t\t\tRotateRight();\n\t\t\tbreak;\n\t\t}\n\n\t}\n  }",
    "int ReadTiff(const char * filename,\n  vector<unsigned char> * ptr,\n  int * w,\n  int * h,\n  int * depth)\n{\n  TIFF* tiff = TIFFOpen(filename, \"r\");\n  if (!tiff) {\n    std::cerr << \"Error: Couldn't open \" << filename << \" fopen returned 0\";\n    return 0;\n  }\n  uint16 bps, spp;\n\n  TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, w);\n  TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, h);\n  TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  *depth = bps * spp / 8;\n\n  ptr->resize((*h)*(*w)*(*depth));\n\n  if (*depth==4) {\n    if (ptr != NULL) {\n      if (!TIFFReadRGBAImageOriented(tiff, *w, *h, (uint32*)&((*ptr)[0]), ORIENTATION_TOPLEFT, 0)) {\n        TIFFClose(tiff);\n        return 0;\n      }\n    }\n  } else {\n    for (size_t i=0; i<TIFFNumberOfStrips(tiff); ++i) {\n      if (TIFFReadEncodedStrip(tiff, i, ((uint8*)&((*ptr)[0]))+i*TIFFStripSize(tiff),(tsize_t)-1) ==\n        std::numeric_limits<tsize_t>::max()) {\n        TIFFClose(tiff);\n        return 0;\n      }\n    }\n  }\n  TIFFClose(tiff);\n  return 1;\n}",
    "bool Read_TIFF_ImageHeader(const char * filename, ImageHeader * imgheader)\n{\n  bool bStatus = false;\n\n  TIFF* tiff = TIFFOpen(filename, \"r\");\n  if (!tiff) {\n    return false;\n  }\n\n  if (imgheader)\n  {\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &imgheader->width);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &imgheader->height);\n    bStatus = true;\n  }\n\n  TIFFClose(tiff);\n  return bStatus;\n}",
    "std::unique_ptr<Bitmap> TiffLoader::Load()\n{\n    uint32_t width, height;\n    TIFFGetField( m_tiff, TIFFTAG_IMAGEWIDTH, &width );\n    TIFFGetField( m_tiff, TIFFTAG_IMAGELENGTH, &height );\n\n    auto bmp = std::make_unique<Bitmap>( width, height );\n\n    if( TIFFReadRGBAImageOriented( m_tiff, width, height, (uint32_t*)bmp->Data(), ORIENTATION_TOPLEFT ) == 0 )\n    {\n        return nullptr;\n    }\n\n    return bmp;\n}",
    "bool Image::initWithTiffData(const unsigned char * data, ssize_t dataLen)\n{\n#if CC_USE_WIC\n    return decodeWithWIC(data, dataLen);\n#elif CC_USE_TIFF\n    bool ret = false;\n    do\n    {\n        // set the read call back function\n        tImageSource imageSource;\n        imageSource.data    = data;\n        imageSource.size    = dataLen;\n        imageSource.offset  = 0;\n\n        TIFF* tif = TIFFClientOpen(\"file.tif\", \"r\", (thandle_t)&imageSource,\n            tiffReadProc, tiffWriteProc,\n            tiffSeekProc, tiffCloseProc, tiffSizeProc,\n            tiffMapProc,\n            tiffUnmapProc);\n\n        CC_BREAK_IF(nullptr == tif);\n\n        uint32 w = 0, h = 0;\n        uint16 bitsPerSample = 0, samplePerPixel = 0, planarConfig = 0;\n        size_t npixels = 0;\n\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplePerPixel);\n        TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planarConfig);\n\n        npixels = w * h;\n\n        _renderFormat = Image::PixelFormat::RGBA8888;\n        _width = w;\n        _height = h;\n\n        _dataLen = npixels * sizeof (uint32);\n        _data = static_cast<unsigned char*>(malloc(_dataLen * sizeof(unsigned char)));\n\n        uint32* raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n        if (raster != nullptr)\n        {\n           if (TIFFReadRGBAImageOriented(tif, w, h, raster, ORIENTATION_TOPLEFT, 0))\n           {\n                /* the raster data is pre-multiplied by the alpha component\n                   after invoking TIFFReadRGBAImageOriented*/\n                _hasPremultipliedAlpha = true;\n\n               memcpy(_data, raster, npixels*sizeof (uint32));\n           }\n\n          _TIFFfree(raster);\n        }\n\n\n        TIFFClose(tif);\n\n        ret = true;\n    } while (0);\n    return ret;\n#else\n    CCLOG(\"tiff is not enabled, please enable it in ccConfig.h\");\n    return false;\n#endif //CC_USE_TIFF\n}",
    "int tImageTIFF::ReadSoftwarePageDuration(TIFF* tiff) const\n{\n\tvoid* data = nullptr;\n\tint durationMilliSec = -1;\n\tint success = TIFFGetField(tiff, TIFFTAG_SOFTWARE, &data);\n\tif (!success || !data)\n\t\treturn durationMilliSec;\n\n\ttString softwareStr((char*)data);\n\ttExprReader script(softwareStr, false);\n\ttExpression tacentView = script.First();\n\tif (tacentView.GetAtomString() == \"TacentLibrary\")\n\t{\n\t\ttExpression tacentVers = tacentView.Next();\n\t\ttExpression durationEx = tacentVers.Next();\n\t\ttExpression durCmd = durationEx.Item0();\n\t\tif (durCmd.GetAtomString() == \"PageDur\")\n\t\t{\n\t\t\ttExpression durVal = durationEx.Item1();\n\t\t\tdurationMilliSec = durVal.GetAtomInt();\n\t\t}\n\t}\n\n\treturn durationMilliSec;\n}",
    "bool tImageTIFF::Load(const tString& tiffFile)\n{\n\tClear();\n\n\tif (tSystem::tGetFileType(tiffFile) != tSystem::tFileType::TIFF)\n\t\treturn false;\n\n\tif (!tFileExists(tiffFile))\n\t\treturn false;\n\n\tTIFF* tiff = TIFFOpen(tiffFile.Chr(), \"rb\");\n\tif (!tiff)\n\t\treturn false;\n\n\t// Create all frames.\n\ttPixelFormat srcFormat = tPixelFormat::R8G8B8A8;\n\tdo\n\t{\n\t\tint width = 0; int height = 0;\n\t\tTIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n\t\tTIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n\t\tif ((width <= 0) || (height <= 0))\n\t\t\tbreak;\n\n\t\tint numPixels = width*height;\n\t\tint durationMilliSeconds = ReadSoftwarePageDuration(tiff);\n\n\t\tuint32* pixels = (uint32*)_TIFFmalloc(numPixels * sizeof(uint32));\n\t\tint successCode = TIFFReadRGBAImage(tiff, width, height, pixels, 0);\n\t\tif (!successCode)\n\t\t{\n\t\t\t_TIFFfree(pixels);\n\t\t\tbreak;\n\t\t}\n\n\t\ttFrame* frame = new tFrame;\n\t\tframe->Width = width;\n\t\tframe->Height = height;\n\t\tframe->Pixels = new tPixel4b[width*height];\n\t\tframe->PixelFormatSrc = srcFormat;\n\n\t\t// If duration not set we use a default of 1 second.\n\t\tframe->Duration = (durationMilliSeconds >= 0) ? float(durationMilliSeconds)/1000.0f : 1.0f;\n\n\t\tfor (int p = 0; p < width*height; p++)\n\t\t\tframe->Pixels[p] = pixels[p];\n\n\t\t_TIFFfree(pixels);\n\t\tFrames.Append(frame);\n\t} while (TIFFReadDirectory(tiff));\n\n\tTIFFClose(tiff);\n\tif (Frames.GetNumItems() == 0)\n\t\treturn false;\n\n\tPixelFormatSrc = srcFormat;\n\tPixelFormat = tPixelFormat::R8G8B8A8;\n\n\t// TIFF files are assumed to be in sRGB.\n\tColourProfileSrc = tColourProfile::sRGB;\n\tColourProfile = tColourProfile::sRGB;\n\n\treturn true;\n}",
    "grk_image* TIFFFormat::decode(const std::string& filename, grk_cparameters* parameters)\n{\n   bool found_assocalpha = false;\n   size_t alpha_count = 0;\n   chroma_subsample_x = 1;\n   chroma_subsample_y = 1;\n   GRK_COLOR_SPACE color_space = GRK_CLRSPC_UNKNOWN;\n   grk_image_comp cmptparm[grk::maxNumPackComponents];\n   grk_image* image = nullptr;\n   uint16_t tiBps = 0, tiPhoto = 0, tiSf = SAMPLEFORMAT_UINT, tiSpp = 0, tiPC = 0;\n   bool hasTiSf = false;\n   short tiResUnit = 0;\n   float tiXRes = 0, tiYRes = 0;\n   uint32_t tiWidth = 0, tiHeight = 0;\n   bool is_cinema = GRK_IS_CINEMA(parameters->rsiz);\n   bool success = false;\n   bool isCIE = false;\n   uint16_t compress;\n   float *luma = nullptr, *refBlackWhite = nullptr;\n   uint16_t *red_orig = nullptr, *green_orig = nullptr, *blue_orig = nullptr;\n\n   tif_ = TIFFOpen(filename.c_str(), \"r\");\n   if(!tif_)\n   {\n      spdlog::error(\"TIFFFormat::decode: Failed to open {} for reading\", filename);\n      return 0;\n   }\n\n   if(TIFFIsTiled(tif_))\n   {\n      spdlog::error(\"TIFFFormat::decode: tiled TIFF images not supported\");\n      return 0;\n   }\n\n   TIFFGetField(tif_, TIFFTAG_COMPRESSION, &compress);\n   TIFFGetFieldDefaulted(tif_, TIFFTAG_IMAGEWIDTH, &tiWidth);\n   TIFFGetFieldDefaulted(tif_, TIFFTAG_IMAGELENGTH, &tiHeight);\n   TIFFGetFieldDefaulted(tif_, TIFFTAG_BITSPERSAMPLE, &tiBps);\n   TIFFGetFieldDefaulted(tif_, TIFFTAG_SAMPLESPERPIXEL, &tiSpp);\n   TIFFGetFieldDefaulted(tif_, TIFFTAG_PHOTOMETRIC, &tiPhoto);\n   TIFFGetFieldDefaulted(tif_, TIFFTAG_PLANARCONFIG, &tiPC);\n   hasTiSf = TIFFGetFieldDefaulted(tif_, TIFFTAG_SAMPLEFORMAT, &tiSf) == 1;\n\n   TIFFGetFieldDefaulted(tif_, TIFFTAG_REFERENCEBLACKWHITE, &refBlackWhite);\n\n   uint32_t w = tiWidth;\n   uint32_t h = tiHeight;\n   uint16_t numcomps = 0;\n   uint32_t icclen = 0;\n   uint8_t* iccbuf = nullptr;\n   uint8_t* iptc_buf = nullptr;\n   uint32_t iptc_len = 0;\n   uint8_t* xmp_buf = nullptr;\n   uint32_t xmp_len = 0;\n   uint16_t* sampleinfo = nullptr;\n   uint16_t extrasamples = 0;\n   bool hasXRes = false, hasYRes = false, hasResUnit = false;\n   bool isSigned = (tiSf == SAMPLEFORMAT_INT);\n   bool needSignedPixelReader = isSigned && (tiBps == 8 || tiBps == 16);\n\n   // 1. sanity checks\n\n   // check for supported photometric interpretation\n   if(tiPhoto != PHOTOMETRIC_MINISBLACK && tiPhoto != PHOTOMETRIC_MINISWHITE &&\n      tiPhoto != PHOTOMETRIC_RGB && tiPhoto != PHOTOMETRIC_ICCLAB &&\n      tiPhoto != PHOTOMETRIC_CIELAB && tiPhoto != PHOTOMETRIC_YCBCR &&\n      tiPhoto != PHOTOMETRIC_SEPARATED && tiPhoto != PHOTOMETRIC_PALETTE)\n   {\n      spdlog::error(\"TIFFFormat::decode: Unsupported color format {}.\\n\"\n                    \"Only RGB(A), GRAY(A), CIELAB, YCC, CMYK and PALETTE have been implemented.\",\n                    getColourFormatString(tiPhoto));\n      goto cleanup;\n   }\n   // check for rec601\n   if(tiPhoto == PHOTOMETRIC_YCBCR)\n   {\n      TIFFGetFieldDefaulted(tif_, TIFFTAG_YCBCRCOEFFICIENTS, &luma);\n      for(size_t i = 0; i < 3; ++i)\n      {\n         if((uint32_t)(luma[i] * 1000.0f + 0.5f) != rec_601_luma[i])\n         {\n            spdlog::error(\n                \"TIFFFormat::decode: YCbCr image with unsupported non Rec. 601 colour space;\");\n            spdlog::error(\"YCbCrCoefficients: {},{},{}\", luma[0], luma[1], luma[2]);\n            spdlog::error(\"Please convert to sRGB before compressing.\");\n            goto cleanup;\n         }\n      }\n   }\n   // check sample format\n   if(hasTiSf && tiSf != SAMPLEFORMAT_UINT && tiSf != SAMPLEFORMAT_INT)\n   {\n      spdlog::error(\"TIFFFormat::decode: Unsupported sample format: {}.\",\n                    getSampleFormatString(tiSf));\n      goto cleanup;\n   }\n   if(tiSpp == 0)\n   {\n      spdlog::error(\"TIFFFormat::decode: Samples per pixel must be non-zero\");\n      goto cleanup;\n   }\n   if(tiBps > 16U || tiBps == 0)\n   {\n      spdlog::error(\"TIFFFormat::decode: Unsupported precision {}. Maximum 16 Bits supported.\",\n                    tiBps);\n      goto cleanup;\n   }\n   if(tiWidth == 0 || tiHeight == 0)\n   {\n      spdlog::error(\"TIFFFormat::decode: Width({}) and height({}) must both \"\n                    \"be non-zero\",\n                    tiWidth, tiHeight);\n      goto cleanup;\n   }\n   TIFFGetFieldDefaulted(tif_, TIFFTAG_EXTRASAMPLES, &extrasamples, &sampleinfo);\n\n   // 2. initialize image components and signed/unsigned\n   memset(&cmptparm[0], 0, grk::maxNumPackComponents * sizeof(grk_image_comp));\n   if((tiPhoto == PHOTOMETRIC_RGB) && (is_cinema) && (tiBps != 12U))\n   {\n      spdlog::warn(\"TIFFFormat::decode: Input image bitdepth is {} bits.\", tiBps);\n      spdlog::warn(\"TIF conversion has automatically rescaled to 12-bits\");\n      spdlog::warn(\"to comply with cinema profiles.\\n\");\n   }\n   else\n   {\n      is_cinema = 0U;\n   }\n   numcomps = extrasamples;\n   switch(tiPhoto)\n   {\n      case PHOTOMETRIC_PALETTE:\n         if(isSigned)\n         {\n            spdlog::error(\"TIFFFormat::decode: Signed palette image not supported\");\n            goto cleanup;\n         }\n         color_space = GRK_CLRSPC_SRGB;\n         numcomps++;\n         break;\n      case PHOTOMETRIC_MINISBLACK:\n      case PHOTOMETRIC_MINISWHITE:\n         color_space = GRK_CLRSPC_GRAY;\n         numcomps++;\n         break;\n      case PHOTOMETRIC_RGB:\n         color_space = GRK_CLRSPC_SRGB;\n         numcomps = (uint16_t)(numcomps + 3);\n         break;\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_ICCLAB:\n         isCIE = true;\n         color_space = GRK_CLRSPC_DEFAULT_CIE;\n         numcomps = (uint16_t)(numcomps + 3);\n         break;\n      case PHOTOMETRIC_YCBCR:\n         // jpeg library is needed to convert from YCbCr to RGB\n         if(compress == COMPRESSION_OJPEG || compress == COMPRESSION_JPEG)\n         {\n            spdlog::error(\"TIFFFormat::decode: YCbCr image with JPEG compression\"\n                          \" is not supported\");\n            goto cleanup;\n         }\n         else if(compress == COMPRESSION_PACKBITS)\n         {\n            spdlog::error(\"TIFFFormat::decode: YCbCr image with PACKBITS compression\"\n                          \" is not supported\");\n            goto cleanup;\n         }\n         color_space = GRK_CLRSPC_SYCC;\n         numcomps = (uint16_t)(numcomps + 3);\n         TIFFGetFieldDefaulted(tif_, TIFFTAG_YCBCRSUBSAMPLING, &chroma_subsample_x,\n                               &chroma_subsample_y);\n         if(chroma_subsample_x == 0 || chroma_subsample_y == 0)\n         {\n            spdlog::error(\"TIFFFormat::decode: chroma subsampling factors must be positive.\");\n            goto cleanup;\n         }\n         if(chroma_subsample_x > 255 || chroma_subsample_y > 255)\n         {\n            spdlog::error(\n                \"TIFFFormat::decode: chroma subsampling factors must each be less than 256.\");\n            goto cleanup;\n         }\n         if(chroma_subsample_x != 1 || chroma_subsample_y != 1)\n         {\n            if(isSigned)\n            {\n               spdlog::error(\"TIFFFormat::decode: chroma subsampling {},{} with signed data \"\n                             \"is not supported\",\n                             chroma_subsample_x, chroma_subsample_y);\n               goto cleanup;\n            }\n            if(numcomps != 3)\n            {\n               spdlog::error(\"TIFFFormat::decode: chroma subsampling {},{} with alpha \"\n                             \"channel(s) not supported\",\n                             chroma_subsample_x, chroma_subsample_y);\n               goto cleanup;\n            }\n         }\n         break;\n      case PHOTOMETRIC_SEPARATED:\n         color_space = GRK_CLRSPC_CMYK;\n         numcomps = (uint16_t)(numcomps + 4);\n         break;\n      default:\n         spdlog::error(\"TIFFFormat::decode: Unsupported colour space {}.\", tiPhoto);\n         goto cleanup;\n         break;\n   }\n   if(tiPhoto == PHOTOMETRIC_CIELAB)\n   {\n      if(hasTiSf && (tiSf != SAMPLEFORMAT_INT))\n         spdlog::warn(\"TIFFFormat::decode: Input image is in CIE colour space\"\n                      \" but sample format is unsigned int. Forcing to signed int\");\n      isSigned = true;\n   }\n   else if(tiPhoto == PHOTOMETRIC_ICCLAB)\n   {\n      if(hasTiSf && (tiSf != SAMPLEFORMAT_UINT))\n         spdlog::warn(\"TIFFFormat::decode: Input image is in ICC CIE colour\"\n                      \" space but sample format is signed int. Forcing to unsigned int\");\n      isSigned = false;\n   }\n\n   if(isSigned)\n   {\n      if(tiPhoto == PHOTOMETRIC_MINISWHITE)\n         spdlog::error(\"TIFFFormat::decode: signed image with \"\n                       \"MINISWHITE format is not fully supported\");\n      if(tiBps != 4 && tiBps != 8 && tiBps != 10 && tiBps != 12 && tiBps != 16)\n      {\n         spdlog::error(\"TIFFFormat::decode: signed image with bit\"\n                       \" depth {} is not supported\",\n                       tiBps);\n         goto cleanup;\n      }\n   }\n   if(numcomps > grk::maxNumPackComponents)\n   {\n      spdlog::error(\"TIFFFormat::decode: number of components \"\n                    \"{} must be <= %u\",\n                    numcomps, grk::maxNumPackComponents);\n      goto cleanup;\n   }\n\n   // 4. create image\n   for(uint32_t j = 0; j < numcomps; j++)\n   {\n      auto img_comp = cmptparm + j;\n      img_comp->prec = (uint8_t)tiBps;\n      bool chroma = (j == 1 || j == 2);\n      img_comp->dx = chroma ? (uint8_t)chroma_subsample_x : 1;\n      img_comp->dy = chroma ? (uint8_t)chroma_subsample_y : 1;\n      img_comp->w = grk::ceildiv<uint32_t>(w, img_comp->dx);\n      img_comp->h = grk::ceildiv<uint32_t>(h, img_comp->dy);\n   }\n   image = grk_image_new(numcomps, &cmptparm[0], color_space, true);\n   if(!image)\n      goto cleanup;\n\n   /* set image offset and reference grid */\n   image->x0 = parameters->image_offset_x0;\n   image->x1 = image->x0 + (w - 1) * 1 + 1;\n   if(image->x1 <= image->x0)\n   {\n      spdlog::error(\"TIFFFormat::decode: Bad value for image->x1({}) vs. \"\n                    \"image->x0({}).\",\n                    image->x1, image->x0);\n      goto cleanup;\n   }\n   image->y0 = parameters->image_offset_y0;\n   image->y1 = image->y0 + (h - 1) * 1 + 1;\n   if(image->y1 <= image->y0)\n   {\n      spdlog::error(\"TIFFFormat::decode: Bad value for image->y1({}) vs. \"\n                    \"image->y0({}).\",\n                    image->y1, image->y0);\n      goto cleanup;\n   }\n   if(tiPhoto == PHOTOMETRIC_PALETTE)\n   {\n      if(!TIFFGetField(tif_, TIFFTAG_COLORMAP, &red_orig, &green_orig, &blue_orig))\n      {\n         spdlog::error(\"TIFFFormat::decode: Missing required \\\"Colormap\\\" tag\");\n         goto cleanup;\n      }\n      uint16_t palette_num_entries = (uint16_t)(1U << tiBps);\n      uint8_t num_channels = 3U;\n      create_meta(image);\n      allocPalette(&image->meta->color, num_channels, (uint16_t)palette_num_entries);\n      auto cmap = new _grk_component_mapping_comp[num_channels];\n      for(uint8_t i = 0; i < num_channels; ++i)\n      {\n         cmap[i].component = 0;\n         cmap[i].mapping_type = 1;\n         cmap[i].palette_column = i;\n         image->meta->color.palette->channel_prec[i] = 16;\n         image->meta->color.palette->channel_sign[i] = false;\n      }\n      image->meta->color.palette->component_mapping = cmap;\n      auto lut_ptr = image->meta->color.palette->lut;\n      for(uint16_t i = 0; i < palette_num_entries; i++)\n      {\n         *lut_ptr++ = red_orig[i];\n         *lut_ptr++ = green_orig[i];\n         *lut_ptr++ = blue_orig[i];\n      }\n   }\n   for(uint32_t j = 0; j < numcomps; j++)\n   {\n      // handle non-colour channel\n      uint16_t numColourChannels = (uint16_t)(numcomps - extrasamples);\n      auto comp = image->comps + j;\n\n      if(extrasamples > 0 && j >= numColourChannels)\n      {\n         comp->type = GRK_CHANNEL_TYPE_UNSPECIFIED;\n         comp->association = GRK_CHANNEL_ASSOC_UNASSOCIATED;\n         auto alphaType = sampleinfo[j - numColourChannels];\n         if(alphaType == EXTRASAMPLE_ASSOCALPHA)\n         {\n            if(found_assocalpha)\n               spdlog::warn(\"TIFFFormat::decode: Found more than one associated alpha channel\");\n            alpha_count++;\n            comp->type = GRK_CHANNEL_TYPE_PREMULTIPLIED_OPACITY;\n            found_assocalpha = true;\n         }\n         else if(alphaType == EXTRASAMPLE_UNASSALPHA)\n         {\n            alpha_count++;\n            comp->type = GRK_CHANNEL_TYPE_OPACITY;\n         }\n         else\n         {\n            // some older mono or RGB images may have alpha channel\n            // stored as EXTRASAMPLE_UNSPECIFIED\n            if((color_space == GRK_CLRSPC_GRAY && numcomps == 2) ||\n               (color_space == GRK_CLRSPC_SRGB && numcomps == 4))\n            {\n               alpha_count++;\n               comp->type = GRK_CHANNEL_TYPE_OPACITY;\n            }\n         }\n      }\n      if(comp->type == GRK_CHANNEL_TYPE_OPACITY ||\n         comp->type == GRK_CHANNEL_TYPE_PREMULTIPLIED_OPACITY)\n      {\n         switch(alpha_count)\n         {\n            case 1:\n               comp->association = GRK_CHANNEL_ASSOC_WHOLE_IMAGE;\n               break;\n            case 2:\n               comp->association = GRK_CHANNEL_ASSOC_UNASSOCIATED;\n               break;\n            default:\n               comp->type = GRK_CHANNEL_TYPE_UNSPECIFIED;\n               comp->association = GRK_CHANNEL_ASSOC_UNASSOCIATED;\n               break;\n         }\n      }\n      comp->sgnd = isSigned;\n   }\n\n   if(needSignedPixelReader && isFinalOutputSubsampled(image))\n   {\n      spdlog::error(\"TIFF: subsampling not supported for signed 8 and 16 bit images\");\n      goto cleanup;\n   }\n\n   // 5. extract capture resolution\n   hasXRes = TIFFGetFieldDefaulted(tif_, TIFFTAG_XRESOLUTION, &tiXRes) == 1;\n   hasYRes = TIFFGetFieldDefaulted(tif_, TIFFTAG_YRESOLUTION, &tiYRes) == 1;\n   hasResUnit = TIFFGetFieldDefaulted(tif_, TIFFTAG_RESOLUTIONUNIT, &tiResUnit) == 1;\n   if(hasXRes && hasYRes && hasResUnit && tiResUnit != RESUNIT_NONE)\n   {\n      set_resolution(parameters->capture_resolution_from_file, tiXRes, tiYRes, tiResUnit);\n      parameters->write_capture_resolution_from_file = true;\n   }\n   // 6. extract embedded ICC profile (with sanity check on binary size of profile)\n   // note: we ignore ICC profile for CIE images as JPEG 2000 can't signal both\n   // CIE and ICC\n   if(!isCIE)\n   {\n      if((TIFFGetFieldDefaulted(tif_, TIFFTAG_ICCPROFILE, &icclen, &iccbuf) == 1) && icclen > 0 &&\n         icclen < grk::maxICCProfileBufferLen)\n         copy_icc(image, iccbuf, icclen);\n   }\n   // 7. extract IPTC meta-data\n   if(TIFFGetFieldDefaulted(tif_, TIFFTAG_RICHTIFFIPTC, &iptc_len, &iptc_buf) == 1)\n   {\n      if(TIFFIsByteSwapped(tif_))\n         TIFFSwabArrayOfLong((uint32_t*)iptc_buf, iptc_len);\n      // since TIFFTAG_RICHTIFFIPTC is of type TIFF_LONG, we must multiply\n      // by 4 to get the length in bytes\n      create_meta(image);\n      image->meta->iptc_len = iptc_len * 4;\n      image->meta->iptc_buf = new uint8_t[iptc_len];\n      memcpy(image->meta->iptc_buf, iptc_buf, iptc_len);\n   }\n   // 8. extract XML meta-data\n   if(TIFFGetFieldDefaulted(tif_, TIFFTAG_XMLPACKET, &xmp_len, &xmp_buf) == 1)\n   {\n      create_meta(image);\n      image->meta->xmp_len = xmp_len;\n      image->meta->xmp_buf = new uint8_t[xmp_len];\n      memcpy(image->meta->xmp_buf, xmp_buf, xmp_len);\n   }\n   // 9. read pixel data\n   if(needSignedPixelReader)\n   {\n      if(tiBps == 8)\n         success = readTiffPixelsSigned<int8_t>(tif_, image->comps, numcomps, tiSpp, tiPC);\n      else\n         success = readTiffPixelsSigned<int16_t>(tif_, image->comps, numcomps, tiSpp, tiPC);\n   }\n   else\n   {\n      success = readTiffPixels(tif_, image->comps, numcomps, tiSpp, tiPC, tiPhoto,\n                               chroma_subsample_x, chroma_subsample_y);\n   }\ncleanup:\n   if(tif_)\n      TIFFClose(tif_);\n   tif_ = nullptr;\n   if(success)\n   {\n      if(is_cinema)\n      {\n         for(uint32_t j = 0; j < numcomps; ++j)\n            scaleComponent(image->comps + j, 12);\n      }\n      return image;\n   }\n   if(image)\n      grk_object_unref(&image->obj);\n\n   return nullptr;\n}",
    "HANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster)\n{\n    void *pDIB = 0;\n    TIFFRGBAImage *img = &dib->tif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER bi;\n    int dwDIBSize;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if (BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled)\n    { // bilevel\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 1;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed = 0;\n        pRgbq[0].rgbBlue = 0;\n        pRgbq[0].rgbGreen = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed = 255;\n        pRgbq[1].rgbBlue = 255;\n        pRgbq[1].rgbGreen = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr(\n            (BITMAPINFOHEADER *)pDIB); //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n    //  For now just always default to the RGB 32 bit form. // save as 32 bit\n    //  for simplicity\n    else if (true /*BitsPerSample == 8 && SamplePerPixel == 3*/)\n    { // 24 bit color\n\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 32;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        // Swap the byte order while copying\n        for (int i = 0; i < sizeWords; ++i)\n        {\n            rgbDib[i].rgbRed = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}",
    "CPLErr GTIFWktFromMemBufEx( int nSize, unsigned char *pabyBuffer,\n                            char **ppszWKT, double *padfGeoTransform,\n                            int *pnGCPCount, GDAL_GCP **ppasGCPList,\n                            int *pbPixelIsPoint )\n\n{\n    bool    bPixelIsPoint = false;\n    int     bPointGeoIgnore = FALSE;\n    short nRasterType;\n    char szFilename[100];\n\n    sprintf( szFilename, \"/vsimem/wkt_from_mem_buf_%ld.tif\",\n             (long) CPLGetPID() );\n\n/* -------------------------------------------------------------------- */\n/*      Make sure we have hooked CSVFilename().                         */\n/* -------------------------------------------------------------------- */\n    LibgeotiffOneTimeInit();\n\n/* -------------------------------------------------------------------- */\n/*      Create a memory file from the buffer.                           */\n/* -------------------------------------------------------------------- */\n    VSILFILE *fp = VSIFileFromMemBuffer( szFilename, pabyBuffer, nSize, FALSE );\n    if( fp == NULL )\n        return CE_Failure;\n    VSIFCloseL( fp );\n\n/* -------------------------------------------------------------------- */\n/*      Initialize access to the memory geotiff structure.              */\n/* -------------------------------------------------------------------- */\n    TIFF        *hTIFF;\n    hTIFF = VSI_TIFFOpen( szFilename, \"rc\" );\n\n    if( hTIFF == NULL )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"TIFF/GeoTIFF structure is corrupt.\" );\n        VSIUnlink( szFilename );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get the projection definition.                                  */\n/* -------------------------------------------------------------------- */\n    GTIF \t*hGTIF;\n    GTIFDefn    *psGTIFDefn;\n\n    hGTIF = GTIFNew(hTIFF);\n\n    if( hGTIF != NULL && GTIFKeyGet(hGTIF, GTRasterTypeGeoKey, &nRasterType,\n                0, 1 ) == 1\n        && nRasterType == (short) RasterPixelIsPoint )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore =\n            CSLTestBoolean( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                            \"FALSE\") );\n    }\n    if( pbPixelIsPoint )\n        *pbPixelIsPoint = bPixelIsPoint;\n\n#if LIBGEOTIFF_VERSION >= 1410\n    psGTIFDefn = GTIFAllocDefn();\n#else\n    psGTIFDefn = (GTIFDefn *) CPLCalloc(1,sizeof(GTIFDefn));\n#endif\n\n\n    if( hGTIF != NULL && GTIFGetDefn( hGTIF, psGTIFDefn ) )\n        *ppszWKT = GTIFGetOGISDefn( hGTIF, psGTIFDefn );\n    else\n        *ppszWKT = NULL;\n\n    if( hGTIF )\n        GTIFFree( hGTIF );\n\n#if LIBGEOTIFF_VERSION >= 1410\n    GTIFFreeDefn(psGTIFDefn);\n#else\n    CPLFree(psGTIFDefn);\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Get geotransform or tiepoints.                                  */\n/* -------------------------------------------------------------------- */\n    double\t*padfTiePoints, *padfScale, *padfMatrix;\n    int16\tnCount;\n\n    padfGeoTransform[0] = 0.0;\n    padfGeoTransform[1] = 1.0;\n    padfGeoTransform[2] = 0.0;\n    padfGeoTransform[3] = 0.0;\n    padfGeoTransform[4] = 0.0;\n    padfGeoTransform[5] = 1.0;\n\n    *pnGCPCount = 0;\n    *ppasGCPList = NULL;\n\n    if( TIFFGetField(hTIFF,TIFFTAG_GEOPIXELSCALE,&nCount,&padfScale )\n        && nCount >= 2 )\n    {\n        padfGeoTransform[1] = padfScale[0];\n        padfGeoTransform[5] = - ABS(padfScale[1]);\n\n        if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && nCount >= 6 )\n        {\n            padfGeoTransform[0] =\n                padfTiePoints[3] - padfTiePoints[0] * padfGeoTransform[1];\n            padfGeoTransform[3] =\n                padfTiePoints[4] - padfTiePoints[1] * padfGeoTransform[5];\n\n            // adjust for pixel is point in transform\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                padfGeoTransform[0] -= (padfGeoTransform[1] * 0.5 + padfGeoTransform[2] * 0.5);\n                padfGeoTransform[3] -= (padfGeoTransform[4] * 0.5 + padfGeoTransform[5] * 0.5);\n            }\n        }\n    }\n\n    else if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n             && nCount >= 6 )\n    {\n        *pnGCPCount = nCount / 6;\n        *ppasGCPList = (GDAL_GCP *) CPLCalloc(sizeof(GDAL_GCP),*pnGCPCount);\n\n        for( int iGCP = 0; iGCP < *pnGCPCount; iGCP++ )\n        {\n            char\tszID[32];\n            GDAL_GCP\t*psGCP = *ppasGCPList + iGCP;\n\n            sprintf( szID, \"%d\", iGCP+1 );\n            psGCP->pszId = CPLStrdup( szID );\n            psGCP->pszInfo = CPLStrdup(\"\");\n            psGCP->dfGCPPixel = padfTiePoints[iGCP*6+0];\n            psGCP->dfGCPLine = padfTiePoints[iGCP*6+1];\n            psGCP->dfGCPX = padfTiePoints[iGCP*6+3];\n            psGCP->dfGCPY = padfTiePoints[iGCP*6+4];\n            psGCP->dfGCPZ = padfTiePoints[iGCP*6+5];\n        }\n    }\n\n    else if( TIFFGetField(hTIFF,TIFFTAG_GEOTRANSMATRIX,&nCount,&padfMatrix )\n             && nCount == 16 )\n    {\n        padfGeoTransform[0] = padfMatrix[3];\n        padfGeoTransform[1] = padfMatrix[0];\n        padfGeoTransform[2] = padfMatrix[1];\n        padfGeoTransform[3] = padfMatrix[7];\n        padfGeoTransform[4] = padfMatrix[4];\n        padfGeoTransform[5] = padfMatrix[5];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup.                                                        */\n/* -------------------------------------------------------------------- */\n    XTIFFClose( hTIFF );\n\n    VSIUnlink( szFilename );\n\n    if( *ppszWKT == NULL )\n        return CE_Failure;\n    else\n        return CE_None;\n}",
    "void CqTiffDirHandle::fillHeaderRequiredAttrs(CqTexFileHeader& header) const\n{\n\t// Fill header with general metadata which won't affect the details of the\n\t// pixel memory layout.\n\theader.setWidth(tiffTagValue<uint32>(TIFFTAG_IMAGEWIDTH));\n\theader.setHeight(tiffTagValue<uint32>(TIFFTAG_IMAGELENGTH));\n\tif(TIFFIsTiled(tiffPtr()))\n\t{\n\t\theader.set<Attr::TileInfo>( SqTileInfo(\n\t\t\t\t\ttiffTagValue<uint32>(TIFFTAG_TILEWIDTH),\n\t\t\t\t\ttiffTagValue<uint32>(TIFFTAG_TILELENGTH)) );\n\t}\n\t// Get the compression type.\n\theader.set<Attr::Compression>(\n\t\t\ttiffCompressionNameFromTag(tiffTagValue<uint16>(TIFFTAG_COMPRESSION)) );\n\t// Compute pixel aspect ratio\n\tTqFloat xRes = 0;\n\tTqFloat yRes = 0;\n\tif(TIFFGetField(tiffPtr(), TIFFTAG_XRESOLUTION, &xRes)\n\t\t\t&& TIFFGetField(tiffPtr(), TIFFTAG_YRESOLUTION, &yRes))\n\t{\n\t\t// yRes/xRes should be the correct quantity corresponding to the\n\t\t// pixelAspectRatio used in OpenEXR.\n\t\theader.set<Attr::PixelAspectRatio>(yRes/xRes);\n\t}\n\telse\n\t{\n\t\theader.set<Attr::PixelAspectRatio>(1.0f);\n\t}\n}",
    "void addAttributeToHeader(ttag_t tag, CqTexFileHeader& header,\n\t\tconst CqTiffDirHandle& dirHandle)\n{\n\tTtiff temp;\n\tif(TIFFGetField(dirHandle.tiffPtr(), tag, &temp))\n\t\theader.set<Tattr>(attrTypeFromTiff<Tattr, Ttiff>(temp));\n}",
    "void addWrapModesToHeader(CqTexFileHeader& header, const CqTiffDirHandle& dirHandle)\n{\n\tchar* wrapModesStr = 0;\n\tif(TIFFGetField(dirHandle.tiffPtr(), TIFFTAG_PIXAR_WRAPMODES, &wrapModesStr))\n\t{\n\t\tstd::istringstream iss(wrapModesStr);\n\t\tSqWrapModes modes;\n\t\tiss >> modes.sWrap >> modes.tWrap;\n\t\theader.set<Attr::WrapModes>(modes);\n\t}\n}",
    "void CqTiffDirHandle::fillHeaderOptionalAttrs(CqTexFileHeader& header) const\n{\n\t// Add various descriptive strings to the header if they exist\n\taddAttributeToHeader<Attr::Software,char*>(TIFFTAG_SOFTWARE, header, *this);\n\taddAttributeToHeader<Attr::HostName,char*>(TIFFTAG_HOSTCOMPUTER, header, *this);\n\taddAttributeToHeader<Attr::Description,char*>(TIFFTAG_IMAGEDESCRIPTION, header, *this);\n\taddAttributeToHeader<Attr::DateTime,char*>(TIFFTAG_DATETIME, header, *this);\n\taddAttributeToHeader<Attr::TextureFormat,const char*>(TIFFTAG_PIXAR_TEXTUREFORMAT, header, *this);\n\n\t// Add texturemap-specific stuff to the header if it exists.\n\taddWrapModesToHeader(header, *this);\n\n\t// Add some matrix attributes\n\taddAttributeToHeader<Attr::WorldToScreenMatrix,float*>(\n\t\t\tTIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN, header, *this);\n\taddAttributeToHeader<Attr::WorldToCameraMatrix,float*>(\n\t\t\tTIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA, header, *this);\n\t// Add cotan of the field of view.\n\taddAttributeToHeader<Attr::FieldOfViewCot,float>(\n\t\t\tTIFFTAG_PIXAR_FOVCOT, header, *this);\n\n\t// Retrieve tags relevant to the display window\n\t// The origin of the image is apparently given in resolution units, but\n\t// here we want to interpret it as the number of pixels from the top left\n\t// of the image, hence the lfloor.\n\tuint32 fullWidth = header.width();\n\tuint32 fullHeight = header.height();\n\tfloat xPos = 0;\n\tfloat yPos = 0;\n\tif( TIFFGetField(tiffPtr(), TIFFTAG_PIXAR_IMAGEFULLWIDTH, &fullWidth)\n\t\t| TIFFGetField(tiffPtr(), TIFFTAG_PIXAR_IMAGEFULLLENGTH, &fullHeight)\n\t\t| TIFFGetField(tiffPtr(), TIFFTAG_XPOSITION, &xPos)\n\t\t| TIFFGetField(tiffPtr(), TIFFTAG_YPOSITION, &yPos)\n\t\t// bitwise OR used since we don't want shortcut evaluation\n\t\t)\n\t{\n\t\theader.set<Attr::DisplayWindow>( SqImageRegion(fullWidth, fullHeight,\n\t\t\t\t\tlfloor(xPos), lfloor(yPos)) );\n\t}\n}",
    "IqTextureMapOld* CqTextureMapOld::GetShadowMap( const CqString& strName )\n{\n\tQGetRenderContext() ->Stats().IncTextureMisses( 3 );\n\n\t//TqUlong hash = CqString::hash(strName.c_str());\n\n\t// First search the texture map cache\n\tfor ( std::vector<CqTextureMapOld*>::iterator i = m_TextureMap_Cache.begin(); i != m_TextureMap_Cache.end(); i++ )\n\t{\n\t\tif ( (*i)->getName() == strName )\n\t\t{\n\t\t\tif ( ( *i ) ->Type() == MapType_Shadow )\n\t\t\t{\n\t\t\t\tQGetRenderContext() ->Stats().IncTextureHits( 1, 3 );\n\t\t\t\treturn ( *i );\n\t\t\t} else\n\t\t\t{\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tQGetRenderContext() ->Stats().IncTextureHits( 0, 3 );\n\n\t// If we got here, it doesn't exist yet, so we must create and load it.\n\tCqShadowMapOld* pNew = new CqShadowMapOld( strName );\n\tm_TextureMap_Cache.push_back( pNew );\n\tpNew->Open();\n\n\tTqPchar ptexfmt;\n\tif ( pNew->m_pImage == 0 ||\n\t        TIFFGetField( pNew->m_pImage, TIFFTAG_PIXAR_TEXTUREFORMAT, &ptexfmt ) != 1 ||\n\t        strcmp( ptexfmt, SHADOWMAP_HEADER ) != 0 )\n\t{\n\t\tstatic bool done = false;\n\t\tif (!done)\n\t\t{\n\t\t\tAqsis::log() << error << \"Map \\\"\" << strName.c_str() << \"\\\" is not a valid shadow map, use RiMakeShadow\" << std::endl;\n\t\t\tdone = true;\n\t\t}\n\t\tpNew->SetInvalid();\n\t}\n   \telse \n   \t{\n\t\tpNew->ReadMatrices();\n   \t}\n\treturn ( pNew );\n}",
    "void CqShadowMapOld::ReadMatrices()\n{\n\t// Read the transform matrices.\n\tTqFloat*\tWToC;\n\tTqFloat*\tWToS;\n\tCqMatrix\tmatWToC, matWToS;\n\n\t// Set the number of shadow maps initially to 0.\n\tm_NumberOfMaps = 0;\n\n\tCqMatrix matCToW;\n\tQGetRenderContextI() ->matSpaceToSpace( \"camera\", \"world\", NULL, NULL, QGetRenderContextI()->Time(), matCToW );\n\n\tTqDouble minz;\n\n\twhile(1)\n\t{\n\t\tTqInt reta = TIFFGetField( m_pImage, TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA, &WToC );\n\t\tTqInt retb = TIFFGetField( m_pImage, TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN, &WToS );\n\t\tif ( !reta || !retb )\n\t\t\tSetInvalid();\n\t\telse\n\t\t{\n\t\t\tTqInt r, c;\n\t\t\tfor ( r = 0; r < 4; r++ )\n\t\t\t{\n\t\t\t\tfor ( c = 0; c < 4; c++ )\n\t\t\t\t{\n\t\t\t\t\tmatWToC[ r ][ c ] = WToC[ ( r * 4 ) + c ];\n\t\t\t\t\tmatWToS[ r ][ c ] = WToS[ ( r * 4 ) + c ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Set the matrixes to general, not Identity as default.\n\t\tmatWToC.SetfIdentity( false );\n\t\tmatWToS.SetfIdentity( false );\n\n\t\tmatWToC *= matCToW;\n\t\tmatWToS *= matCToW;\n\n\t\t// Generate normal conversion matrices to save time.\n\t\tCqMatrix matITTCToL = matWToC;\n\t\tmatITTCToL[ 3 ][ 0 ] = matITTCToL[ 3 ][ 1 ] = matITTCToL[ 3 ][ 2 ] = matITTCToL[ 0 ][ 3 ] = matITTCToL[ 1 ][ 3 ] = matITTCToL[ 2 ][ 3 ] = 0.0;\n\t\tmatITTCToL[ 3 ][ 3 ] = 1.0;\n\t\tmatITTCToL.Inverse();\n\t\tmatITTCToL.Transpose();\n\n\t\tm_WorldToCameraMatrices.push_back( matWToC );\n\t\tm_WorldToScreenMatrices.push_back( matWToS );\n\t\tm_ITTCameraToLightMatrices.push_back( matITTCToL );\n\n\t\tif (TIFFGetField( m_pImage, TIFFTAG_SMINSAMPLEVALUE, &minz ))\n\t\t{\n\t\t\tm_MinZ.push_back( minz );\n\t\t}\n    \n\t\tm_NumberOfMaps++;\t// Increment the number of maps.\n\n\t\tif( TIFFReadDirectory( m_pImage ) == 0 )\n\t\t\tbreak;\n\t}\n}",
    "bool CqTextureMapOld::CreateMIPMAP(bool fProtectBuffers)\n{\n\tif ( m_pImage != 0 )\n\t{\n\t\t// Check if the format is normal scanline, otherwise we are unable to MIPMAP it yet.\n\t\tuint32 tsx;\n\t\tTqInt ret = TIFFGetField( m_pImage, TIFFTAG_TILEWIDTH, &tsx );\n\t\tif( ret )\n\t\t{\n\t\t\tAqsis::log() << error << \"Cannot MIPMAP a tiled image \\\"\" << m_strName.c_str() << \"\\\"\" << std::endl;\n\t\t\treturn( false );\n\t\t}\n\n\t\t// Read the whole image into a buffer.\n\t\tTqUint directory = 0;\n\t\tCqTextureMapBuffer* buffer = GetBuffer( 0, 0, directory++, fProtectBuffers );\n\t\tCqImageDownsampler sampler(m_swidth, m_twidth, m_FilterFunc, m_smode, m_tmode);\n\t\twhile(buffer->Width() > 1 && buffer->Height() > 1)\n\t\t{\n\t\t\tbuffer = sampler.downsample(buffer, *this, directory, fProtectBuffers);\n\t\t\tm_apMipMaps[directory%256].push_back(buffer);\n\t\t\tm_apLast[directory%256] = buffer;\n\t\t\tdirectory++;\n\t\t}\n\t}\n\treturn( true );\n}",
    "CqTextureMapBuffer* CqTextureMapOld::GetBuffer( TqUlong s, TqUlong t, TqInt directory, bool fProt )\n{\n\tQGetRenderContext() ->Stats().IncTextureMisses( 4 );\n\n\tCqTextureMapBuffer *lastcache = m_apLast[directory%256];\n\n\tif (lastcache && lastcache->IsValid(s, t, directory))\n\t{\n\t\tQGetRenderContext() ->Stats().IncTextureHits( 0, 4 );\n\t\treturn lastcache;\n\t}\n\n\t// Search already cached segments first.\n\tstd::list<CqTextureMapBuffer*>::iterator i = m_apMipMaps[directory%256].begin(); \n\tstd::list<CqTextureMapBuffer*>::iterator e = m_apMipMaps[directory%256].end(); \n\tfor ( ; i != e; i++ )\n\t{\n\t\tif ( ( *i ) ->IsValid( s, t, directory ) )\n\t\t{\n\t\t\tQGetRenderContext() ->Stats().IncTextureHits( 1, 4 );\n\t\t\tCqTextureMapBuffer* pbuffer = *i;\n\t\t\tm_apLast[directory%256] = pbuffer;\n\t\t\treturn ( pbuffer );\n\t\t}\n\t}\n\n\t// If we got here, segment is not currently loaded, so load the correct segement and store it in the cache.\n\tCqTextureMapBuffer* pTMB = 0;\n\n\tif ( !m_pImage )\n\t{\n\t\tboost::filesystem::path imagePath = QGetRenderContext()->poptCurrent()\n\t\t\t->findRiFileNothrow(m_strName, \"texture\");\n\t\tif ( imagePath.empty() )\n\t\t{\n\t\t\tAqsis::log() << error << \"Cannot open texture file \\\"\" << m_strName.c_str() << \"\\\"\" << std::endl;\n\t\t\treturn pTMB;\n\t\t}\n\n\t\t// Now open it as a tiff file.\n\t\tm_pImage = TIFFOpen( native(imagePath).c_str(), \"r\" );\n\t}\n\n\tif ( m_pImage )\n\t{\n\t\tuint32 tsx, tsy;\n\t\tTqInt ret = TIFFGetField( m_pImage, TIFFTAG_TILEWIDTH, &tsx );\n\t\tTIFFGetField( m_pImage, TIFFTAG_TILELENGTH, &tsy );\n\t\t// If a tiled image, read the appropriate tile.\n\t\tif ( ret )\n\t\t{\n\t\t\t// Work out the coordinates of this tile.\n\t\t\tTqUlong ox = ( s / tsx ) * tsx;\n\t\t\tTqUlong oy = ( t / tsy ) * tsy;\n\t\t\tpTMB = CreateBuffer( ox, oy, tsx, tsy, directory, fProt );\n\n\t\t\tTIFFSetDirectory( m_pImage, directory );\n\n\t\t\tvoid* pData = pTMB->pVoidBufferData();\n\t\t\tTIFFReadTile( m_pImage, pData, s, t, 0, 0 );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Create a storage buffer\n\t\t\tpTMB = CreateBuffer( 0, 0, m_XRes, m_YRes, directory, true );\n\n\t\t\tTIFFSetDirectory( m_pImage, directory );\n\t\t\tvoid* pdata = pTMB->pVoidBufferData();\n\t\t\tTqUint i;\n\t\t\tfor ( i = 0; i < m_YRes; i++ )\n\t\t\t{\n\t\t\t\tTIFFReadScanline( m_pImage, pdata, i );\n\t\t\t\tpdata = reinterpret_cast<void*>( reinterpret_cast<char*>( pdata ) + m_XRes * pTMB->ElemSize() );\n\t\t\t}\n\t\t}\n\t\t// Put this segment on the top of the list, so that next time it is found first. This\n\t\t// allows us to take advantage of likely spatial coherence during shading.\n\t\tm_apMipMaps[directory%256].push_front( pTMB );\n\t\tm_apLast[directory%256] = pTMB;\n\t}\n\treturn ( pTMB );\n}",
    "void CqTextureMapOld::Open()\n{\n\tm_IsValid = false;\n\n\t// Find the file required.\n\tboost::filesystem::path imagePath = QGetRenderContext()->poptCurrent()\n\t\t->findRiFileNothrow(m_strName, \"texture\");\n\tif ( imagePath.empty() )\n\t{\n\t\tAqsis::log() << error << \"Cannot open texture file \\\"\" << m_strName.c_str() << \"\\\"\" << std::endl;\n\t\treturn ;\n\t}\n\tm_pImage = TIFFOpen(native(imagePath).c_str(), \"r\" );\n\n\tif ( m_pImage )\n\t{\n\t\tAqsis::log() << info << \"TextureMapOld: \\\"\" << imagePath << \"\\\" is open\" << std::endl;\n\t\tTqPchar pFormat = 0;\n\t\tTqPchar pModes = 0;\n\n\t\tTIFFGetField( m_pImage, TIFFTAG_IMAGEWIDTH, &m_XRes );\n\t\tTIFFGetField( m_pImage, TIFFTAG_IMAGELENGTH, &m_YRes );\n\n\t\tuint16 planarconfig;\n\t\tTIFFGetField( m_pImage, TIFFTAG_PLANARCONFIG, &planarconfig );\n\t\tm_PlanarConfig = planarconfig;\n\t\tuint16 samplesperpixel = 1;\n\t\tTIFFGetField( m_pImage, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel );\n\t\tm_SamplesPerPixel = samplesperpixel;\n\t\tuint16 sampleformat;\n\t\tTIFFGetFieldDefaulted( m_pImage, TIFFTAG_SAMPLEFORMAT, &sampleformat );\n\t\tm_SampleFormat = sampleformat;\n\n\t\tuint16 bitspersample;\n\t\tTIFFGetFieldDefaulted( m_pImage, TIFFTAG_BITSPERSAMPLE, &bitspersample );\n\t\tm_BitsPerSample = bitspersample;\n\n\t\tTIFFGetField( m_pImage, TIFFTAG_PIXAR_TEXTUREFORMAT, &pFormat );\n\t\tTIFFGetField( m_pImage, TIFFTAG_PIXAR_WRAPMODES, &pModes );\n\n\t\t// Resize the temporary storage values to the new depth.\n\t\tm_pixel_variance.resize( m_SamplesPerPixel );\n\t\tm_pixel_sublevel.resize( m_SamplesPerPixel );\n\t\tm_accum_color.resize( m_SamplesPerPixel );\n\n\t\t/* Aqsis supports a slighty different scheme for MipMap tiff file;\n\t\t * its filtering is kept as a string in \n\t\t * Texture Wrap Modes: \"periodic periodic box 1.000000 1.000000\"\n\t\t * where AIR, 3Delight, BMRT, RDC use very basic texture wrap mode description eg.\n\t\t * Texture Wrap Modes: \"black,black\"\n\t\t * therefore I initialized the value for filtering to be black, black, box, 1.0, 1.0\n\t\t * \n\t\t */\n\t\tif ( pModes )\n\t\t{\n\t\t\tInterpreted( pModes );\n\t\t}\n\t\tuint32 tsx;\n\n\t\t/* First tests; is it stored using tiles ? */\n\t\tTqInt bMipMap = TIFFGetField( m_pImage, TIFFTAG_TILEWIDTH, &tsx );\n\t\tbMipMap &= TIFFGetField( m_pImage, TIFFTAG_TILELENGTH, &tsx );\n\n\t\t/* Second test; is it containing enough directories for us */\n\t\tTqInt minRes = min(m_XRes, m_YRes );\n\t\tTqInt directory = static_cast<TqInt>(fastlog2(static_cast<TqFloat> (minRes)));\n\t\tif (TIFFSetDirectory(m_pImage, directory - 1) == false)\n\t\t   bMipMap &= TIFFSetDirectory(m_pImage, directory - 2);\n\n\n\t\tTIFFSetDirectory(m_pImage, 0 );\n\n\n\t\t/* Support for 3delight, AIR, BMRT, RDC, PIXIE MipMap files.\n\t\t * Aqsis is not bound to have exact multiples of 2 on height, length.\n\t\t * The Format of 3Delight, AIR, BMRT and RDC is more \"Plain Texture\"/MipMap.\n\t\t * What is preventing us to load their files was the format description file as \n\t\t * MipMap differ from our format description not the way they store their information.\n\t\t * A better way is to ask the direct question if if the image is stored as MipMap via\n\t\t * TIFFTAG_TILEWIDTH, TIFFTAG_TILELENGTH and checking if the texture contains enough \n\t\t * directory/pages.\n\t\t */\n\n\t\tif ( bMipMap )\n\t\t{\n\t\t\tm_Format = TexFormat_MIPMAP;\n\t\t\tm_IsValid = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_Format = TexFormat_Plain;\n\t\t\tm_IsValid = true;\n\t\t}\n\t}\n\tm_Directory = 0;\n\tfor (TqInt k=0; k < 256; k++)\n\t{\n\t\tm_apLast[k] = NULL;\n\t\tm_apMipMaps[k].resize(0);\n\t}\n\tm_apFlat.resize(0);\n}",
    "IqTextureMapOld* CqTextureMapOld::GetLatLongMap( const CqString& strName )\n{\n\tQGetRenderContext() ->Stats().IncTextureMisses( 2 );\n\n\tTqUlong hash = CqString::hash(strName.c_str());\n\n\t// First search the texture map cache\n\tfor ( std::vector<CqTextureMapOld*>::iterator i = m_TextureMap_Cache.begin(); i != m_TextureMap_Cache.end(); i++ )\n\t{\n\t\tif ( ( *i ) ->m_hash == hash )\n\t\t{\n\t\t\tif ( ( *i ) ->Type() == MapType_LatLong )\n\t\t\t{\n\t\t\t\tQGetRenderContext() ->Stats().IncTextureHits( 1, 2 );\n\t\t\t\treturn ( *i );\n\t\t\t} else\n\t\t\t{\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tQGetRenderContext() ->Stats().IncTextureHits( 0, 2 );\n\n\t// If we got here, it doesn't exist yet, so we must create and load it.\n\tCqTextureMapOld* pNew = new CqLatLongMapOld( strName );\n\tm_TextureMap_Cache.push_back( pNew );\n\tpNew->Open();\n\n\tTqPchar ptexfmt;\n\n\t// Invalid only if this is not a LatLong Env. map file\n\tif ( pNew->m_pImage == 0 ||\n\t        TIFFGetField( pNew->m_pImage, TIFFTAG_PIXAR_TEXTUREFORMAT, &ptexfmt ) != 1 ||\n\t        strcmp( ptexfmt, LATLONG_HEADER ) != 0 )\n\t{\n\t\tstatic bool done = false;\n\t\tif (!done)\n\t\t{\n\t\t\tAqsis::log() << error << \"Map \\\"\" << strName.c_str() << \"\\\" is not an environment map, use RiMakeLatLongEnvironment\" << std::endl;\n\t\t\tdone = true;\n\t\t}\n\n\t\tpNew->SetInvalid();\n   \t}\n\treturn ( pNew );\n}",
    "IqTextureMapOld* CqTextureMapOld::GetEnvironmentMap( const CqString& strName )\n{\n\tQGetRenderContext() ->Stats().IncTextureMisses( 1 );\n\n\tTqUlong hash = CqString::hash(strName.c_str());\n\n\t// First search the texture map cache\n\tfor ( std::vector<CqTextureMapOld*>::iterator i = m_TextureMap_Cache.begin(); i != m_TextureMap_Cache.end(); i++ )\n\t{\n\t\tif ( ( *i ) ->m_hash == hash )\n\t\t{\n\t\t\tif ( ( *i ) ->Type() == MapType_Environment )\n\t\t\t{\n\t\t\t\tQGetRenderContext() ->Stats().IncTextureHits( 1, 1 );\n\t\t\t\treturn ( *i );\n\t\t\t} else\n\t\t\t{\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tQGetRenderContext() ->Stats().IncTextureHits( 0, 1 );\n\n\t// If we got here, it doesn't exist yet, so we must create and load it.\n\tCqTextureMapOld* pNew = new CqEnvironmentMapOld( strName );\n\tm_TextureMap_Cache.push_back( pNew );\n\tpNew->Open();\n\n\tTqPchar ptexfmt = 0;\n\n\t// Invalid if the m_pImage is not there or it is not cube or latlong env. map file\n\tif ( pNew->m_pImage == 0 ||\n\t        TIFFGetField( pNew->m_pImage, TIFFTAG_PIXAR_TEXTUREFORMAT, &ptexfmt ) != 1 ||\n\t        ( strcmp( ptexfmt, CUBEENVMAP_HEADER ) != 0 ) && ( strcmp( ptexfmt, LATLONG_HEADER ) != 0 ) )\n\t{\n\t\tstatic bool done = false;\n\t\tif (!done)\n\t\t{\n\t\t\tAqsis::log() << error << \"Map \\\"\" << strName.c_str() << \"\\\" is not an environment map, use RiMakeCubeFaceEnvironment\" << std::endl;\n\t\t\tdone = true;\n\t\t}\n\t\tpNew->SetInvalid();\n\t\tdelete pNew;\n\t\tpNew = NULL;\n\n\t}\n\telse\n\t{\n\t\tTqFloat fov;\n\t\tif (TIFFGetField( pNew->m_pImage, TIFFTAG_PIXAR_FOVCOT, &fov) == 1)\n\t\t\t((CqEnvironmentMapOld *)pNew)->SetFov(fov);\n\t\telse\n\t\t\t((CqEnvironmentMapOld *)pNew)->SetFov(1.0);\n\t}\n\n\t// remove from the list a LatLong env. map since in shadeops.cpp we will cope with it.\n\tif ( ptexfmt && strcmp( ptexfmt, LATLONG_HEADER ) == 0 )\n\t{\n\t\tpNew->SetInvalid();\n\t\tdelete pNew;\n\t\tpNew = NULL;\n   \t} \n   \n\treturn ( pNew );\n}",
    "std::vector<Pixel> load_tiff(const char *path, std::uint32_t &image_width, std::uint32_t &image_height, std::size_t &image_size) {\n        TIFF *image_tiff = TIFFOpen(path, \"r\");\n        if(!image_tiff) {\n            eprintf_error(\"Cannot open %s\", path);\n            exit(EXIT_FAILURE);\n        }\n        TIFFGetField(image_tiff, TIFFTAG_IMAGEWIDTH, &image_width);\n        TIFFGetField(image_tiff, TIFFTAG_IMAGELENGTH, &image_height);\n\n        // Force associated alpha if we have alpha so alpha doesn't get multiplied in TIFFReadRGBAImageOriented\n        std::uint16_t count;\n        std::uint16_t *attributes;\n        int defined = TIFFGetField(image_tiff, TIFFTAG_EXTRASAMPLES, &count, &attributes);\n        if(defined && count == 1) {\n            if(*attributes == EXTRASAMPLE_UNASSALPHA) {\n                std::uint16_t new_value = EXTRASAMPLE_ASSOCALPHA;\n                TIFFSetField(image_tiff, TIFFTAG_EXTRASAMPLES, 1, &new_value);\n            }\n        }\n\n        // Read it all\n        image_size = image_width * image_height * sizeof(Invader::Pixel);\n        auto image_pixels = std::vector<Invader::Pixel>(image_size);\n        TIFFReadRGBAImageOriented(image_tiff, image_width, image_height, reinterpret_cast<std::uint32_t *>(image_pixels.data()), ORIENTATION_TOPLEFT);\n\n        // Close the TIFF\n        TIFFClose(image_tiff);\n\n        // Swap red and blue channels\n        for(std::size_t i = 0; i < image_size / 4; i++) {\n            Invader::Pixel swapped = image_pixels[i];\n            swapped.red = image_pixels[i].blue;\n            swapped.blue = image_pixels[i].red;\n            image_pixels[i] = swapped;\n        }\n\n        return image_pixels;\n    }",
    "TiffFileReader::TiffFileReader(const char* filepath)\n  {\n    _tiff = TIFFOpen(filepath, \"r\");\n    if (!_tiff)\n      throw std::runtime_error{fmt::format(\"Failed to open file {}\", filepath)};\n\n    TIFFGetField(_tiff, TIFFTAG_IMAGEWIDTH, &_width);\n    TIFFGetField(_tiff, TIFFTAG_IMAGELENGTH, &_height);\n  }",
    "void TPTImage::loadImageInfo( int seq, int ang )\n{\n  tdir_t current_dir;\n  int count = 0;\n  uint16_t colour, samplesperpixel, bitspersample, sampleformat;\n  double *sminvalue = NULL, *smaxvalue = NULL;\n  double scale;\n  unsigned int tw, th, w, h;\n  string filename;\n  const char *tmp = NULL;\n\n  currentX = seq;\n  currentY = ang;\n\n  // Get various essential image parameters\n  TIFFGetField( tiff, TIFFTAG_IMAGEWIDTH, &w );\n  TIFFGetField( tiff, TIFFTAG_IMAGELENGTH, &h );\n  TIFFGetField( tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel );\n  TIFFGetField( tiff, TIFFTAG_BITSPERSAMPLE, &bitspersample );\n  TIFFGetField( tiff, TIFFTAG_PHOTOMETRIC, &colour );\n  TIFFGetField( tiff, TIFFTAG_SAMPLEFORMAT, &sampleformat );\n  TIFFGetField( tiff, TIFFTAG_XRESOLUTION, &dpi_x );\n  TIFFGetField( tiff, TIFFTAG_YRESOLUTION, &dpi_y );\n  TIFFGetField( tiff, TIFFTAG_RESOLUTIONUNIT, &dpi_units );\n\n  // If image is untiled, set tile sizes to zero\n  if( TIFFGetField( tiff, TIFFTAG_TILEWIDTH, &tw ) == 0 ) tw = 0;\n  if( TIFFGetField( tiff, TIFFTAG_TILEWIDTH, &th ) == 0 ) th = 0;\n\n  // Units for libtiff are 1=unknown, 2=DPI and 3=pixels/cm, whereas we want 0=unknown, 1=DPI and 2=pixels/cm\n  dpi_units--;\n\n  // We have to do this conversion explicitly to avoid problems on Mac OS X\n  channels = (unsigned int) samplesperpixel;\n  bpc = (unsigned int) bitspersample;\n  sampleType = (sampleformat==3) ? SampleType::FLOATINGPOINT : SampleType::FIXEDPOINT;\n\n  // Check for the no. of resolutions in the pyramidal image\n  current_dir = TIFFCurrentDirectory( tiff );\n\n  // In order to get our list of image sizes, make sure we start in the first TIFF directory\n  if( current_dir != 0 ){\n    if( !TIFFSetDirectory( tiff, 0 ) ) throw file_error( \"TPTImage :: TIFFSetDirectory() failed\" );\n  }\n\n\n  // Empty any existing list of available resolution sizes\n  image_widths.clear();\n  image_heights.clear();\n  tile_widths.clear();\n  tile_heights.clear();\n\n  // Store the list of image dimensions available, starting with the full resolution\n  image_widths.push_back( w );\n  image_heights.push_back( h );\n  tile_widths.push_back( tw );\n  tile_heights.push_back( th );\n\n  // Add this to our list of valid resolutions\n  resolution_ids.push_back( 0 );\n\n  // Sub-resolutions can either be stored within the SubIFDs of a top-level IFD or in separate top-level IFDs.\n  // Check first for sub-resolution levels stored within SubIFDs (as used by OME-TIFF).\n  // In these files, the full resolution image is stored in the first IFD and subsequent\n  // resolutions are stored in SubIFDs\n  loadSubIFDs();\n  subifd_ifd = 0;\n\n  if( subifds.size() > 0 ){\n    // Start from 1 as the top-level IFD already holds the full resolution image\n    for( unsigned int n = 1; n<subifds.size(); n++ ){\n      if( TIFFSetSubDirectory( tiff, subifds[n] ) ){\n\tuint32_t stype;\n\t// Only use valid reduced image subfile types\n\tif( (TIFFGetField( tiff, TIFFTAG_SUBFILETYPE, &stype ) == 1) && (stype == 0x01) ){\n\n\t  // Store exact image size for each resolution level\n\t  TIFFGetField( tiff, TIFFTAG_IMAGEWIDTH, &w );\n\t  TIFFGetField( tiff, TIFFTAG_IMAGELENGTH, &h );\n\t  image_widths.push_back( w );\n\t  image_heights.push_back( h );\n\n\t  // Tile sizes can vary between resolutions\n\t  TIFFGetField( tiff, TIFFTAG_TILEWIDTH, &tw );\n\t  TIFFGetField( tiff, TIFFTAG_TILELENGTH, &th );\n\t  tile_widths.push_back( tw );\n\t  tile_heights.push_back( th );\n\n\t  count++;\n\t}\n      }\n    }\n\n    // If there are valid SubIFDs, tag this image appropriately and check whether we have a stack of images\n    if( count > 0 ){\n      pyramid = SUBIFD;\n      loadStackInfo();\n    }\n\n    // Reset to first TIFF directory\n    if( !TIFFSetDirectory( tiff, 0 ) ) throw file_error( \"TPTImage :: TIFFSetDirectory() failed\" );\n  }\n\n  // If there are no SubIFD resolutions, look for them in the main sequence of IFD TIFF directories\n  if( pyramid == NORMAL ){\n    for( count = 0; TIFFReadDirectory( tiff ); count++ ){\n\n      // Only use tiled IFD directories\n      if( ( TIFFGetField( tiff, TIFFTAG_TILEWIDTH, &tw ) == 1 ) &&\n\t  ( TIFFGetField( tiff, TIFFTAG_TILELENGTH, &th ) == 1 ) ){\n\n\t// Tile sizes can vary between resolutions\n\ttile_widths.push_back( tw );\n\ttile_heights.push_back( th );\n\n\t// Store exact image size for each resolution level\n\tTIFFGetField( tiff, TIFFTAG_IMAGEWIDTH, &w );\n\tTIFFGetField( tiff, TIFFTAG_IMAGELENGTH, &h );\n\timage_widths.push_back( w );\n\timage_heights.push_back( h );\n\n\t// Add this index to our list of valid resolutions\n\tresolution_ids.push_back( count+1 );\n      }\n\n    }\n\n    // Check whether this is in fact a stack from an image too small to have SubIFD resolutions\n    if( (image_widths.size() > 0) && (image_widths[0] == image_widths[1]) && (image_heights[0] == image_heights[1]) ){\n      loadStackInfo();\n      if( stack.size() > 0 ){\n\t// Remove duplicate sizes\n\timage_widths.resize(1);\n\timage_heights.resize(1);\n\ttile_widths.resize(1);\n\ttile_heights.resize(1);\n\tcount = 0;\n      }\n    }\n  }\n\n\n  // Total number of available resolutions\n  numResolutions = image_widths.size();\n\n\n  // Reset the TIFF directory to where it was\n  if( !TIFFSetDirectory( tiff, current_dir ) ) throw file_error( \"TPTImage :: TIFFSetDirectory() failed\" );\n\n\n  // Handle various colour spaces\n  if( colour == PHOTOMETRIC_CIELAB ) colorspace = ColorSpace::CIELAB;\n  else if( colour == PHOTOMETRIC_MINISBLACK ){\n    colorspace = (bpc==1)? ColorSpace::BINARY : ColorSpace::GREYSCALE;\n  }\n  else if( colour == PHOTOMETRIC_PALETTE ){\n    // Watch out for colourmapped images. These are stored as 1 sample per pixel,\n    // but are decoded to 3 channels by libtiff, so declare them as sRGB\n    colorspace = ColorSpace::sRGB;\n    channels = 3;\n  }\n  else if( colour == PHOTOMETRIC_YCBCR ){\n    // JPEG encoded tiles can be subsampled YCbCr encoded. Ask to decode these to RGB\n    TIFFSetField( tiff, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );\n    colorspace = ColorSpace::sRGB;\n  }\n  else colorspace = ColorSpace::sRGB;\n\n\n  // Get the max and min values for our data (important for float data)\n  // First initialize default values to zero in case\n  double *default_min = new double[channels];\n  double *default_max = new double[channels];\n  for( unsigned int k=0; k<channels; k++ ){\n    default_min[k] = 0.0;\n    default_max[k] = 0.0;\n  }\n\n  // These max and min values can either be single values per image, or as from libtiff > 4.0.2\n  // per channel (see: http://www.asmail.be/msg0055458208.html)\n#ifdef TIFFTAG_PERSAMPLE\n\n  TIFFSetField( tiff, TIFFTAG_PERSAMPLE, PERSAMPLE_MULTI ); // Need to activate per sample mode\n  TIFFGetField( tiff, TIFFTAG_SMINSAMPLEVALUE, &sminvalue );\n  TIFFGetField( tiff, TIFFTAG_SMAXSAMPLEVALUE, &smaxvalue );\n\n  if( !sminvalue ) sminvalue = default_min;\n  if( !smaxvalue ) smaxvalue = default_max;\n\n#else\n  // Set defaults\n  sminvalue = default_min;\n  smaxvalue = default_max;\n\n  // Add the single min/max header value to each channel if tag exists\n  double minmax;\n  if( TIFFGetField( tiff, TIFFTAG_SMINSAMPLEVALUE, &minmax ) == 1 ){\n    for( unsigned int k=0; k<channels; k++ ) sminvalue[k] = minmax;\n  }\n  if( TIFFGetField( tiff, TIFFTAG_SMAXSAMPLEVALUE, &minmax ) == 1 ){\n    for( unsigned int k=0; k<channels; k++ ) smaxvalue[k] = minmax;\n  }\n#endif\n\n  // Make sure our min and max arrays are empty\n  min.clear();\n  max.clear();\n\n  for( unsigned int i=0; i<channels; i++ ){\n    // Set our max to the full bit range if max not set in header\n    if( smaxvalue[i] == 0 ){\n      if( bpc <= 8 ) smaxvalue[i] = 255.0;\n      else if( bpc == 12 ) smaxvalue[i] = 4095.0;\n      else if( bpc == 16 ) smaxvalue[i] = 65535.0;\n      else if( bpc == 32 && sampleType == SampleType::FIXEDPOINT ) smaxvalue[i] = 4294967295.0;\n      else if( bpc == 32 && sampleType == SampleType::FLOATINGPOINT ) smaxvalue[i] = 1.0;  // Set dummy value for float\n    }\n    min.push_back( (float)sminvalue[i] );\n    max.push_back( (float)smaxvalue[i] );\n  }\n  // Don't forget to delete our allocated arrays\n  delete[] default_min;\n  delete[] default_max;\n\n  // Also get some basic metadata\n  if( TIFFGetField( tiff, TIFFTAG_ARTIST, &tmp ) ) metadata.insert( {\"creator\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_COPYRIGHT, &tmp ) ) metadata.insert( {\"rights\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_DATETIME, &tmp ) ) metadata.insert( {\"date\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_IMAGEDESCRIPTION, &tmp ) ) metadata.insert( {\"description\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_DOCUMENTNAME, &tmp ) ) metadata.insert( {\"title\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_PAGENAME, &tmp ) ) metadata.insert( {\"pagename\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_SOFTWARE, &tmp ) ) metadata.insert( {\"software\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_MAKE, &tmp ) ) metadata.insert( {\"make\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_MODEL, &tmp ) ) metadata.insert( {\"model\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_XMLPACKET, &count, &tmp ) ) metadata.insert( {\"xmp\",string(tmp,count)} );\n  if( TIFFGetField( tiff, TIFFTAG_ICCPROFILE, &count, &tmp ) ) metadata.insert( {\"icc\",string(tmp,count)} );\n  if( TIFFGetField( tiff, TIFFTAG_STONITS, &scale ) ){\n    char buffer[32];\n    snprintf( buffer, sizeof(buffer), \"%g\", scale );\n    metadata.insert( {\"scale\",buffer} );\n  }\n}",
    "RawTile TPTImage::getTile( int x, int y, unsigned int res, int layers, unsigned int tile, ImageEncoding requested_encoding )\n{\n  uint32_t im_width, im_height, tw, th, ntlx, ntly;\n  uint32_t rem_x, rem_y;\n  uint16_t colour, planar, compression;\n  string filename;\n\n\n  // Check the resolution exists\n  if( res > numResolutions ){\n    ostringstream error;\n    error << \"TPTImage :: Asked for non-existent resolution: \" << res;\n    throw file_error( error.str() );\n  }\n\n\n  // If we are currently working on a different sequence number, then\n  //  close and reload the image.\n  if( stack.empty() && ( (currentX != x) || (currentY != y) ) ){\n    closeImage();\n  }\n\n\n  // Open the TIFF if it's not already open\n  if( !tiff ){\n    filename = getFileName( x, y );\n    if( ( tiff = TIFFOpen( filename.c_str(), mode ) ) == NULL ){\n      throw file_error( \"TPTImage :: TIFFOpen() failed for:\" + filename );\n    }\n  }\n\n\n  // Reload our image information in case the tile size etc is different - no need to do this for image stacks\n  if( stack.empty() && ( (currentX != x) || (currentY != y) ) ){\n    loadImageInfo( x, y );\n  }\n\n\n  // The IIP protocol defines the first resolution as the smallest, so we need to invert\n  //  the requested resolution as our TIFF images are stored with the largest resolution first\n  int vipsres = ( numResolutions - 1 ) - res;\n\n\n  // Check in which directory we currently are\n  tdir_t cd = TIFFCurrentDirectory( tiff );\n\n  // Handle SubIFD-based resolution levels\n  if( pyramid == SUBIFD ){\n\n    // If we have an image stack within our TIFF, change to the appropriate directory\n    if( (int)cd != x ){\n      if( !TIFFSetDirectory( tiff, x ) ){\n\tostringstream error;\n\terror << \"TPTImage :: TIFFSetDirectory() failed for stack \" << x;\n\tthrow file_error( error.str() );\n      }\n      cd = x;\n    }\n\n    // Reload our SubIFD list if necessary\n    if( subifds.empty() || x != (int)subifd_ifd ){\n      loadSubIFDs();\n      subifd_ifd = cd;\n    }\n\n    // Change to the appropriate SubIFD directory if necessary\n    if( (vipsres < (int)subifds.size()) && (subifds[vipsres] > 0) ){\n      if( !TIFFSetSubDirectory( tiff, subifds[vipsres] ) ){\n\tostringstream error;\n\terror << \"TPTImage :: TIFFSetSubDirectory() failed for SubIFD offset \" << subifds[vipsres];\n\tthrow file_error( error.str() );\n      }\n    }\n  }\n  // If TIFF pyramid is a \"classic\" image pyramid with sub-resolutions within successive IFDs, just move to the appropriate directory\n  else {\n    if( vipsres != (int)cd ){\n      if( !TIFFSetDirectory( tiff, resolution_ids[vipsres] ) ){\n\tostringstream error;\n\terror << \"TPTImage :: TIFFSetDirectory() failed for resolution \" << vipsres;\n\tthrow file_error( error.str() );\n      }\n    }\n  }\n\n\n  // Check that a valid tile number was given\n  if( tile >= TIFFNumberOfTiles( tiff ) ) {\n    ostringstream tile_no;\n    tile_no << \"TPTImage :: Asked for non-existent tile: \" << tile;\n    throw file_error( tile_no.str() );\n  }\n\n\n  // Get the size of this tile, the size of the current resolution,\n  //   the number of samples and the colorspace.\n  //  TIFFGetField( tiff, TIFFTAG_TILEWIDTH, &tw );\n  //  TIFFGetField( tiff, TIFFTAG_TILELENGTH, &th );\n  TIFFGetField( tiff, TIFFTAG_IMAGEWIDTH, &im_width );\n  TIFFGetField( tiff, TIFFTAG_IMAGELENGTH, &im_height );\n  TIFFGetField( tiff, TIFFTAG_PHOTOMETRIC, &colour );\n  TIFFGetField( tiff, TIFFTAG_SAMPLESPERPIXEL, &channels );\n  TIFFGetField( tiff, TIFFTAG_BITSPERSAMPLE, &bpc );\n  TIFFGetField( tiff, TIFFTAG_PLANARCONFIG, &planar );\n  TIFFGetField( tiff, TIFFTAG_COMPRESSION, &compression );\n\n  // Get tile size for this resolution - make sure it is tiled\n  tw = tile_widths[vipsres];\n  th = tile_heights[vipsres];\n\n  if( (tw == 0) || (th == 0) ){\n    throw file_error( \"TPTImage :: Requested resolution is not tiled\" );\n  }\n\n  // Total number of pixels in tile\n  size_t np = tw * th;\n\n  // Get the width and height for last row and column tiles\n  rem_x = im_width % tw;\n  rem_y = im_height % th;\n\n\n  // Calculate the number of tiles in each direction\n  ntlx = (im_width / tw) + (rem_x == 0 ? 0 : 1);\n  ntly = (im_height / th) + (rem_y == 0 ? 0 : 1);\n\n\n  // Alter the tile size if it's in the last column\n  if( ( tile % ntlx == ntlx - 1 ) && ( rem_x != 0 ) ) {\n    tw = rem_x;\n  }\n\n\n  // Alter the tile size if it's in the bottom row\n  if( ( tile / ntlx == ntly - 1 ) && rem_y != 0 ) {\n    th = rem_y;\n  }\n\n\n  // Handle various colour spaces\n  if( colour == PHOTOMETRIC_CIELAB ) colorspace = ColorSpace::CIELAB;\n  else if( colour == PHOTOMETRIC_MINISBLACK ){\n    colorspace = (bpc==1)? ColorSpace::BINARY : ColorSpace::GREYSCALE;\n  }\n  else if( colour == PHOTOMETRIC_PALETTE ){\n    // Watch out for colourmapped images. There are stored as 1 sample per pixel,\n    // but are decoded to 3 channels by libtiff, so declare them as sRGB\n    colorspace = ColorSpace::GREYSCALE;\n    channels = 1;\n  }\n  else if( colour == PHOTOMETRIC_YCBCR ){\n    // JPEG encoded tiles can be subsampled YCbCr encoded. Ask to decode these to RGB\n    TIFFSetField( tiff, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );\n    colorspace = ColorSpace::sRGB;\n  }\n  else colorspace = ColorSpace::sRGB;\n\n\n  // Initialize our RawTile object\n  RawTile rawtile( tile, res, x, y, tile_widths[vipsres], tile_heights[vipsres], channels, bpc );\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n  rawtile.sampleType = sampleType;\n\n\n  // If codec pass-through is disabled or the tile needs reprocessing (cropping or change of bit depth),\n  //  make sure we decode the tile to raw pixel format\n  if( (IIPImage::codec_passthrough == false) ||\n      (tw != tile_widths[vipsres] || th != tile_heights[vipsres]) ||\n      (bpc==1 && channels==1) ){\n    requested_encoding = ImageEncoding::RAW;\n  }\n\n  // Also disable pass-through for TIFF-JPEGs where YCbCr sub-sampling has been defined with an RGB color space - these\n  // require the full JFIF format rather than the abreviated JPEG within the TIFF\n  if( requested_encoding == ImageEncoding::JPEG && compression == COMPRESSION_JPEG ){\n    uint16_t subsampling[2];\n    if( (TIFFGetField( tiff, TIFFTAG_YCBCRSUBSAMPLING, &subsampling[0], &subsampling[1] ) != 0) && (colour == PHOTOMETRIC_RGB) ){\n      if( IIPImage::logging ) logfile << \"TPTImage :: Sub-sampled RGB JPEG-encoded TIFF: tile decoded to RAW\" << endl;\n      requested_encoding = ImageEncoding::RAW;\n    }\n  }\n\n\n  // Calculate maximum amount of memory required for the tile when decoded as raw pixels values\n  tsize_t bytes = TIFFTileSize( tiff );\n\n\n  // If we are in pass-through mode, we need to know the exact number of bytes the tile\n  // takes up as this may sometimes be larger than the raw data size\n  if( ( requested_encoding == ImageEncoding::JPEG && compression == COMPRESSION_JPEG )\n#ifdef HAVE_WEB\n      || ( requested_encoding == ImageEncoding::WEBP && compression == COMPRESSION_WEBP )\n#endif\n      ){\n    // Get actual number of bytes for this specific tile from the TILEBYTECOUNTS tag\n    // which returns an array of all tile sizes in current IFD\n    uint64_t *bytecounts;\n    if( !TIFFGetField( tiff, TIFFTAG_TILEBYTECOUNTS, &bytecounts ) ){\n      ostringstream error;\n      error << \"TPTImage :: Unable to get byte count for tile \" << tile;\n      throw file_error( error.str() );\n    }\n    bytes = bytecounts[tile];\n    if( IIPImage::logging ) logfile << \"TPTImage :: Byte count for compressed tile: \" << bytes << endl;\n  }\n\n\n  // Get raw pre-encoded tile if our request matches the tile encoding - only currently makes sense for JPEG and WEBP\n  if( requested_encoding == ImageEncoding::JPEG && compression == COMPRESSION_JPEG ){\n\n    /* TIFF JPEG uses the JPEGTABLES field to store quantization and Huffman tables with image data stored\n       separately in each tile.\n       The JPEGTABLES tag data begins with a JPEG SOI marker (0XFF,0xD8), followed by the tables themselves\n       and ending with an EOI marker (0xFF,0xD9).\n       The tile data consists of image data preceeded by an SOI marker.\n       To reconstruct a full JPEG image, the table and tile data need to be concatenated, but with the final\n       EOI marker from the table tag and the initial SOI marker from the tile data removed\n    */\n\n    unsigned char* jpeg_tables;\n    uint16_t count = 0;\n\n    if( ( TIFFGetField( tiff, TIFFTAG_JPEGTABLES, &count, &jpeg_tables ) != 0 ) && ( count > 4 ) ){\n\n      // Allocate enough space for compressed tile data + JPEG tables\n      rawtile.allocate( bytes + count - 4 );\n\n      // Store last 2 bytes of the JPEG table data itself for use later - skip over the final 2 byte EOI marker\n      unsigned char table_end[2];\n      table_end[0] = ((unsigned char*)jpeg_tables)[count-4];\n      table_end[1] = ((unsigned char*)jpeg_tables)[count-3];\n\n      // Copy tables to our RawTile buffer - ignore the final 2 byte EOI marker\n      memcpy( rawtile.data, jpeg_tables, count-2 );\n\n      // Note starting position before we add image data - rewind by extra 2 bytes as we want to temporarily\n      // overwrite the end of the table data with the SOI which preceeds the image data in the tile stream\n      int pos = count - 4;\n\n      int length = TIFFReadRawTile( tiff, (ttile_t) tile, (tdata_t) &(((unsigned char*)rawtile.data)[pos]), bytes );\n      if( length == -1 ){\n\tthrow file_error( \"TPTImage :: TIFFReadRawTile() failed for JPEG-encoded tile for \" + getFileName( x, y ) );\n      }\n\n      // Overwrite superfluous SOI marker from tile with previously saved end of JPEG tables\n      ((unsigned char*)rawtile.data)[pos]=table_end[0];\n      ((unsigned char*)rawtile.data)[pos+1]=table_end[1];\n\n      rawtile.dataLength = pos + length;\n      rawtile.compressionType = ImageEncoding::JPEG;\n    }\n    else{\n      // Throw error if no JPEG tables present\n      throw file_error( \"TPTImage :: Empty TIFFTAG_JPEGTABLES tag for JPEG-encoded tile for \" + getFileName( x, y ) );\n    }\n  }\n\n#ifdef COMPRESSION_WEBP\n  else if( requested_encoding == ImageEncoding::WEBP && compression == COMPRESSION_WEBP ){\n\n    // Allocate buffer\n    rawtile.allocate( bytes );\n\n    // Copy compressed tile directly into buffer\n    int length = TIFFReadRawTile( tiff, (ttile_t) tile, (tdata_t) rawtile.data, bytes );\n    if( length == -1 ){\n      throw file_error( \"TPTImage :: TIFFReadRawTile() failed for WebP-encoded tile for \" + getFileName( x, y ) );\n    }\n    rawtile.dataLength = length;\n    rawtile.compressionType = ImageEncoding::WEBP;\n  }\n#endif\n\n  // Decode the tile into raw pixel data - dump data directly into RawTile buffer\n  else{\n\n    // Allocate buffer\n    rawtile.allocate( bytes );\n\n    // Copy decoded tile into buffer as raw pixel values\n    int length = TIFFReadEncodedTile( tiff, (ttile_t) tile, (tdata_t) rawtile.data, bytes );\n    if( length == -1 ){\n      throw file_error( \"TPTImage :: TIFFReadEncodedTile() failed for \" + getFileName( x, y ) );\n    }\n    rawtile.dataLength = length;\n    rawtile.quality = 100;\n    rawtile.compressionType = ImageEncoding::RAW;\n  }",
    "void TPTImage::loadSubIFDs()\n{\n  uint16_t n_subifd;\n  toff_t *subifd;\n  subifds.clear();\n  if( TIFFGetField( tiff, TIFFTAG_SUBIFD, &n_subifd, &subifd ) == 1 ){\n    if( n_subifd > 0 ){\n      subifds.push_back(0);\n      for( int n = 0; n<n_subifd; n++ ) subifds.push_back( subifd[n] );\n    }\n  }\n}",
    "void TPTImage::loadStackInfo()\n{\n  double scale;\n  const char *tmp = NULL;\n\n  // Reset to first TIFF directory\n  if( !TIFFSetDirectory( tiff, 0 ) ) throw file_error( \"TPTImage :: TIFFSetDirectory() failed\" );\n\n  // Start from 1 as horizontalAnglesList is initialized with 0 by default\n  int n = 1;\n\n  // Loop through our IFDs and get the name and scaling factor for each\n  do {\n    uint32_t stype;\n\n    // Stack layers should really be in multi-page type sub file types\n    if( (TIFFGetField( tiff, TIFFTAG_SUBFILETYPE, &stype ) == 1) && (stype == 0x02) ){\n      Stack s;\n      horizontalAnglesList.push_back(n++);\n      if( TIFFGetField( tiff, TIFFTAG_DOCUMENTNAME, &tmp ) ) s.name = string(tmp);\n      if( TIFFGetField( tiff, TIFFTAG_STONITS, &scale ) ) s.scale = (float) scale;\n      stack.push_back( s );\n    }\n  } while( TIFFReadDirectory(tiff) );\n\n  // Need to remove last item from stack list\n  if( horizontalAnglesList.size() > 1 ) horizontalAnglesList.pop_back();\n}",
    "void Watermark::init()\n{\n  if( _image.length() > 0 ){\n\n    TIFF *tiff_watermark;\n    if( ( tiff_watermark = TIFFOpen( _image.c_str(), \"r\" ) ) ){\n\n      TIFFGetField( tiff_watermark, TIFFTAG_IMAGEWIDTH, &_width );\n      TIFFGetField( tiff_watermark, TIFFTAG_IMAGELENGTH, &_height );\n      TIFFGetField( tiff_watermark, TIFFTAG_BITSPERSAMPLE, &_bpc );\n\n      uint32_t *buffer = new uint32_t[_width*_height];\n\n      if( TIFFReadRGBAImageOriented( tiff_watermark, _width, _height, buffer, ORIENTATION_TOPLEFT ) == 0 ){\n\tdelete[] buffer;\n\tTIFFClose( tiff_watermark );\n\treturn;\n      }\n\n      // Set our number of channels to 3 as TIFFReadRGBAImage always outputs an 8bit colour image\n      _channels = 3;\n\n      // Set up the memory storage\n      _watermark = new unsigned char[_width*_height*_channels];\n      memset( _watermark, 0, (size_t) _width*_height*_channels );\n\n      // Load the data into our buffers\n      for( uint32_t i=0; i<_width*_height; i++ ){\n\tuint32_t rgba = buffer[i];\n\tunsigned char r,g,b;\n\tfloat a;\n\t// Extract the RGBA values\n\tr = (unsigned char) TIFFGetR(rgba);\n\tg = (unsigned char) TIFFGetG(rgba);\n\tb = (unsigned char) TIFFGetB(rgba);\n\ta = (float) TIFFGetA(rgba) / 255;\n\t_watermark[i*3] = r * _opacity * a;\n\t_watermark[i*3 + 1] = g * _opacity * a;\n\t_watermark[i*3 + 2] = b * _opacity * a;\n      }\n\n      delete[] buffer;\n      TIFFClose( tiff_watermark );\n      _isSet = true;\n    }\n\n  }\n\n}",
    "EStatusCode TIFFImageHandler::ReadTopLevelTiffInformation()\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\ttdir_t directorycount = TIFFNumberOfDirectories(mT2p->input);\n\ttdir_t i=0;\n\tuint16 pagen=0;\n\tuint16 paged=0;\n\tuint16 xuint16=0;\n\n\tdo\n\t{\n\t\t// allocate tiff pages\n\t\tmT2p->tiff_pages = (T2P_PAGE*) _TIFFmalloc(directorycount * sizeof(T2P_PAGE));\n\t\tif(!mT2p->tiff_pages)\n\t\t{\n\t\t\tTRACE_LOG2(\"Can't allocate %u bytes of memory for tiff_pages array, %s\",\n\t\t\t\t\t\tdirectorycount * sizeof(T2P_PAGE),mT2p->inputFilePath.c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t\t_TIFFmemset( mT2p->tiff_pages, 0x00, directorycount * sizeof(T2P_PAGE));\n\t\n\t\t// allocate tile array, one for each page\n\t\tmT2p->tiff_tiles = (T2P_TILES*) _TIFFmalloc(directorycount * sizeof(T2P_TILES));\n\t\tif(!mT2p->tiff_tiles)\n\t\t{\n\t\t\tTRACE_LOG2(\"Can't allocate %u bytes of memory for tiff_tiles array, %s\",\n\t\t\t\t\t\tdirectorycount * sizeof(T2P_PAGE),mT2p->inputFilePath.c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t\t_TIFFmemset( mT2p->tiff_tiles, 0x00, directorycount * sizeof(T2P_TILES));\n\n\t\tfor(i=0;i<directorycount;i++)\n\t\t{\n\t\t\tbool isPage = false,isPage2 = false;\n\t\t\tuint32 subfiletype = 0;\n\t\t\t\n\t\t\tif(!TIFFSetDirectory(mT2p->input, i)){\n\t\t\t\tTRACE_LOG2(\"Can't set directory %u of input file %s\",\n\t\t\t\t\t\t\tdirectorycount * sizeof(T2P_PAGE),mT2p->inputFilePath.c_str());\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\t\t\t\n\n\t\t\tif(TIFFGetField(mT2p->input, TIFFTAG_PAGENUMBER, &pagen, &paged))\n\t\t\t{\n\t\t\t\tmT2p->tiff_pages[mT2p->tiff_pagecount].page_number =\n\t\t\t\t\t((pagen>paged) && (paged != 0)) ? paged : pagen;\n\t\t\t\tisPage2 = true;\n\t\t\t} \n\t\t\telse if(TIFFGetField(mT2p->input, TIFFTAG_SUBFILETYPE, &subfiletype))\n\t\t\t{\n\t\t\t\tisPage = ((subfiletype & FILETYPE_PAGE) != 0) || (subfiletype == 0);\n\t\t\t} \n\t\t\telse if(TIFFGetField(mT2p->input, TIFFTAG_OSUBFILETYPE, &subfiletype))\n\t\t\t{\n\t\t\t\tisPage =\t(subfiletype == OFILETYPE_IMAGE) || \n\t\t\t\t\t\t\t(subfiletype == OFILETYPE_PAGE)\t || \n\t\t\t\t\t\t\t(subfiletype == 0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tisPage = true;\n\t\t\t\tisPage2 = true;\n\t\t\t}\n\n\t\t\tif(isPage)\n\t\t\t\tmT2p->tiff_pages[mT2p->tiff_pagecount].page_number=mT2p->tiff_pagecount;\n\t\t\tif(isPage || isPage2)\n\t\t\t{\n\t\t\t\tmT2p->tiff_pages[mT2p->tiff_pagecount].page_directory=i;\n\t\t\t\tif(TIFFIsTiled(mT2p->input))\n\t\t\t\t{\n\t\t\t\t\tmT2p->tiff_pages[mT2p->tiff_pagecount].page_tilecount = \n\t\t\t\t\t\tTIFFNumberOfTiles(mT2p->input);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmT2p->tiff_pagecount++;\n\t\t}\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tqsort((void*) mT2p->tiff_pages, mT2p->tiff_pagecount,sizeof(T2P_PAGE), t2p_cmp_t2p_page);\n\n\t\tfor(i=0;i<mT2p->tiff_pagecount;i++)\n\t\t{\n\t\t\tTIFFSetDirectory(mT2p->input, mT2p->tiff_pages[i].page_directory );\n\t\t\tif((TIFFGetField(mT2p->input, TIFFTAG_PHOTOMETRIC, &xuint16)\n\t\t\t\t\t\t&& (xuint16==PHOTOMETRIC_PALETTE))\n\t\t\t   || TIFFGetField(mT2p->input, TIFFTAG_INDEXED, &xuint16)) \n\t\t\t{\n\t\t\t\tmT2p->tiff_pages[i].page_extra++;\n\t\t\t}\n\t\t\tif (TIFFGetField(mT2p->input, TIFFTAG_TRANSFERFUNCTION,\n\t\t\t\t\t\t\t\t\t &(mT2p->tiff_transferfunction[0]),\n\t\t\t\t\t\t\t\t\t &(mT2p->tiff_transferfunction[1]),\n\t\t\t\t\t\t\t\t\t &(mT2p->tiff_transferfunction[2]))) \n\t\t\t{\n\t\t\t\tif(mT2p->tiff_transferfunction[1] !=\n\t\t\t\t   mT2p->tiff_transferfunction[0]) \n\t\t\t\t{\n\t\t\t\t\tmT2p->tiff_transferfunctioncount = 3;\n\t\t\t\t\tmT2p->tiff_pages[i].page_extra += 4;\n\t\t\t\t} \n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tmT2p->tiff_transferfunctioncount = 1;\n\t\t\t\t\tmT2p->tiff_pages[i].page_extra += 2;\n\t\t\t\t}\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tmT2p->tiff_transferfunctioncount=0;\n\t\t\t}\n\t\t\tif(TIFFGetField(\n\t\t\t\tmT2p->input, \n\t\t\t\tTIFFTAG_ICCPROFILE, \n\t\t\t\t&(mT2p->tiff_iccprofilelength), \n\t\t\t\t&(mT2p->tiff_iccprofile)) != 0)\n\t\t\t{\n\t\t\t\tmT2p->tiff_pages[i].page_extra++;\n\t\t\t}\n\t\t\tmT2p->tiff_tiles[i].tiles_tilecount = mT2p->tiff_pages[i].page_tilecount;\n\t\t\tif( (TIFFGetField(mT2p->input, TIFFTAG_PLANARCONFIG, &xuint16) != 0)\n\t\t\t\t&& (xuint16 == PLANARCONFIG_SEPARATE ) )\n\t\t\t{\n\t\t\t\t\tTIFFGetField(mT2p->input, TIFFTAG_SAMPLESPERPIXEL, &xuint16);\n\t\t\t\t\tmT2p->tiff_tiles[i].tiles_tilecount/= xuint16;\n\t\t\t}\n\t\t\tif( mT2p->tiff_tiles[i].tiles_tilecount > 0)\n\t\t\t{\n\t\t\t\tTIFFGetField(mT2p->input, \n\t\t\t\t\tTIFFTAG_TILEWIDTH, \n\t\t\t\t\t&(mT2p->tiff_tiles[i].tiles_tilewidth));\n\t\t\t\tTIFFGetField(mT2p->input, \n\t\t\t\t\tTIFFTAG_TILELENGTH, \n\t\t\t\t\t&(mT2p->tiff_tiles[i].tiles_tilelength) );\n\t\t\t\tmT2p->tiff_tiles[i].tiles_tiles = \n\t\t\t\t(T2P_TILE*) _TIFFmalloc(\n\t\t\t\t\tmT2p->tiff_tiles[i].tiles_tilecount \n\t\t\t\t\t* sizeof(T2P_TILE) );\n\t\t\t\tif(!mT2p->tiff_tiles[i].tiles_tiles)\n\t\t\t\t{\n\n\t\t\t\t\tTRACE_LOG2(\"Can't allocate %u bytes of memory for tiles, %s\",\n\t\t\t\t\t\t\t\tmT2p->tiff_tiles[i].tiles_tilecount * sizeof(T2P_TILE),\n\t\t\t\t\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\n\t\n\t}while(false);\n\treturn status;\n}",
    "EStatusCode TIFFImageHandler::ReadTIFFPageInformation() //t2p_read_tiff_data\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\tuint16 xuint16;\n\tuint16* xuint16p;\n\tfloat* xfloatp;\n\n\tmT2p->pdf_transcode = T2P_TRANSCODE_ENCODE;\n\tTIFFSetDirectory(mT2p->input, mT2p->tiff_pages[mT2p->pdf_page].page_directory);\n\tTIFFGetField(mT2p->input, TIFFTAG_IMAGEWIDTH, &(mT2p->tiff_width));\n\n\tdo\n\t{\n\t\tTIFFGetField(mT2p->input, TIFFTAG_IMAGEWIDTH, &(mT2p->tiff_width));\n\t\tif(0 == mT2p->tiff_width)\n\t\t{\n\t\t\tTRACE_LOG1(\"TIFFImageHandler::ReadTIFFPageInformation: No support for %s with zero width\",\n\t\t\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tTIFFGetField(mT2p->input, TIFFTAG_IMAGELENGTH, &(mT2p->tiff_length));\n\t\tif(0 == mT2p->tiff_length)\n\t\t{\n\t\t\tTRACE_LOG1(\"TIFFImageHandler::ReadTIFFPageInformation: No support for %s with zero length\",\n\t\t\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n        if(TIFFGetField(mT2p->input, TIFFTAG_COMPRESSION, &mT2p->tiff_compression) == 0)\n\t\t{\n\t\t\tTRACE_LOG1(\"TIFFImageHandler::ReadTIFFPageInformation: No support for %s with no compression tag\",\n\t\t\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\n        }\n\n        if( TIFFIsCODECConfigured(mT2p->tiff_compression) == 0)\n\t\t{\n\t\t\tTRACE_LOG2(\n\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation: No support for %s with compression type %u:  not configured\", \n\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\tmT2p->tiff_compression);\t\t\t\t\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tTIFFGetFieldDefaulted(mT2p->input, TIFFTAG_BITSPERSAMPLE, &(mT2p->tiff_bitspersample));\n\t\tswitch(mT2p->tiff_bitspersample)\n\t\t{\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\tcase 4:\n\t\t\tcase 8:\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tTRACE_LOG1(\n\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation: Image %s has 0 bits per sample, assuming 1\", \n\t\t\t\t\tmT2p->inputFilePath.c_str());\t\t\t\t\n\t\t\t\tmT2p->tiff_bitspersample = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tTRACE_LOG2(\n\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation: No support for %s with %u bits per sample\", \n\t\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\t\tmT2p->tiff_bitspersample);\t\t\t\t\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t}\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tTIFFGetFieldDefaulted(mT2p->input, TIFFTAG_SAMPLESPERPIXEL, &(mT2p->tiff_samplesperpixel));\n\t\tif(mT2p->tiff_samplesperpixel>4)\n\t\t{\n\t\t\tTRACE_LOG2(\n\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation: No support for %s with %u samples per pixel\", \n\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\tmT2p->tiff_samplesperpixel);\t\t\t\t\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(mT2p->tiff_samplesperpixel==0)\n\t\t{\n\t\t\tTRACE_LOG1(\n\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation: Image %s has 0 samples per pixel, assuming 1\", \n\t\t\t\tmT2p->inputFilePath.c_str());\t\n\t\t\tmT2p->tiff_samplesperpixel=1;\n\t\t}\n\t\n\t\tif(TIFFGetField(mT2p->input, TIFFTAG_SAMPLEFORMAT, &xuint16) != 0 )\n\t\t{\n\t\t\tswitch(xuint16)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\tcase 1:\n\t\t\t\tcase 4:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tTRACE_LOG2(\n\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation: No support for %s with sample format %u\", \n\t\t\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\t\t\txuint16);\t\t\t\t\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t\n\t\tTIFFGetFieldDefaulted(mT2p->input, TIFFTAG_FILLORDER, &(mT2p->tiff_fillorder));\n        if(TIFFGetField(mT2p->input, TIFFTAG_PHOTOMETRIC, &(mT2p->tiff_photometric)) == 0)\n\t\t{\n\t\t\tTRACE_LOG1(\"TIFFImageHandler::ReadTIFFPageInformation: No support for %s with no photometric interpretation tag\",\n\t\t\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n        }\n\n\t\tswitch(mT2p->tiff_photometric)\n\t\t{\n\t\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\t\tcase PHOTOMETRIC_MINISBLACK: \n\t\t\t\tif (mT2p->tiff_bitspersample==1){\n\t\t\t\t\tmT2p->pdf_colorspace=T2P_CS_BILEVEL;\n\t\t\t\t\tif(mT2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){\n\t\t\t\t\t\tmT2p->pdf_switchdecode ^= 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmT2p->pdf_colorspace=T2P_CS_GRAY;\n\t\t\t\t\tif(mT2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){\n\t\t\t\t\t\tmT2p->pdf_switchdecode ^= 1;\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_RGB: \n\t\t\t\tmT2p->pdf_colorspace=T2P_CS_RGB;\n\t\t\t\tif(mT2p->tiff_samplesperpixel == 3)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(TIFFGetField(mT2p->input, TIFFTAG_INDEXED, &xuint16))\n\t\t\t\t{\n\t\t\t\t\tif(xuint16==1)\n\t\t\t\t\t\tReadPhotometricPalette();\n\t\t\t\t}\n\t\t\t\tif(mT2p->tiff_samplesperpixel > 3) \n\t\t\t\t{\n\t\t\t\t\tif(mT2p->tiff_samplesperpixel == 4) \n\t\t\t\t\t{\n\t\t\t\t\t\tmT2p->pdf_colorspace = T2P_CS_RGB;\n\t\t\t\t\t\tif(TIFFGetField(mT2p->input,\n\t\t\t\t\t\t\t\tTIFFTAG_EXTRASAMPLES,\n\t\t\t\t\t\t\t\t&xuint16, &xuint16p)\n\t\t\t\t\t\t   && xuint16 == 1) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(xuint16p[0] == EXTRASAMPLE_ASSOCALPHA)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmT2p->pdf_sample=T2P_SAMPLE_RGBAA_TO_RGB;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xuint16p[0] == EXTRASAMPLE_UNASSALPHA)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmT2p->pdf_sample=T2P_SAMPLE_RGBA_TO_RGB;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tTRACE_LOG1(\n\t\t\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, RGB image %s has 4 samples per pixel, assuming RGBA\",\n\t\t\t\t\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmT2p->pdf_colorspace=T2P_CS_CMYK;\n\t\t\t\t\t\tmT2p->pdf_switchdecode ^= 1;\n\t\t\t\t\t\tTRACE_LOG1(\n\t\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, RGB image %s has 4 samples per pixel, assuming CMYK\",\n\t\t\t\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} \n\t\t\t\t\telse \n\t\t\t\t\t{\n\t\t\t\t\t\tTRACE_LOG2(\n\t\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for RGB image %s with %u samples per pixel\",\n\t\t\t\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\t\t\t\tmT2p->tiff_samplesperpixel\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tTRACE_LOG2(\n\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for RGB image %s with %u samples per pixel\",\n\t\t\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\t\t\tmT2p->tiff_samplesperpixel\n\t\t\t\t\t\t);\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase PHOTOMETRIC_PALETTE: \n\t\t\t\tstatus = ReadPhotometricPalette();\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_SEPARATED:\n\t\t\t\tif(TIFFGetField(mT2p->input, TIFFTAG_INDEXED, &xuint16))\n\t\t\t\t{\n\t\t\t\t\tif(xuint16==1)\n\t\t\t\t\t\tReadPhotometricPaletteCMYK();\n\t\t\t\t}\n\t\t\t\tif( TIFFGetField(mT2p->input, TIFFTAG_INKSET, &xuint16) )\n\t\t\t\t{\n\t\t\t\t\tif(xuint16 != INKSET_CMYK)\n\t\t\t\t\t{\n\t\t\t\t\t\tTRACE_LOG1(\n\t\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for %s because its inkset is not CMYK\",\n\t\t\t\t\t\t\tmT2p->inputFilePath.c_str()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(mT2p->tiff_samplesperpixel==4)\n\t\t\t\t{\n\t\t\t\t\tmT2p->pdf_colorspace=T2P_CS_CMYK;\n\t\t\t\t} \n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG2(\n\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for %s because it has %u samples per pixel\",\n\t\t\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\t\t\tmT2p->tiff_samplesperpixel\n\t\t\t\t\t\t);\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_YCBCR:\n\t\t\t\tmT2p->pdf_colorspace=T2P_CS_RGB;\n\t\t\t\tif(mT2p->tiff_samplesperpixel==1)\n\t\t\t\t{\n\t\t\t\t\tmT2p->pdf_colorspace=T2P_CS_GRAY;\n\t\t\t\t\tmT2p->tiff_photometric=PHOTOMETRIC_MINISBLACK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmT2p->pdf_sample=T2P_SAMPLE_YCBCR_TO_RGB;\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_CIELAB:\n\t\t\t\tmT2p->pdf_labrange[0]= -127;\n\t\t\t\tmT2p->pdf_labrange[1]= 127;\n\t\t\t\tmT2p->pdf_labrange[2]= -127;\n\t\t\t\tmT2p->pdf_labrange[3]= 127;\n\t\t\t\tmT2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;\n\t\t\t\tmT2p->pdf_colorspace=T2P_CS_LAB;\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_ICCLAB:\n\t\t\t\tmT2p->pdf_labrange[0]= 0;\n\t\t\t\tmT2p->pdf_labrange[1]= 255;\n\t\t\t\tmT2p->pdf_labrange[2]= 0;\n\t\t\t\tmT2p->pdf_labrange[3]= 255;\n\t\t\t\tmT2p->pdf_colorspace=T2P_CS_LAB;\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_ITULAB:\n\t\t\t\tmT2p->pdf_labrange[0]=-85;\n\t\t\t\tmT2p->pdf_labrange[1]=85;\n\t\t\t\tmT2p->pdf_labrange[2]=-75;\n\t\t\t\tmT2p->pdf_labrange[3]=124;\n\t\t\t\tmT2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;\n\t\t\t\tmT2p->pdf_colorspace=T2P_CS_LAB;\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_LOGL:\n\t\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\t\tTRACE_LOG1(\n\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for %s with photometric interpretation LogL/LogLuv\",\n\t\t\t\t\tmT2p->inputFilePath.c_str()\n\t\t\t\t\t);\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tTRACE_LOG1(\n\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for %s with photometric interpretation %u\",\n\t\t\t\t\tmT2p->inputFilePath.c_str()\n\t\t\t\t\t);\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t}\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tif(TIFFGetField(mT2p->input, TIFFTAG_PLANARCONFIG, &(mT2p->tiff_planar)))\n\t\t{\n\t\t\tswitch(mT2p->tiff_planar)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tTRACE_LOG1(\n\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, Image %s has planar configuration 0, assuming 1\", \n\t\t\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\t\t\tmT2p->tiff_planar=PLANARCONFIG_CONTIG;\n\t\t\t\tcase PLANARCONFIG_CONTIG:\n\t\t\t\t\tbreak;\n\t\t\t\tcase PLANARCONFIG_SEPARATE:\n\t\t\t\t\tmT2p->pdf_sample=T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG;\n\t\t\t\t\tif(mT2p->tiff_bitspersample!=8)\n\t\t\t\t\t{\n\t\t\t\t\t\tTRACE_LOG2(\n\t\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for %s with separated planar configuration and %u bits per sample\", \n\t\t\t\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\t\t\t\tmT2p->tiff_bitspersample);\n\t\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tTRACE_LOG2(\n\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for %s with planar configuration %u\", \n\t\t\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\t\t\tmT2p->tiff_planar);\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t}\n\n        TIFFGetFieldDefaulted(mT2p->input, TIFFTAG_ORIENTATION,\n                              &(mT2p->tiff_orientation));\n        if(mT2p->tiff_orientation>8)\n\t\t{\n                TRACE_LOG2(\"TIFFImageHandler::ReadTIFFPageInformation, Image %s has orientation %u, assuming 0\",\n                            mT2p->inputFilePath.c_str(), \n\t\t\t\t\t\t\tmT2p->tiff_orientation);\n                mT2p->tiff_orientation=0;\n        }\n\n        if(TIFFGetField(mT2p->input, TIFFTAG_XRESOLUTION, &(mT2p->tiff_xres) ) == 0)\n\t\t{\n                mT2p->tiff_xres=0.0;\n        }\n        if(TIFFGetField(mT2p->input, TIFFTAG_YRESOLUTION, &(mT2p->tiff_yres) ) == 0)\n\t\t{\n                mT2p->tiff_yres=0.0;\n        }\n\t\tTIFFGetFieldDefaulted(mT2p->input, TIFFTAG_RESOLUTIONUNIT,&(mT2p->tiff_resunit));\n\t\tif(mT2p->tiff_resunit == RESUNIT_CENTIMETER) \n\t\t{\n\t\t\tmT2p->tiff_xres *= 2.54F;\n\t\t\tmT2p->tiff_yres *= 2.54F;\n\t\t} \n\t\telse if (mT2p->tiff_resunit != RESUNIT_INCH && mT2p->pdf_centimeters != 0) \n\t\t{\n\t\t\tmT2p->tiff_xres *= 2.54F;\n\t\t\tmT2p->tiff_yres *= 2.54F;\n\t\t}\n\n\t\tComposePDFPage();\n\n\t\tmT2p->pdf_transcode = T2P_TRANSCODE_ENCODE;\n\t\tif(mT2p->pdf_nopassthrough==0)\n\t\t{\n\t\t\tif(mT2p->tiff_compression==COMPRESSION_CCITTFAX4)\n\t\t\t{\n\t\t\t\tif(TIFFIsTiled(mT2p->input) || (TIFFNumberOfStrips(mT2p->input)==1) )\n\t\t\t\t{\n\t\t\t\t\tmT2p->pdf_transcode = T2P_TRANSCODE_RAW;\n\t\t\t\t\tmT2p->pdf_compression=T2P_COMPRESS_G4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mT2p->tiff_compression== COMPRESSION_ADOBE_DEFLATE \n\t\t\t\t|| mT2p->tiff_compression==COMPRESSION_DEFLATE)\n\t\t\t{\n\t\t\t\tif(TIFFIsTiled(mT2p->input) || (TIFFNumberOfStrips(mT2p->input)==1) )\n\t\t\t\t{\n\t\t\t\t\tmT2p->pdf_transcode = T2P_TRANSCODE_RAW;\n\t\t\t\t\tmT2p->pdf_compression=T2P_COMPRESS_ZIP;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(mT2p->pdf_transcode!=T2P_TRANSCODE_RAW)\n\t\t{\n\t\t\tmT2p->pdf_compression = mT2p->pdf_defaultcompression;\n\t\t}\n\n\t\tif(mT2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE)\n\t\t{\n\t\t\tif(mT2p->pdf_colorspace & T2P_CS_CMYK)\n\t\t\t{\n\t\t\t\tmT2p->tiff_samplesperpixel=4;\n\t\t\t\tmT2p->tiff_photometric=PHOTOMETRIC_SEPARATED;\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tmT2p->tiff_samplesperpixel=3;\n\t\t\t\tmT2p->tiff_photometric=PHOTOMETRIC_RGB;\n\t\t\t}\n\t\t}\n\n\t\tif (TIFFGetField(mT2p->input, TIFFTAG_TRANSFERFUNCTION,\n\t\t\t\t &(mT2p->tiff_transferfunction[0]),\n\t\t\t\t &(mT2p->tiff_transferfunction[1]),\n\t\t\t\t &(mT2p->tiff_transferfunction[2]))) \n\t\t{\n\t\t\tif(mT2p->tiff_transferfunction[1] !=\n\t\t\t   mT2p->tiff_transferfunction[0]) \n\t\t\t{\n\t\t\t\tmT2p->tiff_transferfunctioncount=3;\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tmT2p->tiff_transferfunctioncount=1;\n\t\t\t}\n\t\t} \n\t\telse \n\t\t{\n\t\t\tmT2p->tiff_transferfunctioncount=0;\n\t\t}\n\t\tif(TIFFGetField(mT2p->input, TIFFTAG_WHITEPOINT, &xfloatp)!=0)\n\t\t{\n\t\t\tmT2p->tiff_whitechromaticities[0]=xfloatp[0];\n\t\t\tmT2p->tiff_whitechromaticities[1]=xfloatp[1];\n\t\t\tif(mT2p->pdf_colorspace & T2P_CS_GRAY)\n\t\t\t{\n\t\t\t\tmT2p->pdf_colorspace = (t2p_cs_t)(mT2p->pdf_colorspace | T2P_CS_CALGRAY);\n\t\t\t}\n\t\t\tif(mT2p->pdf_colorspace & T2P_CS_RGB)\n\t\t\t{\n\t\t\t\tmT2p->pdf_colorspace = (t2p_cs_t)(mT2p->pdf_colorspace | T2P_CS_CALRGB);\n\t\t\t}\n\t\t}\n\t\tif(TIFFGetField(mT2p->input, TIFFTAG_PRIMARYCHROMATICITIES, &xfloatp)!=0)\n\t\t{\n\t\t\tmT2p->tiff_primarychromaticities[0]=xfloatp[0];\n\t\t\tmT2p->tiff_primarychromaticities[1]=xfloatp[1];\n\t\t\tmT2p->tiff_primarychromaticities[2]=xfloatp[2];\n\t\t\tmT2p->tiff_primarychromaticities[3]=xfloatp[3];\n\t\t\tmT2p->tiff_primarychromaticities[4]=xfloatp[4];\n\t\t\tmT2p->tiff_primarychromaticities[5]=xfloatp[5];\n\t\t\tif(mT2p->pdf_colorspace & T2P_CS_RGB)\n\t\t\t{\n\t\t\t\tmT2p->pdf_colorspace = (t2p_cs_t)(mT2p->pdf_colorspace | T2P_CS_CALRGB);\n\t\t\t}\n\t\t}\n\t\tif(mT2p->pdf_colorspace & T2P_CS_LAB)\n\t\t{\n\t\t\tif(TIFFGetField(mT2p->input, TIFFTAG_WHITEPOINT, &xfloatp) != 0)\n\t\t\t{\n\t\t\t\tmT2p->tiff_whitechromaticities[0]=xfloatp[0];\n\t\t\t\tmT2p->tiff_whitechromaticities[1]=xfloatp[1];\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tmT2p->tiff_whitechromaticities[0]=0.3457F; /* 0.3127F; */\n\t\t\t\tmT2p->tiff_whitechromaticities[1]=0.3585F; /* 0.3290F; */\n\t\t\t}\n\t\t}\n\t\tif(TIFFGetField(mT2p->input, \n\t\t\tTIFFTAG_ICCPROFILE, \n\t\t\t&(mT2p->tiff_iccprofilelength), \n\t\t\t&(mT2p->tiff_iccprofile))!=0){\n\t\t\tmT2p->pdf_colorspace = (t2p_cs_t)(mT2p->pdf_colorspace | T2P_CS_ICCBASED);\n\t\t} \n\t\telse \n\t\t{\n\t\t\tmT2p->tiff_iccprofilelength=0;\n\t\t\tmT2p->tiff_iccprofile=NULL;\n\t\t}\n\t\t\n\t\tif( mT2p->tiff_bitspersample==1 &&\n\t\t\tmT2p->tiff_samplesperpixel==1)\n\t\t{\n\t\t\tmT2p->pdf_compression = T2P_COMPRESS_G4;\n\t\t}\n\t}while(false);\n\n\treturn status;\n}",
    "EStatusCode TIFFImageHandler::ReadPhotometricPalette()\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\tuint16* r;\n\tuint16* g;\n\tuint16* b;\n\n\tdo\n\t{\n\t\tif(mT2p->tiff_samplesperpixel!=1)\n\t\t{\n\t\t\tTRACE_LOG1(\n\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for palettized image %s with not one sample per pixel\",\n\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t\tmT2p->pdf_colorspace= (t2p_cs_t)(T2P_CS_RGB | T2P_CS_PALETTE);\n\t\tmT2p->pdf_palettesize=0x0001<<mT2p->tiff_bitspersample;\n\t\tif(!TIFFGetField(mT2p->input, TIFFTAG_COLORMAP, &r, &g, &b))\n\t\t{\n\t\t\tTRACE_LOG1(\n\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, Palettized image %s has no color map\",\n\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t} \n\t\tif(mT2p->pdf_palette != NULL)\n\t\t{\n\t\t\t_TIFFfree(mT2p->pdf_palette);\n\t\t\tmT2p->pdf_palette=NULL;\n\t\t}\n\t\tmT2p->pdf_palette = (unsigned char*)\n\t\t\t_TIFFmalloc(mT2p->pdf_palettesize*3);\n\t\tif(mT2p->pdf_palette==NULL)\n\t\t{\n\t\t\tTRACE_LOG2(\n\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, Can't allocate %u bytes of memory for t2p_read_tiff_image, %s\",\n\t\t\t\tmT2p->pdf_palettesize,\n\t\t\t\tmT2p->inputFilePath.c_str()\n\t\t\t\t);\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<mT2p->pdf_palettesize;i++)\n\t\t{\n\t\t\tmT2p->pdf_palette[(i*3)]  = (unsigned char) (r[i]>>8);\n\t\t\tmT2p->pdf_palette[(i*3)+1]= (unsigned char) (g[i]>>8);\n\t\t\tmT2p->pdf_palette[(i*3)+2]= (unsigned char) (b[i]>>8);\n\t\t}\n\t\tmT2p->pdf_palettesize *= 3;\n\t}while(false);\n\n\treturn status;\n}",
    "EStatusCode TIFFImageHandler::ReadPhotometricPaletteCMYK()\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\tuint16* r;\n\tuint16* g;\n\tuint16* b;\n\tuint16* a;\n\n\tdo\n\t{\n\t\tif(mT2p->tiff_samplesperpixel!=1)\n\t\t{\n\t\t\tTRACE_LOG1(\n\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for palettized CMYK image %s with not one sample per pixel\",\n\t\t\t\tmT2p->inputFilePath.c_str()\n\t\t\t\t);\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t\tmT2p->pdf_colorspace=t2p_cs_t(T2P_CS_CMYK | T2P_CS_PALETTE);\n\t\tmT2p->pdf_palettesize=0x0001<<mT2p->tiff_bitspersample;\n\t\tif(!TIFFGetField(mT2p->input, TIFFTAG_COLORMAP, &r, &g, &b, &a))\n\t\t{\n\t\t\tTRACE_LOG1(\n\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, Palettized image %s has no color map\",\n\t\t\t\tmT2p->inputFilePath.c_str()\n\t\t\t\t);\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t} \n\t\tif(mT2p->pdf_palette != NULL)\n\t\t{\n\t\t\t_TIFFfree(mT2p->pdf_palette);\n\t\t\tmT2p->pdf_palette=NULL;\n\t\t}\n\t\tmT2p->pdf_palette = (unsigned char*) \n\t\t\t_TIFFmalloc(mT2p->pdf_palettesize*4);\n\t\tif(mT2p->pdf_palette==NULL)\n\t\t{\n\t\t\tTRACE_LOG2(\n\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, Can't allocate %u bytes of memory for t2p_read_tiff_image, %s\",\n\t\t\t\tmT2p->pdf_palettesize, \n\t\t\t\tmT2p->inputFilePath.c_str()\n\t\t\t\t);\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<mT2p->pdf_palettesize;i++)\n\t\t{\n\t\t\tmT2p->pdf_palette[(i*4)]  = (unsigned char) (r[i]>>8);\n\t\t\tmT2p->pdf_palette[(i*4)+1]= (unsigned char) (g[i]>>8);\n\t\t\tmT2p->pdf_palette[(i*4)+2]= (unsigned char) (b[i]>>8);\n\t\t\tmT2p->pdf_palette[(i*4)+3]= (unsigned char) (a[i]>>8);\n\t\t}\n\t\tmT2p->pdf_palettesize *= 4;\n\t}while(false);\n\n\treturn status;\n}",
    "void TIFFImageHandler::CalculateTiffTileSize(int inTileIndex)\n{\n\tuint16 edge=0;\n\n\tedge |= (uint16)TileIsRightEdge(inTileIndex);\n\tedge |= (uint16)TileIsBottomEdge(inTileIndex);\n\t\n\tif(mT2p->pdf_transcode==T2P_TRANSCODE_RAW)\n\t{\n\t\tif(edge)\n\t\t{\n\t\t\tmT2p->tiff_datasize=TIFFTileSize(mT2p->input);\n\t\t} else \n\t\t{\n\t\t\t// \tTIFFTAG_TILEBYTECOUNTS changed in tiff 4.0.0;\n\n\t\t\ttsize_t_compat* tbc = NULL;\n\t\t\tTIFFGetField(mT2p->input, TIFFTAG_TILEBYTECOUNTS, &tbc);\n\t\t\tmT2p->tiff_datasize=static_cast<tsize_t>(tbc[inTileIndex]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tmT2p->tiff_datasize=TIFFTileSize(mT2p->input);\n\t\tif(mT2p->tiff_planar==PLANARCONFIG_SEPARATE)\n\t\t\tmT2p->tiff_datasize*= mT2p->tiff_samplesperpixel;\n\t}\n}",
    "void TIFFImageHandler::CalculateTiffSizeNoTiles()\n{\n\tif(mT2p->pdf_transcode == T2P_TRANSCODE_RAW && \n\t\t(mT2p->pdf_compression == T2P_COMPRESS_G4 || mT2p->pdf_compression == T2P_COMPRESS_ZIP))\n\t{\n\t\t// TIFFTAG_STRIPBYTECOUNTS size changed in tiff 4.0.0\n\t\ttsize_t_compat * sbc = NULL;\n\t\tTIFFGetField(mT2p->input, TIFFTAG_STRIPBYTECOUNTS, &sbc);\n\t\tmT2p->tiff_datasize = static_cast<tsize_t>(sbc[0]);\n\t}\n\telse\n\t{\n\t\tmT2p->tiff_datasize=TIFFScanlineSize(mT2p->input) * mT2p->tiff_length;\n\t\tif(mT2p->tiff_planar==PLANARCONFIG_SEPARATE)\n\t\t\tmT2p->tiff_datasize*= mT2p->tiff_samplesperpixel;\n\t}\n}",
    "bool FilmScan::SourceTIFF(const std::string filename)\n{\n\t// verify the file is a TIFF and get the width and height from the header\n\tInStream img;\n\n\tTIFF *tif;\n\n\tif((tif = TIFFOpen(filename.c_str(), \"r\")) == NULL)\n\t{\n\t\tQString msg;\n\t\tint err;\n\n\t\tmsg += QString(\"FilmScan: Cannot open \");\n\t\tmsg += QString(filename.c_str());\n\t\tmsg += QString(\"\\n\");\n\t\tif((err=errno)!=0) msg += QString(strerror(err));\n\t\tthrow AeoException(msg);\n\t}\n\n\t// just grab the width and height from the header\n\tuint32 w, h;\n\tif(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w) != 1 ||\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h) != 1)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Invalid image size specification in TIFF.\");\n\t}\n\n\tTIFFClose(tif);\n\n\tthis->width = w;\n\tthis->height = h;\n\tthis->srcFormat = SOURCE_TIFF;\n\n\tthis->TimeCode = \"00:00:00:00\";\n\tSourceIdentifyImageSet(filename);\n\n\treturn true;\n}",
    "unsigned char *ReadFrameTIFF_ImageData(const char *fn, unsigned char *buf,\n\t\tint &width, int &height, bool &endian,\n\t\tGLenum &pix_fmt, int &num_components)\n{\n\tTIFF* tif = TIFFOpen(fn, \"r\");\n\n\tif(tif == NULL)\n\t{\n\t\tQString msg;\n\t\tmsg += \"ReadFrameTIFF: Cannot open \";\n\t\tmsg += fn;\n\t\tmsg += \"\\n\";\n\t\tif(errno)\n\t\t\tmsg += strerror(errno);\n\t\tthrow AeoException(msg);\n\t}\n\n\tif(TIFFIsTiled(tif))\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Tiled TIFF not supported.\");\n\t}\n\n\tuint16 bitsPerSample[3];\n\tuint16 bitDepth;\n\tuint16 numChannels;\n\tuint32 imageHeight;\n\tuint32 imageWidth;\n\tuint16 planarConfig;\n\tuint16 sampleFormat(0);\n\tuint16 photometric;\n\n\tif(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &numChannels) != 1)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Invalid TIFF: no SAMPLESPERPIXEL tag\");\n\t}\n\n\tif(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric) != 1)\n\t\tphotometric = (numChannels==1)?PHOTOMETRIC_MINISBLACK:PHOTOMETRIC_RGB;\n\telse if(!(numChannels==1 ||\n\t\t\t(numChannels==3 && photometric == PHOTOMETRIC_RGB)))\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"TIF must be either RGB or grayscale.\");\n\t}\n\n\tif(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &imageWidth) != 1 ||\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imageHeight) != 1)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Invalid TIFF image size\");\n\t}\n\n\t// libtiff docs say this returns 1 value, but other sources say it\n\t// returns <numChannels> values, so just to be safe, we allow it to\n\t// return up to 3 values and just use the first one.\n\tif(TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, bitsPerSample) != 1)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Invalid TIFF: no bitsPerSample tag\");\n\t}\n\n\tbitDepth = bitsPerSample[0];\n\n\tif(bitDepth != 8 && bitDepth != 16)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"TIFF must be 8-bit or 16-bit unsigned int.\");\n\t}\n\n\tif(TIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planarConfig) != 1)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Invalid TIFF: no planarConfig tag\");\n\t}\n\n\tif(TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat) != 1)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Invalid TIFF: no sampleFormat (e.g., uint) tag.\");\n\t}\n\n\tif(sampleFormat != SAMPLEFORMAT_UINT)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"TIFF pixel datatype is not unsigned int.\");\n\t}\n\n\ttdata_t tbuf;\n\tuint32 row;\n\n\ttbuf = _TIFFmalloc(TIFFScanlineSize(tif));\n\tif((unsigned char *)tbuf == NULL)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Out of memory: TIFF scanline buffer.\");\n\t}\n\n\tif(buf == NULL)\n\t{\n\t\tbuf = new unsigned char[\n\t\t\t\timageWidth * imageHeight * numChannels * (bitDepth/8u)];\n\t\tif(buf==NULL)\n\t\t{\n\t\t\t_TIFFfree(tbuf);\n\t\t\tTIFFClose(tif);\n\t\t\tthrow AeoException(\"Out of memory: TIFF image buffer.\");\n\t\t}\n\t}\n\n\tswitch(planarConfig)\n\t{\n\tcase PLANARCONFIG_CONTIG:\n\t\tfor (row = 0; row < imageHeight; row++)\n\t\t{\n\t\t\tif(TIFFReadScanline(tif, tbuf, row) != 1)\n\t\t\t{\n\t\t\t\t_TIFFfree(tbuf);\n\t\t\t\tTIFFClose(tif);\n\t\t\t\tthrow AeoException(\"TIFF I/O Error.\");\n\t\t\t}\n\t\t\tmemcpy(buf+row*imageWidth*numChannels*(bitDepth/8u), tbuf,\n\t\t\t\t\timageWidth*numChannels*(bitDepth/8u));\n\t\t}\n\t\tbreak;\n\tcase PLANARCONFIG_SEPARATE:\n\t\tuint16 s, col;\n\n\t\tfor (s = 0; s < numChannels; s++)\n\t\t{\n\t\t\tfor (row = 0; row < imageHeight; row++)\n\t\t\t{\n\t\t\t\tif(TIFFReadScanline(tif, tbuf, row, s) != 1)\n\t\t\t\t{\n\t\t\t\t\t_TIFFfree(tbuf);\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\tthrow AeoException(\"TIFF I/O Error.\");\n\t\t\t\t}\n\t\t\t\tfor(col = 0; col < imageWidth; col++)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(buf+(bitDepth/8u)*(s+numChannels*(col+imageWidth)),\n\t\t\t\t\t\t\ttbuf, (bitDepth/8u));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t_TIFFfree(tbuf);\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Invalid Planar Config in TIFF.\");\n\t}\n\n\t_TIFFfree(tbuf);\n\tTIFFClose(tif);\n\n\twidth = imageWidth;\n\theight = imageHeight;\n\tnum_components = numChannels;\n\n\tif(bitDepth==8) pix_fmt = GL_UNSIGNED_BYTE;\n\telse pix_fmt = GL_UNSIGNED_SHORT;\n\n\tendian = false; // libtiff automatically converts to native endianness\n\n\treturn buf;\n}",
    "bool\ntiffns::tiff_to_png(const char *tiffname, FILE *pngfp)\n{\n    bool bigendian = test_bigendian();\n\n    TIFF *tif = TIFFOpen(tiffname, \"r\");\n    if (!tif) {\n        err_printf(\"Failed to open %s.\", tiffname);\n        return (false);\n    }\n\n    png_struct *png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,\n        &jmpbuf_struct, error_handler, 0);\n    if (!png_ptr) {\n        TIFFClose(tif);\n        return (false);\n    }\n\n    png_info *info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        png_destroy_write_struct(&png_ptr, 0);\n        TIFFClose(tif);\n        return (false);\n    }\n\n    if (setjmp(jmpbuf_struct.jmpbuf)) {\n        png_destroy_write_struct(&png_ptr, 0);\n        TIFFClose(tif);\n        return (false);\n    }\n\n    png_init_io(png_ptr, pngfp);\n\n#ifdef DEBUG\n    if (verbose) {\n        int byteswapped = TIFFIsByteSwapped(tif);\n\n        fprintf(stderr, \"tiff_to_png:  \");\n        TIFFPrintDirectory(tif, stderr, TIFFPRINT_NONE);\n        fprintf(stderr, \"tiff_to_png:  byte order = %s\\n\",\n            ((bigendian && byteswapped) || (!bigendian && !byteswapped))?\n            \"little-endian (Intel)\" : \"big-endian (Motorola)\");\n        fprintf(stderr, \"tiff_to_png:  this machine is %s-endian\\n\",\n            bigendian? \"big\" : \"little\");\n    }\n#endif\n\n    unsigned short photometric;\n    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric)) {\n        err_printf(\"TIFF photometric could not be retrieved (%s)\", tiffname);\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        TIFFClose(tif);\n        return (false);\n    }\n    unsigned short bps;\n    if (!TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps))\n        bps = 1;\n    unsigned short spp;\n    if (!TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp))\n        spp = 1;\n    unsigned short planar;\n    if (!TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planar))\n        planar = 1;\n\n    unsigned short tiled = TIFFIsTiled(tif);\n\n    int cols, rows;\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cols);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &rows);\n    png_uint_32 width = cols;\n\n    bool have_res = false;\n    float xres, yres;\n    png_uint_32 res_x=0, res_y=0;\n    int unit_type = 0;\n    if (TIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres) &&\n            TIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres) && \n            (xres != 0.0) && (yres != 0.0)) {\n        uint16_t resunit;\n        have_res = true;\n#ifdef DEBUG\n        if (verbose) {\n            float ratio = xres / yres;\n            fprintf(stderr,\n                \"tiff_to_png:  aspect ratio (hor/vert) = %g (%g / %g)\\n\",\n                ratio, xres, yres);\n            if (0.95 < ratio && ratio < 1.05)\n                fprintf(stderr, \"tiff2png:  near-unity aspect ratio\\n\");\n            else if (1.90 < ratio && ratio < 2.10)\n                fprintf(stderr, \"tiff2png:  near-2X aspect ratio\\n\");\n            else\n                fprintf(stderr, \"tiff2png:  non-square, non-2X pixels\\n\");\n        }\n#endif\n\n        if (!TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, &resunit))\n            resunit = RESUNIT_INCH;\n\n        // Convert from TIFF data (floats) to PNG data (unsigned longs).\n        switch (resunit) {\n        case RESUNIT_CENTIMETER:\n            res_x = (png_uint_32)(100.0*xres + 0.5);\n            res_y = (png_uint_32)(100.0*yres + 0.5);\n            unit_type = PNG_RESOLUTION_METER;\n            break;\n        case RESUNIT_INCH:\n            res_x = (png_uint_32)(39.37*xres + 0.5);\n            res_y = (png_uint_32)(39.37*yres + 0.5);\n            unit_type = PNG_RESOLUTION_METER;\n            break;\n        case RESUNIT_NONE:\n        default:\n            res_x = (png_uint_32)(100.0*xres + 0.5);\n            res_y = (png_uint_32)(100.0*yres + 0.5);\n            unit_type = PNG_RESOLUTION_UNKNOWN;\n            break;\n        }\n    }\n\n#ifdef DEBUG\n    if (verbose) {\n        fprintf(stderr, \"tiff_to_png:  %dx%dx%d image\\n\", cols, rows,\n            bps * spp);\n        fprintf(stderr, \"tiff_to_png:  %d bit%s/sample, %d sample%s/pixel\\n\",\n            bps, bps == 1? \"\" : \"s\", spp, spp == 1? \"\" : \"s\");\n    }\n#endif\n\n    // Detect tiff filetype.\n\n    int maxval = (1 << bps) - 1;\n#ifdef DEBUG\n    if (verbose)\n        fprintf(stderr, \"tiff_to_png:  maxval=%d\\n\", maxval);\n#endif\n\n    int color_type = -1;\n    int bit_depth = 0;\n    int colors = 0;\n    png_color palette[MAXCOLORS];\n    unsigned short tiff_compression_method;\n\n    switch (photometric) {\n    case PHOTOMETRIC_MINISWHITE:\n    case PHOTOMETRIC_MINISBLACK:\n#ifdef DEBUG\n        if (verbose) {\n            fprintf(stderr,\n                \"tiff_to_png:  %d graylevels (min = %s)\\n\", maxval + 1,\n                photometric == PHOTOMETRIC_MINISBLACK? \"black\" : \"white\");\n        }\n#endif\n        if (spp == 1) {\n            // no alpha\n            color_type = PNG_COLOR_TYPE_GRAY;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr, \"tiff_to_png:  color type = grayscale\\n\");\n#endif\n            bit_depth = bps;\n        }\n        else {\n            // must be alpha\n            color_type = PNG_COLOR_TYPE_GRAY_ALPHA;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr,\n                    \"tiff_to_png:  color type = grayscale + alpha\\n\");\n#endif\n            if (bps <= 8)\n                bit_depth = 8;\n            else\n                bit_depth = bps;\n        }\n        break;\n\n    case PHOTOMETRIC_PALETTE:\n        {\n            int palette_8bit; // Set iff all color values in TIFF palette\n                              // are < 256.\n\n            color_type = PNG_COLOR_TYPE_PALETTE;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr, \"tiff_to_png:  color type = paletted\\n\");\n#endif\n\n            unsigned short *redcolormap;\n            unsigned short *greencolormap;\n            unsigned short *bluecolormap;\n            if (!TIFFGetField(tif, TIFFTAG_COLORMAP, &redcolormap,\n                    &greencolormap, &bluecolormap)) {\n                err_printf(\"Cannot retrieve TIFF colormaps (%s)\\n\", tiffname);\n                png_destroy_write_struct(&png_ptr, &info_ptr);\n                TIFFClose(tif);\n                return (false);\n            }\n            colors = maxval + 1;\n            if (colors > MAXCOLORS) {\n                err_printf(\"Palette too large (%d colors) (%s)\\n\",\n                    colors, tiffname);\n                png_destroy_write_struct(&png_ptr, &info_ptr);\n                TIFFClose(tif);\n                return (false);\n            }\n            // Max PNG palette-size is 8 bits, you could convert to\n            // full-color.\n            if (bps >= 8) \n                bit_depth = 8;\n            else\n                bit_depth = bps;\n\n            // PLTE chunk\n            // TIFF palettes contain 16-bit shorts, while PNG palettes\n            // are 8-bit.  Some broken (??) software puts 8-bit values\n            // in the shorts, which would make the palette come out\n            // all zeros, which isn't good.  We check...\n\n            palette_8bit = 1;\n            for (int i = 0 ; i < colors ; i++) {\n                if (redcolormap[i] > 255 || greencolormap[i] > 255 ||\n                         bluecolormap[i] > 255) {\n                     palette_8bit = 0;\n                     break;\n                }\n            } \n#ifdef DEBUG\n            if (palette_8bit && verbose)\n                fprintf(stderr,\n                    \"tiff_to_png warning:  assuming 8-bit palette values.\\n\");\n#endif\n\n            for (int i = 0 ; i < colors ; i++) {\n                if (palette_8bit) {\n                    palette[i].red   = (png_byte)redcolormap[i];\n                    palette[i].green = (png_byte)greencolormap[i];\n                    palette[i].blue  = (png_byte)bluecolormap[i];\n                }\n                else {\n                    palette[i].red   = (png_byte)(redcolormap[i] >> 8);\n                    palette[i].green = (png_byte)(greencolormap[i] >> 8);\n                    palette[i].blue  = (png_byte)(bluecolormap[i] >> 8);\n                }\n            }\n            break;\n        }\n\n    case PHOTOMETRIC_YCBCR:\n        TIFFGetField(tif, TIFFTAG_COMPRESSION, &tiff_compression_method);\n        if (tiff_compression_method == COMPRESSION_JPEG &&\n                planar == PLANARCONFIG_CONTIG) {\n            // Can rely on libjpeg to convert to RGB.\n            TIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n            photometric = PHOTOMETRIC_RGB;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr, \"tiff2png:  original color type = YCbCr \"\n                    \"with JPEG compression.\\n\");\n#endif\n        }\n        else {\n            err_printf(\n                \"Don't know how to handle PHOTOMETRIC_YCBCR with \"\n                \"compression %d\\n\"\n                \"  (%sJPEG) and planar config %d (%scontiguous)\\n\"\n                \"  (%s)\\n\", tiff_compression_method,\n                tiff_compression_method == COMPRESSION_JPEG? \"\" : \"not \",\n                planar, planar == PLANARCONFIG_CONTIG? \"\" : \"not \", tiffname);\n            png_destroy_write_struct(&png_ptr, &info_ptr);\n            TIFFClose(tif);\n            return (false);\n        }\n        // fall thru... \n\n    case PHOTOMETRIC_RGB:\n        if (spp == 3) {\n            color_type = PNG_COLOR_TYPE_RGB;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr, \"tiff_to_png:  color type = truecolor\\n\");\n#endif\n        }\n        else {\n            color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr,\n                    \"tiff_to_png:  color type = truecolor + alpha\\n\");\n#endif\n        }\n        if (bps <= 8)\n            bit_depth = 8;\n        else\n            bit_depth = bps;\n        break;\n\n    case PHOTOMETRIC_LOGL:\n    case PHOTOMETRIC_LOGLUV:\n        TIFFGetField(tif, TIFFTAG_COMPRESSION, &tiff_compression_method);\n        if (tiff_compression_method != COMPRESSION_SGILOG &&\n                tiff_compression_method != COMPRESSION_SGILOG24) {\n            err_printf(\"Don't know how to handle PHOTOMETRIC_LOGL%s with\\n\"\n                \"  compression %d (not SGILOG) (%s)\\n\",\n                photometric == PHOTOMETRIC_LOGLUV? \"UV\" : \"\",\n                tiff_compression_method, tiffname);\n            png_destroy_write_struct(&png_ptr, &info_ptr);\n            TIFFClose(tif);\n            return (false);\n        }\n        // rely on library to convert to RGB/greyscale.\n#ifdef LIBTIFF_HAS_16BIT_INTEGER_FORMAT\n        if (bps > 8) {\n            // SGILOGDATAFMT_16BIT converts to a floating-point\n            // luminance value; U,V are left as such. \n            // SGILOGDATAFMT_16BIT_INT doesn't exist.\n\n            TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_16BIT_INT);\n            bit_depth = bps = 16;\n        }\n        else\n#endif\n        {\n            // SGILOGDATAFMT_8BIT converts to normal grayscale or RGB format.\n            TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n            bit_depth = bps = 8;\n        }\n        if (photometric == PHOTOMETRIC_LOGL) {\n            photometric = PHOTOMETRIC_MINISBLACK;\n            color_type = PNG_COLOR_TYPE_GRAY;\n#ifdef DEBUG\n            if (verbose) {\n                fprintf(stderr, \"tiff_to_png:  original color type = \"\n                    \"logL with SGILOG compression.\\n\");\n                fprintf(stderr, \"tiff_to_png:  color type = grayscale.\\n\");\n            }\n#endif\n        }\n        else {\n            photometric = PHOTOMETRIC_RGB;\n            color_type = PNG_COLOR_TYPE_RGB;\n#ifdef DEBUG\n            if (verbose) {\n                fprintf(stderr, \"tiff_to_png:  original color type = \"\n                    \"logLUV with SGILOG compression.\\n\");\n                fprintf(stderr, \"tiff_to_png:  color type = truecolor.\\n\");\n            }\n#endif\n        }\n        break;\n\n    case PHOTOMETRIC_MASK:\n    case PHOTOMETRIC_SEPARATED:\n    case PHOTOMETRIC_CIELAB:\n    case PHOTOMETRIC_DEPTH:\n        err_printf(\"Don't know how to handle %s (%s)\\n\",\n            photometric == PHOTOMETRIC_MASK?      \"PHOTOMETRIC_MASK\" :\n            photometric == PHOTOMETRIC_SEPARATED? \"PHOTOMETRIC_SEPARATED\" :\n            photometric == PHOTOMETRIC_CIELAB?    \"PHOTOMETRIC_CIELAB\" :\n            photometric == PHOTOMETRIC_DEPTH?     \"PHOTOMETRIC_DEPTH\" :\n                                                  \"unknown photometric\",\n            tiffname);\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        TIFFClose(tif);\n        return (false);\n\n    default:\n        err_printf(\"Unknown photometric (%d) (%s)\\n\",\n            photometric, tiffname);\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        TIFFClose(tif);\n        return (false);\n    }\n    int tiff_color_type = color_type;\n\n#ifdef DEBUG\n    if (verbose)\n        fprintf(stderr, \"tiff_to_png:  bit depth = %d\\n\", bit_depth);\n#endif\n\n    // Put parameter info in png-chunks.\n\n    png_set_IHDR(png_ptr, info_ptr, width, rows, bit_depth, color_type,\n        PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT,\n        PNG_FILTER_TYPE_DEFAULT);\n\n//    if (png_compression_level != -1)\n//        png_set_compression_level(png_ptr, png_compression_level);\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE)\n        png_set_PLTE(png_ptr, info_ptr, palette, colors);\n\n    // gAMA chunk\n//    if (gamma != -1.0) {\n#ifdef DEBUG\n//        if (verbose)\n//            fprintf(stderr, \"tiff_to_png:  gamma = %f\\n\", gamma);\n#endif\n//        png_set_gAMA(png_ptr, info_ptr, gamma);\n//    }\n\n    // pHYs chunk\n    if (have_res)\n        png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);\n\n    png_write_info(png_ptr, info_ptr);\n    png_set_packing(png_ptr);\n\n    // Allocate space for one line (or row of tiles) of TIFF image.\n\n    unsigned char *tiffline = 0;\n    unsigned char *tifftile = 0;\n    unsigned char *tiffstrip = 0;\n    size_t tilesz = 0L;\n    int num_tilesX = 0;\n    uint32_t tile_width = 0, tile_height = 0;\n\n    if (!tiled) {\n        // strip-based TIFF\n        if (planar == 1) {\n            // contiguous picture\n            tiffline = (unsigned char*)malloc(TIFFScanlineSize(tif));\n        }\n        else {\n            // separated planes\n            tiffline = (unsigned char*)malloc(TIFFScanlineSize(tif) * spp);\n        }\n    }\n    else {\n        // Allocate space for one \"row\" of tiles.\n\n        TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width);\n        TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height);\n\n        num_tilesX = (width+tile_width-1)/tile_width;\n\n        if (planar == 1) {\n            tilesz = TIFFTileSize(tif);\n            tifftile = new unsigned char[tilesz];\n            size_t stripsz = (tile_width*num_tilesX) * tile_height * spp;\n            tiffstrip = new unsigned char[stripsz];\n            tiffline = tiffstrip;\n            // Just set the line to the top of the strip, we'll move it\n            // through below.\n        }\n        else {\n            err_printf(\n                \"Can't handle tiled separated-plane TIFF format (%s).\\n\",\n                tiffname);\n            png_destroy_write_struct (&png_ptr, &info_ptr);\n            TIFFClose(tif);\n            return (false);\n        }\n    }\n\n    if (!tiffline) {\n        err_printf(\"Can't allocate memory for TIFF scanline buffer (%s).\\n\",\n            tiffname);\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        TIFFClose(tif);\n        if (tiled && planar == 1)\n            delete [] tifftile;\n        return (false);\n    }\n\n    if (planar != 1) {\n        // In case we must combine more planes into one.\n        tiffstrip = new unsigned char[TIFFScanlineSize(tif)];\n        if (!tiffstrip) {\n            err_printf(\"Can't allocate memory for TIFF strip buffer (%s).\\n\",\n                tiffname);\n            png_destroy_write_struct(&png_ptr, &info_ptr);\n            TIFFClose(tif);\n            free(tiffline);\n            return (false);\n        }\n    }\n\n    // Allocate space for one line of PNG image.\n    // max: 3 color channels plus one alpha channel, 16 bit => 8 bytes/pixel\n\n    png_byte *pngline = new unsigned char[cols * 8];\n    for (int pass = 0 ; pass < png_set_interlace_handling(png_ptr); pass++) {\n        for (int row = 0; row < rows; row++) {\n            if (planar == 1) {\n                // contiguous picture\n                if (!tiled) {\n                    if (TIFFReadScanline(tif, tiffline, row, 0) < 0) {\n                        err_printf(\"Bad data read on line %d (%s).\\n\",\n                            row, tiffname);\n                        png_destroy_write_struct(&png_ptr, &info_ptr);\n                        TIFFClose(tif);\n                        free(tiffline);\n                        return (false);\n                    }\n                }\n                else {\n                    // tiled\n                    int col, ok=1, r;\n                    int tileno;\n                    // Read in one row of tiles and hand out the data\n                    // one scanline at a time so the code below\n                    // doesn't need to change.\n\n                    // Is it time for a new strip?\n                    if ((row % tile_height) == 0) {\n                        for (col = 0; ok && col < num_tilesX; col += 1 ) {\n                            tileno = col+(row/tile_height)*num_tilesX;\n                            // Read the tile into an RGB array.\n                            if (!TIFFReadEncodedTile(tif, tileno, tifftile,\n                                    tilesz)) {\n                                ok = 0;\n                                break;\n                            }\n\n                            // Copy this tile into the row buffer.\n                            for (r = 0; r < (int) tile_height; r++) {\n                                void *dest = tiffstrip + (r * tile_width *\n                                    num_tilesX * spp) +\n                                    (col * tile_width * spp);\n                                void *src  = tifftile + (r * tile_width * spp);\n                                memcpy(dest, src, (tile_width * spp));\n                            }\n                        }\n                        tiffline = tiffstrip; // Set tileline to top of strip.\n                    }\n                    else {\n                        tiffline = tiffstrip + ((row % tile_height) *\n                            ((tile_width * num_tilesX) * spp));\n                    }\n                }\n            }\n            else {\n                // Separated planes, then combine more strips into one line.\n                unsigned short s;\n\n                // XXX:  this assumes strips; are separated-plane\n                // tiles possible?\n\n                unsigned char *p_line = tiffline;\n                for (int n = 0; n < (cols/8 * bps*spp); n++)\n                    *p_line++ = '\\0';\n\n                for (s = 0; s < spp; s++) {\n                    unsigned char *p_strip = tiffstrip;\n                    int getbitsleft = 8;\n                    p_line = tiffline;\n                    int putbitsleft = 8;\n\n                    if (TIFFReadScanline(tif, tiffstrip, row, s) < 0) {\n                        err_printf(\"Bad data read on line %d (%s).\\n\",\n                            row, tiffname);\n                        png_destroy_write_struct(&png_ptr, &info_ptr);\n                        TIFFClose(tif);\n                        delete [] tiffline;\n                        delete [] tiffstrip;\n                        return (false);\n                    }\n\n                    p_strip = (unsigned char *)tiffstrip;\n                    unsigned char sample = '\\0';\n                    for (int i = 0 ; i < s ; i++)\n                        PUT_LINE_SAMPLE\n                    for (int n = 0; n < cols; n++) {\n                        GET_STRIP_SAMPLE\n                        PUT_LINE_SAMPLE\n                        sample = '\\0';\n                        for (int i = 0 ; i < (spp-1) ; i++)\n                            PUT_LINE_SAMPLE\n                    }\n                }\n            }\n\n            unsigned char *p_line = tiffline;\n            int bitsleft = 8;\n            png_byte *p_png = pngline;\n\n            // Convert from tiff-line to png-line.\n\n            switch (tiff_color_type) {\n            case PNG_COLOR_TYPE_GRAY:       // we know spp == 1\n                for (int col = cols; col > 0; --col) {\n                    switch (bps) {\n                    case 16:\n#ifdef INVERT_MINISWHITE\n                        if (photometric == PHOTOMETRIC_MINISWHITE) {\n                            unsigned char sample;\n                            int sample16;\n                            if (bigendian) {\n                                // same as PNG order\n                                GET_LINE_SAMPLE\n                                sample16 = sample;\n                                sample16 <<= 8;\n                                GET_LINE_SAMPLE\n                                sample16 |= sample;\n                            }\n                            else {\n                                // reverse of PNG\n                                GET_LINE_SAMPLE\n                                sample16 = sample;\n                                GET_LINE_SAMPLE\n                                sample16 |= (((int)sample) << 8);\n                            }\n                            sample16 = maxval - sample16;\n                            *p_png++ = (unsigned char)((sample16 >> 8) & 0xff);\n                            *p_png++ = (unsigned char)(sample16 & 0xff);\n                        }\n                        else // not PHOTOMETRIC_MINISWHITE\n#endif\n                        {\n                            unsigned char sample;\n                            if (bigendian) {\n                                GET_LINE_SAMPLE\n                                *p_png++ = sample;\n                                GET_LINE_SAMPLE\n                                *p_png++ = sample;\n                            }\n                            else {\n                                GET_LINE_SAMPLE\n                                p_png[1] = sample;\n                                GET_LINE_SAMPLE\n                                *p_png = sample;\n                                p_png += 2;\n                            }\n                        }\n                        break;\n\n                    case 8:\n                    case 4:\n                    case 2:\n                    case 1:\n                        {\n                            unsigned char sample;\n                            GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                            if (photometric == PHOTOMETRIC_MINISWHITE)\n                                sample = maxval - sample;\n#endif\n                            *p_png++ = sample;\n                        }\n                        break;\n\n                    }\n                }\n                break;\n\n            case PNG_COLOR_TYPE_GRAY_ALPHA:\n                for (int col = 0; col < cols; col++) {\n                    for (int i = 0 ; i < spp ; i++) {\n                        switch (bps) {\n                        case 16:\n#ifdef INVERT_MINISWHITE\n                            if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                    i == 0) {\n                                unsigned char sample;\n                                int sample16;\n                                if (bigendian) {\n                                    GET_LINE_SAMPLE\n                                    sample16 = (sample << 8);\n                                    GET_LINE_SAMPLE\n                                    sample16 |= sample;\n                                }\n                                else {\n                                    GET_LINE_SAMPLE\n                                    sample16 = sample;\n                                    GET_LINE_SAMPLE\n                                    sample16 |= (((int)sample) << 8);\n                                }\n                                sample16 = maxval - sample16;\n                                *p_png++ = (unsigned char)(\n                                    (sample16 >> 8) & 0xff);\n                                *p_png++ = (unsigned char)(sample16 & 0xff);\n                            }\n                            else\n#endif\n                            {\n                                unsigned char sample;\n                                if (bigendian) {\n                                    GET_LINE_SAMPLE\n                                    *p_png++ = sample;\n                                    GET_LINE_SAMPLE\n                                    *p_png++ = sample;\n                                }\n                                else {\n                                    GET_LINE_SAMPLE\n                                    p_png[1] = sample;\n                                    GET_LINE_SAMPLE\n                                    *p_png = sample;\n                                    p_png += 2;\n                                }\n                            }\n                            break;\n\n                        case 8:\n                            {\n                                unsigned char sample;\n                                GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                                if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                        i == 0)\n                                    sample = maxval - sample;\n#endif\n                                *p_png++ = sample;\n                            }\n                            break;\n\n                        case 4:\n                            {\n                                unsigned char sample;\n                                GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                                if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                        i == 0)\n                                    sample = maxval - sample;\n#endif\n                                *p_png++ = sample * 17;   /* was 16 */\n                            }\n                            break;\n\n                        case 2:\n                            {\n                                unsigned char sample;\n                                GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                                if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                        i == 0)\n                                    sample = maxval - sample;\n#endif\n                                *p_png++ = sample * 85;   /* was 64 */\n                            }\n                            break;\n\n                        case 1:\n                            {\n                                unsigned char sample;\n                                GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                                if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                        i == 0)\n                                    sample = maxval - sample;\n#endif\n                                *p_png++ = sample * 255;  /* was 128...oops */\n                            }\n                            break;\n\n                        }\n                    }\n                }\n                break;\n\n            case PNG_COLOR_TYPE_RGB:\n            case PNG_COLOR_TYPE_RGB_ALPHA:\n                for (int col = 0; col < cols; col++) {\n                    // Process for red, green and blue (and when\n                    // applicable alpha).\n\n                    for (int i = 0 ; i < spp ; i++) {\n                        switch (bps) {\n                        case 16:\n                            // XXX:  do we need INVERT_MINISWHITE\n                            // support here, too, or is that only for\n                            // grayscale?\n\n                            unsigned char sample;\n                            if (bigendian) {\n                                GET_LINE_SAMPLE\n                                *p_png++ = sample;\n                                GET_LINE_SAMPLE\n                                *p_png++ = sample;\n                            }\n                            else {\n                                GET_LINE_SAMPLE\n                                p_png[1] = sample;\n                                GET_LINE_SAMPLE\n                                *p_png = sample;\n                                p_png += 2;\n                            }\n                            break;\n\n                        case 8:\n                            GET_LINE_SAMPLE\n                            *p_png++ = sample;\n                            break;\n\n                        case 4:\n                            GET_LINE_SAMPLE\n                            *p_png++ = sample * 17;\n                            break;\n\n                        case 2:\n                            GET_LINE_SAMPLE\n                            *p_png++ = sample * 85;\n                            break;\n\n                        case 1:\n                            GET_LINE_SAMPLE\n                            *p_png++ = sample * 255;\n                           break;\n\n                        }\n                    }\n                }\n                break;\n  \n            case PNG_COLOR_TYPE_PALETTE:\n                for (int col = 0; col < cols; col++) {\n                    unsigned char sample;\n                    GET_LINE_SAMPLE\n                    *p_png++ = sample;\n                }\n                break;\n  \n            default:\n                err_printf(\"Unknown photometric (%d) (%s).\\n\",\n                    photometric, tiffname);\n                png_destroy_write_struct(&png_ptr, &info_ptr);\n                TIFFClose(tif);\n                delete [] tiffline;\n                if (tiled && planar == 1)\n                    delete [] tifftile;\n                else if (planar != 1)\n                    delete [] tiffstrip;\n                return (false);\n\n            }\n            png_write_row(png_ptr, pngline);\n        }\n    }\n\n    TIFFClose(tif);\n\n    png_write_end(png_ptr, info_ptr);\n\n    png_destroy_write_struct(&png_ptr, &info_ptr);\n\n    free(tiffline);\n    if (tiled && planar == 1)\n        delete [] tifftile;\n    else if (planar != 1)\n        delete [] tiffstrip;\n    return (true);\n}",
    "auto ReadHeader(lt::TIFF* tif)\n{\n    // Get metadata\n    TIFFHeader hdr;\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &hdr.width);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hdr.height);\n    TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &hdr.type);\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &hdr.depth);\n    TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &hdr.channels);\n    TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &hdr.config);\n    TIFFGetField(tif, TIFFTAG_COMPRESSION, &hdr.compression);\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &hdr.rowsPerStrip);\n    TIFFGetField(tif, TIFFTAG_STRIPOFFSETS, &hdr.stripOffsets);\n    hdr.bigEndian = lt::TIFFIsBigEndian(tif) != 0;\n    return hdr;\n}",
    "File(\n                    const std::string& fileName,\n                    const dtk::InMemoryFile* memory)\n                {\n                    if (memory)\n                    {\n                        _memory.p = memory->p;\n                        _memory.start = memory->p;\n                        _memory.end = memory->p + memory->size;\n                        _tiff.p = TIFFClientOpen(\n                            fileName.c_str(),\n                            \"r\",\n                            &_memory,\n                            tiffMemoryRead,\n                            tiffMemoryWrite,\n                            tiffMemorySeek,\n                            tiffMemoryClose,\n                            tiffMemorySize,\n                            nullptr,\n                            nullptr);\n                    }\n                    else\n                    {\n#if defined(_WINDOWS)\n                        _tiff.p = TIFFOpenW(dtk::toWide(fileName).c_str(), \"r\");\n#else // _WINDOWS\n                        _tiff.p = TIFFOpen(fileName.c_str(), \"r\");\n#endif // _WINDOWS\n                    }\n                    if (!_tiff.p)\n                    {\n                        throw std::runtime_error(dtk::Format(\"{0}: Cannot open\").arg(fileName));\n                    }\n\n                    uint32_t  tiffWidth = 0;\n                    uint32_t  tiffHeight = 0;\n                    uint16_t  tiffPhotometric = 0;\n                    uint16_t  tiffSamples = 0;\n                    uint16_t  tiffSampleDepth = 0;\n                    uint16_t  tiffSampleFormat = 0;\n                    uint16_t* tiffExtraSamples = nullptr;\n                    uint16_t  tiffExtraSamplesSize = 0;\n                    uint16_t  tiffOrient = 0;\n                    uint16_t  tiffCompression = 0;\n                    uint16_t  tiffPlanarConfig = 0;\n                    TIFFGetFieldDefaulted(_tiff.p, TIFFTAG_IMAGEWIDTH, &tiffWidth);\n                    TIFFGetFieldDefaulted(_tiff.p, TIFFTAG_IMAGELENGTH, &tiffHeight);\n                    TIFFGetFieldDefaulted(_tiff.p, TIFFTAG_PHOTOMETRIC, &tiffPhotometric);\n                    TIFFGetFieldDefaulted(_tiff.p, TIFFTAG_SAMPLESPERPIXEL, &tiffSamples);\n                    TIFFGetFieldDefaulted(_tiff.p, TIFFTAG_BITSPERSAMPLE, &tiffSampleDepth);\n                    TIFFGetFieldDefaulted(_tiff.p, TIFFTAG_SAMPLEFORMAT, &tiffSampleFormat);\n                    TIFFGetFieldDefaulted(_tiff.p, TIFFTAG_EXTRASAMPLES, &tiffExtraSamplesSize, &tiffExtraSamples);\n                    TIFFGetFieldDefaulted(_tiff.p, TIFFTAG_ORIENTATION, &tiffOrient);\n                    TIFFGetFieldDefaulted(_tiff.p, TIFFTAG_COMPRESSION, &tiffCompression);\n                    TIFFGetFieldDefaulted(_tiff.p, TIFFTAG_PLANARCONFIG, &tiffPlanarConfig);\n                    _planar = PLANARCONFIG_SEPARATE == tiffPlanarConfig;\n                    _samples = tiffSamples;\n                    _sampleDepth = tiffSampleDepth;\n                    _scanlineSize = tiffWidth * tiffSamples * tiffSampleDepth / 8;\n\n                    dtk::ImageType pixelType = dtk::ImageType::None;\n                    switch (tiffPhotometric)\n                    {\n                    case PHOTOMETRIC_MINISWHITE:\n                    case PHOTOMETRIC_MINISBLACK:\n                    case PHOTOMETRIC_RGB:\n                        if (32 == tiffSampleDepth && tiffSampleFormat != SAMPLEFORMAT_IEEEFP)\n                            break;\n                        if (SAMPLEFORMAT_IEEEFP == tiffSampleFormat)\n                        {\n                            pixelType = io::getFloatType(tiffSamples, tiffSampleDepth);\n                        }\n                        else\n                        {\n                            pixelType = io::getIntType(tiffSamples, tiffSampleDepth);\n                        }\n                        break;\n                    }\n                    if (dtk::ImageType::None == pixelType)\n                    {\n                        throw std::runtime_error(dtk::Format(\"{0}: Cannot open\").arg(fileName));\n                    }\n\n                    dtk::ImageInfo imageInfo(tiffWidth, tiffHeight, pixelType);\n                    imageInfo.layout.mirror.y = true;\n                    _info.video.push_back(imageInfo);\n\n                    char* tag = 0;\n                    if (TIFFGetField(_tiff.p, TIFFTAG_ARTIST, &tag))\n                    {\n                        if (tag)\n                        {\n                            _info.tags[\"Creator\"] = tag;\n                        }\n                    }\n                    if (TIFFGetField(_tiff.p, TIFFTAG_IMAGEDESCRIPTION, &tag))\n                    {\n                        if (tag)\n                        {\n                            _info.tags[\"Description\"] = tag;\n                        }\n                    }\n                    if (TIFFGetField(_tiff.p, TIFFTAG_COPYRIGHT, &tag))\n                    {\n                        if (tag)\n                        {\n                            _info.tags[\"Copyright\"] = tag;\n                        }\n                    }\n                    if (TIFFGetField(_tiff.p, TIFFTAG_DATETIME, &tag))\n                    {\n                        if (tag)\n                        {\n                            _info.tags[\"Time\"] = tag;\n                        }\n                    }\n                }",
    "HANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}",
    "void LibTiffReader::open(std::string filename) {\n    if(this->_is_open)\n        this->recycle();\n\n    this->_tiff = TIFFOpen(filename.c_str(), \"r\");\n    if(! this->_tiff)\n        throw std::runtime_error(\"[LibTiffReader] Failed to access file: \" + filename);\n    this->_is_open = true;\n\n    uint16_t channels, depth;\n    TIFFGetField(this->_tiff, TIFFTAG_IMAGEWIDTH, &(this->_width));\n    TIFFGetField(this->_tiff, TIFFTAG_IMAGELENGTH, &(this->_height));\n    TIFFGetField(this->_tiff, TIFFTAG_SAMPLESPERPIXEL, &channels);\n    TIFFGetField(this->_tiff, TIFFTAG_BITSPERSAMPLE, &depth);\n    this->_channels = channels;\n    this->_depth = depth;\n\n    if(channels == 1) {\n        uint16_t planar_config = 0xffff;\n        TIFFGetField(this->_tiff, TIFFTAG_PLANARCONFIG, &planar_config);\n        if(planar_config != PLANARCONFIG_CONTIG)\n            throw std::runtime_error(\"[LibTiffReader] Only 'Chunky' planar config format is supported: \" + filename);\n    }\n\n    if( \n        _width <= 0 ||\n        _height <= 0 ||\n        _channels <= 0 ||\n        !(_depth == 8 || _depth == 16)\n    ) {\n        this->recycle();\n        throw std::runtime_error(\"[LibTiffReader] Invalid image dimensions.\");\n    }\n}",
    "cv::Mat LibTiffReader::getCrop(uint32_t left, uint32_t top, uint32_t w, uint32_t h) {\n    if( ! this->_is_open )\n        throw std::runtime_error(\"[LibTiffReader] No file opened.\");\n\n    int right = left + w;\n    int bottom = top + h;\n\n    bool lt_valid = (left >= 0) && (top >= 0) && (left < _width) && (top < _height);\n    bool rb_valid = (right > 0) && (bottom > 0) && (right <= _width) && (bottom <= _height);\n    if( ! (lt_valid && rb_valid) )\n        throw std::runtime_error(\"[LibTiffReader] Invalid coordinates.\");\n\n    int sample_byte_size = this->_depth / 8;\n\n    int cv_depth = this->getCVMatType();\n    cv::Mat cropped(h, w, CV_MAKETYPE(cv_depth, _channels));\n\n\n    uint32_t rows_per_strip = 0;\n    TIFFGetField(this->_tiff, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);\n    if(rows_per_strip != 1)\n        throw std::runtime_error(\"[LibTiffReader] This tiff was not saved with one row per strip.\");\n\n\n    uint32_t strip_size = TIFFStripSize(this->_tiff);\n    if(strip_size != _width * _channels * sample_byte_size)\n        throw std::runtime_error(\"[LibTiffReader] Initial strip size assumption failed.\");\n\n\n\tvoid* row_data = _TIFFmalloc(strip_size);\n    if( ! row_data )\n        throw std::runtime_error(\"[LibTiffReader] Memory error.\");\n\n\n\tuint32_t row_index;\n\tuint32_t row_size;\n    uint32_t total_strips = TIFFNumberOfStrips(this->_tiff);\n    if( total_strips != this->_height)\n        throw std::runtime_error(\"[LibTiffReader] Strip count assumption failed.\");\n\n\n    void* crop_row = (char*)row_data + (left * _channels * sample_byte_size);\n    int crop_row_size = w * _channels * sample_byte_size;\n    void* mat_row = cropped.data;\n\tfor (row_index = top; row_index < bottom; row_index++) {\n\n\t\trow_size = TIFFReadEncodedStrip(this->_tiff, row_index, row_data, strip_size);\n\n        if(row_size != strip_size) {\n            _TIFFfree(row_data);\n            if(row_size < 0)\n                throw std::runtime_error(\"[LibTiffReader] Failed to get row #\" + std::to_string(row_index));\n            else\n                throw std::runtime_error(\"[LibTiffReader] Actual strip size assumption failed.\");\n        }\n\n        memcpy(mat_row, crop_row, crop_row_size);\n        mat_row = (char*)mat_row + crop_row_size;\n    }\n\n\t_TIFFfree(row_data);\n\n    return cropped;\n}",
    "std::string LibTiffReader::getColorSpaceString() {\n    if( ! this->_is_open )\n        throw std::runtime_error(\"[LibTiffReader] No file opened.\");\n\n    char* artist_tag = 0;\n    TIFFGetField(this->_tiff, TIFFTAG_ARTIST, &artist_tag);\n    if(!artist_tag)\n        throw std::runtime_error(\"[LibTiffReader] Matrix does not exist.\");\n\n    std::string space;\n    try {\n        jsoncons::json custom_tag = jsoncons::json::parse(artist_tag);\n        space = custom_tag[\"ColorSpace\"].as<std::string>();\n    }\n    catch (const std::exception& e) {\n        throw std::runtime_error(\"[LibTiffReader] \"\n            + std::string(e.what()) + \" Invalid BTRGB Artist tag.\\n\");\n    }\n\n    return space;\n}",
    "cv::Mat LibTiffReader::getConversionMatrix(std::string key) {\n    if( ! this->_is_open )\n        throw std::runtime_error(\"[LibTiffReader] No file opened.\");\n\n    char* artist_tag;\n    if( ! TIFFGetField(this->_tiff, TIFFTAG_ARTIST, &artist_tag) )\n        throw std::runtime_error(\"[LibTiffReader] Image does not have artist tag.\");\n\n    cv::Mat m;\n\n    try {\n        jsoncons::json custom_tag = jsoncons::json::parse(artist_tag);\n        m = this->_extractMat(custom_tag[key]);\n    }\n    catch (const std::exception& e) {\n        throw std::runtime_error(\"[LibTiffReader] \"\n            + std::string(e.what()) + \" Invalid BTRGB Artist tag.\\n\");\n    }\n\n    return m;\n}",
    "std::unordered_map<std::string, cv::Mat> LibTiffReader::getConversionMatrices() {\n    if( ! this->_is_open )\n        throw std::runtime_error(\"[LibTiffReader] No file opened.\");\n\n    std::unordered_map<std::string, cv::Mat> matrices;\n\n    char* artist_tag;\n    if( ! TIFFGetField(this->_tiff, TIFFTAG_ARTIST, &artist_tag) )\n        throw std::runtime_error(\"[LibTiffReader] Image does not have artist tag.\");\n\n    try {\n        jsoncons::json custom_tag = jsoncons::json::parse(artist_tag);\n        for (const auto& tagged_item: custom_tag.object_range()) {\n            auto tag = tagged_item.value();\n            auto name = tagged_item.key();\n\n            if(!tag.is_object() || !tag.contains(\"cv_type\"))\n                continue;\n\n            if(matrices.contains(name))\n                continue;\n\n            matrices[name] = this->_extractMat(tag);\n        }\n\n    }\n    catch (const std::exception& e) {\n        throw std::runtime_error(\"[LibTiffReader] \"\n            + std::string(e.what()) + \" Invalid BTRGB Artist tag.\\n\");\n    }\n\n    return matrices;\n}",
    "void LibTiffReader::getColorProfile(uint32_t* size, void** data) {\n    if( ! this->_is_open )\n        throw std::runtime_error(\"[LibTiffReader] No file opened.\");\n\n    if( ! TIFFGetField(this->_tiff, TIFFTAG_ICCPROFILE, size, data) )\n        throw std::runtime_error(\"[LibTiffReader] File does not have color profile.\");\n}",
    "void TiffIO::init()\n{\n\tENTERFUNC;\n\tif (initialized) {\n\t\treturn;\n\t}\n\tinitialized = true;\n\n\tbool is_new_file = false;\n\tFILE *tmp_in = sfopen(filename, rw_mode, &is_new_file, true);\n\tif (!tmp_in) {\n\t\tthrow ImageReadException(filename, \"open TIFF\");\n\t}\n\n\tif( !is_new_file ) {\n\t\tchar buf[64];\n\t\tif (fread(buf, sizeof(buf), 1, tmp_in) != 1) {\n\t\t\tthrow ImageReadException(filename, \"first block\");\n\t\t}\n\n\t\tif (!is_valid(&buf)) {\n\t\t\tthrow ImageReadException(filename, \"invalid TIFF\");\n\t\t}\n\n\t\tif (buf[0] == TIFF_BIG_ENDIAN) {\n\t\t\tis_big_endian = true;\n\t\t}\n\t\telse {\n\t\t\tis_big_endian = false;\n\t\t}\n\t}\n\n\tfclose(tmp_in);\n\ttmp_in = 0;\n\n\tTIFFSetWarningHandler(0);\n\n\tif( rw_mode == ImageIO::READ_ONLY ) {\n\t\ttiff_file = TIFFOpen(filename.c_str(), \"r\");\n\n\t\tif (!tiff_file) {\n\t\t\tthrow ImageReadException(filename, \"open TIFF\");\n\t\t}\n\n\t\tTIFFGetField(tiff_file, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\n\t\tif (bitspersample != CHAR_BIT &&\n\t\t\t\tbitspersample != (CHAR_BIT * sizeof(short)) &&\n\t\t\t\tbitspersample != (CHAR_BIT * sizeof(float)) ) {\n\t\t\tchar desc[256];\n\t\t\tsprintf(desc, \"invalid %d bits. only %d-bit and %d-bit TIFF are supported\",\n\t\t\t\t\tbitspersample, CHAR_BIT, (int)(CHAR_BIT * sizeof(short)));\n\t\t\tthrow ImageReadException(filename, desc);\n\t\t}\n\t}\n\telse {\n\t\ttiff_file = TIFFOpen(filename.c_str(), \"w\");\n\t\tif (!tiff_file) {\n\t\t\tthrow ImageReadException(filename, \"open TIFF\");\n\t\t}\n\t}\n\n\tEXITFUNC;\n}",
    "int TiffIO::read_header(Dict & dict, int image_index, const Region * area, bool)\n{\n\tENTERFUNC;\n\n\tinit();\n\n\t//single image format, index can only be zero\n\tif(image_index == -1) {\n\t\timage_index = 0;\n\t}\n\n\tif(image_index != 0) {\n\t\tthrow ImageReadException(filename, \"no stack allowed for MRC image. For take 2D slice out of 3D image, read the 3D image first, then use get_clip().\");\n\t}\n\n\tint nx = 0;\n\tint ny = 0;\n\tTIFFGetField(tiff_file, TIFFTAG_IMAGEWIDTH, &nx);\n\tTIFFGetField(tiff_file, TIFFTAG_IMAGELENGTH, &ny);\n\n\tcheck_region(area, IntSize(nx, ny));\n\n\tfloat min = 0;\n\tfloat max = 0;\n\tTIFFDataType data_type = TIFF_NOTYPE;\n\tfloat resolution_x = 0;\n\tfloat resolution_y = 0;\n\n\tTIFFGetField(tiff_file, TIFFTAG_MINSAMPLEVALUE, &min);\n\tTIFFGetField(tiff_file, TIFFTAG_MAXSAMPLEVALUE, &max);\n\n\tTIFFGetField(tiff_file, TIFFTAG_PHOTOMETRIC, &photometric);\n\n\tTIFFGetField(tiff_file, TIFFTAG_SAMPLEFORMAT, &data_type);\n\tTIFFGetField(tiff_file, TIFFTAG_XRESOLUTION, &resolution_x);\n\tTIFFGetField(tiff_file, TIFFTAG_YRESOLUTION, &resolution_y);\n\n\tint xlen = 0, ylen = 0;\n\tEMUtil::get_region_dims(area, nx, &xlen, ny, &ylen);\n\n\tdict[\"nx\"] = xlen;\n\tdict[\"ny\"] = ylen;\n\tdict[\"nz\"] = 1;\n\n\tdict[\"minimum\"] = min;\n\tdict[\"maximum\"] = max;\n\n\tif (bitspersample == CHAR_BIT) {\n\t\tdict[\"datatype\"] = EMUtil::EM_UCHAR;\n\t}\n\telse if (bitspersample == sizeof(unsigned short) * CHAR_BIT) {\n\t\tdict[\"datatype\"] = EMUtil::EM_USHORT;\n\t}\n\telse if (bitspersample == sizeof(float) * CHAR_BIT) {\n\t\tdict[\"datatype\"] = EMUtil::EM_FLOAT;\n\t}\n\n\tdict[\"TIFF.bitspersample\"] = bitspersample;\n\tdict[\"TIFF.resolution_x\"] = resolution_x;\n\tdict[\"TIFF.resolution_y\"] = resolution_y;\n\tEXITFUNC;\n\treturn 0;\n}",
    "int TiffIO::read_data(float *rdata, int image_index, const Region * area, bool)\n{\n\tENTERFUNC;\n\n\t//single image format, index can only be zero\n\timage_index = 0;\n\tcheck_read_access(image_index, rdata);\n\n\tint nx = 0;\n\tint ny = 0;\n\tTIFFGetField(tiff_file, TIFFTAG_IMAGEWIDTH, &nx);\n\tTIFFGetField(tiff_file, TIFFTAG_IMAGELENGTH, &ny);\n\n\tint err = 0;\n\n\t/* for grey scale image, use TIFFReadEncodedStrip() and TIFFReadEncodedTile()\n\t * because the reading of strip image is twice time faster than TIFFReadRGBAImage -Grant*/\n\tif(photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK) {\n\t\tunsigned char *cdata;\t//buffer for strip or tile\n\n\t\tif(TIFFIsTiled(tiff_file)) {\n\t\t\ttsize_t tileSize = TIFFTileSize(tiff_file);\n\t\t\ttsize_t tileMax = TIFFNumberOfTiles(tiff_file);\n\t\t\ttsize_t tileCount;\n\n\t\t\tuint32 tileWidth, tileLength;\n\t\t\tTIFFGetField(tiff_file, TIFFTAG_TILEWIDTH, &tileWidth);\n\t\t\tTIFFGetField(tiff_file, TIFFTAG_TILELENGTH, &tileLength);\n\n\t\t\tif((cdata=(unsigned char*)_TIFFmalloc(tileSize))==NULL){\n\t\t\t\tfprintf(stderr,\"Error: Could not allocate enough memory\\n\");\n\t\t\t\treturn(-1);\n\t\t\t}\n\n\t\t\tint tilePerLine = nx/tileWidth + 1;\n\t\t\tint NX, NY;\t//(NX, NY) is the cordinates of tile\n\t\t\tint xpos, ypos; //(xpos, ypos) is the actual coordinates of pixel (j,i) in image\n\n\t\t\tfor(tileCount=0; tileCount<tileMax; tileCount++) {\n\t\t\t\tif(TIFFReadEncodedTile(tiff_file, tileCount, cdata, tileSize) == -1) {\n\t\t\t\t\tfprintf(stderr,\"Error reading tiled image\\n\");return(-1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tNX = tileCount%tilePerLine;\n\t\t\t\t\tNY = tileCount/tilePerLine;\n\t\t\t\t\tuint32 i, j;\n\t\t\t\t\tfor(i=0; i<tileLength; i++) {\n\t\t\t\t\t\tfor(j=0; j<tileWidth; j++) {\n\t\t\t\t\t\t\txpos = NX*tileWidth + j;\n\t\t\t\t\t\t\typos = NY*tileLength + i;\n\n\t\t\t\t\t\t\tif(bitspersample == CHAR_BIT) {\n\t\t\t\t\t\t\t\tif(xpos<nx && ypos<ny) {\t//discard those pixel in tile which is out of actual image's boundary\n\t\t\t\t\t\t\t\t\tphotometric == PHOTOMETRIC_MINISWHITE ?\n\t\t\t\t\t\t\t\t\t\trdata[nx*(ny-1)-(ypos*nx)+xpos] = -(float) ((unsigned char*)cdata)[i*tileWidth+j] :\n\t\t\t\t\t\t\t\t\t\trdata[nx*(ny-1)-(ypos*nx)+xpos] = (float) ((unsigned char*)cdata)[i*tileWidth+j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(bitspersample == sizeof(unsigned short) * CHAR_BIT) {\n\t\t\t\t\t\t\t\tif(xpos<nx && ypos<ny) {\t//discard those pixel in tile which is out of actual image's boundary\n\t\t\t\t\t\t\t\t\tphotometric == PHOTOMETRIC_MINISWHITE ?\n\t\t\t\t\t\t\t\t\t\trdata[nx*(ny-1)-(ypos*nx)+xpos] = -(float) ((unsigned short*)cdata)[i*tileWidth+j] :\n\t\t\t\t\t\t\t\t\t\trdata[nx*(ny-1)-(ypos*nx)+xpos] = (float) ((unsigned short*)cdata)[i*tileWidth+j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (bitspersample == sizeof(float) * CHAR_BIT) {\n\t\t\t\t\t\t\t\tphotometric == PHOTOMETRIC_MINISWHITE ?\n\t\t\t\t\t\t\t\t\t\trdata[nx*(ny-1)-(ypos*nx)+xpos] = -((float*)cdata)[i*tileWidth+j] :\n\t\t\t\t\t\t\t\t\t\trdata[nx*(ny-1)-(ypos*nx)+xpos] = ((float*)cdata)[i*tileWidth+j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tfprintf(stderr,\"BAILING OUT:Allow only 8- or 16-bits image\\n\");\n\t\t\t\t\t\t\t\treturn(-1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\tcheck_region(area, IntSize(nx, ny));\n\t\t\tint xlen = 0, ylen = 0, x0 = 0, y0 = 0;\n\t\t\tEMUtil::get_region_dims(area, nx, &xlen, ny, &ylen);\n\t\t\tEMUtil::get_region_origins(area, &x0, &y0);\n\n\t\t\tint strip_size = TIFFStripSize(tiff_file);\n\t\t\tuint32 num_strips = TIFFNumberOfStrips(tiff_file);\n\n\t\t\tif((cdata = static_cast < unsigned char *>(_TIFFmalloc(strip_size)))==NULL) {\n\t\t\t\tfprintf(stderr,\"Error: Could not allocate enough memory\\n\");\n\t\t\t\treturn(-1);\n\t\t\t}\n\n\t\t\tint k = 0;\n\t\t\tint num_read = 0;\n\t\t\tint mode_size = bitspersample / CHAR_BIT;\n\t\t\tint total_rows = 0;\n\n\t\t\tfor (uint32 i = 0; i < num_strips; i++) {\n\t\t\t\tif ((num_read = TIFFReadEncodedStrip(tiff_file, i, cdata, strip_size)) == -1) {\n\t\t\t\t\tLOGERR(\"reading stripped TiFF image '%s' failed\", filename.c_str());\n\t\t\t\t\terr = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint nitems = num_read / mode_size;\n\t\t\t\tint nrows = nitems / nx;\n\t\t\t\ttotal_rows += nrows;\n\n\t\t\t\tint y_start = 0;\n\t\t\t\tint y_end = nrows;\n\n\t\t\t\tif (area) {\n\t\t\t\t\tif (total_rows >= y0 && total_rows < y0 + nrows) {\n\t\t\t\t\t\ty_start = nrows - (total_rows - y0);\n\t\t\t\t\t}\n\t\t\t\t\telse if (total_rows >= (y0 + ylen) && total_rows < (y0 + ylen + nrows)) {\n\t\t\t\t\t\ty_end = y0 + ylen - total_rows + nrows;\n\t\t\t\t\t}\n\t\t\t\t\telse if (total_rows >= (y0 + ylen + nrows)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int l = y_start; l < y_end; l++) {\n\t\t\t\t\tfor (int j = x0; j < x0 + xlen; j++) {\n\t\t\t\t\t\tif (bitspersample == CHAR_BIT) {\n\t\t\t\t\t\t\tphotometric == PHOTOMETRIC_MINISWHITE ?\n\t\t\t\t\t\t\t\trdata[k] = -(float) ((unsigned char*)cdata)[l * nx + j] :\n\t\t\t\t\t\t\t\trdata[k] = (float) ((unsigned char*)cdata)[l * nx + j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (bitspersample == sizeof(unsigned short) * CHAR_BIT) {\n\t\t\t\t\t\t\tphotometric == PHOTOMETRIC_MINISWHITE ?\n\t\t\t\t\t\t\t\trdata[k] = -(float)((unsigned short*)cdata)[l * nx + j] :\n\t\t\t\t\t\t\t\trdata[k] = (float)((unsigned short*)cdata)[l * nx + j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (bitspersample == sizeof(float) * CHAR_BIT) {\n\t\t\t\t\t\t\tphotometric == PHOTOMETRIC_MINISWHITE ?\n\t\t\t\t\t\t\t\trdata[k] = -((float*)cdata)[l * nx + j] :\n\t\t\t\t\t\t\t\trdata[k] = ((float*)cdata)[l * nx + j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tUtil::flip_image(rdata, xlen, ylen);\n\t\t}\n\t\t_TIFFfree(cdata);\n\t}\n\telse {\t//process color image, convert to greyscale\n\t\tsize_t npixels = nx * ny;\n\t\tuint32 * raster = (uint32*) _TIFFmalloc(npixels * sizeof(uint32));\n\t\tif(raster != NULL) {\n\t\t\tif(TIFFReadRGBAImage(tiff_file, nx, ny, raster, 0)) {\n\t\t\t\tint abgr = 0;\t//raw ABGR pixel value\n\t\t\t\tint red=0, green=0, blue=0;\n\t\t\t\tfor (int i=0; i<nx; ++i) {\n\t\t\t\t\tfor (int j=0; j<ny; ++j) {\n\t\t\t\t\t\tabgr \t= raster[j+ny*i];\n\t\t\t\t\t\tred \t= TIFFGetR(abgr);\n\t\t\t\t\t\tgreen \t= TIFFGetG(abgr);\n\t\t\t\t\t\tblue \t= TIFFGetB(abgr);\n\t\t\t\t\t\trdata[j+ny*i] = static_cast<float>(red*RED+green*GREEN+blue*BLUE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_TIFFfree(raster);\n\t\t\t}\n\t\t}\n\t}\n\n\tEXITFUNC;\n\treturn err;\n}",
    "err_info *Desk::test_compare_with_tiff (QString &fname)\n   {\n   max_info *max;\n   cpoint size, true_size;\n   int bpp, pagenum;\n   byte *im;\n   TIFF *tif;\n\tunsigned imagelength;\n\tbyte *buf, *ptr;\n\tunsigned row;\n\tint stride, im_size, tif_size;\n   int config, nstrips;\n   int imageWidth, imageLength, tileWidth, tileLength;\n\n   CALL (max_open (fname.latin1 (), &max));\n\n   QString ext;\n   QString newname = removeExtension (fname, ext);\n\n   newname += \".tif\";\n\n   printf (\"name=%s\\n\", newname.latin1 ());\n\n   tif = TIFFOpen (newname.latin1 (), \"r\");\n\n   // compare each page\n   for (pagenum = 0; pagenum < max_get_pagecount (max); pagenum++)\n      {\n      printf (\"page %d / %d: \", pagenum, max_get_pagecount (max));\n\n\t   if (pagenum && !TIFFReadDirectory(tif))\n\t      {\n\t      printf (\"ran out of pages\\n\");\n\t      exit (1);\n\t      }   err_info *test_decomp_comp (QString &fname);\n\n\n//      printf (\"\\nTIFF\\n\");\n    \tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imagelength);\n      TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n   \tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n\t   TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imageLength);\n//   \tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tileWidth);\n//   \tTIFFGetField(tif, TIFFTAG_TILELENGTH, &tileLength);\n\n      tileWidth = tileLength = 0;\n\n      nstrips = TIFFNumberOfStrips(tif);\n//      printf (\"strips=%d, image=%dx%d, tile=%dx%d: %d\\n\", nstrips, imageWidth, imageLength,\n//            tileWidth, tileLength, TIFFNumberOfTiles(tif));\n\n    \tstride = ((TIFFScanlineSize(tif) + 3) & ~3);;\n//      stride = imageWidth / 8;\n    \ttif_size = stride * imagelength;\n     \tbuf = (byte *)malloc (tif_size);\n     \tprintf (\"   stride=%d, \", stride);\n   \tfor (row = 0, ptr = buf; row < imagelength; row++, ptr += stride)\n\t      if (TIFFReadScanline(tif, ptr, row) != 1)\n\t         {\n\t         printf (\"\\nreadscanline error\\n\");\n\t         break;\n\t         }\n      CALL (max_get_image (max, pagenum, &size, &true_size, &bpp, &im, &im_size));\n\n   \tfor (row = 0, ptr = buf; row < imagelength; row++, ptr += stride)\n   \t   if (0 != memcmp (ptr, im + (ptr - buf), stride))\n   \t      {\n   \t      printf (\"\\n- error line %d\\n\", row);\n   \t      dump (\"tif\", ptr, stride, im + (ptr - buf));\n   \t      dump (\"max\", im + (ptr - buf), stride, ptr);\n   \t      }\n\n\t   free (buf);\n\t   printf (\"    lines=%d/%d, %d %d\\n\", imagelength, row, im_size, tif_size);\n\t   }\n   TIFFClose (tif);\n   max_close (max);\n\n   return NULL;\n   }",
    "void readTiff(QImageIO* iio)\n{\n  QImage image;\n  int depth;\n  int i;\n  float x_resolution, y_resolution;\n  int y;\n  TIFF *tiff;\n  Q_UINT16 extra;\n  Q_UINT16* extra_types;\n  Q_UINT16 compress_tag;\n  Q_UINT32 height,width;\n  Q_UINT16 bits_per_sample;\n  Q_UINT16 interlace;\n  Q_UINT16 max_sample_value;\n  Q_UINT16 min_sample_value;\n  Q_UINT16 photometric;\n  Q_UINT16 samples_per_pixel;\n  Q_UINT16 units;\n  bool color;\n  bool has_alpha = false;\n  bool min_is_white = false;\n  tiff=TIFFOpen(QFile::encodeName(iio->fileName()),\"r\");\n  if(tiff == (TIFF *) 0L)\n  {\n    iio->setStatus(1);\n    return;\n  }\n  TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width);\n  TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height);\n  TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample);\n  TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric);\n  TIFFGetField(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel);\n  TIFFGetField(tiff,TIFFTAG_EXTRASAMPLES,&extra,&extra_types);\n  TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace);\n\n  if(extra>0 && (extra_types[0] == EXTRASAMPLE_ASSOCALPHA))\n  {\n    has_alpha = true;\n  }\n  //The formats we can read. If the tiff has been written by QuiteInsane,\n  //then we can read it this way. For other formats, we fall back to\n  //RGBA - at least for the moment.\n  if((!TIFFIsTiled(tiff)) &&\n     (interlace == PLANARCONFIG_CONTIG) &&\n     ((bits_per_sample == 1)   ||\n      (bits_per_sample == 8)   ||\n      (bits_per_sample == 16)) &&\n     ((photometric == PHOTOMETRIC_MINISWHITE) ||\n      (photometric == PHOTOMETRIC_MINISBLACK) ||\n      (photometric == PHOTOMETRIC_RGB)        ||\n      (photometric == PHOTOMETRIC_PALETTE)))\n  {\n    if((bits_per_sample == 8) || (bits_per_sample == 16))\n    {\n      if(photometric == PHOTOMETRIC_RGB)\n      {\n        color = true;\n        depth = 32;\n        if(!image.create(width,height,depth))\n        {\n          iio->setStatus(1);\n          return;\n        }\n        image.setAlphaBuffer(has_alpha);\n      }\n      else\n      {\n        depth = 8;\n        if(!image.create(width,height,depth))\n        {\n          iio->setStatus(1);\n          return;\n        }\n        image.setNumColors(256);\n        image.setAlphaBuffer(has_alpha);\n        if(photometric == PHOTOMETRIC_PALETTE)\n        {\n          color = true;\n          Q_UINT16* blue_colormap;\n          Q_UINT16* green_colormap;\n          Q_UINT16* red_colormap;\n\n          TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,&green_colormap,\n                       &blue_colormap);\n          for(i=0; i < 256; i++)\n          {\n            image.setColor(i,qRgb(red_colormap[i]/257,\n                                  green_colormap[i]/257,\n                                  blue_colormap[i]/257));\n\n          }\n        }\n        else if(photometric == PHOTOMETRIC_MINISWHITE)\n        {\n          color = false; //grayscale\n          min_is_white = true;\n        }\n        else\n        {\n          color = false;\n        }\n      }\n    }\n    else if(bits_per_sample == 1) //lineart, B&W\n    {\n      depth = 1;\n      if(!image.create(width,height,depth,2,QImage::BigEndian))\n      {\n        iio->setStatus(1);\n        return;\n      }\n    }\n    if(depth == 1)\n    {\n      image.setColor(0,qRgb(255,255,255));\n      image.setColor(1,qRgb(0,0,0));\n    }\n    TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units);\n    TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution);\n    TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution);\n    if(units == 1)\n    {\n      image.setDotsPerMeterX(0);\n      image.setDotsPerMeterY(0);\n    }\n    else if(units == 2)\n    {\n      image.setDotsPerMeterX(int(x_resolution*100.0/2.54));\n      image.setDotsPerMeterY(int(y_resolution*100.0/2.54));\n    }\n    else if(units == 3)\n    {\n      image.setDotsPerMeterX(int(x_resolution*100.0));\n      image.setDotsPerMeterY(int(y_resolution*100.0));\n    }\n    TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag);\n    TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value);\n    TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value);\n    TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel);\n\n    Q_UINT8* line;\n    line = 0;\n    if(depth == 32)\n    {\n      if(bits_per_sample == 16)\n      {\n        if(has_alpha)\n          line = new Q_UINT8 [width*8];\n        else\n          line = new Q_UINT8 [width*6];\n      }\n      else\n      {\n        if(has_alpha)\n          line = new Q_UINT8 [width*4];\n        else\n          line = new Q_UINT8 [width*3];\n      }\n    }\n    if(depth == 8)\n    {\n      if(bits_per_sample == 16)\n        line = new Q_UINT8 [width*2];\n      else\n        line = new Q_UINT8 [width];\n    }\n    if(depth == 1)\n      line = new Q_UINT8 [TIFFScanlineSize(tiff)];\n\n    if(line)\n    {\n      for(y=0; y < (int) image.height(); y++)\n      {\n        if(TIFFReadScanline(tiff,(unsigned char*)line,y,0) == -1)\n        {\n          delete [] line;\n          TIFFClose(tiff);\n          iio->setStatus(1);\n          return;\n        }\n        if(depth == 32)\n        {\n          Q_UINT16* line16;\n          line16 = (Q_UINT16*) line;\n          int Qt::red,Qt::green,Qt::blue,alpha;\n          for(i=0;i<image.width();i++)\n          {\n            if(bits_per_sample == 16)\n            {\n              if(has_alpha)\n              {\n                Qt::red = int(line16[i*4])/257;\n                Qt::green = int(line16[i*4+1])/257;\n                Qt::blue = int(line16[i*4+2])/257;\n                alpha = int(line16[i*4+3]/257);\n                if(alpha > 0)\n                {\n                  Qt::red = (Qt::red*255)/alpha;\n                  Qt::green = (Qt::green*255)/alpha;\n                  Qt::blue = (Qt::blue*255)/alpha;\n                }\n                image.setPixel(i,y,qRgba(Qt::red,Qt::green,Qt::blue,alpha));\n              }\n              else\n                image.setPixel(i,y,qRgb(int(line16[i*3]),\n                                        int(line16[i*3+1]),\n                                        int(line16[i*3+2])));\n            }\n            else\n            {\n              if(has_alpha)\n              {\n                Qt::red = int(line[i*4]);\n                Qt::green = int(line[i*4+1]);\n                Qt::blue = int(line[i*4+2]);\n                alpha = int(line[i*4+3]);\n                if(alpha > 0)\n                {\n                  Qt::red = (Qt::red*255)/alpha;\n                  Qt::green = (Qt::green*255)/alpha;\n                  Qt::blue = (Qt::blue*255)/alpha;\n                }\n                image.setPixel(i,y,qRgba(Qt::red,Qt::green,Qt::blue,alpha));\n              }\n              else\n                image.setPixel(i,y,qRgb(int(line[i*3]),\n                                        int(line[i*3+1]),\n                                        int(line[i*3+2])));\n            }\n          }\n        }\n        if(depth == 8)\n        {\n          if(bits_per_sample == 16)\n          {\n            Q_UINT16* line16;\n            line16 = (Q_UINT16*) line;\n            for(i=0;i<image.width();i++)\n            {\n              int Qt::gray = line16[i]/257;\n              if(color)\n              {\n                image.setPixel(i,y,Qt::gray);\n              }\n              else\n              {\n                if(min_is_white)\n                {\n                  Qt::gray = 255 - Qt::gray;\n                  image.setPixel(i,y,Qt::gray);\n                  image.setColor(Qt::gray,qRgb(Qt::gray,Qt::gray,Qt::gray));\n                }\n                else\n                {\n                  image.setPixel(i,y,Qt::gray);\n                  image.setColor(Qt::gray,qRgb(Qt::gray,Qt::gray,Qt::gray));\n                }\n              }\n            }\n          }\n          else if(bits_per_sample == 8)\n          {\n            for(i=0;i<image.width();i++)\n            {\n              if(color)\n              {\n                image.setPixel(i,y,line[i]);\n              }\n              else\n              {\n                image.setPixel(i,y,line[i]);\n                if(min_is_white)\n                {\n                  image.setPixel(i,y,line[i]);\n                  image.setColor(line[i],qRgb(int(line[i]^0xff),\n                                              int(line[i]^0xff),\n                                              int(line[i]^0xff)));\n                }\n                else\n                {\n                  image.setPixel(i,y,line[i]);\n                  image.setColor(line[i],qRgb(int(line[i]),\n                                              int(line[i]),\n                                              int(line[i])));\n                }\n              }\n            }\n          }\n        }\n        if(depth == 1)\n        {\n          memcpy(image.scanLine(y),line,TIFFScanlineSize(tiff));\n        }\n      }\n      delete [] line;\n      TIFFClose(tiff);\n    }\n    else //error\n    {\n      TIFFClose(tiff);\n      iio->setStatus(1);\n      return;\n    }\n  }\n//otherwise, try to read an RGBA image\n  else\n  {\n    unsigned int i;\n    unsigned int i2;\n    unsigned char* idat;\n    uint32 w, h;\n    size_t npixels;\n    uint32* raster;\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &w);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &h);\n    npixels = w * h;\n    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n    if(raster)\n    {\n      if(TIFFReadRGBAImage(tiff, w, h, raster, 0))\n      {\n        if(!image.create(w,h,32))\n        {\n          iio->setStatus(1);\n          _TIFFfree(raster);\n          return;\n        }\n        image.setAlphaBuffer(true);\n        //we finaly can transfer the data to our image\n        idat = (unsigned char*)raster;\n        for(i=0;i<h;i++)\n        {\n          for(i2=0;i2<w;i2++)\n          {\n            image.setPixel(i2,i,qRgba((int)*(idat),\n                                      (int)*(idat+1),\n                                      (int)*(idat+2),\n                                      (int)*(idat+3)));\n            idat += 4;\n          }\n        }\n      }\n      _TIFFfree(raster);\n      image = image.mirror(false,true);\n    }\n    else //couldn't allocate raster\n    {\n      TIFFClose(tiff);\n      iio->setStatus(1);\n      return;\n    }\n    TIFFClose(tiff);\n  }\n  iio->setImage(image);\n  iio->setStatus(0);\n}",
    "int imageIO::readTiff(){\n  TIFF * image;\n  uint width, height, depth, planesize;\n  uint offset = 0;\n  int unit;\n\n  // Open the TIFF image\n  image = TIFFOpen(filename.c_str(), \"r\");\n\n  // Find the width and height of the image\n  TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(image, TIFFTAG_IMAGELENGTH, &height);\n  depth = getTiffCount();\n\n  img.height = height;\n  img.width  = width;\n  img.depth  = depth;\n  img.image_stack = (uchar *) malloc (height * width * depth * sizeof(uchar));\n\n  if (img.image_stack == NULL){\n    cerr << \"Error, could not allocate enough memory for image stack.\\n\";\n    return 0;\n  }\n\n  TIFFGetField(image, TIFFTAG_RESOLUTIONUNIT, &unit);\n  TIFFGetField(image, TIFFTAG_XRESOLUTION, &img.xy_dist);\n\n  if (unit == RESUNIT_CENTIMETER){\n    /*\n     * divide by 10,000 to convert from centimeters to microns\n     * take inverse to get microns/pixel\n     */\n    img.xy_dist = (1 / (img.xy_dist / 10000));\n  }else if (unit == RESUNIT_INCH){\n    // divide by 24,500 to convert from inches to microns \n    img.xy_dist = (1 / (img.xy_dist / 25400));\n  }\n  \n  planesize = height * width;\n\n  if (image != NULL) {\n\n    uint bufsize= TIFFStripSize(image);\n    uchar * buf = (uchar *) _TIFFmalloc(bufsize);\n    uint s, ns  = TIFFNumberOfStrips(image);\n    uint *bytecounts;\n\n    do {\n      \n      TIFFGetField(image, TIFFTAG_STRIPBYTECOUNTS, &bytecounts);\n      for (s = 0; s < ns; s++) {\n\t\n\t// check to see if we need to resize the buffer\n\tif (bytecounts[s] != (uint)bufsize){\n\t  buf = (uchar *)_TIFFrealloc(buf, bytecounts[s]);\n\t  if (!buf){\n\t    return 0;\n\t  }\n\t  bufsize = bytecounts[s];\n\t}\n\t\n\t// try to read the strip\n\tif (TIFFReadRawStrip(image, s, buf, bytecounts[s]) < 0){\n\t  // if we encounter an error, free the buffer and return\n\t  _TIFFfree(buf);\n\t  return 0;\n\t}else{\n\t  memcpy(&img.image_stack[offset], buf, (bufsize * sizeof(uchar)));\n\t  offset += bufsize;\n\t}\n      }\n      \n    } while (TIFFReadDirectory(image));\n    _TIFFfree(buf);\n  }\n\n  /*\n    // DEBUG\n    tstrip_t strip;\n    uint32* bc;\n    \n    TIFFGetField(image, TIFFTAG_STRIPBYTECOUNTS, &bc);\n\n      \n    int cnt = 0;\n\n\n    do {\n      cout << \"strip byte counts: \" << bc[cnt++] << endl;\n\n      // Read the image into the memory buffer\n      if(TIFFReadRGBAStrip(image, 0, raster) == 0){\n\tfprintf(stderr, \"Could not read image\\n\");\n\treturn 0;\n      }\n\n      for (i = 0; i < planesize; ++i){\n\timg.image_stack[offset + i] = ((uchar) TIFFGetR(raster[i]));\n      }\n      offset += planesize;\n\n      cout << \"raster[\" << offset - 1 << \"] = \" << TIFFGetR(raster[offset - 1]) << endl;      \n      printf(\"img[%i] = %i\\n\", offset - 1, img.image_stack[offset - 1]);\n\n    } while (TIFFReadDirectory(image));\n\n    free(raster);\n    (void) TIFFClose(image);\n  }\n  */\n  return 1;\n}",
    "int TMOImage::ReadHeader(TIFF *pFile)\n{\n\tunsigned short iCompression = 0; // compression type\n\tunsigned short iOrientation = 1; // visual orientation (TIFF spec.)\n\n\tif (!TIFFGetField(pFile, TIFFTAG_COMPRESSION, &iCompression))\n\t{\n\t\tiCompression = COMPRESSION_NONE;\n\t}\n\n\tTIFFGetField(pFile, TIFFTAG_XRESOLUTION, &fXres);\n\tTIFFGetField(pFile, TIFFTAG_YRESOLUTION, &fYres);\n\n\tTIFFGetFieldDefaulted(pFile, TIFFTAG_ORIENTATION, &iOrientation);\n\n\tif (!TIFFGetFieldDefaulted(pFile, TIFFTAG_PHOTOMETRIC, &iPhotometric))\n\t\tthrow TMO_EFILE_PARSE;\n\n\tswitch (iPhotometric)\n\t{\n\tcase PHOTOMETRIC_LOGLUV:\n\t\tTIFFSetField(pFile, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n\t\tTIFFSetField(pFile, TIFFTAG_SGILOGENCODE, SGILOGENCODE_RANDITHER);\n\t\tbreak;\n\tcase PHOTOMETRIC_LOGL:\n\t\tTIFFSetField(pFile, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n\t\tTIFFSetField(pFile, TIFFTAG_SGILOGENCODE, SGILOGENCODE_NODITHER);\n\t\tbreak;\n\tcase PHOTOMETRIC_RGB:\n\t\tbreak;\n\tdefault:\n\t\tthrow TMO_EFILE_PARSE;\n\t}\n\n\tif (!TIFFGetField(pFile, TIFFTAG_BITSPERSAMPLE, &iBitsPerSample))\n\t{\n\t\tiBitsPerSample = 8;\n\t}\n\n\tif (!TIFFGetField(pFile, TIFFTAG_IMAGEWIDTH, &iWidth) ||\n\t\t!TIFFGetField(pFile, TIFFTAG_IMAGELENGTH, &iHeight))\n\t\tthrow TMO_EFILE_PARSE;\n\n\tif (!TIFFGetField(pFile, TIFFTAG_STONITS, &dStonits))\n\t\tdStonits = 1.;\n\n\tif (pData)\n\t\tdelete[] pData;\n\tpData = new double[3 * iWidth * iHeight];\n\n\treturn 0;\n}",
    "void TiffDirectory::_getTiffField_ui32(TIFF *tiff, ttag_t tag,\nint64_t *val) const {\n  uint32_t normalint = 0;\n  if (1 == TIFFGetField(tiff, tag, &normalint)) {\n      *val = static_cast<int64_t>(normalint);\n  } else {\n    *val = -1;\n  }\n}",
    "void TiffDirectory::_getTiffField_ui16(TIFF *tiff, ttag_t tag,\nint64_t *val) const {\n  uint16_t normalint = 0;\n  if (1 == TIFFGetField(tiff, tag, &normalint)) {\n      *val = static_cast<int64_t>(normalint);\n  } else {\n    *val = -1;\n  }\n}",
    "void TiffDirectory::_getTiffField_f(TIFF *tiff, ttag_t tag,\ndouble *val) const {\n  float flt;\n  if (1 == TIFFGetField(tiff, tag, &flt)) {\n      *val = static_cast<double>(flt);\n  } else {\n    *val = -1.0;\n  }\n}",
    "void TiffDirectory::_getTiffField_str(TIFF *tiff, ttag_t tag,\nstd::string *val) const {\n  char *str;\n  int result = TIFFGetField(tiff, tag, &str);\n  if (result == 1) {\n    *val = str;\n  } else {\n    *val = \"\";\n  }\n}",
    "void TiffDirectory::_getTiffField_jpegTables(TIFF *tiff,\nint64_t* jpegTableDataSize, std::unique_ptr<uint8_t[]> *jpegTableData) const {\n  uint16_t size = 0;\n  void *tableData;\n  *jpegTableDataSize = -1;\n  *jpegTableData = nullptr;\n  int result = TIFFGetField(tiff, TIFFTAG_JPEGTABLES, &size, &tableData);\n  if (result == 1) {\n    *jpegTableDataSize = static_cast<int64_t>(size);\n    if (*jpegTableDataSize > 0) {\n      *jpegTableData = std::make_unique<uint8_t[]>(size);\n      memcpy((*jpegTableData).get(), tableData, size);\n    }\n  }\n}",
    "bool TiffDirectory::_hasICCProfile(TIFF *tiff) const {\n  uint32_t temp;\n  void *ptr;\n  return (1 == TIFFGetField(tiff, TIFFTAG_ICCPROFILE, &temp, &ptr));\n}",
    "bool isLightZoneLayeredTIFF( TIFF *tiff ) {\n    LC_TIFFFieldValue value[2];\n    if ( !TIFFGetField( tiff, TIFFTAG_SOFTWARE, &value[0] ) )\n        return false;\n    if ( ::strncmp( value[0].cp, AppName, ::strlen( AppName ) ) )\n        return false;\n    if ( !TIFFGetField( tiff, TIFFTAG_PAGENUMBER, &value[0], &value[1] ) )\n        return false;\n    return value[1].u16 == 2;\n}",
    "JNIEXPORT jbyteArray JNICALL LCTIFFReader_METHOD(getICCProfileData)\n    ( JNIEnv *env, jobject jLCTIFFReader )\n{\n    uint32_t profileSize;\n    void *profileData;\n    int const result = TIFFGetField(\n        getNativePtr( env, jLCTIFFReader ), TIFFTAG_ICCPROFILE,\n        &profileSize, &profileData\n    );\n    if ( !result )\n        return NULL;\n    jbyteArray jProfileData = (jbyteArray)env->NewByteArray( profileSize );\n    jarray_to_c<jbyte> cProfileData( env, jProfileData );\n    ::memcpy( cProfileData, profileData, profileSize );\n    return jProfileData;\n}",
    "JNIEXPORT jint JNICALL LCTIFFReader_METHOD(getIntField)\n    ( JNIEnv *env, jobject jLCTIFFReader, jint tagID )\n{\n    TIFF *const tiff = getNativePtr( env, jLCTIFFReader );\n    LC_TIFFFieldValue value, unused;\n    int result;\n    switch ( tagID ) {\n        case TIFFTAG_EXTRASAMPLES:\n            //\n            // Special case for those tags that have extra values we're not\n            // interested in.\n            //\n            result = TIFFGetField( tiff, tagID, &value, &unused );\n            break;\n        default:\n            result = TIFFGetField( tiff, tagID, &value );\n    }\n    if ( !result )\n        return -1;\n    switch ( tagID ) {\n\n        case TIFFTAG_BADFAXLINES:\n        case TIFFTAG_CONSECUTIVEBADFAXLINES:\n        case TIFFTAG_GROUP3OPTIONS:\n        case TIFFTAG_GROUP4OPTIONS:\n        case TIFFTAG_IMAGEDEPTH:\n        case TIFFTAG_IMAGELENGTH:\n        case TIFFTAG_IMAGEWIDTH:\n        case TIFFTAG_ROWSPERSTRIP:\n        case TIFFTAG_SUBFILETYPE:\n        case TIFFTAG_TILEDEPTH:\n        case TIFFTAG_TILELENGTH:\n        case TIFFTAG_TILEWIDTH:\n            return value.u32;\n\n        case TIFFTAG_BITSPERSAMPLE:\n        case TIFFTAG_CLEANFAXDATA:\n        case TIFFTAG_COMPRESSION:\n        case TIFFTAG_DATATYPE:\n        case TIFFTAG_FILLORDER:\n        case TIFFTAG_INKSET:\n        case TIFFTAG_MATTEING:\n        case TIFFTAG_MAXSAMPLEVALUE:\n        case TIFFTAG_MINSAMPLEVALUE:\n        case TIFFTAG_ORIENTATION:\n        case TIFFTAG_PHOTOMETRIC:\n        case TIFFTAG_PLANARCONFIG:\n        case TIFFTAG_PREDICTOR:\n        case TIFFTAG_RESOLUTIONUNIT:\n        case TIFFTAG_SAMPLEFORMAT:\n        case TIFFTAG_SAMPLESPERPIXEL:\n        case TIFFTAG_THRESHHOLDING:\n        case TIFFTAG_YCBCRPOSITIONING:\n        case TIFFTAG_EXTRASAMPLES:\n            return value.u16;\n\n        default:\n            LC_throwIllegalArgumentException( env, \"unsupported tagID\" );\n            return -1;\n    }\n}",
    "JNIEXPORT jint JNICALL LCTIFFReader_METHOD(getIntField2)\n    ( JNIEnv *env, jobject jLCTIFFReader, jint tagID, jboolean getSecond )\n{\n    TIFF *const tiff = getNativePtr( env, jLCTIFFReader );\n    LC_TIFFFieldValue value[2];\n\n    switch ( tagID ) {\n\n        case TIFFTAG_PAGENUMBER:\n            return  TIFFGetField( tiff, tagID, &value[0], &value[1] ) ?\n                    value[ getSecond ].u16 : -1;\n\n        default:\n            LC_throwIllegalArgumentException( env, \"unsupported tagID\" );\n            return -1;\n    }\n}",
    "JNIEXPORT jstring JNICALL LCTIFFReader_METHOD(getStringField)\n    ( JNIEnv *env, jobject jLCTIFFReader, jint tagID )\n{\n    TIFF *const tiff = getNativePtr( env, jLCTIFFReader );\n    LC_TIFFFieldValue value;\n    switch ( tagID ) {\n\n        case TIFFTAG_ARTIST:\n        case TIFFTAG_COPYRIGHT:\n        case TIFFTAG_DATETIME:\n        case TIFFTAG_DOCUMENTNAME:\n        case TIFFTAG_HOSTCOMPUTER:\n        case TIFFTAG_IMAGEDESCRIPTION:\n        case TIFFTAG_INKNAMES:\n        case TIFFTAG_MAKE:\n        case TIFFTAG_MODEL:\n        case TIFFTAG_PAGENAME:\n        case TIFFTAG_SOFTWARE:\n        case TIFFTAG_TARGETPRINTER:\n            return  TIFFGetField( tiff, tagID, &value ) ?\n                    env->NewStringUTF( value.cp ) : NULL;\n\n        default:\n            LC_throwIllegalArgumentException( env, \"unsupported tagID\" );\n            return NULL;\n    }\n}",
    "bool ZLWin32ImageManager::tiffConvert(const std::string &stringData, ZLWin32ImageData &data, bool &result) const {\n\tresult = false;\n\tTIFFReader reader(stringData);\n\tTIFF *tiff = TIFFClientOpen(\"ZLWin32ImageManager\", \"rM\", &reader, TIFFReader::read, TIFFReader::write, TIFFReader::seek, TIFFReader::close, TIFFReader::size, TIFFReader::map, TIFFReader::unmap);\n\tif (tiff == 0) {\n\t\treturn false;\n\t}\n\n\tint width, height;\n\tif (!TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width) ||\n\t\t\t!TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height)) {\n\t\tTIFFClose(tiff);\n\t\treturn false;\n\t}\n\n\tdata.init(width, height, true, 0);\n\n\tresult = TIFFReadRGBAImage(tiff, width, height, (uint32*)data.myArray, 1) != 0;\n\tdata.bgr2rgb();\n\n\tTIFFClose(tiff);\n\treturn true;\n}",
    "Image *Read (IStream *file, const ImageReadOptions& options)\n{\n    int                   nrow;\n    int                   result = 0;\n    long                  LineSize;\n    TIFF                  *tif;\n    Image                 *image ;\n    uint16                BitsPerSample;\n    uint16                BytesPerSample = 1;\n    uint16                PhotometricInterpretation;\n    uint16                SamplePerPixel;\n    uint16                Orientation;\n    uint16                ExtraSamples;\n    uint16*               ExtraSampleInfo;\n    uint32                RowsPerStrip;\n    unsigned int          width;\n    unsigned int          height;\n\n    // TODO - TIFF files probably have some gamma info in them by default, but we're currently ignorant about that.\n    // Until that is fixed, use whatever the user has chosen as default.\n    GammaCurvePtr gamma;\n    if (options.gammacorrect && options.defaultGamma)\n        gamma = TranscodingGammaCurve::Get(options.workingGamma, options.defaultGamma);\n\n    // Rather than have libTIFF complain about tags it doesn't understand,\n    // we just suppress all the warnings.\n    TIFFSetWarningHandler(SuppressTIFFWarnings);\n    TIFFSetErrorHandler(SuppressTIFFWarnings);\n\n    // Open and do initial processing\n    tif = TIFFClientOpen(\"Dummy File Name\", \"r\", file,\n        Tiff_Read, Tiff_Write, Tiff_Seek, Tiff_Close,\n        Tiff_Size, Tiff_Map, Tiff_Unmap);\n    if (!tif)\n        return nullptr;\n\n    // Get basic information about the image\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n    TIFFGetField(tif, TIFFTAG_ORIENTATION, &Orientation);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &ExtraSamples, &ExtraSampleInfo);\n\n    // [CLi] TIFF provides alpha mode information in the TIFFTAG_EXTRASAMPLES field, so that's the preferred mode to use\n    // for the image container unless the user overrides (e.g. to handle a non-compliant file).\n    // If TIFFTAG_EXTRASAMPLES information is absent or inconclusive, we presume associated (= premultiplied) alpha.\n    bool premul = true;\n    if ((ExtraSamples > 0) && (ExtraSampleInfo[0] == EXTRASAMPLE_UNASSALPHA))\n        premul = false;\n    if (options.premultipliedOverride)\n        premul = options.premultiplied;\n\n    // don't support more than 16 bits per sample\n    if (BitsPerSample == 16)\n    {\n        BytesPerSample = 2 ;\n        options.warnings.push_back (\"Warning: reading 16 bits/sample TIFF file; components crunched to 8\");\n    }\n\n    LineSize = TIFFScanlineSize(tif);\n    POV_IMAGE_ASSERT(SamplePerPixel == (int) (LineSize / width) / BytesPerSample);\n    // SamplePerPixel = (int)(LineSize / width);\n\n#if 0\n    // For now we are ignoring the orientation of the image...\n    switch (Orientation)\n    {\n    case ORIENTATION_TOPLEFT:\n        break;\n    case ORIENTATION_TOPRIGHT:\n        break;\n    case ORIENTATION_BOTRIGHT:\n        break;\n    case ORIENTATION_BOTLEFT:\n        break;\n    case ORIENTATION_LEFTTOP:\n        break;\n    case ORIENTATION_RIGHTTOP:\n        break;\n    case ORIENTATION_RIGHTBOT:\n        break;\n    case ORIENTATION_LEFTBOT:\n        break;\n    default:\n        break;\n    }\n#endif\n\n    //PhotometricInterpretation = 2 image is RGB\n    //PhotometricInterpretation = 3 image have a color palette\n    if ((PhotometricInterpretation == PHOTOMETRIC_PALETTE) && (TIFFIsTiled(tif) == 0))\n    {\n        uint16 *red, *green, *blue;\n\n        //load the palette\n        int cmap_len = (1 << BitsPerSample);\n\n        TIFFGetField(tif, TIFFTAG_COLORMAP, &red, &green, &blue);\n\n        std::vector<Image::RGBMapEntry> colormap;\n        Image::RGBMapEntry entry;\n\n        // I may be mistaken, but it appears that alpha/opacity information doesn't\n        // appear in a Paletted Tiff image.  Well - if it does, it's not as easy to\n        // get at as RGB.\n        // Read the palette\n        // Is the palette 16 or 8 bits ?\n        if (checkcmap(cmap_len, red, green, blue) == 16)\n        {\n            for (int i=0;i<cmap_len;i++)\n            {\n                entry.red   = IntDecode(gamma, red[i],   65535);\n                entry.green = IntDecode(gamma, green[i], 65535);\n                entry.blue  = IntDecode(gamma, blue[i],  65535);\n                colormap.push_back (entry);\n            }\n        }\n        else\n        {\n            for (int i=0;i<cmap_len;i++)\n            {\n                entry.red   = IntDecode(gamma, red[i],   255);\n                entry.green = IntDecode(gamma, green[i], 255);\n                entry.blue  = IntDecode(gamma, blue[i],  255);\n                colormap.push_back (entry);\n            }\n        }\n\n        ImageDataType imagetype = options.itype;\n        if (imagetype == ImageDataType::Undefined)\n            imagetype = ImageDataType::Colour_Map;\n        image = Image::Create (width, height, imagetype, colormap) ;\n        image->SetPremultiplied(premul); // specify whether the color map data has premultiplied alpha\n\n        std::unique_ptr<unsigned char[]> buf (new unsigned char [TIFFStripSize(tif)]);\n\n        //read the tiff lines and save them in the image\n        //with RGB mode, we have to change the order of the 3 samples RGB <=> BGR\n        for (int row=0;row<height;row+=RowsPerStrip)\n        {\n            nrow = (row + (int)RowsPerStrip > height ? height - row : RowsPerStrip);\n            TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 0), buf.get(), nrow * LineSize);\n            for (int l = 0, offset = 0; l < nrow ; l++, offset += LineSize)\n                for (int x = 0 ; x < width ; x++)\n                    image->SetIndexedValue (x, row+l, buf[offset+x]) ;\n        }\n    }\n    else\n    {\n        // Allocate the row buffers for the image\n        std::unique_ptr<uint32[]> buf (new uint32 [width * height]) ;\n\n        ImageDataType imagetype = options.itype;\n        if (imagetype == ImageDataType::Undefined)\n            imagetype = Image::GetImageDataType(8, 3, true, gamma);\n        image = Image::Create (width, height, imagetype) ;\n        image->SetPremultiplied(premul); // set desired storage mode regarding alpha premultiplication\n        image->TryDeferDecoding(gamma, 255); // try to have gamma adjustment being deferred until image evaluation.\n\n        TIFFReadRGBAImage(tif, width, height, buf.get(), 0);\n        uint32 abgr, *tbuf = buf.get();\n        for (int i=height-1;i>=0;i--)\n        {\n            for (int j=0;j<width;j++)\n            {\n                abgr = *tbuf++;\n                unsigned int b = (unsigned char)TIFFGetB(abgr);\n                unsigned int g = (unsigned char)TIFFGetG(abgr);\n                unsigned int r = (unsigned char)TIFFGetR(abgr);\n                unsigned int a = (unsigned char)TIFFGetA(abgr);\n                SetEncodedRGBAValue(image, j, i, gamma, 255, r, g, b, a, premul) ;\n            }\n        }\n    }\n\n    TIFFClose(tif);\n\n    return (image) ;\n}",
    "void ImLoadImageToMat(const char* path, ImMat& mat, bool gray)\n{\n    auto file_suffix = ImGuiHelper::path_filename_suffix(path);\n    if (file_suffix.compare(\".tiff\") == 0 || file_suffix.compare(\".TIFF\") == 0)\n    {\n#if IMGUI_TIFF\n        TIFF* tif = TIFFOpen(path, \"r\");\n        if (tif)\n        {\n            uint32_t w, h, c, imagelength;\n            uint16_t depth, config;\n            TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n            TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n            TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &c);\n            TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &depth);\n            TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imagelength);\n            TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n            mat.create_type(w, h, c, depth == 8 ? IM_DT_INT8 : depth == 16 ? IM_DT_INT16 : IM_DT_FLOAT32);\n            if (config == PLANARCONFIG_CONTIG)\n            {\n                mat.elempack = c;\n                for (int row = 0; row < imagelength; row++)\n                {\n                    void* mat_row = (unsigned char*)mat.data + (size_t)mat.w * row * mat.elemsize * mat.elempack;\n                    TIFFReadScanline(tif, mat_row, row);\n                }\n            }\n            else if (config == PLANARCONFIG_SEPARATE)\n            {\n                // TODO::Dicky\n            }\n            TIFFClose(tif);\n        }\n#endif\n        return;\n    }\n\n    int width = 0, height = 0, component = 0;\n    if (auto data = stbi_load(path, &width, &height, &component, gray ? 1 : 4))\n    {\n        ImMat tmp;\n        tmp.create_type(width, height, gray ? 1 : 4, data, IM_DT_INT8);\n        tmp.elempack = gray ? 1 : 4;\n        mat = tmp.clone();\n        stbi_image_free(data);\n    }\n    else if (auto data = stbi_load_16(path, &width, &height, &component, gray ? 1 : 4))\n    {\n        ImMat tmp;\n        tmp.create_type(width, height, gray ? 1 : 4, data, IM_DT_INT16);\n        tmp.elempack = gray ? 1 : 4;\n        mat = tmp.clone();\n        stbi_image_free(data);\n    }\n}",
    "EStatusCode TIFFImageHandler::ReadTopLevelTiffInformation()\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\ttdir_t directorycount = TIFFNumberOfDirectories(mT2p->input);\n\ttdir_t i=0;\n\tuint16_t pagen=0;\n\tuint16_t paged=0;\n\tuint16_t xuint16_t=0;\n\n\tdo\n\t{\n\t\t// allocate tiff pages\n\t\tmT2p->tiff_pages = (T2P_PAGE*) _TIFFmalloc(directorycount * sizeof(T2P_PAGE));\n\t\tif(!mT2p->tiff_pages)\n\t\t{\n\t\t\tTRACE_LOG2(\"Can't allocate %u bytes of memory for tiff_pages array, %s\",\n\t\t\t\t\t\tdirectorycount * sizeof(T2P_PAGE),mT2p->inputFilePath.c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t\t_TIFFmemset( mT2p->tiff_pages, 0x00, directorycount * sizeof(T2P_PAGE));\n\t\n\t\t// allocate tile array, one for each page\n\t\tmT2p->tiff_tiles = (T2P_TILES*) _TIFFmalloc(directorycount * sizeof(T2P_TILES));\n\t\tif(!mT2p->tiff_tiles)\n\t\t{\n\t\t\tTRACE_LOG2(\"Can't allocate %u bytes of memory for tiff_tiles array, %s\",\n\t\t\t\t\t\tdirectorycount * sizeof(T2P_PAGE),mT2p->inputFilePath.c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\t\t_TIFFmemset( mT2p->tiff_tiles, 0x00, directorycount * sizeof(T2P_TILES));\n\n\t\tfor(i=0;i<directorycount;i++)\n\t\t{\n\t\t\tbool isPage = false,isPage2 = false;\n\t\t\tuint32_t subfiletype = 0;\n\t\t\t\n\t\t\tif(!TIFFSetDirectory(mT2p->input, i)){\n\t\t\t\tTRACE_LOG2(\"Can't set directory %u of input file %s\",\n\t\t\t\t\t\t\tdirectorycount * sizeof(T2P_PAGE),mT2p->inputFilePath.c_str());\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\t}\t\t\t\n\n\t\t\tif(TIFFGetField(mT2p->input, TIFFTAG_PAGENUMBER, &pagen, &paged))\n\t\t\t{\n\t\t\t\tmT2p->tiff_pages[mT2p->tiff_pagecount].page_number =\n\t\t\t\t\t((pagen>paged) && (paged != 0)) ? paged : pagen;\n\t\t\t\tisPage2 = true;\n\t\t\t} \n\t\t\telse if(TIFFGetField(mT2p->input, TIFFTAG_SUBFILETYPE, &subfiletype))\n\t\t\t{\n\t\t\t\tisPage = ((subfiletype & FILETYPE_PAGE) != 0) || (subfiletype == 0);\n\t\t\t} \n\t\t\telse if(TIFFGetField(mT2p->input, TIFFTAG_OSUBFILETYPE, &subfiletype))\n\t\t\t{\n\t\t\t\tisPage =\t(subfiletype == OFILETYPE_IMAGE) || \n\t\t\t\t\t\t\t(subfiletype == OFILETYPE_PAGE)\t || \n\t\t\t\t\t\t\t(subfiletype == 0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tisPage = true;\n\t\t\t\tisPage2 = true;\n\t\t\t}\n\n\t\t\tif(isPage)\n\t\t\t\tmT2p->tiff_pages[mT2p->tiff_pagecount].page_number=mT2p->tiff_pagecount;\n\t\t\tif(isPage || isPage2)\n\t\t\t{\n\t\t\t\tmT2p->tiff_pages[mT2p->tiff_pagecount].page_directory=i;\n\t\t\t\tif(TIFFIsTiled(mT2p->input))\n\t\t\t\t{\n\t\t\t\t\tmT2p->tiff_pages[mT2p->tiff_pagecount].page_tilecount = \n\t\t\t\t\t\tTIFFNumberOfTiles(mT2p->input);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmT2p->tiff_pagecount++;\n\t\t}\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tqsort((void*) mT2p->tiff_pages, mT2p->tiff_pagecount,sizeof(T2P_PAGE), t2p_cmp_t2p_page);\n\n\t\tfor(i=0;i<mT2p->tiff_pagecount;i++)\n\t\t{\n\t\t\tTIFFSetDirectory(mT2p->input, mT2p->tiff_pages[i].page_directory );\n\t\t\tif((TIFFGetField(mT2p->input, TIFFTAG_PHOTOMETRIC, &xuint16_t)\n\t\t\t\t\t\t&& (xuint16_t==PHOTOMETRIC_PALETTE))\n\t\t\t   || TIFFGetField(mT2p->input, TIFFTAG_INDEXED, &xuint16_t)) \n\t\t\t{\n\t\t\t\tmT2p->tiff_pages[i].page_extra++;\n\t\t\t}\n\t\t\tif (TIFFGetField(mT2p->input, TIFFTAG_TRANSFERFUNCTION,\n\t\t\t\t\t\t\t\t\t &(mT2p->tiff_transferfunction[0]),\n\t\t\t\t\t\t\t\t\t &(mT2p->tiff_transferfunction[1]),\n\t\t\t\t\t\t\t\t\t &(mT2p->tiff_transferfunction[2]))) \n\t\t\t{\n\t\t\t\tif(mT2p->tiff_transferfunction[1] !=\n\t\t\t\t   mT2p->tiff_transferfunction[0]) \n\t\t\t\t{\n\t\t\t\t\tmT2p->tiff_transferfunctioncount = 3;\n\t\t\t\t\tmT2p->tiff_pages[i].page_extra += 4;\n\t\t\t\t} \n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tmT2p->tiff_transferfunctioncount = 1;\n\t\t\t\t\tmT2p->tiff_pages[i].page_extra += 2;\n\t\t\t\t}\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tmT2p->tiff_transferfunctioncount=0;\n\t\t\t}\n\t\t\tif(TIFFGetField(\n\t\t\t\tmT2p->input, \n\t\t\t\tTIFFTAG_ICCPROFILE, \n\t\t\t\t&(mT2p->tiff_iccprofilelength), \n\t\t\t\t&(mT2p->tiff_iccprofile)) != 0)\n\t\t\t{\n\t\t\t\tmT2p->tiff_pages[i].page_extra++;\n\t\t\t}\n\t\t\tmT2p->tiff_tiles[i].tiles_tilecount = mT2p->tiff_pages[i].page_tilecount;\n\t\t\tif( (TIFFGetField(mT2p->input, TIFFTAG_PLANARCONFIG, &xuint16_t) != 0)\n\t\t\t\t&& (xuint16_t == PLANARCONFIG_SEPARATE ) )\n\t\t\t{\n\t\t\t\t\tTIFFGetField(mT2p->input, TIFFTAG_SAMPLESPERPIXEL, &xuint16_t);\n\t\t\t\t\tmT2p->tiff_tiles[i].tiles_tilecount/= xuint16_t;\n\t\t\t}\n\t\t\tif( mT2p->tiff_tiles[i].tiles_tilecount > 0)\n\t\t\t{\n\t\t\t\tTIFFGetField(mT2p->input, \n\t\t\t\t\tTIFFTAG_TILEWIDTH, \n\t\t\t\t\t&(mT2p->tiff_tiles[i].tiles_tilewidth));\n\t\t\t\tTIFFGetField(mT2p->input, \n\t\t\t\t\tTIFFTAG_TILELENGTH, \n\t\t\t\t\t&(mT2p->tiff_tiles[i].tiles_tilelength) );\n\t\t\t\tmT2p->tiff_tiles[i].tiles_tiles = \n\t\t\t\t(T2P_TILE*) _TIFFmalloc(\n\t\t\t\t\tmT2p->tiff_tiles[i].tiles_tilecount \n\t\t\t\t\t* sizeof(T2P_TILE) );\n\t\t\t\tif(!mT2p->tiff_tiles[i].tiles_tiles)\n\t\t\t\t{\n\n\t\t\t\t\tTRACE_LOG2(\"Can't allocate %u bytes of memory for tiles, %s\",\n\t\t\t\t\t\t\t\tmT2p->tiff_tiles[i].tiles_tilecount * sizeof(T2P_TILE),\n\t\t\t\t\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\n\t\n\t}while(false);\n\treturn status;\n}",
    "EStatusCode TIFFImageHandler::ReadTIFFPageInformation() //t2p_read_tiff_data\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\tuint16_t xuint16_t;\n\tuint16_t* xuint16_tp;\n\tfloat* xfloatp;\n\n\tmT2p->pdf_transcode = T2P_TRANSCODE_ENCODE;\n\tTIFFSetDirectory(mT2p->input, mT2p->tiff_pages[mT2p->pdf_page].page_directory);\n\tTIFFGetField(mT2p->input, TIFFTAG_IMAGEWIDTH, &(mT2p->tiff_width));\n\n\tdo\n\t{\n\t\tTIFFGetField(mT2p->input, TIFFTAG_IMAGEWIDTH, &(mT2p->tiff_width));\n\t\tif(0 == mT2p->tiff_width)\n\t\t{\n\t\t\tTRACE_LOG1(\"TIFFImageHandler::ReadTIFFPageInformation: No support for %s with zero width\",\n\t\t\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tTIFFGetField(mT2p->input, TIFFTAG_IMAGELENGTH, &(mT2p->tiff_length));\n\t\tif(0 == mT2p->tiff_length)\n\t\t{\n\t\t\tTRACE_LOG1(\"TIFFImageHandler::ReadTIFFPageInformation: No support for %s with zero length\",\n\t\t\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n        if(TIFFGetField(mT2p->input, TIFFTAG_COMPRESSION, &mT2p->tiff_compression) == 0)\n\t\t{\n\t\t\tTRACE_LOG1(\"TIFFImageHandler::ReadTIFFPageInformation: No support for %s with no compression tag\",\n\t\t\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\n        }\n\n        if( TIFFIsCODECConfigured(mT2p->tiff_compression) == 0)\n\t\t{\n\t\t\tTRACE_LOG2(\n\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation: No support for %s with compression type %u:  not configured\", \n\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\tmT2p->tiff_compression);\t\t\t\t\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tTIFFGetFieldDefaulted(mT2p->input, TIFFTAG_BITSPERSAMPLE, &(mT2p->tiff_bitspersample));\n\t\tswitch(mT2p->tiff_bitspersample)\n\t\t{\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\tcase 4:\n\t\t\tcase 8:\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tTRACE_LOG1(\n\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation: Image %s has 0 bits per sample, assuming 1\", \n\t\t\t\t\tmT2p->inputFilePath.c_str());\t\t\t\t\n\t\t\t\tmT2p->tiff_bitspersample = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tTRACE_LOG2(\n\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation: No support for %s with %u bits per sample\", \n\t\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\t\tmT2p->tiff_bitspersample);\t\t\t\t\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t}\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tTIFFGetFieldDefaulted(mT2p->input, TIFFTAG_SAMPLESPERPIXEL, &(mT2p->tiff_samplesperpixel));\n\t\tif(mT2p->tiff_samplesperpixel>4)\n\t\t{\n\t\t\tTRACE_LOG2(\n\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation: No support for %s with %u samples per pixel\", \n\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\tmT2p->tiff_samplesperpixel);\t\t\t\t\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(mT2p->tiff_samplesperpixel==0)\n\t\t{\n\t\t\tTRACE_LOG1(\n\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation: Image %s has 0 samples per pixel, assuming 1\", \n\t\t\t\tmT2p->inputFilePath.c_str());\t\n\t\t\tmT2p->tiff_samplesperpixel=1;\n\t\t}\n\t\n\t\tif(TIFFGetField(mT2p->input, TIFFTAG_SAMPLEFORMAT, &xuint16_t) != 0 )\n\t\t{\n\t\t\tswitch(xuint16_t)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\tcase 1:\n\t\t\t\tcase 4:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tTRACE_LOG2(\n\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation: No support for %s with sample format %u\", \n\t\t\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\t\t\txuint16_t);\t\t\t\t\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t\n\t\tTIFFGetFieldDefaulted(mT2p->input, TIFFTAG_FILLORDER, &(mT2p->tiff_fillorder));\n        if(TIFFGetField(mT2p->input, TIFFTAG_PHOTOMETRIC, &(mT2p->tiff_photometric)) == 0)\n\t\t{\n\t\t\tTRACE_LOG1(\"TIFFImageHandler::ReadTIFFPageInformation: No support for %s with no photometric interpretation tag\",\n\t\t\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n        }\n\n\t\tswitch(mT2p->tiff_photometric)\n\t\t{\n\t\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\t\tcase PHOTOMETRIC_MINISBLACK: \n\t\t\t\tif (mT2p->tiff_bitspersample==1){\n\t\t\t\t\tmT2p->pdf_colorspace=T2P_CS_BILEVEL;\n\t\t\t\t\tif(mT2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){\n\t\t\t\t\t\tmT2p->pdf_switchdecode ^= 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmT2p->pdf_colorspace=T2P_CS_GRAY;\n\t\t\t\t\tif(mT2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){\n\t\t\t\t\t\tmT2p->pdf_switchdecode ^= 1;\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_RGB: \n\t\t\t\tmT2p->pdf_colorspace=T2P_CS_RGB;\n\t\t\t\tif(mT2p->tiff_samplesperpixel == 3)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(TIFFGetField(mT2p->input, TIFFTAG_INDEXED, &xuint16_t))\n\t\t\t\t{\n\t\t\t\t\tif(xuint16_t==1)\n\t\t\t\t\t\tReadPhotometricPalette();\n\t\t\t\t}\n\t\t\t\tif(mT2p->tiff_samplesperpixel > 3) \n\t\t\t\t{\n\t\t\t\t\tif(mT2p->tiff_samplesperpixel == 4) \n\t\t\t\t\t{\n\t\t\t\t\t\tmT2p->pdf_colorspace = T2P_CS_RGB;\n\t\t\t\t\t\tif(TIFFGetField(mT2p->input,\n\t\t\t\t\t\t\t\tTIFFTAG_EXTRASAMPLES,\n\t\t\t\t\t\t\t\t&xuint16_t, &xuint16_tp)\n\t\t\t\t\t\t   && xuint16_t == 1) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(xuint16_tp[0] == EXTRASAMPLE_ASSOCALPHA)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmT2p->pdf_sample=T2P_SAMPLE_RGBAA_TO_RGB;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(xuint16_tp[0] == EXTRASAMPLE_UNASSALPHA)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmT2p->pdf_sample=T2P_SAMPLE_RGBA_TO_RGB;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tTRACE_LOG1(\n\t\t\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, RGB image %s has 4 samples per pixel, assuming RGBA\",\n\t\t\t\t\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmT2p->pdf_colorspace=T2P_CS_CMYK;\n\t\t\t\t\t\tmT2p->pdf_switchdecode ^= 1;\n\t\t\t\t\t\tTRACE_LOG1(\n\t\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, RGB image %s has 4 samples per pixel, assuming CMYK\",\n\t\t\t\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} \n\t\t\t\t\telse \n\t\t\t\t\t{\n\t\t\t\t\t\tTRACE_LOG2(\n\t\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for RGB image %s with %u samples per pixel\",\n\t\t\t\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\t\t\t\tmT2p->tiff_samplesperpixel\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tTRACE_LOG2(\n\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for RGB image %s with %u samples per pixel\",\n\t\t\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\t\t\tmT2p->tiff_samplesperpixel\n\t\t\t\t\t\t);\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase PHOTOMETRIC_PALETTE: \n\t\t\t\tstatus = ReadPhotometricPalette();\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_SEPARATED:\n\t\t\t\tif(TIFFGetField(mT2p->input, TIFFTAG_INDEXED, &xuint16_t))\n\t\t\t\t{\n\t\t\t\t\tif(xuint16_t==1)\n\t\t\t\t\t\tReadPhotometricPaletteCMYK();\n\t\t\t\t}\n\t\t\t\tif( TIFFGetField(mT2p->input, TIFFTAG_INKSET, &xuint16_t) )\n\t\t\t\t{\n\t\t\t\t\tif(xuint16_t != INKSET_CMYK)\n\t\t\t\t\t{\n\t\t\t\t\t\tTRACE_LOG1(\n\t\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for %s because its inkset is not CMYK\",\n\t\t\t\t\t\t\tmT2p->inputFilePath.c_str()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(mT2p->tiff_samplesperpixel==4)\n\t\t\t\t{\n\t\t\t\t\tmT2p->pdf_colorspace=T2P_CS_CMYK;\n\t\t\t\t} \n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tTRACE_LOG2(\n\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for %s because it has %u samples per pixel\",\n\t\t\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\t\t\tmT2p->tiff_samplesperpixel\n\t\t\t\t\t\t);\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_YCBCR:\n\t\t\t\tmT2p->pdf_colorspace=T2P_CS_RGB;\n\t\t\t\tif(mT2p->tiff_samplesperpixel==1)\n\t\t\t\t{\n\t\t\t\t\tmT2p->pdf_colorspace=T2P_CS_GRAY;\n\t\t\t\t\tmT2p->tiff_photometric=PHOTOMETRIC_MINISBLACK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmT2p->pdf_sample=T2P_SAMPLE_YCBCR_TO_RGB;\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_CIELAB:\n\t\t\t\tmT2p->pdf_labrange[0]= -127;\n\t\t\t\tmT2p->pdf_labrange[1]= 127;\n\t\t\t\tmT2p->pdf_labrange[2]= -127;\n\t\t\t\tmT2p->pdf_labrange[3]= 127;\n\t\t\t\tmT2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;\n\t\t\t\tmT2p->pdf_colorspace=T2P_CS_LAB;\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_ICCLAB:\n\t\t\t\tmT2p->pdf_labrange[0]= 0;\n\t\t\t\tmT2p->pdf_labrange[1]= 255;\n\t\t\t\tmT2p->pdf_labrange[2]= 0;\n\t\t\t\tmT2p->pdf_labrange[3]= 255;\n\t\t\t\tmT2p->pdf_colorspace=T2P_CS_LAB;\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_ITULAB:\n\t\t\t\tmT2p->pdf_labrange[0]=-85;\n\t\t\t\tmT2p->pdf_labrange[1]=85;\n\t\t\t\tmT2p->pdf_labrange[2]=-75;\n\t\t\t\tmT2p->pdf_labrange[3]=124;\n\t\t\t\tmT2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;\n\t\t\t\tmT2p->pdf_colorspace=T2P_CS_LAB;\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_LOGL:\n\t\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\t\tTRACE_LOG1(\n\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for %s with photometric interpretation LogL/LogLuv\",\n\t\t\t\t\tmT2p->inputFilePath.c_str()\n\t\t\t\t\t);\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tTRACE_LOG1(\n\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for %s with photometric interpretation %u\",\n\t\t\t\t\tmT2p->inputFilePath.c_str()\n\t\t\t\t\t);\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tbreak;\n\t\t}\n\t\tif(status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tif(TIFFGetField(mT2p->input, TIFFTAG_PLANARCONFIG, &(mT2p->tiff_planar)))\n\t\t{\n\t\t\tswitch(mT2p->tiff_planar)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tTRACE_LOG1(\n\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, Image %s has planar configuration 0, assuming 1\", \n\t\t\t\t\t\tmT2p->inputFilePath.c_str());\n\t\t\t\t\tmT2p->tiff_planar=PLANARCONFIG_CONTIG;\n\t\t\t\tcase PLANARCONFIG_CONTIG:\n\t\t\t\t\tbreak;\n\t\t\t\tcase PLANARCONFIG_SEPARATE:\n\t\t\t\t\tmT2p->pdf_sample=T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG;\n\t\t\t\t\tif(mT2p->tiff_bitspersample!=8)\n\t\t\t\t\t{\n\t\t\t\t\t\tTRACE_LOG2(\n\t\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for %s with separated planar configuration and %u bits per sample\", \n\t\t\t\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\t\t\t\tmT2p->tiff_bitspersample);\n\t\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tTRACE_LOG2(\n\t\t\t\t\t\t\"TIFFImageHandler::ReadTIFFPageInformation, No support for %s with planar configuration %u\", \n\t\t\t\t\t\tmT2p->inputFilePath.c_str(),\n\t\t\t\t\t\tmT2p->tiff_planar);\n\t\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(status != PDFHummus::eSuccess)\n\t\t\t\tbreak;\n\t\t}\n\n        TIFFGetFieldDefaulted(mT2p->input, TIFFTAG_ORIENTATION,\n                              &(mT2p->tiff_orientation));\n        if(mT2p->tiff_orientation>8)\n\t\t{\n                TRACE_LOG2(\"TIFFImageHandler::ReadTIFFPageInformation, Image %s has orientation %u, assuming 0\",\n                            mT2p->inputFilePath.c_str(), \n\t\t\t\t\t\t\tmT2p->tiff_orientation);\n                mT2p->tiff_orientation=0;\n        }\n\n        if(TIFFGetField(mT2p->input, TIFFTAG_XRESOLUTION, &(mT2p->tiff_xres) ) == 0)\n\t\t{\n                mT2p->tiff_xres=0.0;\n        }\n        if(TIFFGetField(mT2p->input, TIFFTAG_YRESOLUTION, &(mT2p->tiff_yres) ) == 0)\n\t\t{\n                mT2p->tiff_yres=0.0;\n        }\n\t\tTIFFGetFieldDefaulted(mT2p->input, TIFFTAG_RESOLUTIONUNIT,&(mT2p->tiff_resunit));\n\t\tif(mT2p->tiff_resunit == RESUNIT_CENTIMETER) \n\t\t{\n\t\t\tmT2p->tiff_xres *= 2.54F;\n\t\t\tmT2p->tiff_yres *= 2.54F;\n\t\t} \n\t\telse if (mT2p->tiff_resunit != RESUNIT_INCH && mT2p->pdf_centimeters != 0) \n\t\t{\n\t\t\tmT2p->tiff_xres *= 2.54F;\n\t\t\tmT2p->tiff_yres *= 2.54F;\n\t\t}\n\n\t\tComposePDFPage();\n\n\t\tmT2p->pdf_transcode = T2P_TRANSCODE_ENCODE;\n\t\tif(mT2p->pdf_nopassthrough==0)\n\t\t{\n\t\t\tif(mT2p->tiff_compression==COMPRESSION_CCITTFAX4)\n\t\t\t{\n\t\t\t\tif(TIFFIsTiled(mT2p->input) || (TIFFNumberOfStrips(mT2p->input)==1) )\n\t\t\t\t{\n\t\t\t\t\tmT2p->pdf_transcode = T2P_TRANSCODE_RAW;\n\t\t\t\t\tmT2p->pdf_compression=T2P_COMPRESS_G4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mT2p->tiff_compression== COMPRESSION_ADOBE_DEFLATE \n\t\t\t\t|| mT2p->tiff_compression==COMPRESSION_DEFLATE)\n\t\t\t{\n\t\t\t\tif(TIFFIsTiled(mT2p->input) || (TIFFNumberOfStrips(mT2p->input)==1) )\n\t\t\t\t{\n\t\t\t\t\tmT2p->pdf_transcode = T2P_TRANSCODE_RAW;\n\t\t\t\t\tmT2p->pdf_compression=T2P_COMPRESS_ZIP;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(mT2p->pdf_transcode!=T2P_TRANSCODE_RAW)\n\t\t{\n\t\t\tmT2p->pdf_compression = mT2p->pdf_defaultcompression;\n\t\t}\n\n\t\tif(mT2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE)\n\t\t{\n\t\t\tif(mT2p->pdf_colorspace & T2P_CS_CMYK)\n\t\t\t{\n\t\t\t\tmT2p->tiff_samplesperpixel=4;\n\t\t\t\tmT2p->tiff_photometric=PHOTOMETRIC_SEPARATED;\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tmT2p->tiff_samplesperpixel=3;\n\t\t\t\tmT2p->tiff_photometric=PHOTOMETRIC_RGB;\n\t\t\t}\n\t\t}\n\n\t\tif (TIFFGetField(mT2p->input, TIFFTAG_TRANSFERFUNCTION,\n\t\t\t\t &(mT2p->tiff_transferfunction[0]),\n\t\t\t\t &(mT2p->tiff_transferfunction[1]),\n\t\t\t\t &(mT2p->tiff_transferfunction[2]))) \n\t\t{\n\t\t\tif(mT2p->tiff_transferfunction[1] !=\n\t\t\t   mT2p->tiff_transferfunction[0]) \n\t\t\t{\n\t\t\t\tmT2p->tiff_transferfunctioncount=3;\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tmT2p->tiff_transferfunctioncount=1;\n\t\t\t}\n\t\t} \n\t\telse \n\t\t{\n\t\t\tmT2p->tiff_transferfunctioncount=0;\n\t\t}\n\t\tif(TIFFGetField(mT2p->input, TIFFTAG_WHITEPOINT, &xfloatp)!=0)\n\t\t{\n\t\t\tmT2p->tiff_whitechromaticities[0]=xfloatp[0];\n\t\t\tmT2p->tiff_whitechromaticities[1]=xfloatp[1];\n\t\t\tif(mT2p->pdf_colorspace & T2P_CS_GRAY)\n\t\t\t{\n\t\t\t\tmT2p->pdf_colorspace = (t2p_cs_t)(mT2p->pdf_colorspace | T2P_CS_CALGRAY);\n\t\t\t}\n\t\t\tif(mT2p->pdf_colorspace & T2P_CS_RGB)\n\t\t\t{\n\t\t\t\tmT2p->pdf_colorspace = (t2p_cs_t)(mT2p->pdf_colorspace | T2P_CS_CALRGB);\n\t\t\t}\n\t\t}\n\t\tif(TIFFGetField(mT2p->input, TIFFTAG_PRIMARYCHROMATICITIES, &xfloatp)!=0)\n\t\t{\n\t\t\tmT2p->tiff_primarychromaticities[0]=xfloatp[0];\n\t\t\tmT2p->tiff_primarychromaticities[1]=xfloatp[1];\n\t\t\tmT2p->tiff_primarychromaticities[2]=xfloatp[2];\n\t\t\tmT2p->tiff_primarychromaticities[3]=xfloatp[3];\n\t\t\tmT2p->tiff_primarychromaticities[4]=xfloatp[4];\n\t\t\tmT2p->tiff_primarychromaticities[5]=xfloatp[5];\n\t\t\tif(mT2p->pdf_colorspace & T2P_CS_RGB)\n\t\t\t{\n\t\t\t\tmT2p->pdf_colorspace = (t2p_cs_t)(mT2p->pdf_colorspace | T2P_CS_CALRGB);\n\t\t\t}\n\t\t}\n\t\tif(mT2p->pdf_colorspace & T2P_CS_LAB)\n\t\t{\n\t\t\tif(TIFFGetField(mT2p->input, TIFFTAG_WHITEPOINT, &xfloatp) != 0)\n\t\t\t{\n\t\t\t\tmT2p->tiff_whitechromaticities[0]=xfloatp[0];\n\t\t\t\tmT2p->tiff_whitechromaticities[1]=xfloatp[1];\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tmT2p->tiff_whitechromaticities[0]=0.3457F; /* 0.3127F; */\n\t\t\t\tmT2p->tiff_whitechromaticities[1]=0.3585F; /* 0.3290F; */\n\t\t\t}\n\t\t}\n\t\tif(TIFFGetField(mT2p->input, \n\t\t\tTIFFTAG_ICCPROFILE, \n\t\t\t&(mT2p->tiff_iccprofilelength), \n\t\t\t&(mT2p->tiff_iccprofile))!=0){\n\t\t\tmT2p->pdf_colorspace = (t2p_cs_t)(mT2p->pdf_colorspace | T2P_CS_ICCBASED);\n\t\t} \n\t\telse \n\t\t{\n\t\t\tmT2p->tiff_iccprofilelength=0;\n\t\t\tmT2p->tiff_iccprofile=NULL;\n\t\t}\n\t\t\n\t\tif( mT2p->tiff_bitspersample==1 &&\n\t\t\tmT2p->tiff_samplesperpixel==1)\n\t\t{\n\t\t\tmT2p->pdf_compression = T2P_COMPRESS_G4;\n\t\t}\n\t}while(false);\n\n\treturn status;\n}",
    "void TIFFImageHandler::CalculateTiffTileSize(int inTileIndex)\n{\n\tuint16_t edge=0;\n\n\tedge |= (uint16_t)TileIsRightEdge(inTileIndex);\n\tedge |= (uint16_t)TileIsBottomEdge(inTileIndex);\n\t\n\tif(mT2p->pdf_transcode==T2P_TRANSCODE_RAW)\n\t{\n\t\tif(edge)\n\t\t{\n\t\t\tmT2p->tiff_datasize=TIFFTileSize(mT2p->input);\n\t\t} else \n\t\t{\n\t\t\t// \tTIFFTAG_TILEBYTECOUNTS changed in tiff 4.0.0;\n\n\t\t\ttsize_t_compat* tbc = NULL;\n\t\t\tTIFFGetField(mT2p->input, TIFFTAG_TILEBYTECOUNTS, &tbc);\n\t\t\tmT2p->tiff_datasize=static_cast<tsize_t>(tbc[inTileIndex]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tmT2p->tiff_datasize=TIFFTileSize(mT2p->input);\n\t\tif(mT2p->tiff_planar==PLANARCONFIG_SEPARATE)\n\t\t\tmT2p->tiff_datasize*= mT2p->tiff_samplesperpixel;\n\t}\n}",
    "bool tiffToQImage( const char * data, int size, QImage & image )\n{\n  QByteArray arr = QByteArray::fromRawData( data, size );\n  QBuffer buf;\n  buf.setData( arr );\n  buf.open( QIODevice::ReadOnly );\n\n  TIFF *const tiff = TIFFClientOpen( \"foo\",\n                                     \"r\",\n                                     &buf,\n                                     tiffReadProc,\n                                     tiffWriteProc,\n                                     tiffSeekProc,\n                                     tiffCloseProc,\n                                     tiffSizeProc,\n                                     tiffMapProc,\n                                     tiffUnmapProc );\n  if( !tiff )\n    return false;\n\n  Uint32 width, height;\n  if( !TIFFGetField( tiff, TIFFTAG_IMAGEWIDTH, &width )\n      || !TIFFGetField( tiff, TIFFTAG_IMAGELENGTH, &height ) )\n  {\n    TIFFClose( tiff );\n    return false;\n  }\n\n  Uint16 bitPerSample;\n  if( !TIFFGetField( tiff, TIFFTAG_BITSPERSAMPLE, &bitPerSample ) )\n    bitPerSample = 1;\n\n  Uint16 samplesPerPixel; // they may be e.g. grayscale with 2 samples per pixel\n  if( !TIFFGetField( tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel ) )\n    samplesPerPixel = 1;\n\n  if( bitPerSample == 1 && samplesPerPixel == 1 )\n  {\n    QImage tiffImage( width, height, QImage::Format_Mono );\n\n    QVector<QRgb> colortable( 2 );\n    colortable[0] = 0xffffffff;\n    colortable[1] = 0xff000000;\n    tiffImage.setColorTable( colortable );\n\n    for ( Uint32 y = 0; y < height; ++y )\n    {\n      if( TIFFReadScanline( tiff, tiffImage.scanLine( y ), y, 0 ) < 0 )\n      {\n        TIFFClose( tiff );\n        return false;\n      }\n    }\n\n    image = tiffImage;\n    TIFFClose( tiff );\n    return true;\n  }\n\n  TIFFClose( tiff );\n  return false;\n}",
    "ImageHeaders\nload_tiff_file_headers (std::string const& filename)\n{\n    ImageHeaders headers;\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetErrorHandler(tiff_error_handler);\n\n    TIFF* tif = TIFFOpen(filename.c_str(), \"r\");\n    if (tif == nullptr)\n        throw util::FileException(filename, \"TIFF file format not recognized\");\n\n    try\n    {\n        uint32_t width, height;\n        uint16_t channels, bits, sampleFormat;\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n        TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n        headers.width = width;\n        headers.height = height;\n        headers.channels = channels;\n        headers.type = IMAGE_TYPE_UNKNOWN;\n\n        if (bits == 8) {\n            switch(sampleFormat) {\n                case SAMPLEFORMAT_UINT:\n                    headers.type = IMAGE_TYPE_UINT8;\n                    break;\n                case SAMPLEFORMAT_INT:\n                    headers.type = IMAGE_TYPE_SINT8;\n                    break;\n                case SAMPLEFORMAT_IEEEFP:\n                    headers.type = IMAGE_TYPE_FLOAT;\n                    break;\n                default:\n                    break;\n            }\n        } else if (bits == 16) {\n            switch(sampleFormat) {\n                case SAMPLEFORMAT_UINT:\n                    headers.type = IMAGE_TYPE_UINT16;\n                    break;\n                case SAMPLEFORMAT_INT:\n                    headers.type = IMAGE_TYPE_SINT16;\n                    break;\n                case SAMPLEFORMAT_IEEEFP:\n                    headers.type = IMAGE_TYPE_FLOAT;\n                    break;\n                default:\n                    break;\n            }\n        } else if (bits == 32) {\n            switch(sampleFormat) {\n                case SAMPLEFORMAT_UINT:\n                    headers.type = IMAGE_TYPE_UINT32;\n                    break;\n                case SAMPLEFORMAT_INT:\n                    headers.type = IMAGE_TYPE_SINT32;\n                    break;\n                case SAMPLEFORMAT_IEEEFP:\n                    headers.type = IMAGE_TYPE_FLOAT;\n                    break;\n                default:\n                    break;\n            }\n        } else if (bits == 64) {\n            switch(sampleFormat) {\n                case SAMPLEFORMAT_UINT:\n                    headers.type = IMAGE_TYPE_UINT64;\n                    break;\n                case SAMPLEFORMAT_INT:\n                    headers.type = IMAGE_TYPE_SINT64;\n                    break;\n                case SAMPLEFORMAT_IEEEFP:\n                    headers.type = IMAGE_TYPE_FLOAT;\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        if (headers.type == IMAGE_TYPE_UNKNOWN){\n            throw util::Exception(\"TIFF file has unsupported bits and/or sample format.\");\n        }\n\n        TIFFClose(tif);\n        return headers;\n    }\n    catch (std::exception& e)\n    {\n        TIFFClose(tif);\n        throw;\n    }\n}",
    "ByteImage::Ptr\nload_tiff_file (std::string const& filename)\n{\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetErrorHandler(tiff_error_handler);\n\n    TIFF* tif = TIFFOpen(filename.c_str(), \"r\");\n    if (!tif)\n        throw util::Exception(\"TIFF file format not recognized\");\n\n    try\n    {\n        /* Read width and height from TIFF and create MVE image. */\n        uint32_t width, height;\n        uint16_t channels, bits;\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n        if (bits != 8)\n            throw util::Exception(\"Expected 8 bit TIFF file\");\n        ByteImage::Ptr image = ByteImage::create(width, height, channels);\n\n        /* Scanline based TIFF reading. */\n        uint32_t rowstride = TIFFScanlineSize(tif);\n        ByteImage::ImageData& data = image->get_data();\n        for (uint32_t row = 0; row < height; row++)\n        {\n            tdata_t row_pointer = &data[row * rowstride];\n            TIFFReadScanline(tif, row_pointer, row);\n        }\n\n        TIFFClose(tif);\n        return image;\n    }\n    catch (std::exception& e)\n    {\n        TIFFClose(tif);\n        throw;\n    }\n}",
    "RawImage::Ptr\nload_tiff_16_file (std::string const& filename)\n{\n    if (sizeof(uint16_t) != 2)\n        throw util::Exception(\"Need 16bit data type for TIFF image.\");\n\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetErrorHandler(tiff_error_handler);\n\n    TIFF* tif = TIFFOpen(filename.c_str(), \"r\");\n    if (!tif)\n        throw util::Exception(\"TIFF file format not recognized\");\n\n    try\n    {\n        /* Read width and height from TIFF and create MVE image. */\n        uint32_t width, height;\n        uint16_t channels, bits;\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n        if (bits != 16)\n            throw util::Exception(\"TIFF file bits per sample don't match\");\n\n        RawImage::Ptr image = Image<uint16_t>::create(width, height, channels);\n\n        /* Scanline based TIFF reading. */\n        uint32_t rowstride = TIFFScanlineSize(tif) / sizeof(uint16_t);\n        Image<uint16_t>::ImageData& data = image->get_data();\n        for (uint32_t row = 0; row < height; row++)\n        {\n            tdata_t row_pointer = &data[row * rowstride];\n            TIFFReadScanline(tif, row_pointer, row);\n        }\n\n        TIFFClose(tif);\n        return image;\n    }\n    catch (std::exception& e)\n    {\n        TIFFClose(tif);\n        throw;\n    }\n}",
    "FloatImage::Ptr\nload_tiff_float_file (std::string const& filename)\n{\n    if (sizeof(float) != 4)\n        throw util::Exception(\"Need 32bit data type for TIFF image.\");\n\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetErrorHandler(tiff_error_handler);\n\n    TIFF* tif = TIFFOpen(filename.c_str(), \"r\");\n    if (!tif)\n        throw util::Exception(\"TIFF file format not recognized\");\n\n    try\n    {\n        /* Read width and height from TIFF and create MVE image. */\n        uint32_t width, height;\n        uint16_t channels, bits;\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n        if (bits != 32)\n            throw util::Exception(\"TIFF file bits per sample don't match\");\n\n        FloatImage::Ptr image = Image<float>::create(width, height, channels);\n\n        /* Scanline based TIFF reading. */\n        uint32_t rowstride = TIFFScanlineSize(tif) / sizeof(float);\n        Image<float>::ImageData& data = image->get_data();\n        for (uint32_t row = 0; row < height; row++)\n        {\n            tdata_t row_pointer = &data[row * rowstride];\n            TIFFReadScanline(tif, row_pointer, row);\n        }\n\n        TIFFClose(tif);\n        return image;\n    }\n    catch (std::exception& e)\n    {\n        TIFFClose(tif);\n        throw;\n    }\n}",
    "int R2Image::\nReadTIFFFile(const char *filename)\n{\n#ifdef RN_USE_TIFF\n  // Open file\n  TIFF* tif = TIFFOpen(filename, \"r\");\n  if (!tif) {\n    RNFail(\"Unable to open TIFF file %s\\n\", filename);\n    return 0;\n  }\n\n  // Get image dimensions\n  uint32 w, h;\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n  size_t npixels = w * h;\n\n  // Allocate buffer for data\n  uint32* raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n  if (!raster) {\n    RNFail(\"Unable to allocate data for TIFF file %s\\n\", filename);\n    return 0;\n  }\n\n  // Read data into buffer\n  if (!TIFFReadRGBAImage(tif, w, h, raster, 0)) {\n    RNFail(\"Unable to read TIFF file %s\\n\", filename);\n    return 0;\n  }\n\n  // Initialize R2Image data\n  width = w;\n  height = h;\n  ncomponents = 3;\n  rowsize = ncomponents * width;\n  if ((rowsize % 4) != 0) rowsize = (rowsize / 4 + 1) * 4;\n  int nbytes = rowsize * height;\n  pixels = new unsigned char [nbytes];\n  if (!pixels) {\n    RNFail(\"Unable to allocate memory for TIFF file %s\", filename);\n    return 0;\n  }\n\n  // Fill R2Image pixel data \n  uint32 *rasterp = raster;\n  for (int j = 0; j < height; j++) {\n    unsigned char *p = &pixels[j*rowsize];\n    for (int i = 0; i < width; i++) {\n      uint32 pixel = *(rasterp++);\n      *(p++) = pixel & 0xFF;\n      *(p++) = (pixel >> 8) & 0xFF;\n      *(p++) = (pixel >> 16) & 0xFF;\n    }\n  }\n\n  // Free data\n  _TIFFfree(raster);\n\n  // Close file\n  TIFFClose(tif);\n\n  // Return success\n  return 1;\n#else\n  RNFail(\"TIFF not supported\");\n  return 0;\n#endif\n}",
    "void tiff_dims (TIFF *tiff_handle, std::vector<long> &fdims)\n    {\n        assert(fdims.size() == 2);\n        uint32_t image_length, image_width;\n        if (! TIFFGetField(tiff_handle, TIFFTAG_IMAGELENGTH, &image_length))\n            throw std::runtime_error(\"unable to get image length\");\n        if (! image_length)\n            throw std::runtime_error(\"dimension along column is not positive\");\n        if (! TIFFGetField(tiff_handle, TIFFTAG_IMAGEWIDTH, &image_width))\n            throw std::runtime_error(\"unable to get image width\");\n        if (! image_width)\n            throw std::runtime_error(\"dimension along row is not positive\");\n        fdims[0] = image_length;\n        fdims[1] = image_width;\n    }",
    "void moench_read_data (unsigned int tid,\n                           f_type * destination,\n                           const std::string &path,\n                           const std::vector<mwSize> &mdims,\n                           const std::vector<long> &im_ctr)\n    {\n        /*\n        std::vector<long> fdims{0, 0};\n        std::vector<float> fbuf(0);\n        {\n            TIFF *tiff_handle = TIFFOpen(path.c_str(), \"r\");\n            if (! tiff_handle)\n                throw std::runtime_error(std::string(\"unable to open file \") + path);\n            try {\n                tiff_dims(tiff_handle, fdims);\n                long nelems = fdims[0] * fdims[1];\n                fbuf.resize(nelems);\n                tmsize_t res, sz = fdims[1] * sizeof(float);\n                for (uint32_t strip=0; strip<fdims[0]; strip++) {\n                    float *pos = &fbuf[fdims[1] * strip];\n                    res = TIFFReadRawStrip(tiff_handle, strip, pos, sz);\n                    if (res != sz)\n                        throw std::runtime_error(\"unable to read tiff data\");\n                }\n            } catch (...) {\n                TIFFClose(tiff_handle);\n                throw;\n            }\n            TIFFClose(tiff_handle);\n        }\n        */\n        std::vector<long> fdims{0, 0};\n        std::vector<f_type> fbuf(0);\n        {\n            TIFF *tiff_handle = TIFFOpen(path.c_str(), \"r\");\n            if (! tiff_handle)\n                throw std::runtime_error(std::string(\"unable to open file \") + path);\n            try {\n                tiff_dims(tiff_handle, fdims);\n                long nelems = fdims[0] * fdims[1];\n                fbuf.resize(nelems);\n                std::uint16_t bps;\n                if (TIFFGetField(tiff_handle, TIFFTAG_BITSPERSAMPLE, &bps) != 1)\n                    throw std::runtime_error(std::string(\"unable to read number of bits per sample for file \") + path);\n                std::uint16_t format;\n                if (TIFFGetFieldDefaulted(tiff_handle, TIFFTAG_SAMPLEFORMAT, &format) != 1)\n                    throw std::runtime_error(std::string(\"unable to read sample format for file\") + path);\n                tstrip_t num_strips = TIFFNumberOfStrips(tiff_handle);\n                tsize_t strip_sz = TIFFStripSize(tiff_handle);\n                std::vector<char> cbuf(strip_sz);\n                switch (format) {\n                case 1:\n                    switch (bps) {\n                    case 8:\n                        tiff_read<std::uint8_t, f_type>(tiff_handle, cbuf, fbuf, num_strips); break;\n                    case 16:\n                        tiff_read<std::uint16_t, f_type>(tiff_handle, cbuf, fbuf, num_strips); break;\n                    case 32:\n                        tiff_read<std::uint32_t, f_type>(tiff_handle, cbuf, fbuf, num_strips); break;\n                    default:\n                        throw std::runtime_error(std::string(\"unsupported number of bits per unsigned integer sample in file \") + path);\n                    }\n                    break;\n                case 2:\n                    switch (bps) {\n                    case 8:\n                        tiff_read<std::int8_t, f_type>(tiff_handle, cbuf, fbuf, num_strips); break;\n                    case 16:\n                        tiff_read<std::int16_t, f_type>(tiff_handle, cbuf, fbuf, num_strips); break;\n                    case 32:\n                        tiff_read<std::int32_t, f_type>(tiff_handle, cbuf, fbuf, num_strips); break;\n                    default:\n                        throw std::runtime_error(std::string(\"unsupported number of bits per integer sample in file \") + path);\n                    }\n                    break;\n                case 3:\n                    switch (bps) {\n                    case 32:\n                        tiff_read<float, f_type>(tiff_handle, cbuf, fbuf, num_strips); break;\n                    case 64:\n                        tiff_read<double, f_type>(tiff_handle, cbuf, fbuf, num_strips); break;\n                    default:\n                        throw std::runtime_error(std::string(\"unsupported number of bits per ieee sample in file \") + path);\n                    }\n                    break;\n                default:\n                    throw std::runtime_error(std::string(\"unsupported sample format in file \") + path);\n                }\n            } catch (...) {\n                TIFFClose(tiff_handle);\n                throw;\n            }\n            TIFFClose(tiff_handle);\n        }\n        std::vector<long> fstride{0, 0};\n        std::vector<long> mstride{0, 0};\n        std::vector<long> count{0, 0};\n        adapt_dimensions(fdims, mdims, im_ctr, fstride, mstride, count);\n        DEBUG {\n            LOCK(mutex_cout);\n            OUT << thread_id << \":     fstride=[\" << fstride[0] << ',' << fstride[1] << \"], mstride=[\" << mstride[0] << ',' << mstride[1] << \"], count=[\" << count[0] << ',' << count[1] <<']' << std::endl;\n        }",
    "bool CxImageTIF::Decode(CxFile * hFile)\n{\n  //Comment this line if you need more information on errors\n  // TIFFSetErrorHandler(NULL);  //<Patrick Hoffmann>\n\n  //Open file and fill the TIFF structure\n  // m_tif = TIFFOpen(imageFileName,\"rb\");\n  TIFF* m_tif = _TIFFOpenEx(hFile, \"rb\");\n\n  uint32 height=0;\n  uint32 width=0;\n  uint16 bitspersample=1;\n  uint16 samplesperpixel=1;\n  uint32 rowsperstrip=(DWORD)-1;\n  uint16 photometric=0;\n  uint16 compression=1;\n  uint16 orientation=ORIENTATION_TOPLEFT; //<vho>\n  uint16 res_unit; //<Trifon>\n  uint32 x, y;\n  float resolution, offset;\n  BOOL isRGB;\n  BYTE *bits;    //pointer to source data\n  BYTE *bits2;  //pointer to destination data\n\n  cx_try\n  {\n  //check if it's a tiff file\n  if (!m_tif)\n    cx_throw(\"Error encountered while opening TIFF file\");\n\n  // <Robert Abram> - 12/2002 : get NumFrames directly, instead of looping\n  // info.nNumFrames=0;\n  // while(TIFFSetDirectory(m_tif,(uint16)info.nNumFrames)) info.nNumFrames++;\n  info.nNumFrames = TIFFNumberOfDirectories(m_tif);\n\n  if (!TIFFSetDirectory(m_tif, (uint16)info.nFrame))\n    cx_throw(\"Error: page not present in TIFF file\");      \n\n  //get image info\n  TIFFGetField(m_tif, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(m_tif, TIFFTAG_IMAGELENGTH, &height);\n  TIFFGetField(m_tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n  TIFFGetField(m_tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n  TIFFGetField(m_tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);   \n  TIFFGetField(m_tif, TIFFTAG_PHOTOMETRIC, &photometric);\n  TIFFGetField(m_tif, TIFFTAG_ORIENTATION, &orientation);\n\n  if (info.nEscape == -1) {\n    // Return output dimensions only\n    head.biWidth = width;\n    head.biHeight = height;\n    info.dwType = CXIMAGE_FORMAT_TIF;\n    cx_throw(\"output dimensions returned\");\n  }\n\n  TIFFGetFieldDefaulted(m_tif, TIFFTAG_RESOLUTIONUNIT, &res_unit);\n  if (TIFFGetField(m_tif, TIFFTAG_XRESOLUTION, &resolution))\n  {\n    if (res_unit == RESUNIT_CENTIMETER) resolution = (float)(resolution*2.54f + 0.5f);\n    SetXDPI((long)resolution);\n  }\n  if (TIFFGetField(m_tif, TIFFTAG_YRESOLUTION, &resolution))\n  {\n    if (res_unit == RESUNIT_CENTIMETER) resolution = (float)(resolution*2.54f + 0.5f);\n    SetYDPI((long)resolution);\n  }\n\n  if (TIFFGetField(m_tif, TIFFTAG_XPOSITION, &offset))  info.xOffset = (long)offset;\n  if (TIFFGetField(m_tif, TIFFTAG_YPOSITION, &offset))  info.yOffset = (long)offset;\n\n  head.biClrUsed=0;\n  info.nBkgndIndex =-1;\n\n  if (rowsperstrip>height){\n    rowsperstrip=height;\n    TIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n  }\n\n  isRGB = /*(bitspersample >= 8) && (VK: it is possible so for RGB to have < 8 bpp!)*/\n    (photometric == PHOTOMETRIC_RGB) ||\n    (photometric == PHOTOMETRIC_YCBCR) ||\n    (photometric == PHOTOMETRIC_SEPARATED) ||\n    (photometric == PHOTOMETRIC_LOGL) ||\n    (photometric == PHOTOMETRIC_LOGLUV);\n\n  if (isRGB){\n    head.biBitCount=24;\n  }else{\n    if ((photometric==PHOTOMETRIC_MINISBLACK)||(photometric==PHOTOMETRIC_MINISWHITE)||(photometric==PHOTOMETRIC_PALETTE)){\n      if  (bitspersample == 1){\n        head.biBitCount=1;    //B&W image\n        head.biClrUsed =2;\n      } else if (bitspersample == 4) {\n        head.biBitCount=4;    //16 colors gray scale\n        head.biClrUsed =16;\n      } else {\n        head.biBitCount=8;    //gray scale\n        head.biClrUsed =256;\n      }\n    } else if (bitspersample == 4) {\n      head.biBitCount=4;      // 16 colors\n      head.biClrUsed=16;\n    } else {\n      head.biBitCount=8;      //256 colors\n      head.biClrUsed=256;\n    }\n\n    if ((bitspersample > 8) && (photometric==PHOTOMETRIC_PALETTE))  // + VK + (BIG palette! => convert to RGB)\n    {  head.biBitCount=24;\n      head.biClrUsed =0;\n    }\n  }\n\n  if (info.nEscape) cx_throw(\"Cancelled\"); // <vho> - cancel decoding\n\n  Create(width,height,head.biBitCount,CXIMAGE_FORMAT_TIF);  //image creation\n  if (!pDib) cx_throw(\"CxImageTIF can't create image\");\n\n#if CXIMAGE_SUPPORT_ALPHA\n  if (samplesperpixel==4) AlphaCreate();  //add alpha support for 32bpp tiffs\n  if (samplesperpixel==2 && bitspersample==8) AlphaCreate();  //add alpha support for 8bpp + alpha\n#endif //CXIMAGE_SUPPORT_ALPHA\n\n  TIFFGetField(m_tif, TIFFTAG_COMPRESSION, &compression);\n  SetCodecOption(compression); // <DPR> save original compression type\n\n  if (isRGB) {\n    // Read the whole image into one big RGBA buffer using\n    // the traditional TIFFReadRGBAImage() API that we trust.\n    uint32* raster;    // retrieve RGBA image\n    uint32 *row;\n\n    raster = (uint32*)_TIFFmalloc(width * height * sizeof (uint32));\n    if (raster == NULL) cx_throw(\"No space for raster buffer\");\n      \n    // Read the image in one chunk into an RGBA array\n    if(!TIFFReadRGBAImage(m_tif, width, height, raster, 1)) {\n        _TIFFfree(raster);\n        cx_throw(\"Corrupted TIFF file!\");\n    }\n\n    // read the raster lines and save them in the DIB\n    // with RGB mode, we have to change the order of the 3 samples RGB\n    row = &raster[0];\n    bits2 = info.pImage;\n    for (y = 0; y < height; y++) {\n\n      if (info.nEscape){ // <vho> - cancel decoding\n        _TIFFfree(raster);\n        cx_throw(\"Cancelled\");\n      }\n\n      bits = bits2;\n      for (x = 0; x < width; x++) {\n        *bits++ = (BYTE)TIFFGetB(row[x]);\n        *bits++ = (BYTE)TIFFGetG(row[x]);\n        *bits++ = (BYTE)TIFFGetR(row[x]);\n#if CXIMAGE_SUPPORT_ALPHA\n        if (samplesperpixel==4) AlphaSet(x,y,(BYTE)TIFFGetA(row[x]));\n#endif //CXIMAGE_SUPPORT_ALPHA\n      }\n      row += width;\n      bits2 += info.dwEffWidth;\n    }\n    _TIFFfree(raster);\n  } else {\n    int BIG_palette = (bitspersample > 8) &&  // + VK\n              (photometric==PHOTOMETRIC_PALETTE);    \n    if (BIG_palette && (bitspersample > 24))  // + VK\n      cx_throw(\"Too big palette to handle\");    // + VK\n\n    RGBQUAD *pal;\n    pal=(RGBQUAD*)calloc(BIG_palette ? 1<<bitspersample : 256,sizeof(RGBQUAD)); \n      // ! VK: it coasts nothing but more correct to use 256 as temp palette storage\n      // ! VK: but for case of BIG palette it just copied\n    if (pal==NULL) cx_throw(\"Unable to allocate TIFF palette\");\n\n    int bpp = bitspersample <= 8 ? bitspersample : 8; // + VK (to use instead of bitspersample for case of > 8)\n\n    // set up the colormap based on photometric  \n    switch(photometric) {\n      case PHOTOMETRIC_MINISBLACK:  // bitmap and greyscale image types\n      case PHOTOMETRIC_MINISWHITE:\n        if (bitspersample == 1) {  // Monochrome image\n          if (photometric == PHOTOMETRIC_MINISBLACK) {\n            pal[1].rgbRed = pal[1].rgbGreen = pal[1].rgbBlue = 255;\n          } else {\n            pal[0].rgbRed = pal[0].rgbGreen = pal[0].rgbBlue = 255;\n          }\n        } else {    // need to build the scale for greyscale images\n          if (photometric == PHOTOMETRIC_MINISBLACK) {\n            for (int i=0; i<(1<<bpp); i++){\n              pal[i].rgbRed = pal[i].rgbGreen = pal[i].rgbBlue = (BYTE)(i*(255/((1<<bpp)-1)));\n            }\n          } else {\n            for (int i=0; i<(1<<bpp); i++){\n              pal[i].rgbRed = pal[i].rgbGreen = pal[i].rgbBlue = (BYTE)(255-i*(255/((1<<bpp)-1)));\n            }\n          }\n        }\n        break;\n      case PHOTOMETRIC_PALETTE:  // color map indexed\n        uint16 *red;\n        uint16 *green;\n        uint16 *blue;\n        TIFFGetField(m_tif, TIFFTAG_COLORMAP, &red, &green, &blue); \n\n        // Is the palette 16 or 8 bits ?\n        BOOL Palette16Bits = /*FALSE*/ BIG_palette;\n        if (!BIG_palette) {\n          int n= 1<<bpp;\n          while (n-- > 0) {\n            if (red[n] >= 256 || green[n] >= 256 || blue[n] >= 256) {\n              Palette16Bits=TRUE;\n              break;\n            }\n          }\n        }\n\n        // load the palette in the DIB\n        for (int i = (1 << ( BIG_palette ? bitspersample : bpp )) - 1; i >= 0; i--) {\n          if (Palette16Bits) {\n            pal[i].rgbRed =(BYTE) CVT(red[i]);\n            pal[i].rgbGreen = (BYTE) CVT(green[i]);\n            pal[i].rgbBlue = (BYTE) CVT(blue[i]);           \n          } else {\n            pal[i].rgbRed = (BYTE) red[i];\n            pal[i].rgbGreen = (BYTE) green[i];\n            pal[i].rgbBlue = (BYTE) blue[i];        \n          }\n        }\n        break;\n    }\n    if (!BIG_palette) { // + VK (BIG palette is stored until image is ready)\n      SetPalette(pal,/*head.biClrUsed*/ 1<<bpp);  //palette assign // * VK\n      free(pal); \n      pal = NULL; \n    }\n\n    // read the tiff lines and save them in the DIB\n    uint32 nrow;\n    uint32 ys;\n    int line = CalculateLine(width, bitspersample * samplesperpixel);\n    \n    long bitsize = TIFFStripSize(m_tif);\n    //verify bitsize: could be wrong if StripByteCounts is missing.\n    if (bitsize<(long)(head.biSizeImage*samplesperpixel))\n      bitsize = head.biSizeImage*samplesperpixel;\n\n    if ((bitspersample > 8) && (bitspersample != 16))  // + VK (for bitspersample == 9..15,17..32..64\n      bitsize *= (bitspersample + 7)/8; \n\n    int tiled_image = TIFFIsTiled(m_tif);\n    uint32 tw=0, tl=0;\n    BYTE* tilebuf=NULL;\n    if (tiled_image){\n      TIFFGetField(m_tif, TIFFTAG_TILEWIDTH, &tw);\n      TIFFGetField(m_tif, TIFFTAG_TILELENGTH, &tl);\n      rowsperstrip = tl;\n      bitsize = TIFFTileSize(m_tif) * (int)(1+width/tw);\n      tilebuf = (BYTE*)malloc(TIFFTileSize(m_tif));\n    }\n    \n    bits = (BYTE*)malloc(bitspersample==16? bitsize*2 : bitsize); // * VK\n    BYTE * bits16 = NULL;                      // + VK\n    int line16    = 0;                        // + VK\n\n    if (!tiled_image && bitspersample==16) {            // + VK +\n      line16 = line;\n      line   = CalculateLine(width, 8 * samplesperpixel);\n      bits16 = bits;\n      bits   = (BYTE*)malloc(bitsize);\n    }\n\n    if (bits==NULL){\n      if (bits16) free(bits16);                  // + VK\n      if (pal)  free(pal);                    // + VK\n      if (tilebuf)free(tilebuf);                  // + VK  \n      cx_throw(\"CxImageTIF can't allocate memory\");\n    }\n\n#ifdef FIX_16BPP_DARKIMG // + VK: for each line, store shift count bits used to fix it\n    BYTE* row_shifts = NULL;\n    if (bits16) row_shifts = (BYTE*)malloc(height); \n#endif\n\n    for (ys = 0; ys < height; ys += rowsperstrip) {\n\n      if (info.nEscape){ // <vho> - cancel decoding\n        free(bits);\n        cx_throw(\"Cancelled\");\n      }\n\n      nrow = (ys + rowsperstrip > height ? height - ys : rowsperstrip);\n\n      if (tiled_image){\n        uint32 imagew = TIFFScanlineSize(m_tif);\n        uint32 tilew  = TIFFTileRowSize(m_tif);\n        int iskew = imagew - tilew;\n        uint8* bufp = (uint8*) bits;\n\n        uint32 colb = 0;\n        for (uint32 col = 0; col < width; col += tw) {\n          if (TIFFReadTile(m_tif, tilebuf, col, ys, 0, 0) < 0){\n            free(tilebuf);\n            free(bits);\n            cx_throw(\"Corrupted tiled TIFF file!\");\n          }\n\n          if (colb + tw > imagew) {\n            uint32 owidth = imagew - colb;\n            uint32 oskew = tilew - owidth;\n            TileToStrip(bufp + colb, tilebuf, nrow, owidth, oskew + iskew, oskew );\n          } else {\n            TileToStrip(bufp + colb, tilebuf, nrow, tilew, iskew, 0);\n          }\n          colb += tilew;\n        }\n\n      } else {\n        if (TIFFReadEncodedStrip(m_tif, TIFFComputeStrip(m_tif, ys, 0), \n          (bits16? bits16 : bits), nrow * (bits16 ? line16 : line)) == -1) { // * VK\n\n#ifdef NOT_IGNORE_CORRUPTED\n          free(bits);\n          if (bits16) free(bits16);  // + VK\n          cx_throw(\"Corrupted TIFF file!\");\n#else\n          break;\n#endif\n        }\n      }\n\n      for (y = 0; y < nrow; y++) {\n        long offset=(nrow-y-1)*line;\n        if ((bitspersample==16) && !BIG_palette) {  // * VK\n          long offset16 = (nrow-y-1)*line16;    // + VK\n          if (bits16)  {              // + VK +\n#ifdef FIX_16BPP_DARKIMG\n            int the_shift;\n            BYTE hi_byte, hi_max=0;\n            DWORD xi;\n            for (xi=0;xi<(uint32)line;xi++) {\n              hi_byte = bits16[xi*2+offset16+1];\n              if(hi_byte>hi_max)\n                hi_max = hi_byte;\n            }\n            the_shift = (hi_max == 0) ? 8 : 0;\n            if (!the_shift)\n              while( ! (hi_max & 0x80) ) {\n                the_shift++;\n                hi_max <<= 1;\n              }\n            row_shifts[height-ys-nrow+y] = the_shift;\n            the_shift = 8 - the_shift;\n            for (xi=0;xi<(uint32)line;xi++) \n              bits[xi+offset]= ((bits16[xi*2+offset16+1]<<8) | bits16[xi*2+offset16]) >> the_shift;\n#else\n            for (DWORD xi=0;xi<(uint32)line;xi++) \n              bits[xi+offset]=bits16[xi*2+offset16+1];\n#endif\n          } else {\n            for (DWORD xi=0;xi<width;xi++)\n              bits[xi+offset]=bits[xi*2+offset+1];\n              }\n        }\n        if (samplesperpixel==1) { \n          if (BIG_palette)\n            if (bits16) {\n              long offset16 = (nrow-y-1)*line16;    // + VK\n              MoveBitsPal( info.pImage + info.dwEffWidth * (height-ys-nrow+y),\n                   bits16 + offset16, width, bitspersample, pal );\n            } else\n              MoveBitsPal( info.pImage + info.dwEffWidth * (height-ys-nrow+y),\n                   bits + offset, width, bitspersample, pal );\n          else if ((bitspersample == head.biBitCount) || \n            (bitspersample == 16))  //simple 8bpp, 4bpp image or 16bpp\n            memcpy(info.pImage+info.dwEffWidth*(height-ys-nrow+y),bits+offset,info.dwEffWidth);\n          else\n            MoveBits( info.pImage + info.dwEffWidth * (height-ys-nrow+y),\n                  bits + offset, width, bitspersample );\n        } else if (samplesperpixel==2) { //8bpp image with alpha layer\n          int xi=0;\n          int ii=0;\n          int yi=height-ys-nrow+y;\n#if CXIMAGE_SUPPORT_ALPHA\n          if (!pAlpha) AlphaCreate();      // + VK\n#endif //CXIMAGE_SUPPORT_ALPHA\n          while (ii<line){\n            SetPixelIndex(xi,yi,bits[ii+offset]);\n#if CXIMAGE_SUPPORT_ALPHA\n            AlphaSet(xi,yi,bits[ii+offset+1]);\n#endif //CXIMAGE_SUPPORT_ALPHA\n            ii+=2;\n            xi++;\n            if (xi>=(int)width){\n              yi--;\n              xi=0;\n            }\n          }\n        } else { //photometric==PHOTOMETRIC_CIELAB\n          if (head.biBitCount!=24){ //fix image\n            Create(width,height,24,CXIMAGE_FORMAT_TIF);\n#if CXIMAGE_SUPPORT_ALPHA\n            if (samplesperpixel==4) AlphaCreate();\n#endif //CXIMAGE_SUPPORT_ALPHA\n          }\n\n          int xi=0;\n          uint32 ii=0;\n          int yi=height-ys-nrow+y;\n          RGBQUAD c;\n          int l,a,b,bitsoffset;\n          double p,cx,cy,cz,cr,cg,cb;\n          while (ii</*line*/width){    // * VK\n            bitsoffset = ii*samplesperpixel+offset;\n            l=bits[bitsoffset];\n            a=bits[bitsoffset+1];\n            b=bits[bitsoffset+2];\n            if (a>127) a-=256;\n            if (b>127) b-=256;\n            // lab to xyz\n            p = (l/2.55 + 16) / 116.0;\n            cx = pow( p + a * 0.002, 3);\n            cy = pow( p, 3);\n            cz = pow( p - b * 0.005, 3);\n            // white point\n            cx*=0.95047;\n            //cy*=1.000;\n            cz*=1.0883;\n            // xyz to rgb\n            cr =  3.240479 * cx - 1.537150 * cy - 0.498535 * cz;\n            cg = -0.969256 * cx + 1.875992 * cy + 0.041556 * cz;\n            cb =  0.055648 * cx - 0.204043 * cy + 1.057311 * cz;\n\n            if ( cr > 0.00304 ) cr = 1.055 * pow(cr,0.41667) - 0.055;\n              else            cr = 12.92 * cr;\n            if ( cg > 0.00304 ) cg = 1.055 * pow(cg,0.41667) - 0.055;\n              else            cg = 12.92 * cg;\n            if ( cb > 0.00304 ) cb = 1.055 * pow(cb,0.41667) - 0.055;\n              else            cb = 12.92 * cb;\n\n            c.rgbRed  =(BYTE)max(0,min(255,(int)(cr*255)));\n            c.rgbGreen=(BYTE)max(0,min(255,(int)(cg*255)));\n            c.rgbBlue =(BYTE)max(0,min(255,(int)(cb*255)));\n\n            SetPixelColor(xi,yi,c);\n#if CXIMAGE_SUPPORT_ALPHA\n            if (samplesperpixel==4) AlphaSet(xi,yi,bits[bitsoffset+3]);\n#endif //CXIMAGE_SUPPORT_ALPHA\n            ii++;\n            xi++;\n            if (xi>=(int)width){\n              yi--;\n              xi=0;\n            }\n          }\n        }\n      }\n    }\n    free(bits);\n    if (bits16) free(bits16);\n\n#ifdef FIX_16BPP_DARKIMG\n    if (row_shifts && (samplesperpixel == 1) && (bitspersample==16) && !BIG_palette) {\n      // 1. calculate maximum necessary shift\n      int min_row_shift = 8;\n      for( y=0; y<height; y++ ) {\n        if (min_row_shift > row_shifts[y]) min_row_shift = row_shifts[y];\n      }\n      // 2. for rows having less shift value, correct such rows:\n      for( y=0; y<height; y++ ) {\n        if (min_row_shift < row_shifts[y]) {\n          int need_shift = row_shifts[y] - min_row_shift;\n          BYTE* data = info.pImage + info.dwEffWidth * y;\n          for( x=0; x<width; x++, data++ )\n            *data >>= need_shift;\n        }\n      }\n    }\n    if (row_shifts)  free( row_shifts );\n#endif\n\n    if (tiled_image) free(tilebuf);\n    if (pal)     free(pal);\n\n    switch(orientation){\n    case ORIENTATION_TOPRIGHT: /* row 0 top, col 0 rhs */\n      Mirror();\n      break;\n    case ORIENTATION_BOTRIGHT: /* row 0 bottom, col 0 rhs */\n      Flip();\n      Mirror();\n      break;\n    case ORIENTATION_BOTLEFT: /* row 0 bottom, col 0 lhs */\n      Flip();\n      break;\n    case ORIENTATION_LEFTTOP: /* row 0 lhs, col 0 top */\n      RotateRight();\n      Mirror();\n      break;\n    case ORIENTATION_RIGHTTOP: /* row 0 rhs, col 0 top */\n      RotateLeft();\n      break;\n    case ORIENTATION_RIGHTBOT: /* row 0 rhs, col 0 bottom */\n      RotateLeft();\n      Mirror();\n      break;\n    case ORIENTATION_LEFTBOT: /* row 0 lhs, col 0 bottom */\n      RotateRight();\n      break;\n    }\n\n  }\n  }",
    "int image::read_tiff(const std::string &filename) {\n  TIFF *tiff_handle;\n  size_t bytes_per_line;\n  uint16_t planar_configuration;\n  if ((tiff_handle = TIFFOpen(filename.c_str(), \"r\")) == nullptr) {\n    printf(\"ERROR: File %s is not found.\\n\", filename.c_str());\n    return EXIT_FAILURE;\n  }\n\n  uint32_t tiff_width  = 0;\n  uint32_t tiff_height = 0;\n  TIFFGetField(tiff_handle, TIFFTAG_IMAGEWIDTH, &tiff_width);\n  TIFFGetField(tiff_handle, TIFFTAG_IMAGELENGTH, &tiff_height);\n\n  uint16_t tiff_bits_per_sample   = 0;\n  uint16_t tiff_samples_per_pixel = 0;\n  TIFFGetField(tiff_handle, TIFFTAG_BITSPERSAMPLE, &tiff_bits_per_sample);\n  TIFFGetField(tiff_handle, TIFFTAG_SAMPLESPERPIXEL, &tiff_samples_per_pixel);\n  // some TIFs have tiff_samples_per_pixel=0 when it is a single channel\n  // image - set to 1\n  tiff_samples_per_pixel = (tiff_samples_per_pixel < 1) ? 1 : tiff_samples_per_pixel;\n\n  uint16_t tiff_planar_configuration = 0;\n  uint16_t tiff_photometric          = 0;\n  TIFFGetField(tiff_handle, TIFFTAG_PLANARCONFIG, &tiff_planar_configuration);\n  TIFFGetField(tiff_handle, TIFFTAG_PHOTOMETRIC, &tiff_photometric);\n\n  planar_configuration = tiff_planar_configuration;\n\n  uint16_t tiff_compression    = 0;\n  uint32_t tiff_rows_per_strip = 0;\n  TIFFGetField(tiff_handle, TIFFTAG_COMPRESSION, &tiff_compression);\n  TIFFGetField(tiff_handle, TIFFTAG_ROWSPERSTRIP, &tiff_rows_per_strip);\n\n  if (tiff_planar_configuration == PLANARCONFIG_SEPARATE) {\n    bytes_per_line = tiff_samples_per_pixel * TIFFScanlineSize64(tiff_handle);\n  } else {\n    bytes_per_line = TIFFScanlineSize64(tiff_handle);\n  }\n  // Error on known incompatilbe input formats\n  if (tiff_bits_per_sample != 8 && tiff_bits_per_sample != 16) {\n    printf(\n        \"ERROR: TIFF IO is currently limited to file limited\"\n        \" to files with TIFFTAG_BITSPERSAMPLE=8 and TIFFTAG_BITSPERSAMPLE=16 \\n\"\n        \"input file = %s has TIFFTAG_BITSPERSAMPLE=%d\\n\",\n        filename.c_str(), tiff_bits_per_sample);\n    TIFFClose(tiff_handle);\n    return EXIT_FAILURE;\n  }\n  if (TIFFIsTiled(tiff_handle)) {\n    printf(\n        \"ERROR: TIFF IO is currently limited to TIF files\"\n        \"without tiles. \\nInput file %s has been detected as tiled\\n\",\n        filename.c_str());\n    TIFFClose(tiff_handle);\n    return EXIT_FAILURE;\n  }\n  if (PHOTOMETRIC_RGB != tiff_photometric && PHOTOMETRIC_MINISBLACK != tiff_photometric) {\n    printf(\n        \"ERROR: TIFF IO is currently limited to \"\n        \"TIFFTAG_PHOTOMETRIC=PHOTOMETRIC_MINISBLACK=%d and \"\n        \"PHOTOMETRIC_RGB=%d. \\nInput file %s has been detected \"\n        \"TIFFTAG_PHOTOMETRIC=%d\\n\",\n        PHOTOMETRIC_MINISBLACK, PHOTOMETRIC_RGB, filename.c_str(), tiff_photometric);\n    TIFFClose(tiff_handle);\n    return EXIT_FAILURE;\n  }\n  this->num_components    = tiff_samples_per_pixel;\n  uint16_t num_iterations = this->num_components;\n  // setting bit-depth for components\n  this->width  = tiff_width;\n  this->height = tiff_height;\n  for (int i = 0; i < num_iterations; ++i) {\n    this->component_width.push_back(width);\n    this->component_height.push_back(height);\n    this->bits_per_pixel.push_back(static_cast<uint8_t>(tiff_bits_per_sample));\n    this->is_signed.push_back(false);\n  }\n\n  const uint32_t byte_per_sample = (tiff_bits_per_sample + 8U - 1U) / 8U;\n  const uint32_t component_gap   = num_iterations * byte_per_sample;\n  // const uint32_t line_width = component_gap * tiff_width;\n  std::unique_ptr<uint8_t[]> line_buf = MAKE_UNIQUE<uint8_t[]>(bytes_per_line);\n\n  // allocate memory once\n  if (this->buf == nullptr) {\n    this->buf = MAKE_UNIQUE<std::unique_ptr<int32_t[]>[]>(this->num_components);\n  }\n  for (size_t i = 0; i < this->num_components; ++i) {\n    this->buf[i] =\n        MAKE_UNIQUE<int32_t[]>(static_cast<size_t>(this->component_width[i]) * this->component_height[i]);\n  }\n\n  if (PLANARCONFIG_SEPARATE == planar_configuration) {\n    // PLANAR read\n  } else if (PLANARCONFIG_CONTIG == planar_configuration) {\n    // NORMAL read\n    for (uint32_t i = 0; i < tiff_height; ++i) {\n      if (TIFFReadScanline(tiff_handle, line_buf.get(), i) < 0) {\n        printf(\"ERROR: not enough samples in the given pnm file.\\n\");\n        TIFFClose(tiff_handle);\n        return EXIT_FAILURE;\n      }\n\n      for (size_t c = 0; c < num_iterations; ++c) {\n        uint8_t *src;\n        int32_t *dst;\n        src = &line_buf[c * byte_per_sample];\n        dst = &this->buf[c][static_cast<size_t>(i) * tiff_width];\n\n        switch (byte_per_sample) {\n          case 1:\n            for (size_t j = 0; j < tiff_width; ++j) {\n              *dst = *src;\n              dst++;\n              src += component_gap;\n            }\n            break;\n          case 2:\n            for (size_t j = 0; j < tiff_width; ++j) {\n              // suppose little-endian\n              *dst = src[0] | (src[1] << 8);\n              // *dst >>= 16 - tiff_bits_per_sample; // for future use\n              dst++;\n              src += component_gap;\n            }\n            break;\n          default:\n            printf(\"ERROR: bit-depth over 16 is not supported.\\n\");\n            TIFFClose(tiff_handle);\n            return EXIT_FAILURE;\n            break;\n        }\n      }\n    }\n  }\n  return EXIT_SUCCESS;\n}",
    "bool Tiff16Source::init()\n{\n  //_image = Tiff16();\n  if (_z) {\n    delete [] _z;\n    _z = 0L;\n  }\n\n  iv->clear();\n  im->clear();\n\n  TIFF *tif=TIFFOpen(_filename.toAscii(), \"r\");\n  if (tif) {\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &_width);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &_height);\n\n    _z = new unsigned short[_width*_height];\n\n    char *buf = (char *)_z;\n\n    int linesize = TIFFScanlineSize(tif);\n    for (int i = 0; i < _height; i++) {\n      TIFFReadScanline(tif, &buf[i * linesize], i, 0);\n    }\n  } else {\n    _width = _height = 0;\n  }\n\n  iv->init();\n  im->init();\n  registerChange();\n  return true;\n}",
    "int Tiff16SourcePlugin::understands(QSettings *cfg, const QString& filename) const {\n  Q_UNUSED(cfg)\n\n  quint16 spp, bpp, is_tiled;\n\n  if (filename.toLower().endsWith(\".tiff\") ||\n      filename.toLower().endsWith(\".tif\")) {\n\n    TIFF *tif=TIFFOpen(filename.toAscii(), \"r\");\n\n    if (tif) {\n      TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp);\n      TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n      is_tiled = TIFFIsTiled(tif);\n\n      TIFFClose(tif);\n\n\n      if ((bpp == 16) && (spp = 1) && (is_tiled == 0)) {\n          return 91;\n      }\n    }\n  }\n  return 0;\n}",
    "static FloatImage * loadFloatTIFF(const char * fileName, Stream & s)\r\n{\r\n    nvCheck(!s.isError());\r\n\r\n    TIFF * tif = TIFFOpen(fileName, \"r\");\r\n    //TIFF * tif = TIFFClientOpen(fileName, \"r\", &s, tiffReadWriteProc, tiffReadWriteProc, tiffSeekProc, tiffCloseProc, tiffSizeProc, tiffMapFileProc, tiffUnmapFileProc);\r\n\r\n    if (!tif)\r\n    {\r\n        nvDebug(\"Can't open '%s' for reading\\n\", fileName);\r\n        return NULL;\r\n    }\r\n\r\n    ::uint16 spp, bpp, format;\r\n    ::uint32 width, height;\r\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\r\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\r\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp);\r\n    TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n    TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &format);\r\n\r\n    if (bpp != 8 && bpp != 16 && bpp != 32) {\r\n        nvDebug(\"Can't load '%s', only 1 sample per pixel supported\\n\", fileName);\r\n        TIFFClose(tif);\r\n        return NULL;\r\n    }\r\n\r\n    AutoPtr<FloatImage> fimage(new FloatImage());\r\n    fimage->allocate(spp, width, height);\r\n\r\n    int linesize = TIFFScanlineSize(tif);\r\n    tdata_t buf = malloc<uint8>(linesize);\r\n\r\n    for (uint y = 0; y < height; y++)\r\n    {\r\n        TIFFReadScanline(tif, buf, y, 0);\r\n\r\n\tfor (uint c=0; c<spp; c++ )\r\n\t{\r\n\t    float * dst = fimage->scanline(y, c);\r\n\r\n\t    for(uint x = 0; x < width; x++)\r\n\t    {\r\n\t\tif (bpp == 8)\r\n\t\t{\r\n\t\t\tdst[x] = float(((::uint8 *)buf)[x*spp+c]) / float(0xFF);\r\n\t\t}\r\n\t\telse if (bpp == 16)\r\n\t\t{\r\n\t\t\tdst[x] = float(((::uint16 *)buf)[x*spp+c]) / float(0xFFFF);\r\n\t\t}\r\n\t\telse if (bpp == 32)\r\n\t\t{\r\n\t\t    if (format==SAMPLEFORMAT_IEEEFP)\r\n\t\t    {\r\n\t\t\tdst[x] = float(((float *)buf)[x*spp+c]);\r\n\t\t    }\r\n\t\t    else\r\n\t\t    {\r\n\t\t\tdst[x] = float(((::uint32 *)buf)[x*spp+c] >> 8) / float(0xFFFFFF);\r\n\t\t    }\r\n\t\t}\r\n\t    }\r\n\t}\r\n    }\r\n\r\n    free(buf);\r\n\r\n    TIFFClose(tif);\r\n\r\n    return fimage.release();\r\n}",
    "BiometricEvaluation::Image::TIFF::TIFF(\n    const uint8_t *data,\n    const uint64_t size,\n    const std::string &identifier,\n    const statusCallback_t &statusCallback) :\n    Image(\n    data,\n    size,\n    CompressionAlgorithm::TIFF,\n    identifier,\n    statusCallback)\n{\n\tif (!isTIFF(data, size))\n\t\tthrow BE::Error::StrategyError(\"Not a TIFF image\");\n\n\tTIFFSetWarningHandlerExt(BE_TIFFWarningHandler);\n\tTIFFSetErrorHandlerExt(BE_TIFFErrorHandler);\n\n\tstd::unique_ptr<::TIFF, void(*)(::TIFF*)> tiff(\n\t    static_cast<::TIFF*>(this->getDecompressionStream()), TIFFClose);\n\n\tuint16_t colorType{};\n\tTIFFGetField(tiff.get(), TIFFTAG_PHOTOMETRIC, &colorType);\n\tif ((colorType != PHOTOMETRIC_MINISBLACK) &&\n\t    (colorType != PHOTOMETRIC_RGB))\n\t\tthrow BE::Error::NotImplemented(\"Unsupported TIFF colortype: \" +\n\t\t    std::to_string(colorType));\n\n\tuint32_t width{}, height{};\n\tif (TIFFGetField(tiff.get(), TIFFTAG_IMAGEWIDTH, &width) != 1)\n\t\tthrow BE::Error::StrategyError(\"Could not read width\");\n\tif (TIFFGetField(tiff.get(), TIFFTAG_IMAGELENGTH, &height) != 1)\n\t\tthrow BE::Error::StrategyError(\"Could not read height\");\n\tthis->setDimensions({width, height});\n\n\tuint16_t bitsPerSample{};\n\tif (TIFFGetFieldDefaulted(tiff.get(), TIFFTAG_BITSPERSAMPLE,\n\t    &bitsPerSample) != 1)\n\t\tthrow BE::Error::StrategyError(\"Could not read bits per \"\n\t\t    \"sample\");\n\tthis->setBitDepth(bitsPerSample);\n\n\tuint16_t samplesPerPixel;\n\tif (TIFFGetFieldDefaulted(tiff.get(), TIFFTAG_SAMPLESPERPIXEL,\n\t    &samplesPerPixel) != 1)\n\t\tthrow BE::Error::StrategyError(\"Could not read samples per \"\n\t\t    \"pixel\");\n\tthis->setColorDepth(samplesPerPixel * bitsPerSample);\n\n\tif ((samplesPerPixel == 1) || (samplesPerPixel == 3))\n\t\tthis->setHasAlphaChannel(false);\n\telse {\n\t\tuint16_t extraSamples{};\n\t\tif (TIFFGetFieldDefaulted(tiff.get(), TIFFTAG_EXTRASAMPLES,\n\t\t    &extraSamples) != 1)\n\t\t\tthrow BE::Error::StrategyError(\"Could not read extra \"\n\t\t\t    \"samples\");\n\t\tif (extraSamples == EXTRASAMPLE_ASSOCALPHA)\n\t\t\tthis->setHasAlphaChannel(true);\n\t\telse\n\t\t\tthrow BE::Error::NotImplemented(\"Unusual color depth, \"\n\t\t\t    \"and unsure what do to with extra samples\");\n\t}\n\n\tfloat xRes{}, yRes{};\n\tif (TIFFGetField(tiff.get(), TIFFTAG_XRESOLUTION, &xRes) != 1)\n\t\txRes = 72;\n\tif (TIFFGetField(tiff.get(), TIFFTAG_YRESOLUTION, &yRes) != 1)\n\t\tyRes = 72;\n\n\t/* RGBRGBRGB vs RRRGGGBBB when retrieving scanlines */\n\tuint16_t planarConfig{};\n\tif (TIFFGetField(tiff.get(), TIFFTAG_PLANARCONFIG, &planarConfig) != 1)\n\t\tthrow BE::Error::StrategyError(\"Could not read planar \"\n\t\t    \"configuration\");\n\tif (planarConfig != PLANARCONFIG_CONTIG)\n\t\tthrow BE::Error::NotImplemented(\"TIFF images separated by \"\n\t\t    \"component are not yet supported\");\n\n\tuint16_t rawResUnits{};\n\tif (TIFFGetFieldDefaulted(tiff.get(), TIFFTAG_RESOLUTIONUNIT,\n\t    &rawResUnits) != 1)\n\t\tthrow BE::Error::StrategyError(\"Could not read resolution \"\n\t\t    \"units\");\n\tBE::Image::Resolution::Units resUnits{BE::Image::Resolution::Units::NA};\n\tswitch (rawResUnits) {\n\tcase RESUNIT_INCH:\n\t\tresUnits = BE::Image::Resolution::Units::PPI;\n\t\tbreak;\n\tcase RESUNIT_CENTIMETER:\n\t\tresUnits = BE::Image::Resolution::Units::PPCM;\n\t\tbreak;\n\tdefault:\n\t\tresUnits = BE::Image::Resolution::Units::NA;\n\t\tbreak;\n\t}\n\tthis->setResolution({xRes, yRes, resUnits});\n}",
    "void PdfImage::LoadFromTiffHandle(void* hInHandle) {\n    \n    TIFF* hInTiffHandle = (TIFF*)hInHandle;\n    \n    int32 row, width, height;\n    uint16 samplesPerPixel, bitsPerSample;\n    uint16* sampleInfo;\n    uint16 extraSamples;\n    uint16 planarConfig, photoMetric, orientation;\n    int32 resolutionUnit;\n    \n    TIFFGetField(hInTiffHandle,\t   TIFFTAG_IMAGEWIDTH,\t\t&width);\n    TIFFGetField(hInTiffHandle,\t   TIFFTAG_IMAGELENGTH,\t\t&height);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_BITSPERSAMPLE,\t&bitsPerSample);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_SAMPLESPERPIXEL,     &samplesPerPixel);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_PLANARCONFIG,\t&planarConfig);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_PHOTOMETRIC,\t\t&photoMetric);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_EXTRASAMPLES,\t&extraSamples, &sampleInfo);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_ORIENTATION,\t\t&orientation);\n    \n    resolutionUnit = 0;\n    float resX;\n    float resY;\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_XRESOLUTION,\t\t&resX);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_YRESOLUTION,\t\t&resY);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_RESOLUTIONUNIT,\t&resolutionUnit);\n    \n    int colorChannels = samplesPerPixel - extraSamples;\n    \n    int bitsPixel = bitsPerSample * samplesPerPixel;\n    \n    // TODO: implement special cases\n    if( TIFFIsTiled(hInTiffHandle) )\n    {\n        TIFFClose(hInTiffHandle);\n        PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n    }\n    \n    if ( planarConfig != PLANARCONFIG_CONTIG && colorChannels != 1 )\n    {\n        TIFFClose(hInTiffHandle);\n        PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n    }\n    \n    if ( orientation != ORIENTATION_TOPLEFT )\n    {\n        TIFFClose(hInTiffHandle);\n        PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n    }\n    \n    switch(photoMetric)\n    {\n        case PHOTOMETRIC_MINISBLACK:\n        {\n            if( bitsPixel == 1 )\n            {\n                PdfArray decode;\n                decode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(0) ) );\n                decode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(1) ) );\n                this->GetObject()->GetDictionary().AddKey( PdfName(\"Decode\"), decode );\n                this->GetObject()->GetDictionary().AddKey( PdfName(\"ImageMask\"), PdfVariant( true ) );\n                this->GetObject()->GetDictionary().RemoveKey( PdfName(\"ColorSpace\") );\n            }\n            else if ( bitsPixel == 8  ||  bitsPixel == 16)\n                SetImageColorSpace(ePdfColorSpace_DeviceGray);\n            else\n            {\n                TIFFClose(hInTiffHandle);\n                PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n            }\n        }\n            break;\n            \n        case PHOTOMETRIC_MINISWHITE:\n        {\n            if( bitsPixel == 1 )\n            {\n                PdfArray decode;\n                decode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(1) ) );\n                decode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(0) ) );\n                this->GetObject()->GetDictionary().AddKey( PdfName(\"Decode\"), decode );\n                this->GetObject()->GetDictionary().AddKey( PdfName(\"ImageMask\"), PdfVariant( true ) );\n                this->GetObject()->GetDictionary().RemoveKey( PdfName(\"ColorSpace\") );\n            }\n            else if ( bitsPixel == 8  ||  bitsPixel == 16)\n                SetImageColorSpace(ePdfColorSpace_DeviceGray);\n            else\n            {\n                TIFFClose(hInTiffHandle);\n                PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n            }\n        }\n            break;\n            \n        case PHOTOMETRIC_RGB:\n            if ( bitsPixel != 24 )\n            {\n                TIFFClose(hInTiffHandle);\n                PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n            }\n            SetImageColorSpace(ePdfColorSpace_DeviceRGB);\n            break;\n            \n        case PHOTOMETRIC_SEPARATED:\n            if( bitsPixel != 32)\n            {\n                TIFFClose(hInTiffHandle);\n                PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n            }\n            SetImageColorSpace(ePdfColorSpace_DeviceCMYK);\n            break;\n            \n        case PHOTOMETRIC_PALETTE:\n        {\n            int numColors = (1 << bitsPixel);\n            \n            PdfArray decode;\n            decode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(0) ) );\n            decode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(numColors-1) ) );\n            this->GetObject()->GetDictionary().AddKey( PdfName(\"Decode\"), decode );\n            \n            uint16 * rgbRed;\n            uint16 * rgbGreen;\n            uint16 * rgbBlue;\n            TIFFGetField(hInTiffHandle, TIFFTAG_COLORMAP, &rgbRed, &rgbGreen, &rgbBlue);\n            \n            char *datap = new char[numColors*3];\n            \n            for ( int clr = 0; clr < numColors; clr++ )\n            {\n                datap[3*clr+0] = rgbRed[clr]/257;\n                datap[3*clr+1] = rgbGreen[clr]/257;\n                datap[3*clr+2] = rgbBlue[clr]/257;\n            }\n            PdfMemoryInputStream stream( datap, numColors*3 );\n            \n            // Create a colorspace object\n            PdfObject* pIdxObject = this->GetObject()->GetOwner()->CreateObject();\n            pIdxObject->GetStream()->Set( &stream );\n            \n            // Add the colorspace to our image\n            PdfArray array;\n            array.push_back( PdfName(\"Indexed\") );\n            array.push_back( PdfName(\"DeviceRGB\") );\n            array.push_back( static_cast<pdf_int64>(numColors-1) );\n            array.push_back( pIdxObject->Reference() );\n            this->GetObject()->GetDictionary().AddKey( PdfName(\"ColorSpace\"), array );\n            \n            delete[] datap;\n        }\n            break;\n            \n        default:\n            TIFFClose(hInTiffHandle);\n            PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n            break;\n    }\n    \n    int32 scanlineSize = TIFFScanlineSize(hInTiffHandle);\n    long bufferSize = scanlineSize * height;\n    char *buffer = new char[bufferSize];\n    if( !buffer )\n    {\n        TIFFClose(hInTiffHandle);\n        PODOFO_RAISE_ERROR( ePdfError_OutOfMemory );\n    }\n    \n    for(row = 0; row < height; row++)\n    {\n        if(TIFFReadScanline(hInTiffHandle,\n                            &buffer[row * scanlineSize],\n                            row) == (-1))\n        {\n            TIFFClose(hInTiffHandle);\n            PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n        }\n    }\n    \n    PdfMemoryInputStream stream(buffer, bufferSize);\n    \n    SetImageData(static_cast<unsigned int>(width),\n                 static_cast<unsigned int>(height),\n                 static_cast<unsigned int>(bitsPerSample),\n                 &stream);\n    \n    delete[] buffer;\n    \n    TIFFClose(hInTiffHandle);\n}",
    "static bool ReadTIFF(const char *name, float *&rgba, int &xRes, int &yRes,\n\t\t     bool &hasAlpha)\n{\n    // Try to open TIFF file\n    TIFF *tiff = TIFFOpen(name, \"r\");\n    if (!tiff) {\n\tfprintf(stderr, \"Unable to open TIFF %s\", name);\n\treturn false;\n    }\n    // Get basic information from TIFF header\n    short int nSamples;\n    int xSize, ySize;\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &xSize);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &ySize);\n    TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &nSamples);\n    if (nSamples != 3 && nSamples != 4) {\n\tfprintf(stderr, \"Sorry, only handle 3 and 4 sample TIFFs...\\n\");\n\treturn false;\n    }\n    hasAlpha = (nSamples == 4);\n    xRes = xSize;\n    yRes = ySize;\n\n    // Make sure this is a TIFF we can read\n    short int bitsPerSample, sampleFormat = SAMPLEFORMAT_UINT;\n    if (!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample)) {\n\tfprintf(stderr, \"TIFFRead: bits per sample not set in TIFF\");\n\tTIFFClose(tiff);\n\treturn false;\n    }\n\n    if (!TIFFGetField(tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat)) {\n\tif (bitsPerSample == 32)\n\t    sampleFormat = SAMPLEFORMAT_IEEEFP;\n\telse\n\t    sampleFormat = SAMPLEFORMAT_UINT;\n    }\n\t\n    if (bitsPerSample == 32) {\n\tif (sampleFormat != SAMPLEFORMAT_IEEEFP) {\n\t    fprintf(stderr, \"TIFFRead: 32 bit TIFF not stored in floating point format\");\n\t    TIFFClose(tiff);\n\t    return false;\n\t}\n    }\n    else {\n\tif (bitsPerSample != 8 && bitsPerSample != 32) {\n\t    fprintf(stderr, \"TIFFRead: only 8 and 32 bits per sample supported\");\n\t    TIFFClose(tiff);\n\t    return false;\n\t}\n\tif (sampleFormat != SAMPLEFORMAT_UINT) {\n\t    fprintf(stderr, \"TIFFRead: 8 bit TIFFs must be stored as unsigned ints\");\n\t    TIFFClose(tiff);\n\t    return false;\n\t}\n    }\n\n    int bytesPerSample = bitsPerSample / 8;\n    if (nSamples * xRes * bytesPerSample != TIFFScanlineSize(tiff)) {\n\tfprintf(stderr, \"TIFFRead: RGB not interleaved in TIFF %s\", name);\n\tTIFFClose(tiff);\n\treturn false;\n    }\n\n    // Allocate space for [[pixels]] and buffers\n    rgba = new float[nSamples * xRes * yRes];\n    float *p = rgba;\n    unsigned char *ubuf = NULL;\n    if (bitsPerSample == 8) ubuf = new unsigned char[nSamples * xRes];\n\n    for (int y = 0; y < yRes; ++y) {\n\tif (ubuf) {\n\t    // Read 8-bit TIFF scanline\n\t    if (TIFFReadScanline(tiff, ubuf, y, 1) == -1) {\n\t\tTIFFClose(tiff);\n\t\treturn false;\n\t    }\n\t    for (int x = 0; x < nSamples*xRes; ++x)\n\t\t*p++ = ubuf[x] * INV_255;\n\t}\n\telse {\n\t    // Read floating point TIFF scanline\n\t    if (TIFFReadScanline(tiff, p, y, 1) == -1) {\n\t\tTIFFClose(tiff);\n\t\treturn false;\n\t    }\n\t    p += nSamples * xRes;\n\t}\n    }\n\n    delete[] ubuf;\n    TIFFClose(tiff);\n    return rgba;\n}",
    "TiffReader::TiffInfo::TiffInfo(TiffHandle const& tif, TiffHeader const& header)\n    :   width(0),\n        height(0),\n        bits_per_sample(1),\n        samples_per_pixel(1),\n        sample_format(SAMPLEFORMAT_UINT),\n        photometric(PHOTOMETRIC_MINISBLACK),\n        host_big_endian(QSysInfo::ByteOrder == QSysInfo::BigEndian),\n        file_big_endian(header.signature() == TiffHeader::TIFF_BIG_ENDIAN)\n{\n    uint16 compression = 1;\n    TIFFGetField(tif.handle(), TIFFTAG_COMPRESSION, &compression);\n    switch (compression) {\n    case COMPRESSION_CCITTFAX3:\n    case COMPRESSION_CCITTFAX4:\n    case COMPRESSION_CCITTRLE:\n    case COMPRESSION_CCITTRLEW:\n        photometric = PHOTOMETRIC_MINISWHITE;\n    }\n\n    TIFFGetField(tif.handle(), TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tif.handle(), TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetField(tif.handle(), TIFFTAG_BITSPERSAMPLE, &bits_per_sample);\n    TIFFGetField(tif.handle(), TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel);\n    TIFFGetField(tif.handle(), TIFFTAG_SAMPLEFORMAT, &sample_format);\n    TIFFGetField(tif.handle(), TIFFTAG_PHOTOMETRIC, &photometric);\n}",
    "ImageMetadata\nTiffReader::currentPageMetadata(TiffHandle const& tif)\n{\n    uint32 width = 0, height = 0;\n    float xres = 0, yres = 0;\n    uint16 res_unit = 0;\n    TIFFGetField(tif.handle(), TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tif.handle(), TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetField(tif.handle(), TIFFTAG_XRESOLUTION, &xres);\n    TIFFGetField(tif.handle(), TIFFTAG_YRESOLUTION, &yres);\n    TIFFGetFieldDefaulted(tif.handle(), TIFFTAG_RESOLUTIONUNIT, &res_unit);\n    return ImageMetadata(QSize(width, height), getDpi(xres, yres, res_unit));\n}",
    "QImage\nTiffReader::extractBinaryOrIndexed8Image(\n    TiffHandle const& tif, TiffInfo const& info)\n{\n    QImage::Format format = QImage::Format_Indexed8;\n    if (info.bits_per_sample == 1) {\n        // Because we specify B option when opening, we can\n        // always use Format_Mono, and not Format_MonoLSB.\n        format = QImage::Format_Mono;\n    }\n\n    QImage image(info.width, info.height, format);\n    if (image.isNull()) {\n        throw std::bad_alloc();\n    }\n\n    int const num_colors = 1 << info.bits_per_sample;\n    image.setColorCount(num_colors);\n\n    if (info.photometric == PHOTOMETRIC_PALETTE) {\n        uint16* pr = 0;\n        uint16* pg = 0;\n        uint16* pb = 0;\n        TIFFGetField(tif.handle(), TIFFTAG_COLORMAP, &pr, &pg, &pb);\n        if (!pr || !pg || !pb) {\n            return QImage();\n        }\n        if (info.host_big_endian != info.file_big_endian) {\n            TIFFSwabArrayOfShort(pr, num_colors);\n            TIFFSwabArrayOfShort(pg, num_colors);\n            TIFFSwabArrayOfShort(pb, num_colors);\n        }\n        double const f = 255.0 / 65535.0;\n        for (int i = 0; i < num_colors; ++i) {\n            uint32 const r = (uint32)(pr[i] * f + 0.5);\n            uint32 const g = (uint32)(pg[i] * f + 0.5);\n            uint32 const b = (uint32)(pb[i] * f + 0.5);\n            uint32 const a = 0xFF000000;\n            image.setColor(i, a | (r << 16) | (g << 8) | b);\n        }\n    } else if (info.photometric == PHOTOMETRIC_MINISBLACK) {\n        double const f = 255.0 / (num_colors - 1);\n        for (int i = 0; i < num_colors; ++i) {\n            int const gray = (int)(i * f + 0.5);\n            image.setColor(i, qRgb(gray, gray, gray));\n        }\n    } else if (info.photometric == PHOTOMETRIC_MINISWHITE) {\n        double const f = 255.0 / (num_colors - 1);\n        int c = num_colors - 1;\n        for (int i = 0; i < num_colors; ++i, --c) {\n            int const gray = (int)(c * f + 0.5);\n            image.setColor(i, qRgb(gray, gray, gray));\n        }\n    } else {\n        return QImage();\n    }\n\n    if (info.bits_per_sample == 1 || info.bits_per_sample == 8) {\n        readLines(tif, image);\n    } else {\n        readAndUnpackLines(tif, info, image);\n    }\n\n    return image;\n}",
    "GraphicsBuffer load_image_to_graphics_buffer_tiff(GraphicsDevice device, const char* texturePath, uint32_t& width, uint32_t& height, TextureFormat& textureFormat)\n{\n\t// Set the error callback\n\tTIFFSetErrorHandler(&tif_read_error);\n\n\t// Open the file\n\tTIFF* tif = TIFFOpen(texturePath, \"r\");\n\tassert_msg(tif != nullptr, \"Could not find tiff file.\");\n\n\t// Read the resource's dimensions\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\n\t// Number of channels per pixel\n\tuint16_t channelCount, bitsPerChannel, channelFormat;\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channelCount);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerChannel);\n\tuint16_t channelSize = bitsPerChannel / 8;\n\tTIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &channelFormat);\n\tif (channelSize == 1 && channelCount == 3)\n\t\tchannelFormat = SAMPLEFORMAT_UINT;\n\n\t// Get the output format\n\tuint16_t actualChannelCount;\n\tget_adequate_format(channelSize, channelCount, channelFormat, textureFormat, actualChannelCount);\n\n\t// Allocate the upload texture\n\tconst uint16_t pixelSize = actualChannelCount * channelSize;\n\tconst uint32_t imageSize = width * height * pixelSize;\n\tGraphicsBuffer textureBuffer = d3d12::graphics_resources::create_graphics_buffer(device, imageSize, pixelSize, GraphicsBufferType::Upload);\n\tchar* bufferCPU = d3d12::graphics_resources::allocate_cpu_buffer(textureBuffer);\n\n\t// Read the image\n\ttsize_t lineSize = TIFFScanlineSize(tif);\n\n\tassert(lineSize == width * (channelSize * channelCount));\n\n\t// Allocate a buffer for line reading\n\tchar* image = (char*)malloc(width * channelSize * channelCount);\n\tfor (uint32_t channelIdx = 0; channelIdx < channelCount; ++channelIdx)\n\t{\n\t\t// For each line\n\t\tfor (uint32_t y = 0; y < height; y++)\n\t\t{\n\t\t\tTIFFReadScanline(tif, image, y, channelIdx);\n\t\t\tfor (uint32_t x = 0; x < width; x++)\n\t\t\t{\n\t\t\t\tuint32_t inputOffset = channelSize * channelCount * x;\n\t\t\t\tuint32_t outputOffset = pixelSize * (x + y * width);\n\t\t\t\tmemcpy(bufferCPU + outputOffset, image + inputOffset, channelSize * channelCount);\n\t\t\t}\n\t\t}\n\t}\n\n\t// free the buffer\n\tfree(image);\n\n\t// Release the CPU view\n\td3d12::graphics_resources::release_cpu_buffer(textureBuffer);\n\n\t// Close the tiff file\n\tTIFFClose(tif);\n\n\t// Return the created graphics buffer\n\treturn textureBuffer;\n}",
    "tiffcp(TIFF* in, TIFF* out)\n{\n\tuint16 bitspersample, samplesperpixel = 1;\nuint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;\ncopyFunc cf;\nuint32 width, length;\nstruct cpTag* p;\n\nCopyField(TIFFTAG_IMAGEWIDTH, width);\nCopyField(TIFFTAG_IMAGELENGTH, length);\nCopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);\nCopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\nif (compression != (uint16)-1)\nTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\nelse\nCopyField(TIFFTAG_COMPRESSION, compression);\nTIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression);\nTIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric);\nif (input_compression == COMPRESSION_JPEG) {\n/* Force conversion to RGB */\nTIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n} else if (input_photometric == PHOTOMETRIC_YCBCR) {\n/* Otherwise, can't handle subsampled input */\nuint16 subsamplinghor,subsamplingver;\n\nTIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\n&subsamplinghor, &subsamplingver);\nif (subsamplinghor!=1 || subsamplingver!=1) {\nfprintf(stderr, \"tiffcp: %s: Can't copy/convert subsampled image.\\n\",\nTIFFFileName(in));\nreturn FALSE;\n}\n}\nif (compression == COMPRESSION_JPEG) {\nif (input_photometric == PHOTOMETRIC_RGB &&\njpegcolormode == JPEGCOLORMODE_RGB)\nTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\nelse\nTIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\n}\nelse if (compression == COMPRESSION_SGILOG\n|| compression == COMPRESSION_SGILOG24)\nTIFFSetField(out, TIFFTAG_PHOTOMETRIC,\nsamplesperpixel == 1 ?\nPHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);\nelse if (input_compression == COMPRESSION_JPEG &&\nsamplesperpixel == 3 ) {\n/* RGB conversion was forced above\nhence the output will be of the same type */\nTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n}\nelse\nCopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT);\nif (fillorder != 0)\nTIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\nelse\nCopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);\n/*\n* Will copy `Orientation' tag from input image\n*/\nTIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\nswitch (orientation) {\ncase ORIENTATION_BOTRIGHT:\ncase ORIENTATION_RIGHTBOT:\t/* XXX */\nTIFFWarning(TIFFFileName(in), \"using bottom-left orientation\");\norientation = ORIENTATION_BOTLEFT;\n/* fall thru... */\ncase ORIENTATION_LEFTBOT:\t/* XXX */\ncase ORIENTATION_BOTLEFT:\nbreak;\ncase ORIENTATION_TOPRIGHT:\ncase ORIENTATION_RIGHTTOP:\t/* XXX */\ndefault:\nTIFFWarning(TIFFFileName(in), \"using top-left orientation\");\norientation = ORIENTATION_TOPLEFT;\n/* fall thru... */\ncase ORIENTATION_LEFTTOP:\t/* XXX */\ncase ORIENTATION_TOPLEFT:\nbreak;\n}\nTIFFSetField(out, TIFFTAG_ORIENTATION, orientation);\n/*\n* Choose tiles/strip for the output image according to\n* the command line arguments (-tiles, -strips) and the\n* structure of the input image.\n*/\nif (outtiled == -1)\nouttiled = TIFFIsTiled(in);\nif (outtiled) {\n/*\n* Setup output file's tile width&height.  If either\n* is not specified, use either the value from the\n* input image or, if nothing is defined, use the\n* library default.\n*/\nif (tilewidth == (uint32) -1)\nTIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);\nif (tilelength == (uint32) -1)\nTIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);\nTIFFDefaultTileSize(out, &tilewidth, &tilelength);\nTIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);\nTIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);\n} else {\n/*\n* RowsPerStrip is left unspecified: use either the\n* value from the input image or, if nothing is defined,\n* use the library default.\n*/\nif (rowsperstrip == (uint32) 0) {\nif (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP,\n&rowsperstrip)) {\nrowsperstrip =\nTIFFDefaultStripSize(out, rowsperstrip);\n}\nif (rowsperstrip > length && rowsperstrip != (uint32)-1)\nrowsperstrip = length;\n}\nelse if (rowsperstrip == (uint32) -1)\nrowsperstrip = length;\nTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n}\nif (config != (uint16) -1)\nTIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\nelse\nCopyField(TIFFTAG_PLANARCONFIG, config);\nif (samplesperpixel <= 4)\nCopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);\nCopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);\n/* SMinSampleValue & SMaxSampleValue */\nswitch (compression) {\ncase COMPRESSION_JPEG:\nTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\nTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\nbreak;\ncase COMPRESSION_JBIG:\nCopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\nCopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\nCopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\nCopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII);\nbreak;\ncase COMPRESSION_LZW:\ncase COMPRESSION_ADOBE_DEFLATE:\ncase COMPRESSION_DEFLATE:\ncase COMPRESSION_LZMA:\nif (predictor != (uint16)-1)\nTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\nelse\nCopyField(TIFFTAG_PREDICTOR, predictor);\nif (preset != -1) {\nif (compression == COMPRESSION_ADOBE_DEFLATE\n|| compression == COMPRESSION_DEFLATE)\nTIFFSetField(out, TIFFTAG_ZIPQUALITY, preset);\nelse if (compression == COMPRESSION_LZMA)\nTIFFSetField(out, TIFFTAG_LZMAPRESET, preset);\n}\nbreak;\ncase COMPRESSION_CCITTFAX3:\ncase COMPRESSION_CCITTFAX4:\nif (compression == COMPRESSION_CCITTFAX3) {\nif (g3opts != (uint32) -1)\nTIFFSetField(out, TIFFTAG_GROUP3OPTIONS,\ng3opts);\nelse\nCopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\n} else\nCopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);\nCopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);\nCopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);\nCopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);\nCopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\nCopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\nCopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\nbreak;\n}\n{\nuint32 len32;\nvoid** data;\nif (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))\nTIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);\n}\n{\nuint16 ninks;\nconst char* inknames;\nif (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {\nTIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);\nif (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {\nint inknameslen = strlen(inknames) + 1;\nconst char* cp = inknames;\nwhile (ninks > 1) {\ncp = strchr(cp, '\\0');\ncp++;\ninknameslen += (strlen(cp) + 1);\nninks--;\n}\nTIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);\n}\n}\n}\n{\nunsigned short pg0, pg1;\n\nif (pageInSeq == 1) {\nif (pageNum < 0) /* only one input file */ {\nif (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))\nTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\n} else\nTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n\n} else {\nif (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {\nif (pageNum < 0) /* only one input file */\nTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\nelse\nTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n}\n}\n}\n\nfor (p = tags; p < &tags[NTAGS]; p++)\nCopyTag(p->tag, p->count, p->type);\n\ncf = pickCopyFunc(in, out, bitspersample, samplesperpixel);\nreturn (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE);\n}",
    "loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)\n{\nuint32   i;\nfloat    xres = 0.0, yres = 0.0;\n  uint16   nstrips = 0, ntiles = 0, planar = 0;\nuint16   bps = 0, spp = 0, res_unit = 0;\nuint16   orientation = 0;\nuint16   input_compression = 0, input_photometric = 0;\nuint16   subsampling_horiz, subsampling_vert;\nuint32   width = 0, length = 0;\nuint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;\nuint32   tw = 0, tl = 0;       /* Tile width and length */\nuint32   tile_rowsize = 0;\nunsigned char *read_buff = NULL;\nunsigned char *new_buff  = NULL;\nint      readunit = 0;\nstatic   uint32  prev_readsize = 0;\n\nTIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);\nTIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);\nTIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\nTIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\nif (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric))\nTIFFError(\"loadImage\",\"Image lacks Photometric interpreation tag\");\nif (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))\nTIFFError(\"loadimage\",\"Image lacks image width tag\");\nif(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))\nTIFFError(\"loadimage\",\"Image lacks image length tag\");\nTIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);\nTIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);\nif (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))\nres_unit = RESUNIT_INCH;\nif (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))\ninput_compression = COMPRESSION_NONE;\n\n#ifdef DEBUG2\nchar compressionid[16];\n\nswitch (input_compression)\n{\ncase COMPRESSION_NONE:\t/* 1  dump mode */\nstrcpy (compressionid, \"None/dump\");\nbreak;\ncase COMPRESSION_CCITTRLE:\t  /* 2 CCITT modified Huffman RLE */\nstrcpy (compressionid, \"Huffman RLE\");\nbreak;\ncase COMPRESSION_CCITTFAX3:\t  /* 3 CCITT Group 3 fax encoding */\nstrcpy (compressionid, \"Group3 Fax\");\nbreak;\ncase COMPRESSION_CCITTFAX4:\t  /* 4 CCITT Group 4 fax encoding */\nstrcpy (compressionid, \"Group4 Fax\");\nbreak;\ncase COMPRESSION_LZW:\t  /* 5 Lempel-Ziv  & Welch */\nstrcpy (compressionid, \"LZW\");\nbreak;\ncase COMPRESSION_OJPEG:\t  /* 6 !6.0 JPEG */\nstrcpy (compressionid, \"Old Jpeg\");\nbreak;\ncase COMPRESSION_JPEG:\t  /* 7 %JPEG DCT compression */\nstrcpy (compressionid, \"New Jpeg\");\nbreak;\ncase COMPRESSION_NEXT:\t  /* 32766 NeXT 2-bit RLE */\nstrcpy (compressionid, \"Next RLE\");\nbreak;\ncase COMPRESSION_CCITTRLEW:   /* 32771 #1 w/ word alignment */\nstrcpy (compressionid, \"CITTRLEW\");\nbreak;\ncase COMPRESSION_PACKBITS:\t  /* 32773 Macintosh RLE */\nstrcpy (compressionid, \"Mac Packbits\");\nbreak;\ncase COMPRESSION_THUNDERSCAN: /* 32809 ThunderScan RLE */\nstrcpy (compressionid, \"Thunderscan\");\nbreak;\ncase COMPRESSION_IT8CTPAD:\t  /* 32895 IT8 CT w/padding */\nstrcpy (compressionid, \"IT8 padded\");\nbreak;\ncase COMPRESSION_IT8LW:\t  /* 32896 IT8 Linework RLE */\nstrcpy (compressionid, \"IT8 RLE\");\nbreak;\ncase COMPRESSION_IT8MP:\t  /* 32897 IT8 Monochrome picture */\nstrcpy (compressionid, \"IT8 mono\");\nbreak;\ncase COMPRESSION_IT8BL:\t  /* 32898 IT8 Binary line art */\nstrcpy (compressionid, \"IT8 lineart\");\nbreak;\ncase COMPRESSION_PIXARFILM:\t  /* 32908 Pixar companded 10bit LZW */\nstrcpy (compressionid, \"Pixar 10 bit\");\nbreak;\ncase COMPRESSION_PIXARLOG:\t  /* 32909 Pixar companded 11bit ZIP */\nstrcpy (compressionid, \"Pixar 11bit\");\nbreak;\ncase COMPRESSION_DEFLATE:\t  /* 32946 Deflate compression */\nstrcpy (compressionid, \"Deflate\");\nbreak;\ncase COMPRESSION_ADOBE_DEFLATE: /* 8 Deflate compression */\nstrcpy (compressionid, \"Adobe deflate\");\nbreak;\ndefault:\nstrcpy (compressionid, \"None/unknown\");\nbreak;\n}\nTIFFError(\"loadImage\", \"Input compression %s\", compressionid);\n#endif\n\nscanlinesize = TIFFScanlineSize(in);\nimage->bps = bps;\nimage->spp = spp;\nimage->planar = planar;\nimage->width = width;\nimage->length = length;\nimage->xres = xres;\nimage->yres = yres;\nimage->res_unit = res_unit;\nimage->compression = input_compression;\nimage->photometric = input_photometric;\n#ifdef DEBUG2\nchar photometricid[12];\n\nswitch (input_photometric)\n{\ncase PHOTOMETRIC_MINISWHITE:\nstrcpy (photometricid, \"MinIsWhite\");\nbreak;\ncase PHOTOMETRIC_MINISBLACK:\nstrcpy (photometricid, \"MinIsBlack\");\nbreak;\ncase PHOTOMETRIC_RGB:\nstrcpy (photometricid, \"RGB\");\nbreak;\ncase PHOTOMETRIC_PALETTE:\nstrcpy (photometricid, \"Palette\");\nbreak;\ncase PHOTOMETRIC_MASK:\nstrcpy (photometricid, \"Mask\");\nbreak;\ncase PHOTOMETRIC_SEPARATED:\nstrcpy (photometricid, \"Separated\");\nbreak;\ncase PHOTOMETRIC_YCBCR:\nstrcpy (photometricid, \"YCBCR\");\nbreak;\ncase PHOTOMETRIC_CIELAB:\nstrcpy (photometricid, \"CIELab\");\nbreak;\ncase PHOTOMETRIC_ICCLAB:\nstrcpy (photometricid, \"ICCLab\");\nbreak;\ncase PHOTOMETRIC_ITULAB:\nstrcpy (photometricid, \"ITULab\");\nbreak;\ncase PHOTOMETRIC_LOGL:\nstrcpy (photometricid, \"LogL\");\nbreak;\ncase PHOTOMETRIC_LOGLUV:\nstrcpy (photometricid, \"LOGLuv\");\nbreak;\ndefault:\nstrcpy (photometricid, \"Unknown\");\nbreak;\n}\nTIFFError(\"loadImage\", \"Input photometric interpretation %s\", photometricid);\n\n#endif\nimage->orientation = orientation;\nswitch (orientation)\n{\ncase 0:\ncase ORIENTATION_TOPLEFT:\nimage->adjustments = 0;\nbreak;\ncase ORIENTATION_TOPRIGHT:\nimage->adjustments = MIRROR_HORIZ;\nbreak;\ncase ORIENTATION_BOTRIGHT:\nimage->adjustments = ROTATECW_180;\nbreak;\ncase ORIENTATION_BOTLEFT:\nimage->adjustments = MIRROR_VERT;\nbreak;\ncase ORIENTATION_LEFTTOP:\nimage->adjustments = MIRROR_VERT | ROTATECW_90;\nbreak;\ncase ORIENTATION_RIGHTTOP:\nimage->adjustments = ROTATECW_90;\nbreak;\ncase ORIENTATION_RIGHTBOT:\nimage->adjustments = MIRROR_VERT | ROTATECW_270;\nbreak;\ncase ORIENTATION_LEFTBOT:\nimage->adjustments = ROTATECW_270;\nbreak;\ndefault:\nimage->adjustments = 0;\nimage->orientation = ORIENTATION_TOPLEFT;\n}\n\nif ((bps == 0) || (spp == 0))\n{\nTIFFError(\"loadImage\", \"Invalid samples per pixel (%d) or bits per sample (%d)\",\nspp, bps);\nreturn (-1);\n}\n\nif (TIFFIsTiled(in))\n{\nreadunit = TILE;\ntlsize = TIFFTileSize(in);\nntiles = TIFFNumberOfTiles(in);\nTIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\nTIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\ntile_rowsize  = TIFFTileRowSize(in);\nif (ntiles == 0 || tlsize == 0 || tile_rowsize == 0)\n{\nTIFFError(\"loadImage\", \"File appears to be tiled, but the number of tiles, tile size, or tile rowsize is zero.\");\nexit(-1);\n}\nbuffsize = tlsize * ntiles;\nif (tlsize != (buffsize / ntiles))\n{\nTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\nexit(-1);\n}\n\nif (buffsize < (uint32)(ntiles * tl * tile_rowsize))\n{\nbuffsize = ntiles * tl * tile_rowsize;\nif (ntiles != (buffsize / tl / tile_rowsize))\n{\nTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\nexit(-1);\n}\n\n#ifdef DEBUG2\nTIFFError(\"loadImage\",\n\"Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu\",\ntlsize, (unsigned long)buffsize);\n#endif\n}\n\nif (dump->infile != NULL)\ndump_info (dump->infile, dump->format, \"\",\n\"Tilesize: %u, Number of Tiles: %u, Tile row size: %u\",\ntlsize, ntiles, tile_rowsize);\n}\nelse\n{\nuint32 buffsize_check;\nreadunit = STRIP;\nTIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\nstsize = TIFFStripSize(in);\nnstrips = TIFFNumberOfStrips(in);\nif (nstrips == 0 || stsize == 0)\n{\nTIFFError(\"loadImage\", \"File appears to be striped, but the number of stipes or stripe size is zero.\");\nexit(-1);\n}\n\nbuffsize = stsize * nstrips;\nif (stsize != (buffsize / nstrips))\n{\nTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\nexit(-1);\n}\nbuffsize_check = ((length * width * spp * bps) + 7);\nif (length != ((buffsize_check - 7) / width / spp / bps))\n{\nTIFFError(\"loadImage\", \"Integer overflow detected.\");\nexit(-1);\n}\nif (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))\n{\nbuffsize =  ((length * width * spp * bps) + 7) / 8;\n#ifdef DEBUG2\nTIFFError(\"loadImage\",\n\"Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu\",\nstsize, (unsigned long)buffsize);\n#endif\n}\n\nif (dump->infile != NULL)\ndump_info (dump->infile, dump->format, \"\",\n\"Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u\",\nstsize, nstrips, rowsperstrip, scanlinesize);\n}\n\nif (input_compression == COMPRESSION_JPEG)\n{  /* Force conversion to RGB */\njpegcolormode = JPEGCOLORMODE_RGB;\nTIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n}\n/* The clause up to the read statement is taken from Tom Lane's tiffcp patch */\nelse\n{   /* Otherwise, can't handle subsampled input */\nif (input_photometric == PHOTOMETRIC_YCBCR)\n{\nTIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\n&subsampling_horiz, &subsampling_vert);\nif (subsampling_horiz != 1 || subsampling_vert != 1)\n{\nTIFFError(\"loadImage\",\n\"Can't copy/convert subsampled image with subsampling %d horiz %d vert\",\nsubsampling_horiz, subsampling_vert);\nreturn (-1);\n}\n}\n}\n\nread_buff = *read_ptr;\n/* +3 : add a few guard bytes since reverseSamples16bits() can read a bit */\n/* outside buffer */\nif (!read_buff)\nread_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\nelse\n{\nif (prev_readsize < buffsize)\n{\nnew_buff = _TIFFrealloc(read_buff, buffsize+3);\nif (!new_buff)\n{\nfree (read_buff);\nread_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n}\nelse\nread_buff = new_buff;\n}\n}\nif (!read_buff)\n{\nTIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\nreturn (-1);\n}\n\nread_buff[buffsize] = 0;\nread_buff[buffsize+1] = 0;\nread_buff[buffsize+2] = 0;\n\nprev_readsize = buffsize;\n*read_ptr = read_buff;\n\n/* N.B. The read functions used copy separate plane data into a buffer as interleaved\n* samples rather than separate planes so the same logic works to extract regions\n* regardless of the way the data are organized in the input file.\n*/\nswitch (readunit) {\ncase STRIP:\nif (planar == PLANARCONFIG_CONTIG)\n{\nif (!(readContigStripsIntoBuffer(in, read_buff)))\n{\nTIFFError(\"loadImage\", \"Unable to read contiguous strips into buffer\");\nreturn (-1);\n}\n}\nelse\n{\nif (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump)))\n{\nTIFFError(\"loadImage\", \"Unable to read separate strips into buffer\");\nreturn (-1);\n}\n}\nbreak;\n\ncase TILE:\nif (planar == PLANARCONFIG_CONTIG)\n{\nif (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n{\nTIFFError(\"loadImage\", \"Unable to read contiguous tiles into buffer\");\nreturn (-1);\n}\n}\nelse\n{\nif (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n{\nTIFFError(\"loadImage\", \"Unable to read separate tiles into buffer\");\nreturn (-1);\n}\n}\nbreak;\ndefault: TIFFError(\"loadImage\", \"Unsupported image file format\");\nreturn (-1);\nbreak;\n}\nif ((dump->infile != NULL) && (dump->level == 2))\n{\ndump_info  (dump->infile, dump->format, \"loadImage\",\n\"Image width %d, length %d, Raw image data, %4d bytes\",\nwidth, length,  buffsize);\ndump_info  (dump->infile, dump->format, \"\",\n\"Bits per sample %d, Samples per pixel %d\", bps, spp);\n\nfor (i = 0; i < length; i++)\ndump_buffer(dump->infile, dump->format, 1, scanlinesize,\ni, read_buff + (i * scanlinesize));\n}\nreturn (0);\n}",
    "int main(int argc, char **argv)\n{\n  if (argc < 2) {\n    std::cout << \"Needs input.tif\\n\";\n    return EXIT_FAILURE;\n  }\n\n  TIFF* tif = TIFFOpen(argv[1], \"r\");\n  if (tif) {\n    tdata_t buf;\n    tstrip_t strip;\n\n    // TODO: count is N(SamplesPerPixel)\n    uint16_t sampleformat;\n    if (!TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleformat)) {\n      sampleformat = 1;\n    }\n\n    uint16_t bitspersample;\n    if (!TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample)) {\n      std::cout << \"TIFFTAG_BITSPERSAMPLE not found\\n\";\n      return -1;\n    }\n\n    std::cout << \"bitspersample = \" << bitspersample << \"\\n\";\n    std::cout << \"sampleformat = \" << sampleformat << \"\\n\";\n\n    std::cout << \"strip size: \" << TIFFStripSize(tif) << \"\\n\";\n\n    buf = _TIFFmalloc(TIFFStripSize(tif));\n  \tfor (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {\n\t\t  TIFFReadEncodedStrip(tif, strip, buf, (tsize_t) -1);\n      if (sampleformat == 3) { // IEEEFP\n        assert(bitspersample == 32); // TODO: 64bit float\n        const float *pixels = reinterpret_cast<const float *>(buf);\n        const size_t num_pixels = TIFFStripSize(tif) / sizeof(float);\n        for (size_t i = 0; i < num_pixels; i++) {\n          std::cout << \"val[\" << i << \"] = \" << pixels[i] << \"\\n\";\n        }\n      } else if (sampleformat == 1) { // uint\n        if (bitspersample == 16) {\n          const uint16_t *pixels = reinterpret_cast<const uint16_t *>(buf);\n          const size_t num_pixels = TIFFStripSize(tif) / sizeof(uint16_t);\n          for (size_t i = 0; i < num_pixels; i++) {\n            std::cout << \"val[\" << i << \"] = \" << pixels[i] << \"\\n\";\n          }\n        }\n      }\n    }\n\t  _TIFFfree(buf);\n\t  TIFFClose(tif);\n  }\n\n  return EXIT_SUCCESS;\n}",
    "void XTiffImage::loadTIFF(const std::string& utf8Path) {\n    TIFFSetWarningHandler(onTiffWarning);\n    TIFFSetErrorHandler(onTiffError);\n    auto path = platform::UTF8ToACP(utf8Path);\n    tif = XTIFFOpen(path.c_str(), \"r\");\n\n    if (!tif) {\n        throw std::runtime_error(\"Couldn't open TIFF\");\n    }\n\n    if (!TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &fullWidth)) {\n        XTIFFClose(tif);\n        throw std::runtime_error(\"TIFF has no width\");\n    }\n\n    if (!TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &fullHeight)) {\n        XTIFFClose(tif);\n        throw std::runtime_error(\"TIFF has no height\");\n    }\n}",
    "void Compute(OpKernelContext* context) override {\n    const Tensor* input_tensor;\n    OP_REQUIRES_OK(context, context->input(\"input\", &input_tensor));\n\n    std::istringstream input_stream(input_tensor->scalar<tstring>()(),\n                                    std::ios_base::in | std::ios_base::binary);\n\n    std::unique_ptr<TIFF, void (*)(TIFF*)> tiff(\n        XTIFFStreamOpen(\"memory\", &input_stream), [](TIFF* p) {\n          if (p != nullptr) {\n            XTIFFClose(p);\n          }\n        });\n    OP_REQUIRES(context, (tiff.get() != nullptr),\n                errors::InvalidArgument(\"unable to open TIFF from memory\"));\n\n    std::vector<TensorShape> shape;\n    std::vector<DataType> dtype;\n    do {\n      unsigned int height, width;\n      TIFFGetField(tiff.get(), TIFFTAG_IMAGELENGTH, &height);\n      TIFFGetField(tiff.get(), TIFFTAG_IMAGEWIDTH, &width);\n\n      unsigned short channels;\n      TIFFGetField(tiff.get(), TIFFTAG_SAMPLESPERPIXEL, &channels);\n\n      shape.push_back(\n          TensorShape({static_cast<int64>(height), static_cast<int64>(width),\n                       static_cast<int64>(channels)}));\n\n      unsigned short format, bits;\n      if (!TIFFGetField(tiff.get(), TIFFTAG_SAMPLEFORMAT, &format)) {\n        // If format is not defined, then we assume format is SAMPLEFORMAT_UINT\n        format = SAMPLEFORMAT_UINT;\n      }\n      TIFFGetField(tiff.get(), TIFFTAG_BITSPERSAMPLE, &bits);\n      DataType pixel_dtype;\n      switch (format) {\n        case SAMPLEFORMAT_UINT:\n          switch (bits) {\n            case 8:\n              pixel_dtype = DT_UINT8;\n              break;\n            case 16:\n              pixel_dtype = DT_UINT16;\n              break;\n            default:\n              OP_REQUIRES(context, false,\n                          errors::InvalidArgument(\"unsupported bits \", bits,\n                                                  \" for uint\"));\n          }\n          break;\n        case SAMPLEFORMAT_INT:\n          switch (bits) {\n            default:\n              OP_REQUIRES(context, false,\n                          errors::InvalidArgument(\"unsupported bits \", bits,\n                                                  \" for int\"));\n          }\n          break;\n        case SAMPLEFORMAT_IEEEFP:\n          switch (bits) {\n            case 16:\n              pixel_dtype = DT_HALF;\n              break;\n            default:\n              OP_REQUIRES(context, false,\n                          errors::InvalidArgument(\"unsupported bits \", bits,\n                                                  \" for fp\"));\n          }\n          break;\n        default:\n          OP_REQUIRES(context, false,\n                      errors::InvalidArgument(\"unsupported format \", format));\n      }\n      dtype.push_back(pixel_dtype);\n\n      // GeoTIFF specifi information\n      // std::unique_ptr<GTIF, void(*)(GTIF*)> gtif(GTIFNew(tiff.get()),\n      // [](GTIF* p) { if (p != nullptr) { GTIFFree(p); } });\n      // OP_REQUIRES(context, (gtif.get() != nullptr),\n      // errors::InvalidArgument(\"unable to read GeoTIFF information\"));\n      // GTIFPrint(gtif,0,0);\n    } while (TIFFReadDirectory(tiff.get()));\n\n    Tensor* shape_tensor = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\n                       0, TensorShape({static_cast<int64>(shape.size()), 3}),\n                       &shape_tensor));\n    for (size_t i = 0; i < shape.size(); i++) {\n      shape_tensor->flat<int64>()(i * 3) = shape[i].dim_size(0);\n      shape_tensor->flat<int64>()(i * 3 + 1) = shape[i].dim_size(1);\n      shape_tensor->flat<int64>()(i * 3 + 2) = shape[i].dim_size(2);\n    }\n    Tensor* dtype_tensor = nullptr;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            1, TensorShape({static_cast<int64>(dtype.size())}), &dtype_tensor));\n    for (size_t i = 0; i < dtype.size(); i++) {\n      dtype_tensor->flat<int64>()(i) = dtype[i];\n    }\n  }",
    "void Compute(OpKernelContext* context) override {\n    const Tensor* input_tensor;\n    OP_REQUIRES_OK(context, context->input(\"input\", &input_tensor));\n\n    const Tensor* index_tensor;\n    OP_REQUIRES_OK(context, context->input(\"index\", &index_tensor));\n\n    std::istringstream input_stream(input_tensor->scalar<tstring>()(),\n                                    std::ios_base::in | std::ios_base::binary);\n\n    std::unique_ptr<TIFF, void (*)(TIFF*)> tiff(\n        XTIFFStreamOpen(\"memory\", &input_stream), [](TIFF* p) {\n          if (p != nullptr) {\n            XTIFFClose(p);\n          }\n        });\n    OP_REQUIRES(context, (tiff.get() != nullptr),\n                errors::InvalidArgument(\"unable to open TIFF from memory\"));\n\n    int status = TIFFSetDirectory(tiff.get(), index_tensor->scalar<int64>()());\n    OP_REQUIRES(context, (status),\n                errors::InvalidArgument(\"unable to set TIFF directory to \",\n                                        index_tensor->scalar<int64>()()));\n    unsigned int height, width;\n    TIFFGetField(tiff.get(), TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetField(tiff.get(), TIFFTAG_IMAGEWIDTH, &width);\n\n    Tensor* image_tensor = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\n                       0,\n                       TensorShape({static_cast<int64>(height),\n                                    static_cast<int64>(width), channels_}),\n                       &image_tensor));\n\n    uint32* raster =\n        reinterpret_cast<uint32*>(image_tensor->flat<uint8>().data());\n    OP_REQUIRES(context,\n                (TIFFReadRGBAImageOriented(tiff.get(), width, height, raster,\n                                           ORIENTATION_TOPLEFT, 0)),\n                errors::InvalidArgument(\"unable to read directory: \",\n                                        index_tensor->scalar<int64>()()));\n  }",
    "bool ossimGeoTiff::readTags( TIFF *tiff, ossim_uint32 entryIdx, bool ownTiffPtrFlag)\n{\n   std::lock_guard<std::mutex> lock(theMutex);\n\n   if (!tiff)\n   {\n      return false;\n   }\n\n   if (!TIFFSetDirectory(tiff, (ossim_uint16)entryIdx))\n   {\n      return false;\n   }\n\n   GTIF *gtif = GTIFNew(tiff);\n   if (!gtif)\n   {\n      return false;\n   }\n\n   if (theTiffPtr)\n   {\n      XTIFFClose(theTiffPtr);\n   }\n   theTiffPtr = tiff;\n\n   if (thePrivateDefinitions->m_defs)\n   {\n      delete thePrivateDefinitions->m_defs;\n      ;\n   }\n   thePrivateDefinitions->m_defs = new GTIFDefn;\n   GTIFGetDefn(gtif, thePrivateDefinitions->m_defs);\n   ossim_uint32 idx = 0;\n   theGeoKeysPresentFlag = true;\n   if (traceDebug())\n   {\n      ossimNotify(ossimNotifyLevel_DEBUG)\n          << \"ossimGeoTiff::readTags: Raw Geotiff Tags are\\n\";\n      GTIFPrint(gtif, 0, 0);\n   }\n   if (TIFFGetField(theTiffPtr,\n                    TIFFTAG_IMAGELENGTH,\n                    &theLength))\n   {\n   }\n   if (TIFFGetField(theTiffPtr,\n                    TIFFTAG_IMAGEWIDTH,\n                    &theWidth))\n   {\n   }\n   theScaleFactor = 0.0;\n   theModelType = thePrivateDefinitions->m_defs->Model;\n   theGcsCode = thePrivateDefinitions->m_defs->GCS;\n   thePcsCode = thePrivateDefinitions->m_defs->PCS;\n   theDatumCode = thePrivateDefinitions->m_defs->Datum;\n   theAngularUnits = thePrivateDefinitions->m_defs->UOMAngle;\n   theLinearUnitsCode = thePrivateDefinitions->m_defs->UOMLength;\n\n   if (theAngularUnits == ANGULAR_DMS_HEMISPHERE || theAngularUnits == 9122)\n   {\n      //---\n      // Hack for bug, where the libgeotiff funtion GTIFGetDefn sets the angular units\n      // incorrectly to ANGULAR_DMS_HEMISPHERE:\n      if (traceDebug())\n      {\n         ossimNotify(ossimNotifyLevel_WARN)\n             << \" WARNING ossimGeoTiff::addImageGeometry:\"\n             << \"The angular units (key 2054) is set to ANGULAR_DMS_HEMISPHERE!\"\n             << \"\\nAssuming \\\"Angular_Degree\\\"...\" << std::endl;\n      }\n      theAngularUnits = ANGULAR_DEGREE;\n   }\n\n#if 0\n   ossim_uint16 modelType;\n   if(GTIFKeyGet(gtif, GTModelTypeGeoKey, &modelType, 0, 1))\n   {\n      theModelType = (ModelType)modelType;\n   }\n#endif\n   if (GTIFKeyGet(gtif, GTRasterTypeGeoKey, &theRasterType, 0, 1))\n   {\n   }\n\n#if 0\n   if(GTIFKeyGet(gtif, GeographicTypeGeoKey, &theGcsCode, 0, 1))\n   {\n   }\n   if(GTIFKeyGet(gtif, GeogGeodeticDatumGeoKey, &theDatumCode, 0, 1))\n   {\n   }\n   if(GTIFKeyGet(gtif, GeogAngularUnitsGeoKey, &theAngularUnits, 0, 1))\n   {\n   }\n#endif\n\n   if (GTIFKeyGet(gtif, ProjectedCSTypeGeoKey, &thePcsCode, 0, 1))\n      parsePcsCode();\n\n   //---\n   // ESH 2/2008 -- Handle geotiff's with state plane coordinate systems produced by ERDAS.\n   // They use the citation filed to specify the geometry (complete HACK by Erdas)\n   //---\n   else\n   {\n      const int CITATION_STRING_SIZE = 512;\n      char citationStr[CITATION_STRING_SIZE];\n      if (GTIFKeyGet(gtif, GTCitationGeoKey, &citationStr,\n                     0, CITATION_STRING_SIZE))\n      {\n         ossimString gTCitation = citationStr; // key 1026\n\n         // Extract state plane string from the citation key\n         ossimString projStrTemp =\n             gTCitation.afterRegExp(\"Projection Name = \");\n\n         ossimString projStr = projStrTemp.beforeRegExp(\"\\n\");\n         if (projStr.empty() == false)\n         {\n            ossimEpsgProjectionFactory *f = ossimEpsgProjectionFactory::instance();\n            ossimProjection *proj = f->createProjection(projStr);\n            ossimMapProjection *map_proj = PTR_CAST(ossimMapProjection, proj);\n            parseProjection(map_proj);\n         }\n      } // End of \"if(GTIFKeyGet(gtif, GTCitationGeoKey...\"\n   }\n\n   char *buf = 0;\n   theOriginLon = ossim::nan();\n   theOriginLat = ossim::nan();\n   if (GTIFKeyGet(gtif, PCSCitationGeoKey, &buf, 0, 1))\n   {\n      thePcsCitation = ossimString(buf);\n   }\n   GTIFKeyGet(gtif, ProjCoordTransGeoKey, &theCoorTransGeoCode, 0, 1);\n   for (idx = 0; idx < (ossim_uint32)thePrivateDefinitions->m_defs->nParms; ++idx)\n   {\n      switch (thePrivateDefinitions->m_defs->ProjParmId[idx])\n      {\n      case ProjStdParallel1GeoKey:\n      {\n         theStdPar1 = thePrivateDefinitions->m_defs->ProjParm[idx];\n         break;\n      }\n      case ProjStdParallel2GeoKey:\n      {\n         theStdPar2 = thePrivateDefinitions->m_defs->ProjParm[idx];\n         break;\n      }\n      case ProjOriginLongGeoKey:\n      {\n         theOriginLon = thePrivateDefinitions->m_defs->ProjParm[idx];\n         break;\n      }\n      case ProjOriginLatGeoKey:\n      {\n         theOriginLat = thePrivateDefinitions->m_defs->ProjParm[idx];\n         break;\n      }\n      case ProjFalseEastingGeoKey:\n      {\n         theFalseEasting = thePrivateDefinitions->m_defs->ProjParm[idx];\n         break;\n      }\n      case ProjFalseNorthingGeoKey:\n      {\n         theFalseNorthing = thePrivateDefinitions->m_defs->ProjParm[idx];\n         break;\n      }\n      case ProjCenterLongGeoKey:\n      {\n         theOriginLon = thePrivateDefinitions->m_defs->ProjParm[idx];\n         break;\n      }\n      case ProjCenterLatGeoKey:\n      {\n         theOriginLat = thePrivateDefinitions->m_defs->ProjParm[idx];\n         break;\n      }\n      case ProjFalseOriginLatGeoKey:\n      {\n         theOriginLat = thePrivateDefinitions->m_defs->ProjParm[idx];\n         break;\n      }\n      case ProjFalseOriginLongGeoKey:\n      case ProjStraightVertPoleLongGeoKey:\n      {\n         theOriginLon = thePrivateDefinitions->m_defs->ProjParm[idx];\n         break;\n      }\n      case ProjScaleAtNatOriginGeoKey:\n      {\n         theScaleFactor = thePrivateDefinitions->m_defs->ProjParm[idx];\n         break;\n      }\n      }\n   }\n\n#if 0\n   if(GTIFKeyGet(gtif, ProjStdParallel1GeoKey, &theStdPar1, 0, 1))\n   {\n   }\n   if(GTIFKeyGet(gtif, ProjStdParallel2GeoKey, &theStdPar2, 0, 1))\n   {\n   }\n   if(GTIFKeyGet(gtif, ProjNatOriginLongGeoKey, &tempDouble, 0, 1))\n   {\n      theOriginLon = tempDouble;\n   }\n   else if(GTIFKeyGet(gtif, ProjOriginLongGeoKey, &tempDouble, 0, 1))\n   {\n      theOriginLon = tempDouble;\n   }\n   if(GTIFKeyGet(gtif, ProjNatOriginLatGeoKey, &tempDouble, 0, 1))\n   {\n      theOriginLat = tempDouble;\n   }\n   else if(GTIFKeyGet(gtif, ProjOriginLatGeoKey, &tempDouble, 0, 1))\n   {\n      theOriginLat = tempDouble;\n   }\n   if(GTIFKeyGet(gtif, ProjFalseEastingGeoKey, &theFalseEasting, 0, 1))\n   {\n   }\n   if(GTIFKeyGet(gtif, ProjFalseNorthingGeoKey, &theFalseNorthing, 0, 1))\n   {\n   }\n   if(GTIFKeyGet(gtif, ProjCenterLongGeoKey, &theCenterLon, 0, 1))\n   {\n   }\n   if(GTIFKeyGet(gtif, ProjCenterLatGeoKey, &theCenterLat, 0, 1))\n   {\n   }\n   if(GTIFKeyGet(gtif, ProjScaleAtNatOriginGeoKey, &theScaleFactor, 0, 1))\n   {\n   }\n#endif\n   theScale.clear();\n   theTiePoint.clear();\n   theModelTransformation.clear();\n   ossim_uint16 transSize = 0;\n   double *trans = 0;\n\n   // Geotiff spec (Section 2.6.1: GeoTIFF Tags for Coordinate Transformations) states that either\n   // an image-to-model transform is given, or a tie-point and scale, but not both. Presently, only\n   // transform in meters/pixel units are handled, since the map projection easting/northing is\n   // processed in meters. This may be a bad decision...(OLK 2020)\n   if (TIFFGetField(theTiffPtr, TIFFTAG_GEOTRANSMATRIX, &transSize, &trans))\n   {\n      theModelTransformation.insert(theModelTransformation.begin(), trans, trans + transSize);\n      //initTiePointsFromImageModelTransform();\n   }\n   else\n   {\n      ossim_uint16 tiePointSize = 0;\n      double *tiepoints = 0;\n      if (TIFFGetField(theTiffPtr, TIFFTAG_GEOTIEPOINTS, &tiePointSize, &tiepoints))\n      {\n         theTiePoint.insert(theTiePoint.begin(), tiepoints, tiepoints + tiePointSize);\n\n         // ESH 05/2009 -- If the image is in a projected coordinate system, the\n         // tiepoints will be projected coordinates not lat/lon. Let's avoid setting\n         // the origin lon/lat to projected x/y. Fix for ticket #711.\n         //if ( theModelType == ModelTypeGeographic )\n         //{\n         //   if(ossim::isnan(theOriginLon) &&\n         //      (pixScaleSize > 1) &&\n         //      (tiePointSize > 3))\n         //   {\n         //      theOriginLon = tiepoints[3] - tiepoints[0] * pixScale[0];\n         //   }\n         //\n         //   if(ossim::isnan(theOriginLat) && (pixScaleSize > 1) && (tiePointSize > 3))\n         //   {\n         //      theOriginLat = tiepoints[4] + tiepoints[1] * fabs(pixScale[1]);\n         //   }\n         //}\n      }\n      ossim_uint16 pixScaleSize = 0;\n      double *pixScale = 0;\n      if (TIFFGetField(theTiffPtr, TIFFTAG_GEOPIXELSCALE, &pixScaleSize, &pixScale))\n      {\n         theScale.insert(theScale.begin(), pixScale, pixScale + pixScaleSize);\n         if (theModelType == ModelTypeGeographic)\n         {\n            // The origin latitude must be computed so as to achieve the proper horizontal scaling:\n            theOriginLat = ossim::acosd(theScale[1] / theScale[0]);\n         }\n      }\n   }\n\n   ossim_uint16 doubleParamSize = 0;\n   double *tempDoubleParam = 0;\n   theDoubleParam.clear();\n   if (TIFFGetField(theTiffPtr, TIFFTAG_GEODOUBLEPARAMS, &doubleParamSize, &tempDoubleParam))\n   {\n      theDoubleParam.insert(theDoubleParam.begin(),\n                            tempDoubleParam,\n                            tempDoubleParam + doubleParamSize);\n   }\n\n   char *tempAsciiParam = 0;\n   theAsciiParam = \"\";\n\n   // Note: this tag does not have the setting set to return the size\n   // so this call is only a 3 argument call without a size parameter\n   if (TIFFGetField(theTiffPtr, TIFFTAG_GEOASCIIPARAMS, &tempAsciiParam))\n   {\n      theAsciiParam = tempAsciiParam;\n   }\n\n   if (theGeoKeysPresentFlag)\n   {\n      setOssimProjectionName(); // Initialize the ossim projection name.\n      setOssimDatumName();      // Initialize the ossim datum name.\n   }\n\n   // commenting this out.  Frank mentioned the GTIFFGetDefn which in geo_normalize\n   // this should be all we need.\n   //\n#if 0\n   /* \n      ESH 05/2009: Replacing badly broken code for making \n      use of TIFFTAG_GEODOUBLEPARAMS.\n\n      Read the geokey directory tag in order to see how \n      the TIFFTAG_GEODOUBLEPARAMS are defined.\n\n      For structure of geokey directory, see:\n      http://www.remotesensing.org/geotiff/spec/geotiff2.4.html\n   */\n   ossim_uint16  gkdParamSize = 0;\n   ossim_uint16* gkdParams = 0;\n   if(TIFFGetField(theTiffPtr, TIFFTAG_GEOKEYDIRECTORY, &gkdParamSize, &gkdParams))\n   {\n      ossim_uint16 numKeys = gkdParams ? gkdParams[3] : 0;\n      ossim_uint16 key = 0;\n      for( key=0; key<numKeys; ++key )\n      {\n         ossim_uint16 loc = (key+1) * 4;\n         ossim_uint16 ind = gkdParams[loc+3];\n\n         if ( gkdParams[loc+1] == TIFFTAG_GEODOUBLEPARAMS && \n              gkdParams[loc+2] == 1 && \n              ind >= 0 && ind < doubleParamSize )\n         {\n            double dval = theDoubleParam[ind];\n            switch( gkdParams[loc] )\n            {\n               case ProjStdParallel1GeoKey:     theStdPar1       = dval; break;\n               case ProjStdParallel2GeoKey:     theStdPar2       = dval; break;\n               case ProjNatOriginLongGeoKey:    theOriginLon     = dval; break;\n               /* case ProjOriginLongGeoKey:       theOriginLon     = dval; break; (alias) */\n               case ProjNatOriginLatGeoKey:     theOriginLat     = dval; break;\n               /* case ProjOriginLatGeoKey:        theOriginLat     = dval; break; (alias) */\n               case ProjFalseEastingGeoKey:     theFalseEasting  = dval; break;\n               case ProjFalseNorthingGeoKey:    theFalseNorthing = dval; break;\n               case ProjCenterLongGeoKey:       theCenterLon     = dval; break;\n               case ProjCenterLatGeoKey:        theCenterLat     = dval; break;\n               case ProjScaleAtNatOriginGeoKey: theScaleFactor   = dval; break;\n               default: \n                  if(traceDebug())\n                  {\n                     ossimNotify(ossimNotifyLevel_DEBUG)\n                        << \"ossimGeoTiff::readTags: Unrecognized geokey directory entry.\"\n                        << \"\\ngeokey directory index = \" << loc\n                        << \"\\ngeokey = \" << gkdParams[loc]\n                        << \"\\ndouble array index = \" << ind\n                        << \"\\ndval = \" << dval\n                        << std::endl;\n                  }\n                  break;\n            }\n         }\n      }\n   }\n#endif\n\n   GTIFFree(gtif);\n\n   if (ownTiffPtrFlag == false)\n   {\n      //---\n      // Zero out the pointer so the destructor doesn't close it on some\n      // external code.\n      //---\n      theTiffPtr = 0;\n   }\n\n   return true;\n}",
    "void ossim::TiffHandlerState::loadDirectory(TIFF* tiffPtr, \n                                            ossim_uint32 directory)\n{\n  ossim_uint32  imageWidth=0;\n  ossim_uint32  imageLength=0;\n  // ossim_int32   readMethod=0;\n  ossim_uint16  planarConfig=0;\n  ossim_uint16  photometric=0;\n  ossim_uint32  rowsPerStrip=0;\n  ossim_uint32  imageTileWidth=0;\n  ossim_uint32  imageTileLength=0;\n  // ossim_uint32  imageDirectoryList=0;\n  ossim_int32   compressionType=0;\n  ossim_uint32  subFileType=0;\n  ossim_uint16  bitsPerSample=0;\n  ossim_uint16  samplesPerPixel=0;\n  ossim_uint16  sampleFormatUnit=0;\n  ossim_float64 sampleValue=0;\n  ossim_uint16  sampleUintValue = 0;\n\n  ossim_int32   numberOfDirectories = TIFFNumberOfDirectories(tiffPtr);\n\n  addValue(\"number_of_directories\", ossimString::toString(numberOfDirectories));\n\n  if(TIFFCurrentDirectory(tiffPtr) != directory)\n  {\n    if(!TIFFSetDirectory(tiffPtr, directory))\n    {\n      return;\n    }\n  }\n  ossimString dirPrefix = \"tiff.image\"+ossimString::toString(directory)+\".\";\n\n  if(TIFFGetField(tiffPtr, TIFFTAG_COMPRESSION, &compressionType))\n  {\n    addValue(dirPrefix+\"compression\", ossimString::toString(compressionType));\n  } \n\n  if( TIFFGetField(tiffPtr, TIFFTAG_BITSPERSAMPLE, &bitsPerSample) )\n  {\n    addValue(dirPrefix+\"bits_per_sample\", ossimString::toString(bitsPerSample));\n  }\n  if( TIFFGetField(tiffPtr,\n                   TIFFTAG_SAMPLESPERPIXEL,\n                   &samplesPerPixel ) )\n  {\n    addValue(dirPrefix+\"samples_per_pixel\", ossimString::toString(samplesPerPixel));\n  }\n\n  if ( TIFFGetField( tiffPtr,\n                     TIFFTAG_SAMPLEFORMAT,\n                     &sampleFormatUnit ) )\n  {\n    addValue(dirPrefix+\"sample_format\", ossimString::toString(sampleFormatUnit));\n  }\n\n  if (TIFFGetField(tiffPtr,\n                   TIFFTAG_SMAXSAMPLEVALUE,\n                    &sampleValue ) )\n  {\n    addValue(dirPrefix+\"max_sample_value\", ossimString::toString(sampleValue));\n  }\n  else\n  {\n    if(TIFFGetField( tiffPtr,\n                      TIFFTAG_MAXSAMPLEVALUE,\n                      &sampleUintValue))\n    {\n      addValue(dirPrefix+\"max_sample_value\", ossimString::toString(sampleUintValue));\n    }\n\n  }\n\n  if ( TIFFGetField( tiffPtr,\n                     TIFFTAG_SMINSAMPLEVALUE,\n                     &sampleValue ) )\n  {\n    addValue(dirPrefix+\"min_sample_value\", ossimString::toString(sampleValue));\n  }\n  else\n  {\n    if(TIFFGetField( tiffPtr,\n                      TIFFTAG_MINSAMPLEVALUE,\n                      &sampleUintValue))\n    {\n      addValue(dirPrefix+\"min_sample_value\", ossimString::toString(sampleUintValue));\n    }\n  }\n\n    \n  // lines:\n  if ( TIFFGetField( tiffPtr,\n                      TIFFTAG_IMAGELENGTH,\n                      &imageLength ) )\n  {\n    addValue(dirPrefix+\"image_length\", \n             ossimString::toString(imageLength));\n  }\n\n  // samples:\n  if ( TIFFGetField( tiffPtr,\n                      TIFFTAG_IMAGEWIDTH,\n                      &imageWidth ) )\n  {\n    addValue(dirPrefix+\"image_width\", \n             ossimString::toString(imageWidth));\n  }\n  \n  if (TIFFGetField(tiffPtr,\n                   TIFFTAG_SUBFILETYPE ,\n                   &subFileType ) )\n  {\n    addValue(dirPrefix+\"sub_file_type\", ossimString::toString(subFileType));\n  }\n\n  if( TIFFGetField( tiffPtr, TIFFTAG_PLANARCONFIG,\n                     &planarConfig ) )\n  {\n    addValue(dirPrefix+\"planar_configuration\", \n             ossimString::toString(planarConfig));\n  }\n  \n  if( TIFFGetField( tiffPtr, TIFFTAG_PHOTOMETRIC,\n                     &photometric ) )\n  {\n    addValue(dirPrefix + \"photo_interpretation\",\n             ossimString::toString(photometric));\n  }\n\n  // Check for palette.\n  ossim_uint16* red;\n  ossim_uint16* green;\n  ossim_uint16* blue;\n  if(TIFFGetField(tiffPtr, TIFFTAG_COLORMAP, &red, &green, &blue))\n  {\n    if(bitsPerSample)\n    {\n      saveColorMap(dirPrefix, red, green, blue, 1<<bitsPerSample);\n    }\n  }\n\n  if( TIFFIsTiled(tiffPtr))\n  {\n    addValue(dirPrefix+\"is_tiled\", \"true\");\n    if ( TIFFGetField( tiffPtr,\n                       TIFFTAG_TILEWIDTH,\n                       &imageTileWidth ) )\n    {\n      addValue(dirPrefix+\"tile_width\", \n               ossimString::toString(imageTileWidth));\n    }\n    if ( TIFFGetField( tiffPtr,\n                       TIFFTAG_TILELENGTH,\n                       &imageTileLength ) )\n    {\n      addValue(dirPrefix+\"tile_length\", \n               ossimString::toString(imageTileLength));\n    }\n  }\n  else\n  {\n    addValue(dirPrefix+\"tiff_is_tiled\", \"false\");\n    if( TIFFGetField( tiffPtr, TIFFTAG_ROWSPERSTRIP,\n                      &rowsPerStrip ) )\n    {\n      addValue(dirPrefix+\"rows_per_strip\", \n               ossimString::toString(rowsPerStrip));\n    }\n  }\n\n  loadGeotiffTags(tiffPtr, dirPrefix);    \n}",
    "void ossim::TiffHandlerState::loadGeotiffTags(TIFF* tiffPtr,\n                                              const ossimString& dirPrefix )\n{\n  const int CITATION_STRING_SIZE = 512;\n  ossim_uint16 rasterType = 0;\n  ossim_uint16 pcsCode = 0;\n  ossim_uint16 coordTransGeoCode = 0;\n  // ossim_uint32 idx = 0;\n  GTIF* gtif = GTIFNew(tiffPtr);\n  char citationStrPtr[CITATION_STRING_SIZE];\n  char* buf = 0;\n  ossim_uint16 doubleArraySize = 0;\n  double tempDouble=0.0;\n  double* doubleArray=0;\n  ossimString doubleArrayStr;\n  bool loadedGeotiff = false;\n  if(!gtif)\n  {\n    addValue(dirPrefix+\"is_geotiff\", \"false\");\n    return;\n  } \n\n  // Note:  For some reason I am having troubles using\n  // GTIFGetDefn so I have to query them directly.  I was getting\n  // Core dumps in the JNI calls to the OSSIM core library.\n  // Until this is resolved I will use the direct method of getting\n  // the values I need.\n  //\n  ossim_uint16 tempUint16 = 0; \n  if(GTIFKeyGet(gtif, GTModelTypeGeoKey, &tempUint16, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"model_type\", \n           ossimString::toString(tempUint16));\n  }\n  if(GTIFKeyGet(gtif, GeographicTypeGeoKey, &tempUint16, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"gcs_code\", \n           ossimString::toString(tempUint16));\n  }\n  if(GTIFKeyGet(gtif, GeogGeodeticDatumGeoKey, &tempUint16, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"datum_code\", \n           ossimString::toString(tempUint16));\n  }\n  if(GTIFKeyGet(gtif, GeogAngularUnitsGeoKey, &tempUint16, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"angular_units\", \n           ossimString::toString(tempUint16));\n  }\n  if(GTIFKeyGet(gtif, GeogLinearUnitsGeoKey, &tempUint16, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"linear_units\", \n           ossimString::toString(tempUint16));\n  }\n\n  if(GTIFKeyGet(gtif, ProjStdParallel1GeoKey, &tempDouble, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"std_parallel_1\", \n            ossimString::toString(tempDouble));\n  }\n  if(GTIFKeyGet(gtif, ProjStdParallel2GeoKey, &tempDouble, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"std_parallel_2\", \n            ossimString::toString(tempDouble));\n  }\n  if(GTIFKeyGet(gtif, ProjNatOriginLongGeoKey, &tempDouble, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"origin_lon\", \n            ossimString::toString(tempDouble));\n  }\n  else if(GTIFKeyGet(gtif, ProjOriginLongGeoKey, &tempDouble, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"origin_lon\", \n            ossimString::toString(tempDouble));\n  }\n  if(GTIFKeyGet(gtif, ProjNatOriginLatGeoKey, &tempDouble, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"origin_lat\", \n            ossimString::toString(tempDouble));\n  }\n  else if(GTIFKeyGet(gtif, ProjOriginLatGeoKey, &tempDouble, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"origin_lat\", \n            ossimString::toString(tempDouble));\n  }\n  if(GTIFKeyGet(gtif, ProjFalseEastingGeoKey, &tempDouble, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"false_easting\", \n            ossimString::toString(tempDouble));\n  }\n  if(GTIFKeyGet(gtif, ProjFalseNorthingGeoKey, &tempDouble, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"false_northing\", \n            ossimString::toString(tempDouble));\n  }\n  if(GTIFKeyGet(gtif, ProjCenterLongGeoKey, &tempDouble, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"center_lon\", \n            ossimString::toString(tempDouble));\n  }\n  if(GTIFKeyGet(gtif, ProjCenterLatGeoKey, &tempDouble, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"center_lat\", \n            ossimString::toString(tempDouble));\n  }\n  if(GTIFKeyGet(gtif, ProjScaleAtNatOriginGeoKey, &tempDouble, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"scale_factor\", \n            ossimString::toString(tempDouble));\n  }\n  if(GTIFKeyGet(gtif, GTRasterTypeGeoKey, &rasterType, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"raster_type\", \n             ossimString::toString(rasterType));\n\n  }\n  if (GTIFKeyGet(gtif, ProjectedCSTypeGeoKey, &pcsCode, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"pcs_code\", \n             ossimString::toString(pcsCode));\n  }\n\n  if ( GTIFKeyGet(gtif, GTCitationGeoKey, &citationStrPtr ,\n                  0, CITATION_STRING_SIZE))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"citation\", \n             ossimString(citationStrPtr));\n  }\n  if(GTIFKeyGet(gtif, PCSCitationGeoKey , &buf, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"pcs_citation\", \n             buf);\n  }\n  if(GTIFKeyGet(gtif, ProjCoordTransGeoKey , &coordTransGeoCode, 0, 1))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"coord_trans_code\", \n             ossimString::toString(coordTransGeoCode));\n  }\n\n  if(TIFFGetField(tiffPtr, TIFFTAG_GEOPIXELSCALE, &doubleArraySize, &doubleArray))\n  {\n    loadedGeotiff = true;\n    convertArrayToStringList(doubleArrayStr, doubleArray, doubleArraySize);\n    if(!doubleArrayStr.empty())\n    {\n      addValue(dirPrefix+\"geo_pixel_scale\", doubleArrayStr);\n    }\n  }\n  if(TIFFGetField(tiffPtr, TIFFTAG_GEOTIEPOINTS,  &doubleArraySize, &doubleArray))\n  {\n    loadedGeotiff = true;\n    convertArrayToStringList(doubleArrayStr, doubleArray, doubleArraySize);\n    if(!doubleArrayStr.empty())\n    {\n      addValue(dirPrefix+\"geo_tie_points\", doubleArrayStr);\n    }\n  }\n  if(TIFFGetField(tiffPtr, TIFFTAG_GEODOUBLEPARAMS, &doubleArraySize, &doubleArray))\n  {\n    loadedGeotiff = true;\n    convertArrayToStringList(doubleArrayStr, doubleArray, doubleArraySize);\n    if(!doubleArrayStr.empty())\n    {\n      addValue(dirPrefix+\"geo_double_params\", doubleArrayStr);\n    }\n  }\n  if(TIFFGetField(tiffPtr, TIFFTAG_GEOTRANSMATRIX, &doubleArraySize, &doubleArray))\n  {\n    loadedGeotiff = true;\n    convertArrayToStringList(doubleArrayStr, doubleArray, doubleArraySize);\n    if(!doubleArrayStr.empty())\n    {\n      addValue(dirPrefix+\"geo_trans_matrix\", doubleArrayStr);\n    }\n  }\n  if(TIFFGetField(tiffPtr, TIFFTAG_GEOASCIIPARAMS, &buf))\n  {\n    loadedGeotiff = true;\n    addValue(dirPrefix+\"geo_ascii_params\", buf);\n  }\n#if 0\n  if(gtif)\n  {\n    GTIFDefn *defs = GTIFAllocDefn();\n    GTIFGetDefn(gtif, defs);\n    if (!exists(dirPrefix + \"angular_units\"))\n    {\n      loadedGeotiff = true;\n      addValue(dirPrefix + \"angular_units\",\n               ossimString::toString(defs->UOMAngle));\n    }\n    if (!exists(dirPrefix + \"linear_units\"))\n    {\n      loadedGeotiff = true;\n      addValue(dirPrefix + \"linear_units\",\n               ossimString::toString(defs->UOMLength));\n    }\n    if (!exists(dirPrefix + \"datum_code\"))\n    {\n      loadedGeotiff = true;\n      addValue(dirPrefix + \"datum_code\",\n               ossimString::toString(defs->Datum));\n    }\n    if (!exists(dirPrefix + \"pcs_code\"))\n    {\n      loadedGeotiff = true;\n      addValue(dirPrefix + \"pcs_code\",\n               ossimString::toString(defs->PCS));\n    }\n    if (!exists(dirPrefix + \"gcs_code\"))\n    {\n      loadedGeotiff = true;\n      addValue(dirPrefix + \"gcs_code\",\n               ossimString::toString(defs->GCS));\n    }\n    if (!exists(dirPrefix + \"model_type\"))\n    {\n      loadedGeotiff = true;\n      addValue(dirPrefix + \"model_type\",\n               ossimString::toString(defs->Model));\n    }\n    GTIFFreeDefn(defs);\n  }\n#endif\n\n  addValue(dirPrefix+\"is_geotiff\", ossimString::toString(loadedGeotiff));\n  GTIFFree(gtif);\n}",
    "bool\tExtractGeoTiff(DEMGeo& inMap, const char * inFileName, int post_style, int no_geo_needed)\n{\n\tint result = -1;\n\tdouble\tcorners[8];\n\tTIFF * tif;\n\tTIFFErrorHandler\twarnH = TIFFSetWarningHandler(IgnoreTiffWarnings);\n\tTIFFErrorHandler\terrH = TIFFSetErrorHandler(IgnoreTiffErrs);\n\tStTiffMemFile\ttiffMem(inFileName);\n\tif (tiffMem.file == NULL) goto bail;\n\n\tprintf(\"Trying file: %s\\n\", inFileName);\n\ttif = XTIFFClientOpen(inFileName, \"r\", &tiffMem,\n\t    MemTIFFReadWriteProc, MemTIFFReadWriteProc,\n\t    MemTIFFSeekProc, MemTIFFCloseProc,\n\t    MemTIFFSizeProc,\n\t    MemTIFFMapFileProc, MemTIFFUnmapFileProc);\n\tprintf(\"Opened TIF file.\\n\");\n//    TIFF* tif = TIFFOpen(inFileName, \"r\");\n\n    if (tif == NULL) goto bail;\n\n\tif (!FetchTIFFCornersWithTIFF(tif, corners, post_style))\n\t{\n\t\tif(no_geo_needed)\n\t\t{\n\t\t\tprintf(\"TIFF has no corners - using default.\\n\");\n\t\t\tinMap.mWest = -180;\n\t\t\tinMap.mSouth = -90;\n\t\t\tinMap.mEast = 180;\n\t\t\tinMap.mNorth = 90;\n\t\t\tinMap.mPost = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"Could not read GeoTiff projection data.\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tinMap.mWest = corners[0];\n\tinMap.mSouth = corners[1];\n\tinMap.mEast = corners[6];\n\tinMap.mNorth = corners[7];\n\tinMap.mPost = (post_style == dem_want_Post);\n\n\tprintf(\"Corners: %.12lf,%.12lf   %.12lf,%.12lf   %.12lf,%.12lf   %.12lf,%.12lf\\n\",\n\t\tcorners[0], corners[1], corners[2], corners[3], corners[4], corners[5], corners[6], corners[7]);\n\n\tuint32 w, h;\n\tuint16 cc;\n\tuint16 d;\n\tuint16 format;\n\t\n\tformat = SAMPLEFORMAT_UINT;\t// sample format is NOT mandatory - unsigned int is the default if not present!\n\n\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cc);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &d);\n\tTIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &format);\n\tprintf(\"Image is: %dx%d, samples: %d, depth: %d, format: %d\\n\", w, h, cc, d, format);\n\n\tinMap.resize(w,h);\n\t\n\tif(TIFFIsTiled(tif))\n\t{\n\t\tuint32\ttw, th;\n\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n\t\ttdata_t buf = _TIFFmalloc(TIFFTileSize(tif));\n\t\tfor (int y = 0; y < h; y += th)\n\t\tfor (int x = 0; x < w; x += tw)\n\t\t{\n\t\t\tresult = TIFFReadTile(tif, buf, x, y, 0, 0);\n\t\t\tif (result == -1) { printf(\"Tiff error in read.\\n\"); break; }\n\n\t\t\tint ux = min(tw,w-x);\n\t\t\tint uy = min(th,h-y);\n\n\t\t\tswitch(format) {\n\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\tswitch(d) {\n\t\t\t\tcase 8:\n\t\t\t\t\tcopy_tile<unsigned char>((const unsigned char *) buf, x,y,ux,uy, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\tcopy_tile<unsigned short>((const unsigned short *) buf, x,y,ux,uy, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 32:\n\t\t\t\t\tcopy_tile<unsigned int>((const unsigned int *) buf, x,y,ux,uy, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"TIFF error: unsupported unsigned int sample depth: %d\\n\", d);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\tswitch(d) {\n\t\t\t\tcase 8:\n\t\t\t\t\tcopy_tile<char>((const char *) buf, x,y,ux,uy, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\tcopy_tile<short>((const short *) buf, x,y,ux,uy, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 32:\n\t\t\t\t\tcopy_tile<int>((const int *) buf, x,y,ux,uy, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"TIFF error: unsupported signed int sample depth: %d\\n\", d);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\tswitch(d) {\n\t\t\t\tcase 32:\n\t\t\t\t\tcopy_tile<float>((const float *) buf, x,y,ux,uy, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 64:\n\t\t\t\t\tcopy_tile<double>((const double *) buf, x,y,ux,uy, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"TIFF error: unsupported floating point sample depth: %d\\n\", d);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"TIFF error: unsupported pixel format %d\\n\", format);\n\t\t\t\tbreak;\t\t\t\n\t\t\t}\n\t\t}\n\n\t\t_TIFFfree(buf);\t\n\n\t\tTIFFClose(tif);\n\n\t\tTIFFSetWarningHandler(warnH);\n\t\tTIFFSetErrorHandler(errH);\n\t\treturn result != -1;\n\t}\n\telse\n\t{\n\t\ttsize_t line_size = TIFFScanlineSize(tif);\n\t\ttdata_t aline = _TIFFmalloc(line_size);\n\n\t\tint cs = TIFFCurrentStrip(tif);\n\t\tint nos = TIFFNumberOfStrips(tif);\n\t\tint cr = TIFFCurrentRow  (tif);\n\n\t\tfor (int y = 0; y < h; ++y)\n\t\t{\n\t\t\tresult = TIFFReadScanline(tif, aline, y, 0);\n\t\t\tif (result == -1) { printf(\"Tiff error in read.\\n\"); break; }\n\n\t\t\tswitch(format) {\n\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\tswitch(d) {\n\t\t\t\tcase 8:\n\t\t\t\t\tcopy_scanline<unsigned char>((const unsigned char *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\tcopy_scanline<unsigned short>((const unsigned short *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 32:\n\t\t\t\t\tcopy_scanline<unsigned int>((const unsigned int *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"TIFF error: unsupported unsigned int sample depth: %d\\n\", d);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\tswitch(d) {\n\t\t\t\tcase 8:\n\t\t\t\t\tcopy_scanline<char>((const char *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\tcopy_scanline<short>((const short *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 32:\n\t\t\t\t\tcopy_scanline<int>((const int *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"TIFF error: unsupported signed int sample depth: %d\\n\", d);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\tswitch(d) {\n\t\t\t\tcase 32:\n\t\t\t\t\tcopy_scanline<float>((const float *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 64:\n\t\t\t\t\tcopy_scanline<double>((const double *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"TIFF error: unsupported floating point sample depth: %d\\n\", d);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"TIFF error: unsupported pixel format %d\\n\", format);\n\t\t\t\tbreak;\t\t\t\n\t\t\t}\n\n\t\t}\n\t\t_TIFFfree(aline);\n\n\n\t\tTIFFClose(tif);\n\n\t\tTIFFSetWarningHandler(warnH);\n\t\tTIFFSetErrorHandler(errH);\n\t\treturn result != -1;\n\t}\nbail:\n\tTIFFSetWarningHandler(warnH);\n\tTIFFSetErrorHandler(errH);\n\treturn false;\n\n}",
    "bool\tFetchTIFFCornersWithTIFF(TIFF * tiffFile, double corners[8], int& post_pos, gcp_t * gcp)\n{\n\tbool retVal = false;\n#if USE_TIF\n\tGTIF * gtif = GTIFNew(tiffFile);\n\tif (gtif)\n\t{\n\t\tGTIFPrint(gtif, GTIFPrintFunc, 0);\n\n\t\tGTIFDefn \tdefn;\n        if( GTIFGetDefn( gtif, &defn ) )\n        {\n#if WED\n\t\t\tGTIFPrintDefn(&defn, gLogFile ? gLogFile : stdout);\n#endif\n\t\t\tLOG_MSG(\"PROJ.4 Definition: %s\\n\", GTIFGetProj4Defn(&defn));\n        \tint xs, ys;\n            TIFFGetField( tiffFile, TIFFTAG_IMAGEWIDTH, &xs );\n            TIFFGetField( tiffFile, TIFFTAG_IMAGELENGTH, &ys );\n\t\t\tdouble xsize(xs), ysize(ys);\n\n\t\t\tuint16 pixel_type;\n\t\t\tdouble dx(0.0), dy(0.0);\n\n\t\t\tif (GTIFKeyGet(gtif,GTRasterTypeGeoKey, &pixel_type, 0, 1) != 1)\n\t\t\t\tpixel_type = RasterPixelIsArea;\n\n\t\t\t// If we are a 'point sampled' file, the upper right edge _IS_ the last pixels!  Thus\n\t\t\t// passing in the number of pixels induces an off-by-one.  Cut the size by one to fix this.\n\t\t\tif(pixel_type == RasterPixelIsPoint)\n\t\t\t{\n\t\t\t\txsize -= 1.0;\n\t\t\t\tysize -= 1.0;\n\t\t\t}\n\n\t\t\tif(pixel_type == RasterPixelIsArea && post_pos == dem_want_Post)\n\t\t\t{\n\t\t\t\t// This is an area-pixel DEM, but we are going to reinterpret it via pixel centers.\n\t\t\t\t// This will INSET the corners of the pixels by 1/2 pixel to the sample centers.\n\t\t\t\tdx=0.5;\n\t\t\t\tdy=0.5;\n\t\t\t}\n\n\t\t\tif(pixel_type == RasterPixelIsPoint && post_pos == dem_want_Area)\n\t\t\t{\n\t\t\t\t// This is a center post sampled image, but we are going to treat it as area.  Each\n\t\t\t\t// pixel \"sticks out\" a bit in its coverage, so extend.\n\t\t\t\tdx=-0.5;\n\t\t\t\tdy=-0.5;\n\t\t\t}\n\n\t\t\tif(post_pos == dem_want_File)\n\t\t\t\tpost_pos = (pixel_type==RasterPixelIsPoint) ? dem_want_Post : dem_want_Area;\n\n        \tif (TransformTiffCorner(gtif, &defn,\t   dx, ysize-dy, corners[0], corners[1]) &&\n\t        \tTransformTiffCorner(gtif, &defn, xsize-dx, ysize-dy, corners[2], corners[3]) &&\n\t        \tTransformTiffCorner(gtif, &defn,\t   dx,\t\t dy, corners[4], corners[5]) &&\n\t        \tTransformTiffCorner(gtif, &defn, xsize-dx,\t\t dy, corners[6], corners[7]))\n\t        {\n\t        \tretVal = true;\n\t        }\n\t        \n\t\t\tif (gcp)\n\t\t\t{\n\t\t\t\tgcp->pts.clear();\n\t\t\t\tgcp->size_x = 1;\n\t\t\t\tgcp->size_y = 1;\n\t\t\t\tif (xsize > 1536 || ysize > 1536)  // calculate control points for map warping/projection, if texture has high resolution\n\t\t\t\t{\n\t\t\t\t\tgcp->size_x = intlim(roundf((double) xsize / 1024.0), 2, 10) + 1;\n\t\t\t\t\tgcp->size_y = intlim(roundf((double) ysize / 1024.0), 2, 10) + 1;\n\t\t\t\t\tfor (int y = 0; y < gcp->size_y; y++)\n\t\t\t\t\t\tfor (int x = 0; x < gcp->size_x; x++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdouble lon, lat;\n\t\t\t\t\t\t\tif (TransformTiffCorner(gtif, &defn, dx + x * xsize / (gcp->size_x - 1), ysize - y * ysize / (gcp->size_y - 1) - dy, lon, lat))\n\t\t\t\t\t\t\t\tgcp->pts.push_back(Point2(lon, lat));\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tGTIFFree(gtif);\n\t}\n#endif\n\treturn retVal;\n}",
    "static\tbool\tFetchTIFFCorners(const char * inFileName, double corners[8])\n{\n\tbool retVal = false;\n\tTIFF * tiffFile = XTIFFOpen(inFileName, \"r\");\n\tif (tiffFile)\n\t{\n\t\tGTIF * gtif = GTIFNew(tiffFile);\n\t\tif (gtif)\n\t\t{\n\t\t\tGTIFDefn \tdefn;\n\t        if( GTIFGetDefn( gtif, &defn ) )\n\t        {\n\t        \tint xsize, ysize;\n\t            TIFFGetField( tiffFile, TIFFTAG_IMAGEWIDTH, &xsize );\n\t            TIFFGetField( tiffFile, TIFFTAG_IMAGELENGTH, &ysize );\n\n\t        \tif (TransformTiffCorner(gtif, &defn, 0,     ysize, corners[0], corners[1]) &&\n\t\t        \tTransformTiffCorner(gtif, &defn, xsize, ysize, corners[2], corners[3]) &&\n\t\t        \tTransformTiffCorner(gtif, &defn, 0,     0,     corners[4], corners[5]) &&\n\t\t        \tTransformTiffCorner(gtif, &defn, xsize, 9,     corners[6], corners[7]))\n\t\t        {\n\t\t        \tretVal = true;\n\t\t        }\n\t\t\t}\n\t\t\tGTIFFree(gtif);\n\t\t}\n\n\t\tXTIFFClose(tiffFile);\n\t}\n\treturn retVal;\n}",
    "int\t\tCreateBitmapFromTIF(const char * inFilePath, struct ImageInfo * outImageInfo)\n{\n\tint result = -1;\n\tTIFFErrorHandler\terrH = TIFFSetWarningHandler(IgnoreTiffWarnings);\n\tTIFFErrorHandler\terrH2= TIFFSetErrorHandler(IgnoreTiffWarnings);\n#if SUPPORT_UNICODE\n    TIFF* tif = TIFFOpenW(convert_str_to_utf16(inFilePath).c_str(), \"r\");\n#else\n\tFILE_case_correct_path path(inFilePath);  // If earth.wed.xml with case-incorrect .tif references are exchanged, this helps on Linux\n    TIFF* tif = TIFFOpen(path, \"r\");\n#endif\n    if (tif == NULL) goto bail;\n\n\tuint32 w, h;\n\tuint16 cc;\n\tsize_t npixels;\n\tuint32* raster;\n\n\t\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cc);\n\n\tnpixels = w * h;\n\traster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n\tif (raster != NULL) {\n\t    if (TIFFReadRGBAImage(tif, w, h, raster, 0)) {\n\n\t\t\toutImageInfo->data = (unsigned char *) malloc(npixels * 4);\n\t\t\toutImageInfo->width = w;\n\t\t\toutImageInfo->height = h;\n\t\t\toutImageInfo->channels = 4;\n\t\t\toutImageInfo->pad = 0;\n\t\t\tint\tcount = outImageInfo->width * outImageInfo->height;\n\t\t\tunsigned char * d = outImageInfo->data;\n\t\t\tunsigned char * s = (unsigned char *) raster;\n\t\t\twhile (count--)\n\t\t\t{\n#if BIG\n\t\t\t\td[0] = s[1];\t// B\n\t\t\t\td[1] = s[2];\t// G\n\t\t\t\td[2] = s[3];\t// R\n\t\t\t\td[3] = s[0];\t// A\n#elif LIL\n\t\t\t\td[0] = s[2];\t// B\n\t\t\t\td[1] = s[1];\t// G\n\t\t\t\td[2] = s[0];\t// R\n\t\t\t\td[3] = s[3];\t// A\n#else\n\t#error PLATFORM NOT DEFINED\n#endif\n\t\t\t\ts += 4;\n\t\t\t\td += 4;\n\t\t\t}\n\t\t\tresult = 0;\n\t    }\n\t    _TIFFfree(raster);\n\t}\n\tTIFFClose(tif);\n\tTIFFSetWarningHandler(errH);\n    return result;\nbail:\n\tTIFFSetWarningHandler(errH);\n\treturn -1;\n}",
    "bool\tWED_ExtractGeoTiff(dem_info_t& inMap, const char* inFileName, int post_style)\n{\n\tTIFF * tif;\n#if SUPPORT_UNICODE\n\tXTIFFInitialize();\n\ttif = TIFFOpenW(convert_str_to_utf16(inFileName).c_str(), \"r\");\n#else\n\ttif = XTIFFOpen(inFileName, \"r\");\n#endif\n\tif (tif)\n\t{\n\t\tdouble\tcorners[8];\n\t\tif (FetchTIFFCornersWithTIFF(tif, corners, post_style))\n\t{\n\n\t\t// this assumes geopgrahic, not projected coordinates ...\n\t\tinMap.mWest = corners[0];\n\t\tinMap.mSouth = corners[1];\n\t\tinMap.mEast = corners[6];\n\t\tinMap.mNorth = corners[7];\n\t\tinMap.mPost = (post_style == dem_want_Post);\n\n\t\tuint32 w, h;\n\t\tuint16 cc;\n\t\tuint16 d;\n\t\tuint16 format = SAMPLEFORMAT_UINT;\t// sample format is NOT mandatory - unsigned int is the default if not present!\n\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cc);\n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &d);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &format);\n//\t\tprintf(\"Image is: %dx%d, samples: %d, depth: %d, format: %d\\n\", w, h, cc, d, format);\n\n\t\tinMap.resize(w, h);\n\n\t\tif (TIFFIsTiled(tif))\n\t\t{\n\t\t\tuint32\ttw, th;\n\t\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n\t\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n\t\t\tvector<char> buf;\n\t\t\tbuf.resize(TIFFTileSize(tif));\n\t\t\tfor (int y = 0; y < h; y += th)\n\t\t\t\tfor (int x = 0; x < w; x += tw)\n\t\t\t\t{\n\t\t\t\t\tif (TIFFReadTile(tif, buf.data(), x, y, 0, 0) == -1)\n\t\t\t\t\t\tgoto bail;\n\n\t\t\t\t\tint ux = min(tw, w - x);\n\t\t\t\t\tint uy = min(th, h - y);\n\t\t\t\t\tint pad = tw - ux;\n\n\t\t\t\t\tswitch (format) \n\t\t\t\t\t{\n\t\t\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\t\t\tswitch (d) \n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase 8:  copy_tile<unsigned char >((unsigned char*)  buf.data(), x, y, ux, uy, pad, inMap); break;\n\t\t\t\t\t\tcase 16: copy_tile<unsigned short>((unsigned short*) buf.data(), x, y, ux, uy, pad, inMap); break;\n\t\t\t\t\t\tcase 32: copy_tile<unsigned int  >((unsigned int*)   buf.data(), x, y, ux, uy, pad, inMap); break;\n\t\t\t\t\t\tdefault: goto bail;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\t\t\tswitch (d) \n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase 8:  copy_tile<char >((char* ) buf.data(), x, y, ux, uy, pad, inMap); break;\n\t\t\t\t\t\tcase 16: copy_tile<short>((short*) buf.data(), x, y, ux, uy, pad, inMap); break;\n\t\t\t\t\t\tcase 32: copy_tile<int  >((int*  ) buf.data(), x, y, ux, uy, pad, inMap); break;\n\t\t\t\t\t\tdefault: goto bail;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\t\t\tswitch (d) \n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase 32: copy_tile<float >((float* ) buf.data(), x, y, ux, uy, pad, inMap); break;\n\t\t\t\t\t\tcase 64: copy_tile<double>((double*) buf.data(), x, y, ux, uy, pad, inMap); break;\n\t\t\t\t\t\tdefault: goto bail;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: goto bail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tXTIFFClose(tif);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttsize_t line_size = TIFFScanlineSize(tif);\n\t\t\tvector<char> aline;\n\t\t\taline.resize(line_size);\n\n\t\t\tint cs = TIFFCurrentStrip(tif);\n\t\t\tint nos = TIFFNumberOfStrips(tif);\n\t\t\tint cr = TIFFCurrentRow(tif);\n\n\t\t\tfor (int y = 0; y < h; ++y)\n\t\t\t{\n\t\t\t\tif (TIFFReadScanline(tif, aline.data(), y, 0) == -1)\n\t\t\t\t\tgoto bail;\n\n\t\t\t\tswitch (format) \n\t\t\t\t{\n\t\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\t\tswitch (d) \n\t\t\t\t\t{\n\t\t\t\t\tcase 8:  copy_scanline<unsigned char >((unsigned char* )aline.data(), y, inMap); break;\n\t\t\t\t\tcase 16: copy_scanline<unsigned short>((unsigned short*)aline.data(), y, inMap); break;\n\t\t\t\t\tcase 32: copy_scanline<unsigned int  >((unsigned int*  )aline.data(), y, inMap); break;\n\t\t\t\t\tdefault: goto bail;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\t\tswitch (d) \n\t\t\t\t\t{\n\t\t\t\t\tcase 8:\t copy_scanline<char >((char* )aline.data(), y, inMap); break;\n\t\t\t\t\tcase 16: copy_scanline<short>((short*)aline.data(), y, inMap); break;\n\t\t\t\t\tcase 32: copy_scanline<int  >((int*  )aline.data(), y, inMap); break;\n\t\t\t\t\tdefault: goto bail;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\t\tswitch (d) \n\t\t\t\t\t{\n\t\t\t\t\tcase 32: copy_scanline<float >((float* )aline.data(), y, inMap); break;\n\t\t\t\t\tcase 64: copy_scanline<double>((double*)aline.data(), y, inMap); break;\n\t\t\t\t\tdefault: goto bail;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tXTIFFClose(tif);\n\t\t\treturn true;\n\t\t}\n\t\n\t}\n\tbail:\n\t\tXTIFFClose(tif);\n\t\tLOG_MSG(\"E/Dem Error reading DEM %s\\n\", inFileName);\n\t}\n\telse\n\t\tLOG_MSG(\"E/Dem Error opening DEM %s\\n\", inFileName);\n\treturn false;\n}",
    "FloatImage * nv::ImageIO::loadFloatTIFF(const char * fileName, Stream & s)\r\n{\r\n\tnvCheck(!s.isError());\r\n\t\r\n\tTIFF * tif = TIFFOpen(fileName, \"r\");\r\n\t//TIFF * tif = TIFFClientOpen(fileName, \"r\", &s, tiffReadWriteProc, tiffReadWriteProc, tiffSeekProc, tiffCloseProc, tiffSizeProc, tiffMapFileProc, tiffUnmapFileProc);\r\n\t\r\n\tif (!tif)\r\n\t{\r\n\t\tnvDebug(\"Can't open '%s' for reading\\n\", fileName);\r\n\t\treturn NULL;\r\n\t}\r\n\t\r\n\t::uint16 spp, bpp, format;\r\n\t::uint32 width, height;\r\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\r\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\r\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp);\r\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tTIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &format);\r\n\t\r\n\tif (bpp != 8 && bpp != 16 && bpp != 32) {\r\n\t\tnvDebug(\"Can't load '%s', only 1 sample per pixel supported\\n\", fileName);\r\n\t\tTIFFClose(tif);\r\n\t\treturn NULL;\r\n\t}\r\n\t\r\n\tAutoPtr<FloatImage> fimage(new FloatImage());\r\n\tfimage->allocate(spp, width, height);\r\n\t\r\n\tint linesize = TIFFScanlineSize(tif);\r\n\ttdata_t buf = (::uint8 *)nv::mem::malloc(linesize);\r\n\t\r\n\tfor (uint y = 0; y < height; y++) \r\n\t{\r\n\t\tTIFFReadScanline(tif, buf, y, 0);\r\n\r\n\t\tfor (uint c=0; c<spp; c++ ) \r\n\t\t{\r\n\t\t\tfloat * dst = fimage->scanline(y, c);\r\n\r\n\t\t\tfor(uint x = 0; x < width; x++) \r\n\t\t\t{\r\n\t\t\t\tif (bpp == 8)\r\n\t\t\t\t{\r\n\t\t\t\t\tdst[x] = float(((::uint8 *)buf)[x*spp+c]) / float(0xFF);\r\n\t\t\t\t}\r\n\t\t\t\telse if (bpp == 16)\r\n\t\t\t\t{\r\n\t\t\t\t\tdst[x] = float(((::uint16 *)buf)[x*spp+c]) / float(0xFFFF);\r\n\t\t\t\t}\r\n\t\t\t\telse if (bpp == 32)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (format==SAMPLEFORMAT_IEEEFP)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdst[x] = float(((float *)buf)[x*spp+c]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdst[x] = float(((::uint32 *)buf)[x*spp+c] >> 8) / float(0xFFFFFF);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tnv::mem::free(buf);\r\n\t\r\n\tTIFFClose(tif);\r\n\t\r\n\treturn fimage.release();\r\n}",
    "bool CLoadEerHeader::DoIt(TIFF* pTiff, int iEerSampling)\n{\n\tm_iEerSampling = iEerSampling;\n\tmemset(m_aiCamSize, 0, sizeof(m_aiCamSize));\n\tmemset(m_aiFrmSize, 0, sizeof(m_aiFrmSize));\n\t//------------------------------------------\n\tTIFFGetField(pTiff, TIFFTAG_IMAGEWIDTH, &m_aiCamSize[0]);\n\tTIFFGetField(pTiff, TIFFTAG_IMAGELENGTH, &m_aiCamSize[1]);\n\tm_iNumFrames = TIFFNumberOfDirectories(pTiff);\n\tTIFFGetField(pTiff, TIFFTAG_COMPRESSION, &m_usCompression);\n\tif(m_usCompression == 65000) m_iNumBits = 8;\n\telse if(m_usCompression == 65001) m_iNumBits = 7;\n\telse m_iNumBits = -1;\n\t//-------------------\n\tbool bHasError = mCheckError();\n\tif(bHasError) return false;\n\t//-------------------------\n\tint iFact = 1;\n\tif(m_iEerSampling == 2) iFact = 2;\n\telse if(m_iEerSampling == 3) iFact = 4;\n\tm_aiFrmSize[0] = m_aiCamSize[0] * iFact;\n\tm_aiFrmSize[1] = m_aiCamSize[1] * iFact;\n\treturn true;\n}",
    "bool CLoadTiffHeader::mReadImageSize(void)\n{\n\tuint32_t uiWidth = 0;\n\tuint32_t uiLength = 0;\n\tint iRetX = TIFFGetField(m_pTiff, TIFFTAG_IMAGEWIDTH, &uiWidth);\n        int iRetY = TIFFGetField(m_pTiff, TIFFTAG_IMAGELENGTH, &uiLength);\n\tif(iRetX == 0 || iRetY == 0) return false;\n\tm_aiImgSize[0] = uiWidth;\n\tm_aiImgSize[1] = uiLength;\n\tm_aiImgSize[2] = TIFFNumberOfDirectories(m_pTiff);\n\treturn true;\n}",
    "bool CLoadTiffHeader::mReadMode(void)\n{\n        short sNumBits = 0;\n\tshort sFormat = 0;\n\tTIFFGetField(m_pTiff, TIFFTAG_BITSPERSAMPLE, &sNumBits);\n\tbool bFormat = TIFFGetField(m_pTiff, TIFFTAG_SAMPLEFORMAT, &sFormat);\n\t//-------------------------------------------------------------------\n\tif(sNumBits == 8)\n\t{\tm_iMode = Mrc::eMrcUChar;\n\t\treturn true;\n\t}\n        else if(sNumBits == 16)\n\t{\tif(bFormat && sFormat == SAMPLEFORMAT_INT)\n\t\t{\tm_iMode = Mrc::eMrcShort;\n\t\t}\n                else\n\t\t{\tm_iMode = Mrc::eMrcUShort;\n\t\t}\n\t\treturn true;\n\t}\n        else if(bFormat && sFormat == SAMPLEFORMAT_IEEEFP)\n        {       m_iMode = Mrc::eMrcFloat;\n\t\treturn true;\n        }\n\treturn false;\n}",
    "void CLoadTiffHeader::mReadPixelSize(void)\n{\n\tfloat fResX = 0.0f;\n\tfloat fResY = 0.0f;\n\tshort sResUnit = 0;\n\tbool bResX = TIFFGetField(m_pTiff, TIFFTAG_XRESOLUTION, &fResX);\n\tbool bResY = TIFFGetField(m_pTiff, TIFFTAG_YRESOLUTION, &fResY);\n\tTIFFGetField(m_pTiff, TIFFTAG_RESOLUTIONUNIT, &sResUnit);\n\t//-------------------------------------------------------\n\tif(bResX) \n\t{\tm_fPixelSize = (float)(fResX / 2.54e8);\n\t}\n\telse if(bResY)\n\t{\tm_fPixelSize = (float)(fResY / 2.54e8);\n\t}\n\telse\n\t{\tm_fPixelSize = 0.0f;\n\t} \n}",
    "bool CLoadTiffHeader::mReadRowsPerStrip(void)\n{\n\tuint32_t uiRowsPerStrip = 0;\n\tint iRetVal = TIFFGetField\n        (  m_pTiff,\n           TIFFTAG_ROWSPERSTRIP,\n           &uiRowsPerStrip\n        );\n\tif(iRetVal == 0) return false;\n\t//----------------------------\n\tm_aiTileSize[0] = m_aiImgSize[0];\n\tm_aiTileSize[1] = uiRowsPerStrip;\n\tm_aiNumTiles[0] = 1;\n        m_aiNumTiles[1] = m_aiImgSize[1] / uiRowsPerStrip;\n\tif((m_aiNumTiles[1] * m_aiTileSize[1]) < m_aiImgSize[1])\n\t{\tm_aiNumTiles[1] += 1;\n\t}\n\treturn true;\n}",
    "bool CLoadTiffHeader::mReadTileSize(void)\n{\n\tuint32_t uiWidth = 0;\n\tuint32_t uiLength = 0;\n\tint iRetX = TIFFGetField(m_pTiff, TIFFTAG_TILEWIDTH, &uiWidth);\n\tint iRetY = TIFFGetField(m_pTiff, TIFFTAG_TILELENGTH, &uiLength);\n\tif(iRetX == 0 || iRetY == 0) return false;\n\t//----------------------------------------\n\tm_aiTileSize[0] = uiWidth;\n\tm_aiTileSize[1] = uiLength;\n\tm_aiNumTiles[0] = m_aiImgSize[0] / m_aiTileSize[0];\n\tm_aiNumTiles[1] = m_aiImgSize[1] / m_aiTileSize[1];\n\tif((m_aiNumTiles[0] * m_aiTileSize[0]) < m_aiImgSize[0])\n\t{\tm_aiNumTiles[0] += 1;\n\t}\n\tif((m_aiNumTiles[1] * m_aiTileSize[1]) < m_aiImgSize[1])\n\t{\tm_aiNumTiles[1] += 1;\n\t}\n\treturn true;\n}",
    "int metno::GeoTiff::read_diana(const std::string& infile, unsigned char* image[], int nchan, int /*chan*/[], dihead& ginfo)\n{\n  METLIBS_LOG_TIME();\n\n  ginfo.noofcl = 0;\n  ginfo.zsize =1;\n\n  const int pal = head_diana(infile, ginfo);\n  METLIBS_LOG_DEBUG(LOGVAL(pal));\n  if (pal == -1)\n    return -1;\n\n  if (nchan == 0)\n    return 1;\n\n  std::unique_ptr<TIFF, CloseTIFF> in(TIFFOpen(infile.c_str(), \"rc\"));\n  if (!in) {\n    METLIBS_LOG_ERROR(\"TIFFOpen failed, probably not a TIFF file: '\" << infile << \"'\");\n    return -1;\n  }\n\n  tsample_t samplesperpixel;\n  TIFFGetField(in.get(), TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\n  const int size = ginfo.xsize * ginfo.ysize;\n\n  uint32  count;\n  void    *data;\n  // TIFFTAG_GDAL_METADATA 42112 defined in some projets\n  // see https://www.awaresystems.be/imaging/tiff/tifftags/gdal_metadata.html\n  if (samplesperpixel == 1 && TIFFGetField(in.get(), /*GDAL_METADATA*/ 42112, &count, &data)) {\n    // this is an xml document, we just search for text and hope that\n    // scale is after '... role=\"scale\">'\n    if (const char* t = strstr((char *)data, \"scale\")) {\n      ginfo.AIr = atof(t+7);\n    }\n    // ... and offset after '... role=\"offset\">'\n    if (const char* t = strstr((char *)data, \"offset\")) {\n      ginfo.BIr = atof(t + 8);\n    }\n\n    // Why not use BIr and AIr ?\n    std::ostringstream oss;\n    oss << \"T=(\" << ginfo.BIr << \")+(\" << ginfo.AIr << \")*C\";\n    ginfo.cal_ir = oss.str();\n  }\n  METLIBS_LOG_DEBUG(LOGVAL(ginfo.projection.getProj4Definition()) << LOGVAL(size)\n                    << LOGVAL(ginfo.xsize) << LOGVAL(ginfo.ysize) << LOGVAL(ginfo.zsize)\n                    << LOGVAL(samplesperpixel) << LOGVAL(ginfo.time));\n  /*\n   * Memory allocated for image data in this function (*image) is freed\n   * in function main process.\n   */\n  if (ginfo.zsize > MAXCHANNELS) {\n    METLIBS_LOG_ERROR(\"ginfo.zsize > MAXCHANNELS!\");\n    return(-1);\n  }\n\n  // RGBA buffer\n  image[0] = (unsigned char *) malloc((size)*4);\n  memset(image[0], 0, size*4);\n\n  std::string file = infile.substr(infile.rfind(\"/\") + 1);\n  ImageCache* mImageCache = ImageCache::getInstance();\n\n  if (!mImageCache->getFromCache(file, (uint8_t*)image[0])) {\n    if (!TIFFReadRGBAImageOriented(in.get(), ginfo.xsize, ginfo.ysize, (uint32*)image[0])) {\n      METLIBS_LOG_ERROR(\"TIFFReadRGBAImageOriented (ORIENTATION_BOTLEFT) failed: size \" <<  ginfo.xsize << \",\" << ginfo.ysize);\n    }\n    // GDAL_NODATA, see https://www.awaresystems.be/imaging/tiff/tifftags/gdal_nodata.html\n    // Used by the GDAL library, contains an ASCII encoded nodata or background pixel value.\n    if (samplesperpixel == 1 && TIFFGetField(in.get(), /* GDAL_NODATA */ 42113, &count, &data) && count > 0) {\n      const char* ascii = (const char*)data;\n      const unsigned int nodata = atoi(ascii);\n      const uint32_t rgba_nodata = 0xFF << 24 | nodata << 16 | nodata << 8 | nodata;\n      for (int i=0; i<size; ++i) {\n        uint32_t* rgba = (uint32_t*)(&image[0][i*4]);\n        if (*rgba == rgba_nodata)\n          *rgba = 0;\n      }\n    }\n    mImageCache->putInCache(file, (uint8_t*)image[0], size*4);\n  }\n  return(pal);\n}",
    "int metno::GeoTiff::head_diana(const std::string& infile, dihead &ginfo)\n{\n  METLIBS_LOG_TIME();\n\n  ginfo.noofcl = 0;\n\n  std::unique_ptr<TIFF, CloseXTIFF> in(XTIFFOpen(infile.c_str(), \"rc\"));\n  if (!in) {\n    METLIBS_LOG_ERROR(\"XTIFFOpen failed, probably not a TIFF file: '\" << infile << \"'\");\n    return -1;\n  }\n\n  // test whether this is a color palette image\n  short pmi; // PhotometricInterpretation, 3: Baseline palette-color; 2: Baseline RGB\n  if (!TIFFGetField(in.get(), TIFFTAG_PHOTOMETRIC, &pmi)) {\n    METLIBS_LOG_ERROR(\"no TIFFTAG_PHOTOMETRIC in '\" << infile << \"'\");\n    return -1;\n  }\n  if (pmi == PHOTOMETRIC_PALETTE) { // see tiff.h for the constants\n    unsigned short int *red, *green, *blue;\n    if (!TIFFGetField(in.get(), TIFFTAG_COLORMAP, &red, &green, &blue)) {\n      METLIBS_LOG_ERROR(\"no TIFFTAG_COLORMAP in '\" << infile << \"'\");\n      return -1;\n    }\n\n    for (int i=0; i<256; i++) {\n      ginfo.cmap[0][i] = red[i];\n      ginfo.cmap[1][i] = green[i];\n      ginfo.cmap[2][i] = blue[i];\n    }\n  }\n  // Rest is added by Niklas, for making greyscales of Storm single channel images...\n  else if (pmi == PHOTOMETRIC_MINISWHITE) {\n    for (int i=0; i<256; i++) {\n      ginfo.cmap[0][i] = (255-i)*256;\n      ginfo.cmap[1][i] = (255-i)*256;\n      ginfo.cmap[2][i] = (255-i)*256;\n    }\n  } else if (pmi == PHOTOMETRIC_MINISBLACK) {\n    for (int i=0; i<256; i++) {\n      ginfo.cmap[0][i] = i*256;\n      ginfo.cmap[1][i] = i*256;\n      ginfo.cmap[2][i] = i*256;\n    }\n  }\n\n  char* datetime = 0;\n  if (TIFFGetField(in.get(), TIFFTAG_DATETIME, &datetime) && datetime) {\n    METLIBS_LOG_DEBUG(LOGVAL(datetime));\n\n    int year, month, day, hour, minute, sec;\n    if (sscanf(datetime, \"%4d-%2d-%2d %2d:%2d:%2d\", &year, &month, &day, &hour, &minute, &sec) != 6) {\n      if (sscanf(datetime, \"%4d:%2d:%2d %2d:%2d:%2d\", &year, &month, &day, &hour, &minute, &sec) != 6) {\n         METLIBS_LOG_WARN(\"Invalid time in TIFFTAG_DATETIME '\" << datetime << \"'\");\n      }\n    }\n    if (year == 0)\n      year = 2000;\n    if (hour == 24) {\n      hour = 0;\n      ginfo.time = miutil::miTime(year, month, day, hour, minute, 0);\n      ginfo.time.addDay(1);\n    } else {\n      ginfo.time = miutil::miTime(year, month, day, hour, minute, 0);\n    }\n    METLIBS_LOG_DEBUG(LOGVAL(ginfo.time));\n  } else {\n    METLIBS_LOG_WARN(\"TIFFTAG_DATETIME error\");\n  }\n\n  std::unique_ptr<GTIF, FreeGTIFF> gtifin(GTIFNew(in.get()));\n  if (!gtifin) {\n    METLIBS_LOG_ERROR(\"could not init GTIF object\");\n    return -1;\n  }\n\n  double x_0, y_0, x_scale, y_scale;\n\n  // Geospecific Tags\n  uint32 transmatrix_size = 0;\n  double* transmatrix = 0;\n  const bool have_transmatrix = (TIFFGetField(in.get(), GTIFF_TRANSMATRIX, &transmatrix_size, &transmatrix) == 1) && (transmatrix_size == 16) && transmatrix;\n  if (have_transmatrix) {\n    x_scale = transmatrix[0];\n    x_0 = transmatrix[3];\n    y_scale = transmatrix[5];\n    y_0 = transmatrix[7];\n    if (transmatrix[1] != 0 || transmatrix[1] != 0 || transmatrix[4] != 0 || transmatrix[6] != 0) {\n      METLIBS_LOG_WARN(\"only the linear part of GTIFF_TRANSMATRIX is supported in '\" << infile << \"'\");\n    }\n  } else { // !have_transmatrix\n    uint32 tiepointsize = 0;\n    double* tiepoints = 0; //[6];\n    const bool have_tiepoints = (TIFFGetField(in.get(), TIFFTAG_GEOTIEPOINTS, &tiepointsize, &tiepoints) == 1) && (tiepointsize >= 6) && tiepoints;\n\n    uint32 pixscalesize = 0;\n    double* pixscale = 0; //[3];\n    const bool have_pixelscale = (TIFFGetField(in.get(), TIFFTAG_GEOPIXELSCALE, &pixscalesize, &pixscale) == 1) && (pixscalesize == 3) && pixscale;\n\n    if (METLIBS_LOG_DEBUG_ENABLED()) {\n      METLIBS_LOG_DEBUG(\"tiepointsize: \" << tiepointsize);\n      if (tiepoints) {\n        for (uint32 i = 0; i < tiepointsize; i++)\n          METLIBS_LOG_DEBUG(\"tiepoints[\" << i << \"]=\" << tiepoints[i]);\n      }\n      METLIBS_LOG_DEBUG(\"pixscalesize: \" << pixscalesize);\n      if (pixscale) {\n        for (uint32 i = 0; i < pixscalesize; i++)\n          METLIBS_LOG_DEBUG(\"pixscale[\" << i << \"]=\" << pixscale[i]);\n      }\n    }\n\n    if (!(have_tiepoints && have_pixelscale)) {\n      METLIBS_LOG_ERROR(\"neither GTIFF_TRANSMATRIX nor TIFFTAG_GEOTIEPOINTS+TIFFTAG_GEOPIXELSCALE in '\" << infile << \"'\");\n      return -1;\n    }\n\n    x_scale = pixscale[0];\n    y_scale = -pixscale[1];\n    x_0 = tiepoints[3];\n    y_0 = tiepoints[4];\n    METLIBS_LOG_DEBUG(LOGVAL(x_scale) << LOGVAL(y_scale) << LOGVAL(x_0) << LOGVAL(y_0));\n  } // !have_transmatrix\n\n  /* Coordinate Transformation Codes */\n  short linearUnitsCode;\n  if (!GTIFKeyGet(gtifin.get(), ProjLinearUnitsGeoKey, &linearUnitsCode, 0, 1)) {\n    linearUnitsCode = 32767;\n  }\n  double unit_scale_factor = 1;\n\n  unsigned short modeltype;\n  if (!GTIFKeyGet(gtifin.get(), GTModelTypeGeoKey, &modeltype, 0, 1)) {\n    METLIBS_LOG_ERROR(\"getting GTModelType from file\");\n    return -1;\n  }\n\n  if (modeltype == 32767) {\n    // User defined WKT, use gdalsrsrinfo to convert to proj4\n    int cit_size;\n    int cit_length = GTIFKeyInfo(gtifin.get(), PCSCitationGeoKey, &cit_size, NULL);\n    if (cit_length <= 0) {\n      METLIBS_LOG_ERROR(\"Missing PCSCitationGeoKey\");\n      return -1;\n    }\n    std::unique_ptr<char[]> citation(new char[cit_length]);\n    GTIFKeyGet(gtifin.get(), PCSCitationGeoKey, citation.get(), 0, cit_length);\n    std::string PCSCitation(citation.get());\n\n    miutil::replace(PCSCitation, \"ESRI PE String = \", \"\");\n    ginfo.projection.setFromWKT(PCSCitation);\n\n  } else if (modeltype == ModelTypeGeographic) {\n    /* Geographic latitude-longitude System */\n    /* Assume mercartor for now */\n\n    double GeogSemiMajorAxis = 0, GeogSemiMinorAxis = 0, GeogInvFlattening = 0;\n    if (!GTIFKeyGet(gtifin.get(), GeogSemiMajorAxisGeoKey, &GeogSemiMajorAxis, 0, 1)) {\n      METLIBS_LOG_INFO(\"No GeogSemiMajorAxisGeoKey in geotiff, set to 6.37814e+06\");\n      GeogSemiMajorAxis = 6.37814e6;\n    }\n    unsigned short GeogAngularUnits, GeogEllipsoid, GeographicType;\n    if (!GTIFKeyGet(gtifin.get(), GeogAngularUnitsGeoKey, &GeogAngularUnits, 0, 1)) {\n      GeogAngularUnits = Angular_Degree;\n    }\n    if (!GTIFKeyGet(gtifin.get(), GeogEllipsoidGeoKey, &GeogEllipsoid, 0, 1)) {\n      GeogEllipsoid = 32767;\n    }\n    if (!GTIFKeyGet(gtifin.get(), GeogSemiMinorAxisGeoKey, &GeogSemiMinorAxis, 0, 1)) {\n      GeogSemiMinorAxis = 6356752.314;\n    }\n    if (!GTIFKeyGet(gtifin.get(), GeogInvFlatteningGeoKey, &GeogInvFlattening, 0, 1)) {\n      GeogInvFlattening = 298.257;\n    }\n    if (!GTIFKeyGet(gtifin.get(), GeographicTypeGeoKey, &GeographicType, 0, 1)) {\n      GeographicType = 32767; // Default value\n    }\n\n    int cit_size;\n    int cit_length = GTIFKeyInfo(gtifin.get(), GeogCitationGeoKey, &cit_size, NULL);\n    std::string GTCitation;\n    if (cit_length > 0) {\n      std::unique_ptr<char[]> citation(new char[cit_length]);\n      GTIFKeyGet(gtifin.get(), GeogCitationGeoKey, citation.get(), 0, cit_length);\n      GTCitation = std::string(citation.get());\n    }\n\n    ginfo.projection = Projection(\"+proj=lonlat +ellps=WGS84 +towgs84=0,0,0 +no_defs\");\n    switch (GeogAngularUnits) { // see http://geotiff.maptools.org/spec/geotiff6.html#6.3.1.4\n    case Angular_Degree:\n      unit_scale_factor = 1;\n      break;\n    case Angular_Radian:\n      unit_scale_factor = 180 / M_PI;\n      break;\n    case Angular_Arc_Minute:\n      unit_scale_factor = 1 / 60;\n      break;\n    case Angular_Arc_Second:\n      unit_scale_factor = 1 / 3600;\n      break;\n    case Angular_Gon:\n      unit_scale_factor = 0.9;\n      break;\n    default:\n      METLIBS_LOG_WARN(\"GeogAngularUnits = \" << GeogAngularUnits << \" are not supported\");\n    }\n\n    if (METLIBS_LOG_DEBUG_ENABLED()) {\n      METLIBS_LOG_DEBUG(\"GTIFKeyGet: GTModelTypeGeoKey = \" << modeltype);\n      METLIBS_LOG_DEBUG(\"GTIFKeyGet: GeographicType = \" << GeographicType);\n      METLIBS_LOG_DEBUG(\"GTIFKeyGet: GeogCitation = \" << GTCitation);\n      METLIBS_LOG_DEBUG(\"GTIFKeyGet: GeogAngularUnits = \" << GeogAngularUnits);\n      METLIBS_LOG_DEBUG(\"GTIFKeyGet: GeogSemiMajorAxis = \" << GeogSemiMajorAxis);\n      METLIBS_LOG_DEBUG(\"GTIFKeyGet: GeogSemiMinorAxis = \" << GeogSemiMinorAxis);\n      METLIBS_LOG_DEBUG(\"GTIFKeyGet: GeogInvFlattening = \" << GeogInvFlattening);\n    }\n\n  } else if (modeltype == ModelTypeProjected) {\n    unsigned short ProjectedCSType = 0;\n    if (!GTIFKeyGet(gtifin.get(), ProjectedCSTypeGeoKey, &ProjectedCSType, 0, 1)) {\n      METLIBS_LOG_ERROR(\"geotiff key ProjectedCSTypeGeoKey could not be read\");\n      return -1;\n    }\n    std::ostringstream proj4;\n    if (ProjectedCSType >= 1024 && ProjectedCSType <= 32766) {\n      // EPSG code; note: this range is for geotiff 1.1, in geotiff 1.0 the range was 20000 to 32766\n      proj4 << \"+init=epsg:\" << ProjectedCSType;\n    } else /*if (ProjectedCSType == 32767)*/ {\n      unsigned short ProjCoordTrans = 0;\n      if (!GTIFKeyGet(gtifin.get(), ProjCoordTransGeoKey, &ProjCoordTrans, 0, 1)) {\n        METLIBS_LOG_ERROR(\"geotiff key ProjectionGeoKey could not be read\");\n        return -1;\n      }\n      if (ProjCoordTrans == CT_PolarStereographic) {\n        // see http://geotiff.maptools.org/proj_list/polar_stereographic.html\n        double ProjNatOriginLat, ProjScaleAtNatOrigin = 1, ProjStraightVertPoleLong;\n        GTIFKeyGet(gtifin.get(), ProjNatOriginLatGeoKey, &ProjNatOriginLat, 0, 1);\n        GTIFKeyGet(gtifin.get(), ProjScaleAtNatOriginGeoKey, &ProjScaleAtNatOrigin, 0, 1);\n        GTIFKeyGet(gtifin.get(), ProjStraightVertPoleLongGeoKey, &ProjStraightVertPoleLong, 0, 1);\n        // clang-format off\n        proj4 << \"+proj=stere\"\n              << \" +lat_ts=\" << ProjNatOriginLat\n              << \" +lat_0=\" << (ProjNatOriginLat < 0 ? \"-\" : \"\") << \"90\"\n              << \" +lon_0=\" << ProjStraightVertPoleLong\n              << \" +ellps=WGS84\"\n              << \" +units=m\"\n              << \" +k_0=\" << ProjScaleAtNatOrigin;\n        // clang-format on\n      } else if (ProjCoordTrans == CT_Mercator) {\n        // see http://geotiff.maptools.org/proj_list/mercator_1sp.html\n        double ProjNatOriginLong, ProjNatOriginLat, ProjScaleAtNatOrigin;\n        GTIFKeyGet(gtifin.get(), ProjNatOriginLongGeoKey, &ProjNatOriginLong, 0, 1);\n        GTIFKeyGet(gtifin.get(), ProjNatOriginLatGeoKey, &ProjNatOriginLat, 0, 1);\n        GTIFKeyGet(gtifin.get(), ProjScaleAtNatOriginGeoKey, &ProjScaleAtNatOrigin, 0, 1);\n        // clang-format off\n        proj4 << \"+proj=merc\"\n              << \" +lon_0=\" << ProjNatOriginLong\n              << \" +lat_0=\" << ProjNatOriginLat\n              << \" +k_0=\" << ProjScaleAtNatOrigin;\n        // clang-format on\n      } else if (ProjCoordTrans == CT_Equirectangular) {\n        // see http://geotiff.maptools.org/proj_list/equirectangular.html\n        double ProjCenterLong, ProjCenterLat, ProjStdParallel1;\n        GTIFKeyGet(gtifin.get(), ProjCenterLongGeoKey, &ProjCenterLong, 0, 1);\n        GTIFKeyGet(gtifin.get(), ProjCenterLatGeoKey, &ProjCenterLat, 0, 1);\n        GTIFKeyGet(gtifin.get(), ProjStdParallel1GeoKey, &ProjStdParallel1, 0, 1);\n        // clang-format off\n        proj4 << \"+proj=eqc\"\n              << \" +lat_ts=\" << ProjCenterLat\n              << \" +lon_0=\" << ProjCenterLong;\n        // clang-format on\n      } else if (ProjCoordTrans == CT_LambertConfConic_2SP) {\n        // see http://geotiff.maptools.org/proj_list/lambert_conic_conformal_2sp.html\n        double ProjStdParallel1 = 63, ProjStdParallel2 = 63, ProjFalseOriginLat = 63, ProjFalseOriginLong = 15;\n        GTIFKeyGet(gtifin.get(), ProjStdParallel1GeoKey, &ProjStdParallel1, 0, 1);\n        GTIFKeyGet(gtifin.get(), ProjStdParallel2GeoKey, &ProjStdParallel2, 0, 1);\n        GTIFKeyGet(gtifin.get(), ProjFalseOriginLatGeoKey, &ProjFalseOriginLat, 0, 1);\n        GTIFKeyGet(gtifin.get(), ProjFalseOriginLongGeoKey, &ProjFalseOriginLong, 0, 1);\n        // clang-format off\n        proj4 << \"+proj=lcc\"\n              << \" +lat_1=\" << ProjStdParallel1     // latitude of first standard parallel\n              << \" +lat_2=\" << ProjStdParallel2     // latitude of second standard parallel\n              << \" +lat_0=\" << ProjFalseOriginLat   // latitude of false origin\n              << \" +lon_0=\" << ProjFalseOriginLong; // longitude of false origin\n        // clang-format on\n      } else if (ProjCoordTrans == CT_HotineObliqueMercatorAzimuthCenter || ProjCoordTrans == CT_ObliqueMercator_Hotine) {\n        // see http://geotiff.maptools.org/proj_list/oblique_mercator.html\n        // and http://geotiff.maptools.org/proj_list/hotine_oblique_mercator.html\n        double ProjCenterLat = 63, ProjCenterLon = 15, ProjScaleAtCenter = 1;\n        GTIFKeyGet(gtifin.get(), ProjCenterLatGeoKey, &ProjCenterLat, 0, 1);\n        GTIFKeyGet(gtifin.get(), ProjCenterLongGeoKey, &ProjCenterLon, 0, 1);\n        GTIFKeyGet(gtifin.get(), ProjScaleAtCenterGeoKey, &ProjScaleAtCenter, 0, 1);\n        double ProjAzimuthAngle = 63, ProjRectifiedGridAngle = 0;\n        const bool have_alpha = (GTIFKeyGet(gtifin.get(), ProjAzimuthAngleGeoKey, &ProjAzimuthAngle, 0, 1) > 0);\n        const bool have_gamma = (GTIFKeyGet(gtifin.get(), ProjRectifiedGridAngleGeoKey, &ProjRectifiedGridAngle, 0, 1) > 0);\n\n        double GeogSemiMajorAxis = 6370997, GeogSemiMinorAxis = GeogSemiMajorAxis, GeogInvFlattening = 298;\n        bool have_semiminor_axis = false;\n        if (GTIFKeyGet(gtifin.get(), GeogSemiMajorAxisGeoKey, &GeogSemiMajorAxis, 0, 1)) {\n          METLIBS_LOG_DEBUG(LOGVAL(GeogSemiMajorAxis));\n        }\n        if (GTIFKeyGet(gtifin.get(), GeogSemiMinorAxisGeoKey, &GeogSemiMinorAxis, 0, 1)) {\n          METLIBS_LOG_DEBUG(LOGVAL(GeogSemiMinorAxis));\n          have_semiminor_axis = true;\n        } else if (GTIFKeyGet(gtifin.get(), GeogInvFlatteningGeoKey, &GeogInvFlattening, 0, 1)) {\n          METLIBS_LOG_DEBUG(LOGVAL(GeogInvFlattening));\n        }\n\n        // clang-format off\n        proj4 << \"+proj=omerc\"\n              << \" +lat_0=\" << ProjCenterLat\n              << \" +lonc=\" << ProjCenterLon;\n        // clang-format on\n        if (have_alpha)\n          proj4 << \" +alpha=\" << ProjAzimuthAngle;\n        if (have_gamma)\n          proj4 << \" +gamma=\" << ProjRectifiedGridAngle;\n        // clang-format off\n        proj4 << \" +k_0=\" << ProjScaleAtCenter\n              << \" +a=\" << GeogSemiMajorAxis\n              << \" +units=m +no_defs\";\n        // clang-format on\n        if (have_semiminor_axis)\n          proj4 << \" +b=\" << GeogSemiMinorAxis;\n        else\n          proj4 << \" +rf=\" << GeogInvFlattening;\n      } else {\n        METLIBS_LOG_ERROR(\"Projection CT \" << ProjCoordTrans << \" not yet supported\");\n        return -1;\n      }\n\n      double ProjFalseEasting = 0, ProjFalseNorthing = 0;\n      GTIFKeyGet(gtifin.get(), ProjFalseEastingGeoKey, &ProjFalseEasting, 0, 1);\n      GTIFKeyGet(gtifin.get(), ProjFalseNorthingGeoKey, &ProjFalseNorthing, 0, 1);\n      if (ProjFalseEasting != 0)\n        proj4 << \" +x_0=\" << ProjFalseEasting;\n      if (ProjFalseNorthing != 0)\n        proj4 << \" +y_0=\" << ProjFalseNorthing;\n    }\n    ginfo.projection = Projection(proj4.str());\n  } else {\n    METLIBS_LOG_ERROR(\"Grid type not supported, GTModelType = \" << modeltype);\n    return -1;\n  }\n\n  ginfo.Bx = x_0 * unit_scale_factor;\n  ginfo.By = y_0 * unit_scale_factor;\n  ginfo.Ax = x_scale * unit_scale_factor;\n  ginfo.Ay = y_scale * unit_scale_factor;\n\n  if (!TIFFGetField(in.get(), TIFFTAG_IMAGEWIDTH, &ginfo.xsize)) {\n    METLIBS_LOG_DEBUG(\"No TIFFTAG_IMAGEWIDTH\");\n  }\n  if (!TIFFGetField(in.get(), TIFFTAG_IMAGELENGTH, &ginfo.ysize)) {\n    METLIBS_LOG_DEBUG(\"No TIFFTAG_IMAGELENGTH\");\n  }\n\n  int tilesAcross = 1, tilesDown = 1;\n\n  unsigned int tileWidth;\n  if (!TIFFGetField(in.get(), TIFFTAG_TILEWIDTH, &tileWidth)) {\n    METLIBS_LOG_DEBUG(\"No TIFFTAG_TILEWIDTH\");\n    tileWidth = 0;\n  }\n  unsigned int tileLength;\n  if (!TIFFGetField(in.get(), TIFFTAG_TILELENGTH, &tileLength)) {\n    METLIBS_LOG_DEBUG(\"No TIFFTAG_TILELENGTH\");\n    tileLength = 0;\n  }\n\n  if (tileWidth != 0 && tileLength != 0) {\n    tilesAcross = (ginfo.xsize + (tileWidth - 1)) / tileWidth;\n    tilesDown = (ginfo.ysize + (tileLength - 1)) / tileLength;\n    if (tilesAcross * tileWidth > ginfo.xsize)\n      ginfo.xsize = tilesAcross * tileWidth;\n    if (tilesDown * tileLength > ginfo.ysize)\n      ginfo.ysize = tilesDown * tileLength;\n  }\n\n  METLIBS_LOG_DEBUG(LOGVAL(ginfo.Ax) << LOGVAL(ginfo.Ay) << LOGVAL(ginfo.Bx) << LOGVAL(ginfo.By) << LOGVAL(ginfo.projection.getProj4Definition())\n                                     << LOGVAL(tileWidth) << LOGVAL(tileLength) << LOGVAL(tilesAcross) << LOGVAL(tilesDown));\n\n  if (pmi == PHOTOMETRIC_PALETTE)\n    return 2;\n  else\n    return 0;\n}",
    "int satimg::MITIFF_read_diana(const std::string& infile, unsigned char* image[], int nchan, const int chan[], dihead& ginfo)\n{\n  ginfo.noofcl = 0;\n\n  const int pal = MITIFF_head_diana(infile, ginfo);\n  if (pal == -1)\n    return -1;\n\n  if (nchan == 0) {\n    return 1;\n  }\n\n  std::unique_ptr<TIFF, CloseTIFF> in(TIFFOpen(infile.c_str(), \"rc\"));\n  if (!in) {\n    METLIBS_LOG_ERROR(\"TIFFOpen failed, probably not a TIFF file: '\" << infile << \"'\");\n    return -1;\n  }\n\n  // Read image data into matrix.\n  TIFFGetField(in.get(), TIFFTAG_IMAGEWIDTH, &ginfo.xsize);\n  TIFFGetField(in.get(), TIFFTAG_IMAGELENGTH, &ginfo.ysize);\n  const int size = ginfo.xsize * ginfo.ysize;\n\n  /*\n   * Memory allocated for image data in this function (*image) is freed\n   * in function main process.\n   */\n  if (ginfo.zsize > MAXCHANNELS) {\n    METLIBS_LOG_ERROR(\"NOT ENOUGH POINTERS AVAILABLE TO HOLD DATA!\");\n    return -1;\n  }\n\n  for (int i = 0; i < nchan; i++) {\n    if (i != 0 || chan[0] != 0) { /*TIFFsetDirectory chrashes if chan[0]=0,why??*/\n      if (!TIFFSetDirectory(in.get(), chan[i]))\n        return -1;\n    }\n    image[i] = new unsigned char[size + 1];\n    if (!image[i])\n      return -1;\n\n    int compression = COMPRESSION_NONE;\n    if (!TIFFGetField(in.get(), TIFFTAG_COMPRESSION, &compression))\n      compression = COMPRESSION_NONE;\n\n    int status;\n    if (compression == COMPRESSION_NONE)\n      status = TIFFReadRawStrip(in.get(), 0, image[i], size);\n    else\n      status = TIFFReadEncodedStrip(in.get(), 0, image[i], size);\n    if (status == -1)\n      return -1;\n  }\n\n  return pal;\n}",
    "int satimg::MITIFF_head_diana(const std::string& infile, dihead& ginfo)\n{\n  METLIBS_LOG_SCOPE();\n  std::unique_ptr<TIFF, CloseTIFF> in(TIFFOpen(infile.c_str(), \"rc\"));\n  if (!in) {\n    METLIBS_LOG_ERROR(\"TIFFOpen failed, probably not a TIFF file: '\" << infile << \"'\");\n    return -1;\n  }\n\n  const std::string fieldname[] = {\"Satellite:\",\n                                   \"Date and Time:\",\n                                   \"SatDir:\",\n                                   \"Channels:\",\n                                   \"In this file:\",\n                                   \"Xsize:\",\n                                   \"Ysize:\",\n                                   \"Map projection:\",\n                                   \"Proj string:\",\n                                   \"TrueLat:\",\n                                   \"GridRot:\",\n                                   \"Xunit:\",\n                                   \"Yunit:\",\n                                   \"NPX:\",\n                                   \"NPY:\",\n                                   \"Ax:\",\n                                   \"Ay:\",\n                                   \"Bx:\",\n                                   \"By:\",\n                                   \"Calibration VIS:\",\n                                   \"Calibration IR:\",\n                                   \"Table_calibration:\",\n                                   \"COLOR INFO:\",\n                                   \"NWP INFO:\"};\n  const size_t FIELDS = sizeof(fieldname) / sizeof(fieldname[0]);\n\n  float gridRot = 60, trueLat = 0;\n  ginfo.noofcl = 0;\n\n  // Test whether this is a color palette image or not. pmi==3 => color palette\n  short pmi;\n  if (TIFFGetField(in.get(), TIFFTAG_PHOTOMETRIC, &pmi) && pmi == PHOTOMETRIC_PALETTE) {\n    unsigned short int *red, *green, *blue;\n    if (!TIFFGetField(in.get(), TIFFTAG_COLORMAP, &red, &green, &blue)) {\n      return 2;\n    }\n    for (int i = 0; i < 256; i++) {\n      ginfo.cmap[0][i] = red[i];\n      ginfo.cmap[1][i] = green[i];\n      ginfo.cmap[2][i] = blue[i];\n    }\n  }\n\n  char* description = 0;\n  if (!TIFFGetField(in.get(), TIFFTAG_IMAGEDESCRIPTION, &description) || !description)\n    return -1;\n  std::string desc_str(description);\n\n  // read all common fields\n  while (true) {\n    // Find key word\n    size_t i = 0;\n    size_t nn = desc_str.npos;\n    while (nn == desc_str.npos && i < FIELDS) {\n      nn = desc_str.find(fieldname[i]);\n      i++;\n    }\n    if (i == FIELDS)\n      break; // no key word found\n    i--;\n    nn += fieldname[i].size();\n    desc_str = desc_str.substr(nn, desc_str.size() - nn + 1);\n    // find next key word\n    size_t j = 0;\n    size_t mm = std::string::npos;\n    while (mm == std::string::npos && j < FIELDS) {\n      mm = desc_str.find(fieldname[j]);\n      j++;\n    }\n    std::string value;\n    if (j < FIELDS + 1)\n      value = desc_str.substr(0, mm);\n    else\n      value = desc_str;\n\n    miutil::trim(value);\n    if (fillhead_diana(value, fieldname[i], ginfo, gridRot, trueLat) != 0)\n      return -1;\n  }\n\n  // If the mitiff image contains no proj string, it is probably transformed to +R=6371000\n  // and adjusted to fit nwp-data and maps.\n  // These adjustments require no conversion between +R=6371000 and ellps=WGS84,\n  // and therefore no +datum or +towgs84 are given.\n  if (!ginfo.projection.isDefined()) {\n    std::ostringstream proj4;\n    proj4 << \"+proj=stere\";\n    proj4 << \" +lon_0=\" << gridRot;\n    proj4 << \" +lat_ts=\" << trueLat;\n    proj4 << \" +lat_0=90\";\n    proj4 << \" +R=6371000\";\n    proj4 << \" +units=km\";\n    ginfo.projection.setProj4Definition(proj4.str());\n    ginfo.By -= ginfo.Ay * ginfo.ysize;\n  } else {\n    double x_0, y_0;\n    std::string proj4 = ginfo.projection.getProj4Definition();\n    if (proj4_value(proj4, \"+x_0=\", x_0, true))\n      ginfo.Bx = x_0 / -1000;\n    if (proj4_value(proj4, \"+y_0=\", y_0, true))\n      ginfo.By = y_0 / -1000;\n    ginfo.projection.setProj4Definition(proj4);\n  }\n\n  return (pmi == PHOTOMETRIC_PALETTE) ? 2 : 0;\n}",
    "uint8 ReadGeotiff_bits(char *filename)\n{\n    TIFF *tif;\n    uint8 bits;\n    \n    tif = XTIFFOpen(filename, \"r\");\n    if (tif)\n    {\n        size_t value = 0;\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &value);\n        \n        if(value == 16)\n            bits = 12;\n        else\n            bits = value;\n        \n        XTIFFClose(tif);\n    }\n    return bits;\n}",
    "CSize ReadGeotiff_info(const char *filename, double *minX, double *maxY, double *grid_size)\n{\n    TIFF *tif;\n    CSize image_size;\n\n    tif = XTIFFOpen(filename, \"r\");\n    if (tif)\n    {\n        uint16 count = 0;\n        double *data = 0;\n\n        TIFFGetField(tif, TIFFTAG_GEOTIEPOINTS, &count, &data);\n        if (minX != NULL) *minX = data[3];\n        if (maxY != NULL) *maxY = data[4];\n\n        TIFFGetField(tif, TIFFTAG_GEOPIXELSCALE, &count, &data);\n        if (grid_size != NULL) *grid_size = data[0];\n\n        size_t value = 0;\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &value);\n        image_size.width = value;\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &value);\n        image_size.height = value;\n\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &value);\n        \n        if(value == 16)\n            value = 12;\n       XTIFFClose(tif);\n    }\n    return image_size;\n}",
    "CSize ReadGeotiff_info_dxy(char *filename, double *minX, double *maxY, double *grid_size_dx, double *grid_size_dy)\n{\n    TIFF *tif;\n    CSize image_size;\n    \n    tif = XTIFFOpen(filename, \"r\");\n    if (tif)\n    {\n        uint16 count = 0;\n        double *data = 0;\n        \n        TIFFGetField(tif, TIFFTAG_GEOTIEPOINTS, &count, &data);\n        if (minX != NULL) *minX = data[3];\n        if (maxY != NULL) *maxY = data[4];\n        \n        TIFFGetField(tif, TIFFTAG_GEOPIXELSCALE, &count, &data);\n        if (grid_size_dx != NULL) *grid_size_dx = data[0];\n        if (grid_size_dy != NULL) *grid_size_dy = data[1];\n        \n        size_t value = 0;\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &value);\n        image_size.width = value;\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &value);\n        image_size.height = value;\n        \n        XTIFFClose(tif);\n    }\n    return image_size;\n}",
    "bool Image::initWithTiffData(const unsigned char * data, ssize_t dataLen)\n{\n#if CC_USE_TIFF\n    bool ret = false;\n    do \n    {\n        // set the read call back function\n        tImageSource imageSource;\n        imageSource.data    = data;\n        imageSource.size    = dataLen;\n        imageSource.offset  = 0;\n\n        TIFF* tif = TIFFClientOpen(\"file.tif\", \"r\", (thandle_t)&imageSource, \n            tiffReadProc, tiffWriteProc,\n            tiffSeekProc, tiffCloseProc, tiffSizeProc,\n            tiffMapProc,\n            tiffUnmapProc);\n\n        CC_BREAK_IF(nullptr == tif);\n\n        uint32 w = 0, h = 0;\n        uint16 bitsPerSample = 0, samplePerPixel = 0, planarConfig = 0;\n        size_t npixels = 0;\n        \n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplePerPixel);\n        TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planarConfig);\n\n        npixels = w * h;\n        \n        _renderFormat = Texture2D::PixelFormat::RGBA8888;\n        _width = w;\n        _height = h;\n\n        _dataLen = npixels * sizeof (uint32);\n        _data = static_cast<unsigned char*>(malloc(_dataLen * sizeof(unsigned char)));\n\n        uint32* raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n        if (raster != nullptr) \n        {\n           if (TIFFReadRGBAImageOriented(tif, w, h, raster, ORIENTATION_TOPLEFT, 0))\n           {\n                /* the raster data is pre-multiplied by the alpha component \n                   after invoking TIFFReadRGBAImageOriented*/\n                _hasPremultipliedAlpha = true;\n\n               memcpy(_data, raster, npixels*sizeof (uint32));\n           }\n\n          _TIFFfree(raster);\n        }\n        \n\n        TIFFClose(tif);\n\n        ret = true;\n    } while (0);\n    return ret;\n#else\n    CCLOG(\"tiff is not enabled, please enalbe it in ccConfig.h\");\n    return false;\n#endif\n}",
    "bool TIFFTReadUInt16(TIFF* tif, uint16_t** image, uint16_t* width, uint16_t* height, char* errormessage, unsigned int /*sample*/) {\n    uint16_t samplesperpixel=1;\n    uint16_t bitspersample=16;\n    uint16_t sampleformat = SAMPLEFORMAT_UINT;\n    uint32_t nx=0;\n    uint32_t ny=0;\n    uint16_t* tiffbuf = NULL;\n    uint16_t* imagebuf=NULL;\n    uint32_t row = 0;\n    uint32_t rowsperstrip = 0;\n    unsigned int rr=0;\n    unsigned int cc=0;\n    bool ok=true;\n\n    TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\n    TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\n    TIFFGetField(tif,TIFFTAG_SAMPLESPERPIXEL,&samplesperpixel);\n    TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleformat);\n    TIFFGetFieldDefaulted(tif,TIFFTAG_BITSPERSAMPLE,&bitspersample);\n\n\n    if (sampleformat!=SAMPLEFORMAT_UINT) {\n        if (errormessage) sprintf(errormessage, \"can not read sample format other than uint\");\n        return false;\n    }\n\n    if ((bitspersample!=16)) {\n        if (errormessage) sprintf(errormessage, \"can not read sample with %d bits depth\", bitspersample);\n        return false;\n    }\n\n    if ((*image==NULL)||(nx!=*width)||(ny!=*height)) {\n        *image=(uint16_t*)realloc(*image, nx*ny*sizeof(uint16_t));\n        *width=nx;\n        *height=ny;\n    }\n\n    imagebuf=*image;\n    if (imagebuf==NULL) {\n        if (errormessage) sprintf(errormessage, \"error allocating memory (%.1f kBytes)\", (float)(nx*ny*sizeof(uint16_t))/1024.0);\n        return false;\n    }\n\n    tiffbuf = (uint16_t*)_TIFFmalloc(TIFFStripSize(tif));\n    if (tiffbuf) {\n        row = 0;\n        rowsperstrip = 0;\n        TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n        for (row = 0; ok&&(row<ny); row+= rowsperstrip) {\n            uint32_t nrow =  ( (row+rowsperstrip>ny)?(ny-row):rowsperstrip);\n            tstrip_t strip = TIFFComputeStrip(tif, row, 0);\n            if ((TIFFReadEncodedStrip(tif,strip,tiffbuf,-1))<0) {\n                ok=false;\n                if (errormessage) sprintf(errormessage, \"invalid strip\");\n                break;\n            }\n            uint16_t* ptr = tiffbuf;\n            int iii=0;\n            for (rr = 0;rr<nrow; ++rr) {\n                for (cc = 0; cc<nx; ++cc) {\n                    uint16_t t=(uint16_t)*(ptr++);\n                    iii++;\n                    imagebuf[cc+(row+rr)*nx]=t;\n                }\n            }\n        }\n    } else {\n        if (errormessage) sprintf(errormessage, \"error allocating memory buffer for TIFF strip\");\n        return false;\n    }\n    if (tiffbuf) _TIFFfree(tiffbuf);\n\n    return ok;\n}",
    "void TEST_AGAINST_LIBTIFF(const std::string& filename, std::vector<TestResult>& test_results) {\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    HighResTimer timer, timer1;\r\n    bool ok=false;\r\n    std::cout<<\"\\n\\nreading '\"<<std::string(filename)<<\"' with tinytiff and libtiff and checking read contents ... filesize = \"<<bytestostr(get_filesize(filename.c_str()))<<\"\\n\";\r\n    test_results.emplace_back();\r\n    test_results.back().name=std::string(\"TEST_AGAINST_LIBTIFF(\")+std::string(filename)+std::string(\")\");\r\n    test_results.back().success=ok=false;\r\n    test_results.back().numImages=0;\r\n    try {\r\n        timer.start();\r\n        std::cout<<\"    libTIFF: opening file with     [duration: \"<<floattounitstr(double(timer.get_time())/1.0e6, \"s\")<<\" ]\\n\";\r\n        TIFF* ltiff=TIFFOpen(filename.c_str(), \"r\");\r\n        if (!ltiff) {\r\n            TESTFAIL(\"libTIFF ERROR: reading (not existent, not accessible or no TIFF file)\", test_results.back())\r\n        } else {\r\n            timer.start();\r\n            uint32_t libTIFF_frames=TIFFCountDirectories(ltiff);\r\n            double duration=timer.get_time();\r\n            std::cout<<\"    libTIFF: frames: \"<<libTIFF_frames<<\"     [duration: \"<<duration<<\" us  =  \"<<floattounitstr(duration/1.0e6, \"s\")<<\" ]\\n\";\r\n            std::cout<<\"    TinyTIFF: opening file with     [duration: \"<<floattounitstr(double(timer.get_time())/1.0e6, \"s\")<<\" ]\\n\";\r\n            TinyTIFFReaderFile* tiffr=TinyTIFFReader_open(filename.c_str());\r\n            if (!tiffr) {\r\n                TESTFAIL(\"TinyTIFF ERROR: reading (not existent, not accessible or no TIFF file)\", test_results.back())\r\n                ok=false;\r\n            } else if (TinyTIFFReader_wasError(tiffr)) {\r\n                TESTFAIL(\"TinyTIFF ERROR: \"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back())\r\n                ok=false;\r\n            } else {\r\n                timer.start();\r\n                uint32_t tinyTIFF_frames=TinyTIFFReader_countFrames(tiffr);\r\n                duration=timer.get_time();\r\n                std::cout<<\"    TinyTIFF: frames: \"<<tinyTIFF_frames<<\"     [duration: \"<<duration<<\" us  =  \"<<floattounitstr(duration/1.0e6, \"s\")<<\" ]\\n\";\r\n                if (TinyTIFFReader_wasError(tiffr)) {\r\n                    TESTFAIL(\"TinyTIFF ERROR: \"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back())\r\n                    ok=false;\r\n                } else {\r\n                    if (libTIFF_frames!=tinyTIFF_frames) {\r\n                        TESTFAIL(\"number of frames, read with TinyTIFF (\"<<tinyTIFF_frames<<\") and libTIFF (\"<<libTIFF_frames<<\") are not equal!\", test_results.back())\r\n                        ok=false;\r\n                    } else {\r\n                        timer.start();\r\n                        size_t frame=0;\r\n                        ok=true;\r\n                        do {\r\n                            std::cout<<\"   frame: \"<<frame<<std::endl;\r\n                            uint32_t tinyTIFF_width=TinyTIFFReader_getWidth(tiffr);\r\n                            uint32_t tinyTIFF_height=TinyTIFFReader_getHeight(tiffr);\r\n                            uint16_t tinyTIFF_bitspersample=TinyTIFFReader_getBitsPerSample(tiffr, 0);\r\n                            uint16_t tinyTIFF_samplesperpixel=TinyTIFFReader_getSamplesPerPixel(tiffr);\r\n                            const char* tinyTIFF_imagedesc=TinyTIFFReader_getImageDescription(tiffr);\r\n                            std::cout<<\"     tinyTIFF: width=\"<<tinyTIFF_width<<\", height=\"<<tinyTIFF_height<<\", bitspersample=\"<<tinyTIFF_bitspersample<<\", samplesperpixel=\"<<tinyTIFF_samplesperpixel<<\"\\n\";\r\n                            if (frame==0) {\r\n                                const std::string desc=std::to_string(tinyTIFF_width)+\"x\"+std::to_string(tinyTIFF_height)+\"pix/\"+std::to_string(sizeof(TIMAGESAMPLETYPE)*8)+\"bit/\"+std::to_string(tinyTIFF_samplesperpixel)+\"ch/\"+std::to_string(tinyTIFF_frames)+\"frames\";\r\n                                test_results.back().name=std::string(\"TEST_AGAINST_LIBTIFF(\")+desc+\", \"+std::string(filename)+std::string(\")\");\r\n                            }\r\n\r\n                            uint32_t libTIFF_width=0;\r\n                            uint32_t libTIFF_height=0;\r\n                            uint32_t libTIFF_bitspersample=0;\r\n                            uint32_t libTIFF_samplesperpixel=0;\r\n                            char*libtiff_imagedesc;\r\n                            TIFFGetField(ltiff,TIFFTAG_SAMPLESPERPIXEL,&libTIFF_samplesperpixel);\r\n                            TIFFGetField(ltiff,TIFFTAG_BITSPERSAMPLE,&libTIFF_bitspersample);\r\n                            TIFFGetField(ltiff,TIFFTAG_IMAGEWIDTH,&libTIFF_width);\r\n                            TIFFGetField(ltiff,TIFFTAG_IMAGELENGTH,&libTIFF_height);\r\n                            TIFFGetField(ltiff,TIFFTAG_IMAGEDESCRIPTION,&libtiff_imagedesc);\r\n                            TIFFPrintDirectory(ltiff, stdout,TIFFPRINT_STRIPS|TIFFPRINT_COLORMAP);\r\n                            std::cout<<\"     libTIFF:  width=\"<<libTIFF_width<<\", height=\"<<libTIFF_height<<\", bitspersample=\"<<libTIFF_bitspersample<<\", samplesperpixel=\"<<libTIFF_samplesperpixel<<\"\\n\";\r\n\r\n                            if (tinyTIFF_width!=libTIFF_width) {\r\n                                TESTFAIL(\"in frame \"<<frame<<\": TinyTIFF and libTIFF read different widths (TinyTIFF: \"<<tinyTIFF_width<<\" != libTIFF: \"<<libTIFF_width<<\")\", test_results.back())\r\n                                ok=false;\r\n                                break;\r\n                            }\r\n                            if (tinyTIFF_height!=libTIFF_height) {\r\n                                TESTFAIL(\"in frame \"<<frame<<\": TinyTIFF and libTIFF read different heights (TinyTIFF: \"<<tinyTIFF_height<<\" != libTIFF: \"<<libTIFF_height<<\")\", test_results.back())\r\n                                ok=false;\r\n                                break;\r\n                            }\r\n                            if (tinyTIFF_bitspersample!=libTIFF_bitspersample) {\r\n                                TESTFAIL(\"in frame \"<<frame<<\": TinyTIFF and libTIFF read different bitspersamples (TinyTIFF: \"<<tinyTIFF_bitspersample<<\" != libTIFF: \"<<libTIFF_bitspersample<<\")\", test_results.back())\r\n                                ok=false;\r\n                                break;\r\n                            }\r\n                            if (tinyTIFF_samplesperpixel!=libTIFF_samplesperpixel) {\r\n                                TESTFAIL(\"in frame \"<<frame<<\": TinyTIFF and libTIFF read different samplesperpixels (TinyTIFF: \"<<tinyTIFF_samplesperpixel<<\" != libTIFF: \"<<libTIFF_samplesperpixel<<\")\", test_results.back())\r\n                                ok=false;\r\n                                break;\r\n                            }\r\n                            if (tinyTIFF_imagedesc==nullptr || libtiff_imagedesc==nullptr || strcmp(tinyTIFF_imagedesc, libtiff_imagedesc)!=0) {\r\n                                std::cout<<\"       WARNING in frame \"<<frame<<\": TinyTIFF and libTIFF read different descriptions (TinyTIFF: '\"<<tinyTIFF_imagedesc<<\"' != libTIFF: '\"<<libtiff_imagedesc<<\"')\\n\";\r\n                                //ok=false;\r\n                                //break;\r\n                            }\r\n                            if (ok) {\r\n                                for (size_t sample=0; sample<libTIFF_samplesperpixel; sample++) {\r\n                                    std::vector<TIMAGESAMPLETYPE> tinyTIFF_data(tinyTIFF_width*tinyTIFF_height*sizeof(TIMAGESAMPLETYPE)*2, 0);\r\n                                    TinyTIFFReader_getSampleData(tiffr,tinyTIFF_data.data(), sample);\r\n                                    if (TinyTIFFReader_wasError(tiffr)) {\r\n                                        TESTFAIL(\"TinyTIFF ERROR: reading frame \"<<frame<<\", sample \"<<sample<<\":\"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back())\r\n                                        ok=false;\r\n                                        break;\r\n                                    }\r\n                                    std::vector<TIMAGESAMPLETYPE> libTIFF_data(libTIFF_width*libTIFF_height*sizeof(TIMAGESAMPLETYPE)*2, 0);\r\n                                    if (!TIFFReadFrame(ltiff, libTIFF_data.data(), sample)) {\r\n                                        TESTFAIL(\"libTIFF ERROR: reading frame \"<<frame<<\", sample \"<<sample<<\"\", test_results.back())\r\n                                        ok=false;\r\n                                        break;\r\n                                    }\r\n                                    for (size_t i=0; i<libTIFF_data.size(); i++) {\r\n                                        if (i<=8) std::cout<<\"          f\"<<frame<<\"s\"<<sample<<\"i\"<<i<<\": tiny=\"<<std::dec<<static_cast<typename atleast_int<TIMAGESAMPLETYPE>::TPrint>(tinyTIFF_data[i])<<\" lib=\"<<static_cast<typename atleast_int<TIMAGESAMPLETYPE>::TPrint>(libTIFF_data[i])<<\"\\n\";\r\n                                        if (libTIFF_data[i]!=tinyTIFF_data[i]) {\r\n                                            TESTFAIL(\"in frame \"<<frame<<\", sample \"<<sample<<\": TinyTIFF and libTIFF read different sample values (I=\"<<i<<\": TinyTIFF: \"<<std::dec<<static_cast<typename atleast_int<TIMAGESAMPLETYPE>::TPrint>(tinyTIFF_data[i])<<\" != libTIFF: \"<<std::dec<<static_cast<typename atleast_int<TIMAGESAMPLETYPE>::TPrint>(libTIFF_data[i])<<\")\", test_results.back())\r\n                                            ok=false;\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                    if (!ok) {\r\n                                        SAVE_TIFF(std::string(std::string(filename)+\".tinytiff.error_sample\"+std::to_string(sample)+\".tif\").c_str(), tinyTIFF_data.data(), tinyTIFF_width, tinyTIFF_height);\r\n                                        SAVE_TIFF(std::string(std::string(filename)+\".libtiff.error_sample\"+std::to_string(sample)+\".tif\").c_str(), libTIFF_data.data(), tinyTIFF_width, tinyTIFF_height);\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n\r\n                            frame++;\r\n                        } while (ok && TIFFReadDirectory(ltiff) && TinyTIFFReader_readNext(tiffr));\r\n\r\n                        test_results.back().success=ok;\r\n                        test_results.back().numImages=frame;\r\n                        duration=timer.get_time();\r\n                        test_results.back().duration_ms=duration/1.0e3;\r\n                        std::cout<<\"    read and checked all \"<<frame<<\" frames: \"<<((ok)?std::string(\"SUCCESS\"):std::string(\"ERROR\"))<<\"     [duration: \"<<duration<<\" us  =  \"<<floattounitstr(duration/1.0e6, \"s\")<<\" ]\\n\";\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch(...) {\r\n        ok=false;\r\n        std::cout<<\"       CRASH While reading file\\n\";\r\n    }\r\n\r\n    test_results.back().success=ok;\r\n    if (ok) std::cout<<\"  => SUCCESS\\n\";\r\n    else std::cout<<\"  => NOT CORRECTLY READ\\n\";\r\n#endif\r\n}",
    "bool libtiffTestRead(const char* filename, const T* writteneven, const T* writtenodd, uint32_t width, uint32_t height, uint16_t samples=1, uint32_t frames_expected=0, TinyTIFFSampleLayout inputOrg=TinyTIFF_Chunky, std::string* description_out=nullptr)  {\r\n    bool ok=true;\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    TIFF* tif = TIFFOpen(filename, \"r\");\r\n    T* data=(T*)malloc(width*height*sizeof(T));\r\n    if (tif) {\r\n        uint32_t frame=0;\r\n        do {\r\n            uint32_t nx,ny;\r\n            uint16_t ns,bs;\r\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\r\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\r\n            TIFFGetField(tif,TIFFTAG_SAMPLESPERPIXEL,&ns);\r\n            TIFFGetField(tif,TIFFTAG_BITSPERSAMPLE,&bs);\r\n            char* val=NULL;\r\n            TIFFGetField(tif,TIFFTAG_IMAGEDESCRIPTION,&val);\r\n            if (val) {\r\n                std::cout<<\"    ImageDescription(\"<<strlen(val)<<\"):\\n\"<<val<<\"\\n\";\r\n                if (description_out) *description_out=val;\r\n            } else {\r\n                if (description_out) description_out->clear();\r\n            }\r\n            TIFFPrintDirectory(tif, stdout);\r\n            if (nx==width && ny==height && ns==samples && bs==sizeof(T)*8) {\r\n                size_t errcnt=0;\r\n                size_t pixcnt=0;\r\n                for (uint16_t samp=0; samp<samples; samp++) {\r\n                    if (TIFFReadFrame(tif, data, samp)) {\r\n                        ok=true;\r\n                        const T* written=writteneven;\r\n                        if (writtenodd && frame%2==1) written=writtenodd;\r\n                        if (inputOrg==TinyTIFF_Chunky) {\r\n                            for (uint32_t i=0; i<width*height; i++) {\r\n                                if (data[i]!=written[i*samples+samp]) {\r\n                                    ok=false;\r\n                                    errcnt++;\r\n                                    if (errcnt<50) std::cout<<\" -- READ-ERROR: pixel-value differs in frame \"<<frame<<\" for pixel (\"<<i%width<<\",\"<<i/width<<\"): file: \"<<static_cast<typename atleast_int<T>::TPrint>(data[i])<<\" expected: \"<<static_cast<typename atleast_int<T>::TPrint>(written[i*samples+samp])<<\"\\n\";\r\n                                    if (errcnt==50) std::cout<<\" -- READ-ERROR: ...\\n\";\r\n                                } else {\r\n                                    pixcnt++;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            for (uint32_t i=0; i<width*height; i++) {\r\n                                if (data[i]!=written[i+samp*width*height]) {\r\n                                    ok=false;\r\n                                    errcnt++;\r\n                                    if (errcnt<50) std::cout<<\" -- READ-ERROR: pixel-value differs in frame \"<<frame<<\" for pixel (\"<<i%width<<\",\"<<i/width<<\"): file: \"<<static_cast<typename atleast_int<T>::TPrint>(data[i])<<\" expected: \"<<static_cast<typename atleast_int<T>::TPrint>(written[i+samp*width*height])<<\"\\n\";\r\n                                    if (errcnt==50) std::cout<<\" -- READ-ERROR: ...\\n\";\r\n                                } else {\r\n                                    pixcnt++;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (!ok) {\r\n                            std::cout<<\" -- TEST READ WITH LIBTIFF: READ WRONG DATA for \"<<errcnt<<\" pixels in frame \"<<frame<<\"!!!\\n\";\r\n                        }\r\n                    } else {\r\n                        std::cout<<\" -- TEST READ WITH LIBTIFF: COULD NOT READ FRAME \"<<frame<<\"!\\n\";\r\n                        ok=false;\r\n                    }\r\n                }\r\n                if (ok) {\r\n                    std::cout<<\" -- TEST READ WITH LIBTIFF: SUCCESS FOR FRAME \"<<frame<<\"! All \"<<pixcnt<<\" pixels&samples as expected!\\n\";\r\n                }\r\n            } else {\r\n                std::cout<<\" -- TEST READ WITH LIBTIFF: FRAME SIZE OF FRAME \"<<frame<<\" DOES NOT MATCH (width: file:\"<<nx<<\"/expected:\"<<width<<\",   height: file:\"<<ny<<\"/expected:\"<<height<<\",   samples: file:\"<<ns<<\"/expected:\"<<samples<<\",   bitspersample: file:\"<<bs<<\"/expected:\"<<(sizeof(T)*8)<<\")!\\n\";\r\n                ok=false;\r\n            }\r\n            frame++;\r\n        } while (ok && TIFFReadDirectory(tif));\r\n        if (frames_expected>0 && frames_expected!=frame) {\r\n            std::cout<<\" -- ERROR IN TEST READ WITH LIBTIFF: number of frames (\"<<frame<<\")does not match expected number of frames (\"<<frames_expected<<\")\\n\";\r\n            ok=false;\r\n        }\r\n        TIFFClose(tif);\r\n    } else {\r\n        std::cout<<\" -- TEST READ WITH LIBTIFF: COULD NOT OPEN FILE!\\n\";\r\n        ok=false;\r\n    }\r\n    free(data);\r\n#endif\r\n    return ok;\r\n}",
    "__declspec(dllexport) void ReadEERCombinedFrame(const char* path, int firstFrameInclusive, int lastFrameExclusive, int eer_upsampling, float* h_result)\n{\n\tif (eer_upsampling < 1 || eer_upsampling > 3)\n\t\tthrow(\"EERRenderer::read: eer_upsampling must be 1, 2 or 3.\");\n\t\n\t// First of all, check the file size\n\tFILE* fh = fopen(path, \"r\");\n\tif (fh == NULL)\n\t\tthrow std::runtime_error(\"Failed to open file\");\n\n\tfseek(fh, 0, SEEK_END);\n\tlong long file_size = ftell(fh);\n\tfseek(fh, 0, SEEK_SET);\n\tfclose(fh);\n\n\tint nframes = 0;\n\tbool is_7bit = false;\n\t\n\t// Try reading as TIFF; this handle is kept open\n\tTIFF* ftiff = TIFFOpen(path, \"r\");\n\n\tif (ftiff == NULL)\n\t{\n\t\tthrow std::runtime_error(\"Legacy mode not implemented\");\n\t}\n\telse\n\t{\n\t\t// Check width & size\n\t\tint width, height;\n\t\tuint16_t compression = 0;\n\t\tTIFFGetField(ftiff, TIFFTAG_IMAGEWIDTH, &width);\n\t\tTIFFGetField(ftiff, TIFFTAG_IMAGELENGTH, &height);\n\t\tTIFFGetField(ftiff, TIFFTAG_COMPRESSION, &compression);\n\n\t\t// TIA can write an EER file whose first page is a sum and compressoin == 1.\n\t\t// This is not supported (yet). EPU never writes such movies.\n\t\tif (compression == TIFF_COMPRESSION_EER8bit)\n\t\t\tis_7bit = false;\n\t\telse if (compression == TIFF_COMPRESSION_EER7bit)\n\t\t\tis_7bit = true;\n\t\telse\n\t\t\tthrow std::runtime_error(\"Unknown compression scheme for EER\");\n\n\t\tif (width != EER_IMAGE_WIDTH || height != EER_IMAGE_HEIGHT)\n\t\t\tthrow std::runtime_error(\"Currently we support only 4096x4096 pixel EER movies.\");\n\n\t\t// Find the number of frames\n\t\tnframes = TIFFNumberOfDirectories(ftiff);\n\t}\n\t\n\tstd::vector<long long> frame_starts, frame_sizes;\n\tunsigned char* buf;\n\n\t{\n\t\tframe_starts.resize(nframes, 0);\n\t\tframe_sizes.resize(nframes, 0);\n\t\tbuf = (unsigned char*)malloc(file_size); // This is big enough\n\t\tif (buf == NULL)\n\t\t\tthrow std::runtime_error(\"Failed to allocate buffer\");\n\t\tlong long pos = 0;\n\n\t\t// Read everything\n\t\tfor (int frame = firstFrameInclusive; frame < lastFrameExclusive; frame++)\n\t\t{\n\t\t\tTIFFSetDirectory(ftiff, frame);\n\t\t\tconst int nstrips = TIFFNumberOfStrips(ftiff);\n\t\t\tframe_starts[frame] = pos;\n\n\t\t\tfor (int strip = 0; strip < nstrips; strip++)\n\t\t\t{\n\t\t\t\tconst int strip_size = TIFFRawStripSize(ftiff, strip);\n\t\t\t\tif (pos + strip_size >= file_size)\n\t\t\t\t\tthrow std::runtime_error(\"EER: buffer overflow when reading raw strips.\");\n\n\t\t\t\tTIFFReadRawStrip(ftiff, strip, buf + pos, strip_size);\n\t\t\t\tpos += strip_size;\n\t\t\t\tframe_sizes[frame] += strip_size;\n\t\t\t}\n\t\t}\n\n\t\tTIFFClose(ftiff);\n\t}\n\n\t{\n\t\tlong long total_n_electron = 0;\n\n\t\tlong long supersize = 4096 << (eer_upsampling - 1);\n\n\t\tstd::vector<unsigned int> positions;\n\t\tstd::vector<unsigned char> symbols;\n\t\tmemset(h_result, 0, supersize * supersize * sizeof(float));\n\n\t\tfor (int iframe = firstFrameInclusive; iframe < lastFrameExclusive; iframe++)\n\t\t{\n\t\t\tlong long pos = frame_starts[iframe];\n\t\t\tunsigned int n_pix = 0, n_electron = 0;\n\t\t\tconst int max_electrons = frame_sizes[iframe] * 2; // at 4 bits per electron (very permissive bound!)\n\t\t\tif (positions.size() < max_electrons)\n\t\t\t{\n\t\t\t\tpositions.resize(max_electrons);\n\t\t\t\tsymbols.resize(max_electrons);\n\t\t\t}\n\n\t\t\tif (is_7bit)\n\t\t\t{\n\t\t\t\tunsigned int bit_pos = 0; // 4 K * 4 K * 11 bit << 2 ** 32\n\t\t\t\tunsigned char p, s;\n\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\t// Fetch 32 bits and unpack up to 2 chunks of 7 + 4 bits.\n\t\t\t\t\t// This is faster than unpack 7 and 4 bits sequentially.\n\t\t\t\t\t// Since the size of buf is larger than the actual size by the TIFF header size,\n\t\t\t\t\t// it is always safe to read ahead.\n\n\t\t\t\t\tlong long first_byte = pos + (bit_pos >> 3);\n\t\t\t\t\tconst unsigned int bit_offset_in_first_byte = bit_pos & 7; // 7 = 00000111 (same as % 8)\n\t\t\t\t\tconst unsigned int chunk = (*(unsigned int*)(buf + first_byte)) >> bit_offset_in_first_byte;\n\n\t\t\t\t\tp = (unsigned char)(chunk & 127); // 127 = 01111111\n\t\t\t\t\tbit_pos += 7; // TODO: we can remove this for further speed.\n\t\t\t\t\tn_pix += p;\n\t\t\t\t\tif (n_pix == EER_IMAGE_PIXELS) break;\n\t\t\t\t\tif (p == 127) continue; // this should be rare.\n\n\t\t\t\t\ts = (unsigned char)((chunk >> 7) & 15) ^ 0x0A; // 15 = 00001111; See below for 0x0A\n\t\t\t\t\tbit_pos += 4;\n\t\t\t\t\tpositions[n_electron] = n_pix;\n\t\t\t\t\tsymbols[n_electron] = s;\n\t\t\t\t\tn_electron++;\n\t\t\t\t\tn_pix++;\n\n\t\t\t\t\tp = (unsigned char)((chunk >> 11) & 127); // 127 = 01111111\n\t\t\t\t\tbit_pos += 7;\n\t\t\t\t\tn_pix += p;\n\t\t\t\t\tif (n_pix == EER_IMAGE_PIXELS) break;\n\t\t\t\t\tif (p == 127) continue;\n\n\t\t\t\t\ts = (unsigned char)((chunk >> 18) & 15) ^ 0x0A; // 15 = 00001111; See below for 0x0A\n\t\t\t\t\tbit_pos += 4;\n\t\t\t\t\tpositions[n_electron] = n_pix;\n\t\t\t\t\tsymbols[n_electron] = s;\n\t\t\t\t\tn_electron++;\n\t\t\t\t\tn_pix++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// unpack every two symbols = 12 bit * 2 = 24 bit = 3 byte\n\t\t\t\t// high <- |bbbbBBBB|BBBBaaaa|AAAAAAAA| -> low\n\t\t\t\t// With SIMD intrinsics at the SSSE3 level, we can unpack 10 symbols (120 bits) simultaneously.\n\t\t\t\tunsigned char p1, p2, s1, s2;\n\n\t\t\t\tconst long long pos_limit = frame_starts[iframe] + frame_sizes[iframe];\n\t\t\t\t// Because there is a footer, it is safe to go beyond the limit by two bytes.\n\t\t\t\twhile (pos < pos_limit)\n\t\t\t\t{\n\t\t\t\t\t// symbol is bit tricky. 0000YyXx; Y and X must be flipped.\n\t\t\t\t\tp1 = buf[pos];\n\t\t\t\t\ts1 = (buf[pos + 1] & 0x0F) ^ 0x0A; // 0x0F = 00001111, 0x0A = 00001010\n\n\t\t\t\t\tp2 = (buf[pos + 1] >> 4) | (buf[pos + 2] << 4);\n\t\t\t\t\ts2 = (buf[pos + 2] >> 4) ^ 0x0A;\n\n\t\t\t\t\t// Note the order. Add p before checking the size and placing a new electron.\n\t\t\t\t\tn_pix += p1;\n\t\t\t\t\tif (n_pix == EER_IMAGE_PIXELS) break;\n\t\t\t\t\tif (p1 < 255)\n\t\t\t\t\t{\n\t\t\t\t\t\tpositions[n_electron] = n_pix;\n\t\t\t\t\t\tsymbols[n_electron] = s1;\n\t\t\t\t\t\tn_electron++;\n\t\t\t\t\t\tn_pix++;\n\t\t\t\t\t}\n\n\t\t\t\t\tn_pix += p2;\n\t\t\t\t\tif (n_pix == EER_IMAGE_PIXELS) break;\n\t\t\t\t\tif (p2 < 255)\n\t\t\t\t\t{\n\t\t\t\t\t\tpositions[n_electron] = n_pix;\n\t\t\t\t\t\tsymbols[n_electron] = s2;\n\t\t\t\t\t\tn_electron++;\n\t\t\t\t\t\tn_pix++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpos += 3;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (n_pix != EER_IMAGE_PIXELS)\n\t\t\t\tthrow std::runtime_error(\"Number of pixels is not right.\");\n\n\t\t\tif (eer_upsampling == 3)\n\t\t\t\trender16K(h_result, positions, symbols, n_electron);\n\t\t\telse if (eer_upsampling == 2)\n\t\t\t\trender8K(h_result, positions, symbols, n_electron);\n\t\t\telse if (eer_upsampling == 1)\n\t\t\t\trender4K(h_result, positions, symbols, n_electron);\n\t\t\telse\n\t\t\t\tthrow std::runtime_error(\"Invalid EER upsamle\");\n\n\t\t\ttotal_n_electron += n_electron;\n\t\t}\n\n\t\tfree(buf);\n\t}\n}",
    "__declspec(dllexport) void ReadTIFF(const char* path, int layer, bool flipy, float* h_result)\n{\n\tTIFF* ftiff = TIFFOpen(path, \"r\");\n\t\n\t// libtiff's types\n\tuint32 width, length;\n\n\tif (TIFFGetField(ftiff, TIFFTAG_IMAGEWIDTH, &width) != 1 ||\n\t\tTIFFGetField(ftiff, TIFFTAG_IMAGELENGTH, &length) != 1)\n\t{\n\t\tthrow std::runtime_error(\"The input TIFF file does not have the width or height field.\");\n\t}\n\n\tint3 dims = make_int3(width, length, TIFFNumberOfDirectories(ftiff));\n\n\tif (layer >= dims.z)\n\t\tthrow std::runtime_error(\"Requested layer exceeds the stack size.\");\n\n\tif (layer >= 0)\n\t\tdims.z = 1;\n\n\tuint16 sampleFormat, bitsPerSample;\n\tTIFFGetFieldDefaulted(ftiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n\tTIFFGetFieldDefaulted(ftiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n\tTIFFSetDirectory(ftiff, 0);\n\t\n\trelion::DataType datatype;\n\n\tif (bitsPerSample == 8 && sampleFormat == 1) {\n\t\tdatatype = relion::UChar;\n\t}\n\telse if (bitsPerSample == 16 && sampleFormat == 1) {\n\t\tdatatype = relion::UShort;\n\t}\n\telse if (bitsPerSample == 16 && sampleFormat == 2) {\n\t\tdatatype = relion::Short;\n\t}\n\telse if (bitsPerSample == 32 && sampleFormat == 3) {\n\t\tdatatype = relion::Float;\n\t}\n\telse {\n\t\tthrow std::runtime_error(\"Unsupported TIFF format\");\n\t}\n\n\tfloat* h_tempstrip = (float*)malloc(dims.x * sizeof(float));\n\n\t//dims.z = 20;\n\n\tfor (int z = 0; z < dims.z; z++) \n\t{\n\t\tTIFFSetDirectory(ftiff, layer < 0 ? z : layer);\n\n\t\tfloat* h_resultlayer = h_result + Elements2(dims) * z;\n\t\t\n\t\ttsize_t stripSize = TIFFStripSize(ftiff);\n\t\ttstrip_t numberOfStrips = TIFFNumberOfStrips(ftiff);\n\t\ttdata_t buf = _TIFFmalloc(stripSize);\n\t\n\t\tsize_t haveread_n = 0;\n\n\t\tfor (tstrip_t strip = 0; strip < numberOfStrips; strip++) \n\t\t{\n\t\t\ttsize_t actually_read = TIFFReadEncodedStrip(ftiff, strip, buf, stripSize);\n\t\t\ttsize_t actually_read_n = actually_read * 8 / bitsPerSample;\n\n\t\t\ttsize_t actually_read_n_8 = actually_read_n / 8 * 8;\n\n\t\t\tif (datatype == relion::UChar)\n\t\t\t{\n\t\t\t\tfor (tsize_t i = 0; i < actually_read_n_8; i += 8)\n\t\t\t\t{\n\t\t\t\t\th_resultlayer[haveread_n + i] = (float)((uchar*)buf)[i];\n\t\t\t\t\th_resultlayer[haveread_n + i + 1] = (float)((uchar*)buf)[i + 1];\n\t\t\t\t\th_resultlayer[haveread_n + i + 2] = (float)((uchar*)buf)[i + 2];\n\t\t\t\t\th_resultlayer[haveread_n + i + 3] = (float)((uchar*)buf)[i + 3];\n\t\t\t\t\th_resultlayer[haveread_n + i + 4] = (float)((uchar*)buf)[i + 4];\n\t\t\t\t\th_resultlayer[haveread_n + i + 5] = (float)((uchar*)buf)[i + 5];\n\t\t\t\t\th_resultlayer[haveread_n + i + 6] = (float)((uchar*)buf)[i + 6];\n\t\t\t\t\th_resultlayer[haveread_n + i + 7] = (float)((uchar*)buf)[i + 7];\n\t\t\t\t}\n\t\t\t\tfor (tsize_t i = actually_read_n_8; i < actually_read_n; i++)\n\t\t\t\t\th_resultlayer[haveread_n + i] = (float)((uchar*)buf)[i];\n\t\t\t}\n\t\t\telse if (datatype == relion::UShort)\n\t\t\t\tfor (tsize_t i = 0; i < actually_read_n; i++)\n\t\t\t\t\th_resultlayer[haveread_n + i] = (float)((ushort*)buf)[i];\n\t\t\telse if (datatype == relion::Short)\n\t\t\t\tfor (tsize_t i = 0; i < actually_read_n; i++)\n\t\t\t\t\th_resultlayer[haveread_n + i] = (float)((short*)buf)[i];\n\t\t\telse if (datatype == relion::Float)\n\t\t\t\tmemcpy(h_resultlayer + haveread_n, buf, actually_read);\n\t\t\t\n\t\t\thaveread_n += actually_read_n;\n\t\t}\n\n\t\t_TIFFfree(buf);\n\n\t\t// Flip the Y axis if requested\n\n\t\tif (flipy)\n\t\t{\n\t\t\tfor (tsize_t y1 = 0; y1 < dims.y / 2; y1++)\n\t\t\t{\n\t\t\t\ttsize_t y2 = dims.y - 1 - y1;\n\n\t\t\t\tmemcpy(h_tempstrip, h_resultlayer + y1 * dims.x, dims.x * sizeof(float));\n\n\t\t\t\tmemcpy(h_resultlayer + y1 * dims.x, h_resultlayer + y2 * dims.x, dims.x * sizeof(float));\n\n\t\t\t\tmemcpy(h_resultlayer + y2 * dims.x, h_tempstrip, dims.x * sizeof(float));\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(h_tempstrip);\n\n\tTIFFClose(ftiff);\n}",
    "char *loadTiff3D2Metadata ( char * filename, unsigned int &sz0, unsigned int  &sz1, unsigned int  &sz2, unsigned int  &sz3, int &datatype, int &b_swap, void * &fhandle, int &header_len ) {\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffLoadMetadata)\r\n    #endif\r\n\r\n\tuint32 XSIZE;\r\n\tuint32 YSIZE;\r\n\tuint16 bpp;\r\n\tuint16 spp;\r\n\tuint16 Cpage;\r\n\tuint16 Npages;\r\n    TIFF *input;\r\n    int check;\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\tinput=TIFFOpen(filename,\"r\");\r\n\tif (!input)\r\n    {\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Cannot open the file %s\",finName).c_str());\r\n\t\treturn ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &XSIZE);\r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n\t\treturn ((char *) \"Image width of undefined.\");\r\n\t}\t\t\r\n    \r\n\tcheck=TIFFGetField(input, TIFFTAG_IMAGELENGTH, &YSIZE);\r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n\t\treturn ((char *) \"Image length of undefined.\");\r\n\t}\t\t\r\n    \r\n\tcheck=TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp); \r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n\t\treturn ((char *) \"Undefined bits per sample.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tif (!check)\r\n\t{\r\n\t\tspp = 1;\r\n\t\t//TIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n\t\t//return ((char *) \"Undefined samples per pixel.\");\r\n\t}\r\n\r\n\t// 2021-02-10. Giulio. when it is compiled as a Vaa3D plugin does not check the tag TIFFTAG_PAGENUMBER to avoid exceptions on inconsistent files  \r\n\t#ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n\tcheck = 0;\r\n\t#else\r\n\t// Onofri\r\n\tcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &Npages);\r\n\t#endif\r\n\tif (check!=1 || Npages==0) { // the tag has not been read correctly\r\n\t\t// Add warning?\r\n\t\tNpages = 0;\r\n\t\tdo {\r\n\t\t\tNpages++;\r\n\t\t} while ( TIFFReadDirectory(input) );\r\n\t}\r\n\r\n\tsz0 = XSIZE;\r\n\tsz1 = YSIZE;\r\n\tsz2 = Npages;\r\n\tsz3 = spp;\r\n\tdatatype = bpp/8;\r\n\r\n\t//b_swap = 0;\r\n\tb_swap=TIFFIsByteSwapped(input);\r\n\tfhandle = (void *) input;\r\n\theader_len = -1;\r\n\r\n\t// the file must non be closed (it is responsibility of the caller)\r\n\t//TIFFClose(input);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffLoadMetadata, tf::IO, tf::strprintf(\"successfully loaded metadata from file \\\"%s\\\"\", filename))\r\n    #endif\r\n\r\n\treturn ((char *) 0);\r\n}",
    "char *appendSlice2Tiff3DFile ( char *filename, int slice, unsigned char *img, unsigned int img_width, unsigned int img_height ) {\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffAppendData)\r\n    #endif\r\n\r\n\tTIFF *output;\r\n\tuint16 spp, bpp, NPages, pg0;\r\n\tuint32 rperstrip;\r\n\tuint16 cmprssd;\r\n\tuint16 photomtrcintrp;\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\toutput=TIFFOpen(filename,\"r\");\r\n\tTIFFGetField(output, TIFFTAG_BITSPERSAMPLE, &bpp); \r\n\tTIFFGetField(output, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tTIFFGetField(output, TIFFTAG_PAGENUMBER, &pg0, &NPages);\r\n\tTIFFGetField(output, TIFFTAG_ROWSPERSTRIP, &rperstrip);\r\n\tTIFFGetField(output, TIFFTAG_COMPRESSION, &cmprssd);\r\n\tTIFFGetField(output, TIFFTAG_PHOTOMETRIC, &photomtrcintrp);\r\n\tTIFFClose(output);\r\n\r\n\tiim::sint64 expectedSize = ((iim::sint64) img_width) * ((iim::sint64) img_height) * ((iim::sint64) NPages) * ((iim::sint64) spp) * ((iim::sint64) (bpp/8)); \r\n\r\n\tif ( bigtiff || expectedSize > (4*GBSIZE) ) {\r\n\t\tif ( (rowsPerStrip == -1 && (((iim::sint64) img_width) * ((iim::sint64) img_height)) > (4*GBSIZE)) || ((rowsPerStrip * ((iim::sint64) img_width)) > (4*GBSIZE)) )\r\n\t\t\t// one strip is larger than 4GB\r\n\t\t\treturn ((char *) \"Too many rows per strip for this image width.\");\r\n\t\telse \r\n\t\t\toutput = (slice==0)? TIFFOpen(filename,\"w8\") : TIFFOpen(filename,\"a8\");\r\n\t}\r\n\telse\r\n\t\toutput = (slice==0)? TIFFOpen(filename,\"w\") : TIFFOpen(filename,\"a\");\r\n\r\n\tTIFFSetDirectory(output,slice); // WARNING: slice must be the first page after the last, otherwise the file can be corrupted\r\n\r\n\tTIFFSetField(output, TIFFTAG_IMAGEWIDTH, img_width);\r\n\tTIFFSetField(output, TIFFTAG_IMAGELENGTH, img_height);\r\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, bpp); \r\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, spp);\r\n\tTIFFSetField(output, TIFFTAG_ROWSPERSTRIP, rperstrip);\r\n\tTIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n\tTIFFSetField(output, TIFFTAG_COMPRESSION, cmprssd);\r\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, photomtrcintrp);\t\r\n\t// We are writing single page of the multipage file \r\n\tTIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n\tTIFFSetField(output, TIFFTAG_PAGENUMBER, (uint16)slice, NPages); \r\n\r\n\tif ( rowsPerStrip == -1 ) \r\n\t\tTIFFWriteEncodedStrip(output, 0, img, img_width * img_height * spp * (bpp/8));\r\n\telse { \r\n\t\tint check,StripsPerImage,LastStripSize;\r\n\t\tuint32 rps = rperstrip;\r\n\t\tunsigned char *buf = img;\r\n\r\n\t\tStripsPerImage =  (img_height + rps - 1) / rps;\r\n\t\tLastStripSize = img_height % rps;\r\n\t\tif (LastStripSize==0)\r\n\t\t\tLastStripSize=rps;\r\n\r\n\t\tfor (int i=0; i < StripsPerImage-1; i++){\r\n\t\t\tTIFFWriteEncodedStrip(output, i, buf, spp * rps * img_width * (bpp/8));\r\n\t\t\tbuf = buf + spp * rps * img_width * (bpp/8);\r\n\t\t}\r\n\r\n\t\tTIFFWriteEncodedStrip(output, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\r\n\t\tbuf = buf + spp * LastStripSize * img_width * (bpp/8);\r\n\t}\r\n\t//img +=  img_width * img_height;\r\n\r\n\tTIFFWriteDirectory(output);\r\n\r\n\tTIFFClose(output);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffAppendData, tf::IO, tf::strprintf(\"appended slice %d x %d to 3D tiff \\\"%s\\\"\", img_width, img_height, filename))\r\n    #endif\r\n\r\n\treturn (char *) 0;\r\n}",
    "char *readTiff3DFile2Buffer ( void *fhandler, unsigned char *img, unsigned int img_width, unsigned int img_height, unsigned int first, unsigned int last, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   int b_swap, int downsamplingFactor, int starti, int endi, int startj, int endj ) {\r\n\tuint32 rps;\r\n    uint16 spp, bpp, orientation, photo, comp, planar_config;\r\n    int check, StripsPerImage,LastStripSize;\r\n\tuint32 XSIZE;\r\n\tuint32 YSIZE;\r\n\r\n    TIFF *input = (TIFF *) fhandler;\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp); \r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Undefined bits per sample.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tif (!check)\r\n\t{\r\n\t\tspp = 1;\r\n\t\t//return ((char *) \"Undefined samples per pixel.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &photo);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Cannot determine photometric interpretation.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_COMPRESSION, &comp);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Cannot determine compression technique.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_PLANARCONFIG, &planar_config);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Cannot determine planar configuration.\");\r\n\t}\r\n\r\n\tstarti = (starti == -1) ? 0 : starti;\r\n\tendi   = (endi == -1) ? img_height-1 : endi;\r\n\tstartj = (startj == -1) ? 0 : startj;\r\n\tendj   = (endj == -1) ? img_width-1 : endj;\r\n\r\n\tcheck=TIFFIsTiled(input);\r\n\tif (check) // file is internally tiled\r\n\t{\r\n\t\tuint32 tilewidth;\r\n\t\tuint32 tilelength;\r\n\t\tuint32 tiledepth;\r\n\t\ttsize_t tilenum;\r\n\t\ttsize_t tilesize;\r\n\t\ttsize_t tilenum_width;\r\n\t\ttsize_t tilenum_length;\r\n\t\tttile_t tile;\r\n\t\ttdata_t data;\r\n\t\tunsigned char *psrc; // pointer in the tile buffer to the top left pixel of the current block to be copied\r\n\t\tunsigned char *pdst; // pointer in the image buffer to the top left pixel of the current block to be filled\r\n\t\tuint32 stride_src;\r\n\t\tuint32 stride_dst;\r\n\t\tint i; // row index in the slice of the top left pixel of the current block to be filled\r\n\t\tint j; // column index in the slice of the top left pixel of the current block to be filled \r\n\t\tuint32 width; // width of the current block to be filled (in pixels)\r\n\t\tuint32 len; // length of the current block to be filled (in pixels)\r\n\t\tint page;\r\n\r\n\t\t// checks\r\n\t\tif ( TIFFGetField(input, TIFFTAG_TILEDEPTH, &tiledepth) )\r\n\t\t\treturn ((char *) \"Tiling among slices (z direction) not supported.\");\r\n\t\tif ( spp > 1 )\r\n\t\t\tif ( TIFFGetField(input, TIFFTAG_PLANARCONFIG, &planar_config) )\r\n\t\t\t\tif ( planar_config > 1 )\r\n\t\t\t\t\treturn ((char *) \"Non-interleaved multiple channels not supported with tiling.\");\r\n\r\n\t\t// tiling is in x,y only\r\n\t\tTIFFGetField(input, TIFFTAG_TILEWIDTH, &tilewidth);\r\n\t\tTIFFGetField(input, TIFFTAG_TILELENGTH, &tilelength);\r\n\t\ttilenum = TIFFNumberOfTiles(input);\r\n\t\ttilesize = TIFFTileSize(input);\r\n\t\ttilenum_width  = (img_width % tilewidth) ? (img_width / tilewidth) + 1 : img_width / tilewidth;\r\n\t\ttilenum_length = (img_height % tilelength) ? (img_height / tilelength) + 1 : img_height / tilelength;\r\n\r\n\t\tdata = new unsigned char[tilesize];\r\n\t\tstride_src = tilewidth * spp; // width of tile (in bytes)\r\n\t\tstride_dst = (endj - startj + 1) * spp; // width of subregion (in bytes)\r\n\r\n\t\tpage = 0;\r\n\t\tdo {\r\n\r\n\t\t\tpsrc = ((unsigned char *)data) + ((starti % tilelength)*tilewidth + (startj % tilewidth)) * spp; // in the first tile skip (starti % tilelength) rows plus (startj % tilewidth) pixels\r\n\t\t\tpdst = img; // the buffer has the size of the subregion\r\n\t\t\tlen = tilelength - (starti % tilelength); // rows to be copied for the first row of tiles \r\n\t\t\ttile = TIFFComputeTile(input,startj,starti,0,0); // index of the first tile to be copied in the current row of tiles\r\n\t\t\tfor ( i=starti; i<=endi; ) {\r\n\t\t\t\twidth = tilewidth - (startj%tilewidth); // width of the first block to be copied/filled\r\n\t\t\t\tfor ( j=startj; j<=endj; ) {\r\n\t\t\t\t\tTIFFReadEncodedTile(input,tile,data,(tsize_t) -1); // read tile into tile buffer\r\n\t\t\t\t\tcopydata (psrc,stride_src,pdst,stride_dst,(width * spp),len); // copy the block \r\n\t\t\t\t\tj += width;\r\n\t\t\t\t\ttile++; // index of the next tile in the same row of tiles\r\n\t\t\t\t\tpsrc = ((unsigned char *)data) + ((i % tilelength)*tilewidth) * spp; // the block in the next tile begins just after (i % tilelength) rows\r\n\t\t\t\t\tpdst += width * spp; // the block in the image buffer move forward of width pixels\r\n\t\t\t\t\twidth = (((tile%tilenum_width) + 1) * tilewidth <= (endj+1)) ? tilewidth : ((endj+1)%tilewidth); // if the next tile in the row is all within the subregion, width is tilewidth otherwise it is shorter\r\n\t\t\t\t}\r\n\t\t\t\ti += len;\r\n\t\t\t\ttile = TIFFComputeTile(input,startj,i,0,0); // index of the first tile to be copied in the current row of tiles\r\n\t\t\t\tpsrc = ((unsigned char *)data) + ((i % tilelength)*tilewidth + (startj % tilewidth)) * spp; // in the first tile of the next row of tiles skip (i % tilelength) rows plus (startj % tilewidth) pixels\r\n\t\t\t\tpdst = img + ((i-starti) * stride_dst); // the block in the image buffer begin after (i-starti) rows\r\n\t\t\t\tlen = (((tile/tilenum_width) + 1) * tilelength <= (endi+1)) ? tilelength : ((endi+1)%tilelength); // if the next row of tiles is all within the subregion, len is tilelength otherwise it is shorter\r\n\t\t\t}\r\n\r\n\t\t\tpage++;\r\n\t\r\n\t\t}while ( page < static_cast<int>(last-first+1) && TIFFReadDirectory(input));\r\n\r\n\t\treturn (char *) 0;\r\n\t}\r\n\r\n\t// 2018-08-22. Giulio. @CHANGED if TIFFTAG_ROWSPERSTRIP is missing it is assumed that all rows are packed into only one strip\r\n\tif ( !TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rps) )\r\n\t\trps = img_height;\t\r\n// \tcheck=TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rps);\r\n// \tif (!check)\r\n// \t{\r\n// \t\treturn ((char *) \"Undefined rows per strip.\");\r\n// \t}\r\n\r\n    \r\n\t//check=TIFFGetField(input, TIFFTAG_ORIENTATION, &orientation); \r\n\t//if (!check)\r\n\t//{\r\n\t//\treturn ((char *) \"Image orientation undefined.\");\r\n\t//}\t\r\n    \r\n\tStripsPerImage =  (img_height + rps - 1) / rps;\r\n\tLastStripSize = img_height % rps;\r\n\tif (LastStripSize==0)\r\n\t\tLastStripSize=rps;\r\n\r\n\tunsigned char *buf = img;\r\n\tint page=0;\r\n\r\n\tif ( downsamplingFactor == 1 ) { // read without downsampling\r\n\r\n\t\tif ( starti < 0 || endi >= img_height || startj < 0 || endj >= img_width || starti >= endi || startj >= endj )\r\n\t\t{\r\n\t\t\treturn ((char *) \"Wrong substack indices.\");\r\n\t\t}\r\n\r\n\t\tif ( starti == 0 && endi == (img_height-1) && startj == 0 && endj == (img_width-1) ) { // read whole images from files \r\n\r\n\t\t\tcheck=TIFFSetDirectory(input, first);\r\n\t\t\tif (!check)\r\n\t\t\t{\r\n\t\t\t\treturn ((char *) \"Cannot open the requested first strip.\");\r\n\t\t\t}\r\n\r\n\t\t\tdo{\r\n\r\n\t\t\t\tfor (int i=0; i < StripsPerImage-1; i++){\r\n\t\t\t\t\tif (comp==1) {\r\n\t\t\t\t\t\tTIFFReadRawStrip(input, i, buf, spp * rps * img_width * (bpp/8));\r\n\t\t\t\t\t\tbuf = buf + spp * rps * img_width * (bpp/8);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tTIFFReadEncodedStrip(input, i, buf, spp * rps * img_width * (bpp/8));\r\n\t\t\t\t\t\tbuf = buf + spp * rps * img_width * (bpp/8);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (comp==1) {\r\n\t\t\t\t\tTIFFReadRawStrip(input, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tTIFFReadEncodedStrip(input, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\r\n\t\t\t\t}\r\n\t\t\t\tbuf = buf + spp * LastStripSize * img_width * (bpp/8);\r\n\r\n\t\t\t\tpage++;\r\n\t\r\n\t\t\t}while ( page < static_cast<int>(last-first+1) && TIFFReadDirectory(input));//while (TIFFReadDirectory(input));\r\n\r\n\t\t}\r\n\t\telse { // read only a subregion of images from files\r\n\r\n\t\t\tcheck=TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &XSIZE);\r\n\t\t\tif (!check)\r\n\t\t\t{\r\n\t\t\t\treturn ((char *) \"Image width of undefined.\");\r\n\t\t\t}\t\t    \r\n\t\t\tcheck=TIFFGetField(input, TIFFTAG_IMAGELENGTH, &YSIZE);\r\n\t\t\tif (!check)\r\n\t\t\t{\r\n\t\t\t\treturn ((char *) \"Image length of undefined.\");\r\n\t\t\t}\r\n\r\n\t\t\tunsigned char *rowbuf = new unsigned char[spp * rps * XSIZE * (bpp/8)];\r\n\t\t\tunsigned char *bufptr;\r\n\r\n\t\t\tdo{\r\n\t\t\t\tcheck=TIFFSetDirectory(input, first + page);\r\n\t\t\t\tif (!check)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn ((char *) \"Cannot open next requested strip.\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tint stripIndex = (starti / rps) - 1; // the strip preceeding the first one\r\n\t\t\t\tfor (int i=starti; i <= endi; i++) {\r\n\t\t\t\t\tif ( floor((double)i / rps) > stripIndex ) { // read a new strip\r\n\t\t\t\t\t\tstripIndex = (int)floor((double)i / rps);\r\n\t\t\t\t\t\tif (comp==1) {\r\n\t\t\t\t\t\t\tTIFFReadRawStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\tTIFFReadEncodedStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbufptr = rowbuf + (i % rps) * (spp * XSIZE * (bpp/8));\r\n\t\t\t\t\tif ( bpp == 8 )\r\n\t\t\t\t\t\tfor (int j=0, j1=startj; j<=(endj-startj); j++, j1++) {\r\n\t\t\t\t\t\t\tfor (int c=0; c<spp; c++) {\r\n\t\t\t\t\t\t\t\tbuf[j * spp + c] = bufptr[j1 * spp + c];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tfor (int j=0 , j1=startj; j<=(endj-startj); j++, j1++) {\r\n\t\t\t\t\t\t\tfor (int c=0; c<spp; c++) {\r\n\t\t\t\t\t\t\t\t((uint16 *)buf)[j * spp + c] = ((uint16 *)bufptr)[j1 * spp + c];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\tbuf = buf + spp * (endj-startj+1) * (bpp/8);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpage++;\r\n\r\n\t\t\t}while ( page < static_cast<int>(last-first+1) );\r\n\r\n\t\t\tdelete []rowbuf;\r\n\r\n\t\t}\r\n\r\n\t\t// input file is assumed to be already open and it is provided as an handler; the file should be closed by caller\r\n\t\t//TIFFClose(input); \r\n\r\n\t\t// 2021. Giulio. The following code seems useless since the condition should be always false\r\n// \t\tif ( page < static_cast<int>(last-first+1) ){\r\n// \t\t\treturn ((char *) \"Cannot read all the pages.\");\r\n// \t\t}\r\n\t}\r\n\telse { // read with downsampling\r\n\r\n\t\t// preliminary checks\r\n\t\tif ( starti != 0 || endi != (img_height-1) || startj != 0 || endj != (img_width-1) ) { // a subregion has been requested \r\n\t\t\treturn ((char *) \"Subregion extraction not supported with downsampling.\");\r\n\t\t}\t\t    \r\n\t\tcheck=TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &XSIZE);\r\n\t\tif (!check)\r\n\t\t{\r\n\t\t\treturn ((char *) \"Image width of undefined.\");\r\n\t\t}\t\t    \r\n\t\tcheck=TIFFGetField(input, TIFFTAG_IMAGELENGTH, &YSIZE);\r\n\t\tif (!check)\r\n\t\t{\r\n\t\t\treturn ((char *) \"Image length of undefined.\");\r\n\t\t}\r\n\r\n\t\tif ( (int)ceil((double)XSIZE/downsamplingFactor) < img_width ) \r\n\t\t{\r\n\t\t\treturn ((char *) \"Requested image width too large.\");\r\n\t\t}\r\n\t\tif ( (int)ceil((double)YSIZE/downsamplingFactor) < img_height ) \r\n\t\t{\r\n\t\t\treturn ((char *) \"Requested image height too large.\");\r\n\t\t}\r\n\r\n\t\tunsigned char *rowbuf = new unsigned char[spp * rps * XSIZE * (bpp/8)];\r\n\t\tunsigned char *bufptr;\r\n\r\n\t\tdo{\r\n\t\t\tcheck=TIFFSetDirectory(input, ((first + page) * downsamplingFactor));\r\n\t\t\tif (!check)\r\n\t\t\t{\r\n\t\t\t\treturn ((char *) \"Cannot open next requested strip.\");\r\n\t\t\t}\r\n\r\n\t\t\tint stripIndex = -1; // the strip preceeding the first one\r\n\t\t\tfor (int i=0; i < img_height; i++) {\r\n\t\t\t\tif ( floor(i * downsamplingFactor / (double)rps) > stripIndex ) { // read a new strip\r\n\t\t\t\t\tstripIndex = (int)floor(i * downsamplingFactor / (double)rps);\r\n\t\t\t\t\tif (comp==1) {\r\n\t\t\t\t\t\tTIFFReadRawStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tTIFFReadEncodedStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbufptr = rowbuf + ((i * downsamplingFactor) % rps) * (spp * XSIZE * (bpp/8));\r\n\t\t\t\tif ( bpp == 8 )\r\n\t\t\t\t\tfor (int j=0; j<img_width; j++) {\r\n\t\t\t\t\t\tfor (int c=0; c<spp; c++) {\r\n\t\t\t\t\t\t\tbuf[j * spp + c] = bufptr[j * spp * downsamplingFactor + c];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tfor (int j=0; j<img_width; j++) {\r\n\t\t\t\t\t\tfor (int c=0; c<spp; c++) {\r\n\t\t\t\t\t\t\t((uint16 *)buf)[j * spp + c] = ((uint16 *)bufptr)[j * spp * downsamplingFactor + c];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\tbuf = buf + spp * img_width * (bpp/8);\r\n\t\t\t}\r\n\r\n\t\t\tpage++;\r\n\r\n\t\t}while ( page < static_cast<int>(last-first+1) );\r\n\r\n\t\tdelete []rowbuf;\r\n\t}\r\n    \r\n\t// swap the data bytes if necessary \t\r\n\tif (b_swap)\r\n\t{\r\n\t\tint i;\r\n\t\tsize_t total = img_width * img_height * spp * (last-first+1);\r\n\t\tif (bpp/8 == 2)\r\n\t\t{\r\n\t\t\tfor (i=0;i<total; i++)\r\n\t\t\t{\r\n                iim::swap2bytes((void *)(img+2*i));\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (bpp/8 == 4)\r\n\t\t{\r\n\t\t\tfor (i=0;i<total; i++)\r\n\t\t\t{\r\n                iim::swap4bytes((void *)(img+4*i));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn (char *) 0;\r\n}",
    "void \r\n\tiomanager::tiff3D::readMetadata(\r\n\tstd::string img_path,\t\t// (INPUT)\timage filepath\r\n\tint & img_width,\t\t\t// (OUTPUT) image width  (in pixels)\r\n\tint & img_height,\t\t\t// (OUTPUT) image height (in pixels)\r\n\tint & img_depth,\t\t\t// (OUTPUT) image depth (in pixels)\r\n\tint & img_bytes_x_chan,\t// (OUTPUT) number of bytes per channel\r\n\tint & img_chans,\t\t\t// (OUTPUT) number of channels\r\n\tconst std::string & params)\t// (INPUT)\tadditional parameters <param1=val, param2=val, ...> \r\nthrow (iom::exception)\r\n{\r\n\t/**/iom::debug(iom::LEV3, iom::strprintf(\"img_path = %s, img_width = %d, img_height = %d, img_depth = %d, img_bytes_x_chan = %d, img_chans = %d, params = \\\"%s\\\"\",\r\n\t\timg_path.c_str(), img_width, img_height, img_depth,\timg_bytes_x_chan, img_chans, params.c_str()).c_str(), __iom__current__function__);\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\tTIFF* input=TIFFOpen(img_path.c_str(),\"r\");\r\n\tif (!input)\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to open image \\\"%s\\\". Possible unsupported format or it isn't an image.\\nSupported format is 3DTIFF\", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &img_width))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGEWIDTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &img_height))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGELENGTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &img_bytes_x_chan))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_BITSPERSAMPLE' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_bytes_x_chan /= 8;\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &img_chans)) \r\n\t\timg_chans = 1;\r\n\t\t//throw iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_SAMPLESPERPIXEL' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\t// Onofri\r\n\tuint16 cpage;  // Current page. We do not actually need it.\r\n\tuint16 npages; // Number of pages. \r\n\tint PNcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &cpage, &npages);\r\n\tif (!PNcheck || npages==0) { // the tag has not been read correctly\r\n\t\t//iom::warning(iom::strprintf(\"unable to determine 'TIFFTAG_PAGENUMBER' from image file \\\"%s\\\". \", img_path.c_str()).c_str(),__iom__current__function__);\r\n\t\timg_depth = 0;\r\n\t\tdo {\r\n\t\t\timg_depth++;\r\n\t\t} while (TIFFReadDirectory(input));\r\n\t}\r\n\telse\r\n\t\timg_depth = npages;\r\n\r\n\tTIFFClose(input);\r\n}",
    "void \r\n\tiomanager::tiff2D::readMetadata(\r\n\tstd::string img_path,\t\t\t// (INPUT)  image filepath\r\n\tint & img_width,\t\t\t\t// (OUTPUT) image width  (in pixels)\r\n\tint & img_height,\t\t\t\t// (OUTPUT) image height (in pixels)\r\n\tint & img_bytes_x_chan,\t\t\t// (OUTPUT) number of bytes per channel\r\n\tint & img_chans,\t\t\t\t// (OUTPUT) number of channels\r\n\tconst std::string & params)\t\t// (INPUT)  additional parameters <param1=val, param2=val, ...> \r\nthrow (iom::exception)\r\n{\r\n\t/**/iom::debug(iom::LEV3, iom::strprintf(\"img_path = \\\"%s\\\", params = \\\"%s\\\"\",img_path.c_str(), params.c_str()).c_str(), __iom__current__function__);\r\n\r\n\tuint16 bpp;\r\n\tuint16 spp;\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\tTIFF* input=TIFFOpen(img_path.c_str(),\"r\");\r\n\tif (!input)\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to open image \\\"%s\\\". Possible unsupported format or it isn't an image.\\nSupported format is 2DTIFF\", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &img_width))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGEWIDTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &img_height))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGELENGTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_BITSPERSAMPLE' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_bytes_x_chan = bpp/8;\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp)) \r\n\t\tspp = 1;\r\n\t\t//throw iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_SAMPLESPERPIXEL' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_chans = spp;\r\n\r\n\t// Onofri\r\n\tint img_depth;\t\t\t// image depth (in pixels)\r\n\tuint16 cpage;  // Current page. We do not actually need it.\r\n\tuint16 npages; // Number of pages. \r\n\tint PNcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &cpage, &npages);\r\n\tif (!PNcheck || npages==0) { // the tag has not been read correctly\r\n\t\t//iom::warning(iom::strprintf(\"unable to determine 'TIFFTAG_PAGENUMBER' from image file \\\"%s\\\". \", img_path.c_str()).c_str(),__iom__current__function__);\r\n\t\timg_depth = 0;\r\n\t\tdo {\r\n\t\t\timg_depth++;\r\n\t\t} while (TIFFReadDirectory(input));\r\n\t}\r\n\telse\r\n\t\timg_depth = npages;\r\n\r\n\tTIFFClose(input);\r\n\t\r\n\t// check the exception after closing the file\r\n\tif ( img_depth > 1 ) \r\n\t\tthrow iom::exception(iom::strprintf(\"image \\\"%s\\\" has more than one page.\\nSupported format is 2DTIFF\", img_path.c_str()), __iom__current__function__);\r\n}",
    "bool Import_3DTiff_Workspace::sizeOfDomain() {\n    uint32 bitsPerSample = 0;\n    uint16 rgb_check;\n\n    TIFF* input_Image;\n    TIFFSetWarningHandler(nullptr);\n    if((input_Image = TIFFOpen(fileName.c_str(), \"r\")) == nullptr){\n        X=-1;\n        return false;\n    }\n\n\n    if(input_Image) {\n        TIFFGetField(input_Image, TIFFTAG_IMAGEWIDTH, &X);\n        TIFFGetField(input_Image, TIFFTAG_IMAGELENGTH, &Y);\n        TIFFGetField(input_Image, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n        TIFFGetField(input_Image, TIFFTAG_SAMPLESPERPIXEL, &rgb_check);\n    }\n\n    if(rgb_check == 3){\n        std::cout << \"Image must be grayscale, input is RGB.\" << std::endl;\n        X=-1;\n        return false;\n    }\n\n    if(bitsPerSample!=8){\n        if(bitsPerSample == 16 || bitsPerSample == 32){\n            std::cout << \"Image must be 8-bit\" << std::endl;\n            X=-1;\n            return false;\n        }\n        else {\n            bitsPerSample = 8;\n        }\n    }\n\n    int page=0;\n    while(true){\n        TIFFSetDirectory(input_Image, page);\n        page++;\n        if(!TIFFReadDirectory(input_Image)) {\n            break;\n        }\n    }\n    Z=page;\n\n    xMin = 0;\n    yMin = 0;\n    zMin = 0;\n    xMax = X-1;\n    yMax = Y-1;\n    zMax = Z-1;\n\n    TIFFClose(input_Image);\n\n    return true;\n}",
    "bool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif.get());\n    if (!tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n            if (!tif)\n                delete buf_helper;\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n        if (tif)\n            m_tif.reset(tif, cv_tiffCloseHandle);\n        else\n            m_tif.release();\n    }\n\n    if (tif)\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &wdth));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hght));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n        {\n            bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n            uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n            if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n            {\n                // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n                bpp = 1;\n            }\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n\n            m_width = wdth;\n            m_height = hght;\n            if (ncn == 3 && photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            uint16 sample_format = SAMPLEFORMAT_UINT;\n            TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sample_format);\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch (bpp)\n            {\n            case 1:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_8S : CV_8U;\n                m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 4:\n                //support 4-bit palette.\n                if (photometric == PHOTOMETRIC_PALETTE)\n                {\n                    CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                    int depth = sample_format == SAMPLEFORMAT_INT ? CV_8S : CV_8U;\n                    m_type = CV_MAKETYPE(depth, 3);\n                    result = true;\n                }\n                else\n                    CV_Error(cv::Error::StsError, \"bitsperpixel value is 4 should be palette.\");\n                break;\n            case 8:\n            {\n                //Palette color, the value of the component is used as an index into the red,\n                //green and blue curves in the ColorMap field to retrieve an RGB triplet that defines the color.\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_8S : CV_8U;\n                if (photometric == PHOTOMETRIC_PALETTE)\n                    m_type = CV_MAKETYPE(depth, 3);\n                else\n                    m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 10:\n            case 12:\n            case 14:\n            case 16:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_16S : CV_16U;\n                m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 32:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_IEEEFP || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_IEEEFP ? CV_32F : CV_32S;\n                m_type = CV_MAKETYPE(depth, wanted_channels);\n                result = true;\n                break;\n            }\n            case 64:\n                CV_CheckEQ((int)sample_format, SAMPLEFORMAT_IEEEFP, \"\");\n                m_type = CV_MAKETYPE(CV_64F, wanted_channels);\n                result = true;\n                break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 10, 12, 14, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16 photometric = (uint16)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n        if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n        {\n            // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n            bpp = 1;\n        }\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        constexpr const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if (dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if (!TIFFRGBAImageOK(tif, errmsg))\n            {\n                CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                close();\n                return false;\n            }\n        }\n\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n            CV_Assert(((uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte)) < MAX_TILE_SIZE) && \"TIFF tile size is too large: >= 1Gb\");\n\n            if (dst_bpp == 8)\n            {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n            const size_t src_buffer_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_size = tile_height0 * src_buffer_bytes_per_row;\n            const size_t src_buffer_unpacked_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * dst_bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_unpacked_size = tile_height0 * src_buffer_unpacked_bytes_per_row;\n            const bool needsUnpacking = (bpp < dst_bpp);\n            AutoBuffer<uchar> _src_buffer(src_buffer_size);\n            uchar* src_buffer = _src_buffer.data();\n            AutoBuffer<uchar> _src_buffer_unpacked(needsUnpacking ? src_buffer_unpacked_size : 0);\n            uchar* src_buffer_unpacked = needsUnpacking ? _src_buffer_unpacked.data() : nullptr;\n            int tileidx = 0;\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = src_buffer;\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32*)src_buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)src_buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32*)src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32*)src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                ushort* buffer16 = (ushort*)(src_buffer+i*src_buffer_bytes_per_row);\n                                if (needsUnpacking)\n                                {\n                                    const uchar* src_packed = src_buffer+i*src_buffer_bytes_per_row;\n                                    uchar* dst_unpacked = src_buffer_unpacked+i*src_buffer_unpacked_bytes_per_row;\n                                    if (bpp == 10)\n                                        _unpack10To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 12)\n                                        _unpack12To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 14)\n                                        _unpack14To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    buffer16 = (ushort*)dst_unpacked;\n                                }\n\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy(img.ptr<ushort>(img_y + i, x),\n                                               buffer16,\n                                               tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? (depth == CV_32S ? CV_32S : CV_32F) : CV_64F, ncn), src_buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        if (bpp < dst_bpp)\n          img *= (1<<(dst_bpp-bpp));\n        fixOrientation(img, img_orientation, dst_bpp);\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}",
    "FXbool fxloadTIF(FXStream& store,FXColor*& data,FXint& width,FXint& height,FXushort& codec){\n  tiff_store_handle s_handle;\n  FXuval size,s;\n\n  // Null out\n  data=nullptr;\n  width=0;\n  height=0;\n\n  // Set error/warning handlers\n  TIFFSetErrorHandler(nullptr);\n  TIFFSetWarningHandler(nullptr);\n\n  // Initialize\n  s_handle.store=&store;\n  s_handle.begin=store.position();\n  s_handle.end=store.position();\n\n  FXTRACE((100,\"fxloadTIF\\n\"));\n\n  // Open image\n  TIFF* image=TIFFClientOpen(\"tiff\",\"rm\",(thandle_t)&s_handle,tif_read_store,tif_write_store,tif_seek_store,tif_close_store,tif_size_store,nullptr,nullptr);\n  if(image){\n\n    // Get sizes\n    TIFFGetField(image,TIFFTAG_IMAGEWIDTH,&width);\n    TIFFGetField(image,TIFFTAG_IMAGELENGTH,&height);\n    TIFFGetField(image,TIFFTAG_COMPRESSION,&codec);\n\n    FXTRACE((100,\"fxloadTIF: width=%d height=%d codec=%d\\n\",width,height,codec));\n\n    // Make room for data\n    size=width*height;\n    if(allocElms(data,size)){\n      if(TIFFReadRGBAImageOriented(image,width,height,data,ORIENTATION_TOPLEFT,0)){\n        for(s=0; s<size; s++){\n          data[s]=((data[s]&0xff)<<16)|((data[s]&0xff0000)>>16)|(data[s]&0xff00)|(data[s]&0xff000000);\n          }\n        TIFFClose(image);\n        return true;\n        }\n      freeElms(data);\n      }\n    TIFFClose(image);\n    }\n  return false;\n  }",
    "FXbool fxloadTIF__(FXStream& store,FXColor*& data,FXint& width,FXint& height,FXushort& codec){\n  tiff_store_handle s_handle;\n  FXbool result=false;\n  TIFF* image;\n\n  // Null out\n  data=nullptr;\n  width=0;\n  height=0;\n  codec=0;\n\n  // Set error/warning handlers\n  TIFFSetErrorHandler(nullptr);\n  TIFFSetWarningHandler(nullptr);\n\n  // Initialize\n  s_handle.store=&store;\n  s_handle.begin=store.position();\n  s_handle.end=store.position();\n\n  FXTRACE((100,\"fxloadGEOTIF\\n\"));\n\n  // Open image\n  if((image=TIFFClientOpen(\"tiff\",\"rm\",(thandle_t)&s_handle,tif_read_store,tif_write_store,tif_seek_store,tif_close_store,tif_size_store,nullptr,nullptr))!=nullptr){\n    FXushort samples=0;\n    FXushort samplebits=0;\n    FXushort format=0;\n    FXuint   scanlinesize;\n    FXuchar *scanline;\n\n    // Get size\n    TIFFGetField(image,TIFFTAG_IMAGEWIDTH,&width);\n    TIFFGetField(image,TIFFTAG_IMAGELENGTH,&height);\n    TIFFGetField(image,TIFFTAG_SAMPLESPERPIXEL,&samples);\n    TIFFGetField(image,TIFFTAG_BITSPERSAMPLE,&samplebits);\n    TIFFGetField(image,TIFFTAG_SAMPLEFORMAT,&format);\n\n    // We try to remember the codec for later when we save the image back out...\n    TIFFGetField(image,TIFFTAG_COMPRESSION,&codec);\n\n    // Get line size (bytes)\n    scanlinesize=TIFFScanlineSize(image);\n\n    // Show image configuration\n    FXTRACE((100,\"width=%d height=%d codec=%u samples=%u samplebits=%u format=%u scanlinesize=%u\\n\",width,height,codec,samples,samplebits,format,scanlinesize));\n\n    // Supported formats\n    if((format==SAMPLEFORMAT_UINT || format==SAMPLEFORMAT_INT || format==SAMPLEFORMAT_IEEEFP) && (samples==1 || samples==3)){\n\n      // Allocate scanline buffer\n      if(callocElms(scanline,scanlinesize)){\n\n        // Make room for data\n        if(callocElms(data,width*height)){\n\n/*\n\n    FXuint nPlanarConfig=0;\n    FXuint nCompressFlag=0;\n    FXuint nPhotometric=0;\n\n\n\n\n    TIFFGetField(image,TIFFTAG_PLANARCONFIG,&nPlanarConfig);\n    TIFFGetField(image,TIFFTAG_COMPRESSION,&nCompressFlag);\n    TIFFGetField(image,TIFFTAG_PHOTOMETRIC,&nPhotometric);\n\n    FXTRACE((100,\"nPlanarConfig=%u\\n\",nPlanarConfig));\n    FXTRACE((100,\"nCompressFlag=%u\\n\",nCompressFlag));\n    FXTRACE((100,\"nPhotometric=%u\\n\",nPhotometric));\n\n    switch(nSampleFormat){\n      case SAMPLEFORMAT_UINT:\n        break;\n      case SAMPLEFORMAT_INT:\n        break;\n      case SAMPLEFORMAT_IEEEFP:\n        break;\n      case SAMPLEFORMAT_VOID:\n        break;\n      case SAMPLEFORMAT_COMPLEXINT:\n        break;\n      case SAMPLEFORMAT_COMPLEXIEEEFP:\n        break;\n      default:\n        break;\n      }\n*/\n\n          // Read lines\n          for(FXint y=0; y<height; ++y){\n            TIFFReadScanline(image,scanline,y,0);\n\n            if(samples==3){\n              if(samplebits==8){\n                for(FXint x=0; x<width; ++x){\n                  ((FXuchar*)&data[y*width+x])[0]=scanline[3*x+2];        // Blue\n                  ((FXuchar*)&data[y*width+x])[1]=scanline[3*x+1];        // Green\n                  ((FXuchar*)&data[y*width+x])[2]=scanline[3*x+0];        // Red\n                  ((FXuchar*)&data[y*width+x])[3]=255;                    // Alpha\n                  }\n                }\n              else if(samplebits==16){\n                for(FXint x=0; x<width; ++x){\n                  ((FXuchar*)&data[y*width+x])[0]=((FXushort*)scanline)[3*x+2]/257;\n                  ((FXuchar*)&data[y*width+x])[1]=((FXushort*)scanline)[3*x+1]/257;\n                  ((FXuchar*)&data[y*width+x])[2]=((FXushort*)scanline)[3*x+0]/257;\n                  ((FXuchar*)&data[y*width+x])[3]=255;\n                  }\n                }\n              }\n            else{\n              if(samplebits==8){\n                for(FXint x=0; x<width; ++x){\n                  ((FXuchar*)&data[y*width+x])[0]=scanline[x];          // Blue\n                  ((FXuchar*)&data[y*width+x])[1]=scanline[x];          // Green\n                  ((FXuchar*)&data[y*width+x])[2]=scanline[x];          // Red\n                  ((FXuchar*)&data[y*width+x])[3]=255;                  // Alpha\n                  }\n                }\n              else if(samplebits==16){\n                for(FXint x=0; x<width; ++x){\n                  ((FXuchar*)&data[y*width+x])[0]=((FXushort*)scanline)[x]/257;\n                  ((FXuchar*)&data[y*width+x])[1]=((FXushort*)scanline)[x]/257;\n                  ((FXuchar*)&data[y*width+x])[2]=((FXushort*)scanline)[x]/257;\n                  ((FXuchar*)&data[y*width+x])[3]=255;\n                  }\n                }\n              }\n            }\n\n          // Got as far as this if success\n          result=true;\n          }\n        }\n      freeElms(scanline);\n      }\n    TIFFClose(image);\n    }\n  return result;\n  }",
    "bool Image::LoadTIFFImage(Stream::IStream& stream)\r\n{\r\n\tbool result = false;\r\n\tTIFFStreamManager manager(stream);\r\n\tTIFF* tif = manager.Open(\"Test\", \"r\");\r\n\tif (tif != 0)\r\n\t{\r\n\t\tuint32 newImageWidth;\r\n\t\tuint32 newImageHeight;\r\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &newImageWidth);\r\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &newImageHeight);\r\n\r\n\t\tunsigned int pixelCount = (unsigned int)(newImageWidth * newImageHeight);\r\n\t\tuint32* rawPixelData = new uint32[pixelCount];\r\n\t\tif (TIFFReadRGBAImage(tif, newImageWidth, newImageHeight, rawPixelData, 0) != 0)\r\n\t\t{\r\n\t\t\t// Apply the new image format\r\n\t\t\tSetImageFormat(newImageWidth, newImageHeight, PIXELFORMAT_RGBA, DATAFORMAT_8BIT);\r\n\r\n\t\t\t// Decode the image data\r\n\t\t\tfor (unsigned int ypos = 0; ypos < _imageHeight; ++ypos)\r\n\t\t\t{\r\n\t\t\t\tunsigned int writeYPos = ((_imageHeight - 1) - ypos);\r\n\t\t\t\tfor (unsigned int xpos = 0; xpos < _imageWidth; ++xpos)\r\n\t\t\t\t{\r\n\t\t\t\t\tuint32 pixel = rawPixelData[(ypos * _imageWidth) + xpos];\r\n\t\t\t\t\tunsigned char r = (unsigned char)TIFFGetR(pixel);\r\n\t\t\t\t\tunsigned char g = (unsigned char)TIFFGetG(pixel);\r\n\t\t\t\t\tunsigned char b = (unsigned char)TIFFGetB(pixel);\r\n\t\t\t\t\tunsigned char a = (unsigned char)TIFFGetA(pixel);\r\n\t\t\t\t\tWritePixelDataInternal(xpos, writeYPos, 0, r);\r\n\t\t\t\t\tWritePixelDataInternal(xpos, writeYPos, 1, g);\r\n\t\t\t\t\tWritePixelDataInternal(xpos, writeYPos, 2, b);\r\n\t\t\t\t\tWritePixelDataInternal(xpos, writeYPos, 3, a);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tresult = true;\r\n\t\t}\r\n\t\tdelete[] rawPixelData;\r\n\t}\r\n\r\n\treturn result;\r\n}",
    "std::unique_ptr<Image> TifFormat::loadFromFile(const std::string &name, const Image::Optimization &optimization, const ColorSpace &color_space, float gamma)\n{\n#if defined(_WIN32)\n\tstd::wstring wname = string::utf8ToWutf16Le(name);\n\tlibtiff::TIFF *tif = libtiff::TIFFOpenW(wname.c_str(), \"r\");\t//Windows needs the path in UTF16LE (unicode, UTF16, little endian) so we have to convert the UTF8 path to UTF16\n#else\n\tlibtiff::TIFF *tif = libtiff::TIFFOpen(name.c_str(), \"r\");\n#endif\n\tif(!tif)\n\t{\n\t\tlogger_.logError(getFormatName(), \": Cannot open file \", name);\n\t\treturn nullptr;\n\t}\n\tlogger_.logInfo(getFormatName(), \": Loading image \\\"\", name, \"\\\"...\");\n\tuint32_t w, h;\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\tauto *tiff_data = static_cast<uint32_t *>(libtiff::_TIFFmalloc(w * h * sizeof(uint32_t)));\n\tif(!libtiff::TIFFReadRGBAImage(tif, w, h, tiff_data, 0))\n\t{\n\t\tlogger_.logError(getFormatName(), \": Error reading TIFF file\");\n\t\treturn nullptr;\n\t}\n\tImage::Params image_params;\n\timage_params.width_ = static_cast<int>(w);\n\timage_params.height_ = static_cast<int>(h);\n\timage_params.type_ = Image::getTypeFromSettings(true, grayscale_);\n\timage_params.image_optimization_ = optimization;\n\timage_params.filename_ = name;\n\tauto image = Image::factory(image_params);\n\tint i = 0;\n\tfor(int y = static_cast<int>(h) - 1; y >= 0; y--)\n\t{\n\t\tfor(int x = 0; x < static_cast<int>(w); x++)\n\t\t{\n\t\t\tRgba color;\n\t\t\tcolor.set((float)TIFFGetR(tiff_data[i]) * inv_max_8_bit_,\n\t\t\t\t\t  (float)TIFFGetG(tiff_data[i]) * inv_max_8_bit_,\n\t\t\t\t\t  (float)TIFFGetB(tiff_data[i]) * inv_max_8_bit_,\n\t\t\t\t\t  (float)TIFFGetA(tiff_data[i]) * inv_max_8_bit_);\n\t\t\tcolor.linearRgbFromColorSpace(color_space, gamma);\n\t\t\timage->setColor({{x, y}}, color);\n\t\t\t++i;\n\t\t}\n\t}\n\tlibtiff::_TIFFfree(tiff_data);\n\tlibtiff::TIFFClose(tif);\n\tif(logger_.isVerbose()) logger_.logVerbose(getFormatName(), \": Done.\");\n\treturn image;\n}",
    "RasterPage* GeoTiffPager::getPage(DataRequest *pOriginalRequest,\n      DimensionDescriptor startRow, \n      DimensionDescriptor startColumn, \n      DimensionDescriptor startBand)\n{\n   if (pOriginalRequest == NULL)\n   {\n      return NULL;\n   }\n\n   if (pOriginalRequest->getWritable())\n   {\n      return NULL;\n   }\n\n   GeoTiffPage* pPage(NULL);\n\n   // ensure only one thread enters this code at a time\n   mta::MutexLock lock(mMutex);\n\n   // we wrap all this in a try/catch so we can have one exit point\n   // and ensure that the mutex gets unlocked on an error\n   try\n   {\n      unsigned int concurrentRows = pOriginalRequest->getConcurrentRows();\n      unsigned int concurrentColumns = pOriginalRequest->getConcurrentColumns();\n      unsigned int concurrentBands = pOriginalRequest->getConcurrentBands();\n\n      unsigned int rowNumber = startRow.getOnDiskNumber();\n      unsigned int colNumber = startColumn.getOnDiskNumber();\n      unsigned int bandNumber = startBand.getOnDiskNumber();\n\n      // make sure the request is valid\n      if ((rowNumber >= mRowCount) || ((rowNumber + concurrentRows) > mRowCount) ||\n         (colNumber >= mColumnCount) || ((colNumber + concurrentColumns) > mColumnCount) ||\n         (bandNumber >= mBandCount) || ((bandNumber + concurrentBands) > mBandCount))\n      {\n         // Since it is acceptable to increment off the end of the data, do not report an error message\n         throw string();\n      }\n\n      if ((mInterleave == BSQ) && (concurrentBands != 1))\n      {\n         throw string(\"BSQ data can only be accessed one band at a time.\");\n      }\n\n      /**\n       * possibilities for load\n       *\n       * BIP with strips\n       *     with tiles\n       * BSQ with strips\n       *     with tiles\n       **/\n\n      if (TIFFIsTiled(mpTiff) == 0)\n      {\n         // the data are stored as strips\n         tsize_t stripSize(TIFFStripSize(mpTiff)); // columns * bands * rows in a strip (bands=1 for BSQ)\n         if (stripSize <= 0)\n         {\n            throw string(\"TIFF file error. Strip size <= 0.\");\n         }\n\n         // Load in a data block and create a GeoTiffPage for the data.\n         // we do this reasonably efficiently by loading complete strips even\n         // if that means loading more data than needed\n\n         // how many strips should we load?\n         // find the strip that our data block begins in\n         // then find the strip that our concurrent data ends in\n         tstrip_t startStrip(TIFFComputeStrip(mpTiff, rowNumber, static_cast<tsample_t>(bandNumber)));\n         tstrip_t endStrip(TIFFComputeStrip(mpTiff, (rowNumber + concurrentRows) - 1, static_cast<tsample_t>(bandNumber)));\n\n         // if this data block is already in the cache, retrieve it...otherwise create a new block\n         GeoTiffOnDisk::CacheUnit* pCacheUnit(mBlockCache.getCacheUnit(startStrip, endStrip, stripSize));\n         if (pCacheUnit == NULL)\n         {\n            throw string(\"Can't create a cache unit\");\n         }\n         if (mInterleave == BIP)\n         {\n            float rowsPerStrip(static_cast<float>(stripSize / mColumnCount) / static_cast<float>(mBandCount) /\n               static_cast<float>(mBytesPerElement));\n            if (rowsPerStrip < 1.0)\n            {\n               pPage = new GeoTiffPage(pCacheUnit, 0 + (rowNumber * mBandCount * mBytesPerElement) +\n                                                           (bandNumber * mBytesPerElement),\n                                                           0, 0, 0);\n            }\n            else\n            {\n               const unsigned int uiRowsPerStrip = static_cast<unsigned int>(rowsPerStrip);\n               const unsigned int numRowsOffset = rowNumber % uiRowsPerStrip;\n               const unsigned int numRowsAvailable = (uiRowsPerStrip * (endStrip - startStrip + 1)) - numRowsOffset;\n               pPage = new GeoTiffPage(pCacheUnit,\n                           (numRowsOffset * mColumnCount * mBandCount * mBytesPerElement) +\n                           (colNumber * mBandCount * mBytesPerElement) + (bandNumber * mBytesPerElement),\n                           numRowsAvailable, 0, 0);\n            }\n         }\n         else if (mInterleave == BSQ)\n         {\n            float rowsPerStrip(static_cast<float>(stripSize / mColumnCount) / static_cast<float>(mBytesPerElement));\n            if (rowsPerStrip < 1.0)\n            {\n               pPage = new GeoTiffPage(pCacheUnit, 0 + colNumber * mBytesPerElement, 0, 0, 0);\n            }\n            else\n            {\n               const unsigned int uiRowsPerStrip = static_cast<unsigned int>(rowsPerStrip);\n               const unsigned int numRowsOffset = rowNumber % uiRowsPerStrip;\n               const unsigned int numRowsAvailable = (uiRowsPerStrip * (endStrip - startStrip + 1)) - numRowsOffset;\n               pPage = new GeoTiffPage(pCacheUnit,\n                  (numRowsOffset * mColumnCount * mBytesPerElement) + (colNumber * mBytesPerElement),\n                  numRowsAvailable, 0, 0);\n            }\n         }\n\n         if (pPage == NULL)\n         {\n            throw string(\"Can't create a data block\");\n         }\n         if (pCacheUnit->isEmpty())\n         {\n            // we need to load this block\n            char* pData(pCacheUnit->data());\n            if (pData == NULL)\n            {\n               throw string(\"Data block has no data\");\n            }\n            // read in the strips\n            char* pBlockPos(pData);\n            for (tstrip_t curStrip = startStrip; curStrip <= endStrip; curStrip++)\n            {\n               tsize_t bytesRead = TIFFReadEncodedStrip(mpTiff, curStrip, pBlockPos, -1);\n               if (bytesRead == -1)\n               {\n                  throw string(\"Error reading TIFF data\");\n               }\n               pBlockPos += bytesRead;\n            }\n\n            pCacheUnit->setIsEmpty(false);\n         }\n      }\n      else\n      {\n         // The number of pixels in each tile from left to right\n         uint32 tileWidth;\n         if (TIFFGetField(mpTiff, TIFFTAG_TILEWIDTH, &tileWidth) == 0 || tileWidth == 0)\n         {\n            throw string(\"Cannot determine tileWidth\");\n         }\n\n         // The number of pixels in each tile from top to bottom\n         uint32 tileLength;\n         if (TIFFGetField(mpTiff, TIFFTAG_TILELENGTH, &tileLength) == 0 || tileLength == 0)\n         {\n            throw string(\"Cannot determine tileLength\");\n         }\n\n         // The number of bytes in each tile\n         const tsize_t tileSize(TIFFTileSize(mpTiff));\n         if (tileSize <= 0)\n         {\n            throw string(\"Cannot determine tileSize\");\n         }\n\n         // Compute the first and last tile to load.\n         // This should ideally use TIFFComputeTile, but there are problems\n         // in that method (as of libtiff 3.8.1) so compute them manually here.\n\n         // The number of tiles from left to right\n         const uint32 tilesAcross((mColumnCount + tileWidth - 1) / tileWidth);\n         if (tilesAcross == 0)\n         {\n            throw string(\"Cannot determine tilesAcross\");\n         }\n\n         // The number of tiles from top to bottom\n         const uint32 tilesDown((mRowCount + tileLength - 1) / tileLength);\n         if (tilesDown == 0)\n         {\n            throw string(\"Cannot determine tilesDown\");\n         }\n\n         // The offset to the first tile in the requested band\n         // BIP: Tiles contain all bands, so this is 0\n         // BSQ: Tiles contain a single band, so this is number of tiles per band * bandNumber\n         // This is stated in the TIFF 6.0 spec on page 68 (in the TileOffsets definition)\n         const uint32 tileOffset(mInterleave == BIP ? 0 : bandNumber * tilesAcross * tilesDown);\n\n         // The 0-based index of the first desired tile\n         const ttile_t startTileIndex(rowNumber / tileLength);\n\n         // The tile containing the first column of the first requested row\n         const ttile_t startTile(tileOffset + startTileIndex * tilesAcross);\n         if (startTile < 0)\n         {\n            throw string(\"Cannot determine startTile\");\n         }\n\n         // The 0-based index of the last desired tile\n         const ttile_t endTileIndex((rowNumber + concurrentRows - 1) / tileLength);\n\n         // The tile containing the last column of the last requested row\n         const ttile_t endTile(tileOffset + endTileIndex * tilesAcross + tilesAcross - 1);\n         if (endTile < 0)\n         {\n            throw string(\"Cannot determine endTile\");\n         }\n\n         // Retrieve a block from the cache\n         GeoTiffOnDisk::CacheUnit* pCacheUnit(mBlockCache.getCacheUnit(startTile, endTile, tileSize));\n         if (pCacheUnit == NULL)\n         {\n            throw string(\"Cannot create a cache unit\");\n         }\n\n         // The number of bands in pPage\n         const unsigned int bandSkip(mInterleave == BIP ? mBandCount : 1);\n\n         // The number of columns in pPage\n         const unsigned int columnSkip(mColumnCount);\n\n         // The offset of the first requested data within pPage\n         const size_t offset(mBytesPerElement *\n            ((rowNumber % tileLength) * columnSkip * bandSkip + (mInterleave == BSQ ? 0 : bandNumber)));\n\n         // The number of rows in pPage\n         const unsigned int rowSkip(tileLength * ((endTile - startTile + 1) / tilesAcross));\n\n         // Create a GeoTiffPage based on the computed values\n         pPage = new GeoTiffPage(pCacheUnit, offset, rowSkip, columnSkip, bandSkip);\n         if (pCacheUnit->isEmpty())\n         {\n            // Temporary storage for the working tile\n            vector<unsigned char> tileData(tileSize);\n            for (ttile_t curTile = startTile, tileNum = 0; curTile <= endTile; ++curTile, ++tileNum)\n            {\n               if (TIFFReadEncodedTile(mpTiff, curTile, &tileData[0], tileSize) != tileSize)\n               {\n                  throw string(\"Error reading TIFF data\");\n               }\n\n               // The starting address of this tile within pPage\n               char* pBlockPos(pCacheUnit->data());\n\n               // Increment by one or more rows of tiles\n               pBlockPos += tileSize * tilesAcross * bandSkip * mBytesPerElement * (tileNum / tilesAcross);\n\n               // Increment by one or more tiles within a row\n               pBlockPos += tileWidth * bandSkip * mBytesPerElement * (tileNum % tilesAcross);\n\n               // The number of bytes to copy - this might be different for partial tiles (e.g.: at the end of a row)\n               size_t numBytesToCopy = tileWidth;\n               if ((tileNum + 1) % tilesAcross == 0 && mColumnCount % tileWidth != 0)\n               {\n                  numBytesToCopy = mColumnCount % tileWidth;\n               }\n\n               numBytesToCopy *= bandSkip * mBytesPerElement;\n               for (uint32 row = 0; row < tileLength; ++row)\n               {\n                  const size_t rowOffset = row * mColumnCount * bandSkip * mBytesPerElement;\n                  const size_t tileOffset2 = row * tileWidth * bandSkip * mBytesPerElement;\n                  memcpy(pBlockPos + rowOffset, &tileData[tileOffset2], numBytesToCopy);\n               }\n            }\n\n            pCacheUnit->setIsEmpty(false);\n         }\n      }\n   }\n   catch (const string& exc)\n   {\n      delete pPage;\n      pPage = NULL;\n      if (exc.empty() == false)\n      {\n         MessageResource pMsg(\"GeoTIFF Pager Error\", \"app\", \"71B84E03-6AF1-4971-9F83-69E3C8BC6BF3\");\n         pMsg->addProperty(\"Message\", exc);\n      }\n   }\n\n   return pPage;\n}",
    "bool populateStaticTagMetadata(TIFF* pTiffFile, ttag_t tag,\n      const uint32 count, DynamicObject* pMetadata, string& message)\n   {\n      VERIFY(pTiffFile != NULL && count > 0 && pMetadata != NULL);\n      const TIFFField* pFieldInfo = TIFFFieldWithTag(pTiffFile, tag);\n      VERIFY(pFieldInfo != NULL);\n\n      vector<T> values(count);\n      if (TIFFGetField(pTiffFile, TIFFFieldTag(pFieldInfo), &values[0]) == 0)\n      {\n         // The tag was not present in the file\n         return false;\n      }\n\n      // Must call the templated version because some fields are internally inconsistent within libtiff\n      // e.g.: TIFFTAG_BITSPERSAMPLE can be TIFF_LONG according to tif_dirinfo.c yet is used as a uint16 in tif_dir.c\n      // While it is inefficient to make multiple copies of the vector, this code is only reached by static,\n      // non-pointer tags which typically have no more than 2 elements.\n      if (setMetadata<T>(TIFFFieldName(pFieldInfo), count, &values[0], pMetadata) == false)\n      {\n         message += \"Error processing \" + string(TIFFFieldName(pFieldInfo)) + \"\\n\";\n         return false;\n      }\n\n      return true;\n   }",
    "bool populateStaticTagMetadataArray1D(TIFF* pTiffFile, ttag_t tag,\n      uint32 count, DynamicObject* pMetadata, string& message)\n   {\n      VERIFY(pTiffFile != NULL && pMetadata != NULL);\n\n      const TIFFField* pFieldInfo = TIFFFieldWithTag(pTiffFile, tag);\n      VERIFY(pFieldInfo != NULL);\n\n      T* pValue = NULL;\n      if (count == 0)\n      {\n         // Special case\n         // The only fields that need this are TIFFTAG_EXTRASAMPLES and TIFFTAG_SUBIFD (tif_dir.c:747, 782)\n         // Both of these fields use a uint16 to store the count, so create a temporary uint16\n         uint16 count16 = 0;\n         if (TIFFGetField(pTiffFile, TIFFFieldTag(pFieldInfo), &count16, &pValue) == 0)\n         {\n            // The tag was not present in the file\n            return false;\n         }\n\n         count = static_cast<uint32>(count16);\n      }\n      else\n      {\n         if (TIFFGetField(pTiffFile, TIFFFieldTag(pFieldInfo), &pValue) == 0)\n         {\n            // The tag was not present in the file\n            return false;\n         }\n      }\n\n      VERIFY(pValue != NULL && count > 0);\n\n      // Must call the templated version because values must be copied into a vector to be stored in a DataVariant\n      if (setMetadata<T>(TIFFFieldName(pFieldInfo), count, pValue, pMetadata) == false)\n      {\n         message += \"Error processing \" + string(TIFFFieldName(pFieldInfo)) + \"\\n\";\n         return false;\n      }\n\n      return true;\n   }",
    "bool populateStaticTagMetadataArray2D(TIFF* pTiffFile, ttag_t tag,\n      const uint32 count, DynamicObject* pMetadata, string& message)\n   {\n      VERIFY(pTiffFile != NULL && count != 0 && pMetadata != NULL);\n      const TIFFField* pFieldInfo = TIFFFieldWithTag(pTiffFile, tag);\n      VERIFY(pFieldInfo != NULL);\n\n      // TIFFTAG_COLORMAP and TIFFTAG_TRANSFERFUNCTION have up to 3 children\n      vector<T*> values(3, NULL);\n      if (TIFFGetField(pTiffFile, TIFFFieldTag(pFieldInfo), &values[0], &values[1], &values[2]) == 0)\n      {\n         // The tag was not present in the file\n         return false;\n      }\n\n      for (uint32 i = 0; i < values.size() && values[i] != NULL; ++i)\n      {\n         // Must call the templated version because values must be copied into a vector to be stored in a DataVariant\n         if (setMetadata<T>((QString(TIFFFieldName(pFieldInfo)) + QString(\"-%1\").arg(i)).toStdString(),\n            count, values[i], pMetadata) == false)\n         {\n            message += \"Error processing \" + string(TIFFFieldName(pFieldInfo)) + \"\\n\";\n            return false;\n         }\n      }\n\n      return true;\n   }",
    "bool populateCustomTagMetadata(TIFF* pTiffFile, ttag_t tag, DynamicObject* pMetadata, string& message)\n   {\n      VERIFY(pTiffFile != NULL && pMetadata != NULL);\n\n      const TIFFField* pFieldInfo = TIFFFieldWithTag(pTiffFile, tag);\n      VERIFY(pFieldInfo != NULL);\n\n      uint32 count = 0;\n      void* pValues = NULL;\n      if (TIFFFieldPassCount(pFieldInfo))\n      {\n         // Special case\n         // Use either a uint16* or uint32* based on field_readcount as is done in tif_dir.c:837\n         void* pCount = &count;\n         uint16 count16 = 0;\n         if (TIFFFieldReadCount(pFieldInfo) != TIFF_VARIABLE2)\n         {\n            pCount = &count16;\n         }\n\n         if (TIFFGetField(pTiffFile, TIFFFieldTag(pFieldInfo), pCount, &pValues) == 0)\n         {\n            // The tag was not present in the file even though libtiff earlier said it was present\n            message += \"Unable to retrieve information for \" + string(TIFFFieldName(pFieldInfo)) + \"\\n\";\n            return false;\n         }\n\n         if (TIFFFieldReadCount(pFieldInfo) != TIFF_VARIABLE2)\n         {\n            count = count16;\n         }\n      }\n      else\n      {\n         // Special case\n         // TIFFTAG_DOTRANGE requires either 2 or N arguments\n         // Since it cannot be known how many arguments to send, display a warning\n         if (TIFFFieldTag(pFieldInfo) == TIFFTAG_DOTRANGE)\n         {\n            message += \"Custom field \" + string(TIFFFieldName(pFieldInfo)) + \" is not supported.\\n\";\n            return false;\n         }\n\n         // The data types in this switch must match the ones in tif_dir.c:861\n         switch (TIFFFieldDataType(pFieldInfo))\n         {\n            case TIFF_ASCII:\n            {\n               // Special case\n               // Make this appear as a string rather than a vector<char>\n               count = 1;\n               if (TIFFGetField(pTiffFile, TIFFFieldTag(pFieldInfo), &pValues) == 0)\n               {\n                  return false;\n               }\n\n               break;\n            }\n\n            case TIFF_BYTE:   // Fall through\n            case TIFF_UNDEFINED:\n            {\n               return populateStaticTagMetadata<uint8>(pTiffFile, tag,\n                   TIFFFieldReadCount(pFieldInfo), pMetadata, message);\n            }\n\n            case TIFF_SBYTE:\n            {\n               return populateStaticTagMetadata<int8>(pTiffFile, tag,\n                   TIFFFieldReadCount(pFieldInfo), pMetadata, message);\n            }\n\n            case TIFF_SHORT:\n            {\n               return populateStaticTagMetadata<uint16>(pTiffFile, tag,\n                   TIFFFieldReadCount(pFieldInfo), pMetadata, message);\n            }\n\n            case TIFF_SSHORT:\n            {\n               return populateStaticTagMetadata<int16>(pTiffFile, tag,\n                   TIFFFieldReadCount(pFieldInfo), pMetadata, message);\n            }\n\n            case TIFF_LONG:   // Fall through\n            case TIFF_IFD:\n            {\n               return populateStaticTagMetadata<uint32>(pTiffFile, tag,\n                   TIFFFieldReadCount(pFieldInfo), pMetadata, message);\n            }\n\n            case TIFF_SLONG:\n            {\n               return populateStaticTagMetadata<int32>(pTiffFile, tag,\n                   TIFFFieldReadCount(pFieldInfo), pMetadata, message);\n            }\n\n            case TIFF_RATIONAL:  // Fall through\n            case TIFF_SRATIONAL: // Fall through\n            case TIFF_FLOAT:\n            {\n               return populateStaticTagMetadata<float>(pTiffFile, tag,\n                   TIFFFieldReadCount(pFieldInfo), pMetadata, message);\n            }\n\n            case TIFF_DOUBLE:\n            {\n               return populateStaticTagMetadata<double>(pTiffFile, tag,\n                   TIFFFieldReadCount(pFieldInfo), pMetadata, message);\n            }\n\n            default:\n            {\n               message += \"Invalid tag type for custom field \" + string(TIFFFieldName(pFieldInfo)) + \"\\n\";\n               return false;\n            }\n         }\n      }\n\n      if (setMetadata(pFieldInfo, count, pValues, pMetadata) == false)\n      {\n         message += \"Error processing custom field \" + string(TIFFFieldName(pFieldInfo)) + \"\\n\";\n         return false;\n      }\n\n      return true;\n   }",
    "void populateTiffMetadata(TIFF* pTiffFile, DynamicObject* pMetadata, string& message)\n   {\n      message.clear();\n      if (pTiffFile == NULL || pMetadata == NULL)\n      {\n         message += \"Cannot populate metadata.\\n\";\n         return;\n      }\n\n      // Static tags - these MUST match those called out in tif_dir.c:657-800\n      populateStaticTagMetadata<uint32>(pTiffFile, TIFFTAG_SUBFILETYPE, 1, pMetadata, message);\n      populateStaticTagMetadata<uint32>(pTiffFile, TIFFTAG_IMAGEWIDTH, 1, pMetadata, message);\n      populateStaticTagMetadata<uint32>(pTiffFile, TIFFTAG_IMAGELENGTH, 1, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_BITSPERSAMPLE, 1, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_COMPRESSION, 1, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_PHOTOMETRIC, 1, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_THRESHHOLDING, 1, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_FILLORDER, 1, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_ORIENTATION, 1, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_SAMPLESPERPIXEL, 1, pMetadata, message);\n      populateStaticTagMetadata<uint32>(pTiffFile, TIFFTAG_ROWSPERSTRIP, 1, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_MINSAMPLEVALUE, 1, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_MAXSAMPLEVALUE, 1, pMetadata, message);\n      populateStaticTagMetadata<double>(pTiffFile, TIFFTAG_SMINSAMPLEVALUE, 1, pMetadata, message);\n      populateStaticTagMetadata<double>(pTiffFile, TIFFTAG_SMAXSAMPLEVALUE, 1, pMetadata, message);\n      populateStaticTagMetadata<float>(pTiffFile, TIFFTAG_XRESOLUTION, 1, pMetadata, message);\n      populateStaticTagMetadata<float>(pTiffFile, TIFFTAG_YRESOLUTION, 1, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_PLANARCONFIG, 1, pMetadata, message);\n      populateStaticTagMetadata<float>(pTiffFile, TIFFTAG_XPOSITION, 1, pMetadata, message);\n      populateStaticTagMetadata<float>(pTiffFile, TIFFTAG_YPOSITION, 1, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_RESOLUTIONUNIT, 1, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_PAGENUMBER, 2, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_HALFTONEHINTS, 2, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_MATTEING, 1, pMetadata, message);\n      populateStaticTagMetadata<uint32>(pTiffFile, TIFFTAG_TILEWIDTH, 1, pMetadata, message);\n      populateStaticTagMetadata<uint32>(pTiffFile, TIFFTAG_TILELENGTH, 1, pMetadata, message);\n      populateStaticTagMetadata<uint32>(pTiffFile, TIFFTAG_TILEDEPTH, 1, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_DATATYPE, 1, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_SAMPLEFORMAT, 1, pMetadata, message);\n      populateStaticTagMetadata<uint32>(pTiffFile, TIFFTAG_IMAGEDEPTH, 1, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_YCBCRPOSITIONING, 1, pMetadata, message);\n      populateStaticTagMetadata<uint16>(pTiffFile, TIFFTAG_YCBCRSUBSAMPLING, 2, pMetadata, message);\n\n      // More static tags - each of these tags represents a special case in tif_dir.c:657-800\n\n      // Special case\n      // Either strips or tiles will be present, but not both\n      // In either case, the number is obtained by calling the appropriate TIFFNumberOf function\n      if (TIFFIsTiled(pTiffFile) == 0)\n      {\n         // Strips\n         const tstrip_t numStrips(TIFFNumberOfStrips(pTiffFile));\n         populateStaticTagMetadataArray1D<uint32>(pTiffFile, TIFFTAG_STRIPOFFSETS, numStrips, pMetadata, message);\n         populateStaticTagMetadataArray1D<uint32>(pTiffFile, TIFFTAG_STRIPBYTECOUNTS, numStrips, pMetadata, message);\n      }\n      else\n      {\n         // Tiles\n         const ttile_t numTiles(TIFFNumberOfTiles(pTiffFile));\n         populateStaticTagMetadataArray1D<uint32>(pTiffFile, TIFFTAG_TILEOFFSETS, numTiles, pMetadata, message);\n         populateStaticTagMetadataArray1D<uint32>(pTiffFile, TIFFTAG_TILEBYTECOUNTS, numTiles, pMetadata, message);\n      }\n\n      // Special case\n      // Counts for TIFFTAG_EXTRASAMPLES and TIFFTAG_SUBIFD are obtained by calling TIFFGetField\n      populateStaticTagMetadataArray1D<uint16>(pTiffFile, TIFFTAG_EXTRASAMPLES, 0, pMetadata, message);\n      populateStaticTagMetadataArray1D<uint32>(pTiffFile, TIFFTAG_SUBIFD, 0, pMetadata, message);\n\n      // Special case\n      // TIFFTAG_COLORMAP and TIFFTAG_TRANSFERFUNCTION are uint16** with either 1 or 3 entries\n      uint16 bitsPerElement = 0;\n      TIFFGetField(pTiffFile, TIFFTAG_BITSPERSAMPLE, &bitsPerElement);\n      populateStaticTagMetadataArray2D<uint16>(pTiffFile, TIFFTAG_COLORMAP,\n         static_cast<uint32>(1 << bitsPerElement), pMetadata, message);\n\n      populateStaticTagMetadataArray2D<uint16>(pTiffFile, TIFFTAG_TRANSFERFUNCTION, \n         static_cast<uint32>(1 << bitsPerElement), pMetadata, message);\n\n      // Special case\n      // TIFFTAG_REFERENCEBLACKWHITE is float* with exactly 6 entries\n      populateStaticTagMetadataArray1D<float>(pTiffFile, TIFFTAG_REFERENCEBLACKWHITE, 6, pMetadata, message);\n\n      // Special case\n      // TIFFTAG_INKNAMES is a char** to be read in as multiple NULL-terminated strings\n      uint16 numberOfInks = 0;\n      TIFFGetField(pTiffFile, TIFFTAG_NUMBEROFINKS, &numberOfInks);\n      if (numberOfInks > 0)\n      {\n         if (numberOfInks > 1)\n         {\n            message += QString(\"%1 InkNames defined. Only the first will be read.\\n\").arg(numberOfInks).toStdString();\n            numberOfInks = 1;\n         }\n\n         populateStaticTagMetadataArray1D<char>(pTiffFile, TIFFTAG_INKNAMES, numberOfInks, pMetadata, message);\n      }\n\n      // Iterate over each custom tag, placing it into the metadata\n      const int numTags = TIFFGetTagListCount(pTiffFile);\n      for (int i = 0; i < numTags; ++i)\n      {\n         populateCustomTagMetadata(pTiffFile, TIFFGetTagListEntry(pTiffFile, i), pMetadata, message);\n      }\n   }",
    "bool GeoTIFFImporter::populateDataDescriptor(RasterDataDescriptor* pDescriptor)\n{\n   if (pDescriptor == NULL)\n   {\n      return false;\n   }\n\n   RasterFileDescriptor* pFileDescriptor = dynamic_cast<RasterFileDescriptor*>\n      (pDescriptor->getFileDescriptor());\n   if (pFileDescriptor == NULL)\n   {\n      return false;\n   }\n\n   const string& filename = pFileDescriptor->getFilename();\n   if (filename.empty() == true)\n   {\n      return false;\n   }\n\n   {\n      // Check the first four bytes for TIFF magic number\n\n      //force file to be closed when scope block ends\n      FileResource pFile(filename.c_str(), \"r\");\n      if (pFile.get() != NULL)\n      {\n         const unsigned short tiffBigEndianMagicNumber = 0x4d4d;\n         const unsigned short tiffLittleEndianMagicNumber = 0x4949;\n         const unsigned short tiffVersionMagicNumber = 42;\n\n         unsigned short fileEndian;\n         fread(&fileEndian, sizeof(fileEndian), 1, pFile);\n\n         if ( (fileEndian == tiffBigEndianMagicNumber) || (fileEndian == tiffLittleEndianMagicNumber) )\n         {\n            unsigned short tiffVersion;\n            fread(&tiffVersion, sizeof(tiffVersion), 1, pFile);\n\n            EndianType fileEndianType = (fileEndian == tiffBigEndianMagicNumber ? BIG_ENDIAN_ORDER : LITTLE_ENDIAN_ORDER);\n            Endian swapper(fileEndianType);\n            swapper.swapBuffer(&tiffVersion, 1);\n\n            if (tiffVersion != tiffVersionMagicNumber)\n            {\n               return false;\n            }\n            pFileDescriptor->setEndian(fileEndianType);\n         }\n         else\n         {\n            return false;\n         }\n      }\n   }\n\n   TIFF* pTiffFile = XTIFFOpen(filename.c_str(), \"r\");\n   if (pTiffFile == NULL)\n   {\n      return false;\n   }\n\n   // Metadata\n   DynamicObject* pMetadata = pDescriptor->getMetadata();\n   if (pMetadata != NULL)\n   {\n      // TIFF tags\n      string message;\n      populateTiffMetadata(pTiffFile, pDescriptor->getMetadata(), message);\n      if (message.empty() == false)\n      {\n         const string& rasterName = pDescriptor->getName();\n         mMetadataMessages[rasterName] = message;\n      }\n\n      // ISD metadata\n      QuickbirdIsd isd(pMetadata);\n\n      QString isdFilename = isd.getIsdFilename();\n      if (isdFilename.isEmpty() == true)\n      {\n         // An ISD filename has not yet been set, so check for an existing file based on the raster filename\n         const FileDescriptor* pFileDescriptor2 = pDescriptor->getFileDescriptor();\n         if (pFileDescriptor2 != NULL)\n         {\n            QFileInfo tiffInfo(QString::fromStdString(pFileDescriptor2->getFilename().getFullPathAndName()));\n            QFileInfo isdInfo(tiffInfo.absolutePath() + \"/\" + tiffInfo.completeBaseName() + \".xml\");\n            if (isdInfo.exists() == true)\n            {\n               isdFilename = isdInfo.absoluteFilePath();\n            }\n         }\n      }\n\n      isd.loadIsdMetadata(isdFilename);\n   }\n\n   // Check for unsupported palette data\n   unsigned short photometric = 0;\n   TIFFGetField(pTiffFile, TIFFTAG_PHOTOMETRIC, &photometric);\n\n   if (photometric == PHOTOMETRIC_PALETTE)\n   {\n      XTIFFClose(pTiffFile);\n      return false;\n   }\n\n   // Rows\n   unsigned int numRows = 0;\n   TIFFGetField(pTiffFile, TIFFTAG_IMAGELENGTH, &numRows);\n\n   vector<DimensionDescriptor> rows = RasterUtilities::generateDimensionVector(numRows, true, false, true);\n   pDescriptor->setRows(rows);\n   pFileDescriptor->setRows(rows);\n\n   // Columns\n   unsigned int numColumns = 0;\n   TIFFGetField(pTiffFile, TIFFTAG_IMAGEWIDTH, &numColumns);\n\n   vector<DimensionDescriptor> columns = RasterUtilities::generateDimensionVector(numColumns, true, false, true);\n\n   pDescriptor->setColumns(columns);\n   pFileDescriptor->setColumns(columns);\n\n   // Bands\n   unsigned short numBands = 1;\n   TIFFGetField(pTiffFile, TIFFTAG_SAMPLESPERPIXEL, &numBands);\n\n   vector<DimensionDescriptor> bands = RasterUtilities::generateDimensionVector(numBands, true, false, true);\n\n   pDescriptor->setBands(bands);\n   pFileDescriptor->setBands(bands);\n\n   // Bits per pixel\n   unsigned short bitsPerElement = 0;\n   TIFFGetField(pTiffFile, TIFFTAG_BITSPERSAMPLE, &bitsPerElement);\n\n   pFileDescriptor->setBitsPerElement(bitsPerElement);\n\n   // Data type\n   unsigned short sampleFormat = SAMPLEFORMAT_VOID;\n   TIFFGetField(pTiffFile, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n   EncodingType dataType = INT1UBYTE;\n\n   unsigned int bytesPerElement = bitsPerElement / 8;\n   switch (bytesPerElement)\n   {\n      case 1:\n         if (sampleFormat == SAMPLEFORMAT_INT)\n         {\n            dataType = INT1SBYTE;\n         }\n         else\n         {\n            dataType = INT1UBYTE;\n         }\n         break;\n\n      case 2:\n         if (sampleFormat == SAMPLEFORMAT_INT)\n         {\n            dataType = INT2SBYTES;\n         }\n         else\n         {\n            dataType = INT2UBYTES;\n         }\n         break;\n\n      case 4:\n         if (sampleFormat == SAMPLEFORMAT_INT)\n         {\n            dataType = INT4SBYTES;\n         }\n         else if (sampleFormat == SAMPLEFORMAT_IEEEFP)\n         {\n            dataType = FLT4BYTES;\n         }\n         else\n         {\n            dataType = INT4UBYTES;\n         }\n         break;\n\n      case 8:\n         dataType = FLT8BYTES;\n         break;\n\n      default:\n         break;\n   }\n\n   pDescriptor->setDataType(dataType);\n   pDescriptor->setValidDataTypes(vector<EncodingType>(1, dataType));\n\n   // Interleave format\n   unsigned short planarConfig = 0;\n   TIFFGetField(pTiffFile, TIFFTAG_PLANARCONFIG, &planarConfig);\n\n   if (planarConfig == PLANARCONFIG_SEPARATE)\n   {\n      pFileDescriptor->setInterleaveFormat(BSQ);\n   }\n   else if (planarConfig == PLANARCONFIG_CONTIG)\n   {\n      pFileDescriptor->setInterleaveFormat(BIP);\n   }\n\n   pDescriptor->setInterleaveFormat(BIP);\n\n   // Bad values\n   if ((dataType != FLT4BYTES) && (dataType != FLT8COMPLEX) && (dataType != FLT8BYTES))\n   {\n      vector<int> badValues(1);\n      badValues[0] = 0;\n\n      pDescriptor->setBadValues(badValues);\n   }\n\n   // Latitude/longitude GCPs\n   GTIF* pGeoTiff = GTIFNew(pTiffFile);\n\n   GTIFDefn defn;\n   GTIFGetDefn(pGeoTiff, &defn);\n\n   char* pProj4Defn = GTIFGetProj4Defn(&defn);\n   if (pProj4Defn != NULL)\n   {\n      free(pProj4Defn);\n      list<GcpPoint> gcps;\n\n      // The pixel coordinate system for GeoTIFF is defined as referring to the\n      // top-left corner of the pixel, regardless of whether the format is set\n      // as PixelIsArea or PixelIsPoint.  More on the issue can be read at the\n      // GeoTIFF FAQ: http://remotesensing.org/geotiff/faq.html#PixelIsPoint\n\n      // Upper left\n      double x = 0;\n      double y = 0;\n      if (GTIFImageToPCS(pGeoTiff, &x, &y) &&\n         (defn.Model == ModelTypeGeographic || GTIFProj4ToLatLong(&defn, 1, &x, &y)))\n      {\n         GcpPoint gcp;\n         gcp.mPixel.mX = 0.0;\n         gcp.mPixel.mY = 0.0;\n         gcp.mCoordinate.mX = y;\n         gcp.mCoordinate.mY = x;\n         gcps.push_back(gcp);\n      }\n\n      // Lower left\n      x = 0;\n      y = numRows - 1;\n      if (GTIFImageToPCS(pGeoTiff, &x, &y) &&\n         (defn.Model == ModelTypeGeographic || GTIFProj4ToLatLong(&defn, 1, &x, &y)))\n      {\n         GcpPoint gcp;\n         gcp.mPixel.mX = 0.0;\n         gcp.mPixel.mY = numRows - 1.0;\n         gcp.mCoordinate.mX = y;\n         gcp.mCoordinate.mY = x;\n         gcps.push_back(gcp);\n      }\n\n      // Upper right\n      x = numColumns - 1;\n      y = 0;\n      if (GTIFImageToPCS(pGeoTiff, &x, &y) &&\n         (defn.Model == ModelTypeGeographic || GTIFProj4ToLatLong(&defn, 1, &x, &y)))\n      {\n         GcpPoint gcp;\n         gcp.mPixel.mX = numColumns - 1.0;\n         gcp.mPixel.mY = 0.0;\n         gcp.mCoordinate.mX = y;\n         gcp.mCoordinate.mY = x;\n         gcps.push_back(gcp);\n      }\n\n      // Lower right\n      x = numColumns - 1;\n      y = numRows - 1;\n      if (GTIFImageToPCS(pGeoTiff, &x, &y) &&\n         (defn.Model == ModelTypeGeographic || GTIFProj4ToLatLong(&defn, 1, &x, &y)))\n      {\n         GcpPoint gcp;\n         gcp.mPixel.mX = numColumns - 1.0;\n         gcp.mPixel.mY = numRows - 1.0;\n         gcp.mCoordinate.mX = y;\n         gcp.mCoordinate.mY = x;\n         gcps.push_back(gcp);\n      }\n\n      // Center\n      x = (numColumns - 1) / 2;\n      y = (numRows - 1) / 2;\n      if (GTIFImageToPCS(pGeoTiff, &x, &y) &&\n         (defn.Model == ModelTypeGeographic || GTIFProj4ToLatLong(&defn, 1, &x, &y)))\n      {\n         GcpPoint gcp;\n         // pixels in GeoTIFF refer to top-left corner of the rastered pixel, so floor the center\n         gcp.mPixel.mX = floor((numColumns - 1.0) / 2.0);\n         gcp.mPixel.mY = floor((numRows - 1.0) / 2.0);\n         gcp.mCoordinate.mX = y;\n         gcp.mCoordinate.mY = x;\n         gcps.push_back(gcp);\n      }\n\n      if (gcps.empty() == false)\n      {\n         pFileDescriptor->setGcps(gcps);\n      }\n   }\n\n   // Close the TIFF file\n   XTIFFClose(pTiffFile);\n\n   return true;\n}",
    "bool TIFFImage::initializeType(const std::string& imagePath) {\r\n  std::unique_lock<std::shared_mutex> l(*_openCloseMutex);\r\n  cleanup();\r\n\r\n#ifdef _WIN32\r\n  int wchars_num = MultiByteToWideChar(CP_UTF8, 0, imagePath.c_str(), -1, NULL, 0);\r\n  wchar_t* w_imagePath = new wchar_t[wchars_num];\r\n  MultiByteToWideChar(CP_UTF8, 0, imagePath.c_str(), -1, w_imagePath, wchars_num);\r\n  _tiff = TIFFOpenW(w_imagePath, \"rm\");\r\n  delete[] w_imagePath;\r\n#else\r\n  _tiff = TIFFOpen(imagePath.c_str(), \"rm\");\r\n#endif\r\n\r\n  if (_tiff) {\r\n    const char* img_desc = NULL;\r\n\r\n    if (TIFFGetFieldDefaulted(_tiff, TIFFTAG_IMAGEDESCRIPTION, &img_desc)) {\r\n      std::string img_desc_string(img_desc);\r\n      if (img_desc_string.find(\"DICOM\") != std::string::npos || img_desc_string.find(\"xml\") != std::string::npos || img_desc_string.find(\"XML\") != std::string::npos) {\r\n        // Not one of our TIFFs\r\n        cleanup();\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (TIFFIsTiled(_tiff) == 0) {\r\n      cleanup();\r\n      return false;\r\n    }\r\n    unsigned int codec = 0;\r\n    TIFFGetField(_tiff, TIFFTAG_COMPRESSION, &codec);\r\n    if (codec != 33005 && codec != COMPRESSION_DEFLATE && codec != COMPRESSION_JPEG && codec != COMPRESSION_LZW && codec != COMPRESSION_NONE) {\r\n      cleanup();\r\n      return false;\r\n    }\r\n\r\n    unsigned int cType = 0, dType = 0, planarconfig = 0, bitsPerSample = 0;\r\n    TIFFGetField(_tiff, TIFFTAG_PHOTOMETRIC, &cType);\r\n\r\n    // TIFFTAG_SAMPLEFORMAT is not always present, when it is not the TIFF\r\n    // standard indicates that data should be interpreted as unsigned int\r\n    if (TIFFGetField(_tiff, TIFFTAG_SAMPLEFORMAT, &dType) == 0 && dType == 0) {\r\n      dType = 1;\r\n    }\r\n\r\n    TIFFGetField(_tiff, TIFFTAG_SAMPLESPERPIXEL, &_samplesPerPixel);\r\n    TIFFGetField(_tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\r\n    TIFFGetField(_tiff, TIFFTAG_PLANARCONFIG, &planarconfig);\r\n\r\n    if (planarconfig != PLANARCONFIG_CONTIG) {\r\n      cleanup();\r\n    }\r\n    if (dType != SAMPLEFORMAT_IEEEFP && dType != SAMPLEFORMAT_UINT) {\r\n      cleanup();\r\n    }\r\n    if (cType != PHOTOMETRIC_MINISBLACK && cType != PHOTOMETRIC_RGB && cType != PHOTOMETRIC_YCBCR) {\r\n      cleanup();\r\n    }\r\n    if (cType == PHOTOMETRIC_RGB && _samplesPerPixel != 3 && _samplesPerPixel != 4) {\r\n      cleanup();\r\n    }\r\n    if (dType == SAMPLEFORMAT_IEEEFP && bitsPerSample != 32) {\r\n      cleanup();\r\n    }\r\n    if (dType == SAMPLEFORMAT_UINT && bitsPerSample != 32 && bitsPerSample != 16 && bitsPerSample != 8) {\r\n      cleanup();\r\n    }\r\n    if (!_tiff) {\r\n      return false;\r\n    }\r\n\r\n    _numberOfLevels = TIFFNumberOfDirectories(_tiff);\r\n\r\n    if (_numberOfLevels < 1) {\r\n      cleanup();\r\n      return false;\r\n    }\r\n\r\n    // Check if the multi-resolution pyramid is stored nicely\r\n    TIFFSetDirectory(_tiff, 0);\r\n    unsigned int width = 0;\r\n    TIFFGetField(_tiff, TIFFTAG_IMAGEWIDTH, &width);\r\n    unsigned int x = 0, y = 0;\r\n    unsigned int tileW = 0, tileH = 0;\r\n    unsigned int dir = 0;\r\n    for (int level = 0; level < TIFFNumberOfDirectories(_tiff); ++level) {\r\n      TIFFSetDirectory(_tiff, level);\r\n      if (TIFFIsTiled(_tiff) == 1) {\r\n        TIFFGetField(_tiff, TIFFTAG_IMAGEWIDTH, &x);\r\n        TIFFGetField(_tiff, TIFFTAG_IMAGELENGTH, &y);\r\n        TIFFGetField(_tiff, TIFFTAG_TILEWIDTH, &tileW);\r\n        TIFFGetField(_tiff, TIFFTAG_TILELENGTH, &tileH);\r\n        std::vector<unsigned long long> tmp;\r\n        std::vector<unsigned int> levelTileSize;\r\n        tmp.push_back(x);\r\n        tmp.push_back(y);\r\n        levelTileSize.push_back(tileW);\r\n        levelTileSize.push_back(tileH);\r\n        _levelDimensions.push_back(tmp);\r\n        _tileSizesPerLevel.push_back(levelTileSize);\r\n        if (level > 0) {\r\n          if (width > x) {\r\n            width = x;\r\n          }\r\n          else {\r\n            cleanup();\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        _numberOfLevels -= 1;\r\n      }\r\n    }\r\n\r\n    TIFFSetDirectory(_tiff, 0);\r\n    if (dType == SAMPLEFORMAT_IEEEFP) {\r\n      _dataType = DataType::Float;\r\n    }\r\n    else if (dType == SAMPLEFORMAT_UINT) {\r\n      if (bitsPerSample == 8) {\r\n        _dataType = DataType::UChar;\r\n      }\r\n      else if (bitsPerSample == 16) {\r\n        _dataType = DataType::UInt16;\r\n      }\r\n      else if (bitsPerSample == 32) {\r\n        _dataType = DataType::UInt32;\r\n      }\r\n      else {\r\n        _dataType = DataType::InvalidDataType;\r\n      }\r\n    }\r\n\r\n    if (cType == PHOTOMETRIC_MINISBLACK) {\r\n      if (_samplesPerPixel > 1) {\r\n        _colorType = ColorType::Indexed;\r\n      }\r\n      else {\r\n        _colorType = ColorType::Monochrome;\r\n      }\r\n    }\r\n    else if (cType == PHOTOMETRIC_RGB) {\r\n      if (_samplesPerPixel == 3) {\r\n        _colorType = ColorType::RGB;\r\n      }\r\n      else if (_samplesPerPixel == 4) {\r\n        _colorType = ColorType::RGBA;\r\n      }\r\n      else {\r\n        _colorType = ColorType::InvalidColorType;\r\n      }\r\n    }\r\n    else if (cType == PHOTOMETRIC_YCBCR && codec == COMPRESSION_JPEG) {\r\n      if (_samplesPerPixel == 3) {\r\n        _colorType = ColorType::RGB;\r\n      }\r\n      else if (_samplesPerPixel == 4) {\r\n        _colorType = ColorType::RGBA;\r\n      }\r\n      else {\r\n        _colorType = ColorType::InvalidColorType;\r\n      }\r\n    }\r\n\r\n    float spacingX;\r\n    float spacingY;\r\n    if (TIFFGetField(_tiff, TIFFTAG_XRESOLUTION, &spacingX) == 1) {\r\n      _spacing.push_back(1. / (spacingX / (10000.)));\r\n    }\r\n    if (TIFFGetField(_tiff, TIFFTAG_YRESOLUTION, &spacingY) == 1) {\r\n      _spacing.push_back(1. / (spacingY / (10000.)));\r\n    }\r\n\r\n    TIFFSetField(_tiff, TIFFTAG_PERSAMPLE, PERSAMPLE_MULTI);\r\n    double* min_values;\r\n    if (TIFFGetField(_tiff, TIFFTAG_SMINSAMPLEVALUE, &min_values)) {\r\n      for (unsigned int i = 0; i < _samplesPerPixel; ++i) {\r\n        _minValues.push_back(min_values[i]);\r\n      }\r\n    }\r\n    else {\r\n      for (unsigned int i = 0; i < _samplesPerPixel; ++i) {\r\n        _minValues.push_back(0.);\r\n      }\r\n    }\r\n    double* max_values;\r\n    if (TIFFGetField(_tiff, TIFFTAG_SMAXSAMPLEVALUE, &max_values)) {\r\n      for (unsigned int i = 0; i < _samplesPerPixel; ++i) {\r\n        _maxValues.push_back(max_values[i]);\r\n      }\r\n    }\r\n    else {\r\n      for (unsigned int i = 0; i < _samplesPerPixel; ++i) {\r\n        _maxValues.push_back(255.);\r\n      }\r\n    }\r\n    TIFFSetField(_tiff, TIFFTAG_PERSAMPLE, PERSAMPLE_MERGED);\r\n\r\n    _fileType = \"tif\";\r\n    _isValid = true;\r\n  }\r\n  else {\r\n    cleanup();\r\n    return false;\r\n  }\r\n\r\n  if (_dataType == DataType::UInt32) {\r\n    createCache<unsigned int>();\r\n  }\r\n  else if (_dataType == DataType::UInt16) {\r\n    createCache<unsigned short>();\r\n  }\r\n  else if (_dataType == DataType::Float) {\r\n    createCache<float>();\r\n  }\r\n  else if (_dataType == DataType::UChar) {\r\n    createCache<unsigned char>();\r\n  }\r\n  return _isValid;\r\n}",
    "long long TIFFImage::getEncodedTileSize(const long long& startX, const long long& startY, const unsigned int& level) {\r\n  if (_tiff && level < this->_numberOfLevels) {\r\n    long long levelStartX = std::floor(startX / getLevelDownsample(level) + 0.5);\r\n    long long levelStartY = std::floor(startY / getLevelDownsample(level) + 0.5);\r\n    TIFFSetDirectory(_tiff, level);\r\n    unsigned int tileNr = TIFFComputeTile(_tiff, levelStartX, levelStartY, 0, 0);\r\n    unsigned int total_tiles = TIFFNumberOfTiles(_tiff);\r\n    if (tileNr < total_tiles) {\r\n      unsigned long long* tbc = NULL;\r\n      TIFFGetField(_tiff, TIFFTAG_TILEBYTECOUNTS, &tbc);\r\n      unsigned long long k = tbc[tileNr];\r\n      if (k == 0) {\r\n        return -1;\r\n      }\r\n      unsigned int count = 0;\r\n      unsigned char* jpt;\r\n      if (TIFFGetField(_tiff, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\r\n        if (count > 4) {\r\n          k = k + count;\r\n          k -= 2; /* don't use EOI of header or SOI of tile */\r\n        }\r\n      }\r\n      return k;\r\n    }\r\n    else {\r\n      return -1;\r\n    }\r\n  }\r\n  else {\r\n    return -1;\r\n  }\r\n}",
    "unsigned char* TIFFImage::readEncodedDataFromImage(const long long& startX, const long long& startY, const unsigned int& level) {\r\n  if (_tiff) {\r\n    unsigned int codec = 0;\r\n    TIFFGetField(_tiff, TIFFTAG_COMPRESSION, &codec);\r\n    if (codec == 7) { // New style JPEG\r\n      long long levelStartX = std::floor(startX / getLevelDownsample(level) + 0.5);\r\n      long long levelStartY = std::floor(startY / getLevelDownsample(level) + 0.5);\r\n      TIFFSetDirectory(_tiff, level);\r\n      unsigned int tileNr = TIFFComputeTile(_tiff, levelStartX, levelStartY, 0, 0);\r\n      if (tileNr < TIFFNumberOfTiles(_tiff)) {\r\n        unsigned char table_end[2];\r\n        unsigned int count = 0;\r\n        unsigned char* jpt;\r\n        float* xfloatp;\r\n        unsigned int endOfBuffer = 0;\r\n        unsigned long long datasize = this->getEncodedTileSize(startX, startY, level);\r\n        if (datasize < 0) {\r\n          return NULL;\r\n        }\r\n        unsigned long long bufferoffset = 0;\r\n        unsigned char* buffer = new unsigned char[datasize];\r\n\r\n        if (TIFFGetField(_tiff, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\r\n          if (count > 4) {\r\n            int retTIFFReadRawTile;\r\n            /* Ignore EOI marker of JpegTables */\r\n            _TIFFmemcpy(buffer, jpt, count - 2);\r\n            bufferoffset += count - 2;\r\n            /* Store last 2 bytes of the JpegTables */\r\n            table_end[0] = buffer[bufferoffset - 2];\r\n            table_end[1] = buffer[bufferoffset - 1];\r\n            endOfBuffer = bufferoffset;\r\n            bufferoffset -= 2;\r\n            retTIFFReadRawTile = TIFFReadRawTile(\r\n              _tiff,\r\n              tileNr,\r\n              (void*)&(((unsigned char*)buffer)[bufferoffset]),\r\n              -1);\r\n            bufferoffset += retTIFFReadRawTile;\r\n            /* Overwrite SOI marker of image scan with previously */\r\n            /* saved end of JpegTables */\r\n            buffer[endOfBuffer - 2] = table_end[0];\r\n            buffer[endOfBuffer - 1] = table_end[1];\r\n          }\r\n        }\r\n        else {\r\n          TIFFReadRawTile(\r\n            _tiff,\r\n            tileNr,\r\n            (void*)&(((unsigned char*)buffer)[bufferoffset]),\r\n            -1);\r\n        }\r\n        return buffer;\r\n      }\r\n      else {\r\n        return NULL;\r\n      }\r\n    }\r\n    else {\r\n      return NULL;\r\n    }\r\n  }\r\n  else {\r\n    return NULL;\r\n  }\r\n}",
    "T* TIFFImage::FillRequestedRegionFromTIFF(const long long& startX, const long long& startY, const unsigned long long& width,\r\n  const unsigned long long& height, const unsigned int& level, unsigned int nrSamples)\r\n{\r\n  std::shared_lock<std::shared_mutex> l(*_openCloseMutex);\r\n  T* temp = new T[width * height * nrSamples];\r\n  std::fill(temp, temp + width * height * nrSamples, static_cast<T>(0));\r\n  unsigned int tileW = _tileSizesPerLevel[level][0], tileH = _tileSizesPerLevel[level][1], levelH = _levelDimensions[level][1], levelW = _levelDimensions[level][0];\r\n\r\n  long long levelStartX = std::floor(startX / getLevelDownsample(level) + 0.5);\r\n  long long levelStartY = std::floor(startY / getLevelDownsample(level) + 0.5);\r\n  long long startTileY = levelStartY - (levelStartY - ((levelStartY / tileH) * tileH));\r\n  long long startTileX = levelStartX - (levelStartX - ((levelStartX / tileW) * tileW));\r\n  long long finalX = levelStartX + width >= levelW ? levelW : levelStartX + width;\r\n  long long finalY = levelStartY + height >= levelH ? levelH : levelStartY + height;\r\n\r\n  for (long long iy = startTileY; iy < finalY; iy += tileH) {\r\n    if (iy < 0) {\r\n      continue;\r\n    }\r\n    for (long long ix = startTileX; ix < finalX; ix += tileW) {\r\n      if (ix < 0) {\r\n        continue;\r\n      }\r\n\r\n      std::stringstream k;\r\n      k << ix * getLevelDownsample(level) << \"-\" << iy * getLevelDownsample(level) << \"-\" << level;\r\n      bool deleteTile = false;\r\n      unsigned int cachedTileSize = 0;\r\n      T* tile = NULL;\r\n      _cacheMutex->lock();\r\n      std::static_pointer_cast<TileCache<T>>(_cache)->get(k.str(), tile, cachedTileSize);\r\n      _cacheMutex->unlock();\r\n      if (!tile) {\r\n        tile = new T[tileW * tileH * getSamplesPerPixel()];\r\n        std::fill(tile, tile + tileW * tileH * getSamplesPerPixel(), static_cast<T>(0.0));\r\n        _cacheMutex->lock();\r\n        TIFFSetDirectory(_tiff, level);\r\n        unsigned int codec = 0;\r\n        TIFFGetField(_tiff, TIFFTAG_COMPRESSION, &codec);\r\n        unsigned int ycbcr = 0;\r\n        TIFFGetField(_tiff, TIFFTAG_PHOTOMETRIC, &ycbcr);\r\n        if (codec == 33005) {\r\n          if (!_jp2000) {\r\n            _jp2000 = new JPEG2000Codec();\r\n          }\r\n          unsigned int byteSize = tileW * tileH * getSamplesPerPixel() * sizeof(T);\r\n          unsigned int rawSize = TIFFReadRawTile(_tiff, TIFFComputeTile(_tiff, ix, iy, 0, 0), tile, byteSize);\r\n          _jp2000->decode((unsigned char*)tile, rawSize, byteSize);\r\n        }\r\n        else {\r\n          if (codec == COMPRESSION_JPEG && ycbcr == PHOTOMETRIC_YCBCR) {\r\n            TIFFSetField(_tiff, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\r\n          }\r\n          TIFFReadTile(_tiff, tile, ix, iy, 0, 0);\r\n        }\r\n        if (std::static_pointer_cast<TileCache<T>>(_cache)->set(k.str(), tile, tileW * tileH * getSamplesPerPixel() * sizeof(T))) {\r\n          deleteTile = true;\r\n        }\r\n        _cacheMutex->unlock();\r\n      }\r\n\r\n      long long ixx = (ix - levelStartX);\r\n      long long iyy = (iy - levelStartY);\r\n      long long lyh = levelStartY + height;\r\n      long long lxw = levelStartX + width;\r\n      long long ixw = ixx + tileW;\r\n      long long rowLength = ixw > static_cast<long long>(width) ? (tileW - (ixw - width)) * nrSamples : tileW * nrSamples;\r\n      long long tileDeltaX = 0;\r\n      if (ixx < 0) {\r\n        rowLength += ixx * nrSamples;\r\n        tileDeltaX -= ixx * nrSamples;\r\n        ixx = 0;\r\n      }\r\n      for (unsigned int ty = 0; ty < tileH; ++ty) {\r\n        if ((iyy + ty >= 0) && (ixx >= 0) && (iyy + ty < static_cast<long long>(height)) && lxw > 0) {\r\n          long long idx = (ty + iyy) * width * nrSamples + ixx * nrSamples;\r\n          long long tids = (ty * tileW) * nrSamples;\r\n          std::copy(tile + tids + tileDeltaX, tile + tids + rowLength + tileDeltaX, temp + idx);\r\n        }\r\n      }\r\n      if (deleteTile) {\r\n        delete[] tile;\r\n      }\r\n    }\r\n  }\r\n  return temp;\r\n}",
    "void AperioSVSWriter::writeThumbnail() {\r\n  unsigned long w = 0, h = 0, nrsamples = 0;\r\n  TIFF* lowestResTiff = TIFFOpen(_levelFiles[_levelFiles.size()-1].c_str(), \"r\");\r\n  TIFFGetField(lowestResTiff, TIFFTAG_IMAGEWIDTH, &w);\r\n  TIFFGetField(lowestResTiff, TIFFTAG_IMAGELENGTH, &h);\r\n  TIFFGetField(lowestResTiff, TIFFTAG_SAMPLESPERPIXEL, &nrsamples);\r\n\r\n  setBaseTags(_tiff);\r\n  TIFFSetField(_tiff, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\r\n  TIFFSetField(_tiff, TIFFTAG_JPEGQUALITY, 70);\r\n  TIFFSetField(_tiff, TIFFTAG_ROWSPERSTRIP, 16);\r\n  TIFFSetField(_tiff, TIFFTAG_IMAGEWIDTH, w);\r\n  TIFFSetField(_tiff, TIFFTAG_IMAGELENGTH, h);\r\n  TIFFSetField(_tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER);\r\n  TIFFSetField(_tiff, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE);\r\n\r\n  unsigned int npixels = w * h * nrsamples;\r\n  T* raster = (T*)_TIFFmalloc(npixels * sizeof(T));\r\n  unsigned int nrTiles = TIFFNumberOfTiles(lowestResTiff);\r\n  unsigned int tileW = 0, tileH = 0;\r\n  TIFFGetField(lowestResTiff, TIFFTAG_TILEWIDTH, &tileW);\r\n  TIFFGetField(lowestResTiff, TIFFTAG_TILELENGTH, &tileH);\r\n  T* tile = (T*)_TIFFmalloc(tileW * tileH * nrsamples * sizeof(T));\r\n  JPEG2000Codec cod;\r\n  for (unsigned int tileY = 0; tileY < h; tileY += tileH) {\r\n    for (unsigned int tileX = 0; tileX < w; tileX += tileW) {\r\n      if (getCompression() == Compression::JPEG2000) {\r\n        unsigned int no = TIFFComputeTile(lowestResTiff, tileX, tileY, 0, 0);\r\n        unsigned int rawSize = TIFFReadRawTile(lowestResTiff, no, tile, tileW*tileH*nrsamples*sizeof(T));\r\n        cod.decode((unsigned char*)tile, rawSize, tileW*tileH*nrsamples*sizeof(T));\r\n      }\r\n      else {\r\n        TIFFReadTile(lowestResTiff, tile, tileX, tileY, 0, 0);\r\n      }\r\n      for (unsigned int y = 0; y < tileH; ++y){\r\n        for (unsigned int x = 0; x < tileW; ++x){\r\n          if ((tileX + x) < w && (tileY + y) < h) {\r\n            for (unsigned int s = 0; s < nrsamples; ++s) {\r\n              (*(raster + (tileY + y) * w * nrsamples + (tileX + x) * nrsamples + s)) = (*(tile + y * tileW * nrsamples + x * nrsamples + s));\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  _TIFFfree(tile);\r\n  tile = NULL;\r\n  if (raster != NULL) {\r\n    unsigned int nrOfStrips = TIFFNumberOfStrips(_tiff);\r\n    for (unsigned int i = 0; i < nrOfStrips; ++i) {\r\n      T* strip = (T*)_TIFFmalloc(16 * w * nrsamples * sizeof(T));\r\n      unsigned int startOfStrip = i * 16 * w * nrsamples;\r\n      unsigned int endOfStrip = (i + 1) * 16 * w * nrsamples;\r\n      if (endOfStrip>npixels) {\r\n        endOfStrip = npixels;\r\n      }\r\n      for (unsigned int j = startOfStrip, k = 0; j < endOfStrip; ++j, ++k) {\r\n        T val = *(raster + j);\r\n        *(strip + k) = val;\r\n      }\r\n      TIFFWriteEncodedStrip(_tiff, i, strip, 16 * w * nrsamples * sizeof(T));\r\n      _TIFFfree(strip);\r\n    }\r\n    _TIFFfree(raster);\r\n  }\r\n\r\n  TIFFClose(lowestResTiff);\r\n  lowestResTiff = NULL;\r\n  if (TIFFNumberOfDirectories(_tiff) > 1) {\r\n    TIFFSetField(_tiff, TIFFTAG_IMAGEDESCRIPTION, \"Aperio Image macro\");\r\n  }\r\n  TIFFWriteDirectory(_tiff);\r\n}",
    "int MultiResolutionImageWriter::writePyramidToDisk() {\r\n\r\n\t//! First get the overall image width and height;\r\n\tunsigned long w = 0, h = 0, nrsamples = 0, nrbits = 0;\r\n\t// TIFF idiosyncracy, when setting resolution tags one uses doubles,\r\n\t// getting them requires floats\r\n\tfloat spacingX = 0, spacingY = 0;\r\n\tstd::vector<double> spacing;\r\n\tTIFFGetField(_tiff, TIFFTAG_IMAGEWIDTH, &w);\r\n\tTIFFGetField(_tiff, TIFFTAG_IMAGELENGTH, &h);\r\n\tTIFFGetField(_tiff, TIFFTAG_SAMPLESPERPIXEL, &nrsamples);\r\n\tTIFFGetField(_tiff, TIFFTAG_BITSPERSAMPLE, &nrbits);\r\n\tif (TIFFGetField(_tiff, TIFFTAG_XRESOLUTION, &spacingX) == 1) {\r\n\t\tif (TIFFGetField(_tiff, TIFFTAG_YRESOLUTION, &spacingY) == 1) {\r\n\t\t\tspacing.push_back(1. / (spacingX / (10000.)));\r\n\t\t\tspacing.push_back(1. / (spacingY / (10000.)));\r\n\t\t}\r\n\t}\r\n\t// Determine the amount of pyramid levels\r\n\tunsigned int pyramidlevels = 1;\r\n\tunsigned int lowestwidth = w;\r\n\tif (_maxPyramidLevels < 0) {\r\n\t\twhile (lowestwidth > 1024) {\r\n\t\t\tlowestwidth /= _downsamplePerLevel;\r\n\t\t\tpyramidlevels += 1;\r\n\t\t}\r\n\t\tif (abs(1024. - lowestwidth) > abs(1024. - lowestwidth * 2)) {\r\n\t\t\tlowestwidth *= _downsamplePerLevel;\r\n\t\t\tpyramidlevels -= 1;\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tpyramidlevels = _maxPyramidLevels;\r\n\t\tlowestwidth /= pow(_downsamplePerLevel, pyramidlevels);\r\n\t}\r\n\t// Setup the image directory for the thumbnail\r\n\tunsigned int lowestheight = (unsigned int)(h / pow(_downsamplePerLevel, (double)pyramidlevels));\r\n\r\n\t// Write temporary image to store previous level (LibTiff does not allow to go back and forth between\r\n\t// empty directories\r\n#ifdef WIN32\r\n\tsize_t found = _fileName.find_last_of(\"/\\\\\");\r\n#else \r\n\tsize_t found = _fileName.find_last_of(\"/\");\r\n#endif\r\n\tstring tmpPth = _fileName.substr(0, found + 1);\r\n\tstring fileName = _fileName.substr(found + 1);\r\n\tsize_t dotLoc = fileName.find_last_of(\".\");\r\n\tstring baseName = fileName.substr(0, dotLoc);\r\n\tfor (unsigned int level = 1; level <= pyramidlevels; ++level) {\r\n\t\tif (_monitor) {\r\n\t\t\t_monitor->setProgress((_monitor->maximumProgress() / 2.) + (static_cast<float>(level) / static_cast<float>(pyramidlevels))* (_monitor->maximumProgress() / 4.));\r\n\t\t}\r\n\t\tTIFF* prevLevelTiff = _tiff;\r\n\t\tif (level != 1) {\r\n\t\t\tstd::stringstream ssm;\r\n\t\t\tssm << tmpPth << \"temp\" << baseName << \"Level\" << level - 1 << \".tif\";\r\n\t\t\tprevLevelTiff = TIFFOpen(ssm.str().c_str(), \"r\");\r\n\t\t}\r\n\t\tstd::stringstream ssm;\r\n\t\tssm << tmpPth << \"temp\" << baseName << \"Level\" << level << \".tif\";\r\n\t\tTIFF* levelTiff = TIFFOpen(ssm.str().c_str(), \"w8\");\r\n\t\t_levelFiles.push_back(ssm.str());\r\n\t\tunsigned int levelw = (unsigned int)(w / pow(_downsamplePerLevel, (double)level));\r\n\t\tunsigned int levelh = (unsigned int)(h / pow(_downsamplePerLevel, (double)level));\r\n\t\tunsigned int prevLevelw = (unsigned int)(w / pow(_downsamplePerLevel, (double)level - 1));\r\n\t\tunsigned int prevLevelh = (unsigned int)(h / pow(_downsamplePerLevel, (double)level - 1));\r\n\t\tsetTempPyramidTags(levelTiff, levelw, levelh);\r\n\t\tunsigned int nrTilesX = (unsigned int)ceil(float(levelw) / _tileSize);\r\n\t\tunsigned int nrTilesY = (unsigned int)ceil(float(levelh) / _tileSize);\r\n\t\tunsigned int levelTiles = nrTilesX * nrTilesY;\r\n\t\tunsigned int npixels = _tileSize * _tileSize * nrsamples;\r\n\t\tint rowOrg = -_downsamplePerLevel, colOrg = 0;\r\n\t\tfor (unsigned int i = 0; i < levelTiles; ++i) {\r\n\t\t\tif (i % nrTilesX == 0) {\r\n\t\t\t\trowOrg += _downsamplePerLevel;\r\n\t\t\t\tcolOrg = 0;\r\n\t\t\t}\r\n\t\t\tunsigned int xpos = _tileSize * colOrg;\r\n\t\t\tunsigned int ypos = _tileSize * rowOrg;\r\n\t\t\tint inpTilesForOutpTile = _downsamplePerLevel * _downsamplePerLevel;\r\n\t\t\tstd::vector<T*> tiles;\r\n\t\t\tstd::vector<bool> tiles_valid;\r\n\t\t\tfor (int inTileNr = 0; inTileNr < inpTilesForOutpTile; ++inTileNr) {\r\n\t\t\t\ttiles.push_back((T*)_TIFFmalloc(npixels * sizeof(T)));\r\n\t\t\t\ttiles_valid.push_back(false);\r\n\t\t\t}\r\n\t\t\tT* outTile = (T*)_TIFFmalloc(npixels * sizeof(T));\r\n\t\t\tunsigned int size = npixels * sizeof(T);\r\n\t\t\tif (level == 1 && (getCompression() == Compression::JPEG2000)) {\r\n\t\t\t\tfor (int inRow = 0; inRow < _downsamplePerLevel; inRow++) {\r\n\t\t\t\t\tfor (int inCol = 0; inCol < _downsamplePerLevel; inCol++) {\r\n\t\t\t\t\t\tif (xpos + inCol * _tileSize >= prevLevelw || ypos + inRow * _tileSize >= prevLevelh) {\r\n\t\t\t\t\t\t\tstd::fill_n(tiles[inRow * _downsamplePerLevel + inCol], npixels, static_cast<T>(0));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tint tileNr = TIFFComputeTile(prevLevelTiff, xpos + inCol * _tileSize, ypos + inRow * _tileSize, 0, 0);\r\n\t\t\t\t\t\t\tunsigned int outTileSize = _tileSize * _tileSize * nrsamples * (nrbits / 8);\r\n\t\t\t\t\t\t\tint rawSize = TIFFReadRawTile(prevLevelTiff, tileNr, tiles[inRow * _downsamplePerLevel + inCol], outTileSize);\r\n\t\t\t\t\t\t\tif (rawSize > 0) {\r\n\t\t\t\t\t\t\t\ttiles_valid[inRow * _downsamplePerLevel + inCol] = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tstd::fill_n(tiles[inRow * _downsamplePerLevel + inCol], npixels, static_cast<T>(0));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfor (int inRow = 0; inRow < _downsamplePerLevel; inRow++) {\r\n\t\t\t\t\tfor (int inCol = 0; inCol < _downsamplePerLevel; inCol++) {\r\n\t\t\t\t\t\tif (xpos + inCol * _tileSize >= prevLevelw || ypos + inRow * _tileSize >= prevLevelh) {\r\n\t\t\t\t\t\t\tstd::fill_n(tiles[inRow * _downsamplePerLevel + inCol], npixels, static_cast<T>(0));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (TIFFReadTile(prevLevelTiff, tiles[inRow * _downsamplePerLevel + inCol], xpos + inCol * _tileSize, ypos + inRow * _tileSize, 0, 0) < 0) {\r\n\t\t\t\t\t\t\t\tstd::fill_n(tiles[inRow * _downsamplePerLevel + inCol], npixels, static_cast<T>(0));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\ttiles_valid[inRow * _downsamplePerLevel + inCol] = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (std::any_of(tiles_valid.begin(), tiles_valid.end(), [](bool v) { return v; })) {\r\n\t\t\t\tstd::vector<T*> dsTiles;\r\n\t\t\t\tfor (auto tile : tiles) {\r\n\t\t\t\t\tdsTiles.push_back(downscaleTile(tile, _tileSize, nrsamples));\r\n\t\t\t\t}\r\n\t\t\t\tunsigned int dsSize = _tileSize / _downsamplePerLevel;\r\n\t\t\t\tfor (unsigned int y = 0; y < _tileSize; ++y) {\r\n\t\t\t\t\tfor (unsigned int x = 0; x < _tileSize; ++x) {\r\n\t\t\t\t\t\tfor (unsigned int s = 0; s < nrsamples; ++s) {\r\n\t\t\t\t\t\t\tunsigned int outIndex = nrsamples * (y * _tileSize + x) + s;\r\n\t\t\t\t\t\t\tunsigned int colTile = std::floor(x / dsSize);\r\n\t\t\t\t\t\t\tunsigned int rowTile = std::floor(y / dsSize);\r\n\t\t\t\t\t\t\tunsigned int inIndex = y * dsSize * nrsamples + x * nrsamples + s;\r\n\t\t\t\t\t\t\tT* usedTile = dsTiles[rowTile * _downsamplePerLevel + colTile];\r\n\t\t\t\t\t\t\tinIndex = ((y - rowTile * dsSize) * dsSize * nrsamples) + ((x - colTile * dsSize) * nrsamples) + s;\r\n\t\t\t\t\t\t\tT val = *(usedTile + inIndex);\r\n\t\t\t\t\t\t\t*(outTile + outIndex) = val;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tTIFFWriteEncodedTile(levelTiff, i, outTile, npixels * sizeof(T));\r\n\t\t\t\tfor (auto tile : dsTiles) {\r\n\t\t\t\t\t_TIFFfree(tile);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (auto tile : tiles) {\r\n\t\t\t\t_TIFFfree(tile);\r\n\t\t\t}\r\n\t\t\t_TIFFfree(outTile);\r\n\t\t\tcolOrg += _downsamplePerLevel;\r\n\t\t}\r\n\t\tif (level != 1) {\r\n\t\t\tTIFFClose(prevLevelTiff);\r\n\t\t}\r\n\t\tTIFFSetField(_tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER);\r\n\t\tif (!spacing.empty()) {\r\n\t\t\tspacing[0] *= _downsamplePerLevel;\r\n\t\t\tspacing[1] *= _downsamplePerLevel;\r\n\t\t\tdouble pixPerCmX = (1. / spacing[0]) * 10000;\r\n\t\t\tdouble pixPerCmY = (1. / spacing[1]) * 10000;\r\n\t\t\tTIFFSetField(levelTiff, TIFFTAG_XRESOLUTION, pixPerCmX);\r\n\t\t\tTIFFSetField(levelTiff, TIFFTAG_YRESOLUTION, pixPerCmY);\r\n\t\t}\r\n\t\tTIFFClose(levelTiff);\r\n\t}\r\n\t//! Write base directory to disk\r\n\tTIFFWriteDirectory(_tiff);\r\n\treturn 0;\r\n}",
    "int MultiResolutionImageWriter::incorporatePyramid() {\r\n\tunsigned long nrsamples = 0;\r\n\r\n\t//// Now add all the pyramid levels\r\n\tfor (vector<string>::const_iterator it = _levelFiles.begin(); it != _levelFiles.end(); ++it) {\r\n\t\tif (_monitor) {\r\n\t\t\t_monitor->setProgress(3 * (_monitor->maximumProgress() / 4.) + ((static_cast<float>(it - _levelFiles.begin()) + 1.0) / static_cast<float>(_levelFiles.size()))* (_monitor->maximumProgress() / 4.));\r\n\t\t}\r\n\t\tTIFF* level = TIFFOpen(it->c_str(), \"rm\");\r\n\r\n\t\tfloat spacingX = 0, spacingY = 0;\r\n\t\tstd::vector<double> spacing;\r\n\t\tif (TIFFGetField(level, TIFFTAG_XRESOLUTION, &spacingX) == 1) {\r\n\t\t\tif (TIFFGetField(level, TIFFTAG_YRESOLUTION, &spacingY) == 1) {\r\n\t\t\t\tspacing.push_back(1. / (spacingX / (10000.)));\r\n\t\t\t\tspacing.push_back(1. / (spacingY / (10000.)));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tunsigned int levelw, levelh;\r\n\t\tTIFFGetField(level, TIFFTAG_IMAGEWIDTH, &levelw);\r\n\t\tTIFFGetField(level, TIFFTAG_IMAGELENGTH, &levelh);\r\n\t\tsetPyramidTags(_tiff, levelw, levelh);\r\n\t\tTIFFSetField(_tiff, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE);\r\n\t\tTIFFGetField(level, TIFFTAG_SAMPLESPERPIXEL, &nrsamples);\r\n\t\twritePyramidLevel<T>(level, levelw, levelh, nrsamples);\r\n\r\n\t\tsetSpacing(spacing);\r\n\t\tTIFFWriteDirectory(_tiff);\r\n\t\tTIFFClose(level);\r\n\t}\r\n\treturn 0;\r\n}",
    "DATA_TYPE GridManager::getGridDataType( const char * cfilename, GRID_TYPE GridType )\r\n{\t\r\n\tCString filename = cfilename;\r\n\r\n\tGRID_TYPE grid_type = GridType;\r\n\tif( GridType == USE_EXTENSION )\r\n\t\tgrid_type = getGridType( filename );\r\n\t\r\n\tif( grid_type == GEOTIFF_GRID) //added 8/26/05 --ah\r\n\t{\r\n\t\tDATA_TYPE type = UNKNOWN_TYPE;\r\n\t\tTIFF *tiff = XTIFFOpen((char *)cfilename, \"r\"); // TIFF-level descriptor\r\n\t\tif(tiff)\r\n\t\t{\r\n\t\t\tuint16_t sampleFormat, bitsPerSample;\r\n\r\n\t\t\tTIFFGetField(tiff,TIFFTAG_SAMPLEFORMAT, &sampleFormat);\r\n\t\t\tTIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\r\n\t\t\tif(sampleFormat == 1)\r\n\t\t\t{//type is unsigned int\r\n\t\t\t\ttype = SHORT_TYPE;\r\n\t\t\t}\r\n\t\t\telse if(sampleFormat == 2)\r\n\t\t\t{//type is signed int\r\n\t\t\t\ttype = LONG_TYPE;\r\n\t\t\t}\r\n\t\t\telse if(sampleFormat == 3)\r\n\t\t\t{//IEEE floating-point value\r\n\t\t\t\tif(bitsPerSample == 32)\r\n\t\t\t\t{\r\n\t\t\t\t\ttype = FLOAT_TYPE;\r\n\t\t\t\t}\r\n\t\t\t\telse if(bitsPerSample == 64)\r\n\t\t\t\t{\r\n\t\t\t\t\ttype = DOUBLE_TYPE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//TODO: may want to check for other sample formats:\r\n\t\t\t//4 = unknown, 5 = complex int, 6 = complex float or double\r\n\t\t\t//0 = undefined -> check bits per sample and samples per pixel\r\n\t\t\t//to determine size.\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\ttype = UNKNOWN_TYPE;\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\t\tXTIFFClose(tiff);\r\n\r\n\t\treturn type;\r\n\t}\r\n\telse if( grid_type == ASCII_GRID )\r\n\t\treturn DOUBLE_TYPE;\r\n\telse if( grid_type == BINARY_GRID )\r\n\t{\t\r\n\t\tFILE * in = fopen( filename, \"rb\" );\r\n\t\tif( !in )\r\n\t\t\treturn INVALID_DATA_TYPE;\r\n\t\telse\r\n\t\t{\tlong ncols;\r\n\t\t\tfread( &ncols, sizeof(int),1,in);\r\n\t\t\tlong nrows;\r\n\t\t\tfread( &nrows, sizeof(int),1,in);\r\n\t\t\tdouble dx;\r\n\t\t\tfread( &dx, sizeof(double),1,in);\r\n\t\t\tdouble dy;\r\n\t\t\tfread( &dy, sizeof(double),1,in);\r\n\t\t\tdouble xllcenter;\r\n\t\t\tfread( &xllcenter, sizeof(double),1,in);\r\n\t\t\tdouble yllcenter;\r\n\t\t\tfread( &yllcenter, sizeof(double),1,in);\r\n\t\t\tDATA_TYPE data_type;\r\n\t\t\tfread( &data_type, sizeof(DATA_TYPE),1,in);\r\n\t\t\tfclose( in );\r\n\t\t\treturn data_type;\r\n\t\t}\r\n\t}\r\n\telse if( grid_type == SDTS_GRID )\r\n\t\treturn DOUBLE_TYPE;\r\n\telse if( grid_type == ESRI_GRID )\r\n\t{\tif( filename.GetLength() <= 0 )\r\n\t\t\treturn INVALID_DATA_TYPE;\t\t\r\n\t\telse\r\n\t\t{\tDATA_TYPE data_type = esri_data_type(filename);\r\n\t\t\treturn data_type;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn INVALID_DATA_TYPE;\r\n}",
    "STDMETHODIMP CUtils::IsTiffGrid(BSTR Filename, VARIANT_BOOL* retVal)\r\n{\r\n\tAFX_MANAGE_STATE(AfxGetStaticModuleState());\r\n\t*retVal = VARIANT_FALSE;\r\n\r\n\ttry\r\n\t{\r\n\t\tUSES_CONVERSION;\r\n\t\tconst char* name = OLE2CA(Filename);\r\n\t\tTIFF* tiff = XTIFFOpen(name, \"r\"); // TIFF-level descriptor\r\n\t\tif (tiff)\r\n\t\t{\r\n\t\t\tint w = 0, h = 0;\r\n\r\n\t\t\ttdir_t d = 0;\r\n\t\t\tTIFFSetDirectory(tiff, d);\r\n\r\n\t\t\tuint32_t SamplesPerPixel = 0;\r\n\r\n\t\t\tTIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &w);\r\n\t\t\tTIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &h);\r\n\t\t\tTIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &SamplesPerPixel);\r\n\r\n\t\t\tuint16_t photo = 0;\r\n\t\t\t// If it's a color-mapped palette, consider it an image --\r\n\t\t\t// it's probably an image (USGS DLG or USGS Quad Map most commonly)\r\n\t\t\tTIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &photo);\r\n\r\n\t\t\tXTIFFClose(tiff);\r\n\r\n\t\t\tif (photo == PHOTOMETRIC_PALETTE) {}\r\n\t\t\telse if (SamplesPerPixel == 1)\r\n\t\t\t{\r\n\t\t\t\t*retVal = VARIANT_TRUE;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcatch (...)\r\n\t{\r\n\t\tCallbackHelper::ErrorMsg(\"Exception in Utils.IsTiffGrid\");\r\n\t}\r\n\treturn S_OK;\r\n}",
    "CML::Pair<CML::FloatImage, CML::Image> CML::loadTiffImage(const uint8_t *str, size_t lenght) {\r\n    std::istringstream input_TIFF_stream(std::string((char *)str, lenght));\r\n\r\n//Populate input_TIFF_stream with TIFF image data\r\n//...\r\n\r\n    TIFF *tif = TIFFStreamOpen(\"MemTIFF\", &input_TIFF_stream);\r\n\r\n    if (!tif) {\r\n        throw std::runtime_error(\"Can't open the tiff file\");\r\n    }\r\n\r\n    uint32_t height, width, bitspersample;\r\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\r\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\r\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\r\n\r\n    if (bitspersample == 8) {\r\n        return loadTiffImage<uint8_t, 8>(tif, width, height);\r\n    }\r\n    if (bitspersample == 16) {\r\n        return loadTiffImage<uint16_t, 16>(tif, width, height);\r\n    }\r\n    if (bitspersample == 32) {\r\n        return loadTiffImage<uint32_t, 32>(tif, width, height);\r\n    }\r\n    if (bitspersample == 64) {\r\n        return loadTiffImage<uint64_t, 64>(tif, width, height);\r\n    }\r\n\r\n    throw std::runtime_error(\"Unsupported tiff bit per sample : \" + std::to_string(bitspersample));\r\n\r\n}",
    "bool getCurrentDirectoryInfo(TIFF* tif, Vec3c& dimensions, ImageDataType& dataType, size_t& pixelSizeBytes,\n\t\t\t\tcoord_t& imageJDepth, uint64_t& imageJOffset,\n\t\t\t\tstring& reason)\n\t\t\t{\n\t\t\t\treason = \"\";\n\n\t\t\t\tuint16_t tiffDatatype = 0;\n\t\t\t\tuint32_t sampleFormat = 0;\n\t\t\t\tuint32_t tiffWidth = 0;\n\t\t\t\tuint32_t tiffHeight = 0;\n\t\t\t\tuint32_t tiffDepth = 0;\n\t\t\t\tuint16_t samplesPerPixel = 0;\n\t\t\t\tuint16_t bitsPerSample = 0;\n\t\t\t\tchar* description = 0;\n\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_DATATYPE, &tiffDatatype);\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_IMAGEWIDTH, &tiffWidth);\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_IMAGELENGTH, &tiffHeight);\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_IMAGEDEPTH, &tiffDepth);\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_IMAGEDESCRIPTION, &description);\n\n\t\t\t\tdimensions = Vec3c(tiffWidth, tiffHeight, tiffDepth);\n\t\t\t\timageJDepth = dimensions.z;\n\t\t\t\timageJOffset = 0;\n\n\t\t\t\t// Test if this file is a ImageJ fake tiff.\n\t\t\t\tif (description)\n\t\t\t\t{\n\t\t\t\t\tstring desc = description;\n\t\t\t\t\tif (startsWith(desc, \"ImageJ=\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tauto start = desc.find(\"images=\");\n\t\t\t\t\t\tif (start != string::npos)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstart += string(\"images=\").length();\n\t\t\t\t\t\t\tauto end = desc.find(\"\\n\", start);\n\t\t\t\t\t\t\tif (end != string::npos)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstring depth = desc.substr(start, end - start);\n\t\t\t\t\t\t\t\timageJDepth = fromString<uint32_t>(depth);\n\n\t\t\t\t\t\t\t\tuint64_t* stripOffsets = 0;\n\t\t\t\t\t\t\t\tint result = TIFFGetField(tif, TIFFTAG_STRIPOFFSETS, &stripOffsets);\n\t\t\t\t\t\t\t\timageJOffset = stripOffsets[0];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tswitch (sampleFormat)\n\t\t\t\t{\n\t\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\t\tif (bitsPerSample == 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tdataType = ImageDataType::UInt8;\n\t\t\t\t\t\tpixelSizeBytes = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(bitsPerSample == 16)\n\t\t\t\t\t{\n\t\t\t\t\t\tdataType = ImageDataType::UInt16;\n\t\t\t\t\t\tpixelSizeBytes = 2;\n\t\t\t\t\t}\n\t\t\t\t\telse if (bitsPerSample == 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tdataType = ImageDataType::UInt32;\n\t\t\t\t\t\tpixelSizeBytes = 4;\n\t\t\t\t\t}\n\t\t\t\t\telse if (bitsPerSample == 64)\n\t\t\t\t\t{\n\t\t\t\t\t\tdataType = ImageDataType::UInt64;\n\t\t\t\t\t\tpixelSizeBytes = 8;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\treason = \"Unsupported unsigned integer data type.\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\t\treason = \"Unsupported signed integer data type.\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\t\tif (bitsPerSample == 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tdataType = ImageDataType::Float32;\n\t\t\t\t\t\tpixelSizeBytes = 4;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\treason = \"Unsupported floating point data type.\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_COMPLEXINT:\n\t\t\t\t\treason = \"Unsupported complex integer data type.\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_COMPLEXIEEEFP:\n\t\t\t\t\tif (bitsPerSample == 64)\n\t\t\t\t\t{\n\t\t\t\t\t\tdataType = ImageDataType::Complex32;\n\t\t\t\t\t\tpixelSizeBytes = 8;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\treason = \"Unsupported complex floating point data type.\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_VOID:\n\t\t\t\t\t// Unknown data type\n\n\t\t\t\t\t// Check older tag\n\t\t\t\t\tswitch (tiffDatatype)\n\t\t\t\t\t{\n\t\t\t\t\tcase TIFF_BYTE:\n\t\t\t\t\t\tdataType = ImageDataType::UInt8;\n\t\t\t\t\t\tpixelSizeBytes = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\t\tdataType = ImageDataType::UInt16;\n\t\t\t\t\t\tpixelSizeBytes = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIFF_LONG:\n\t\t\t\t\t\tdataType = ImageDataType::UInt32;\n\t\t\t\t\t\tpixelSizeBytes = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIFF_LONG8:\n\t\t\t\t\t\tdataType = ImageDataType::UInt64;\n\t\t\t\t\t\tpixelSizeBytes = 8;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\t\tdataType = ImageDataType::Float32;\n\t\t\t\t\t\tpixelSizeBytes = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIFF_NOTYPE:\n\t\t\t\t\t\tdataType = ImageDataType::Unknown;\n\t\t\t\t\t\tpixelSizeBytes = bitsPerSample / 8;\n\n\t\t\t\t\t\t//// Guess data type (this is needed to load, e.g., tiff files generated by ImageJ)\n\t\t\t\t\t\t//if (pixelSizeBytes == 1)\n\t\t\t\t\t\t//\tdataType = ImageDataType::UInt8;\n\t\t\t\t\t\t//else if (pixelSizeBytes == 2)\n\t\t\t\t\t\t//\tdataType = ImageDataType::UInt16;\n\t\t\t\t\t\t//else if (pixelSizeBytes == 4)\n\t\t\t\t\t\t//\tdataType = ImageDataType::Float32;\n\t\t\t\t\t\t//else if (pixelSizeBytes == 8)\n\t\t\t\t\t\t//\tdataType = ImageDataType::UInt64;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (samplesPerPixel != 1)\n\t\t\t\t\treason = \"Only grayscale images are supported.\";\n\n\t\t\t\tlastTiffErrorMessage = reason;\n\n\t\t\t\treturn reason.length() <= 0;\n\t\t\t}",
    "int readTiffRGBA(char const *const filename, VkExtent2D *const size,\n                 VkSubresourceLayout *layout, uint8_t *const data)\n{\n    const uint32_t nchannels = 4;\n\n    TIFF *tif = TIFFOpen(filename, \"r\");\n    if (tif == NULL)\n        return 1;\n\n    if (data == NULL) {\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &size->height);\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &size->width);\n    } else {\n        if (layout == NULL || size == NULL)\n            goto cleanup;\n\n        char *const temp = (char *)malloc(nchannels * size->width * size->height);\n        if (!TIFFReadRGBAImage(tif, size->width, size->height, (uint32_t *) temp, 0))\n            goto cleanup;\n\n        for (size_t x = 0; x < size->width; x++)\n            for (size_t y = 0; y < size->height; y++)\n                for (size_t ch = 0; ch < nchannels; ch++) {\n                    data[ch + x * nchannels + y * layout->rowPitch] =\n                        temp[ch + x * nchannels + y * size->width * nchannels];\n                }\n        free(temp);\n    }\n\n    TIFFClose(tif);\n    return 0;\ncleanup:\n    TIFFClose(tif);\n    return 1;\n}",
    "void TIFFFileImageProvider::progress()\n{\n    if (!p) {\n        p = new TIFFPrivate(this);\n        p->tif = TIFFOpen(filename.c_str(), \"rm\");\n        if (!p->tif)\n            return onFinish(makeError(\"cannot read tiff \" + filename));\n\n        int r = 0;\n        r += TIFFGetField(p->tif, TIFFTAG_IMAGEWIDTH, &p->w);\n        r += TIFFGetField(p->tif, TIFFTAG_IMAGELENGTH, &p->h);\n\n        if (r != 2)\n            return onFinish(makeError(\"can not read tiff of unknown size\"));\n\n        r = TIFFGetField(p->tif, TIFFTAG_SAMPLESPERPIXEL, &p->spp);\n        if (!r)\n            p->spp = 1;\n\n        r = TIFFGetField(p->tif, TIFFTAG_BITSPERSAMPLE, &p->bps);\n        if (!r)\n            p->bps = 1;\n\n        r = TIFFGetField(p->tif, TIFFTAG_SAMPLEFORMAT, &p->fmt);\n        if (!r)\n            p->fmt = SAMPLEFORMAT_UINT;\n\n        if (p->fmt == SAMPLEFORMAT_COMPLEXINT || p->fmt == SAMPLEFORMAT_COMPLEXIEEEFP) {\n            p->spp *= 2;\n            p->bps /= 2;\n        }\n        if (p->fmt == SAMPLEFORMAT_COMPLEXINT)\n            p->fmt = SAMPLEFORMAT_INT;\n        if (p->fmt == SAMPLEFORMAT_COMPLEXIEEEFP)\n            p->fmt = SAMPLEFORMAT_IEEEFP;\n\n        uint16_t planarity;\n        r = TIFFGetField(p->tif, TIFFTAG_PLANARCONFIG, &planarity);\n        if (r != 1)\n            planarity = PLANARCONFIG_CONTIG;\n        p->broken = planarity == PLANARCONFIG_SEPARATE;\n\n        uint32_t scanline_size = (p->w * p->spp * p->bps) / 8;\n        int rbps = (p->bps / 8) ? (p->bps / 8) : 1;\n        p->sls = TIFFScanlineSize(p->tif);\n        if ((int)scanline_size != p->sls)\n            fprintf(stderr, \"scanline_size,sls = %d,%d\\n\", (int)scanline_size, p->sls);\n        //assert((int)scanline_size == sls);\n        if (!p->broken)\n            assert((int)scanline_size == p->sls);\n        assert((int)scanline_size >= p->sls);\n        p->data = (float*)malloc(p->w * p->h * p->spp * rbps);\n        p->buf = (uint8_t*)_TIFFmalloc(scanline_size);\n        p->curh = 0;\n\n        if (TIFFIsTiled(p->tif) || p->fmt != SAMPLEFORMAT_IEEEFP || p->broken || rbps != sizeof(float)) {\n#ifdef USE_IIO\n            std::shared_ptr<Image> image = load_from_iio(filename);\n            if (!image) {\n                onFinish(makeError(\"iio: cannot load image '\" + filename + \"'\"));\n            } else {\n                onFinish(image);\n            }\n#else\n            onFinish(makeError(\"cannot load image '\" + filename + \"'\"));\n#endif\n        }\n    } else if (p->curh < p->h) {\n        int r = TIFFReadScanline(p->tif, p->buf, p->curh);\n        if (r < 0) {\n            onFinish(makeError(\"error reading tiff row \" + std::to_string(p->curh)));\n        }\n        memcpy(p->data + p->curh * p->sls / sizeof(float), p->buf, p->sls);\n        p->curh++;\n    } else {\n        std::shared_ptr<Image> image = std::make_shared<Image>(p->data, p->w, p->h, p->spp);\n        onFinish(image);\n        p->data = nullptr;\n    }\n}",
    "ILboolean iLoadTiffInternal()\n{\n\tTIFF\t *tif;\n\tuint16\t photometric, planarconfig, orientation;\n\tuint16\t samplesperpixel, bitspersample, *sampleinfo, extrasamples;\n\tuint32\t w, h, d, linesize, tilewidth, tilelength;\n\tILubyte  *pImageData;\n\tILuint\t i, ProfileLen, DirCount = 0;\n\tvoid\t *Buffer;\n\tILimage  *Image, *TempImage;\n\tILushort si;\n        ILfloat  x_position, x_resolution, y_position, y_resolution;\n\t//TIFFRGBAImage img;\n\t//char emsg[1024];\n\n\t// to avoid high order bits garbage when used as shorts\n\tw = h = d = linesize = tilewidth = tilelength = 0;\n\n\tif (iCurImage == NULL) {\n\t\tilSetError(IL_ILLEGAL_OPERATION);\n\t\treturn IL_FALSE;\n\t}\n\n\tTIFFSetWarningHandler (NULL);\n\tTIFFSetErrorHandler   (NULL);\n\n\t//for debugging only\n\t//TIFFSetWarningHandler(warningHandler);\n\t//TIFFSetErrorHandler(errorHandler);\n\n\ttif = iTIFFOpen((char*)\"r\");\n\tif (tif == NULL) {\n\t\tilSetError(IL_COULD_NOT_OPEN_FILE);\n\t\treturn IL_FALSE;\n\t}\n\n\tdo {\n\t\tDirCount++;\n\t} while (TIFFReadDirectory(tif));\n\n\t/*\n\t if (!ilTexImage(1, 1, 1, 1, IL_RGBA, IL_UNSIGNED_BYTE, NULL)) {\n\t\t TIFFClose(tif);\n\t\t return IL_FALSE;\n\t}\n\tImage = iCurImage;\n\tfor (i = 1; i < DirCount; i++) {\n\t\t Image->Next = ilNewImage(1, 1, 1, 1, 1);\n\t\tif (Image->Next == NULL) {\n\t\t\tTIFFClose(tif);\n\t\t\treturn IL_FALSE;\n\t\t}\n\t\tImage = Image->Next;\n\t}\n\tiCurImage->NumNext = DirCount - 1;\n\t*/\n\tImage = NULL;\n\tfor (i = 0; i < DirCount; i++) {\n\t\tTIFFSetDirectory(tif, (tdir_t)i);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH,  &w);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_IMAGEDEPTH,\t\t&d); //TODO: d is ignored...\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE,\t&bitspersample);\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,\t&extrasamples, &sampleinfo);\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_ORIENTATION, \t&orientation);\n\n\t\tlinesize = (uint32)TIFFScanlineSize(tif);\n\t\t\n\t\t//added 2003-08-31\n\t\t//1 bpp tiffs are not neccessarily greyscale, they can\n\t\t//have a palette (photometric == 3)...get this information\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_PHOTOMETRIC,  &photometric);\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planarconfig);\n\n\t\t//special-case code for frequent data cases that may be read more\n\t\t//efficiently than with the TIFFReadRGBAImage() interface.\n\t\t\n\t\t//added 2004-05-12\n\t\t//Get tile sizes and use TIFFReadRGBAImage() for tiled images for now\n\t\ttilewidth = w; tilelength = h;\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_TILEWIDTH,  &tilewidth);\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_TILELENGTH, &tilelength);\n\n\n\t\tif (extrasamples == 0\n\t\t\t&& samplesperpixel == 1  //luminance or palette\n\t\t\t&& (bitspersample == 8 || bitspersample == 1 || bitspersample == 16)\n\t\t\t&& (photometric == PHOTOMETRIC_MINISWHITE\n\t\t\t\t|| photometric == PHOTOMETRIC_MINISBLACK\n\t\t\t\t|| photometric == PHOTOMETRIC_PALETTE)\n\t\t\t&& (orientation == ORIENTATION_TOPLEFT || orientation == ORIENTATION_BOTLEFT)\n\t\t\t&& tilewidth == w && tilelength == h\n\t\t\t) {\n\t\t\tILubyte* strip;\n\t\t\ttsize_t stripsize;\n\t\t\tILuint y;\n\t\t\tuint32 rowsperstrip, j, linesread;\n\n\t\t\t//TODO: 1 bit/pixel images should not be stored as 8 bits...\n\t\t\t//(-> add new format)\n\t\t\tif (!Image) {\n\t\t\t\tint type = IL_UNSIGNED_BYTE;\n\t\t\t\tif (bitspersample == 16) type = IL_UNSIGNED_SHORT;\n\t\t\t\tif (!ilTexImage(w, h, 1, 1, IL_LUMINANCE, type, NULL)) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = iCurImage;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tImage->Next = ilNewImage(w, h, 1, 1, 1);\n\t\t\t\tif (Image->Next == NULL) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = Image->Next;\n\t\t\t}\n\n\t\t\tif (photometric == PHOTOMETRIC_PALETTE) { //read palette\n\t\t\t\tuint16 *red, *green, *blue;\n\t\t\t\t//ILboolean is16bitpalette = IL_FALSE;\n\t\t\t\tILubyte *entry;\n\t\t\t\tuint32 count = 1 << bitspersample, j;\n\t\t\n\t\t\t\tTIFFGetField(tif, TIFFTAG_COLORMAP, &red, &green, &blue);\n\n\t\t\t\tImage->Format = IL_COLOUR_INDEX;\n\t\t\t\tImage->Pal.PalSize = (count)*3;\n\t\t\t\tImage->Pal.PalType = IL_PAL_RGB24;\n\t\t\t\tImage->Pal.Palette = (ILubyte*)ialloc(Image->Pal.PalSize);\n\t\t\t\tentry = Image->Pal.Palette;\n\t\t\t\tfor (j = 0; j < count; ++j) {\n\t\t\t\t\tentry[0] = (ILubyte)(red[j] >> 8);\n\t\t\t\t\tentry[1] = (ILubyte)(green[j] >> 8);\n\t\t\t\t\tentry[2] = (ILubyte)(blue[j] >> 8);\n\n\t\t\t\t\tentry += 3;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\t\t\tstripsize = TIFFStripSize(tif);\n\n\t\t\tstrip = (ILubyte*)ialloc(stripsize);\n\n\t\t\tif (bitspersample == 8 || bitspersample == 16) {\n\t\t\t\tILubyte *dat = Image->Data;\n\t\t\t\tfor (y = 0; y < h; y += rowsperstrip) {\n\t\t\t\t\t//the last strip may contain less data if the image\n\t\t\t\t\t//height is not evenly divisible by rowsperstrip\n\t\t\t\t\tif (y + rowsperstrip > h) {\n\t\t\t\t\t\tstripsize = linesize*(h - y);\n\t\t\t\t\t\tlinesread = h - y;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tlinesread = rowsperstrip;\n\n\t\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, 0), strip, stripsize) == -1) {\n\t\t\t\t\t\tilSetError(IL_LIB_TIFF_ERROR);\n\t\t\t\t\t\tifree(strip);\n\t\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISWHITE) { //invert channel\n\t\t\t\t\t\tuint32 k, t2;\n\t\t\t\t\t\tfor (j = 0; j < linesread; ++j) {\n\t\t\t\t\t\t\tt2 = j*linesize;\n\t\t\t\t\t\t\t//this works for 16bit images as well: the two bytes\n\t\t\t\t\t\t\t//making up a pixel can be inverted independently\n\t\t\t\t\t\t\tfor (k = 0; k < Image->Bps; ++k)\n\t\t\t\t\t\t\t\tdat[k] = ~strip[t2 + k];\n\t\t\t\t\t\t\tdat += w;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfor(j = 0; j < linesread; ++j)\n\t\t\t\t\t\t\tmemcpy(&Image->Data[(y + j)*Image->Bps], &strip[j*linesize], Image->Bps);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (bitspersample == 1) {\n\t\t\t\t//TODO: add a native format to devil, so we don't have to\n\t\t\t\t//unpack the values here\n\t\t\t\tILubyte mask, curr, *dat = Image->Data;\n\t\t\t\tuint32 k, sx, t2;\n\t\t\t\tfor (y = 0; y < h; y += rowsperstrip) {\n\t\t\t\t\t//the last strip may contain less data if the image\n\t\t\t\t\t//height is not evenly divisible by rowsperstrip\n\t\t\t\t\tif (y + rowsperstrip > h) {\n\t\t\t\t\t\tstripsize = linesize*(h - y);\n\t\t\t\t\t\tlinesread = h - y;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tlinesread = rowsperstrip;\n\n\t\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, 0), strip, stripsize) == -1) {\n\t\t\t\t\t\tilSetError(IL_LIB_TIFF_ERROR);\n\t\t\t\t\t\tifree(strip);\n\t\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < linesread; ++j) {\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tsx = 0;\n\t\t\t\t\t\tt2 = j*linesize;\n\t\t\t\t\t\twhile (k < w) {\n\t\t\t\t\t\t\tcurr = strip[t2 + sx];\n\t\t\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISWHITE)\n\t\t\t\t\t\t\t\tcurr = ~curr;\n\t\t\t\t\t\t\tfor (mask = 0x80; mask != 0 && k < w; mask >>= 1){\n\t\t\t\t\t\t\t\tif((curr & mask) != 0)\n\t\t\t\t\t\t\t\t\tdat[k] = 255;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tdat[k] = 0;\n\t\t\t\t\t\t\t\t++k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++sx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdat += w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tifree(strip);\n\n\t\t\tif(orientation == ORIENTATION_TOPLEFT)\n\t\t\t\tImage->Origin = IL_ORIGIN_UPPER_LEFT;\n\t\t\telse if(orientation == ORIENTATION_BOTLEFT)\n\t\t\t\tImage->Origin = IL_ORIGIN_LOWER_LEFT;\n\t\t}\n\t\t//for 16bit rgb images:\n\t\telse if (extrasamples == 0\n\t\t\t&& samplesperpixel == 3\n\t\t\t&& (bitspersample == 8 || bitspersample == 16)\n\t\t\t&& photometric == PHOTOMETRIC_RGB\n\t\t\t&& planarconfig == 1\n\t\t\t&& (orientation == ORIENTATION_TOPLEFT || orientation == ORIENTATION_BOTLEFT)\n\t\t\t&& tilewidth == w && tilelength == h\n\t\t\t) {\n\t\t\tILubyte *strip, *dat;\n\t\t\ttsize_t stripsize;\n\t\t\tILuint y;\n\t\t\tuint32 rowsperstrip, j, linesread;\n\n\t\t\tif (!Image) {\n\t\t\t\tint type = IL_UNSIGNED_BYTE;\n\t\t\t\tif (bitspersample == 16) type = IL_UNSIGNED_SHORT;\n\t\t\t\tif(!ilTexImage(w, h, 1, 3, IL_RGB, type, NULL)) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = iCurImage;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tImage->Next = ilNewImage(w, h, 1, 1, 1);\n\t\t\t\tif(Image->Next == NULL) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = Image->Next;\n\t\t\t}\n\n\t\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\t\t\tstripsize = TIFFStripSize(tif);\n\n\t\t\tstrip = (ILubyte*)ialloc(stripsize);\n\n\t\t\tdat = Image->Data;\n\t\t\tfor (y = 0; y < h; y += rowsperstrip) {\n\t\t\t\t//the last strip may contain less data if the image\n\t\t\t\t//height is not evenly divisible by rowsperstrip\n\t\t\t\tif (y + rowsperstrip > h) {\n\t\t\t\t\tstripsize = linesize*(h - y);\n\t\t\t\t\tlinesread = h - y;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tlinesread = rowsperstrip;\n\n\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, 0), strip, stripsize) == -1) {\n\t\t\t\t\tilSetError(IL_LIB_TIFF_ERROR);\n\t\t\t\t\tifree(strip);\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\n\t\t\t\tfor(j = 0; j < linesread; ++j)\n\t\t\t\t\t\tmemcpy(&Image->Data[(y + j)*Image->Bps], &strip[j*linesize], Image->Bps);\n\t\t\t}\n\n\t\t\tifree(strip);\n\t\t\t\n\t\t\tif(orientation == ORIENTATION_TOPLEFT)\n\t\t\t\tImage->Origin = IL_ORIGIN_UPPER_LEFT;\n\t\t\telse if(orientation == ORIENTATION_BOTLEFT)\n\t\t\t\tImage->Origin = IL_ORIGIN_LOWER_LEFT;\n\t\t}/*\n\t\telse if (extrasamples == 0 && samplesperpixel == 3  //rgb\n\t\t\t\t\t&& (bitspersample == 8 || bitspersample == 1 || bitspersample == 16)\n\t\t\t\t\t&& photometric == PHOTOMETRIC_RGB\n\t\t\t\t\t&& (planarconfig == PLANARCONFIG_CONTIG || planarcon\n\t\t\t\t\t\t&& (orientation == ORIENTATION_TOPLEFT || orientation == ORIENTATION_BOTLEFT)\n\t\t\t\t\t) {\n\t\t}\n\t\t\t\t*/\n\t\telse {\n\t\t\t\t//not direclty supported format\n\t\t\tif(!Image) {\n\t\t\t\tif(!ilTexImage(w, h, 1, 4, IL_RGBA, IL_UNSIGNED_BYTE, NULL)) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = iCurImage;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tImage->Next = ilNewImage(w, h, 1, 4, 1);\n\t\t\t\tif(Image->Next == NULL) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = Image->Next;\n\t\t\t}\n\n\t\t\tif (samplesperpixel == 4) {\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &extrasamples, &sampleinfo);\n\t\t\t\tif (!sampleinfo || sampleinfo[0] == EXTRASAMPLE_UNSPECIFIED) {\n\t\t\t\t\tsi = EXTRASAMPLE_ASSOCALPHA;\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_EXTRASAMPLES, 1, &si);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t if (!ilResizeImage(Image, Image->Width, Image->Height, 1, 4, 1)) {\n\t\t\t\t TIFFClose(tif);\n\t\t\t\t return IL_FALSE;\n\t\t\t }\n\t\t\t */\n\t\t\tImage->Format = IL_RGBA;\n\t\t\tImage->Type = IL_UNSIGNED_BYTE;\n\t\n\t\t\t// Siigron: added u_long cast to shut up compiler warning\n\t\t\t//2003-08-31: changed flag from 1 (exit on error) to 0 (keep decoding)\n\t\t\t//this lets me view text.tif, but can give crashes with unsupported\n\t\t\t//tiffs...\n\t\t\t//2003-09-04: keep flag 1 for official version for now\n\t\t\tif (!TIFFReadRGBAImage(tif, Image->Width, Image->Height, (uint32*)Image->Data, 0)) {\n\t\t\t\tTIFFClose(tif);\n\t\t\t\tilSetError(IL_LIB_TIFF_ERROR);\n\t\t\t\treturn IL_FALSE;\n\t\t\t}\n\t\t\tImage->Origin = IL_ORIGIN_LOWER_LEFT;  // eiu...dunno if this is right\n\n#ifdef __BIG_ENDIAN__ //TIFFReadRGBAImage reads abgr on big endian, convert to rgba\n\t\t\tEndianSwapData(Image);\n#endif\n\n\t\t\t/*\n\t\t\t The following switch() should not be needed,\n\t\t\t because we take care of the special cases that needed\n\t\t\t these conversions. But since not all special cases\n\t\t\t are handled right now, keep it :)\n\t\t\t */\n\t\t\t//TODO: put switch into the loop??\n\t\t\tTempImage = iCurImage;\n\t\t\tiCurImage = Image; //ilConvertImage() converts iCurImage\n\t\t\tswitch (samplesperpixel)\n\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\t//added 2003-08-31 to keep palettized tiffs colored\n\t\t\t\t\tif(photometric != 3)\n\t\t\t\t\t\tilConvertImage(IL_LUMINANCE, IL_UNSIGNED_BYTE);\n\t\t\t\t\telse //strip alpha as tiff supports no alpha palettes\n\t\t\t\t\t\tilConvertImage(IL_RGB, IL_UNSIGNED_BYTE);\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 3:\n\t\t\t\t\t//TODO: why the ifdef??\n#ifdef __LITTLE_ENDIAN__\n\t\t\t\t\tilConvertImage(IL_RGB, IL_UNSIGNED_BYTE);\n#endif\t\t\t\n\t\t\t\t\tbreak; \n\t\t\t\t\t\n\t\t\t\tcase 4:\n\t\t\t\t\tpImageData = Image->Data;\n\t\t\t\t\t//removed on 2003-08-26...why was this here? libtiff should and does\n\t\t\t\t\t//take care of these things???\n\t\t\t\t\t/*\t\t\t\n\t\t\t\t\t//invert alpha\n#ifdef __LITTLE_ENDIAN__\n\t\t\t\t\tpImageData += 3;\n#endif\t\t\t\n\t\t\t\t\tfor (i = Image->Width * Image->Height; i > 0; i--) {\n\t\t\t\t\t\t*pImageData ^= 255;\n\t\t\t\t\t\tpImageData += 4;\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tiCurImage = TempImage;\n\t\t\t\n\t\t} //else not directly supported format\n\n\t\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &ProfileLen, &Buffer)) {\n\t\t\tif (Image->Profile && Image->ProfileSize)\n\t\t\t\tifree(Image->Profile);\n\t\t\tImage->Profile = (ILubyte*)ialloc(ProfileLen);\n\t\t\tif (Image->Profile == NULL) {\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn IL_FALSE;\n\t\t\t}\n\n\t\t\tmemcpy(Image->Profile, Buffer, ProfileLen);\n\t\t\tImage->ProfileSize = ProfileLen;\n\n\t\t\t//removed on 2003-08-24 as explained in bug 579574 on sourceforge\n\t\t\t//_TIFFfree(Buffer);\n\t\t}\n\n                // dangelo: read offset from tiff tags.\n                //If nothing is stored in these tags, then this must be an \"uncropped\" TIFF \n                //file, in which case, the \"full size\" width/height is the same as the \n                //\"cropped\" width and height\n                //\n                // the full size is currently not supported by DevIL\n                //if (TIFFGetField(tif, TIFFTAG_PIXAR_IMAGEFULLWIDTH, &(c->full_width)) ==\n                //        0)\n                //    (c->full_width = c->cropped_width);\n                //if (TIFFGetField(tif, TIFFTAG_PIXAR_IMAGEFULLLENGTH, &(c->full_height)) ==\n                //        0)\n                //    (c->full_height = c->cropped_height);\n\n                if (TIFFGetField(tif, TIFFTAG_XPOSITION, &x_position) == 0)\n                    x_position = 0;\n                if (TIFFGetField(tif, TIFFTAG_XRESOLUTION, &x_resolution) == 0)\n                    x_resolution = 0;\n                if (TIFFGetField(tif, TIFFTAG_YPOSITION, &y_position) == 0)\n                    y_position = 0;\n                if (TIFFGetField(tif, TIFFTAG_YRESOLUTION, &y_resolution) == 0)\n                    y_resolution = 0;\n\n                //offset in pixels of \"cropped\" image from top left corner of \n                //full image (rounded to nearest integer)\n                Image->OffX = (uint32) ((x_position * x_resolution) + 0.49);\n                Image->OffY = (uint32) ((y_position * y_resolution) + 0.49);\n                \n\n\t\t/*\n\t\t Image = Image->Next;\n\t\t if (Image == NULL)  // Should never happen except when we reach the end, but check anyway.\n\t\t break;\n\t\t */ \n\t} //for tiff directories\n\n\tTIFFClose(tif);\n\n\treturn ilFixImage();\n}",
    "static Status libtiff_process(TiffDecHandle handle, const TiffDecInput* in, TiffDecOutput* out) {\n    tiff_dec_libtiff_t* state = (tiff_dec_libtiff_t*)handle;\n\n    state->data->msg.clear();\n\n    TiffStream stream;\n    stream.data = (char*)in->buffer;\n    stream.pos = 0;\n    stream.size = in->size;\n\n    TIFF* inTiff = TIFFClientOpen(\"Memory\", \"r\", (thandle_t)&stream, tiff_Read, tiff_Write, tiff_Seek, tiff_Close,\n                                  tiff_Size, tiff_Map, tiff_Unmap);\n\n    uint32 width = 0;\n    uint32 height = 0;\n    uint16 bitsPerSample = 0;\n    uint16 nsamples = 0;\n    uint16 photometric = 0;\n    uint16 subsampling[2] = {0, 0};\n\n    TIFFGetField(inTiff, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(inTiff, TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetField(inTiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n    TIFFGetField(inTiff, TIFFTAG_SAMPLESPERPIXEL, &nsamples);\n    TIFFGetField(inTiff, TIFFTAG_PHOTOMETRIC, &photometric);\n\n    if (bitsPerSample != 16) {\n        state->data->msg = \"Unsupported bit-depth: \" + std::to_string(bitsPerSample);\n        TIFFClose(inTiff);\n        return STATUS_ERROR;\n    }\n\n    TiffFormat format;\n    if (PHOTOMETRIC_RGB == photometric) {\n        format = TIFF_FORMAT_RGB48LE;\n    }\n    else if (PHOTOMETRIC_YCBCR == photometric) {\n        TIFFGetField(inTiff, TIFFTAG_YCBCRSUBSAMPLING, &subsampling[0], &subsampling[1]);\n        if (1 == subsampling[0] && 1 == subsampling[1]) {\n            format = TIFF_FORMAT_YUV444P16LE;\n        }\n        else {\n            state->data->msg =\n                \"Unsupported subsampling: \" + std::to_string(subsampling[0]) + \",\" + std::to_string(subsampling[1]);\n            TIFFClose(inTiff);\n            return STATUS_ERROR;\n        }\n    }\n    else {\n        state->data->msg = \"Unsupported photometric interpretation: \" + std::to_string(photometric);\n        TIFFClose(inTiff);\n        return STATUS_ERROR;\n    }\n    const int maxPlaneNum = 4;\n    uint64_t buffer_size = width * height * maxPlaneNum;\n    if (!state->data->outputBuffer)\n        state->data->outputBuffer = new uint16_t[buffer_size];\n    if (!state->data->lineBuffer)\n        state->data->lineBuffer = new uint16_t[buffer_size];\n\n    uint64_t pixNum = width * height;\n    memset(state->data->outputBuffer, 0, buffer_size);\n    uint16* plane[maxPlaneNum];\n    for (int i = 0; i < maxPlaneNum; i++) {\n        plane[i] = &state->data->outputBuffer[i * pixNum];\n    }\n\n    out->buffer[0] = (void*)plane[0];\n    out->buffer[1] = (void*)plane[1];\n    out->buffer[2] = (void*)plane[2];\n\n    uint16_t* line = state->data->lineBuffer;\n    for (uint32 row = 0; row < height; row++) {\n        if (!TIFFReadScanline(inTiff, line, row)) {\n            state->data->msg = \"TIFFReadScanline failed\";\n            TIFFClose(inTiff);\n            return STATUS_ERROR;\n        }\n\n        for (uint32 i = 0; i < width; i++) {\n            for (uint32 s = 0; s < nsamples; s++) {\n                *(plane[s]++) = line[(i*nsamples)+s];\n            }\n        }\n    }\n\n    out->width = width;\n    out->height = height;\n    out->format = format;\n\n    TIFFClose(inTiff);\n    return STATUS_OK;\n}",
    "JNIEXPORT void JNICALL Java_freed_jni_DngStack_startStack(JNIEnv *env, jobject thiz, jobjectArray filesToStack, jstring outputfile)\n{\n    int stringCount = (*env).GetArrayLength(filesToStack);\n    int width,height, outputcount;\n    const char * files[stringCount];\n    const char * outfile =(*env).GetStringUTFChars( outputfile, NULL);\n    unsigned short tmpPixel, bitdeep,bitdeeptemp;\n    unsigned char * rawOutputData;\n    unsigned char* cfa= new unsigned char[4];\n    unsigned char* cfatmp= new unsigned char[4];\n    float* cmat1 = new float[9];\n    float * cmat2 = new float[9];\n    float * neutMat = new float[3];\n    float * fmat1= new float[9];\n    float * fmat2= new float[9];\n    float * calib1= new float[9];\n    float * calib2= new float[9];\n    double *noisemat  = new double[6];\n    float *blackleveltmp;\n    short blacklevel;\n    float * tmpmat = new float[9];\n    double * tmpdouble = new double[6];\n    long * whitelvl;\n    long white;\n\n    //short * whitelvltmp;\n    //short whitelvl;\n    unsigned char * inbuf;\n    /*unsigned char * opcodetmp;\n    unsigned char * opcode2;\n    unsigned char * opcode3;*/\n    LOGD(\"FilesToReadCount: %i\", stringCount);\n    for (int i=0; i<stringCount; i++) {\n        jstring string = (jstring) (*env).GetObjectArrayElement(filesToStack, i);\n        files[i] = (*env).GetStringUTFChars( string, NULL);\n    }\n\n\n    TIFF *tif=TIFFOpen(files[0], \"rw\");\n    //read needed dng tags\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n    LOGD(\"GetWidth\");\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n    LOGD(\"GetHeight\");\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitdeeptemp);\n    LOGD(\"GetBitDeep\");\n    bitdeep = bitdeeptemp;\n    TIFFGetField(tif, TIFFTAG_COLORMATRIX1,9, &tmpmat);\n    LOGD(\"cc1\");\n    moveToMem(tmpmat, cmat1,9);\n    TIFFGetField(tif, TIFFTAG_COLORMATRIX2,9, &tmpmat);\n    LOGD(\"cc2\");\n    moveToMem(tmpmat, cmat2,9);\n    TIFFGetField(tif, TIFFTAG_ASSHOTNEUTRAL,3, &tmpmat);\n    LOGD(\"neutral\");\n    moveToMem(tmpmat, neutMat,3);\n    TIFFGetField(tif, TIFFTAG_FOWARDMATRIX1,9, &tmpmat);\n    moveToMem(tmpmat, fmat1,9);\n    TIFFGetField(tif, TIFFTAG_FOWARDMATRIX2,9, &tmpmat);\n    moveToMem(tmpmat, fmat2,9);\n    TIFFGetField(tif, TIFFTAG_CAMERACALIBRATION1,9, &tmpmat);\n    moveToMem(tmpmat, calib1,9);\n    TIFFGetField(tif, TIFFTAG_CAMERACALIBRATION2,9, &tmpmat);\n    moveToMem(tmpmat, calib2,9);\n    TIFFGetField(tif, TIFFTAG_NOISEPROFILE,6, &tmpdouble);\n    for (int i = 0; i < 6; ++i) {\n        noisemat[i] = tmpdouble[i];\n    }\n    TIFFGetField(tif, TIFFTAG_CFAPATTERN, &cfatmp);\n    for (int i = 0; i < 4; ++i) {\n        cfa[i] = cfatmp[i];\n    }\n    LOGD(\"cfa pattern %c%c&c&c\", cfa[0],cfa[1],cfa[2],cfa[3]);\n\n    TIFFGetField(tif, TIFFTAG_WHITELEVEL, &whitelvl);\n    LOGD(\"whitelvl:%i\" , whitelvl[0]);\n    white = whitelvl[0];\n    LOGD(\"whitelvl:%i\" , white);\n    //whitelvl = whitelvltmp[0];\n    TIFFGetField(tif, TIFFTAG_BLACKLEVEL, &blackleveltmp);\n    /*TIFFGetField(tif, TIFFTAG_OPC2, &opcodetmp);\n    opcode2 = opcodetmp;\n    TIFFGetField(tif, TIFFTAG_OPC3, &opcodetmp);\n    opcode3 = opcodetmp;*/\n    blacklevel = blackleveltmp[0];\n\n    rawOutputData = new unsigned char[((width*height)*16)/8];\n\n    int scanlinesize = TIFFStripSize(tif);\n    inbuf = (unsigned char*)_TIFFmalloc(scanlinesize);\n    outputcount = 0;\n    for (int row = 0; row < height; row++)\n    {\n        TIFFReadRawStrip(tif,row, inbuf, scanlinesize);\n        if(bitdeep == 10)\n        {\n            for (int i = 0; i < scanlinesize; i+=5) {\n                tmpPixel = (inbuf[i] << 2 | (inbuf[i+1] & 0b11000000) >> 6); //11111111 11\n                rawOutputData[outputcount++] = tmpPixel & 0xff;\n                rawOutputData[outputcount++] = tmpPixel >>8;\n\n                tmpPixel = ((inbuf[i+1] & 0b00111111 ) << 4 | (inbuf[i+2] & 0b11110000) >> 4); // 222222 2222\n                rawOutputData[outputcount++] = tmpPixel & 0xff;\n                rawOutputData[outputcount++] = tmpPixel >>8;\n\n                tmpPixel = ((inbuf[i+2]& 0b00001111 ) << 6 | (inbuf[i+3] & 0b11111100) >> 2); // 3333 333333\n                rawOutputData[outputcount++] = tmpPixel & 0xff;\n                rawOutputData[outputcount++] = tmpPixel >>8;\n\n                tmpPixel = ((inbuf[i+3]& 0b00000011 ) << 8 | inbuf[i+4]); // 44 44444444\n                rawOutputData[outputcount++] = tmpPixel & 0xff;\n                rawOutputData[outputcount++] = tmpPixel >>8;\n            }\n        }\n        else if(bitdeep == 16)\n        {\n            for (int i = 0; i < scanlinesize; i+=8) {\n                tmpPixel = (inbuf[i] | inbuf[i+1]<<8);\n                rawOutputData[outputcount++] = tmpPixel & 0xff;\n                rawOutputData[outputcount++] = tmpPixel >>8;\n\n                tmpPixel = (inbuf[i+2] | inbuf[i+3]<<8);\n                rawOutputData[outputcount++] = tmpPixel & 0xff;\n                rawOutputData[outputcount++] = tmpPixel >>8;\n\n                tmpPixel = (inbuf[i+4] | inbuf[i+5]<<8);\n                rawOutputData[outputcount++] = tmpPixel & 0xff;\n                rawOutputData[outputcount++] = tmpPixel >>8;\n\n                tmpPixel = (inbuf[i+6] | inbuf[i+7]<<8);\n                rawOutputData[outputcount++] = tmpPixel & 0xff;\n                rawOutputData[outputcount++] = tmpPixel >>8;\n            }\n        }\n    }\n    TIFFClose(tif);\n\n    //read left dngs and merge them\n    for (int i = 1; i < stringCount; ++i) {\n        TIFF *tif=TIFFOpen(files[i], \"rw\");\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitdeeptemp);\n        bitdeep = bitdeeptemp;\n        outputcount = 0;\n        for (int row = 0; row < height; row++)\n        {\n            TIFFReadRawStrip(tif,row, inbuf, scanlinesize);\n            if(bitdeep == 10)\n            {\n                for (int i = 0; i < scanlinesize; i+=5) {\n                    tmpPixel = (((inbuf[i] << 2 | (inbuf[i+1] & 0b11000000) >> 6)) + (rawOutputData[outputcount] | rawOutputData[outputcount+1]<<8))/2; //11111111 11\n                    rawOutputData[outputcount++] = tmpPixel & 0xff;\n                    rawOutputData[outputcount++] = tmpPixel >>8;\n\n                    tmpPixel = ((((inbuf[i+1] & 0b00111111 ) << 4 | (inbuf[i+2] & 0b11110000) >> 4)) + (rawOutputData[outputcount] | rawOutputData[outputcount+1]<<8))/2; // 222222 2222\n                    rawOutputData[outputcount++] = tmpPixel & 0xff;\n                    rawOutputData[outputcount++] = tmpPixel >>8;\n\n                    tmpPixel = ((((inbuf[i+2]& 0b00001111 )  | (inbuf[i+3] & 0b11111100) >> 2)) + (rawOutputData[outputcount] | rawOutputData[outputcount+1]<<8))/2; // 3333 333333\n                    rawOutputData[outputcount++] = tmpPixel & 0xff;\n                    rawOutputData[outputcount++] = tmpPixel >>8;\n\n                    tmpPixel = ((((inbuf[i+3]& 0b00000011 ) << 8 | inbuf[i+4])) + (rawOutputData[outputcount] | rawOutputData[outputcount+1]<<8))/2; // 44 44444444\n                    rawOutputData[outputcount++] = tmpPixel & 0xff;\n                    rawOutputData[outputcount++] = tmpPixel >>8;\n                }\n            }\n            else if(bitdeep == 16)\n            {\n                for (int i = 0; i < scanlinesize; i+=8) {\n                    tmpPixel = (((inbuf[i] | inbuf[i+1]<<8))+ (rawOutputData[outputcount] | rawOutputData[outputcount+1]<<8))/2;\n                    rawOutputData[outputcount++] = tmpPixel & 0xff;\n                    rawOutputData[outputcount++] = tmpPixel >>8;\n\n                    tmpPixel = (((inbuf[i+2] | inbuf[i+3]<<8))+ (rawOutputData[outputcount] | rawOutputData[outputcount+1]<<8))/2;\n                    rawOutputData[outputcount++] = tmpPixel & 0xff;\n                    rawOutputData[outputcount++] = tmpPixel >>8;\n\n                    tmpPixel = (((inbuf[i+4] | inbuf[i+5]<<8))+ (rawOutputData[outputcount] | rawOutputData[outputcount+1]<<8))/2;\n                    rawOutputData[outputcount++] = tmpPixel & 0xff;\n                    rawOutputData[outputcount++] = tmpPixel >>8;\n\n                    tmpPixel = (((inbuf[i+6] | inbuf[i+7]<<8))+ (rawOutputData[outputcount] | rawOutputData[outputcount+1]<<8))/2;\n                    rawOutputData[outputcount++] = tmpPixel & 0xff;\n                    rawOutputData[outputcount++] = tmpPixel >>8;\n                }\n            }\n        }\n        TIFFClose(tif);\n    }\n    free(inbuf);\n    //create stacked dng\n    tif=TIFFOpen(outfile, \"w\");\n\n    TIFFSetField (tif, TIFFTAG_SUBFILETYPE, 0);\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CFA);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    TIFFSetField (tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_DNGVERSION, \"\\001\\003\\0\\0\");\n    TIFFSetField(tif, TIFFTAG_DNGBACKWARDVERSION, \"\\001\\001\\0\\0\");\n    TIFFSetField(tif, TIFFTAG_COLORMATRIX1, 9, cmat1);\n    LOGD(\"colormatrix1\");\n    TIFFSetField(tif, TIFFTAG_COLORMATRIX2, 9, cmat2);\n    TIFFSetField(tif, TIFFTAG_ASSHOTNEUTRAL, 3, neutMat);\n    LOGD(\"neutralMatrix\");\n    if(fmat1 != NULL)\n        TIFFSetField(tif, TIFFTAG_FOWARDMATRIX1, 9,  fmat1);\n    if(fmat2 != NULL)\n        TIFFSetField(tif, TIFFTAG_FOWARDMATRIX2, 9,  fmat2);\n    if(calib1 != NULL)\n        TIFFSetField(tif, TIFFTAG_CAMERACALIBRATION1, 9,  calib1);\n    if(calib2 != NULL)\n        TIFFSetField(tif, TIFFTAG_CAMERACALIBRATION2, 9,  calib2);\n    if(noisemat != NULL)\n        TIFFSetField(tif, TIFFTAG_NOISEPROFILE, 6,  noisemat);\n    TIFFSetField(tif, TIFFTAG_CALIBRATIONILLUMINANT1, 17);\n    TIFFSetField(tif, TIFFTAG_CALIBRATIONILLUMINANT2, 21);\n\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n    TIFFSetField (tif, TIFFTAG_CFAPATTERN, cfa);\n    LOGD(\"whitelvl:%i\" , white);\n    TIFFSetField (tif, TIFFTAG_WHITELEVEL,1, &white);\n\n    short CFARepeatPatternDim[] = { 2,2 };\n    TIFFSetField (tif, TIFFTAG_CFAREPEATPATTERNDIM, CFARepeatPatternDim);\n    int bl = blacklevel;\n    float *blacklevelar = new float[4];\n    for (int i = 0; i < 4; ++i) {\n        blacklevelar[i] = bl;\n    }\n    TIFFSetField (tif, TIFFTAG_BLACKLEVEL, 4, blacklevelar);\n    LOGD(\"wrote blacklevel\");\n    TIFFSetField (tif, TIFFTAG_BLACKLEVELREPEATDIM, CFARepeatPatternDim);\n\n    //TODO find out why OPCODE cause ueof ex in ps\n    /*if(sizeof(opcode2)>0)\n        TIFFSetField(tif,TIFFTAG_OPC2, sizeof(opcode2), opcode2);\n    if(sizeof(opcode3)>0)\n        TIFFSetField(tif,TIFFTAG_OPC3, sizeof(opcode3), opcode3);*/\n    TIFFCheckpointDirectory(tif);\n\n    TIFFWriteRawStrip(tif, 0, rawOutputData, ((width*height)*16)/8);\n\n    TIFFRewriteDirectory(tif);\n\n    //TIFFWriteRawStrip(tif, 0, rawOutputData, width*height);\n\n    TIFFClose(tif);\n    delete[] rawOutputData;\n}",
    "bool Image::initWithTiffData(const unsigned char * data, ssize_t dataLen)\n{\n#if CC_USE_TIFF\n    bool ret = false;\n    do \n    {\n        // set the read call back function\n        tImageSource imageSource;\n        imageSource.data    = data;\n        imageSource.size    = dataLen;\n        imageSource.offset  = 0;\n\n        TIFF* tif = TIFFClientOpen(\"file.tif\", \"r\", (thandle_t)&imageSource, \n            tiffReadProc, tiffWriteProc,\n            tiffSeekProc, tiffCloseProc, tiffSizeProc,\n            tiffMapProc,\n            tiffUnmapProc);\n\n        CC_BREAK_IF(nullptr == tif);\n\n        uint32 w = 0, h = 0;\n        uint16 bitsPerSample = 0, samplePerPixel = 0, planarConfig = 0;\n        size_t npixels = 0;\n        \n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplePerPixel);\n        TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planarConfig);\n\n        npixels = w * h;\n        \n        _renderFormat = Texture2D::PixelFormat::RGBA8888;\n        _width = w;\n        _height = h;\n\n        _dataLen = npixels * sizeof (uint32);\n        _data = static_cast<unsigned char*>(malloc(_dataLen * sizeof(unsigned char)));\n\n        uint32* raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n        if (raster != nullptr) \n        {\n           if (TIFFReadRGBAImageOriented(tif, w, h, raster, ORIENTATION_TOPLEFT, 0))\n           {\n                /* the raster data is pre-multiplied by the alpha component \n                   after invoking TIFFReadRGBAImageOriented*/\n                _hasPremultipliedAlpha = true;\n\n               memcpy(_data, raster, npixels*sizeof (uint32));\n           }\n\n          _TIFFfree(raster);\n        }\n        \n\n        TIFFClose(tif);\n\n        ret = true;\n    } while (0);\n    return ret;\n#else\n    CCLOG(\"tiff is not enabled\");\n    return false;\n#endif //CC_USE_TIFF\n}",
    "sensor_msgs::ImagePtr\nloadTiff(const std::string& file)\n{\n    using\tnamespace sensor_msgs;\n\n    TIFF* const\ttiff = TIFFOpen(file.c_str(), \"r\");\n    if (!tiff)\n\tthrow std::runtime_error(\"loadTiff(): cannot open file[\" + file + ']');\n\n    uint32\twidth, height;\n    uint16\tbitsPerSample, samplesPerPixel, photometric;\n\n    if (!TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH,\t     &width)\t\t||\n\t!TIFFGetField(tiff, TIFFTAG_IMAGELENGTH,     &height)\t\t||\n\t!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE,   &bitsPerSample)\t||\n\t!TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel)\t||\n\t!TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC,     &photometric))\n    {\n\tthrow std::runtime_error(\"loadTiff(): cannot get necessary fields\");\n    }\n\n    sensor_msgs::ImagePtr\timage(new sensor_msgs::Image());\n    image->width  = width;\n    image->height = height;\n\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n\tswitch(bitsPerSample)\n\t{\n\t  case 8:\n\t    image->encoding = image_encodings::MONO8;\n\t    break;\n\t  case 16:\n\t    image->encoding = image_encodings::MONO16;\n\t    break;\n\t  case 32:\n\t    switch (samplesPerPixel)\n\t    {\n\t      case 1:\n\t\timage->encoding = image_encodings::TYPE_32FC1;\n\t\tbreak;\n\t      case 2:\n\t\timage->encoding = image_encodings::TYPE_32FC2;\n\t\tbreak;\n\t      case 3:\n\t\timage->encoding = image_encodings::TYPE_32FC3;\n\t\tbreak;\n\t      case 4:\n\t\timage->encoding = image_encodings::TYPE_32FC4;\n\t\tbreak;\n\t      default:\n\t\tthrow std::runtime_error(\"loadTiff(): unsupported #samples per pixel[\"\n\t\t\t\t\t + std::to_string(samplesPerPixel)\n\t\t\t\t\t + \"] under #bits per sample[\"\n\t\t\t\t\t + std::to_string(bitsPerSample)\n\t\t\t\t\t + ']');\n\t    }\n\t    break;\n\t  case 64:\n\t    switch (samplesPerPixel)\n\t    {\n\t      case 1:\n\t\timage->encoding = image_encodings::TYPE_64FC1;\n\t\tbreak;\n\t      case 2:\n\t\timage->encoding = image_encodings::TYPE_64FC2;\n\t\tbreak;\n\t      case 3:\n\t\timage->encoding = image_encodings::TYPE_64FC3;\n\t\tbreak;\n\t      case 4:\n\t\timage->encoding = image_encodings::TYPE_64FC4;\n\t\tbreak;\n\t      default:\n\t\tthrow std::runtime_error(\"loadTiff(): unsupported #samples per pixel[\"\n\t\t\t\t\t + std::to_string(samplesPerPixel)\n\t\t\t\t\t + \"] under #bits per sample[\"\n\t\t\t\t\t + std::to_string(bitsPerSample)\n\t\t\t\t\t + ']');\n\t    }\n\t    break;\n\t  default:\n\t    throw std::runtime_error(\"loadTiff(): unsupported #bits per sample[\"\n\t\t\t\t     + std::to_string(bitsPerSample) + ']');\n\t}\n\tbreak;\n\n      case PHOTOMETRIC_RGB:\n\tswitch(bitsPerSample)\n\t{\n\t  case 8:\n\t    image->encoding = image_encodings::RGB8;\n\t    break;\n\t  case 16:\n\t    image->encoding = image_encodings::RGB16;\n\t    break;\n\t  default:\n\t    throw std::runtime_error(\"loadTiff(): unsupported #bits per sample[\"\n\t\t\t\t     + std::to_string(bitsPerSample) + ']');\n\t}\n\tbreak;\n\n      default:\n\tthrow std::runtime_error(\"loadTiff(): unsupported photometic[\"\n\t\t\t\t + std::to_string(photometric) + ']');\n    }\n\n    image->step\t\t= image->width * bitsPerSample * samplesPerPixel / 8;\n    image->is_bigendian = false;\n    image->data.resize(image->height * image->step);\n\n    const auto\tnBytesPerStrip = TIFFStripSize(tiff);\n    const auto\tnStrips        = TIFFNumberOfStrips(tiff);\n\n    for (int n = 0, offset = 0; n < nStrips; ++n)\n    {\n\tconst auto nBytes = TIFFReadEncodedStrip(tiff, n,\n\t\t\t\t\t\t image->data.data() + offset,\n\t\t\t\t\t\t nBytesPerStrip);\n\tif (nBytes < 0)\n\t    throw std::runtime_error(\"loadTiff(): failed to read strip\");\n\n\toffset += nBytes;\n    }\n\n    TIFFClose(tiff);\n\n    return image;\n}",
    "int ImageMatrix::LoadTIFF(char *filename) {\n\tunsigned int h,w,x=0,y=0;\n\tunsigned short int spp=0,bps=0;\n\tTIFF *tif = NULL;\n\tunsigned char *buf8;\n\tunsigned short *buf16;\n\tRGBcolor rgb = {0,0,0};\n\tImageMatrix R_matrix, G_matrix, B_matrix;\n\tMoments2 R_stats, G_stats, B_stats;\n\n\tTIFFSetWarningHandler(NULL);\n\tif( (tif = TIFFOpen(filename, \"r\")) ) {\n\t\tsource = filename;\n\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\t\twidth = w;\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\theight = h;\n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n\t\tbits=bps;\n\t\tif ( ! (bits == 8 || bits == 16) ) return (0); // only 8 and 16-bit images supported.\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n\t\tif (!spp) spp=1;  /* assume one sample per pixel if nothing is specified */\n\t\t// regardless of how the image comes in, the stored mode is HSV\n\t\tif (spp == 3) {\n\t\t\tColorMode = cmHSV;\n\t\t\t// If the bits are > 8, we do the read into doubles so that later\n\t\t\t// we can scale the image to its actual signal range.\n\t\t\tif (bits > 8) {\n\t\t\t\tR_matrix.ColorMode = cmGRAY;\n\t\t\t\tR_matrix.allocate (width, height);\n\t\t\t\tG_matrix.ColorMode = cmGRAY;\n\t\t\t\tG_matrix.allocate (width, height);\n\t\t\t\tB_matrix.ColorMode = cmGRAY;\n\t\t\t\tB_matrix.allocate (width, height);\n\t\t\t}\n\t\t} else {\n\t\t\tColorMode = cmGRAY;\n\t\t}\n\t\tif ( TIFFNumberOfDirectories(tif) > 1) return(0);   /* get the number of slices (Zs) */\n\n\t\t/* allocate the data */\n\t\tallocate (width, height);\n\t\twriteablePixels pix_plane = WriteablePixels();\n\t\twriteableColors clr_plane = WriteableColors();\n\n\t\t/* read TIFF header and determine image size */\n\t\tbuf8 = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif)*spp);\n\t\tbuf16 = (unsigned short *)_TIFFmalloc( (tsize_t)sizeof(unsigned short)*TIFFScanlineSize(tif)*spp );\n\t\tfor (y = 0; y < height; y++) {\n\t\t\tint col;\n\t\t\tif (bits==8) TIFFReadScanline(tif, buf8, y);\n\t\t\telse TIFFReadScanline(tif, buf16, y);\n\t\t\tx=0;col=0;\n\t\t\twhile (x<width) {\n\t\t\t\tunsigned char byte_data;\n\t\t\t\tunsigned short short_data;\n\t\t\t\tdouble val=0;\n\t\t\t\tint sample_index;\n\t\t\t\tfor (sample_index=0;sample_index<spp;sample_index++) {\n\t\t\t\t\tbyte_data=buf8[col+sample_index];\n\t\t\t\t\tshort_data=buf16[col+sample_index];\n\t\t\t\t\tif (bits==8) val=(double)byte_data;\n\t\t\t\t\telse val=(double)(short_data);\n\t\t\t\t\tif (spp==3 && bits > 8) {  /* RGB image */\n\t\t\t\t\t\tif (sample_index==0) R_matrix.WriteablePixels()(y,x) = R_stats.add (val);\n\t\t\t\t\t\tif (sample_index==1) G_matrix.WriteablePixels()(y,x) = G_stats.add (val);\n\t\t\t\t\t\tif (sample_index==2) B_matrix.WriteablePixels()(y,x) = B_stats.add (val);\n\t\t\t\t\t} else if (spp == 3) {\n\t\t\t\t\t\tif (sample_index==0) rgb.r = (unsigned char)(R_stats.add (val));\n\t\t\t\t\t\tif (sample_index==1) rgb.g = (unsigned char)(G_stats.add (val));\n\t\t\t\t\t\tif (sample_index==2) rgb.b = (unsigned char)(B_stats.add (val));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (spp == 3 && bits == 8) {\n\t\t\t\t\tpix_plane (y, x) = stats.add (RGB2GRAY (rgb));\n\t\t\t\t\tclr_plane (y, x) = RGB2HSV(rgb);\n\t\t\t\t} else if (spp == 1) {\n\t\t\t\t\tpix_plane (y, x) = stats.add (val);\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t\tcol+=spp;\n\t\t\t}\n\t\t}\n\t\t// Do the conversion to unsigned chars based on the input signal range\n\t\t// i.e. scale global RGB min-max to 0-255\n\t\tif (spp == 3 && bits > 8) {\n\t\t\t//size_t a, num = width*height;\n\t\t\tdouble RGB_min=0, RGB_max=0, RGB_scale=0;\n\t\t\tR_matrix.finish();\n\t\t\tG_matrix.finish();\n\t\t\tB_matrix.finish();\n\t\t\t// Get the min and max for all 3 channels\n\t\t\tif (R_stats.min() <= G_stats.min() && R_stats.min() <= B_stats.min()) RGB_min = R_stats.min();\n\t\t\telse if (G_stats.min() <= R_stats.min() && G_stats.min() <= B_stats.min()) RGB_min = G_stats.min();\n\t\t\telse if (B_stats.min() <= R_stats.min() && B_stats.min() <= G_stats.min()) RGB_min = B_stats.min();\n\t\t\tif (R_stats.max() >= G_stats.max() && R_stats.max() >= B_stats.max()) RGB_max = R_stats.max();\n\t\t\telse if (G_stats.max() >= R_stats.max() && G_stats.max() >= B_stats.max()) RGB_max = G_stats.max();\n\t\t\telse if (B_stats.max() >= R_stats.max() && B_stats.max() >= G_stats.max()) RGB_max = B_stats.max();\n\t\t\t// Scale the clrData to the global min / max.\n\t\t\tRGB_scale = (255.0/(RGB_max-RGB_min));\n\t\t\tfor (y = 0; y < height; y++) {\n\t\t\t\tfor (x = 0; x < width; x++) {\n\t\t\t\t\trgb.r = (unsigned char)( (R_matrix.ReadablePixels()(y,x) - RGB_min) * RGB_scale);\n\t\t\t\t\trgb.g = (unsigned char)( (G_matrix.ReadablePixels()(y,x) - RGB_min) * RGB_scale);\n\t\t\t\t\trgb.b = (unsigned char)( (B_matrix.ReadablePixels()(y,x) - RGB_min) * RGB_scale);\n\t\t\t\t\tpix_plane (y, x) = stats.add (RGB2GRAY (rgb));\n\t\t\t\t\tclr_plane (y, x) = RGB2HSV(rgb);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(buf8);\n\t\t_TIFFfree(buf16);\n\t\tTIFFClose(tif);\n\n\t} else return(0);\n\n\treturn(1);\n}",
    "unsigned char *\nsimage_tiff_load(std::istream& fin,\n                 int& width_ret,\n                 int& height_ret,\n                 int& numComponents_ret,\n                 uint16& bitspersample)\n{\n    TIFF *in;\n    uint16 dataType;\n    uint16 samplesperpixel;\n    uint16 photometric;\n    uint32 w, h;\n    uint16 config;\n    uint16* red;\n    uint16* green;\n    uint16* blue;\n    unsigned char *inbuf = NULL;\n    tsize_t rowsize;\n    uint32 row;\n    int format;\n    unsigned char *buffer;\n    int width;\n    int height;\n    unsigned char *currPtr;\n\n    TIFFSetErrorHandler(tiff_error);\n    TIFFSetWarningHandler(tiff_warn);\n\n    in = TIFFClientOpen(\"inputstream\", \"r\", (thandle_t)&fin,\n            libtiffStreamReadProc, //Custom read function\n            libtiffStreamWriteProc, //Custom write function\n            libtiffStreamSeekProc, //Custom seek function\n            libtiffStreamCloseProc, //Custom close function\n            libtiffStreamSizeProc, //Custom size function\n            libtiffStreamMapProc, //Custom map function\n            libtiffStreamUnmapProc); //Custom unmap function\n\n    if (in == NULL)\n    {\n        tifferror = ERR_OPEN;\n        return NULL;\n    }\n    if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric) == 1)\n    {\n        if (photometric != PHOTOMETRIC_RGB && photometric != PHOTOMETRIC_PALETTE &&\n            photometric != PHOTOMETRIC_MINISWHITE &&\n            photometric != PHOTOMETRIC_MINISBLACK)\n        {\n            OSG_NOTICE << \"Photometric type \"<<photometric<<\" not handled; can only handle Grayscale, RGB and Palette images\" << std::endl;\n            TIFFClose(in);\n            tifferror = ERR_UNSUPPORTED;\n            return NULL;\n        }\n    }\n    else\n    {\n        tifferror = ERR_READ;\n        TIFFClose(in);\n        return NULL;\n    }\n\n    if (TIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel) == 1)\n    {\n        if (samplesperpixel != 1 &&\n            samplesperpixel != 2 &&\n            samplesperpixel != 3 &&\n            samplesperpixel != 4)\n        {\n            OSG_DEBUG << \"Bad samples/pixel\" << std::endl;\n            tifferror = ERR_UNSUPPORTED;\n            TIFFClose(in);\n            return NULL;\n        }\n    }\n    else\n    {\n        tifferror = ERR_READ;\n        TIFFClose(in);\n        return NULL;\n    }\n\n    if (TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample) == 1)\n    {\n         if (bitspersample != 8 && bitspersample != 16 && bitspersample != 32)\n        {\n            OSG_NOTICE << \"can only handle 8, 16 and 32 bit samples\" << std::endl;\n            TIFFClose(in);\n            tifferror = ERR_UNSUPPORTED;\n            return NULL;\n        }\n    }\n    else\n    {\n        tifferror = ERR_READ;\n        TIFFClose(in);\n        return NULL;\n    }\n\n    if (TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w) != 1 ||\n        TIFFGetField(in, TIFFTAG_IMAGELENGTH, &h) != 1 ||\n        TIFFGetField(in, TIFFTAG_PLANARCONFIG, &config) != 1)\n    {\n        TIFFClose(in);\n        tifferror = ERR_READ;\n        return NULL;\n    }\n\n\n    TIFFGetField(in, TIFFTAG_DATATYPE, &dataType);\n    OSG_INFO<<\"TIFFTAG_DATATYPE=\"<<dataType<<std::endl;\n\n\n    /*\n    if (photometric == PHOTOMETRIC_MINISWHITE ||\n        photometric == PHOTOMETRIC_MINISBLACK)\n        format = 1;\n    else\n        format = 3;\n    */\n    // if it has a palette, data returned is 3 byte rgb\n    // so set format to 3.\n    if (photometric == PHOTOMETRIC_PALETTE)\n        format = 3;\n    else\n        format = samplesperpixel * bitspersample / 8;\n\n\n    int bytespersample = bitspersample / 8;\n    int bytesperpixel = bytespersample * samplesperpixel;\n\n    OSG_INFO<<\"format=\"<<format<<std::endl;\n    OSG_INFO<<\"bytespersample=\"<<bytespersample<<std::endl;\n    OSG_INFO<<\"bytesperpixel=\"<<bytesperpixel<<std::endl;\n\n    buffer = new unsigned char [w*h*format];\n\n    if (!buffer)\n    {\n        tifferror = ERR_MEM;\n        TIFFClose(in);\n        return NULL;\n    }\n\n    // initialize memory\n    for(unsigned char* ptr=buffer;ptr<buffer+w*h*format;++ptr) *ptr = 0;\n\n    width = w;\n    height = h;\n\n    currPtr = buffer + (h-1)*w*format;\n\n    tifferror = ERR_NO_ERROR;\n\n    switch (pack(photometric, config))\n    {\n        case pack(PHOTOMETRIC_MINISWHITE, PLANARCONFIG_CONTIG):\n        case pack(PHOTOMETRIC_MINISBLACK, PLANARCONFIG_CONTIG):\n        case pack(PHOTOMETRIC_MINISWHITE, PLANARCONFIG_SEPARATE):\n        case pack(PHOTOMETRIC_MINISBLACK, PLANARCONFIG_SEPARATE):\n            inbuf = new unsigned char [TIFFScanlineSize(in)];\n            for (row = 0; row < h; row++)\n            {\n                if (TIFFReadScanline(in, inbuf, row, 0) < 0)\n                {\n                    tifferror = ERR_READ;\n                    break;\n                }\n                invert_row(currPtr, inbuf, samplesperpixel*w, photometric == PHOTOMETRIC_MINISWHITE, bitspersample);\n                currPtr -= format*w;\n            }\n            break;\n\n        case pack(PHOTOMETRIC_PALETTE, PLANARCONFIG_CONTIG):\n        case pack(PHOTOMETRIC_PALETTE, PLANARCONFIG_SEPARATE):\n\n            if (TIFFGetField(in, TIFFTAG_COLORMAP, &red, &green, &blue) != 1)\n            {\n                tifferror = ERR_READ;\n                break;\n            }\n\n            /* */\n            /* Convert 16-bit colormap to 8-bit (unless it looks */\n            /* like an old-style 8-bit colormap). */\n            /* */\n            if (!tifferror && bitspersample!=32 && checkcmap(1<<bitspersample, red, green, blue) == 16)\n            {\n                int i;\n                for (i = (1<<bitspersample)-1; i >= 0; i--)\n                {\n                    red[i] = CVT(red[i]);\n                    green[i] = CVT(green[i]);\n                    blue[i] = CVT(blue[i]);\n                }\n            }\n\n            inbuf = new unsigned char [TIFFScanlineSize(in)];\n            for (row = 0; row < h; row++)\n            {\n                if (TIFFReadScanline(in, inbuf, row, 0) < 0)\n                {\n                    tifferror = ERR_READ;\n                    break;\n                }\n                remap_row(currPtr, inbuf, w, red, green, blue);\n                currPtr -= format*w;\n            }\n            break;\n\n        case pack(PHOTOMETRIC_RGB, PLANARCONFIG_CONTIG):\n            inbuf = new unsigned char [TIFFScanlineSize(in)];\n            for (row = 0; row < h; row++)\n            {\n                if (TIFFReadScanline(in, inbuf, row, 0) < 0)\n                {\n                    tifferror = ERR_READ;\n                    break;\n                }\n                memcpy(currPtr, inbuf, format*w);\n                currPtr -= format*w;\n            }\n            break;\n\n        case pack(PHOTOMETRIC_RGB, PLANARCONFIG_SEPARATE):\n            rowsize = TIFFScanlineSize(in);\n            inbuf = new unsigned char [format*rowsize];\n            for (row = 0; !tifferror && row < h; row++)\n            {\n                int s;\n                for (s = 0; s < format; s++)\n                {\n                    if (TIFFReadScanline(in, (tdata_t)(inbuf+s*rowsize), (uint32)row, (tsample_t)s) < 0)\n                    {\n                        tifferror = ERR_READ; break;\n                    }\n                }\n                if (!tifferror)\n                {\n                    if (format==3) interleave_row(currPtr, inbuf, inbuf+rowsize, inbuf+2*rowsize, w, format, bitspersample);\n                    else if (format==4) interleave_row(currPtr, inbuf, inbuf+rowsize, inbuf+2*rowsize, inbuf+3*rowsize, w, format, bitspersample);\n                    currPtr -= format*w;\n                }\n            }\n            break;\n        default:\n            tifferror = ERR_UNSUPPORTED;\n            break;\n    }\n\n    if (inbuf) delete [] inbuf;\n    TIFFClose(in);\n\n    if (tifferror)\n    {\n        if (buffer) delete [] buffer;\n        return NULL;\n    }\n    width_ret = width;\n    height_ret = height;\n    if (photometric == PHOTOMETRIC_PALETTE)\n        numComponents_ret = format;\n    else\n        numComponents_ret = samplesperpixel;\n\n    return buffer;\n}",
    "IO::Info Read::_open(const std::string& fileName, File& f)\n            {\n#if defined(DJV_PLATFORM_WINDOWS)\n                f.f = TIFFOpen(fileName.data(), \"r\");\n#else\n                f.f = TIFFOpen(fileName.data(), \"r\");\n#endif // DJV_WINDOWS\n                if (!f.f)\n                {\n                    throw System::File::Error(String::Format(\"{0}: {1}\").\n                        arg(fileName).\n                        arg(_textSystem->getText(DJV_TEXT(\"error_file_open\"))));\n                }\n\n                uint32   width            = 0;\n                uint32   height           = 0;\n                uint16   photometric      = 0;\n                uint16   samples          = 0;\n                uint16   sampleDepth      = 0;\n                uint16   sampleFormat     = 0;\n                uint16 * extraSamples     = nullptr;\n                uint16   extraSamplesSize = 0;\n                uint16   orient           = 0;\n                uint16   compression      = 0;\n                uint16   channels         = 0;\n                TIFFGetFieldDefaulted(f.f, TIFFTAG_IMAGEWIDTH, &width);\n                TIFFGetFieldDefaulted(f.f, TIFFTAG_IMAGELENGTH, &height);\n                TIFFGetFieldDefaulted(f.f, TIFFTAG_PHOTOMETRIC, &photometric);\n                TIFFGetFieldDefaulted(f.f, TIFFTAG_SAMPLESPERPIXEL, &samples);\n                TIFFGetFieldDefaulted(f.f, TIFFTAG_BITSPERSAMPLE, &sampleDepth);\n                TIFFGetFieldDefaulted(f.f, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n                TIFFGetFieldDefaulted(f.f, TIFFTAG_EXTRASAMPLES, &extraSamplesSize, &extraSamples);\n                TIFFGetFieldDefaulted(f.f, TIFFTAG_ORIENTATION, &orient);\n                TIFFGetFieldDefaulted(f.f, TIFFTAG_COMPRESSION, &compression);\n                TIFFGetFieldDefaulted(f.f, TIFFTAG_PLANARCONFIG, &channels);\n                TIFFGetFieldDefaulted(f.f, TIFFTAG_COLORMAP, &f.colormap[0], &f.colormap[1], &f.colormap[2]);\n\n                Image::Type imageType = Image::Type::None;\n                switch (photometric)\n                {\n                case PHOTOMETRIC_PALETTE:\n                    imageType = Image::Type::RGB_U8;\n                    break;\n                case PHOTOMETRIC_MINISWHITE:\n                case PHOTOMETRIC_MINISBLACK:\n                case PHOTOMETRIC_RGB:\n                    if (32 == sampleDepth && sampleFormat != SAMPLEFORMAT_IEEEFP)\n                        break;\n                    if (SAMPLEFORMAT_IEEEFP == sampleFormat)\n                    {\n                        imageType = Image::getFloatType(samples, sampleDepth);\n                    }\n                    else\n                    {\n                        imageType = Image::getIntType(samples, sampleDepth);\n                    }\n                    break;\n                }\n                if (Image::Type::None == imageType)\n                {\n                    throw System::File::Error(String::Format(\"{0}: {1}\").\n                        arg(fileName).\n                        arg(_textSystem->getText(DJV_TEXT(\"error_unsupported_image_type\"))));\n                }\n\n                Image::Layout layout;\n                switch (orient)\n                {\n                case ORIENTATION_TOPLEFT:  break;\n                case ORIENTATION_TOPRIGHT: layout.mirror.x = true; break;\n                case ORIENTATION_BOTRIGHT: layout.mirror.x = layout.mirror.y = true; break;\n                case ORIENTATION_BOTLEFT:  layout.mirror.y = true; break;\n                }\n\n                f.compression = compression != COMPRESSION_NONE;\n                f.palette = PHOTOMETRIC_PALETTE == photometric;\n\n                Image::Tags tags;\n                char * tag = 0;\n                if (TIFFGetField(f.f, TIFFTAG_ARTIST, &tag))\n                {\n                    if (tag)\n                    {\n                        tags.set(\"Creator\", tag);\n                    }\n                }\n                if (TIFFGetField(f.f, TIFFTAG_IMAGEDESCRIPTION, &tag))\n                {\n                    if (tag)\n                    {\n                        tags.set(\"Description\", tag);\n                    }\n                }\n                if (TIFFGetField(f.f, TIFFTAG_COPYRIGHT, &tag))\n                {\n                    if (tag)\n                    {\n                        tags.set(\"Copyright\", tag);\n                    }\n                }\n                if (TIFFGetField(f.f, TIFFTAG_DATETIME, &tag))\n                {\n                    if (tag)\n                    {\n                        tags.set(\"Time\", tag);\n                    }\n                }\n\n                IO::Info info;\n                info.fileName = fileName;\n                info.videoSpeed = _speed;\n                info.videoSequence = _sequence;\n                info.video.push_back(Image::Info(width, height, imageType, layout));\n                info.tags = tags;\n                return info;\n            }",
    "bool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif.get());\n    if (!tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n            if (!tif)\n                delete buf_helper;\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n        if (tif)\n            m_tif.reset(tif, cv_tiffCloseHandle);\n        else\n            m_tif.release();\n    }\n\n    if (tif)\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &wdth));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hght));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n        {\n            bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n            uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp));\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n\n            m_width = wdth;\n            m_height = hght;\n            if (ncn == 3 && photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 1:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, wanted_channels);\n                    result = true;\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, wanted_channels);\n                    result = true;\n                    break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16 photometric = (uint16)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp));\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if (dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if (!TIFFRGBAImageOK(tif, errmsg))\n            {\n                CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                close();\n                return false;\n            }\n        }\n\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n            CV_Assert(((uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte)) < MAX_TILE_SIZE) && \"TIFF tile size is too large: >= 1Gb\");\n\n            if (dst_bpp == 8)\n            {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n            const size_t buffer_size = (bpp / bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer(buffer_size);\n            uchar* buffer = _buffer.data();\n            ushort* buffer16 = (ushort*)buffer;\n            int tileidx = 0;\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = buffer;\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32*)buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy(img.ptr<ushort>(img_y + i, x),\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? CV_32F : CV_64F, ncn), buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        fixOrientation(img, img_orientation, dst_bpp);\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}",
    "TerrainImportOp PrepareTerrainImport(\n        const ::Assets::ResChar input[], \n        unsigned destNodeDims, unsigned destCellTreeDepth)\n    {\n        TerrainImportOp result;\n        result._sourceDims = UInt2(0, 0);\n        result._sourceFile = input;\n        result._sourceIsGood = false;\n        result._importCoverageFormat = (unsigned)ImpliedTyping::TypeCat::Float;\n\n        auto ext = XlExtension(input);\n        if (ext && (!XlCompareStringI(ext, \"hdr\") || !XlCompareStringI(ext, \"flt\"))) {\n\n            result._sourceFormat = TerrainImportOp::SourceFormat::AbsoluteFloats;\n            result._sourceHeightRange = Float2(FLT_MAX, -FLT_MAX);\n\n            ::Assets::ResChar inputFile[MaxPath];\n            XlCopyString(inputFile, input);\n            XlChopExtension(inputFile);\n            XlCatString(inputFile, dimof(inputFile), \".hdr\");\n\n            size_t fileSize = 0;\n            auto block = LoadFileAsMemoryBlock(inputFile, &fileSize);\n            if (block.get() && fileSize) {\n                std::string configAsString(block.get(), &block[fileSize]);\n                std::regex parse(\"^(\\\\S+)\\\\s+(.*)\");\n\n                std::vector<int> captureGroups;\n                captureGroups.push_back(1);\n                captureGroups.push_back(2);\n    \n                const std::sregex_token_iterator end;\n                std::sregex_token_iterator iter(configAsString.begin(), configAsString.end(), parse, captureGroups);\n                for (;iter != end;) {\n                    auto paramName = *iter++;\n                    auto paramValue = *iter++;\n\n                        //  we ignore many parameters. But we at least need to get ncols & nrows\n                        //  These tell us the dimensions of the input data\n                    if (!XlCompareStringI(paramName.str().c_str(), \"ncols\")) { result._sourceDims[0] = XlAtoI32(paramValue.str().c_str()); }\n                    if (!XlCompareStringI(paramName.str().c_str(), \"nrows\")) { result._sourceDims[1] = XlAtoI32(paramValue.str().c_str()); }\n                }\n\n                result._sourceIsGood = true;\n            } else {\n                result._warnings.push_back(\"Could not open input file\");\n            }\n\n        } else if (ext && (!XlCompareStringI(ext, \"tif\") || !XlCompareStringI(ext, \"tiff\"))) {\n\n            auto oldWarningHandler = TIFFSetWarningHandler(&TIFFWarningHandler);\n            auto oldErrorHandler = TIFFSetErrorHandler(&TIFFErrorHandler);\n            s_tiffWarningVector = &result._warnings;\n            auto autoClose = MakeAutoClose([oldWarningHandler, oldErrorHandler]() \n                {\n                    TIFFSetWarningHandler(oldWarningHandler);\n                    TIFFSetErrorHandler(oldErrorHandler);\n                    s_tiffWarningVector = nullptr;\n                });\n            \n            auto* tif = TIFFOpen(input, \"r\");\n            if (tif) {\n                auto autoClose = MakeAutoClose([tif]() { TIFFClose(tif); });\n\n                TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &result._sourceDims[0]);\n                TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &result._sourceDims[1]);\n\n                uint32 bitsPerPixel = 32;\n                uint32 sampleFormat = SAMPLEFORMAT_IEEEFP;\n                TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerPixel);\n                TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n                switch (sampleFormat) {\n                case SAMPLEFORMAT_UINT:\n\t\t\t\t\tresult._sourceFormat = TerrainImportOp::SourceFormat::Quantized;\n                    if (bitsPerPixel == 8)          { result._sourceHeightRange = Float2(0.f, float(0xff)); result._importCoverageFormat = (unsigned)ImpliedTyping::TypeCat::UInt8; }\n                    else if (bitsPerPixel == 16)    { result._sourceHeightRange = Float2(0.f, float(0xffff)); result._importCoverageFormat = (unsigned)ImpliedTyping::TypeCat::UInt16; }\n                    else if (bitsPerPixel == 32)    { result._sourceHeightRange = Float2(0.f, float(0xffffffff)); result._importCoverageFormat = (unsigned)ImpliedTyping::TypeCat::UInt32; }\n                    else                            { result._warnings.push_back(\"Bad bits per pixel\"); return result; }\n                    break;\n\n                case SAMPLEFORMAT_INT:\n                    result._sourceFormat = TerrainImportOp::SourceFormat::Quantized;\n                    if (bitsPerPixel == 8)          { result._sourceHeightRange = Float2(float( INT8_MIN), float( INT8_MAX)); result._importCoverageFormat = (unsigned)ImpliedTyping::TypeCat::UInt8; }\n                    else if (bitsPerPixel == 16)    { result._sourceHeightRange = Float2(float(INT16_MIN), float(INT16_MAX)); result._importCoverageFormat = (unsigned)ImpliedTyping::TypeCat::UInt16; }\n                    else if (bitsPerPixel == 32)    { result._sourceHeightRange = Float2(float(INT32_MIN), float(INT32_MAX)); result._importCoverageFormat = (unsigned)ImpliedTyping::TypeCat::UInt32; }\n                    else                            { result._warnings.push_back(\"Bad bits per pixel\"); return result; }\n                    break;\n\n                case SAMPLEFORMAT_IEEEFP:\n                    result._sourceFormat = TerrainImportOp::SourceFormat::AbsoluteFloats;\n                    if (bitsPerPixel != 16 && bitsPerPixel != 32)\n                        { result._warnings.push_back(\"Bad bits per pixel\"); return result; }\n\n                    result._importCoverageFormat = (unsigned)ImpliedTyping::TypeCat::Float;     // (todo -- float16 support?)\n                    break;\n\n                default:\n                    result._warnings.push_back(\"Unsupported sample format\");\n                    return result;\n                }\n\n                result._sourceIsGood = true;\n            } else {\n                result._warnings.push_back(\"Could not open tiff file\");\n            }\n\n        } else {\n            result._warnings.push_back(\"Unknown input file format\");\n        }\n\n        result._importMins = UInt2(0, 0);\n        result._importMaxs = ClampImportDims(result._sourceDims, destNodeDims, destCellTreeDepth);\n        result._importHeightRange = result._sourceHeightRange;\n        return result;\n    }",
    "bool hasAssociatedAlpha()\n    {\n        uint16_t extra = EXTRASAMPLE_UNSPECIFIED;\n        // WAR to avoid random segfaults when TIFFTAG_EXTRASAMPLES exists.\n        // The first 3(?) values get filled with random garbage (libtiff 4.0.6).\n        //\n        // The documentation for TIFFGetField states there should be two params:\n        // TIFFTAG_EXTRASAMPLES  2    uint16*,uint16** count & types array\n        //\n        // Which is probably for symmetry with TIFFSetField:\n        // TIFFTAG_EXTRASAMPLES\t 2    uint16,uint16*   count & types array\n        //\n        // Except when reading the value of the parameter is written in the\n        // first variable...\n        std::array<int16_t, 10> overflowBuffer;\n        TIFFGetField(tif.get(), TIFFTAG_EXTRASAMPLES, &extra, &overflowBuffer);\n        return extra == EXTRASAMPLE_ASSOCALPHA;\n    }",
    "QSize TiffPyramidReader::getImageSize() const\n{\n    QSize size;\n    TIFFGetField(_impl->tif.get(), TIFFTAG_IMAGEWIDTH, &size.rwidth());\n    TIFFGetField(_impl->tif.get(), TIFFTAG_IMAGELENGTH, &size.rheight());\n    return size;\n}",
    "QSize TiffPyramidReader::getTileSize() const\n{\n    QSize size;\n    TIFFGetField(_impl->tif.get(), TIFFTAG_TILEWIDTH, &size.rwidth());\n    TIFFGetField(_impl->tif.get(), TIFFTAG_TILELENGTH, &size.rheight());\n    return size;\n}",
    "int TiffPyramidReader::getBytesPerPixel() const\n{\n    int value = 0;\n    TIFFGetField(_impl->tif.get(), TIFFTAG_SAMPLESPERPIXEL, &value);\n    return value;\n}",
    "GTiffRasterBand::GTiffRasterBand( GTiffDataset *poDSIn, int nBandIn ) :\n    eBandInterp(GCI_Undefined),\n    bHaveOffsetScale(false),\n    dfOffset(0.0),\n    dfScale(1.0),\n    poGDS(poDSIn),\n    bNoDataSet(false),\n    dfNoDataValue(-9999.0)\n{\n    poDS = poDSIn;\n    nBand = nBandIn;\n\n/* -------------------------------------------------------------------- */\n/*      Get the GDAL data type.                                         */\n/* -------------------------------------------------------------------- */\n    const uint16 nBitsPerSample = poGDS->nBitsPerSample;\n    const uint16 nSampleFormat = poGDS->nSampleFormat;\n\n    eDataType = GDT_Unknown;\n\n    if( nBitsPerSample <= 8 )\n    {\n        eDataType = GDT_Byte;\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            oGTiffMDMD.SetMetadataItem( \"PIXELTYPE\", \"SIGNEDBYTE\",\n                                        \"IMAGE_STRUCTURE\" );\n    }\n    else if( nBitsPerSample <= 16 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int16;\n        else\n            eDataType = GDT_UInt16;\n    }\n    else if( nBitsPerSample == 32 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt16;\n        else if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float32;\n        else if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int32;\n        else\n            eDataType = GDT_UInt32;\n    }\n    else if( nBitsPerSample == 64 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float64;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat32;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt32;\n    }\n    else if( nBitsPerSample == 128 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat64;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try to work out band color interpretation.                      */\n/* -------------------------------------------------------------------- */\n    bool bLookForExtraSamples = false;\n\n    if( poGDS->poColorTable != nullptr && nBand == 1 )\n    {\n        eBandInterp = GCI_PaletteIndex;\n    }\n    else if( poGDS->nPhotometric == PHOTOMETRIC_RGB\n             || (poGDS->nPhotometric == PHOTOMETRIC_YCBCR\n                 && poGDS->nCompression == COMPRESSION_JPEG\n                 && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                    \"YES\") )) )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_RedBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_GreenBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_BlueBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( poGDS->nPhotometric == PHOTOMETRIC_YCBCR )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_YCbCr_YBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_YCbCr_CbBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_YCbCr_CrBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( poGDS->nPhotometric == PHOTOMETRIC_SEPARATED )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_CyanBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_MagentaBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_YellowBand;\n        else if( nBand == 4 )\n            eBandInterp = GCI_BlackBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( poGDS->nPhotometric == PHOTOMETRIC_MINISBLACK && nBand == 1 )\n    {\n        eBandInterp = GCI_GrayIndex;\n    }\n    else\n    {\n        bLookForExtraSamples = true;\n    }\n\n    if( bLookForExtraSamples )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n\n        if( TIFFGetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            const int nBaseSamples = poGDS->nSamplesPerPixel - count;\n            const int nExpectedBaseSamples =\n                (poGDS->nPhotometric == PHOTOMETRIC_MINISBLACK) ? 1 :\n                (poGDS->nPhotometric == PHOTOMETRIC_MINISWHITE) ? 1 :\n                (poGDS->nPhotometric == PHOTOMETRIC_RGB) ? 3 :\n                (poGDS->nPhotometric == PHOTOMETRIC_YCBCR) ? 3 :\n                (poGDS->nPhotometric == PHOTOMETRIC_SEPARATED) ? 4 : 0;\n\n            if( nExpectedBaseSamples > 0 &&\n                nBand == nExpectedBaseSamples + 1 &&\n                nBaseSamples != nExpectedBaseSamples )\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"Wrong number of ExtraSamples : %d. %d were expected\",\n                         count, poGDS->nSamplesPerPixel - nExpectedBaseSamples);\n            }\n\n            if( nBand > nBaseSamples\n                && nBand-nBaseSamples-1 < count\n                && (v[nBand-nBaseSamples-1] == EXTRASAMPLE_ASSOCALPHA\n                    || v[nBand-nBaseSamples-1] == EXTRASAMPLE_UNASSALPHA) )\n                eBandInterp = GCI_AlphaBand;\n            else\n                eBandInterp = GCI_Undefined;\n        }\n        else\n        {\n            eBandInterp = GCI_Undefined;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Establish block size for strip or tiles.                        */\n/* -------------------------------------------------------------------- */\n    nBlockXSize = poGDS->nBlockXSize;\n    nBlockYSize = poGDS->nBlockYSize;\n}",
    "int GTiffRasterBand::DirectIO( GDALRWFlag eRWFlag,\n                               int nXOff, int nYOff, int nXSize, int nYSize,\n                               void * pData, int nBufXSize, int nBufYSize,\n                               GDALDataType eBufType,\n                               GSpacing nPixelSpace, GSpacing nLineSpace,\n                               GDALRasterIOExtraArg* psExtraArg )\n{\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(eRWFlag == GF_Read &&\n          poGDS->nCompression == COMPRESSION_NONE &&\n          (poGDS->nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           poGDS->nPhotometric == PHOTOMETRIC_RGB ||\n           poGDS->nPhotometric == PHOTOMETRIC_PALETTE) &&\n          poGDS->nBitsPerSample == nDTSizeBits &&\n          poGDS->SetDirectory() /* very important to make hTIFF uptodate! */) )\n    {\n        return -1;\n    }\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) &&\n        psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"DirectIO(%d,%d,%d,%d -> %dx%d)\",\n              nXOff, nYOff, nXSize, nYSize,\n              nBufXSize, nBufYSize );\n#endif\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( poGDS->GetAccess() == GA_Update )\n    {\n        poGDS->FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( poGDS->hTIFF ) );\n    }\n\n    if( TIFFIsTiled( poGDS->hTIFF ) )\n    {\n        if( poGDS->m_pTempBufferForCommonDirectIO == nullptr )\n        {\n            const int nDTSize = nDTSizeBits / 8;\n            poGDS->m_nTempBufferForCommonDirectIOSize =\n                static_cast<size_t>(\n                    nBlockXSize * nBlockYSize * nDTSize *\n                    (poGDS->nPlanarConfig == PLANARCONFIG_CONTIG ?\n                     poGDS->nBands : 1) );\n\n            poGDS->m_pTempBufferForCommonDirectIO =\n                static_cast<GByte *>( VSI_MALLOC_VERBOSE(\n                    poGDS->m_nTempBufferForCommonDirectIOSize ) );\n            if( poGDS->m_pTempBufferForCommonDirectIO == nullptr )\n                return CE_Failure;\n        }\n\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( poGDS->hTIFF ));\n        FetchBufferDirectIO oFetcher(fp, poGDS->m_pTempBufferForCommonDirectIO,\n                                     poGDS->m_nTempBufferForCommonDirectIOSize);\n\n        return poGDS->CommonDirectIO(\n            oFetcher,\n            nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize,\n            eBufType,\n            1, &nBand,\n            nPixelSpace, nLineSpace,\n            0 );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    // TODO(schwehr): Make ppData be GByte**.\n    void** ppData = static_cast<void **>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void*)) );\n    vsi_l_offset* panOffsets = static_cast<vsi_l_offset *>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)) );\n    size_t* panSizes = static_cast<size_t *>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)) );\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void* pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands =\n        poGDS->nPlanarConfig == PLANARCONFIG_CONTIG ? poGDS->nBands : 1;\n    int nSrcPixelSize = nDTSize * nContigBands;\n\n    if( ppData == nullptr || panOffsets == nullptr || panSizes == nullptr )\n        eErr = CE_Failure;\n    else if( nXSize != nBufXSize || nYSize != nBufYSize ||\n             eBufType != eDataType ||\n             nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n             nContigBands > 1 )\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC_VERBOSE(nReqXSize * nReqYSize * nSrcPixelSize);\n        if( pTmpBuffer == nullptr )\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    for( int iLine = 0; eErr == CE_None && iLine < nReqYSize; ++iLine )\n    {\n        if( pTmpBuffer == nullptr )\n            ppData[iLine] = static_cast<GByte *>(pData) + iLine * nLineSpace;\n        else\n            ppData[iLine] =\n                static_cast<GByte *>(pTmpBuffer) +\n                iLine * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if( nBufYSize < nYSize )  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast<int>((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n        if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            nBlockId += (nBand-1) * poGDS->nBlocksPerBand;\n        }\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if( panOffsets[iLine] == 0 )  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff + nYOffsetInBlock * nBlockXSize) * nSrcPixelSize;\n        panSizes[iLine] = nReqXSize * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if( eErr == CE_None )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( poGDS->hTIFF ));\n        const int nRet =\n            VSIFReadMultiRangeL( nReqYSize, ppData, panOffsets, panSizes, fp );\n        if( nRet != 0 )\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if( eErr == CE_None && TIFFIsByteSwapped(poGDS->hTIFF) )\n    {\n        for( int iLine = 0; iLine < nReqYSize; ++iLine )\n        {\n            if( GDALDataTypeIsComplex(eDataType) )\n                GDALSwapWords( ppData[iLine], nDTSize / 2,\n                               2 * nReqXSize * nContigBands, nDTSize / 2 );\n            else\n                GDALSwapWords( ppData[iLine], nDTSize,\n                               nReqXSize * nContigBands, nDTSize );\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    if( eErr == CE_None && pTmpBuffer != nullptr )\n    {\n        for( int iY=0; iY < nBufYSize; ++iY )\n        {\n            const int iSrcY =\n                nBufYSize <= nYSize ?\n                iY : static_cast<int>((iY + 0.5) * dfSrcYInc);\n\n            GByte* pabySrcData =\n                static_cast<GByte*>(ppData[iSrcY]) +\n                (nContigBands > 1 ? (nBand-1) : 0) * nDTSize;\n            GByte* pabyDstData =\n                static_cast<GByte *>(pData) + iY * nLineSpace;\n            if( nBufXSize == nXSize )\n            {\n                GDALCopyWords( pabySrcData,\n                               eDataType,\n                               nSrcPixelSize,\n                               pabyDstData,\n                               eBufType,\n                               static_cast<int>(nPixelSpace),\n                               nBufXSize );\n            }\n            else\n            {\n                if( eDataType == GDT_Byte && eBufType == GDT_Byte )\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for( int iX = 0; iX < nBufXSize; ++iX, dfSrcX += dfSrcXInc )\n                    {\n                        const int iSrcX = static_cast<int>(dfSrcX);\n                        pabyDstData[iX * nPixelSpace] =\n                            pabySrcData[iSrcX * nSrcPixelSize];\n                    }\n                }\n                else\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for( int iX = 0; iX < nBufXSize; ++iX, dfSrcX += dfSrcXInc )\n                    {\n                        const int iSrcX = static_cast<int>(dfSrcX);\n                        GDALCopyWords( pabySrcData + iSrcX * nSrcPixelSize,\n                                       eDataType, 0,\n                                       pabyDstData + iX * nPixelSpace,\n                                       eBufType, 0, 1 );\n                    }\n                }\n            }\n        }\n    }\n\n    // Cleanup.\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}",
    "CPLVirtualMem* GTiffRasterBand::GetVirtualMemAutoInternal( GDALRWFlag eRWFlag,\n                                                           int *pnPixelSpace,\n                                                           GIntBig *pnLineSpace,\n                                                           char **papszOptions )\n{\n    int nLineSize = nBlockXSize * GDALGetDataTypeSizeBytes(eDataType);\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        nLineSize *= poGDS->nBands;\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        // In case of a pixel interleaved file, we save virtual memory space\n        // by reusing a base mapping that embraces the whole imagery.\n        if( poGDS->pBaseMapping != nullptr )\n        {\n            // Offset between the base mapping and the requested mapping.\n            vsi_l_offset nOffset =\n                static_cast<vsi_l_offset>(nBand - 1) *\n                GDALGetDataTypeSizeBytes(eDataType);\n\n            GTiffRasterBand** ppoSelf =\n                static_cast<GTiffRasterBand** >(\n                    CPLCalloc(1, sizeof(GTiffRasterBand*)) );\n            *ppoSelf = this;\n\n            CPLVirtualMem* pVMem = CPLVirtualMemDerivedNew(\n                poGDS->pBaseMapping,\n                nOffset,\n                CPLVirtualMemGetSize(poGDS->pBaseMapping) - nOffset,\n                GTiffRasterBand::DropReferenceVirtualMem,\n                ppoSelf);\n            if( pVMem == nullptr )\n            {\n                CPLFree(ppoSelf);\n                return nullptr;\n            }\n\n            // Mechanism used so that the memory mapping object can be\n            // destroyed after the raster band.\n            aSetPSelf.insert(ppoSelf);\n            ++poGDS->nRefBaseMapping;\n            *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n            if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n                *pnPixelSpace *= poGDS->nBands;\n            *pnLineSpace = nLineSize;\n            return pVMem;\n        }\n    }\n\n    if( !poGDS->SetDirectory() )  // Very important to make hTIFF up-to-date.\n        return nullptr;\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( poGDS->hTIFF ));\n\n    vsi_l_offset nLength = static_cast<vsi_l_offset>(nRasterYSize) * nLineSize;\n\n    if( !(CPLIsVirtualMemFileMapAvailable() &&\n          VSIFGetNativeFileDescriptorL(fp) != nullptr &&\n#if SIZEOF_VOIDP == 4\n          nLength == static_cast<size_t>(nLength) &&\n#endif\n          poGDS->nCompression == COMPRESSION_NONE &&\n          (poGDS->nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           poGDS->nPhotometric == PHOTOMETRIC_RGB ||\n           poGDS->nPhotometric == PHOTOMETRIC_PALETTE) &&\n          poGDS->nBitsPerSample == GDALGetDataTypeSizeBits(eDataType) &&\n          !TIFFIsTiled( poGDS->hTIFF ) && !TIFFIsByteSwapped(poGDS->hTIFF)) )\n    {\n        return nullptr;\n    }\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( poGDS->GetAccess() == GA_Update )\n    {\n        poGDS->FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( poGDS->hTIFF ) );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return nullptr;\n    }\n\n    int nBlockSize =\n        nBlockXSize * nBlockYSize * GDALGetDataTypeSizeBytes(eDataType);\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        nBlockSize *= poGDS->nBands;\n\n    int nBlocks = poGDS->nBlocksPerBand;\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlocks *= poGDS->nBands;\n    int i = 0;  // Used after for.\n    for( ; i < nBlocks; ++i )\n    {\n        if( panTIFFOffsets[i] != 0 )\n            break;\n    }\n    if( i == nBlocks )\n    {\n        // All zeroes.\n        if( poGDS->eAccess == GA_Update )\n        {\n            // Initialize the file with empty blocks so that the file has\n            // the appropriate size.\n\n            toff_t* panByteCounts = nullptr;\n            if( !TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPBYTECOUNTS,\n                               &panByteCounts ) ||\n                panByteCounts == nullptr )\n            {\n                return nullptr;\n            }\n            if( VSIFSeekL(fp, 0, SEEK_END) != 0 )\n                return nullptr;\n            vsi_l_offset nBaseOffset = VSIFTellL(fp);\n\n            // Just write one tile with libtiff to put it in appropriate state.\n            GByte* pabyData =\n                static_cast<GByte*>(VSI_CALLOC_VERBOSE(1, nBlockSize));\n            if( pabyData == nullptr )\n            {\n                return nullptr;\n            }\n            int ret =\n                static_cast<int>(\n                    TIFFWriteEncodedStrip( poGDS->hTIFF, 0, pabyData,\n                                           nBlockSize ) );\n            VSI_TIFFFlushBufferedWrite( TIFFClientdata( poGDS->hTIFF ) );\n            VSIFree(pabyData);\n            if( ret != nBlockSize )\n            {\n                return nullptr;\n            }\n            CPLAssert(panTIFFOffsets[0] == nBaseOffset);\n            CPLAssert(panByteCounts[0] == static_cast<toff_t>(nBlockSize));\n\n            // Now simulate the writing of other blocks.\n            const vsi_l_offset nDataSize =\n                static_cast<vsi_l_offset>(nBlockSize) * nBlocks;\n            if( VSIFTruncateL(fp, nBaseOffset + nDataSize) != 0 )\n                return nullptr;\n\n            for( i = 1; i < nBlocks; ++i)\n            {\n                panTIFFOffsets[i] =\n                    nBaseOffset + i * static_cast<toff_t>(nBlockSize);\n                panByteCounts[i] = nBlockSize;\n            }\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"Sparse files not supported in file mapping\" );\n            return nullptr;\n        }\n    }\n\n    GIntBig nBlockSpacing = 0;\n    bool bCompatibleSpacing = true;\n    toff_t nPrevOffset = 0;\n    for( i = 0; i < poGDS->nBlocksPerBand; ++i )\n    {\n        toff_t nCurOffset = 0;\n        if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n            nCurOffset =\n                panTIFFOffsets[poGDS->nBlocksPerBand * (nBand - 1) + i];\n        else\n            nCurOffset = panTIFFOffsets[i];\n        if( nCurOffset == 0 )\n        {\n            bCompatibleSpacing = false;\n            break;\n        }\n        if( i > 0 )\n        {\n            const GIntBig nCurSpacing = nCurOffset - nPrevOffset;\n            if( i == 1 )\n            {\n                if( nCurSpacing !=\n                    static_cast<GIntBig>(nBlockYSize) * nLineSize )\n                {\n                    bCompatibleSpacing = false;\n                    break;\n                }\n                nBlockSpacing = nCurSpacing;\n            }\n            else if( nBlockSpacing != nCurSpacing )\n            {\n                bCompatibleSpacing = false;\n                break;\n            }\n        }\n        nPrevOffset = nCurOffset;\n    }\n\n    if( !bCompatibleSpacing )\n    {\n        return nullptr;\n    }\n\n    vsi_l_offset nOffset = 0;\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        CPLAssert( poGDS->pBaseMapping == nullptr );\n        nOffset = panTIFFOffsets[0];\n    }\n    else\n    {\n        nOffset = panTIFFOffsets[poGDS->nBlocksPerBand * (nBand - 1)];\n    }\n    CPLVirtualMem* pVMem = CPLVirtualMemFileMapNew(\n        fp, nOffset, nLength,\n        eRWFlag == GF_Write ? VIRTUALMEM_READWRITE : VIRTUALMEM_READONLY,\n        nullptr, nullptr);\n    if( pVMem == nullptr )\n    {\n        return nullptr;\n    }\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        // TODO(schwehr): Revisit this block.\n        poGDS->pBaseMapping = pVMem;\n        pVMem = GetVirtualMemAutoInternal( eRWFlag,\n                                           pnPixelSpace,\n                                           pnLineSpace,\n                                           papszOptions );\n        // Drop ref on base mapping.\n        CPLVirtualMemFree(poGDS->pBaseMapping);\n        if( pVMem == nullptr )\n            poGDS->pBaseMapping = nullptr;\n    }\n    else\n    {\n        *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n        if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n            *pnPixelSpace *= poGDS->nBands;\n        *pnLineSpace = nLineSize;\n    }\n    return pVMem;\n}",
    "CPLErr GTiffDataset::CommonDirectIO(\n    FetchBuffer& oFetcher,\n    int nXOff, int nYOff, int nXSize, int nYSize,\n    void * pData, int nBufXSize, int nBufYSize,\n    GDALDataType eBufType,\n    int nBandCount, int *panBandMap,\n    GSpacing nPixelSpace, GSpacing nLineSpace,\n    GSpacing nBandSpace )\n{\n    const GDALDataType eDataType = GetRasterBand(1)->GetRasterDataType();\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    const bool bIsComplex = CPL_TO_BOOL(GDALDataTypeIsComplex(eDataType));\n    const int nBufDTSize = GDALGetDataTypeSizeBytes(eBufType);\n\n    // Get strip offsets.\n    toff_t *panOffsets = nullptr;\n    if( !TIFFGetField( hTIFF, (TIFFIsTiled( hTIFF )) ?\n                       TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                       &panOffsets ) ||\n        panOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    bool bUseContigImplementation =\n        nPlanarConfig == PLANARCONFIG_CONTIG &&\n        nBandCount > 1 &&\n        nBandSpace == nBufDTSize;\n    if( bUseContigImplementation )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            const int nBand = panBandMap[iBand];\n            if( nBand != iBand + 1 )\n            {\n                bUseContigImplementation = false;\n                break;\n            }\n        }\n    }\n\n    const int nBandsPerBlock =\n        nPlanarConfig == PLANARCONFIG_SEPARATE ? 1 : nBands;\n    const int nBandsPerBlockDTSize = nBandsPerBlock * nDTSize;\n    const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    const bool bNoTypeChange = (eDataType == eBufType);\n    const bool bNoXResampling = (nXSize == nBufXSize );\n    const bool bNoXResamplingNoTypeChange = (bNoTypeChange && bNoXResampling);\n    const bool bByteOnly = (bNoTypeChange && nDTSize == 1 );\n    const bool bByteNoXResampling = ( bByteOnly && bNoXResamplingNoTypeChange );\n    const bool bIsByteSwapped = CPL_TO_BOOL(TIFFIsByteSwapped(hTIFF));\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    int bNoDataSetIn = FALSE;\n    double dfNoData = GetRasterBand(1)->GetNoDataValue( &bNoDataSetIn );\n    GByte abyNoData = 0;\n    if( !bNoDataSetIn )\n        dfNoData = 0;\n    else if( dfNoData >= 0 && dfNoData <= 255 )\n        abyNoData = static_cast<GByte>(dfNoData + 0.5);\n\n    if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( hTIFF ) && bNoXResampling && (nYSize == nBufYSize ) &&\n             nPlanarConfig == PLANARCONFIG_CONTIG && nBandCount > 1 )\n    {\n        GByte* pabyData = static_cast<GByte *>(pData);\n        for( int y = 0; y < nBufYSize; )\n        {\n            const int nSrcLine = nYOff + y;\n            const int nBlockYOff = nSrcLine / nBlockYSize;\n            const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n            const int nUsedBlockHeight =\n                std::min( nBufYSize - y,\n                          nBlockYSize - nYOffsetInBlock );\n\n            int nBlockXOff = nXOff / nBlockXSize;\n            int nXOffsetInBlock = nXOff % nBlockXSize;\n            int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n            int x = 0;\n            while( x < nBufXSize )\n            {\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                const int nUsedBlockWidth =\n                    std::min( nBlockXSize - nXOffsetInBlock,\n                              nBufXSize - x );\n\n                if( nCurOffset == 0 )\n                {\n                    REACHED(30);\n                    for( int k = 0; k < nUsedBlockHeight; ++k )\n                    {\n                        GByte* pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for( int iBand = 0; iBand < nBandCount; ++iBand )\n                        {\n                            GByte* pabyLocalDataBand =\n                                pabyLocalData + iBand * nBandSpace;\n\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalDataBand, eBufType,\n                                static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth );\n                        }\n                    }\n                }\n                else\n                {\n                    const int nByteOffsetInBlock =\n                        nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n                    const GByte* pabyLocalSrcDataK0 = oFetcher.FetchBytes(\n                            nCurOffset + nByteOffsetInBlock,\n                            nBlockXSize *\n                            nUsedBlockHeight * nBandsPerBlock,\n                            nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                    if( pabyLocalSrcDataK0 == nullptr )\n                        return CE_Failure;\n\n                    for( int k = 0; k < nUsedBlockHeight; ++k )\n                    {\n                        GByte* pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        const GByte* pabyLocalSrcData =\n                            pabyLocalSrcDataK0 +\n                            (k * nBlockXSize + nXOffsetInBlock) *\n                            nBandsPerBlockDTSize;\n\n                        if( bUseContigImplementation && nBands == nBandCount &&\n                            nPixelSpace == nBandsPerBlockDTSize )\n                        {\n                            REACHED(31);\n                            GDALCopyWords( pabyLocalSrcData,\n                                           eDataType, nDTSize,\n                                           pabyLocalData,\n                                           eBufType, nBufDTSize,\n                                           nUsedBlockWidth * nBands );\n                        }\n                        else\n                        {\n                            REACHED(32);\n                            for( int iBand = 0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand]-1) * nDTSize;\n\n                                GDALCopyWords(\n                                    pabyLocalSrcDataBand,\n                                    eDataType, nBandsPerBlockDTSize,\n                                    pabyLocalDataBand,\n                                    eBufType, static_cast<int>(nPixelSpace),\n                                    nUsedBlockWidth );\n                            }\n                        }\n                    }\n                }\n\n                nXOffsetInBlock = 0;\n                ++nBlockXOff;\n                ++nBlockId;\n                x += nUsedBlockWidth;\n            }\n\n            y += nUsedBlockHeight;\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( hTIFF ) && bNoXResampling &&\n             (nYSize == nBufYSize ) )\n             // && (nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            GByte* pabyData = static_cast<GByte *>(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            for( int y = 0; y < nBufYSize; )\n            {\n                const int nSrcLine = nYOff + y;\n                const int nBlockYOff = nSrcLine / nBlockYSize;\n                const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                const int nUsedBlockHeight =\n                    std::min( nBufYSize - y,\n                              nBlockYSize - nYOffsetInBlock);\n\n                int nBlockXOff = nXOff / nBlockXSize;\n                int nXOffsetInBlock = nXOff % nBlockXSize;\n                int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n                if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                {\n                    REACHED(33);\n                    nBlockId += nBlocksPerBand * (nBand - 1);\n                }\n                else\n                {\n                    REACHED(34);\n                }\n\n                int x = 0;\n                while( x < nBufXSize )\n                {\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    const int nUsedBlockWidth =\n                        std::min(\n                            nBlockXSize - nXOffsetInBlock,\n                            nBufXSize - x);\n\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(35);\n                        for( int k = 0; k < nUsedBlockHeight; ++k )\n                        {\n                            GByte* pabyLocalData =\n                                pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData, eBufType,\n                                static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth );\n                        }\n                    }\n                    else\n                    {\n                        const int nByteOffsetInBlock =\n                            nYOffsetInBlock * nBlockXSize *\n                            nBandsPerBlockDTSize;\n                        const GByte* pabyLocalSrcDataK0 =\n                            oFetcher.FetchBytes(\n                                nCurOffset + nByteOffsetInBlock,\n                                nBlockXSize *\n                                nUsedBlockHeight * nBandsPerBlock,\n                                nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                        if( pabyLocalSrcDataK0 == nullptr )\n                            return CE_Failure;\n\n                        if( nPlanarConfig == PLANARCONFIG_CONTIG )\n                        {\n                            REACHED(36);\n                            pabyLocalSrcDataK0 += (nBand - 1) * nDTSize;\n                        }\n                        else\n                        {\n                            REACHED(37);\n                        }\n\n                        for( int k = 0; k < nUsedBlockHeight; ++k )\n                        {\n                            GByte* pabyLocalData =\n                                pabyData + (y + k) * nLineSpace +\n                                x * nPixelSpace;\n                            const GByte* pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (k * nBlockXSize + nXOffsetInBlock) *\n                                nBandsPerBlockDTSize;\n\n                            GDALCopyWords(\n                                pabyLocalSrcData,\n                                eDataType, nBandsPerBlockDTSize,\n                                pabyLocalData,\n                                eBufType, static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth);\n                        }\n                    }\n\n                    nXOffsetInBlock = 0;\n                    ++nBlockXOff;\n                    ++nBlockId;\n                    x += nUsedBlockWidth;\n                }\n\n                y += nUsedBlockHeight;\n            }\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( hTIFF ) &&\n             nPlanarConfig == PLANARCONFIG_CONTIG && nBandCount > 1 )\n    {\n        GByte* pabyData = static_cast<GByte *>(pData);\n        int anSrcYOffset[256] = { 0 };\n        for( int y = 0; y < nBufYSize; )\n        {\n            const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n            const int nSrcLine = static_cast<int>(dfYOffStart);\n            const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n            const int nBlockYOff = nSrcLine / nBlockYSize;\n            const int nBaseByteOffsetInBlock =\n                nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n            int ychunk = 1;\n            int nLastSrcLineK = nSrcLine;\n            anSrcYOffset[0] = 0;\n            for( int k = 1; k < nBufYSize - y; ++k )\n            {\n                int nSrcLineK =\n                    nYOff + static_cast<int>((y + k + 0.5) * dfSrcYInc);\n                const int nBlockYOffK = nSrcLineK / nBlockYSize;\n                if( k < 256)\n                    anSrcYOffset[k] =\n                        ((nSrcLineK % nBlockYSize) - nYOffsetInBlock) *\n                        nBlockXSize * nBandsPerBlockDTSize;\n                if( nBlockYOffK != nBlockYOff )\n                {\n                    break;\n                }\n                ++ychunk;\n                nLastSrcLineK = nSrcLineK;\n            }\n            const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n            // CPLAssert(nUsedBlockHeight <= nBlockYSize);\n\n            double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n            int nCurBlockXOff = 0;\n            int nNextBlockXOff = 0;\n            toff_t nCurOffset = 0;\n            const GByte* pabyLocalSrcDataStartLine = nullptr;\n            for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc)\n            {\n                const int nSrcPixel = static_cast<int>(dfSrcX);\n                if( nSrcPixel >= nNextBlockXOff )\n                {\n                    const int nBlockXOff = nSrcPixel / nBlockXSize;\n                    nCurBlockXOff = nBlockXOff * nBlockXSize;\n                    nNextBlockXOff = nCurBlockXOff + nBlockXSize;\n                    const int nBlockId =\n                        nBlockXOff + nBlockYOff * nBlocksPerRow;\n                    nCurOffset = panOffsets[nBlockId];\n                    if( nCurOffset != 0 )\n                    {\n                        pabyLocalSrcDataStartLine =\n                            oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetInBlock,\n                                nBlockXSize *\n                                nBandsPerBlock * nUsedBlockHeight,\n                                nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId);\n                        if( pabyLocalSrcDataStartLine == nullptr )\n                            return CE_Failure;\n                    }\n                }\n\n                if( nCurOffset == 0 )\n                {\n                    REACHED(38);\n\n                    for( int k = 0; k < ychunk; ++k )\n                    {\n                        GByte* const pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for( int iBand = 0; iBand < nBandCount; ++iBand )\n                        {\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData + nBandSpace * iBand, eBufType, 0,\n                                1);\n                        }\n                    }\n                }\n                else\n                {\n                    const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                    double dfYOff = dfYOffStart;\n                    const GByte* const pabyLocalSrcDataK0 =\n                        pabyLocalSrcDataStartLine +\n                        nXOffsetInBlock * nBandsPerBlockDTSize;\n                    GByte* pabyLocalData =\n                        pabyData + y * nLineSpace + x * nPixelSpace;\n                    for( int k = 0;\n                         k < ychunk;\n                         ++k, pabyLocalData += nLineSpace )\n                    {\n                        const GByte* pabyLocalSrcData = nullptr;\n                        if( ychunk <= 256 )\n                        {\n                            REACHED(39);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 + anSrcYOffset[k];\n                        }\n                        else\n                        {\n                            REACHED(40);\n                            const int nYOffsetInBlockK =\n                                static_cast<int>(dfYOff) % nBlockYSize;\n                            // CPLAssert(\n                            //     nYOffsetInBlockK - nYOffsetInBlock <=\n                            //     nUsedBlockHeight);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (nYOffsetInBlockK - nYOffsetInBlock) *\n                                nBlockXSize * nBandsPerBlockDTSize;\n                            dfYOff += dfSrcYInc;\n                        }\n\n                        if( bByteOnly )\n                        {\n                            REACHED(41);\n                            for( int iBand=0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData + (panBandMap[iBand]-1);\n                                *pabyLocalDataBand = *pabyLocalSrcDataBand;\n                            }\n                        }\n                        else\n                        {\n                            REACHED(42);\n                            for( int iBand = 0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand]-1) * nDTSize;\n\n                                GDALCopyWords( pabyLocalSrcDataBand,\n                                               eDataType, 0,\n                                               pabyLocalDataBand,\n                                               eBufType, 0,\n                                               1 );\n                            }\n                        }\n                    }\n                }\n            }\n\n            y += ychunk;\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( hTIFF ) )\n             // && (nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            GByte* pabyData = static_cast<GByte*>(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            int anSrcYOffset[256] = { 0 };\n            for( int y = 0; y < nBufYSize; )\n            {\n                const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n                const int nSrcLine = static_cast<int>(dfYOffStart);\n                const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                const int nBlockYOff = nSrcLine / nBlockYSize;\n                const int nBaseByteOffsetInBlock =\n                    nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n                int ychunk = 1;\n                int nLastSrcLineK = nSrcLine;\n                anSrcYOffset[0] = 0;\n                for( int k = 1; k < nBufYSize - y; ++k )\n                {\n                    const int nSrcLineK =\n                        nYOff + static_cast<int>((y + k + 0.5) * dfSrcYInc);\n                    const int nBlockYOffK = nSrcLineK / nBlockYSize;\n                    if( k < 256)\n                        anSrcYOffset[k] =\n                            ((nSrcLineK % nBlockYSize) - nYOffsetInBlock) *\n                            nBlockXSize * nBandsPerBlockDTSize;\n                    if( nBlockYOffK != nBlockYOff )\n                    {\n                        break;\n                    }\n                    ++ychunk;\n                    nLastSrcLineK = nSrcLineK;\n                }\n                const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n                // CPLAssert(nUsedBlockHeight <= nBlockYSize);\n\n                double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                int nCurBlockXOff = 0;\n                int nNextBlockXOff = 0;\n                toff_t nCurOffset = 0;\n                const GByte* pabyLocalSrcDataStartLine = nullptr;\n                for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc )\n                {\n                    int nSrcPixel = static_cast<int>(dfSrcX);\n                    if( nSrcPixel >= nNextBlockXOff )\n                    {\n                        const int nBlockXOff = nSrcPixel / nBlockXSize;\n                        nCurBlockXOff = nBlockXOff * nBlockXSize;\n                        nNextBlockXOff = nCurBlockXOff + nBlockXSize;\n                        int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n                        if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                        {\n                            REACHED(43);\n                            nBlockId += nBlocksPerBand * (nBand - 1);\n                        }\n                        else\n                        {\n                            REACHED(44);\n                        }\n                        nCurOffset = panOffsets[nBlockId];\n                        if( nCurOffset != 0 )\n                        {\n                            pabyLocalSrcDataStartLine =\n                                oFetcher.FetchBytes(\n                                    nCurOffset + nBaseByteOffsetInBlock,\n                                    nBlockXSize *\n                                    nBandsPerBlock * nUsedBlockHeight,\n                                    nDTSize,\n                                    bIsByteSwapped, bIsComplex, nBlockId);\n                            if( pabyLocalSrcDataStartLine == nullptr )\n                                return CE_Failure;\n\n                            if( nPlanarConfig == PLANARCONFIG_CONTIG )\n                            {\n                                REACHED(45);\n                                pabyLocalSrcDataStartLine +=\n                                    (nBand - 1) * nDTSize;\n                            }\n                            else\n                            {\n                                REACHED(46);\n                            }\n                        }\n                    }\n\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(47);\n\n                        for( int k = 0; k < ychunk; ++k )\n                        {\n                            GByte* const pabyLocalData =\n                                pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n\n                            GDALCopyWords( &dfNoData, GDT_Float64, 0,\n                                           pabyLocalData, eBufType, 0,\n                                           1 );\n                        }\n                    }\n                    else\n                    {\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                        double dfYOff = dfYOffStart;\n                        const GByte* const pabyLocalSrcDataK0 =\n                            pabyLocalSrcDataStartLine +\n                            nXOffsetInBlock * nBandsPerBlockDTSize;\n                        GByte* pabyLocalData =\n                            pabyData + y * nLineSpace + x * nPixelSpace;\n                        for( int k = 0;\n                             k < ychunk;\n                             ++k, pabyLocalData += nLineSpace )\n                        {\n                            const GByte* pabyLocalSrcData = nullptr;\n                            if( ychunk <= 256 )\n                            {\n                                REACHED(48);\n                                pabyLocalSrcData =\n                                    pabyLocalSrcDataK0 + anSrcYOffset[k];\n                            }\n                            else\n                            {\n                                REACHED(49);\n                                const int nYOffsetInBlockK =\n                                    static_cast<int>(dfYOff) % nBlockYSize;\n                                // CPLAssert(\n                                //     nYOffsetInBlockK - nYOffsetInBlock <=\n                                //     nUsedBlockHeight);\n                                pabyLocalSrcData = pabyLocalSrcDataK0 +\n                                    (nYOffsetInBlockK - nYOffsetInBlock) *\n                                    nBlockXSize * nBandsPerBlockDTSize;\n                                dfYOff += dfSrcYInc;\n                            }\n\n                            if( bByteOnly )\n                            {\n                                REACHED(50);\n\n                                *pabyLocalData = *pabyLocalSrcData;\n                            }\n                            else\n                            {\n                                REACHED(51);\n\n                                GDALCopyWords( pabyLocalSrcData,\n                                               eDataType, 0,\n                                               pabyLocalData,\n                                               eBufType, 0,\n                                               1 );\n                            }\n                        }\n                    }\n                }\n\n                y += ychunk;\n            }\n        }\n    }\n    else if( bUseContigImplementation )\n    {\n        if( !FetchBuffer::bMinimizeIO && TIFFIsTiled( hTIFF ) )\n        {\n            GByte* pabyData = static_cast<GByte *>(pData);\n            for( int y = 0; y < nBufYSize; ++y )\n            {\n                const int nSrcLine =\n                    nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                const int nBlockYOff = nSrcLine / nBlockYSize;\n                const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                const int nBaseByteOffsetInBlock =\n                    nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n\n                if( bNoXResampling )\n                {\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    int nBlockXOff = nXOff / nBlockXSize;\n                    int nXOffsetInBlock = nXOff % nBlockXSize;\n                    int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n                    int x = 0;\n                    while( x < nBufXSize )\n                    {\n                        const int nByteOffsetInBlock = nBaseByteOffsetInBlock +\n                                        nXOffsetInBlock * nBandsPerBlockDTSize;\n                        const toff_t nCurOffset = panOffsets[nBlockId];\n                        const int nUsedBlockWidth =\n                            std::min(\n                                nBlockXSize - nXOffsetInBlock,\n                                nBufXSize - x);\n\n                        int nIters = nUsedBlockWidth;\n                        if( nCurOffset == 0 )\n                        {\n                            if( bByteNoXResampling )\n                            {\n                                REACHED(0);\n                                while( nIters-- > 0 )\n                                {\n                                    for( int iBand = 0;\n                                         iBand < nBandCount;\n                                         ++iBand )\n                                    {\n                                        pabyLocalData[iBand] = abyNoData;\n                                    }\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                            else\n                            {\n                                REACHED(1);\n                                while( nIters-- > 0 )\n                                {\n                                    GDALCopyWords(\n                                        &dfNoData, GDT_Float64, 0,\n                                        pabyLocalData, eBufType,\n                                        static_cast<int>(nBandSpace),\n                                        nBandCount);\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if( bNoTypeChange && nBands == nBandCount &&\n                                nPixelSpace == nBandsPerBlockDTSize )\n                            {\n                                REACHED(2);\n                                if( !oFetcher.FetchBytes(\n                                        pabyLocalData,\n                                        nCurOffset + nByteOffsetInBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId) )\n                                {\n                                    return CE_Failure;\n                                }\n                                pabyLocalData +=\n                                    nIters * nBandsPerBlock * nDTSize;\n                            }\n                            else\n                            {\n                                const GByte* pabyLocalSrcData =\n                                    oFetcher.FetchBytes(\n                                        nCurOffset + nByteOffsetInBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId);\n                                if( pabyLocalSrcData == nullptr )\n                                    return CE_Failure;\n                                if( bByteNoXResampling )\n                                {\n                                    REACHED(3);\n                                    CopyContigByteMultiBand(\n                                        pabyLocalSrcData,\n                                        nBandsPerBlockDTSize,\n                                        pabyLocalData,\n                                        static_cast<int>(nPixelSpace),\n                                        nIters,\n                                        nBandCount);\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    REACHED(4);\n                                    while( nIters-- > 0 )\n                                    {\n                                        GDALCopyWords(\n                                            pabyLocalSrcData,\n                                            eDataType, nDTSize,\n                                            pabyLocalData,\n                                            eBufType,\n                                            static_cast<int>(nBandSpace),\n                                            nBandCount);\n                                        pabyLocalSrcData +=\n                                            nBandsPerBlockDTSize;\n                                        pabyLocalData += nPixelSpace;\n                                    }\n                                }\n                            }\n                        }\n\n                        nXOffsetInBlock = 0;\n                        ++nBlockXOff;\n                        ++nBlockId;\n                        x += nUsedBlockWidth;\n                    }\n                }\n                else  // Contig, tiled, potential resampling & data type change.\n                {\n                    const GByte* pabyLocalSrcDataStartLine = nullptr;\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                    int nCurBlockXOff = 0;\n                    int nNextBlockXOff = 0;\n                    toff_t nCurOffset = 0;\n                    for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc )\n                    {\n                        int nSrcPixel = static_cast<int>(dfSrcX);\n                        if( nSrcPixel >= nNextBlockXOff )\n                        {\n                            const int nBlockXOff = nSrcPixel / nBlockXSize;\n                            nCurBlockXOff = nBlockXOff * nBlockXSize;\n                            nNextBlockXOff = nCurBlockXOff + nBlockXSize;\n                            const int nBlockId =\n                                nBlockXOff + nBlockYOff * nBlocksPerRow;\n                            nCurOffset = panOffsets[nBlockId];\n                            if( nCurOffset != 0 )\n                            {\n                                pabyLocalSrcDataStartLine =\n                                    oFetcher.FetchBytes(\n                                        nCurOffset + nBaseByteOffsetInBlock,\n                                        nBlockXSize *\n                                        nBandsPerBlock,\n                                        nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId);\n                                if( pabyLocalSrcDataStartLine == nullptr )\n                                    return CE_Failure;\n                            }\n                        }\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n\n                        if( nCurOffset == 0 )\n                        {\n                            REACHED(5);\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData,\n                                eBufType,\n                                static_cast<int>(nBandSpace),\n                                nBandCount );\n                            pabyLocalData += nPixelSpace;\n                        }\n                        else\n                        {\n                            const GByte* pabyLocalSrcData =\n                                pabyLocalSrcDataStartLine +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                            REACHED(6);\n                            if( bByteOnly )\n                            {\n                                for( int iBand = 0; iBand < nBands; ++iBand )\n                                    pabyLocalData[iBand] =\n                                        pabyLocalSrcData[iBand];\n                            }\n                            else\n                            {\n                                GDALCopyWords(\n                                    pabyLocalSrcData,\n                                    eDataType, nDTSize,\n                                    pabyLocalData,\n                                    eBufType,\n                                    static_cast<int>(nBandSpace),\n                                    nBandCount );\n                            }\n                            pabyLocalData += nPixelSpace;\n                        }\n                    }\n                }\n            }\n        }\n        else  // Contig, stripped organized.\n        {\n            GByte* pabyData = static_cast<GByte*>(pData);\n            for( int y = 0; y < nBufYSize; ++y )\n            {\n                const int nSrcLine =\n                    nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                const int nBlockYOff = nSrcLine / nBlockYSize;\n                const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                const int nBlockId = nBlockYOff;\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                if( nCurOffset == 0 )\n                {\n                    REACHED(7);\n                    for( int x = 0; x < nBufXSize; ++x )\n                    {\n                        GDALCopyWords(\n                            &dfNoData, GDT_Float64, 0,\n                            pabyData + y * nLineSpace + x * nPixelSpace,\n                            eBufType, static_cast<int>(nBandSpace),\n                            nBandCount);\n                    }\n                }\n                else\n                {\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    const int nBaseByteOffsetInBlock =\n                        (nYOffsetInBlock * nBlockXSize + nXOff) *\n                        nBandsPerBlockDTSize;\n\n                    if( bNoXResamplingNoTypeChange && nBands == nBandCount &&\n                        nPixelSpace == nBandsPerBlockDTSize )\n                    {\n                        REACHED(8);\n                        if( !oFetcher.FetchBytes(\n                               pabyLocalData,\n                               nCurOffset + nBaseByteOffsetInBlock,\n                               nXSize * nBandsPerBlock, nDTSize, bIsByteSwapped,\n                               bIsComplex, nBlockId) )\n                        {\n                            return CE_Failure;\n                        }\n                    }\n                    else\n                    {\n                        const GByte* pabyLocalSrcData = oFetcher.FetchBytes(\n                            nCurOffset + nBaseByteOffsetInBlock,\n                            nXSize * nBandsPerBlock, nDTSize, bIsByteSwapped,\n                            bIsComplex, nBlockId);\n                        if( pabyLocalSrcData == nullptr )\n                            return CE_Failure;\n\n                        if( bByteNoXResampling )\n                        {\n                            REACHED(9);\n                            CopyContigByteMultiBand(\n                                pabyLocalSrcData,\n                                nBandsPerBlockDTSize,\n                                pabyLocalData,\n                                static_cast<int>(nPixelSpace),\n                                nBufXSize,\n                                nBandCount);\n                        }\n                        else if( bByteOnly )\n                        {\n                            REACHED(10);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for( int x = 0;\n                                 x < nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc )\n                            {\n                                const int nSrcPixelMinusXOff =\n                                    static_cast<int>(dfSrcX);\n                                for( int iBand = 0;\n                                     iBand < nBandCount;\n                                     ++iBand )\n                                {\n                                    pabyLocalData[x * nPixelSpace + iBand] =\n                                        pabyLocalSrcData[nSrcPixelMinusXOff *\n                                                         nBandsPerBlockDTSize +\n                                                         iBand];\n                                }\n                            }\n                        }\n                        else\n                        {\n                            REACHED(11);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for( int x = 0;\n                                 x < nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc )\n                            {\n                                int nSrcPixelMinusXOff =\n                                    static_cast<int>(dfSrcX);\n                                GDALCopyWords(\n                                    pabyLocalSrcData +\n                                    nSrcPixelMinusXOff * nBandsPerBlockDTSize,\n                                    eDataType, nDTSize,\n                                    pabyLocalData + x * nPixelSpace,\n                                    eBufType,\n                                    static_cast<int>(nBandSpace),\n                                    nBandCount );\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else  // Non-contig reading case.\n    {\n        if( !FetchBuffer::bMinimizeIO && TIFFIsTiled( hTIFF ) )\n        {\n            for( int iBand = 0; iBand < nBandCount; ++iBand )\n            {\n                const int nBand = panBandMap[iBand];\n                GByte* const pabyData =\n                    static_cast<GByte*>(pData) + iBand * nBandSpace;\n                for( int y = 0; y < nBufYSize; ++y )\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                    const int nBlockYOff = nSrcLine / nBlockYSize;\n                    const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n\n                    int nBaseByteOffsetInBlock =\n                        nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n                    if( nPlanarConfig == PLANARCONFIG_CONTIG )\n                    {\n                        REACHED(12);\n                        nBaseByteOffsetInBlock += (nBand - 1) * nDTSize;\n                    }\n                    else\n                    {\n                        REACHED(13);\n                    }\n\n                    if( bNoXResampling )\n                    {\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        int nBlockXOff = nXOff / nBlockXSize;\n                        int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n                        if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                        {\n                            REACHED(14);\n                            nBlockId += nBlocksPerBand * (nBand - 1);\n                        }\n                        else\n                        {\n                            REACHED(15);\n                        }\n                        int nXOffsetInBlock = nXOff % nBlockXSize;\n\n                        int x = 0;\n                        while( x < nBufXSize )\n                        {\n                            const int nByteOffsetInBlock =\n                                nBaseByteOffsetInBlock +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n                            const toff_t nCurOffset = panOffsets[nBlockId];\n                            const int nUsedBlockWidth =\n                                std::min(\n                                    nBlockXSize - nXOffsetInBlock,\n                                    nBufXSize - x );\n                            int nIters = nUsedBlockWidth;\n\n                            if( nCurOffset == 0 )\n                            {\n                                REACHED(16);\n                                GDALCopyWords(\n                                    &dfNoData, GDT_Float64, 0,\n                                    pabyLocalData, eBufType,\n                                    static_cast<int>(nPixelSpace),\n                                    nIters);\n                                pabyLocalData += nIters * nPixelSpace;\n                            }\n                            else\n                            {\n                                if( bNoTypeChange &&\n                                    nPixelSpace == nBandsPerBlockDTSize )\n                                {\n                                    REACHED(17);\n                                    if( !oFetcher.FetchBytes(\n                                           pabyLocalData,\n                                           nCurOffset + nByteOffsetInBlock,\n                                           (nIters - 1) * nBandsPerBlock + 1,\n                                           nDTSize,\n                                           bIsByteSwapped, bIsComplex,\n                                           nBlockId) )\n                                    {\n                                        return CE_Failure;\n                                    }\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    const GByte* pabyLocalSrcData =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset + nByteOffsetInBlock,\n                                            (nIters - 1) * nBandsPerBlock + 1,\n                                            nDTSize,\n                                            bIsByteSwapped,\n                                            bIsComplex,\n                                            nBlockId );\n                                    if( pabyLocalSrcData == nullptr )\n                                        return CE_Failure;\n\n                                    REACHED(18);\n                                    GDALCopyWords(\n                                        pabyLocalSrcData, eDataType,\n                                        nBandsPerBlockDTSize,\n                                        pabyLocalData, eBufType,\n                                        static_cast<int>(nPixelSpace),\n                                        nIters );\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                            }\n\n                            nXOffsetInBlock = 0;\n                            ++nBlockXOff;\n                            ++nBlockId;\n                            x += nUsedBlockWidth;\n                        }\n                    }\n                    else\n                    {\n                        // Non-contig reading, tiled, potential resampling and\n                        // data type change.\n\n                        const GByte* pabyLocalSrcDataStartLine = nullptr;\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                        int nCurBlockXOff = 0;\n                        int nNextBlockXOff = 0;\n                        toff_t nCurOffset = 0;\n                        for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc)\n                        {\n                            const int nSrcPixel = static_cast<int>(dfSrcX);\n                            if( nSrcPixel >= nNextBlockXOff )\n                            {\n                                const int nBlockXOff = nSrcPixel / nBlockXSize;\n                                nCurBlockXOff = nBlockXOff * nBlockXSize;\n                                nNextBlockXOff = nCurBlockXOff + nBlockXSize;\n                                int nBlockId =\n                                    nBlockXOff + nBlockYOff * nBlocksPerRow;\n                                if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                                {\n                                    REACHED(19);\n                                    nBlockId += nBlocksPerBand * (nBand - 1);\n                                }\n                                else\n                                {\n                                    REACHED(20);\n                                }\n                                nCurOffset = panOffsets[nBlockId];\n                                if( nCurOffset != 0 )\n                                {\n                                    pabyLocalSrcDataStartLine =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset + nBaseByteOffsetInBlock,\n                                            nBlockXSize * nBandsPerBlock,\n                                            nDTSize,\n                                            bIsByteSwapped,\n                                            bIsComplex,\n                                            nBlockId);\n                                    if( pabyLocalSrcDataStartLine == nullptr )\n                                        return CE_Failure;\n                                }\n                            }\n                            const int nXOffsetInBlock =\n                                nSrcPixel - nCurBlockXOff;\n\n                            if( nCurOffset == 0 )\n                            {\n                                REACHED(21);\n                                GDALCopyWords( &dfNoData, GDT_Float64, 0,\n                                               pabyLocalData,\n                                               eBufType, 0,\n                                               1 );\n                                pabyLocalData += nPixelSpace;\n                            }\n                            else\n                            {\n                                const GByte* pabyLocalSrcData =\n                                    pabyLocalSrcDataStartLine +\n                                    nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                                REACHED(22);\n                                if( bByteOnly )\n                                {\n                                    *pabyLocalData = *pabyLocalSrcData;\n                                }\n                                else\n                                {\n                                    GDALCopyWords(pabyLocalSrcData,\n                                                eDataType, 0,\n                                                pabyLocalData,\n                                                eBufType, 0,\n                                                1);\n                                }\n                                pabyLocalData += nPixelSpace;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else  // Non-contig reading, stripped.\n        {\n            for( int iBand = 0; iBand < nBandCount; ++iBand )\n            {\n                const int nBand = panBandMap[iBand];\n                GByte* pabyData =\n                    static_cast<GByte *>(pData) + iBand * nBandSpace;\n                for( int y = 0; y < nBufYSize; ++y )\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                    const int nBlockYOff = nSrcLine / nBlockYSize;\n                    const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                    int nBlockId = nBlockYOff;\n                    if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                    {\n                        REACHED(23);\n                        nBlockId += nBlocksPerBand * (nBand - 1);\n                    }\n                    else\n                    {\n                        REACHED(24);\n                    }\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(25);\n                        GDALCopyWords(\n                            &dfNoData, GDT_Float64, 0,\n                            pabyData + y * nLineSpace,\n                            eBufType,\n                            static_cast<int>(nPixelSpace),\n                            nBufXSize);\n                    }\n                    else\n                    {\n                        int nBaseByteOffsetInBlock =\n                            (nYOffsetInBlock * nBlockXSize + nXOff) *\n                            nBandsPerBlockDTSize;\n                        if( nPlanarConfig == PLANARCONFIG_CONTIG )\n                            nBaseByteOffsetInBlock += (nBand - 1) * nDTSize;\n\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        if( bNoXResamplingNoTypeChange &&\n                            nPixelSpace == nBandsPerBlockDTSize )\n                        {\n                            REACHED(26);\n                            if( !oFetcher.FetchBytes(\n                                pabyLocalData,\n                                nCurOffset + nBaseByteOffsetInBlock,\n                                (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId) )\n                            {\n                                return CE_Failure;\n                            }\n                        }\n                        else\n                        {\n                            const GByte* pabyLocalSrcData = oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetInBlock,\n                                (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId);\n                            if( pabyLocalSrcData == nullptr )\n                                return CE_Failure;\n\n                            if( bNoXResamplingNoTypeChange )\n                            {\n                                REACHED(27);\n                                GDALCopyWords(pabyLocalSrcData,\n                                              eDataType, nBandsPerBlockDTSize,\n                                              pabyLocalData, eBufType,\n                                              static_cast<int>(nPixelSpace),\n                                              nBufXSize);\n                            }\n                            else if( bByteOnly )\n                            {\n                                REACHED(28);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for( int x = 0;\n                                     x < nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc )\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast<int>(dfSrcX);\n                                    pabyLocalData[x * nPixelSpace] =\n                                        pabyLocalSrcData[nSrcPixelMinusXOff *\n                                                         nBandsPerBlockDTSize];\n                                }\n                            }\n                            else\n                            {\n                                REACHED(29);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for( int x = 0;\n                                     x < nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc )\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast<int>(dfSrcX);\n                                    GDALCopyWords(\n                                        pabyLocalSrcData +\n                                        nSrcPixelMinusXOff *\n                                        nBandsPerBlockDTSize,\n                                        eDataType, 0,\n                                        pabyLocalData + x * nPixelSpace,\n                                        eBufType, 0,\n                                        1 );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return CE_None;\n}",
    "int GTiffDataset::DirectIO( GDALRWFlag eRWFlag,\n                            int nXOff, int nYOff, int nXSize, int nYSize,\n                            void * pData, int nBufXSize, int nBufYSize,\n                            GDALDataType eBufType,\n                            int nBandCount, int *panBandMap,\n                            GSpacing nPixelSpace, GSpacing nLineSpace,\n                            GSpacing nBandSpace,\n                            GDALRasterIOExtraArg* psExtraArg )\n{\n    const GDALDataType eDataType = GetRasterBand(1)->GetRasterDataType();\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(eRWFlag == GF_Read &&\n          nCompression == COMPRESSION_NONE &&\n          (nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           nPhotometric == PHOTOMETRIC_RGB ||\n           nPhotometric == PHOTOMETRIC_PALETTE) &&\n          nBitsPerSample == nDTSizeBits &&\n          SetDirectory() /* Very important to make hTIFF uptodate! */ ) )\n    {\n        return -1;\n    }\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) &&\n        psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n    // If the file is band interleave or only one band is requested, then\n    // fallback to band DirectIO.\n    bool bUseBandRasterIO = false;\n    if( nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1 )\n    {\n        bUseBandRasterIO = true;\n    }\n    else\n    {\n        // For simplicity, only deals with \"naturally ordered\" bands.\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            if( panBandMap[iBand] != iBand + 1)\n            {\n                bUseBandRasterIO = true;\n                break;\n            }\n        }\n    }\n    if( bUseBandRasterIO )\n    {\n        CPLErr eErr = CE_None;\n        for( int iBand = 0; eErr == CE_None && iBand < nBandCount; ++iBand )\n        {\n            eErr = GetRasterBand(panBandMap[iBand])->RasterIO(\n                eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                static_cast<GByte *>(pData) + iBand * nBandSpace,\n                nBufXSize, nBufYSize,\n                eBufType,\n                nPixelSpace, nLineSpace,\n                psExtraArg );\n        }\n        return eErr;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"DirectIO(%d,%d,%d,%d -> %dx%d)\",\n              nXOff, nYOff, nXSize, nYSize,\n              nBufXSize, nBufYSize );\n#endif\n\n    // No need to look if overviews can satisfy the request as it has already */\n    // been done in GTiffDataset::IRasterIO().\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( GetAccess() == GA_Update )\n    {\n        FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( hTIFF ) );\n    }\n\n    if( TIFFIsTiled( hTIFF ) )\n    {\n        if( m_pTempBufferForCommonDirectIO == nullptr )\n        {\n            const int nDTSize = nDTSizeBits / 8;\n            m_nTempBufferForCommonDirectIOSize =\n                static_cast<size_t>(nBlockXSize * nBlockYSize * nDTSize *\n                ((nPlanarConfig == PLANARCONFIG_CONTIG) ? nBands : 1));\n\n            m_pTempBufferForCommonDirectIO =\n                static_cast<GByte *>(\n                    VSI_MALLOC_VERBOSE(m_nTempBufferForCommonDirectIOSize) );\n            if( m_pTempBufferForCommonDirectIO == nullptr )\n                return CE_Failure;\n        }\n\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n        FetchBufferDirectIO oFetcher(fp, m_pTempBufferForCommonDirectIO,\n                                     m_nTempBufferForCommonDirectIOSize);\n\n        return CommonDirectIO( oFetcher,\n                               nXOff, nYOff, nXSize, nYSize,\n                               pData, nBufXSize, nBufYSize,\n                               eBufType,\n                               nBandCount, panBandMap,\n                               nPixelSpace, nLineSpace,\n                              nBandSpace );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    void** ppData =\n        static_cast<void **>( VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void*)) );\n    vsi_l_offset* panOffsets =\n        static_cast<vsi_l_offset *>(\n            VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)) );\n    size_t* panSizes =\n        static_cast<size_t *>( VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)) );\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void* pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands = nBands;\n    const int nSrcPixelSize = nDTSize * nContigBands;\n\n    if( ppData == nullptr || panOffsets == nullptr || panSizes == nullptr )\n    {\n        eErr = CE_Failure;\n    }\n    // For now we always allocate a temp buffer as it is easier.\n    else\n        // if( nXSize != nBufXSize || nYSize != nBufYSize ||\n        //   eBufType != eDataType ||\n        //   nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n        //   check if the user buffer is large enough )\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC_VERBOSE(nReqXSize * nReqYSize * nSrcPixelSize);\n        if( pTmpBuffer == nullptr )\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    for( int iLine = 0; eErr == CE_None && iLine < nReqYSize; ++iLine )\n    {\n        ppData[iLine] =\n            static_cast<GByte *>(pTmpBuffer) +\n            iLine * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if( nBufYSize < nYSize )  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast<int>((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n        const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if( panOffsets[iLine] == 0)  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff + nYOffsetInBlock * nBlockXSize) * nSrcPixelSize;\n        panSizes[iLine] = nReqXSize * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if( eErr == CE_None )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n        const int nRet =\n            VSIFReadMultiRangeL(nReqYSize, ppData, panOffsets, panSizes, fp);\n        if( nRet != 0 )\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if( eErr == CE_None && TIFFIsByteSwapped(hTIFF) )\n    {\n        for( int iLine = 0; iLine < nReqYSize; ++iLine )\n        {\n            if( GDALDataTypeIsComplex(eDataType) )\n                GDALSwapWords( ppData[iLine], nDTSize / 2,\n                               2 * nReqXSize * nContigBands, nDTSize / 2);\n            else\n                GDALSwapWords( ppData[iLine], nDTSize,\n                               nReqXSize * nContigBands, nDTSize);\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    if( eErr == CE_None && pTmpBuffer != nullptr )\n    {\n        for( int iY = 0; iY < nBufYSize; ++iY )\n        {\n            const int iSrcY =\n                nBufYSize <= nYSize ?\n                iY : static_cast<int>((iY + 0.5) * dfSrcYInc);\n            // Optimization: no resampling, no data type change, number of\n            // bands requested == number of bands and buffer is packed\n            // pixel-interleaved.\n            if( nBufXSize == nXSize && nContigBands == nBandCount &&\n                eDataType == eBufType &&\n                nBandSpace == nDTSize &&\n                nPixelSpace == nBandCount * nBandSpace )\n            {\n                memcpy(\n                    static_cast<GByte *>(pData) + iY * nLineSpace,\n                    ppData[iSrcY],\n                    static_cast<size_t>(nReqXSize * nPixelSpace) );\n            }\n            // Other optimization: no resampling, no data type change,\n            // data type is Byte.\n            else if( nBufXSize == nXSize &&\n                     eDataType == eBufType && eDataType == GDT_Byte )\n            {\n                GByte* pabySrcData = static_cast<GByte *>(ppData[iSrcY]);\n                GByte* pabyDstData =\n                    static_cast<GByte *>(pData) + iY * nLineSpace;\n                if( nBandSpace == 1 && nPixelSpace > nBandCount )\n                {\n                    // Buffer is pixel-interleaved (with some stridding\n                    // between pixels).\n                    CopyContigByteMultiBand( pabySrcData, nSrcPixelSize,\n                                             pabyDstData,\n                                             static_cast<int>(nPixelSpace),\n                                             nBufXSize, nBandCount );\n                }\n                else\n                {\n                    for( int iBand = 0; iBand < nBandCount; ++iBand )\n                    {\n                        GDALCopyWords(\n                            pabySrcData + iBand, GDT_Byte, nSrcPixelSize,\n                            pabyDstData + iBand * nBandSpace,\n                            GDT_Byte, static_cast<int>(nPixelSpace),\n                            nBufXSize );\n                    }\n                }\n            }\n            else  // General case.\n            {\n                for( int iBand = 0; iBand < nBandCount; ++iBand )\n                {\n                    GByte* pabySrcData =\n                        static_cast<GByte *>(ppData[iSrcY]) + iBand * nDTSize;\n                    GByte* pabyDstData =\n                        static_cast<GByte *>(pData) +\n                        iBand * nBandSpace + iY * nLineSpace;\n                    if( eDataType == GDT_Byte && eBufType == GDT_Byte )\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for( int iX = 0;\n                             iX < nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast<int>(dfSrcX);\n                            pabyDstData[iX * nPixelSpace] =\n                                pabySrcData[iSrcX * nSrcPixelSize];\n                        }\n                    }\n                    else\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for( int iX = 0;\n                             iX < nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast<int>(dfSrcX);\n                            GDALCopyWords( pabySrcData + iSrcX * nSrcPixelSize,\n                                        eDataType, 0,\n                                        pabyDstData + iX * nPixelSpace,\n                                        eBufType, 0, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}",
    "const char *GTiffRasterBand::GetMetadataItem( const char * pszName,\n                                              const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        poGDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszName != nullptr && pszDomain != nullptr && EQUAL(pszDomain, \"TIFF\") )\n    {\n        int nBlockXOff = 0;\n        int nBlockYOff = 0;\n\n        if( EQUAL(pszName, \"JPEGTABLES\") )\n        {\n            if( !poGDS->SetDirectory() )\n                return nullptr;\n\n            uint32 nJPEGTableSize = 0;\n            void* pJPEGTable = nullptr;\n            if( TIFFGetField( poGDS->hTIFF, TIFFTAG_JPEGTABLES,\n                              &nJPEGTableSize, &pJPEGTable ) != 1 ||\n                pJPEGTable == nullptr || nJPEGTableSize > INT_MAX )\n            {\n                return nullptr;\n            }\n            char* const pszHex =\n                CPLBinaryToHex( nJPEGTableSize, static_cast<const GByte*>(pJPEGTable) );\n            const char* pszReturn = CPLSPrintf(\"%s\", pszHex);\n            CPLFree(pszHex);\n\n            return pszReturn;\n        }\n\n        if( EQUAL(pszName, \"IFD_OFFSET\") )\n        {\n            if( !poGDS->SetDirectory() )\n                return nullptr;\n\n            return CPLSPrintf( CPL_FRMT_GUIB,\n                               static_cast<GUIntBig>(poGDS->nDirOffset) );\n        }\n\n        if( sscanf( pszName, \"BLOCK_OFFSET_%d_%d\",\n                         &nBlockXOff, &nBlockYOff ) == 2 )\n        {\n            if( !poGDS->SetDirectory() )\n                return nullptr;\n\n            nBlocksPerRow =\n                DIV_ROUND_UP(poGDS->nRasterXSize, poGDS->nBlockXSize);\n            nBlocksPerColumn =\n                DIV_ROUND_UP(poGDS->nRasterYSize, poGDS->nBlockYSize);\n            if( nBlockXOff < 0 || nBlockXOff >= nBlocksPerRow ||\n                nBlockYOff < 0 || nBlockYOff >= nBlocksPerColumn )\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n            {\n                nBlockId += (nBand - 1) * poGDS->nBlocksPerBand;\n            }\n\n            vsi_l_offset nOffset = 0;\n            if( !poGDS->IsBlockAvailable(nBlockId, &nOffset) )\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf( CPL_FRMT_GUIB, static_cast<GUIntBig>(nOffset) );\n        }\n\n        if( sscanf( pszName, \"BLOCK_SIZE_%d_%d\",\n                    &nBlockXOff, &nBlockYOff ) == 2 )\n        {\n            if( !poGDS->SetDirectory() )\n                return nullptr;\n\n            nBlocksPerRow =\n                DIV_ROUND_UP(poGDS->nRasterXSize, poGDS->nBlockXSize);\n            nBlocksPerColumn =\n                DIV_ROUND_UP(poGDS->nRasterYSize, poGDS->nBlockYSize);\n            if( nBlockXOff < 0 || nBlockXOff >= nBlocksPerRow ||\n                nBlockYOff < 0 || nBlockYOff >= nBlocksPerColumn )\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n            {\n                nBlockId += (nBand - 1) * poGDS->nBlocksPerBand;\n            }\n\n            vsi_l_offset nByteCount = 0;\n            if( !poGDS->IsBlockAvailable(nBlockId, nullptr, &nByteCount) )\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf(CPL_FRMT_GUIB, static_cast<GUIntBig>(nByteCount));\n        }\n    }\n    return oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}",
    "CPLErr GTiffRasterBand::SetColorInterpretation( GDALColorInterp eInterp )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( eInterp == eBandInterp )\n        return CE_None;\n\n    eBandInterp = eInterp;\n\n    if( eAccess != GA_Update )\n    {\n        CPLDebug( \"GTIFF\", \"ColorInterpretation %s for band %d goes to PAM \"\n                  \"instead of TIFF tag\",\n                  GDALGetColorInterpretationName(eInterp), nBand );\n        return GDALPamRasterBand::SetColorInterpretation( eInterp );\n    }\n\n    if( poGDS->bCrystalized )\n    {\n        if( !poGDS->SetDirectory() )\n            return CE_Failure;\n    }\n\n    poGDS->bNeedsRewrite = true;\n    poGDS->bMetadataChanged = true;\n\n    // Try to autoset TIFFTAG_PHOTOMETRIC = PHOTOMETRIC_RGB if possible.\n    if( poGDS->nBands >= 3 &&\n        poGDS->nCompression != COMPRESSION_JPEG &&\n        poGDS->nPhotometric != PHOTOMETRIC_RGB &&\n        CSLFetchNameValue( poGDS->papszCreationOptions,\n                           \"PHOTOMETRIC\" ) == nullptr &&\n        ((nBand == 1 && eInterp == GCI_RedBand) ||\n         (nBand == 2 && eInterp == GCI_GreenBand) ||\n         (nBand == 3 && eInterp == GCI_BlueBand)) )\n    {\n        if( poGDS->GetRasterBand(1)->GetColorInterpretation() == GCI_RedBand &&\n            poGDS->GetRasterBand(2)->GetColorInterpretation() == GCI_GreenBand &&\n            poGDS->GetRasterBand(3)->GetColorInterpretation() == GCI_BlueBand )\n        {\n            poGDS->nPhotometric = PHOTOMETRIC_RGB;\n            TIFFSetField( poGDS->hTIFF, TIFFTAG_PHOTOMETRIC,\n                          poGDS->nPhotometric );\n\n            // We need to update the number of extra samples.\n            uint16 *v = nullptr;\n            uint16 count = 0;\n            const uint16 nNewExtraSamplesCount =\n                static_cast<uint16>(poGDS->nBands - 3);\n            if( poGDS->nBands >= 4 &&\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES,\n                              &count, &v ) &&\n                count > nNewExtraSamplesCount )\n            {\n                uint16 * const pasNewExtraSamples =\n                    static_cast<uint16 *>( CPLMalloc(\n                        nNewExtraSamplesCount * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v + count - nNewExtraSamplesCount,\n                        nNewExtraSamplesCount * sizeof(uint16) );\n\n                TIFFSetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES,\n                              nNewExtraSamplesCount, pasNewExtraSamples );\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n        return CE_None;\n    }\n\n    // On the contrary, cancel the above if needed\n    if( poGDS->nCompression != COMPRESSION_JPEG &&\n        poGDS->nPhotometric == PHOTOMETRIC_RGB &&\n        CSLFetchNameValue( poGDS->papszCreationOptions,\n                           \"PHOTOMETRIC\") == nullptr &&\n        ((nBand == 1 && eInterp != GCI_RedBand) ||\n         (nBand == 2 && eInterp != GCI_GreenBand) ||\n         (nBand == 3 && eInterp != GCI_BlueBand)) )\n    {\n        poGDS->nPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(poGDS->hTIFF, TIFFTAG_PHOTOMETRIC, poGDS->nPhotometric);\n\n        // We need to update the number of extra samples.\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        const uint16 nNewExtraSamplesCount =\n            static_cast<uint16>(poGDS->nBands - 1);\n        if( poGDS->nBands >= 2 )\n        {\n            TIFFGetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v );\n            if( nNewExtraSamplesCount > count )\n            {\n                uint16 * const pasNewExtraSamples =\n                    static_cast<uint16 *>( CPLMalloc(\n                        nNewExtraSamplesCount * sizeof(uint16) ) );\n                for( int i = 0;\n                     i < static_cast<int>(nNewExtraSamplesCount - count);\n                     ++i )\n                    pasNewExtraSamples[i] = EXTRASAMPLE_UNSPECIFIED;\n                if( count > 0 )\n                {\n                    memcpy( pasNewExtraSamples + nNewExtraSamplesCount - count,\n                            v,\n                            count * sizeof(uint16) );\n                }\n\n                TIFFSetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES,\n                              nNewExtraSamplesCount, pasNewExtraSamples );\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n    }\n\n    // Mark alpha band / undefined in extrasamples.\n    if( eInterp == GCI_AlphaBand || eInterp == GCI_Undefined )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        if( TIFFGetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            const int nBaseSamples = poGDS->nSamplesPerPixel - count;\n\n            if( eInterp == GCI_AlphaBand )\n            {\n                for( int i = 1; i <= poGDS->nBands; ++i )\n                {\n                    if( i != nBand &&\n                        poGDS->GetRasterBand(i)->GetColorInterpretation() ==\n                        GCI_AlphaBand )\n                    {\n                        if( i == nBaseSamples + 1 &&\n                            CSLFetchNameValue( poGDS->papszCreationOptions,\n                                            \"ALPHA\" ) != nullptr )\n                        {\n                            CPLError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too. \"\n                                \"Presumably ALPHA creation option is not needed\",\n                                i, nBand );\n                        }\n                        else\n                        {\n                            CPLError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too\",\n                                i, nBand );\n                        }\n                    }\n                }\n            }\n\n            if( nBand > nBaseSamples && nBand - nBaseSamples - 1 < count )\n            {\n                // We need to allocate a new array as (current) libtiff\n                // versions will not like that we reuse the array we got from\n                // TIFFGetField().\n\n                uint16* pasNewExtraSamples =\n                    static_cast<uint16 *>(\n                        CPLMalloc( count * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v, count * sizeof(uint16) );\n                if( eInterp == GCI_AlphaBand )\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        GTiffGetAlphaValue(CPLGetConfigOption(\"GTIFF_ALPHA\", nullptr),\n                                            DEFAULT_ALPHA_TYPE);\n                }\n                else\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        EXTRASAMPLE_UNSPECIFIED;\n                }\n\n                TIFFSetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES,\n                              count, pasNewExtraSamples);\n\n                CPLFree(pasNewExtraSamples);\n\n                return CE_None;\n            }\n        }\n    }\n\n    if( poGDS->nPhotometric != PHOTOMETRIC_MINISBLACK &&\n        CSLFetchNameValue( poGDS->papszCreationOptions, \"PHOTOMETRIC\") == nullptr )\n    {\n        poGDS->nPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(poGDS->hTIFF, TIFFTAG_PHOTOMETRIC, poGDS->nPhotometric);\n    }\n\n    return CE_None;\n}",
    "CPLErr GTiffRGBABand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                  void * pImage )\n\n{\n    if( !poGDS->SetDirectory() )\n        return CE_Failure;\n\n    CPLAssert( nBlocksPerRow != 0 );\n    const int nBlockBufSize = 4 * nBlockXSize * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n#ifdef INTERNAL_LIBTIFF\n    if( poGDS->nCompression == COMPRESSION_OJPEG )\n    {\n        // Need to fetch all offsets for Old-JPEG compression\n        if( poGDS->pabyBlockBuf == nullptr )\n        {\n            toff_t *panByteCounts = nullptr;\n            toff_t *panOffsets = nullptr;\n            const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(poGDS->hTIFF) );\n\n            if( bIsTiled )\n            {\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts );\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_TILEOFFSETS, &panOffsets );\n            }\n            else\n            {\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts );\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPOFFSETS, &panOffsets );\n            }\n        }\n    }\n#endif\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        for( int iBand = 0; iBand < poGDS->nSamplesPerPixel; iBand ++ )\n        {\n            int nBlockIdBand = nBlockId + iBand * poGDS->nBlocksPerBand;\n            if( !poGDS->IsBlockAvailable(nBlockIdBand) )\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if( !poGDS->IsBlockAvailable(nBlockId) )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( poGDS->pabyBlockBuf == nullptr )\n    {\n        poGDS->pabyBlockBuf =\n            static_cast<GByte *>(\n                VSI_MALLOC3_VERBOSE( 4, nBlockXSize, nBlockYSize ) );\n        if( poGDS->pabyBlockBuf == nullptr )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read the strip                                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if( poGDS->nLoadedBlock != nBlockId )\n    {\n        if( TIFFIsTiled( poGDS->hTIFF ) )\n        {\n#if defined(INTERNAL_LIBTIFF) || TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBATileExt(\n                   poGDS->hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf),\n                   !poGDS->bIgnoreReadErrors) == 0\n                && !poGDS->bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBATile(\n                   poGDS->hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf)) == 0\n                && !poGDS->bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBATile() failed.\" );\n\n                memset( poGDS->pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n#if defined(INTERNAL_LIBTIFF) || TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBAStripExt(\n                   poGDS->hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf),\n                   !poGDS->bIgnoreReadErrors) == 0\n                && !poGDS->bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBAStrip(\n                   poGDS->hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf)) == 0\n                && !poGDS->bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBAStrip() failed.\" );\n\n                memset( poGDS->pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    poGDS->nLoadedBlock = nBlockId;\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case of eight bit data, and pixel interleaving.   */\n/* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if( nBlockYOff * nBlockYSize > GetYSize() - nBlockYSize\n        && !TIFFIsTiled( poGDS->hTIFF ) )\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for( int iDestLine = 0; iDestLine < nThisBlockYSize; ++iDestLine )\n    {\n        const int nSrcOffset =\n            (nThisBlockYSize - iDestLine - 1) * nBlockXSize * 4;\n\n        GDALCopyWords(\n            poGDS->pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n            static_cast<GByte *>(pImage)+iDestLine*nBlockXSize, GDT_Byte, 1,\n            nBlockXSize );\n    }\n\n    if( eErr == CE_None )\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}",
    "int GTiffDataset::GetJPEGOverviewCount()\n{\n    if( nJPEGOverviewCount >= 0 )\n        return nJPEGOverviewCount;\n\n    nJPEGOverviewCount = 0;\n    if( !bBase || eAccess != GA_ReadOnly || nCompression != COMPRESSION_JPEG ||\n        (nRasterXSize < 256 && nRasterYSize < 256) ||\n        !CPLTestBool(CPLGetConfigOption(\"GTIFF_IMPLICIT_JPEG_OVR\", \"YES\")) ||\n        GDALGetDriverByName(\"JPEG\") == nullptr )\n    {\n        return 0;\n    }\n    const char* pszSourceColorSpace =\n        oGTiffMDMD.GetMetadataItem( \"SOURCE_COLOR_SPACE\", \"IMAGE_STRUCTURE\" );\n    if( pszSourceColorSpace != nullptr && EQUAL(pszSourceColorSpace, \"CMYK\") )\n    {\n        // We cannot handle implicit overviews on JPEG CMYK datasets converted\n        // to RGBA This would imply doing the conversion in\n        // GTiffJPEGOverviewBand.\n        return 0;\n    }\n\n    // libjpeg-6b only supports 2, 4 and 8 scale denominators.\n    // TODO: Later versions support more.\n    for( int i = 2; i >= 0; i-- )\n    {\n        if( nRasterXSize >= (256 << i) || nRasterYSize >= (256 << i) )\n        {\n            nJPEGOverviewCount = i + 1;\n            break;\n        }\n    }\n    if( nJPEGOverviewCount == 0 )\n        return 0;\n\n    if( !SetDirectory() )\n    {\n        nJPEGOverviewCount = 0;\n        return 0;\n    }\n\n    // Get JPEG tables.\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    GByte abyFFD8[] = { 0xFF, 0xD8 };\n    if( TIFFGetField(hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize, &pJPEGTable) )\n    {\n        if( pJPEGTable == nullptr ||\n            nJPEGTableSize > INT_MAX ||\n            static_cast<GByte*>(pJPEGTable)[nJPEGTableSize-1] != 0xD9 )\n        {\n            nJPEGOverviewCount = 0;\n            return 0;\n        }\n        nJPEGTableSize--;  // Remove final 0xD9.\n    }\n    else\n    {\n        pJPEGTable = abyFFD8;\n        nJPEGTableSize = 2;\n    }\n\n    papoJPEGOverviewDS =\n        static_cast<GTiffJPEGOverviewDS **>(\n            CPLMalloc( sizeof(GTiffJPEGOverviewDS*) * nJPEGOverviewCount ) );\n    for( int i = 0; i < nJPEGOverviewCount; ++i )\n    {\n        papoJPEGOverviewDS[i] =\n            new GTiffJPEGOverviewDS(\n                this, i + 1,\n                pJPEGTable, static_cast<int>(nJPEGTableSize) );\n    }\n\n    nJPEGOverviewCountOri = nJPEGOverviewCount;\n\n    return nJPEGOverviewCount;\n}",
    "void GTiffDataset::FillEmptyTiles()\n\n{\n    if( !SetDirectory() )\n        return;\n\n/* -------------------------------------------------------------------- */\n/*      How many blocks are there in this file?                         */\n/* -------------------------------------------------------------------- */\n    const int nBlockCount =\n        nPlanarConfig == PLANARCONFIG_SEPARATE ?\n        nBlocksPerBand * nBands :\n        nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Fetch block maps.                                               */\n/* -------------------------------------------------------------------- */\n    toff_t *panByteCounts = nullptr;\n\n    if( TIFFIsTiled( hTIFF ) )\n        TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts );\n    else\n        TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts );\n\n    if( panByteCounts == nullptr )\n    {\n        // Got here with libtiff 3.9.3 and tiff_write_8 test.\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"FillEmptyTiles() failed because panByteCounts == NULL\" );\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Prepare a blank data buffer to write for uninitialized blocks.  */\n/* -------------------------------------------------------------------- */\n    const int nBlockBytes =\n        TIFFIsTiled( hTIFF ) ?\n        static_cast<int>(TIFFTileSize(hTIFF)) :\n        static_cast<int>(TIFFStripSize(hTIFF));\n\n    GByte *pabyData =\n        static_cast<GByte *>( VSI_CALLOC_VERBOSE(nBlockBytes, 1) );\n    if( pabyData == nullptr )\n    {\n        return;\n    }\n\n    // Force tiles completely filled with the nodata value to be written.\n    bWriteEmptyTiles = true;\n\n/* -------------------------------------------------------------------- */\n/*      If set, fill data buffer with no data value.                    */\n/* -------------------------------------------------------------------- */\n    if( bNoDataSet && dfNoDataValue != 0.0 )\n    {\n        const GDALDataType eDataType = GetRasterBand( 1 )->GetRasterDataType();\n        const int nDataTypeSize = GDALGetDataTypeSizeBytes( eDataType );\n        if( nDataTypeSize &&\n            nDataTypeSize * 8 == static_cast<int>(nBitsPerSample) )\n        {\n            GDALCopyWords( &dfNoDataValue, GDT_Float64, 0,\n                           pabyData, eDataType,\n                           nDataTypeSize,\n                           nBlockBytes / nDataTypeSize );\n        }\n        else if( nDataTypeSize )\n        {\n            // Handle non power-of-two depths.\n            // Ideally make a packed buffer, but that is a bit tedious,\n            // so use the normal I/O interfaces.\n\n            CPLFree( pabyData );\n\n            pabyData = static_cast<GByte *>(\n                VSI_MALLOC3_VERBOSE(nBlockXSize, nBlockYSize, nDataTypeSize) );\n            if( pabyData == nullptr )\n                return;\n            GDALCopyWords( &dfNoDataValue, GDT_Float64, 0,\n                           pabyData, eDataType,\n                           nDataTypeSize,\n                           nBlockXSize * nBlockYSize );\n            const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n            for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n            {\n                if( panByteCounts[iBlock] == 0 )\n                {\n                    if( nPlanarConfig == PLANARCONFIG_SEPARATE || nBands == 1 )\n                    {\n                        CPL_IGNORE_RET_VAL( GetRasterBand(\n                            1 + iBlock / nBlocksPerBand )->WriteBlock(\n                                (iBlock % nBlocksPerBand) % nBlocksPerRow,\n                                (iBlock % nBlocksPerBand) / nBlocksPerRow,\n                                pabyData ) );\n                    }\n                    else\n                    {\n                        // In contig case, don't directly call WriteBlock(), as\n                        // it could cause useless decompression-recompression.\n                        const int nXOff =\n                            (iBlock % nBlocksPerRow) * nBlockXSize;\n                        const int nYOff =\n                            (iBlock / nBlocksPerRow) * nBlockYSize;\n                        const int nXSize =\n                            (nXOff + nBlockXSize <= nRasterXSize) ?\n                            nBlockXSize : nRasterXSize - nXOff;\n                        const int nYSize =\n                            (nYOff + nBlockYSize <= nRasterYSize) ?\n                            nBlockYSize : nRasterYSize - nYOff;\n                        for( int iBand = 1; iBand <= nBands; ++iBand )\n                        {\n                            CPL_IGNORE_RET_VAL( GetRasterBand( iBand )->\n                                RasterIO(\n                                    GF_Write, nXOff, nYOff, nXSize, nYSize,\n                                    pabyData, nXSize, nYSize,\n                                    eDataType, 0, 0, nullptr ) );\n                        }\n                    }\n                }\n            }\n            CPLFree( pabyData );\n            return;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      When we must fill with zeroes, try to create non-sparse file    */\n/*      w.r.t TIFF spec ... as a sparse file w.r.t filesystem, ie by    */\n/*      seeking to end of file instead of writing zero blocks.          */\n/* -------------------------------------------------------------------- */\n    else if( nCompression == COMPRESSION_NONE && (nBitsPerSample % 8) == 0 )\n    {\n        // Only use libtiff to write the first sparse block to ensure that it\n        // will serialize offset and count arrays back to disk.\n        int nCountBlocksToZero = 0;\n        for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n        {\n            if( panByteCounts[iBlock] == 0 )\n            {\n                if( nCountBlocksToZero == 0 )\n                {\n                    const bool bWriteEmptyTilesBak = bWriteEmptyTiles;\n                    bWriteEmptyTiles = true;\n                    const bool bOK =\n                        WriteEncodedTileOrStrip( iBlock, pabyData,\n                                                 FALSE ) == CE_None;\n                    bWriteEmptyTiles = bWriteEmptyTilesBak;\n                    if( !bOK )\n                        break;\n                }\n                nCountBlocksToZero++;\n            }\n        }\n        CPLFree( pabyData );\n\n        --nCountBlocksToZero;\n\n        // And then seek to end of file for other ones.\n        if( nCountBlocksToZero > 0 )\n        {\n            toff_t *panByteOffsets = nullptr;\n\n            if( TIFFIsTiled( hTIFF ) )\n                TIFFGetField( hTIFF, TIFFTAG_TILEOFFSETS, &panByteOffsets );\n            else\n                TIFFGetField( hTIFF, TIFFTAG_STRIPOFFSETS, &panByteOffsets );\n\n            if( panByteOffsets == nullptr )\n            {\n                CPLError(\n                    CE_Failure, CPLE_AppDefined,\n                    \"FillEmptyTiles() failed because panByteOffsets == NULL\");\n                return;\n            }\n\n            VSILFILE* fpTIF = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n            VSIFSeekL( fpTIF, 0, SEEK_END );\n            const vsi_l_offset nOffset = VSIFTellL(fpTIF);\n\n            vsi_l_offset iBlockToZero = 0;\n            for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n            {\n                if( panByteCounts[iBlock] == 0 )\n                {\n                    panByteOffsets[iBlock] = static_cast<toff_t>(\n                                        nOffset + iBlockToZero * nBlockBytes);\n                    panByteCounts[iBlock] = nBlockBytes;\n                    iBlockToZero++;\n                }\n            }\n            CPLAssert( iBlockToZero ==\n                       static_cast<vsi_l_offset>(nCountBlocksToZero) );\n\n            if( VSIFTruncateL( fpTIF,\n                               nOffset + iBlockToZero * nBlockBytes ) != 0 )\n            {\n                CPLError(CE_Failure, CPLE_FileIO,\n                         \"Cannot initialize empty blocks\");\n            }\n        }\n\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check all blocks, writing out data for uninitialized blocks.    */\n/* -------------------------------------------------------------------- */\n\n    GByte* pabyRaw = nullptr;\n    vsi_l_offset nRawSize = 0;\n    for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n    {\n        if( panByteCounts[iBlock] == 0 )\n        {\n            if( pabyRaw == nullptr )\n            {\n                if( WriteEncodedTileOrStrip( iBlock, pabyData, FALSE\n                                                                ) != CE_None )\n                    break;\n\n                vsi_l_offset nOffset = 0;\n                bool b = IsBlockAvailable( iBlock, &nOffset, &nRawSize);\n#ifdef DEBUG\n                CPLAssert(b);\n#else\n                CPL_IGNORE_RET_VAL(b);\n#endif\n                // When using compression, get back the compressed block\n                // so we can use the raw API to write it faster.\n                if( nCompression != COMPRESSION_NONE )\n                {\n                    pabyRaw = static_cast<GByte*>(\n                            VSI_MALLOC_VERBOSE(static_cast<int>(nRawSize)));\n                    if( pabyRaw )\n                    {\n                        VSILFILE* fp = VSI_TIFFGetVSILFile(\n                                                    TIFFClientdata( hTIFF ));\n                        const vsi_l_offset nCurOffset = VSIFTellL(fp);\n                        VSIFSeekL(fp, nOffset, SEEK_SET);\n                        VSIFReadL(pabyRaw, 1, static_cast<int>(nRawSize), fp);\n                        VSIFSeekL(fp, nCurOffset, SEEK_SET);\n                    }\n                }\n            }\n            else\n            {\n                WriteRawStripOrTile( iBlock, pabyRaw,\n                                     static_cast<int>(nRawSize) );\n            }\n        }\n    }\n\n    CPLFree( pabyData );\n    VSIFree( pabyRaw );\n}",
    "void GTiffDataset::ThreadCompressionFunc( void* pData )\n{\n    GTiffCompressionJob* psJob = static_cast<GTiffCompressionJob *>(pData);\n    GTiffDataset* poDS = psJob->poDS;\n\n    VSILFILE* fpTmp = VSIFOpenL(psJob->pszTmpFilename, \"wb+\");\n    TIFF* hTIFFTmp = VSI_TIFFOpen(psJob->pszTmpFilename,\n        psJob->bTIFFIsBigEndian ? \"wb+\" : \"wl+\", fpTmp);\n    CPLAssert( hTIFFTmp != nullptr );\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGEWIDTH, poDS->nBlockXSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGELENGTH, psJob->nHeight);\n    TIFFSetField(hTIFFTmp, TIFFTAG_BITSPERSAMPLE, poDS->nBitsPerSample);\n    TIFFSetField(hTIFFTmp, TIFFTAG_COMPRESSION, poDS->nCompression);\n    if( psJob->nPredictor != PREDICTOR_NONE )\n        TIFFSetField(hTIFFTmp, TIFFTAG_PREDICTOR, psJob->nPredictor);\n\n    TIFFSetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, poDS->nPhotometric);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLEFORMAT, poDS->nSampleFormat);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLESPERPIXEL, poDS->nSamplesPerPixel);\n    TIFFSetField(hTIFFTmp, TIFFTAG_ROWSPERSTRIP, poDS->nBlockYSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PLANARCONFIG, poDS->nPlanarConfig);\n\n    poDS->RestoreVolatileParameters(hTIFFTmp);\n\n    bool bOK =\n        TIFFWriteEncodedStrip(hTIFFTmp, 0, psJob->pabyBuffer,\n                              psJob->nBufferSize) == psJob->nBufferSize;\n\n    int nOffset = 0;\n    if( bOK )\n    {\n        toff_t* panOffsets = nullptr;\n        toff_t* panByteCounts = nullptr;\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPOFFSETS, &panOffsets);\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts);\n\n        nOffset = static_cast<int>( panOffsets[0]);\n        psJob->nCompressedBufferSize = static_cast<int>( panByteCounts[0] );\n    }\n    else\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Error when compressing strip/tile %d\",\n                  psJob->nStripOrTile);\n    }\n\n    XTIFFClose(hTIFFTmp);\n    if( VSIFCloseL(fpTmp) != 0 )\n    {\n        if( bOK )\n        {\n            bOK = false;\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"Error when compressing strip/tile %d\",\n                      psJob->nStripOrTile);\n        }\n    }\n\n    if( bOK )\n    {\n        vsi_l_offset nFileSize = 0;\n        GByte* pabyCompressedBuffer = VSIGetMemFileBuffer(psJob->pszTmpFilename,\n                                                          &nFileSize,\n                                                          FALSE);\n        CPLAssert( nOffset + psJob->nCompressedBufferSize <=\n                   static_cast<int>(nFileSize) );\n        psJob->pabyCompressedBuffer = pabyCompressedBuffer + nOffset;\n    }\n    else\n    {\n        psJob->pabyCompressedBuffer = nullptr;\n        psJob->nCompressedBufferSize = 0;\n    }\n\n    CPLAcquireMutex(poDS->hCompressThreadPoolMutex, 1000.0);\n    psJob->bReady = true;\n    CPLReleaseMutex(poDS->hCompressThreadPoolMutex);\n}",
    "void GTiffDataset::WriteRawStripOrTile( int nStripOrTile,\n                                        GByte* pabyCompressedBuffer,\n                                        int nCompressedBufferSize )\n{\n#ifdef DEBUG_VERBOSE\n    CPLDebug(\"GTIFF\", \"Writing raw strip/tile %d, size %d\",\n             nStripOrTile, nCompressedBufferSize);\n#endif\n    toff_t *panOffsets = nullptr;\n    if( TIFFGetField(\n            hTIFF,\n            TIFFIsTiled( hTIFF ) ?\n            TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS, &panOffsets ) &&\n            panOffsets[nStripOrTile] != 0 )\n    {\n        // Make sure that if the tile/strip already exists,\n        // we write at end of file.\n        TIFFSetWriteOffset(hTIFF, 0);\n    }\n    if( TIFFIsTiled( hTIFF ) )\n        TIFFWriteRawTile( hTIFF, nStripOrTile, pabyCompressedBuffer,\n                          nCompressedBufferSize );\n    else\n        TIFFWriteRawStrip( hTIFF, nStripOrTile, pabyCompressedBuffer,\n                           nCompressedBufferSize );\n}",
    "bool GTiffDataset::SubmitCompressionJob( int nStripOrTile, GByte* pabyData,\n                                         int cc, int nHeight )\n{\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    if( !( poCompressThreadPool != nullptr &&\n           (nCompression == COMPRESSION_ADOBE_DEFLATE ||\n            nCompression == COMPRESSION_LZW ||\n            nCompression == COMPRESSION_PACKBITS ||\n            nCompression == COMPRESSION_LZMA ||\n            nCompression == COMPRESSION_ZSTD ||\n            nCompression == COMPRESSION_LERC ||\n            nCompression == COMPRESSION_WEBP) ) )\n        return false;\n\n    int nNextCompressionJobAvail = -1;\n    // Wait that at least one job is finished.\n    poCompressThreadPool->WaitCompletion(\n        static_cast<int>(asCompressionJobs.size() - 1) );\n    for( int i = 0; i < static_cast<int>(asCompressionJobs.size()); ++i )\n    {\n        CPLAcquireMutex(hCompressThreadPoolMutex, 1000.0);\n        const bool bReady = asCompressionJobs[i].bReady;\n        CPLReleaseMutex(hCompressThreadPoolMutex);\n        if( bReady )\n        {\n            if( asCompressionJobs[i].nCompressedBufferSize )\n            {\n                WriteRawStripOrTile( asCompressionJobs[i].nStripOrTile,\n                                asCompressionJobs[i].pabyCompressedBuffer,\n                                asCompressionJobs[i].nCompressedBufferSize );\n            }\n            asCompressionJobs[i].pabyCompressedBuffer = nullptr;\n            asCompressionJobs[i].nBufferSize = 0;\n            asCompressionJobs[i].bReady = false;\n            asCompressionJobs[i].nStripOrTile = -1;\n        }\n        if( asCompressionJobs[i].nBufferSize == 0 )\n        {\n            if( nNextCompressionJobAvail < 0 )\n                nNextCompressionJobAvail = i;\n        }\n    }\n    CPLAssert(nNextCompressionJobAvail >= 0);\n\n    GTiffCompressionJob* psJob = &asCompressionJobs[nNextCompressionJobAvail];\n    psJob->poDS = this;\n    psJob->bTIFFIsBigEndian = CPL_TO_BOOL( TIFFIsBigEndian(hTIFF) );\n    psJob->pabyBuffer =\n        static_cast<GByte*>( CPLRealloc(psJob->pabyBuffer, cc) );\n    memcpy(psJob->pabyBuffer, pabyData, cc);\n    psJob->nBufferSize = cc;\n    psJob->nHeight = nHeight;\n    psJob->nStripOrTile = nStripOrTile;\n    psJob->nPredictor = PREDICTOR_NONE;\n    if( nCompression == COMPRESSION_LZW ||\n        nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        nCompression == COMPRESSION_ZSTD )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_PREDICTOR, &psJob->nPredictor );\n    }\n\n    poCompressThreadPool->SubmitJob(ThreadCompressionFunc, psJob);\n    return true;\n}",
    "static void GTiffFillStreamableOffsetAndCount( TIFF* hTIFF, int nSize )\n{\n    uint32 nXSize = 0;\n    uint32 nYSize = 0;\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(hTIFF) );\n    const int nBlockCount =\n        bIsTiled ? TIFFNumberOfTiles(hTIFF) : TIFFNumberOfStrips(hTIFF);\n\n    toff_t *panOffset = nullptr;\n    TIFFGetField( hTIFF, bIsTiled ? TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                  &panOffset );\n    toff_t *panSize = nullptr;\n    TIFFGetField( hTIFF,\n                  bIsTiled ? TIFFTAG_TILEBYTECOUNTS : TIFFTAG_STRIPBYTECOUNTS,\n                  &panSize );\n    toff_t nOffset = nSize;\n    // Trick to avoid clang static analyzer raising false positive about\n    // divide by zero later.\n    int nBlocksPerBand = 1;\n    uint32 nRowsPerStrip = 0;\n    if( !bIsTiled )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP, &nRowsPerStrip);\n        if( nRowsPerStrip > static_cast<uint32>(nYSize) )\n            nRowsPerStrip = nYSize;\n        nBlocksPerBand = DIV_ROUND_UP(nYSize, nRowsPerStrip);\n    }\n    for( int i = 0; i < nBlockCount; ++i )\n    {\n        int cc = bIsTiled ? static_cast<int>(TIFFTileSize(hTIFF)) :\n                            static_cast<int>(TIFFStripSize(hTIFF));\n        if( !bIsTiled )\n        {\n/* -------------------------------------------------------------------- */\n/*      If this is the last strip in the image, and is partial, then    */\n/*      we need to trim the number of scanlines written to the          */\n/*      amount of valid data we have. (#2748)                           */\n/* -------------------------------------------------------------------- */\n            int nStripWithinBand = i % nBlocksPerBand;\n            if( nStripWithinBand * nRowsPerStrip > nYSize - nRowsPerStrip )\n            {\n                cc = (cc / nRowsPerStrip)\n                    * (nYSize - nStripWithinBand * nRowsPerStrip);\n            }\n        }\n        panOffset[i] = nOffset;\n        panSize[i] = cc;\n        nOffset += cc;\n    }\n}",
    "bool GTiffDataset::IsBlockAvailable( int nBlockId,\n                                     vsi_l_offset* pnOffset,\n                                     vsi_l_offset* pnSize,\n                                     bool *pbErrOccurred )\n\n{\n    if( pbErrOccurred )\n        *pbErrOccurred = false;\n\n    WaitCompletionForBlock(nBlockId);\n\n#if defined(INTERNAL_LIBTIFF) && defined(DEFER_STRILE_LOAD)\n    // Optimization to avoid fetching the whole Strip/TileCounts and\n    // Strip/TileOffsets arrays.\n\n    // Note: if strip choping is in effect, _TIFFFillStrilesInternal()\n    // will have 0-memset td_stripoffset_entry/td_stripbytecount_entry, so\n    // we won't enter the below block\n\n    if( eAccess == GA_ReadOnly &&\n        hTIFF->tif_dir.td_stripoffset_entry.tdir_tag != 0 &&\n        hTIFF->tif_dir.td_stripbytecount_entry.tdir_tag != 0 &&\n        !bStreamingIn )\n    {\n        if( !((hTIFF->tif_dir.td_stripoffset_entry.tdir_type == TIFF_SHORT ||\n               hTIFF->tif_dir.td_stripoffset_entry.tdir_type == TIFF_LONG ||\n               hTIFF->tif_dir.td_stripoffset_entry.tdir_type == TIFF_LONG8) &&\n              (hTIFF->tif_dir.td_stripbytecount_entry.tdir_type == TIFF_SHORT ||\n               hTIFF->tif_dir.td_stripbytecount_entry.tdir_type == TIFF_LONG ||\n               hTIFF->tif_dir.td_stripbytecount_entry.tdir_type == TIFF_LONG8)) )\n        {\n            if( nStripArrayAlloc == 0 )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"Unhandled type for StripOffset/StripByteCount\");\n                nStripArrayAlloc = ~nStripArrayAlloc;\n            }\n            if( pnOffset )\n                *pnOffset = 0;\n            if( pnSize )\n                *pnSize = 0;\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        // The size of tags can be actually lesser than the number of strips\n        // (libtiff accepts such files)\n        if( static_cast<uint32>(nBlockId) >=\n                hTIFF->tif_dir.td_stripoffset_entry.tdir_count ||\n            static_cast<uint32>(nBlockId) >=\n                hTIFF->tif_dir.td_stripbytecount_entry.tdir_count )\n        {\n            // In case the tags aren't large enough.\n            if( pnOffset )\n                *pnOffset = 0;\n            if( pnSize )\n                *pnSize = 0;\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        if( hTIFF->tif_dir.td_stripoffset == nullptr )\n        {\n            nStripArrayAlloc = 0;\n        }\n        if( static_cast<uint32>(nBlockId) >= nStripArrayAlloc )\n        {\n            if( nBlockId > 1000000 )\n            {\n                // Avoid excessive memory allocation attempt\n                if( m_nFileSize == 0 )\n                {\n                    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n                    const vsi_l_offset nCurOffset = VSIFTellL(fp);\n                    CPL_IGNORE_RET_VAL( VSIFSeekL(fp, 0, SEEK_END) );\n                    m_nFileSize = VSIFTellL(fp);\n                    CPL_IGNORE_RET_VAL( VSIFSeekL(fp, nCurOffset, SEEK_SET) );\n                }\n                // For such a big blockid we need at least a TIFF_LONG\n                if( static_cast<vsi_l_offset>(nBlockId) >\n                                        m_nFileSize / (2 * sizeof(GUInt32)) )\n                {\n                    CPLError(CE_Failure, CPLE_AppDefined, \"File too short\");\n                    if( pnOffset )\n                        *pnOffset = 0;\n                    if( pnSize )\n                        *pnSize = 0;\n                    if( pbErrOccurred )\n                        *pbErrOccurred = true;\n                    return false;\n                }\n            }\n\n            uint32 nStripArrayAllocBefore = nStripArrayAlloc;\n            uint32 nStripArrayAllocNew;\n            if( nStripArrayAlloc == 0 &&\n                hTIFF->tif_dir.td_nstrips < 1024 * 1024 )\n            {\n                nStripArrayAllocNew = hTIFF->tif_dir.td_nstrips;\n            }\n            else\n            {\n                nStripArrayAllocNew = std::max(\n                    static_cast<uint32>(nBlockId) + 1, 1024U * 512U );\n                if( nStripArrayAllocNew < UINT_MAX / 2  )\n                    nStripArrayAllocNew *= 2;\n                nStripArrayAllocNew = std::min(\n                    nStripArrayAllocNew, hTIFF->tif_dir.td_nstrips);\n            }\n            CPLAssert( static_cast<uint32>(nBlockId) < nStripArrayAllocNew );\n            const uint64 nArraySize64 =\n                static_cast<uint64>(sizeof(uint64)) * nStripArrayAllocNew;\n            const size_t nArraySize = static_cast<size_t>(nArraySize64);\n#if SIZEOF_VOIDP == 4\n            if( nArraySize != nArraySize64 )\n            {\n                CPLError(CE_Failure, CPLE_OutOfMemory,\n                         \"Cannot allocate strip offset and bytecount arrays\");\n                if( pbErrOccurred )\n                    *pbErrOccurred = true;\n                return false;\n            }\n#endif\n            uint64* offsetArray = static_cast<uint64 *>(\n                _TIFFrealloc( hTIFF->tif_dir.td_stripoffset, nArraySize ) );\n            uint64* bytecountArray = static_cast<uint64 *>(\n                _TIFFrealloc( hTIFF->tif_dir.td_stripbytecount, nArraySize ) );\n            if( offsetArray )\n                hTIFF->tif_dir.td_stripoffset = offsetArray;\n            if( bytecountArray )\n                hTIFF->tif_dir.td_stripbytecount = bytecountArray;\n            if( offsetArray && bytecountArray )\n            {\n                nStripArrayAlloc = nStripArrayAllocNew;\n                memset(hTIFF->tif_dir.td_stripoffset + nStripArrayAllocBefore,\n                    0xFF,\n                    (nStripArrayAlloc - nStripArrayAllocBefore) * sizeof(uint64) );\n                memset(hTIFF->tif_dir.td_stripbytecount + nStripArrayAllocBefore,\n                    0xFF,\n                    (nStripArrayAlloc - nStripArrayAllocBefore) * sizeof(uint64) );\n            }\n            else\n            {\n                CPLError(CE_Failure, CPLE_OutOfMemory,\n                         \"Cannot allocate strip offset and bytecount arrays\");\n                _TIFFfree(hTIFF->tif_dir.td_stripoffset);\n                hTIFF->tif_dir.td_stripoffset = nullptr;\n                _TIFFfree(hTIFF->tif_dir.td_stripbytecount);\n                hTIFF->tif_dir.td_stripbytecount = nullptr;\n                nStripArrayAlloc = 0;\n            }\n        }\n        if( hTIFF->tif_dir.td_stripbytecount == nullptr )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n        if( ~(hTIFF->tif_dir.td_stripoffset[nBlockId]) == 0 ||\n            ~(hTIFF->tif_dir.td_stripbytecount[nBlockId]) == 0 )\n        {\n            VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n            const vsi_l_offset nCurOffset = VSIFTellL(fp);\n            if( ~(hTIFF->tif_dir.td_stripoffset[nBlockId]) == 0 )\n            {\n                if( !ReadStripArray( fp,\n                                hTIFF,\n                                &hTIFF->tif_dir.td_stripoffset_entry,\n                                nBlockId,\n                                nStripArrayAlloc,\n                                hTIFF->tif_dir.td_stripoffset ) )\n                {\n                    if( pbErrOccurred )\n                        *pbErrOccurred = true;\n                    return false;\n                }\n            }\n\n            if( ~(hTIFF->tif_dir.td_stripbytecount[nBlockId]) == 0 )\n            {\n                if( !ReadStripArray( fp,\n                                hTIFF,\n                                &hTIFF->tif_dir.td_stripbytecount_entry,\n                                nBlockId,\n                                nStripArrayAlloc,\n                                hTIFF->tif_dir.td_stripbytecount ) )\n                {\n                    if( pbErrOccurred )\n                        *pbErrOccurred = true;\n                    return false;\n                }\n            }\n            if( VSIFSeekL(fp, nCurOffset, SEEK_SET) != 0 )\n            {\n                // For some reason Coverity reports:\n                // Value of non-local \"this->hTIFF->tif_dir.td_stripoffset\"\n                // that was verified to be \"NULL\" is not restored as it was\n                // along other paths.\n                // coverity[end_of_path]\n                if( pbErrOccurred )\n                    *pbErrOccurred = true;\n                return false;\n            }\n        }\n        if( pnOffset )\n            *pnOffset = hTIFF->tif_dir.td_stripoffset[nBlockId];\n        if( pnSize )\n            *pnSize = hTIFF->tif_dir.td_stripbytecount[nBlockId];\n        return hTIFF->tif_dir.td_stripbytecount[nBlockId] != 0;\n    }\n#endif  // defined(INTERNAL_LIBTIFF) && defined(DEFER_STRILE_LOAD)\n    toff_t *panByteCounts = nullptr;\n    toff_t *panOffsets = nullptr;\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(hTIFF) );\n\n    if( ( bIsTiled\n          && TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts )\n          && (pnOffset == nullptr ||\n              TIFFGetField( hTIFF, TIFFTAG_TILEOFFSETS, &panOffsets )) )\n        || ( !bIsTiled\n          && TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts )\n          && (pnOffset == nullptr ||\n              TIFFGetField( hTIFF, TIFFTAG_STRIPOFFSETS, &panOffsets )) ) )\n    {\n        if( panByteCounts == nullptr || (pnOffset != nullptr && panOffsets == nullptr) )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n        const int nBlockCount =\n            bIsTiled ? TIFFNumberOfTiles(hTIFF) : TIFFNumberOfStrips(hTIFF);\n        if( nBlockId >= nBlockCount )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        if( pnOffset )\n            *pnOffset = panOffsets[nBlockId];\n        if( pnSize )\n            *pnSize = panByteCounts[nBlockId];\n        return panByteCounts[nBlockId] != 0;\n    }\n    else\n    {\n        if( pbErrOccurred )\n            *pbErrOccurred = true;\n    }\n\n    return false;\n}",
    "void GTiffDataset::FlushDirectory()\n\n{\n    if( GetAccess() == GA_Update )\n    {\n        if( bMetadataChanged )\n        {\n            if( !SetDirectory() )\n                return;\n            bNeedsRewrite =\n                    WriteMetadata( this, hTIFF, true, osProfile, osFilename,\n                                   papszCreationOptions );\n            bMetadataChanged = false;\n\n            if( m_bForceUnsetRPC )\n            {\n#ifdef HAVE_UNSETFIELD\n                double *padfRPCTag = nullptr;\n                uint16 nCount;\n                if( TIFFGetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, &nCount, &padfRPCTag ) )\n                {\n                    std::vector<double> zeroes(92);\n                    TIFFSetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, 92, zeroes.data() );\n                    TIFFUnsetField( hTIFF, TIFFTAG_RPCCOEFFICIENT );\n                    bNeedsRewrite = true;\n                }\n#endif\n                GDALWriteRPCTXTFile( osFilename, nullptr );\n                GDALWriteRPBFile( osFilename, nullptr );\n            }\n        }\n\n        if( bGeoTIFFInfoChanged )\n        {\n            if( !SetDirectory() )\n                return;\n            WriteGeoTIFFInfo();\n        }\n\n        if( bNoDataChanged )\n        {\n            if( !SetDirectory() )\n                return;\n            if( bNoDataSet )\n            {\n                WriteNoDataValue( hTIFF, dfNoDataValue );\n            }\n            else\n            {\n                UnsetNoDataValue( hTIFF );\n            }\n            bNeedsRewrite = true;\n            bNoDataChanged = false;\n        }\n\n        if( bNeedsRewrite )\n        {\n#if defined(TIFFLIB_VERSION)\n#if defined(HAVE_TIFFGETSIZEPROC)\n            if( !SetDirectory() )\n                return;\n\n            const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( hTIFF );\n\n            nDirOffset = pfnSizeProc( TIFFClientdata( hTIFF ) );\n            if( (nDirOffset % 2) == 1 )\n                ++nDirOffset;\n\n            TIFFRewriteDirectory( hTIFF );\n\n            TIFFSetSubDirectory( hTIFF, nDirOffset );\n#elif TIFFLIB_VERSION > 20010925 && TIFFLIB_VERSION != 20011807\n            if( !SetDirectory() )\n                return;\n\n            TIFFRewriteDirectory( hTIFF );\n#endif\n#endif\n            bNeedsRewrite = false;\n        }\n    }\n\n    // There are some circumstances in which we can reach this point\n    // without having made this our directory (SetDirectory()) in which\n    // case we should not risk a flush.\n    if( GetAccess() == GA_Update && TIFFCurrentDirOffset(hTIFF) == nDirOffset )\n    {\n#if defined(BIGTIFF_SUPPORT)\n        const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            ++nNewDirOffset;\n\n        TIFFFlush( hTIFF );\n\n        if( nDirOffset != TIFFCurrentDirOffset( hTIFF ) )\n        {\n            nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\",\n                      \"directory moved during flush in FlushDirectory()\" );\n        }\n#else\n        // For libtiff 3.X, the above causes regressions and crashes in\n        // tiff_write.py and tiff_ovr.py.\n        TIFFFlush( hTIFF );\n#endif\n    }\n}",
    "CPLErr GTiffDataset::CreateOverviewsFromSrcOverviews(GDALDataset* poSrcDS)\n{\n    CPLAssert(poSrcDS->GetRasterCount() != 0);\n    CPLAssert(nOverviewCount == 0);\n\n    ScanDirectories();\n\n/* -------------------------------------------------------------------- */\n/*      Move to the directory for this dataset.                         */\n/* -------------------------------------------------------------------- */\n    if( !SetDirectory() )\n        return CE_Failure;\n    FlushDirectory();\n\n    int nOvBitsPerSample = nBitsPerSample;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed;\n    std::vector<unsigned short> anTGreen;\n    std::vector<unsigned short> anTBlue;\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( nPhotometric == PHOTOMETRIC_PALETTE && poColorTable != nullptr )\n    {\n        CreateTIFFColorTable(poColorTable, nOvBitsPerSample,\n                             anTRed, anTGreen, anTBlue,\n                             panRed, panGreen, panBlue);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( \"NONE\", this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = nullptr;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples,\n                      &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew =\n            static_cast<uint16*>(\n                CPLMalloc(nExtraSamples * sizeof(uint16)) );\n        memcpy( panExtraSampleValuesNew, panExtraSampleValues,\n                nExtraSamples * sizeof(uint16));\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = nullptr;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if( nCompression == COMPRESSION_LZW ||\n        nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        nCompression == COMPRESSION_ZSTD )\n        TIFFGetField( hTIFF, TIFFTAG_PREDICTOR, &nPredictor );\n    int nOvrBlockXSize = 0;\n    int nOvrBlockYSize = 0;\n    GTIFFGetOverviewBlockSize(&nOvrBlockXSize, &nOvrBlockYSize);\n\n    int nSrcOverviews = poSrcDS->GetRasterBand(1)->GetOverviewCount();\n    CPLErr eErr = CE_None;\n\n    for( int i = 0; i < nSrcOverviews && eErr == CE_None; ++i )\n    {\n        GDALRasterBand* poOvrBand = poSrcDS->GetRasterBand(1)->GetOverview(i);\n\n        int nOXSize = poOvrBand->GetXSize();\n        int nOYSize = poOvrBand->GetYSize();\n\n        int nOvrJpegQuality = nJpegQuality;\n        if( nCompression == COMPRESSION_JPEG &&\n            CPLGetConfigOption( \"JPEG_QUALITY_OVERVIEW\", nullptr ) != nullptr )\n        {\n            nOvrJpegQuality =\n                atoi(CPLGetConfigOption(\"JPEG_QUALITY_OVERVIEW\",\"75\"));\n        }\n\n        CPLString osNoData; // don't move this in inner scope\n        const char* pszNoData = nullptr;\n        if( bNoDataSet )\n        {\n            osNoData = GTiffFormatGDALNoDataTagValue(dfNoDataValue);\n            pszNoData = osNoData.c_str();\n        }\n\n        toff_t nOverviewOffset =\n                GTIFFWriteDirectory(hTIFF, FILETYPE_REDUCEDIMAGE,\n                                    nOXSize, nOYSize,\n                                    nOvBitsPerSample, nPlanarConfig,\n                                    nSamplesPerPixel,\n                                    nOvrBlockXSize,\n                                    nOvrBlockYSize,\n                                    TRUE,\n                                    nCompression, nPhotometric, nSampleFormat,\n                                    nPredictor,\n                                    panRed, panGreen, panBlue,\n                                    nExtraSamples, panExtraSampleValues,\n                                    osMetadata,\n                                    nOvrJpegQuality >= 0 ?\n                                        CPLSPrintf(\"%d\", nOvrJpegQuality) : nullptr,\n                                    CPLSPrintf(\"%d\", nJpegTablesMode),\n                                    pszNoData,\n#ifdef HAVE_LERC\n                                    anLercAddCompressionAndVersion\n#else\n                                    nullptr\n#endif\n                                   );\n\n        if( nOverviewOffset == 0 )\n            eErr = CE_Failure;\n        else\n            eErr = RegisterNewOverviewDataset(nOverviewOffset, nOvrJpegQuality);\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    if( eErr == CE_None )\n        eErr = CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n\n    return eErr;\n}",
    "CPLErr GTiffDataset::IBuildOverviews(\n    const char * pszResampling,\n    int nOverviews, int * panOverviewList,\n    int nBandsIn, int * panBandList,\n    GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    ScanDirectories();\n\n    // Make implicit JPEG overviews invisible, but do not destroy\n    // them in case they are already used (not sure that the client\n    // has the right to do that.  Behaviour maybe undefined in GDAL API.\n    nJPEGOverviewCount = 0;\n\n/* -------------------------------------------------------------------- */\n/*      If RRD or external OVR overviews requested, then invoke         */\n/*      generic handling.                                               */\n/* -------------------------------------------------------------------- */\n    bool bUseGenericHandling = false;\n\n    if( CPLTestBool(CPLGetConfigOption( \"USE_RRD\", \"NO\" ))\n        || CPLTestBool(CPLGetConfigOption( \"TIFF_USE_OVR\", \"NO\" )) )\n    {\n        bUseGenericHandling = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have read access, then create the overviews         */\n/*      externally.                                                     */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() != GA_Update )\n    {\n        CPLDebug( \"GTiff\",\n                  \"File open for read-only accessing, \"\n                  \"creating overviews externally.\" );\n\n        bUseGenericHandling = true;\n    }\n\n    if( bUseGenericHandling )\n    {\n        if( nOverviewCount != 0 )\n        {\n            CPLError(\n                CE_Failure, CPLE_NotSupported,\n                \"Cannot add external overviews when there are already \"\n                \"internal overviews\" );\n            return CE_Failure;\n        }\n\n        return GDALDataset::IBuildOverviews(\n            pszResampling, nOverviews, panOverviewList,\n            nBandsIn, panBandList, pfnProgress, pProgressData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Our TIFF overview support currently only works safely if all    */\n/*      bands are handled at the same time.                             */\n/* -------------------------------------------------------------------- */\n    if( nBandsIn != GetRasterCount() )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Generation of overviews in TIFF currently only \"\n                  \"supported when operating on all bands.  \"\n                  \"Operation failed.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If zero overviews were requested, we need to clear all          */\n/*      existing overviews.                                             */\n/* -------------------------------------------------------------------- */\n    if( nOverviews == 0 )\n    {\n        if( nOverviewCount == 0 )\n            return GDALDataset::IBuildOverviews(\n                pszResampling, nOverviews, panOverviewList,\n                nBandsIn, panBandList, pfnProgress, pProgressData );\n\n        return CleanOverviews();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      libtiff 3.X has issues when generating interleaved overviews.   */\n/*      so generate them one after another one.                         */\n/* -------------------------------------------------------------------- */\n\n    CPLErr eErr = CE_None;\n\n#ifndef BIGTIFF_SUPPORT\n    if( nOverviews > 1 )\n    {\n        double* padfOvrRasterFactor =\n            static_cast<double*>( CPLMalloc(sizeof(double) * nOverviews) );\n        double dfTotal = 0;\n        for( int i = 0; i < nOverviews; ++i )\n        {\n            if( panOverviewList[i] <= 0 )\n            {\n                CPLError(CE_Failure, CPLE_AppDefined,\n                         \"Invalid overview factor : %d\", panOverviewList[i]);\n                eErr = CE_Failure;\n                break;\n            }\n            padfOvrRasterFactor[i] =\n                1.0 / (panOverviewList[i] * panOverviewList[i]);\n            dfTotal += padfOvrRasterFactor[i];\n        }\n\n        double dfAcc = 0.0;\n        for( int i = 0; i < nOverviews && eErr == CE_None; ++i )\n        {\n            void *pScaledProgressData =\n                GDALCreateScaledProgress(\n                    dfAcc / dfTotal,\n                    (dfAcc + padfOvrRasterFactor[i]) / dfTotal,\n                    pfnProgress, pProgressData );\n            dfAcc += padfOvrRasterFactor[i];\n\n            eErr = IBuildOverviews(\n                pszResampling, 1, &panOverviewList[i],\n                nBandsIn, panBandList, GDALScaledProgress,\n                pScaledProgressData );\n\n            GDALDestroyScaledProgress(pScaledProgressData);\n        }\n\n        CPLFree(padfOvrRasterFactor);\n\n        return eErr;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Initialize progress counter.                                    */\n/* -------------------------------------------------------------------- */\n    if( !pfnProgress( 0.0, nullptr, pProgressData ) )\n    {\n        CPLError( CE_Failure, CPLE_UserInterrupt, \"User terminated\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Move to the directory for this dataset.                         */\n/* -------------------------------------------------------------------- */\n    if( !SetDirectory() )\n        return CE_Failure;\n    FlushDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      If we are averaging bit data to grayscale we need to create     */\n/*      8bit overviews.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvBitsPerSample = nBitsPerSample;\n\n    if( STARTS_WITH_CI(pszResampling, \"AVERAGE_BIT2\") )\n        nOvBitsPerSample = 8;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed;\n    std::vector<unsigned short> anTGreen;\n    std::vector<unsigned short> anTBlue;\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( nPhotometric == PHOTOMETRIC_PALETTE && poColorTable != nullptr )\n    {\n        CreateTIFFColorTable(poColorTable, nOvBitsPerSample,\n                             anTRed, anTGreen, anTBlue,\n                             panRed, panGreen, panBlue);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( pszResampling, this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = nullptr;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples,\n                      &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew =\n            static_cast<uint16*>( CPLMalloc(nExtraSamples * sizeof(uint16)) );\n        memcpy( panExtraSampleValuesNew, panExtraSampleValues,\n                nExtraSamples * sizeof(uint16) );\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = nullptr;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if( nCompression == COMPRESSION_LZW ||\n        nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        nCompression == COMPRESSION_ZSTD )\n        TIFFGetField( hTIFF, TIFFTAG_PREDICTOR, &nPredictor );\n\n/* -------------------------------------------------------------------- */\n/*      Establish which of the overview levels we already have, and     */\n/*      which are new.  We assume that band 1 of the file is            */\n/*      representative.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvrBlockXSize = 0;\n    int nOvrBlockYSize = 0;\n    GTIFFGetOverviewBlockSize(&nOvrBlockXSize, &nOvrBlockYSize);\n    std::vector<bool> abRequireNewOverview(nOverviews, true);\n    for( int i = 0; i < nOverviews && eErr == CE_None; ++i )\n    {\n        for( int j = 0; j < nOverviewCount && eErr == CE_None; ++j )\n        {\n            GTiffDataset *poODS = papoOverviewDS[j];\n\n            const int nOvFactor =\n                GDALComputeOvFactor(poODS->GetRasterXSize(),\n                                    GetRasterXSize(),\n                                    poODS->GetRasterYSize(),\n                                    GetRasterYSize());\n\n            // If we already have a 1x1 overview and this new one would result\n            // in it too, then don't create it.\n            if( poODS->GetRasterXSize() == 1 &&\n                poODS->GetRasterYSize() == 1 &&\n                (GetRasterXSize() + panOverviewList[i] - 1)\n                    / panOverviewList[i] == 1 &&\n                (GetRasterYSize() + panOverviewList[i] - 1)\n                    / panOverviewList[i] == 1 )\n            {\n                abRequireNewOverview[i] = false;\n                break;\n            }\n\n            if( nOvFactor == panOverviewList[i]\n                || nOvFactor == GDALOvLevelAdjust2( panOverviewList[i],\n                                                    GetRasterXSize(),\n                                                    GetRasterYSize() ) )\n            {\n                abRequireNewOverview[i] = false;\n                break;\n            }\n        }\n\n        if( abRequireNewOverview[i] )\n        {\n            const int nOXSize =\n                (GetRasterXSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n            const int nOYSize =\n                (GetRasterYSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n\n            int nOvrJpegQuality = nJpegQuality;\n            if( nCompression == COMPRESSION_JPEG &&\n                CPLGetConfigOption( \"JPEG_QUALITY_OVERVIEW\", nullptr ) != nullptr )\n            {\n                nOvrJpegQuality =\n                    atoi(CPLGetConfigOption(\"JPEG_QUALITY_OVERVIEW\",\"75\"));\n            }\n\n            CPLString osNoData; // don't move this in inner scope\n            const char* pszNoData = nullptr;\n            if( bNoDataSet )\n            {\n                osNoData = GTiffFormatGDALNoDataTagValue(dfNoDataValue);\n                pszNoData = osNoData.c_str();\n            }\n\n            const toff_t nOverviewOffset =\n                GTIFFWriteDirectory(\n                    hTIFF, FILETYPE_REDUCEDIMAGE,\n                    nOXSize, nOYSize,\n                    nOvBitsPerSample, nPlanarConfig,\n                    nSamplesPerPixel, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                    nCompression, nPhotometric, nSampleFormat,\n                    nPredictor,\n                    panRed, panGreen, panBlue,\n                    nExtraSamples, panExtraSampleValues,\n                    osMetadata,\n                    nOvrJpegQuality >= 0 ?\n                                CPLSPrintf(\"%d\", nOvrJpegQuality) : nullptr,\n                    CPLSPrintf(\"%d\", nJpegTablesMode),\n                    pszNoData,\n#ifdef HAVE_LERC\n                    anLercAddCompressionAndVersion\n#else\n                    nullptr\n#endif\n            );\n\n            if( nOverviewOffset == 0 )\n                eErr = CE_Failure;\n            else\n                eErr = RegisterNewOverviewDataset(nOverviewOffset,\n                                                  nOvrJpegQuality);\n        }\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    if( eErr != CE_None )\n        return eErr;\n\n    eErr = CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n\n/* -------------------------------------------------------------------- */\n/*      Refresh overviews for the mask                                  */\n/* -------------------------------------------------------------------- */\n    if( poMaskDS != nullptr &&\n        poMaskDS->GetRasterCount() == 1 )\n    {\n        int nMaskOverviews = 0;\n\n        GDALRasterBand **papoOverviewBands = static_cast<GDALRasterBand **>(\n            CPLCalloc(sizeof(void*),nOverviewCount) );\n        for( int i = 0; i < nOverviewCount; ++i )\n        {\n            if( papoOverviewDS[i]->poMaskDS != nullptr )\n            {\n                papoOverviewBands[nMaskOverviews++] =\n                        papoOverviewDS[i]->poMaskDS->GetRasterBand(1);\n            }\n        }\n        eErr = GDALRegenerateOverviews(\n            poMaskDS->GetRasterBand(1),\n            nMaskOverviews,\n            reinterpret_cast<GDALRasterBandH *>( papoOverviewBands ),\n            pszResampling, GDALDummyProgress, nullptr );\n        CPLFree(papoOverviewBands);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Refresh old overviews that were listed.                         */\n/* -------------------------------------------------------------------- */\n    if( nPlanarConfig == PLANARCONFIG_CONTIG &&\n        GDALDataTypeIsComplex(GetRasterBand( panBandList[0] )->\n                              GetRasterDataType()) == FALSE &&\n        GetRasterBand( panBandList[0] )->GetColorTable() == nullptr &&\n        (STARTS_WITH_CI(pszResampling, \"NEAR\") ||\n         EQUAL(pszResampling, \"AVERAGE\") ||\n         EQUAL(pszResampling, \"GAUSS\") ||\n         EQUAL(pszResampling, \"CUBIC\") ||\n         EQUAL(pszResampling, \"CUBICSPLINE\") ||\n         EQUAL(pszResampling, \"LANCZOS\") ||\n         EQUAL(pszResampling, \"BILINEAR\")) )\n    {\n        // In the case of pixel interleaved compressed overviews, we want to\n        // generate the overviews for all the bands block by block, and not\n        // band after band, in order to write the block once and not loose\n        // space in the TIFF file.  We also use that logic for uncompressed\n        // overviews, since GDALRegenerateOverviewsMultiBand() will be able to\n        // trigger cascading overview regeneration even in the presence\n        // of an alpha band.\n\n        int nNewOverviews = 0;\n\n        GDALRasterBand ***papapoOverviewBands =\n            static_cast<GDALRasterBand ***>(CPLCalloc(sizeof(void*),nBandsIn));\n        GDALRasterBand **papoBandList =\n            static_cast<GDALRasterBand **>(CPLCalloc(sizeof(void*),nBandsIn));\n        for( int iBand = 0; iBand < nBandsIn; ++iBand )\n        {\n            GDALRasterBand* poBand = GetRasterBand( panBandList[iBand] );\n\n            papoBandList[iBand] = poBand;\n            papapoOverviewBands[iBand] =\n                static_cast<GDALRasterBand **>( CPLCalloc(\n                    sizeof(void*), poBand->GetOverviewCount()) );\n\n            int iCurOverview = 0;\n            std::vector<bool> abAlreadyUsedOverviewBand(\n                poBand->GetOverviewCount(), false);\n\n            for( int i = 0; i < nOverviews; ++i )\n            {\n                for( int j = 0; j < poBand->GetOverviewCount(); ++j )\n                {\n                    if( abAlreadyUsedOverviewBand[j] )\n                        continue;\n\n                    int    nOvFactor;\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    nOvFactor = GDALComputeOvFactor(poOverview->GetXSize(),\n                                                     poBand->GetXSize(),\n                                                     poOverview->GetYSize(),\n                                                     poBand->GetYSize());\n\n                    int bHasNoData = FALSE;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if( bHasNoData )\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    if( nOvFactor == panOverviewList[i]\n                        || nOvFactor == GDALOvLevelAdjust2(\n                                            panOverviewList[i],\n                                            poBand->GetXSize(),\n                                            poBand->GetYSize() ) )\n                    {\n                        abAlreadyUsedOverviewBand[j] = true;\n                        CPLAssert(iCurOverview < poBand->GetOverviewCount());\n                        papapoOverviewBands[iBand][iCurOverview] = poOverview;\n                        ++iCurOverview ;\n                        break;\n                    }\n                }\n            }\n\n            if( nNewOverviews == 0 )\n            {\n                nNewOverviews = iCurOverview;\n            }\n            else if( nNewOverviews != iCurOverview )\n            {\n                CPLAssert(false);\n                return CE_Failure;\n            }\n        }\n\n        GDALRegenerateOverviewsMultiBand( nBandsIn, papoBandList,\n                                          nNewOverviews, papapoOverviewBands,\n                                          pszResampling, pfnProgress,\n                                          pProgressData );\n\n        for( int iBand = 0; iBand < nBandsIn; ++iBand )\n        {\n            CPLFree(papapoOverviewBands[iBand]);\n        }\n        CPLFree(papapoOverviewBands);\n        CPLFree(papoBandList);\n    }\n    else\n    {\n        GDALRasterBand **papoOverviewBands = static_cast<GDALRasterBand **>(\n            CPLCalloc(sizeof(void*), nOverviews) );\n\n        for( int iBand = 0; iBand < nBandsIn && eErr == CE_None; ++iBand )\n        {\n            GDALRasterBand *poBand = GetRasterBand( panBandList[iBand] );\n            if( poBand == nullptr )\n            {\n                eErr = CE_Failure;\n                break;\n            }\n\n            std::vector<bool> abAlreadyUsedOverviewBand(\n                poBand->GetOverviewCount(), false);\n\n            int nNewOverviews = 0;\n            for( int i = 0; i < nOverviews; ++i )\n            {\n                for( int j = 0; j < poBand->GetOverviewCount(); ++j )\n                {\n                    if( abAlreadyUsedOverviewBand[j] )\n                        continue;\n\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    int bHasNoData = FALSE;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if( bHasNoData )\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    const int nOvFactor =\n                        GDALComputeOvFactor(poOverview->GetXSize(),\n                                            poBand->GetXSize(),\n                                            poOverview->GetYSize(),\n                                            poBand->GetYSize());\n\n                    if( nOvFactor == panOverviewList[i]\n                        || nOvFactor == GDALOvLevelAdjust2(\n                                            panOverviewList[i],\n                                            poBand->GetXSize(),\n                                            poBand->GetYSize() ) )\n                    {\n                        abAlreadyUsedOverviewBand[j] = true;\n                        CPLAssert(nNewOverviews < poBand->GetOverviewCount());\n                        papoOverviewBands[nNewOverviews++] = poOverview;\n                        break;\n                    }\n                }\n            }\n\n            void *pScaledProgressData =\n                GDALCreateScaledProgress(\n                    iBand / static_cast<double>( nBandsIn ),\n                    (iBand + 1) / static_cast<double>( nBandsIn ),\n                    pfnProgress, pProgressData );\n\n            eErr = GDALRegenerateOverviews(\n                poBand,\n                nNewOverviews,\n                reinterpret_cast<GDALRasterBandH *>( papoOverviewBands ),\n                pszResampling,\n                GDALScaledProgress,\n                pScaledProgressData );\n\n            GDALDestroyScaledProgress( pScaledProgressData );\n        }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup                                                         */\n    /* -------------------------------------------------------------------- */\n        CPLFree( papoOverviewBands );\n    }\n\n    pfnProgress( 1.0, nullptr, pProgressData );\n\n    return eErr;\n}",
    "static void GTiffWriteDummyGeokeyDirectory( TIFF* hTIFF )\n{\n    // If we have existing geokeys, try to wipe them\n    // by writing a dummy geokey directory. (#2546)\n    uint16 *panVI = nullptr;\n    uint16 nKeyCount = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY,\n                        &nKeyCount, &panVI ) )\n    {\n        GUInt16 anGKVersionInfo[4] = { 1, 1, 0, 0 };\n        double adfDummyDoubleParams[1] = { 0.0 };\n        TIFFSetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY,\n                        4, anGKVersionInfo );\n        TIFFSetField( hTIFF, TIFFTAG_GEODOUBLEPARAMS,\n                        1, adfDummyDoubleParams );\n        TIFFSetField( hTIFF, TIFFTAG_GEOASCIIPARAMS, \"\" );\n    }\n}",
    "static void WriteMDMetadata( GDALMultiDomainMetadata *poMDMD, TIFF *hTIFF,\n                             CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail,\n                             int nBand, const char * pszProfile )\n\n{\n\n/* ==================================================================== */\n/*      Process each domain.                                            */\n/* ==================================================================== */\n    char **papszDomainList = poMDMD->GetDomainList();\n    for( int iDomain = 0;\n         papszDomainList && papszDomainList[iDomain];\n         ++iDomain )\n    {\n        char **papszMD = poMDMD->GetMetadata( papszDomainList[iDomain] );\n        bool bIsXML = false;\n\n        if( EQUAL(papszDomainList[iDomain], \"IMAGE_STRUCTURE\") )\n            continue;  // Ignored.\n        if( EQUAL(papszDomainList[iDomain], \"COLOR_PROFILE\") )\n            continue;  // Ignored.\n        if( EQUAL(papszDomainList[iDomain], MD_DOMAIN_RPC) )\n            continue;  // Handled elsewhere.\n        if( EQUAL(papszDomainList[iDomain], \"xml:ESRI\")\n            && CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n            continue;  // Handled elsewhere.\n        if( EQUAL(papszDomainList[iDomain], \"xml:XMP\") )\n            continue;  // Handled in SetMetadata.\n\n        if( STARTS_WITH_CI(papszDomainList[iDomain], \"xml:\") )\n            bIsXML = true;\n\n/* -------------------------------------------------------------------- */\n/*      Process each item in this domain.                               */\n/* -------------------------------------------------------------------- */\n        for( int iItem = 0; papszMD && papszMD[iItem]; ++iItem )\n        {\n            const char *pszItemValue = nullptr;\n            char *pszItemName = nullptr;\n\n            if( bIsXML )\n            {\n                pszItemName = CPLStrdup(\"doc\");\n                pszItemValue = papszMD[iItem];\n            }\n            else\n            {\n                pszItemValue = CPLParseNameValue( papszMD[iItem], &pszItemName);\n                if( pszItemName == nullptr )\n                {\n                    CPLDebug( \"GTiff\",\n                              \"Invalid metadata item : %s\", papszMD[iItem] );\n                    continue;\n                }\n            }\n\n/* -------------------------------------------------------------------- */\n/*      Convert into XML item or handle as a special TIFF tag.          */\n/* -------------------------------------------------------------------- */\n            if( strlen(papszDomainList[iDomain]) == 0\n                && nBand == 0 &&\n                (STARTS_WITH_CI(pszItemName, \"TIFFTAG_\") ||\n                 (EQUAL(pszItemName, \"GEO_METADATA\") &&\n                  EQUAL(pszProfile, szPROFILE_GDALGeoTIFF)) ||\n                 (EQUAL(pszItemName, \"TIFF_RSID\") &&\n                  EQUAL(pszProfile, szPROFILE_GDALGeoTIFF))) )\n            {\n                if( EQUAL(pszItemName, \"TIFFTAG_RESOLUTIONUNIT\") )\n                {\n                    // ResolutionUnit can't be 0, which is the default if\n                    // atoi() fails.  Set to 1=Unknown.\n                    int v = atoi(pszItemValue);\n                    if( !v ) v = RESUNIT_NONE;\n                    TIFFSetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, v);\n                }\n                else\n                {\n                    bool bFoundTag = false;\n                    size_t iTag = 0;  // Used after for.\n                    for( ;\n                         iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n                         ++iTag )\n                    {\n                        if( EQUAL(pszItemName, asTIFFTags[iTag].pszTagName) )\n                        {\n                            bFoundTag = true;\n                            break;\n                        }\n                    }\n\n                    if( bFoundTag &&\n                        asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      pszItemValue );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      CPLAtof(pszItemValue) );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      atoi(pszItemValue) );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING )\n                    {\n                        int nLen = static_cast<int>(strlen(pszItemValue));\n                        if( nLen )\n                        {\n                            TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                          nLen,\n                                          pszItemValue );\n                        }\n                    }\n                    else\n                        CPLError(\n                            CE_Warning, CPLE_NotSupported,\n                            \"%s metadata item is unhandled and \"\n                            \"will not be written\",\n                            pszItemName);\n                }\n            }\n            else if( nBand == 0 && EQUAL(pszItemName,GDALMD_AREA_OR_POINT) )\n            {\n                /* Do nothing, handled elsewhere. */;\n            }\n            else\n            {\n                AppendMetadataItem( ppsRoot, ppsTail,\n                                    pszItemName, pszItemValue,\n                                    nBand, nullptr, papszDomainList[iDomain] );\n            }\n\n            CPLFree( pszItemName );\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Remove TIFFTAG_xxxxxx that are already set but no longer in     */\n/*      the metadata list (#5619)                                       */\n/* -------------------------------------------------------------------- */\n        if( strlen(papszDomainList[iDomain]) == 0 && nBand == 0 )\n        {\n            for( size_t iTag = 0;\n                 iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n                 ++iTag )\n            {\n                uint32 nCount = 0;\n                char* pszText = nullptr;\n                int16 nVal = 0;\n                float fVal = 0.0f;\n                const char* pszVal =\n                    CSLFetchNameValue(papszMD, asTIFFTags[iTag].pszTagName);\n                if( pszVal == nullptr &&\n                    ((asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                    &pszText )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &nVal )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &fVal )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &nCount, &pszText ))) )\n                {\n#ifdef HAVE_UNSETFIELD\n                    TIFFUnsetField( hTIFF, asTIFFTags[iTag].nTagVal );\n#else\n                    if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n                    {\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal, \"\" );\n                    }\n#endif\n                }\n            }\n        }\n    }\n}",
    "bool GTiffDataset::WriteMetadata( GDALDataset *poSrcDS, TIFF *l_hTIFF,\n                                  bool bSrcIsGeoTIFF,\n                                  const char *pszProfile,\n                                  const char *pszTIFFFilename,\n                                  char **l_papszCreationOptions,\n                                  bool bExcludeRPBandIMGFileWriting)\n\n{\n/* -------------------------------------------------------------------- */\n/*      Convert all the remaining metadata into a simple XML            */\n/*      format.                                                         */\n/* -------------------------------------------------------------------- */\n    CPLXMLNode *psRoot = nullptr;\n    CPLXMLNode *psTail = nullptr;\n\n    if( bSrcIsGeoTIFF )\n    {\n        GTiffDataset* poSrcDSGTiff = cpl::down_cast<GTiffDataset *>(poSrcDS);\n        assert(poSrcDSGTiff);\n        WriteMDMetadata(\n            &poSrcDSGTiff->oGTiffMDMD,\n            l_hTIFF, &psRoot, &psTail, 0, pszProfile );\n    }\n    else\n    {\n        char **papszMD = poSrcDS->GetMetadata();\n\n        if( CSLCount(papszMD) > 0 )\n        {\n            GDALMultiDomainMetadata l_oMDMD;\n            l_oMDMD.SetMetadata( papszMD );\n\n            WriteMDMetadata( &l_oMDMD, l_hTIFF, &psRoot, &psTail,\n                             0, pszProfile );\n        }\n    }\n\n    if( !bExcludeRPBandIMGFileWriting )\n    {\n        WriteRPC(poSrcDS, l_hTIFF, bSrcIsGeoTIFF,\n                 pszProfile, pszTIFFFilename,\n                 l_papszCreationOptions);\n\n/* -------------------------------------------------------------------- */\n/*      Handle metadata data written to an IMD file.                    */\n/* -------------------------------------------------------------------- */\n        char **papszIMDMD = poSrcDS->GetMetadata(MD_DOMAIN_IMD);\n        if( papszIMDMD != nullptr )\n        {\n            GDALWriteIMDFile( pszTIFFFilename, papszIMDMD );\n        }\n    }\n\n    uint16 nPhotometric = 0;\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    const bool bStardardColorInterp =\n        IsStandardColorInterpretation(poSrcDS, nPhotometric,\n                                      l_papszCreationOptions);\n\n/* -------------------------------------------------------------------- */\n/*      We also need to address band specific metadata, and special     */\n/*      \"role\" metadata.                                                */\n/* -------------------------------------------------------------------- */\n    for( int nBand = 1; nBand <= poSrcDS->GetRasterCount(); ++nBand )\n    {\n        GDALRasterBand *poBand = poSrcDS->GetRasterBand( nBand );\n\n        if( bSrcIsGeoTIFF )\n        {\n            GTiffRasterBand* poSrcBandGTiff = cpl::down_cast<GTiffRasterBand *>(poBand);\n            assert(poSrcBandGTiff);\n            WriteMDMetadata(\n                &poSrcBandGTiff->oGTiffMDMD,\n                l_hTIFF, &psRoot, &psTail, nBand, pszProfile );\n        }\n        else\n        {\n            char **papszMD = poBand->GetMetadata();\n\n            if( CSLCount(papszMD) > 0 )\n            {\n                GDALMultiDomainMetadata l_oMDMD;\n                l_oMDMD.SetMetadata( papszMD );\n\n                WriteMDMetadata( &l_oMDMD, l_hTIFF, &psRoot, &psTail, nBand,\n                                 pszProfile );\n            }\n        }\n\n        const double dfOffset = poBand->GetOffset();\n        const double dfScale = poBand->GetScale();\n        bool bGeoTIFFScaleOffsetInZ = false;\n        double adfGeoTransform[6];\n        // Check if we have already encoded scale/offset in the GeoTIFF tags\n        if( poSrcDS->GetGeoTransform(adfGeoTransform) == CE_None &&\n            adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0\n            && adfGeoTransform[5] < 0.0 &&\n            HasVerticalCS(poSrcDS->GetProjectionRef()) &&\n            poSrcDS->GetRasterCount() == 1 )\n        {\n            bGeoTIFFScaleOffsetInZ = true;\n        }\n\n        if( (dfOffset != 0.0 || dfScale != 1.0) && !bGeoTIFFScaleOffsetInZ )\n        {\n            char szValue[128] = {};\n\n            CPLsnprintf( szValue, sizeof(szValue), \"%.18g\", dfOffset );\n            AppendMetadataItem( &psRoot, &psTail, \"OFFSET\", szValue, nBand,\n                                \"offset\", \"\" );\n            CPLsnprintf( szValue, sizeof(szValue), \"%.18g\", dfScale );\n            AppendMetadataItem( &psRoot, &psTail, \"SCALE\", szValue, nBand,\n                                \"scale\", \"\" );\n        }\n\n        const char* pszUnitType = poBand->GetUnitType();\n        if( pszUnitType != nullptr && pszUnitType[0] != '\\0' )\n            AppendMetadataItem( &psRoot, &psTail, \"UNITTYPE\",\n                                pszUnitType, nBand,\n                                \"unittype\", \"\" );\n\n        if( strlen(poBand->GetDescription()) > 0 )\n        {\n            AppendMetadataItem( &psRoot, &psTail, \"DESCRIPTION\",\n                                poBand->GetDescription(), nBand,\n                                \"description\", \"\" );\n        }\n\n        if( !bStardardColorInterp &&\n            !(nBand <= 3 &&  EQUAL(CSLFetchNameValueDef(\n                l_papszCreationOptions, \"PHOTOMETRIC\", \"\"), \"RGB\") ) )\n        {\n            AppendMetadataItem( &psRoot, &psTail, \"COLORINTERP\",\n                                GDALGetColorInterpretationName(\n                                    poBand->GetColorInterpretation()),\n                                nBand,\n                                \"colorinterp\", \"\" );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the generic XML metadata if there is any.             */\n/* -------------------------------------------------------------------- */\n    if( psRoot != nullptr )\n    {\n        bool bRet = true;\n\n        if( EQUAL(pszProfile,szPROFILE_GDALGeoTIFF) )\n        {\n            char *pszXML_MD = CPLSerializeXMLTree( psRoot );\n            if( strlen(pszXML_MD) > 32000 )\n            {\n                if( bSrcIsGeoTIFF )\n                {\n                    if( cpl::down_cast<GTiffDataset *>(\n                           poSrcDS)->GetPamFlags() & GPF_DISABLED )\n                    {\n                        CPLError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"Metadata exceeding 32000 bytes cannot be written \"\n                            \"into GeoTIFF.\" );\n                    }\n                    else\n                    {\n                        cpl::down_cast<GTiffDataset *>(poSrcDS)->\n                            PushMetadataToPam();\n                        CPLError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"Metadata exceeding 32000 bytes cannot be written \"\n                            \"into GeoTIFF. Transferred to PAM instead.\" );\n                    }\n                }\n                else\n                {\n                    bRet = false;\n                }\n            }\n            else\n            {\n                TIFFSetField( l_hTIFF, TIFFTAG_GDAL_METADATA, pszXML_MD );\n            }\n            CPLFree( pszXML_MD );\n        }\n        else\n        {\n            if( bSrcIsGeoTIFF )\n                cpl::down_cast<GTiffDataset *>(poSrcDS)->PushMetadataToPam();\n            else\n                bRet = false;\n        }\n\n        CPLDestroyXMLNode( psRoot );\n\n        return bRet;\n    }\n\n    // If we have no more metadata but it existed before,\n    // remove the GDAL_METADATA tag.\n    if( EQUAL(pszProfile,szPROFILE_GDALGeoTIFF) )\n    {\n        char* pszText = nullptr;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n        {\n#ifdef HAVE_UNSETFIELD\n            TIFFUnsetField( l_hTIFF, TIFFTAG_GDAL_METADATA );\n#else\n            TIFFSetField( l_hTIFF, TIFFTAG_GDAL_METADATA, \"\" );\n#endif\n        }\n    }\n\n    return true;\n}",
    "char** GTiffDatasetReadRPCTag(TIFF* hTIFF)\n\n{\n    double *padfRPCTag = nullptr;\n    uint16 nCount;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, &nCount, &padfRPCTag )\n        || nCount != 92 )\n        return nullptr;\n\n    CPLStringList asMD;\n    asMD.SetNameValue(RPC_LINE_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[2]));\n    asMD.SetNameValue(RPC_SAMP_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[3]));\n    asMD.SetNameValue(RPC_LAT_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[4]));\n    asMD.SetNameValue(RPC_LONG_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[5]));\n    asMD.SetNameValue(RPC_HEIGHT_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[6]));\n    asMD.SetNameValue(RPC_LINE_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[7]));\n    asMD.SetNameValue(RPC_SAMP_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[8]));\n    asMD.SetNameValue(RPC_LAT_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[9]));\n    asMD.SetNameValue(RPC_LONG_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[10]));\n    asMD.SetNameValue(RPC_HEIGHT_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[11]));\n\n    CPLString osField;\n    CPLString osMultiField;\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[12+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue(RPC_LINE_NUM_COEFF, osMultiField );\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[32+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_LINE_DEN_COEFF, osMultiField );\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[52+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_SAMP_NUM_COEFF, osMultiField );\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[72+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_SAMP_DEN_COEFF, osMultiField );\n\n    return asMD.StealList();\n}",
    "void GTiffDataset::RestoreVolatileParameters(TIFF* l_hTIFF)\n{\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( nCompression == COMPRESSION_JPEG\n        && nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode = JPEGCOLORMODE_RAW;  // Initialize to 0;\n\n        TIFFGetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode );\n        if( nColorMode != JPEGCOLORMODE_RGB )\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Propagate any quality settings.                                 */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() == GA_Update )\n    {\n        // Now, reset zip and jpeg quality.\n        if(nJpegQuality > 0 && nCompression == COMPRESSION_JPEG)\n        {\n#ifdef DEBUG_VERBOSE\n            CPLDebug( \"GTiff\", \"Propagate JPEG_QUALITY(%d) in SetDirectory()\",\n                      nJpegQuality );\n#endif\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGQUALITY, nJpegQuality);\n        }\n        if(nJpegTablesMode >= 0 && nCompression == COMPRESSION_JPEG)\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGTABLESMODE, nJpegTablesMode);\n        if(nZLevel > 0 && (nCompression == COMPRESSION_ADOBE_DEFLATE ||\n                           nCompression == COMPRESSION_LERC) )\n            TIFFSetField(l_hTIFF, TIFFTAG_ZIPQUALITY, nZLevel);\n        if(nLZMAPreset > 0 && nCompression == COMPRESSION_LZMA)\n            TIFFSetField(l_hTIFF, TIFFTAG_LZMAPRESET, nLZMAPreset);\n        if( nZSTDLevel > 0 && (nCompression == COMPRESSION_ZSTD ||\n                               nCompression == COMPRESSION_LERC) )\n            TIFFSetField(l_hTIFF, TIFFTAG_ZSTD_LEVEL, nZSTDLevel);\n#if HAVE_LERC\n        if( nCompression == COMPRESSION_LERC )\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_LERC_MAXZERROR, dfMaxZError);\n            TIFFSetField(l_hTIFF, TIFFTAG_LERC_PARAMETERS, 2,\n                         anLercAddCompressionAndVersion);\n        }\n#endif\n        if( nWebPLevel > 0 && nCompression == COMPRESSION_WEBP)\n            TIFFSetField(l_hTIFF, TIFFTAG_WEBP_LEVEL, nWebPLevel);\n        if( bWebPLossless && nCompression == COMPRESSION_WEBP)\n            TIFFSetField(l_hTIFF, TIFFTAG_WEBP_LOSSLESS, 1);\n    }\n}",
    "GDALDataset *GTiffDataset::Open( GDALOpenInfo * poOpenInfo )\n\n{\n    const char *pszFilename = poOpenInfo->pszFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Check if it looks like a TIFF file.                             */\n/* -------------------------------------------------------------------- */\n    if( !Identify(poOpenInfo) )\n        return nullptr;\n\n    bool bAllowRGBAInterface = true;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") )\n        return OpenDir( poOpenInfo );\n\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    // Disable strip chop for now.\n    bool bStreaming = false;\n    const char* pszReadStreaming =\n        CPLGetConfigOption(\"TIFF_READ_STREAMING\", nullptr);\n    if( poOpenInfo->fpL == nullptr )\n    {\n        poOpenInfo->fpL =\n            VSIFOpenL( pszFilename,\n                       poOpenInfo->eAccess == GA_ReadOnly ? \"rb\" : \"r+b\" );\n        if( poOpenInfo->fpL == nullptr )\n            return nullptr;\n    }\n    else if( !(pszReadStreaming && !CPLTestBool(pszReadStreaming)) &&\n             poOpenInfo->nHeaderBytes >= 24 &&\n             // A pipe has no seeking capability, so its position is 0 despite\n             // having read bytes.\n             (static_cast<int>( VSIFTellL(poOpenInfo->fpL) ) ==\n              poOpenInfo->nHeaderBytes ||\n              strcmp(pszFilename, \"/vsistdin/\") == 0 ||\n              // STARTS_WITH(pszFilename, \"/vsicurl_streaming/\") ||\n              (pszReadStreaming && CPLTestBool(pszReadStreaming))) )\n    {\n        bStreaming = true;\n        if( !GTIFFMakeBufferedStream(poOpenInfo) )\n            return nullptr;\n    }\n\n    // Store errors/warnings and emit them later.\n    std::vector<GTIFFErrorStruct> aoErrors;\n    CPLPushErrorHandlerEx(GTIFFErrorHandler, &aoErrors);\n    CPLSetCurrentErrorHandlerCatchDebug( FALSE );\n    // Open and disable \"strip chopping\" (c option)\n    TIFF *l_hTIFF =\n        VSI_TIFFOpen( pszFilename,\n                      poOpenInfo->eAccess == GA_ReadOnly ? \"r\" : \"r+\",\n                      poOpenInfo->fpL );\n    CPLPopErrorHandler();\n\n    // Now emit errors and change their criticality if needed\n    // We only emit failures if we didn't manage to open the file.\n    // Otherwise it makes Python bindings unhappy (#5616).\n    for( size_t iError = 0; iError < aoErrors.size(); ++iError )\n    {\n        CPLError( (l_hTIFF == nullptr && aoErrors[iError].type == CE_Failure) ?\n                  CE_Failure : CE_Warning,\n                  aoErrors[iError].no,\n                  \"%s\",\n                  aoErrors[iError].msg.c_str() );\n    }\n    aoErrors.resize(0);\n\n    if( l_hTIFF == nullptr )\n        return nullptr;\n\n    uint32 nXSize = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    uint32 nYSize = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n    if( nXSize > INT_MAX || nYSize > INT_MAX )\n    {\n        // GDAL only supports signed 32bit dimensions.\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Too large image size: %u x %u\",\n                 nXSize, nYSize);\n        XTIFFClose( l_hTIFF );\n        return nullptr;\n    }\n\n    uint16 l_nCompression = 0;\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, &(l_nCompression) ) )\n        l_nCompression = COMPRESSION_NONE;\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription( pszFilename );\n    poDS->osFilename = pszFilename;\n    poDS->poActiveDS = poDS;\n    poDS->fpL = poOpenInfo->fpL;\n    poOpenInfo->fpL = nullptr;\n    poDS->bStreamingIn = bStreaming;\n    poDS->nCompression = l_nCompression;\n\n    // In the case of GDAL_DISABLE_READDIR_ON_OPEN = NO / EMPTY_DIR\n    if( poOpenInfo->AreSiblingFilesLoaded() &&\n        CSLCount( poOpenInfo->GetSiblingFiles() ) <= 1 )\n    {\n        poDS->oOvManager.TransferSiblingFiles( CSLDuplicate(\n                                            poOpenInfo->GetSiblingFiles() ) );\n        poDS->m_bHasGotSiblingFiles = true;\n    }\n\n    if( poDS->OpenOffset( l_hTIFF, &(poDS->poActiveDS),\n                          TIFFCurrentDirOffset(l_hTIFF), true,\n                          poOpenInfo->eAccess,\n                          bAllowRGBAInterface, true) != CE_None )\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    // Do we want blocks that are set to zero and that haven't yet being\n    // allocated as tile/strip to remain implicit?\n    if( CPLFetchBool( poOpenInfo->papszOpenOptions, \"SPARSE_OK\", false ) )\n        poDS->bWriteEmptyTiles = false;\n\n    if( poOpenInfo->eAccess == GA_Update )\n    {\n        poDS->InitCreationOrOpenOptions(poOpenInfo->papszOpenOptions);\n    }\n\n    poDS->m_bLoadPam = true;\n    poDS->bColorProfileMetadataChanged = false;\n    poDS->bMetadataChanged = false;\n    poDS->bGeoTIFFInfoChanged = false;\n    poDS->bNoDataChanged = false;\n    poDS->bForceUnsetGTOrGCPs = false;\n    poDS->bForceUnsetProjection = false;\n\n/* -------------------------------------------------------------------- */\n/*      Initialize info for external overviews.                         */\n/* -------------------------------------------------------------------- */\n    poDS->oOvManager.Initialize( poDS, pszFilename );\n    if( poOpenInfo->AreSiblingFilesLoaded() )\n        poDS->oOvManager.TransferSiblingFiles(\n            poOpenInfo->StealSiblingFiles() );\n\n    // For backward compatibility, in case GTIFF_POINT_GEO_IGNORE is defined\n    // load georeferencing right now so as to not require it to be defined\n    // at the GetGeoTransform() time.\n    if( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\", nullptr) != nullptr )\n    {\n        poDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    return poDS;\n}",
    "void GTiffDataset::LoadICCProfile()\n{\n    if( bICCMetadataLoaded )\n        return;\n    bICCMetadataLoaded = true;\n\n    if( !SetDirectory() )\n        return;\n\n    uint32 nEmbedLen = 0;\n    uint8* pEmbedBuffer = nullptr;\n\n\n    if( TIFFGetField(hTIFF, TIFFTAG_ICCPROFILE, &nEmbedLen, &pEmbedBuffer) )\n    {\n        char *pszBase64Profile =\n            CPLBase64Encode(nEmbedLen, reinterpret_cast<const GByte*>(pEmbedBuffer));\n\n        oGTiffMDMD.SetMetadataItem( \"SOURCE_ICC_PROFILE\", pszBase64Profile,\n                                    \"COLOR_PROFILE\" );\n\n        CPLFree(pszBase64Profile);\n\n        return;\n    }\n\n    // Check for colorimetric tiff.\n    float* pCHR = nullptr;\n    float* pWP = nullptr;\n    uint16 *pTFR = nullptr;\n    uint16 *pTFG = nullptr;\n    uint16 *pTFB = nullptr;\n    uint16 *pTransferRange = nullptr;\n\n    if( TIFFGetField(hTIFF, TIFFTAG_PRIMARYCHROMATICITIES, &pCHR) )\n    {\n        if( TIFFGetField(hTIFF, TIFFTAG_WHITEPOINT, &pWP) )\n        {\n            if( !TIFFGetFieldDefaulted( hTIFF, TIFFTAG_TRANSFERFUNCTION, &pTFR,\n                                        &pTFG, &pTFB) )\n                return;\n\n            const int TIFFTAG_TRANSFERRANGE = 0x0156;\n            TIFFGetFieldDefaulted( hTIFF, TIFFTAG_TRANSFERRANGE,\n                                   &pTransferRange);\n\n            // Set all the colorimetric metadata.\n            oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_RED\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[0]),\n                                    static_cast<double>(pCHR[1]) ),\n                \"COLOR_PROFILE\" );\n            oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_GREEN\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[2]),\n                                    static_cast<double>(pCHR[3]) ),\n                \"COLOR_PROFILE\" );\n            oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_BLUE\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[4]),\n                                    static_cast<double>(pCHR[5]) ),\n                \"COLOR_PROFILE\" );\n\n            oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_WHITEPOINT\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pWP[0]),\n                                    static_cast<double>(pWP[1]) ),\n                \"COLOR_PROFILE\" );\n\n            // Set transfer function metadata.\n\n            // Get length of table.\n            const uint32 nTransferFunctionLength = 1 << nBitsPerSample;\n\n            oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_RED\",\n                ConvertTransferFunctionToString( pTFR, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n                ConvertTransferFunctionToString( pTFG, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n                ConvertTransferFunctionToString( pTFB, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            // Set transfer range.\n            if( pTransferRange )\n            {\n                oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_BLACK\",\n                    CPLString().Printf( \"%d, %d, %d\",\n                                        static_cast<int>(pTransferRange[0]),\n                                        static_cast<int>(pTransferRange[2]),\n                                        static_cast<int>(pTransferRange[4])),\n                    \"COLOR_PROFILE\" );\n                oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_WHITE\",\n                    CPLString().Printf( \"%d, %d, %d\",\n                                        static_cast<int>(pTransferRange[1]),\n                                        static_cast<int>(pTransferRange[3]),\n                                        static_cast<int>(pTransferRange[5])),\n                    \"COLOR_PROFILE\" );\n            }\n        }\n    }\n}",
    "CPLErr GTiffDataset::OpenOffset( TIFF *hTIFFIn,\n                                 GTiffDataset **ppoActiveDSRefIn,\n                                 toff_t nDirOffsetIn,\n                                 bool bBaseIn, GDALAccess eAccessIn,\n                                 bool bAllowRGBAInterface,\n                                 bool bReadGeoTransform )\n\n{\n    eAccess = eAccessIn;\n\n    hTIFF = hTIFFIn;\n    ppoActiveDSRef = ppoActiveDSRefIn;\n\n    nDirOffset = nDirOffsetIn;\n\n    if( !SetDirectory( nDirOffsetIn ) )\n        return CE_Failure;\n\n    bBase = bBaseIn;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some information from the file that is of interest.     */\n/* -------------------------------------------------------------------- */\n    uint32 nXSize = 0;\n    uint32 nYSize = 0;\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    if( nXSize > INT_MAX || nYSize > INT_MAX )\n    {\n        // GDAL only supports signed 32bit dimensions.\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Too large image size: %u x %u\",\n                 nXSize, nYSize);\n        return CE_Failure;\n    }\n    nRasterXSize = nXSize;\n    nRasterYSize = nYSize;\n\n    if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSamplesPerPixel ) )\n        nBands = 1;\n    else\n        nBands = nSamplesPerPixel;\n\n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &(nBitsPerSample)) )\n        nBitsPerSample = 1;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &(nPlanarConfig) ) )\n        nPlanarConfig = PLANARCONFIG_CONTIG;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLEFORMAT, &(nSampleFormat) ) )\n        nSampleFormat = SAMPLEFORMAT_UINT;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n\n#if defined(TIFFLIB_VERSION) && TIFFLIB_VERSION > 20031007 // 3.6.0\n    if( nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(nCompression) )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Cannot open TIFF file due to missing codec.\" );\n        return CE_Failure;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( nCompression == COMPRESSION_JPEG\n        && nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\") ) )\n    {\n        oGTiffMDMD.SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\",\n                                    \"IMAGE_STRUCTURE\" );\n        int nColorMode = 0;\n        if( !TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n            nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get strip/tile layout.                                          */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled(hTIFF) )\n    {\n        uint32 l_nBlockXSize = 0;\n        uint32 l_nBlockYSize = 0;\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(l_nBlockXSize) );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(l_nBlockYSize) );\n        if( l_nBlockXSize > INT_MAX || l_nBlockYSize > INT_MAX )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Too large block size: %u x %u\",\n                     l_nBlockXSize, l_nBlockYSize);\n            return CE_Failure;\n        }\n        nBlockXSize = static_cast<int>(l_nBlockXSize);\n        nBlockYSize = static_cast<int>(l_nBlockYSize);\n    }\n    else\n    {\n        if( !TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(nRowsPerStrip) ) )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined,\n                      \"RowsPerStrip not defined ... assuming all one strip.\" );\n            nRowsPerStrip = nYSize;  // Dummy value.\n        }\n\n        // If the rows per strip is larger than the file we will get\n        // confused.  libtiff internally will treat the rowsperstrip as\n        // the image height and it is best if we do too. (#4468)\n        if( nRowsPerStrip > static_cast<uint32>(nRasterYSize) )\n            nRowsPerStrip = nRasterYSize;\n\n        nBlockXSize = nRasterXSize;\n        nBlockYSize = nRowsPerStrip;\n    }\n\n    const int l_nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, nBlockYSize);\n    const int l_nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    if( l_nBlocksPerColumn > INT_MAX / l_nBlocksPerRow )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Too many blocks: %d x %d\",\n                  l_nBlocksPerRow, l_nBlocksPerColumn );\n        return CE_Failure;\n    }\n\n    // Note: we could potentially go up to UINT_MAX blocks, but currently\n    // we use a int nBlockId\n    nBlocksPerBand = l_nBlocksPerColumn * l_nBlocksPerRow;\n    if( nPlanarConfig == PLANARCONFIG_SEPARATE &&\n        nBlocksPerBand > INT_MAX / nBands )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Too many blocks: %d x %d x %d bands\",\n                  l_nBlocksPerRow, l_nBlocksPerColumn, nBands );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we handle this using the GTiffBitmapBand?                */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsBitmap = false;\n\n    if( nBitsPerSample == 1 && nBands == 1 )\n    {\n        bTreatAsBitmap = true;\n\n        // Lets treat large \"one row\" bitmaps using the scanline api.\n        if( !TIFFIsTiled(hTIFF)\n            && nBlockYSize == nRasterYSize\n            && nRasterYSize > 2000\n            // libtiff does not support reading JBIG files with\n            // TIFFReadScanline().\n            && nCompression != COMPRESSION_JBIG )\n        {\n            bTreatAsSplitBitmap = true;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the RGBA interface?                    */\n/* -------------------------------------------------------------------- */\n    if(\n#ifdef DEBUG\n        CPLTestBool(CPLGetConfigOption(\"GTIFF_FORCE_RGBA\", \"NO\")) ||\n#endif\n        (bAllowRGBAInterface &&\n        !bTreatAsBitmap && !(nBitsPerSample > 8)\n        && (nPhotometric == PHOTOMETRIC_CIELAB ||\n            nPhotometric == PHOTOMETRIC_LOGL ||\n            nPhotometric == PHOTOMETRIC_LOGLUV ||\n            nPhotometric == PHOTOMETRIC_SEPARATED ||\n            ( nPhotometric == PHOTOMETRIC_YCBCR\n              && nCompression != COMPRESSION_JPEG ))) )\n    {\n        char szMessage[1024] = {};\n\n        if( TIFFRGBAImageOK( hTIFF, szMessage ) == 1 )\n        {\n            const char* pszSourceColorSpace = nullptr;\n            nBands = 4;\n            switch( nPhotometric )\n            {\n                case PHOTOMETRIC_CIELAB:\n                    pszSourceColorSpace = \"CIELAB\";\n                    break;\n                case PHOTOMETRIC_LOGL:\n                    pszSourceColorSpace = \"LOGL\";\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    pszSourceColorSpace = \"LOGLUV\";\n                    break;\n                case PHOTOMETRIC_SEPARATED:\n                    pszSourceColorSpace = \"CMYK\";\n                    break;\n                case PHOTOMETRIC_YCBCR:\n                    pszSourceColorSpace = \"YCbCr\";\n                    nBands = 3; // probably true for other photometric values\n                    break;\n            }\n            if( pszSourceColorSpace )\n                oGTiffMDMD.SetMetadataItem( \"SOURCE_COLOR_SPACE\",\n                                            pszSourceColorSpace,\n                                            \"IMAGE_STRUCTURE\" );\n            bTreatAsRGBA = true;\n\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"TIFFRGBAImageOK says:\\n%s\", szMessage );\n        }\n    }\n\n    // libtiff has various issues with OJPEG compression and chunky-strip\n    // support with the \"classic\" scanline/strip/tile interfaces, and that\n    // wouldn't work either, so better bail out.\n    if( nCompression == COMPRESSION_OJPEG &&\n        !bTreatAsRGBA )\n    {\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Old-JPEG compression only supported through RGBA interface, \"\n                 \"which cannot be used probably because the file is corrupted\");\n        return CE_Failure;\n    }\n\n    // If photometric is YCbCr, scanline/strip/tile interfaces assumes that\n    // we are ready with downsampled data. And we are not.\n    if( nCompression != COMPRESSION_JPEG &&\n        nCompression != COMPRESSION_OJPEG &&\n        nPhotometric == PHOTOMETRIC_YCBCR &&\n        nPlanarConfig == PLANARCONFIG_CONTIG &&\n        !bTreatAsRGBA )\n    {\n        uint16 nF1, nF2;\n        TIFFGetFieldDefaulted(hTIFF,TIFFTAG_YCBCRSUBSAMPLING,&nF1,&nF2);\n        if( nF1 != 1 || nF2 != 1 )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"Cannot open TIFF file with YCbCr, subsampling and \"\n                      \"BitsPerSample > 8 that is not JPEG compressed\" );\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the split interface?                   */\n/* -------------------------------------------------------------------- */\n    if( !TIFFIsTiled(hTIFF)\n        && nBitsPerSample == 8\n        && nBlockYSize == nRasterYSize\n        && nRasterYSize > 2000\n        && !bTreatAsRGBA\n        && CPLTestBool(CPLGetConfigOption(\"GDAL_ENABLE_TIFF_SPLIT\", \"YES\")) )\n    {\n        // libtiff 3.9.2 (20091104) and older, libtiff 4.0.0beta5 (also\n        // 20091104) and older will crash when trying to open a\n        // all-in-one-strip YCbCr JPEG compressed TIFF (see #3259).\n#if (TIFFLIB_VERSION <= 20091104 && !defined(BIGTIFF_SUPPORT)) || \\\n    (TIFFLIB_VERSION <= 20091104 && defined(BIGTIFF_SUPPORT))\n        if( nPhotometric == PHOTOMETRIC_YCBCR &&\n            nCompression == COMPRESSION_JPEG )\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"Avoid using split band to open all-in-one-strip \"\n                \"YCbCr JPEG compressed TIFF because of older libtiff\" );\n        }\n        else\n#endif\n        {\n            bTreatAsSplit = true;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the odd bits interface?                */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsOdd = false;\n    if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n    {\n        if( nBitsPerSample == 16 || nBitsPerSample == 24 )\n            bTreatAsOdd = true;\n    }\n    else if( !bTreatAsRGBA && !bTreatAsBitmap\n             && nBitsPerSample != 8\n             && nBitsPerSample != 16\n             && nBitsPerSample != 32\n             && nBitsPerSample != 64\n             && nBitsPerSample != 128 )\n    {\n        bTreatAsOdd = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We don't support 'chunks' bigger than 2GB although libtiff v4   */\n/*      can.                                                            */\n/* -------------------------------------------------------------------- */\n#if defined(BIGTIFF_SUPPORT)\n    uint64 nChunkSize = 0;\n    if( bTreatAsSplit || bTreatAsSplitBitmap )\n    {\n        nChunkSize = TIFFScanlineSize64( hTIFF );\n    }\n    else\n    {\n        if( TIFFIsTiled(hTIFF) )\n            nChunkSize = TIFFTileSize64( hTIFF );\n        else\n            nChunkSize = TIFFStripSize64( hTIFF );\n    }\n    if( bTreatAsRGBA )\n    {\n        nChunkSize = std::max(nChunkSize,\n                        4 * static_cast<uint64>(nBlockXSize) * nBlockYSize);\n    }\n    if( nChunkSize > static_cast<uint64>(INT_MAX) )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Scanline/tile/strip size bigger than 2GB.\" );\n        return CE_Failure;\n    }\n#endif\n\n    const bool bMinIsWhite = nPhotometric == PHOTOMETRIC_MINISWHITE;\n\n/* -------------------------------------------------------------------- */\n/*      Check for NODATA                                                */\n/* -------------------------------------------------------------------- */\n    char *pszText = nullptr;\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_NODATA, &pszText ) &&\n        !EQUAL(pszText, \"\") )\n    {\n        bNoDataSet = true;\n        dfNoDataValue = CPLAtofM( pszText );\n        if( nBitsPerSample == 32 && nSampleFormat == SAMPLEFORMAT_IEEEFP )\n        {\n            dfNoDataValue = GDALAdjustNoDataCloseToFloatMax(dfNoDataValue);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture the color table if there is one.                        */\n/* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( bTreatAsRGBA || nBitsPerSample > 16\n        || TIFFGetField( hTIFF, TIFFTAG_COLORMAP,\n                         &panRed, &panGreen, &panBlue) == 0 )\n    {\n        // Build inverted palette if we have inverted photometric.\n        // Pixel values remains unchanged.  Avoid doing this for *deep*\n        // data types (per #1882)\n        if( nBitsPerSample <= 16 && nPhotometric == PHOTOMETRIC_MINISWHITE )\n        {\n            poColorTable = new GDALColorTable();\n            const int nColorCount = 1 << nBitsPerSample;\n\n            for( int iColor = 0; iColor < nColorCount; ++iColor )\n            {\n                const short nValue =\n                    static_cast<short>(((255 * (nColorCount - 1 - iColor)) /\n                                        (nColorCount - 1)));\n                const GDALColorEntry oEntry =\n                    { nValue, nValue, nValue, static_cast<short>(255) };\n                poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n\n            nPhotometric = PHOTOMETRIC_PALETTE;\n        }\n        else\n        {\n            poColorTable = nullptr;\n        }\n    }\n    else\n    {\n        unsigned short nMaxColor = 0;\n\n        poColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 << nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            // TODO(schwehr): Ensure the color entries are never negative?\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast<short>(panRed[iColor] / divisor),\n                static_cast<short>(panGreen[iColor] / divisor),\n                static_cast<short>(panBlue[iColor] / divisor),\n                static_cast<short>(\n                    bNoDataSet && static_cast<int>(dfNoDataValue) == iColor\n                    ? 0\n                    : 255)\n            };\n\n            poColorTable->SetColorEntry( iColor, &oEntry );\n\n            nMaxColor = std::max(nMaxColor, panRed[iColor]);\n            nMaxColor = std::max(nMaxColor, panGreen[iColor]);\n            nMaxColor = std::max(nMaxColor, panBlue[iColor]);\n        }\n\n        // Bug 1384 - Some TIFF files are generated with color map entry\n        // values in range 0-255 instead of 0-65535 - try to handle these\n        // gracefully.\n        if( nMaxColor > 0 && nMaxColor < 256 )\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"TIFF ColorTable seems to be improperly scaled, fixing up.\" );\n\n            for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n            {\n                // TODO(schwehr): Ensure the color entries are never negative?\n                const GDALColorEntry oEntry = {\n                    static_cast<short>(panRed[iColor]),\n                    static_cast<short>(panGreen[iColor]),\n                    static_cast<short>(panBlue[iColor]),\n                    bNoDataSet &&\n                    static_cast<int>(dfNoDataValue) == iColor\n                    ? static_cast<short>(0)\n                    : static_cast<short>(255)\n                };\n\n                poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < nBands; ++iBand )\n    {\n        if( bTreatAsRGBA )\n            SetBand( iBand + 1, new GTiffRGBABand( this, iBand + 1 ) );\n        else if( bTreatAsSplitBitmap )\n            SetBand( iBand + 1, new GTiffSplitBitmapBand( this, iBand + 1 ) );\n        else if( bTreatAsSplit )\n            SetBand( iBand + 1, new GTiffSplitBand( this, iBand + 1 ) );\n        else if( bTreatAsBitmap )\n            SetBand( iBand + 1, new GTiffBitmapBand( this, iBand + 1 ) );\n        else if( bTreatAsOdd )\n            SetBand( iBand + 1, new GTiffOddBitsBand( this, iBand + 1 ) );\n        else\n            SetBand( iBand + 1, new GTiffRasterBand( this, iBand + 1 ) );\n    }\n\n    if( GetRasterBand(1)->GetRasterDataType() == GDT_Unknown )\n    {\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Unsupported TIFF configuration: BitsPerSample(=%d) and \"\n                 \"SampleType(=%d)\",\n                 nBitsPerSample,\n                 nSampleFormat);\n        return CE_Failure;\n    }\n\n    m_bReadGeoTransform = bReadGeoTransform;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some other potentially interesting information.         */\n/* -------------------------------------------------------------------- */\n    char szWorkMDI[200] = {};\n    uint16 nShort = 0;\n\n    for( size_t iTag = 0;\n         iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n         ++iTag )\n    {\n        if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n        {\n            if( TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &pszText ) )\n                oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            pszText );\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT )\n        {\n            float fVal = 0.0;\n            if( TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &fVal ) )\n            {\n                CPLsnprintf( szWorkMDI, sizeof(szWorkMDI), \"%.8g\", fVal );\n                oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            szWorkMDI );\n            }\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT &&\n                 asTIFFTags[iTag].nTagVal != TIFFTAG_RESOLUTIONUNIT )\n        {\n            if( TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &nShort ) )\n            {\n                snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort );\n                oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            szWorkMDI );\n            }\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING )\n        {\n            uint32 nCount = 0;\n            if( TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                              &nCount, &pszText ) )\n            {\n                std::string osStr;\n                osStr.assign(pszText, nCount);\n                oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            osStr.c_str() );\n            }\n        }\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, &nShort ) )\n    {\n        if( nShort == RESUNIT_NONE )\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d (unitless)\", nShort );\n        else if( nShort == RESUNIT_INCH )\n            snprintf( szWorkMDI, sizeof(szWorkMDI),\n                      \"%d (pixels/inch)\", nShort );\n        else if( nShort == RESUNIT_CENTIMETER )\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d (pixels/cm)\", nShort );\n        else\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort );\n        oGTiffMDMD.SetMetadataItem( \"TIFFTAG_RESOLUTIONUNIT\", szWorkMDI );\n    }\n\n    int nTagSize = 0;\n    void* pData = nullptr;\n    if( TIFFGetField( hTIFF, TIFFTAG_XMLPACKET, &nTagSize, &pData ) )\n    {\n        char* pszXMP =\n            static_cast<char *>( VSI_MALLOC_VERBOSE(nTagSize + 1) );\n        if( pszXMP )\n        {\n            memcpy(pszXMP, pData, nTagSize);\n            pszXMP[nTagSize] = '\\0';\n\n            char *apszMDList[2] = { pszXMP, nullptr };\n            oGTiffMDMD.SetMetadata(apszMDList, \"xml:XMP\");\n\n            CPLFree(pszXMP);\n        }\n    }\n\n    if( nCompression == COMPRESSION_NONE )\n        /* no compression tag */;\n    else if( nCompression == COMPRESSION_CCITTRLE )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTRLE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_CCITTFAX3 )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTFAX3\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_CCITTFAX4 )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTFAX4\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_LZW )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LZW\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_OJPEG )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"OJPEG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_JPEG )\n    {\n        if( nPhotometric == PHOTOMETRIC_YCBCR )\n            oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\",\n                                        \"IMAGE_STRUCTURE\" );\n        else\n            oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JPEG\",\n                                        \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_NEXT )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"NEXT\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_CCITTRLEW )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTRLEW\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_PACKBITS )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PACKBITS\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_THUNDERSCAN )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"THUNDERSCAN\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_PIXARFILM )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PIXARFILM\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_PIXARLOG )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PIXARLOG\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_DEFLATE )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DEFLATE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_ADOBE_DEFLATE )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DEFLATE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_DCS )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DCS\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_JBIG )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JBIG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_SGILOG )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"SGILOG\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_SGILOG24 )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"SGILOG24\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_JP2000 )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JP2000\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_LZMA )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LZMA\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_ZSTD )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"ZSTD\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_LERC )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC\", \"IMAGE_STRUCTURE\" );\n#if HAVE_LERC\n        uint32 nLercParamCount = 0;\n        uint32* panLercParms = nullptr;\n        if( TIFFGetField( hTIFF, TIFFTAG_LERC_PARAMETERS, &nLercParamCount,\n                          &panLercParms ) &&\n            nLercParamCount == 2 )\n        {\n            memcpy( anLercAddCompressionAndVersion, panLercParms,\n                    sizeof(anLercAddCompressionAndVersion) );\n        }\n\n        uint32 nAddVersion = LERC_ADD_COMPRESSION_NONE;\n        if( TIFFGetField( hTIFF, TIFFTAG_LERC_ADD_COMPRESSION, &nAddVersion ) &&\n            nAddVersion != LERC_ADD_COMPRESSION_NONE )\n        {\n            if( nAddVersion == LERC_ADD_COMPRESSION_DEFLATE )\n            {\n                oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC_DEFLATE\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n            else if( nAddVersion == LERC_ADD_COMPRESSION_ZSTD )\n            {\n                oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC_ZSTD\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n        }\n        uint32 nLercVersion = LERC_VERSION_2_4;\n        if( TIFFGetField( hTIFF, TIFFTAG_LERC_VERSION, &nLercVersion) )\n        {\n            if( nLercVersion == LERC_VERSION_2_4 )\n            {\n                oGTiffMDMD.SetMetadataItem( \"LERC_VERSION\", \"2.4\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n            else\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"Unknown Lerc version: %d\", nLercVersion);\n            }\n        }\n#endif\n    }\n    else if( nCompression == COMPRESSION_WEBP )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"WEBP\", \"IMAGE_STRUCTURE\" );\n    }\n    else\n    {\n        CPLString oComp;\n        oComp.Printf( \"%d\", nCompression);\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", oComp.c_str());\n    }\n\n    if( nPlanarConfig == PLANARCONFIG_CONTIG && nBands != 1 )\n        oGTiffMDMD.SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        oGTiffMDMD.SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    if( (GetRasterBand(1)->GetRasterDataType() == GDT_Byte &&\n         nBitsPerSample != 8 ) ||\n        (GetRasterBand(1)->GetRasterDataType() == GDT_UInt16 &&\n         nBitsPerSample != 16) ||\n        ((GetRasterBand(1)->GetRasterDataType() == GDT_UInt32 ||\n          GetRasterBand(1)->GetRasterDataType() == GDT_Float32) &&\n         nBitsPerSample != 32) )\n    {\n        for( int i = 0; i < nBands; ++i )\n            cpl::down_cast<GTiffRasterBand*>(GetRasterBand(i + 1))->\n                oGTiffMDMD.SetMetadataItem(\n                    \"NBITS\",\n                    CPLString().Printf(\n                        \"%d\", static_cast<int>(nBitsPerSample) ),\n                    \"IMAGE_STRUCTURE\" );\n    }\n\n    if( bMinIsWhite )\n        oGTiffMDMD.SetMetadataItem( \"MINISWHITE\", \"YES\", \"IMAGE_STRUCTURE\" );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n    {\n        CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n        CPLXMLNode *psItem = nullptr;\n\n        if( psRoot != nullptr && psRoot->eType == CXT_Element\n            && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n            psItem = psRoot->psChild;\n\n        for( ; psItem != nullptr; psItem = psItem->psNext )\n        {\n\n            if( psItem->eType != CXT_Element\n                || !EQUAL(psItem->pszValue,\"Item\") )\n                continue;\n\n            const char *pszKey = CPLGetXMLValue( psItem, \"name\", nullptr );\n            const char *pszValue = CPLGetXMLValue( psItem, nullptr, nullptr );\n            int nBand =\n                atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" ));\n            if( nBand < -1 || nBand > 65535 )\n                continue;\n            nBand ++;\n            const char *pszRole = CPLGetXMLValue( psItem, \"role\", \"\" );\n            const char *pszDomain = CPLGetXMLValue( psItem, \"domain\", \"\" );\n\n            if( pszKey == nullptr || pszValue == nullptr )\n                continue;\n            if( EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n                continue;\n\n            bool bIsXML = false;\n\n            if( STARTS_WITH_CI(pszDomain, \"xml:\") )\n                bIsXML = TRUE;\n\n            char *pszUnescapedValue =\n                CPLUnescapeString( pszValue, nullptr, CPLES_XML );\n            if( nBand == 0 )\n            {\n                if( bIsXML )\n                {\n                    char *apszMD[2] = { pszUnescapedValue, nullptr };\n                    oGTiffMDMD.SetMetadata( apszMD, pszDomain );\n                }\n                else\n                {\n                    oGTiffMDMD.SetMetadataItem( pszKey, pszUnescapedValue,\n                                                pszDomain );\n                }\n            }\n            else\n            {\n                GTiffRasterBand *poBand =\n                    cpl::down_cast<GTiffRasterBand*>(GetRasterBand(nBand));\n                if( poBand != nullptr )\n                {\n                    if( EQUAL(pszRole,\"scale\") )\n                    {\n                        poBand->bHaveOffsetScale = true;\n                        poBand->dfScale = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if( EQUAL(pszRole,\"offset\") )\n                    {\n                        poBand->bHaveOffsetScale = true;\n                        poBand->dfOffset = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if( EQUAL(pszRole,\"unittype\") )\n                    {\n                        poBand->osUnitType = pszUnescapedValue;\n                    }\n                    else if( EQUAL(pszRole,\"description\") )\n                    {\n                        poBand->osDescription = pszUnescapedValue;\n                    }\n                    else if( EQUAL(pszRole, \"colorinterp\") )\n                    {\n                        poBand->eBandInterp =\n                            GDALGetColorInterpretationByName(pszUnescapedValue);\n                    }\n                    else\n                    {\n                        if( bIsXML )\n                        {\n                            char *apszMD[2] = { pszUnescapedValue, nullptr };\n                            poBand->oGTiffMDMD.SetMetadata( apszMD, pszDomain );\n                        }\n                        else\n                        {\n                            poBand->oGTiffMDMD.SetMetadataItem(\n                                pszKey,\n                                pszUnescapedValue,\n                                pszDomain );\n                        }\n                    }\n                }\n            }\n            CPLFree( pszUnescapedValue );\n        }\n\n        CPLDestroyXMLNode( psRoot );\n    }\n\n    if( bStreamingIn )\n    {\n        toff_t* panOffsets = nullptr;\n        TIFFGetField( hTIFF,\n                      TIFFIsTiled( hTIFF ) ?\n                      TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                      &panOffsets );\n        if( panOffsets )\n        {\n            int nBlockCount =\n                TIFFIsTiled(hTIFF) ?\n                TIFFNumberOfTiles(hTIFF) : TIFFNumberOfStrips(hTIFF);\n            for( int i = 1; i < nBlockCount; ++i )\n            {\n                if( panOffsets[i] < panOffsets[i-1] )\n                {\n                    oGTiffMDMD.SetMetadataItem( \"UNORDERED_BLOCKS\", \"YES\",\n                                                \"TIFF\");\n                    CPLDebug(\n                        \"GTIFF\",\n                        \"Offset of block %d is lower than previous block. \"\n                        \"Reader must be careful\",\n                        i );\n                    break;\n                }\n            }\n        }\n    }\n\n    if( nCompression == COMPRESSION_JPEG && eAccess == GA_Update )\n    {\n        SetJPEGQualityAndTablesModeFromFile();\n    }\n\n    CPLAssert(m_bReadGeoTransform == bReadGeoTransform);\n    CPLAssert(!bMetadataChanged);\n    bMetadataChanged = false;\n\n    return CE_None;\n}",
    "void GTiffDataset::LoadGeoreferencingAndPamIfNeeded()\n\n{\n    if( !m_bReadGeoTransform && !m_bLoadPam )\n        return;\n\n    IdentifyAuthorizedGeoreferencingSources();\n\n/* -------------------------------------------------------------------- */\n/*      Get the transform or gcps from the GeoTIFF file.                */\n/* -------------------------------------------------------------------- */\n    if( m_bReadGeoTransform )\n    {\n        m_bReadGeoTransform = false;\n\n        if( !SetDirectory() )\n            return;\n\n        char *pszTabWKT = nullptr;\n        double *padfTiePoints = nullptr;\n        double *padfScale = nullptr;\n        double *padfMatrix = nullptr;\n        uint16 nCount = 0;\n        bool bPixelIsPoint = false;\n        short nRasterType = 0;\n        bool bPointGeoIgnore = false;\n\n        std::set<int> aoSetPriorities;\n        if( m_nINTERNALGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nINTERNALGeorefSrcIndex);\n        if( m_nTABFILEGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nTABFILEGeorefSrcIndex);\n        if( m_nWORLDFILEGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nWORLDFILEGeorefSrcIndex);\n        std::set<int>::iterator oIter = aoSetPriorities.begin();\n        for( ; oIter != aoSetPriorities.end(); ++oIter )\n        {\n            int nIndex = *oIter;\n            if( m_nINTERNALGeorefSrcIndex == nIndex )\n            {\n                GTIF *psGTIF = GTiffDatasetGTIFNew( hTIFF );  // How expensive this is?\n\n                if( psGTIF )\n                {\n                    if( GDALGTIFKeyGetSHORT(psGTIF, GTRasterTypeGeoKey,\n                                            &nRasterType, 0, 1 ) == 1\n                        && nRasterType ==\n                           static_cast<short>(RasterPixelIsPoint) )\n                    {\n                        bPixelIsPoint = true;\n                        bPointGeoIgnore =\n                            CPLTestBool(\n                                CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                                   \"FALSE\") );\n                    }\n\n                    GTIFFree( psGTIF );\n                }\n\n                adfGeoTransform[0] = 0.0;\n                adfGeoTransform[1] = 1.0;\n                adfGeoTransform[2] = 0.0;\n                adfGeoTransform[3] = 0.0;\n                adfGeoTransform[4] = 0.0;\n                adfGeoTransform[5] = 1.0;\n\n                uint16 nCountScale = 0;\n                if( TIFFGetField(hTIFF, TIFFTAG_GEOPIXELSCALE,\n                                 &nCountScale, &padfScale )\n                    && nCountScale >= 2\n                    && padfScale[0] != 0.0 && padfScale[1] != 0.0 )\n                {\n                    adfGeoTransform[1] = padfScale[0];\n                    if( padfScale[1] < 0 )\n                    {\n                        const char* pszOptionVal =\n                            CPLGetConfigOption(\"GTIFF_HONOUR_NEGATIVE_SCALEY\",\n                                               nullptr);\n                        if( pszOptionVal == nullptr )\n                        {\n                            CPLError(CE_Warning, CPLE_AppDefined,\n                                \"File with negative value for ScaleY in \"\n                                \"GeoPixelScale tag. This is rather \"\n                                \"unusual. GDAL, contrary to the GeoTIFF \"\n                                \"specification, assumes that the file \"\n                                \"was intended to be north-up, and will \"\n                                \"treat this file as if ScaleY was \"\n                                \"positive. You may override this behaviour \"\n                                \"by setting the GTIFF_HONOUR_NEGATIVE_SCALEY \"\n                                \"configuration option to YES\");\n                            adfGeoTransform[5] = padfScale[1];\n                        }\n                        else if( CPLTestBool(pszOptionVal) )\n                        {\n                            adfGeoTransform[5] = -padfScale[1];\n                        }\n                        else\n                        {\n                            adfGeoTransform[5] = padfScale[1];\n                        }\n                    }\n                    else\n                    {\n                        adfGeoTransform[5] = -padfScale[1];\n                    }\n\n                    if( TIFFGetField(hTIFF, TIFFTAG_GEOTIEPOINTS,\n                                     &nCount, &padfTiePoints )\n                        && nCount >= 6 )\n                    {\n                        adfGeoTransform[0] =\n                            padfTiePoints[3] -\n                            padfTiePoints[0] * adfGeoTransform[1];\n                        adfGeoTransform[3] =\n                            padfTiePoints[4] -\n                            padfTiePoints[1] * adfGeoTransform[5];\n\n                        if( bPixelIsPoint && !bPointGeoIgnore )\n                        {\n                            adfGeoTransform[0] -=\n                                (adfGeoTransform[1] * 0.5 +\n                                 adfGeoTransform[2] * 0.5);\n                            adfGeoTransform[3] -=\n                                (adfGeoTransform[4] * 0.5 +\n                                 adfGeoTransform[5] * 0.5);\n                        }\n\n                        bGeoTransformValid = true;\n                        m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                        if( nCountScale >= 3 && GetRasterCount() == 1 &&\n                            (padfScale[2] != 0.0 ||\n                             padfTiePoints[2] != 0.0 ||\n                             padfTiePoints[5] != 0.0) )\n                        {\n                            LookForProjection();\n                            if( pszProjection && HasVerticalCS(pszProjection) )\n                            {\n                                /* modelTiePointTag = (pixel, line, z0, X, Y, Z0) */\n                                /* thus Z(some_point) = (z(some_point) - z0) * scaleZ + Z0 */\n                                /* equivalently written as */\n                                /* Z(some_point) = z(some_point) * scaleZ + offsetZ with */\n                                /* offsetZ = - z0 * scaleZ + Z0 */\n                                double dfScale = padfScale[2];\n                                double dfOffset =\n                                    -padfTiePoints[2] * dfScale + padfTiePoints[5];\n                                GTiffRasterBand* poBand =\n                                    cpl::down_cast<GTiffRasterBand*>(GetRasterBand(1));\n                                poBand->bHaveOffsetScale = true;\n                                poBand->dfScale = dfScale;\n                                poBand->dfOffset = dfOffset;\n                            }\n                        }\n                    }\n                }\n\n                else if( TIFFGetField(hTIFF, TIFFTAG_GEOTRANSMATRIX,\n                                      &nCount, &padfMatrix )\n                        && nCount == 16 )\n                {\n                    adfGeoTransform[0] = padfMatrix[3];\n                    adfGeoTransform[1] = padfMatrix[0];\n                    adfGeoTransform[2] = padfMatrix[1];\n                    adfGeoTransform[3] = padfMatrix[7];\n                    adfGeoTransform[4] = padfMatrix[4];\n                    adfGeoTransform[5] = padfMatrix[5];\n\n                    if( bPixelIsPoint && !bPointGeoIgnore )\n                    {\n                        adfGeoTransform[0] -=\n                            adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                        adfGeoTransform[3] -=\n                            adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n                    }\n\n                    bGeoTransformValid = true;\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                }\n                if( bGeoTransformValid )\n                    break;\n            }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise try looking for a .tab, .tfw, .tifw or .wld file.     */\n/* -------------------------------------------------------------------- */\n            if( m_nTABFILEGeorefSrcIndex == nIndex )\n            {\n                char* pszGeorefFilename = nullptr;\n\n                char** papszSiblingFiles = GetSiblingFiles();\n\n                // Begin with .tab since it can also have projection info.\n                const int bTabFileOK =\n                    GDALReadTabFile2( osFilename, adfGeoTransform,\n                                        &pszTabWKT, &nGCPCount, &pasGCPList,\n                                        papszSiblingFiles, &pszGeorefFilename );\n\n                if( bTabFileOK )\n                {\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                    // if( pszTabWKT )\n                    // {\n                    //     m_nProjectionGeorefSrcIndex = nIndex;\n                    // }\n                    if( nGCPCount == 0 )\n                    {\n                        bGeoTransformValid = true;\n                    }\n                }\n\n                if( pszGeorefFilename )\n                {\n                    osGeorefFilename = pszGeorefFilename;\n                    CPLFree(pszGeorefFilename);\n                }\n                if( bGeoTransformValid )\n                    break;\n            }\n\n            if( m_nWORLDFILEGeorefSrcIndex == nIndex )\n            {\n                char* pszGeorefFilename = nullptr;\n\n                char** papszSiblingFiles = GetSiblingFiles();\n\n                bGeoTransformValid = CPL_TO_BOOL( GDALReadWorldFile2(\n                                osFilename, nullptr, adfGeoTransform,\n                                papszSiblingFiles, &pszGeorefFilename) );\n\n                if( !bGeoTransformValid )\n                {\n                    bGeoTransformValid =\n                        CPL_TO_BOOL( GDALReadWorldFile2(\n                            osFilename, \"wld\", adfGeoTransform,\n                            papszSiblingFiles, &pszGeorefFilename ) );\n                }\n                if( bGeoTransformValid )\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                if( pszGeorefFilename )\n                {\n                    osGeorefFilename = pszGeorefFilename;\n                    CPLFree(pszGeorefFilename);\n                }\n                if( bGeoTransformValid )\n                    break;\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Check for GCPs.                                                 */\n/* -------------------------------------------------------------------- */\n        if( m_nINTERNALGeorefSrcIndex >= 0 &&\n            TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && !bGeoTransformValid )\n        {\n            if( nGCPCount > 0 )\n            {\n                GDALDeinitGCPs( nGCPCount, pasGCPList );\n                CPLFree( pasGCPList );\n            }\n            nGCPCount = nCount / 6;\n            pasGCPList =\n                static_cast<GDAL_GCP *>(CPLCalloc(sizeof(GDAL_GCP), nGCPCount));\n\n            for( int iGCP = 0; iGCP < nGCPCount; ++iGCP )\n            {\n                char szID[32] = {};\n\n                snprintf( szID, sizeof(szID), \"%d\", iGCP + 1 );\n                pasGCPList[iGCP].pszId = CPLStrdup( szID );\n                pasGCPList[iGCP].pszInfo = CPLStrdup(\"\");\n                pasGCPList[iGCP].dfGCPPixel = padfTiePoints[iGCP*6+0];\n                pasGCPList[iGCP].dfGCPLine = padfTiePoints[iGCP*6+1];\n                pasGCPList[iGCP].dfGCPX = padfTiePoints[iGCP*6+3];\n                pasGCPList[iGCP].dfGCPY = padfTiePoints[iGCP*6+4];\n                pasGCPList[iGCP].dfGCPZ = padfTiePoints[iGCP*6+5];\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    pasGCPList[iGCP].dfGCPPixel -= 0.5;\n                    pasGCPList[iGCP].dfGCPLine -= 0.5;\n                }\n            }\n            m_nGeoTransformGeorefSrcIndex = m_nINTERNALGeorefSrcIndex;\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Did we find a tab file?  If so we will use its coordinate       */\n/*      system and give it precedence.                                  */\n/* -------------------------------------------------------------------- */\n        if( pszTabWKT != nullptr\n            && (pszProjection == nullptr || pszProjection[0] == '\\0') )\n        {\n            CPLFree( pszProjection );\n            pszProjection = pszTabWKT;\n            pszTabWKT = nullptr;\n            bLookedForProjection = true;\n        }\n\n        CPLFree( pszTabWKT );\n    }\n\n    if( m_bLoadPam && m_nPAMGeorefSrcIndex >= 0 )\n    {\n/* -------------------------------------------------------------------- */\n/*      Initialize any PAM information.                                 */\n/* -------------------------------------------------------------------- */\n        CPLAssert(!bColorProfileMetadataChanged);\n        CPLAssert(!bMetadataChanged);\n        CPLAssert(!bGeoTIFFInfoChanged);\n        CPLAssert(!bNoDataChanged);\n\n        // We must absolutely unset m_bLoadPam now, otherwise calling\n        // GetFileList() on a .tif with a .aux will result in an (almost)\n        // endless sequence of calls.\n        m_bLoadPam = false;\n\n        TryLoadXML( GetSiblingFiles() );\n        ApplyPamInfo();\n\n        bColorProfileMetadataChanged = false;\n        bMetadataChanged = false;\n        bGeoTIFFInfoChanged = false;\n        bNoDataChanged = false;\n\n        for( int i = 1; i <= nBands; ++i )\n        {\n            GTiffRasterBand* poBand =\n                cpl::down_cast<GTiffRasterBand *>(GetRasterBand(i));\n\n            /* Load scale, offset and unittype from PAM if available */\n            if( !poBand->bHaveOffsetScale )\n            {\n                int nHaveOffsetScale = FALSE;\n                poBand->dfScale =\n                    poBand->GDALPamRasterBand::GetScale( &nHaveOffsetScale );\n                poBand->bHaveOffsetScale = CPL_TO_BOOL(nHaveOffsetScale);\n                poBand->dfOffset = poBand->GDALPamRasterBand::GetOffset();\n            }\n            if( poBand->osUnitType.empty() )\n            {\n                const char* pszUnitType =\n                    poBand->GDALPamRasterBand::GetUnitType();\n                if( pszUnitType )\n                    poBand->osUnitType = pszUnitType;\n            }\n            if( poBand->osDescription.empty() )\n                poBand->osDescription =\n                    poBand->GDALPamRasterBand::GetDescription();\n\n            GDALColorInterp ePAMColorInterp =\n                poBand->GDALPamRasterBand::GetColorInterpretation();\n            if( ePAMColorInterp != GCI_Undefined )\n                poBand->eBandInterp = ePAMColorInterp;\n        }\n    }\n    m_bLoadPam = false;\n}",
    "void GTiffDataset::ScanDirectories()\n\n{\n/* -------------------------------------------------------------------- */\n/*      We only scan once.  We do not scan for non-base datasets.       */\n/* -------------------------------------------------------------------- */\n    if( !bScanDeferred )\n        return;\n\n    bScanDeferred = false;\n\n    if( !bBase )\n        return;\n\n    if( TIFFLastDirectory( hTIFF ) )\n        return;\n\n    CPLDebug( \"GTiff\", \"ScanDirectories()\" );\n\n/* ==================================================================== */\n/*      Scan all directories.                                           */\n/* ==================================================================== */\n    CPLStringList aosSubdatasets;\n    int iDirIndex = 0;\n\n    FlushDirectory();\n    while( !TIFFLastDirectory( hTIFF )\n           && (iDirIndex == 0 || TIFFReadDirectory( hTIFF ) != 0) )\n    {\n        // Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if !defined(SUPPORTS_MORE_THAN_32768_DIRECTORIES)\n        if( iDirIndex == 32768 )\n            break;\n#endif\n        toff_t nThisDir = TIFFCurrentDirOffset(hTIFF);\n        uint32 nSubType = 0;\n\n        *ppoActiveDSRef = nullptr; // Our directory no longer matches this ds.\n\n        ++iDirIndex;\n\n        if( !TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n            nSubType = 0;\n\n        /* Embedded overview of the main image */\n        if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n            (nSubType & FILETYPE_MASK) == 0 &&\n            iDirIndex != 1 &&\n            nOverviewCount < 30 /* to avoid DoS */ )\n        {\n            GTiffDataset *poODS = new GTiffDataset();\n            poODS->osFilename = osFilename;\n            if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, false,\n                                   eAccess ) != CE_None\n                || poODS->GetRasterCount() != GetRasterCount() )\n            {\n                delete poODS;\n            }\n            else\n            {\n                CPLDebug( \"GTiff\", \"Opened %dx%d overview.\",\n                          poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                ++nOverviewCount;\n                papoOverviewDS = static_cast<GTiffDataset **>(\n                    CPLRealloc(papoOverviewDS,\n                               nOverviewCount * (sizeof(void*))) );\n                papoOverviewDS[nOverviewCount-1] = poODS;\n                poODS->poBaseDS = this;\n                poODS->bIsOverview_ = true;\n            }\n        }\n        // Embedded mask of the main image.\n        else if( (nSubType & FILETYPE_MASK) != 0 &&\n                 (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                 iDirIndex != 1 &&\n                 poMaskDS == nullptr )\n        {\n            poMaskDS = new GTiffDataset();\n            poMaskDS->osFilename = osFilename;\n\n            // The TIFF6 specification - page 37 - only allows 1\n            // SamplesPerPixel and 1 BitsPerSample Here we support either 1 or\n            // 8 bit per sample and we support either 1 sample per pixel or as\n            // many samples as in the main image We don't check the value of\n            // the PhotometricInterpretation tag, which should be set to\n            // \"Transparency mask\" (4) according to the specification (page\n            // 36).  However, the TIFF6 specification allows image masks to\n            // have a higher resolution than the main image, what we don't\n            // support here.\n\n            if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir,\n                                      false, eAccess ) != CE_None\n                || poMaskDS->GetRasterCount() == 0\n                || !(poMaskDS->GetRasterCount() == 1\n                     || poMaskDS->GetRasterCount() == GetRasterCount())\n                || poMaskDS->GetRasterXSize() != GetRasterXSize()\n                || poMaskDS->GetRasterYSize() != GetRasterYSize()\n                || poMaskDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n            {\n                delete poMaskDS;\n                poMaskDS = nullptr;\n            }\n            else\n            {\n                CPLDebug( \"GTiff\", \"Opened band mask.\");\n                poMaskDS->poBaseDS = this;\n\n                poMaskDS->bPromoteTo8Bits =\n                    CPLTestBool(\n                        CPLGetConfigOption( \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                            \"YES\" ) );\n            }\n        }\n\n        // Embedded mask of an overview.  The TIFF6 specification allows the\n        // combination of the FILETYPE_xxxx masks.\n        else if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                 (nSubType & FILETYPE_MASK) != 0 &&\n                 iDirIndex != 1 )\n        {\n            GTiffDataset* poDS = new GTiffDataset();\n            poDS->osFilename = osFilename;\n            if( poDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE,\n                                  eAccess ) != CE_None\n                || poDS->GetRasterCount() == 0\n                || poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n            {\n                delete poDS;\n            }\n            else\n            {\n                int i = 0;  // Used after for.\n                for( ; i < nOverviewCount; ++i )\n                {\n                    if( cpl::down_cast<GTiffDataset *>(GDALDataset::FromHandle(\n                           papoOverviewDS[i]))->poMaskDS == nullptr &&\n                        poDS->GetRasterXSize() ==\n                        papoOverviewDS[i]->GetRasterXSize() &&\n                        poDS->GetRasterYSize() ==\n                        papoOverviewDS[i]->GetRasterYSize() &&\n                        (poDS->GetRasterCount() == 1 ||\n                         poDS->GetRasterCount() == GetRasterCount()))\n                    {\n                        CPLDebug(\n                            \"GTiff\", \"Opened band mask for %dx%d overview.\",\n                            poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                        cpl::down_cast<GTiffDataset*>(GDALDataset::FromHandle(\n                            papoOverviewDS[i]))->\n                            poMaskDS = poDS;\n                        poDS->bPromoteTo8Bits =\n                            CPLTestBool(\n                                CPLGetConfigOption(\n                                    \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                    \"YES\" ) );\n                        poDS->poBaseDS = this;\n                        break;\n                    }\n                }\n                if( i == nOverviewCount )\n                {\n                    delete poDS;\n                }\n            }\n        }\n        else if( nSubType == 0 || nSubType == FILETYPE_PAGE )\n        {\n            uint32 nXSize = 0;\n            uint32 nYSize = 0;\n\n            TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n            TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n            if( nXSize > INT_MAX || nYSize > INT_MAX )\n            {\n                CPLDebug(\"GTiff\",\n                         \"Skipping directory with too large image: %u x %u\",\n                         nXSize, nYSize);\n            }\n            else\n            {\n                uint16 nSPP = 0;\n                if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP ) )\n                    nSPP = 1;\n\n                CPLString osName, osDesc;\n                osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\",\n                            iDirIndex, iDirIndex, osFilename.c_str() );\n                osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\",\n                            iDirIndex, iDirIndex,\n                            static_cast<int>(nXSize),\n                            static_cast<int>(nYSize),\n                            nSPP );\n\n                aosSubdatasets.AddString(osName);\n                aosSubdatasets.AddString(osDesc);\n            }\n        }\n\n        // Make sure we are stepping from the expected directory regardless\n        // of churn done processing the above.\n        if( TIFFCurrentDirOffset(hTIFF) != nThisDir )\n            TIFFSetSubDirectory( hTIFF, nThisDir );\n        *ppoActiveDSRef = nullptr;\n    }\n\n    // Nasty hack. Probably something that should be fixed in libtiff\n    // In case the last directory cycles to the first directory, we have\n    // TIFFCurrentDirOffset(hTIFF) == nDirOffset, but the TIFFReadDirectory()\n    // hasn't done its job, so SetDirectory() would be confused and think it\n    // has nothing to do. To avoid that reset to a fake offset before calling\n    // SetDirectory()\n    // This can also occur if the last directory cycles to the IFD of the\n    // mask dataset and we activate this mask dataset.\n    // So always completely reset\n    TIFFSetSubDirectory( hTIFF, 0 );\n    *ppoActiveDSRef = nullptr;\n    CPL_IGNORE_RET_VAL( SetDirectory() );\n\n    // If we have a mask for the main image, loop over the overviews, and if\n    // they have a mask, let's set this mask as an overview of the main mask.\n    if( poMaskDS != nullptr )\n    {\n        for( int i = 0; i < nOverviewCount; ++i )\n        {\n            if( cpl::down_cast<GTiffDataset *>(GDALDataset::FromHandle(\n                   papoOverviewDS[i]))->poMaskDS != nullptr)\n            {\n                ++poMaskDS->nOverviewCount;\n                poMaskDS->papoOverviewDS = static_cast<GTiffDataset **>(\n                    CPLRealloc(poMaskDS->papoOverviewDS,\n                               poMaskDS->nOverviewCount * (sizeof(void*))) );\n                poMaskDS->papoOverviewDS[poMaskDS->nOverviewCount-1] =\n                    cpl::down_cast<GTiffDataset*>(GDALDataset::FromHandle(\n                        papoOverviewDS[i]))->poMaskDS;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n    if( aosSubdatasets.size() > 2 )\n    {\n        oGTiffMDMD.SetMetadata( aosSubdatasets.List(), \"SUBDATASETS\" );\n    }\n}",
    "void GTiffWriteJPEGTables( TIFF* hTIFF,\n                           const char* pszPhotometric,\n                           const char* pszJPEGQuality,\n                           const char* pszJPEGTablesMode )\n{\n    // Would perhaps works with libtiff 3.X but didn't bother trying This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n#if defined(BIGTIFF_SUPPORT)\n    uint16 nBands = 0;\n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL,\n                        &nBands ) )\n        nBands = 1;\n\n    uint16 l_nBitsPerSample = 0;\n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE,\n                        &(l_nBitsPerSample)) )\n        l_nBitsPerSample = 1;\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf(\"%s%p\", szJPEGGTiffDatasetTmpPrefix, hTIFF);\n    VSILFILE* fpTmp = nullptr;\n    CPLString osTmp;\n    char** papszLocalParameters = nullptr;\n    const int nInMemImageWidth = 16;\n    const int nInMemImageHeight = 16;\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\" );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEG_QUALITY\",\n                                            pszJPEGQuality );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"PHOTOMETRIC\", pszPhotometric );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"BLOCKYSIZE\",\n                                            CPLSPrintf(\"%u\", nInMemImageHeight)\n                                          );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"NBITS\",\n                                            CPLSPrintf(\"%u\", l_nBitsPerSample));\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEGTABLESMODE\",\n                                            pszJPEGTablesMode );\n\n    TIFF* hTIFFTmp = GTiffDataset::CreateLL(\n                    osTmpFilenameIn, nInMemImageWidth, nInMemImageHeight,\n                    (nBands <= 4) ? nBands : 1,\n                    (l_nBitsPerSample <= 8) ? GDT_Byte : GDT_UInt16, 0.0,\n                    papszLocalParameters, &fpTmp, osTmp );\n    CSLDestroy(papszLocalParameters);\n    if( hTIFFTmp )\n    {\n        uint16 l_nPhotometric = 0;\n        int nJpegTablesModeIn = 0;\n        TIFFGetField( hTIFFTmp, TIFFTAG_PHOTOMETRIC, &(l_nPhotometric) );\n        TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                        &nJpegTablesModeIn );\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now, reset quality and jpegcolormode.\n        const int l_nJpegQuality = pszJPEGQuality ? atoi(pszJPEGQuality) : 0;\n        if(l_nJpegQuality > 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGQUALITY, l_nJpegQuality);\n        if( l_nPhotometric == PHOTOMETRIC_YCBCR\n            && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGCOLORMODE,\n                            JPEGCOLORMODE_RGB);\n        }\n        if( nJpegTablesModeIn >= 0 )\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                            nJpegTablesModeIn);\n\n        int nBlockSize = nInMemImageWidth * nInMemImageHeight *\n                                        ((nBands <= 4) ? nBands : 1);\n        if( l_nBitsPerSample == 12 )\n            nBlockSize = (nBlockSize * 3) / 2;\n        std::vector<GByte> abyZeroData( nBlockSize, 0 );\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, &abyZeroData[0], nBlockSize);\n\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSize,\n                            &pJPEGTable) )\n            TIFFSetField( hTIFF, TIFFTAG_JPEGTABLES, nJPEGTableSize,\n                            pJPEGTable);\n\n        float *ref = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_REFERENCEBLACKWHITE, &ref) )\n            TIFFSetField(hTIFF, TIFFTAG_REFERENCEBLACKWHITE, ref);\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n    VSIUnlink(osTmpFilenameIn);\n#endif\n}",
    "int GTiffDataset::GuessJPEGQuality( bool& bOutHasQuantizationTable,\n                                    bool& bOutHasHuffmanTable )\n{\n    CPLAssert( nCompression == COMPRESSION_JPEG );\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    if( !TIFFGetField(hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize, &pJPEGTable) )\n    {\n        bOutHasQuantizationTable = false;\n        bOutHasHuffmanTable = false;\n        return -1;\n    }\n\n    bOutHasQuantizationTable =\n        GTIFFFindNextTable( static_cast<const GByte*>(pJPEGTable), 0xDB,\n                            nJPEGTableSize, nullptr) != nullptr;\n    bOutHasHuffmanTable =\n        GTIFFFindNextTable( static_cast<const GByte*>(pJPEGTable), 0xC4,\n                            nJPEGTableSize, nullptr) != nullptr;\n    if( !bOutHasQuantizationTable )\n        return -1;\n\n    char** papszLocalParameters = nullptr;\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\");\n    if( nPhotometric == PHOTOMETRIC_YCBCR )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"YCBCR\");\n    else if( nPhotometric == PHOTOMETRIC_SEPARATED )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"CMYK\");\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"BLOCKYSIZE\", \"16\");\n    if( nBitsPerSample == 12 )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                \"NBITS\", \"12\");\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf( \"/vsimem/gtiffdataset_guess_jpeg_quality_tmp_%p\",\n                            this );\n\n    int nRet = -1;\n    for( int nQuality = 0; nQuality <= 100 && nRet < 0; ++nQuality )\n    {\n        VSILFILE* fpTmp = nullptr;\n        if( nQuality == 0 )\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                   \"JPEG_QUALITY\", \"75\");\n        else\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                \"JPEG_QUALITY\", CPLSPrintf(\"%d\", nQuality));\n\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        CPLString osTmp;\n        TIFF* hTIFFTmp =\n            CreateLL( osTmpFilenameIn, 16, 16, (nBands <= 4) ? nBands : 1,\n                      GetRasterBand(1)->GetRasterDataType(), 0.0,\n                      papszLocalParameters, &fpTmp, osTmp );\n        CPLPopErrorHandler();\n        if( !hTIFFTmp )\n        {\n            break;\n        }\n\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now reset jpegcolormode.\n        if( nPhotometric == PHOTOMETRIC_YCBCR\n            && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n\n        GByte abyZeroData[(16*16*4*3)/2] = {};\n        const int nBlockSize =\n            (16 * 16 * ((nBands <= 4) ? nBands : 1) * nBitsPerSample) / 8;\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, abyZeroData, nBlockSize);\n\n        uint32 nJPEGTableSizeTry = 0;\n        void* pJPEGTableTry = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES,\n                         &nJPEGTableSizeTry, &pJPEGTableTry) )\n        {\n            if( GTIFFQuantizationTablesEqual(\n                   static_cast<GByte *>(pJPEGTable), nJPEGTableSize,\n                   static_cast<GByte *>(pJPEGTableTry), nJPEGTableSizeTry) )\n            {\n                nRet = (nQuality == 0 ) ? 75 : nQuality;\n            }\n        }\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n\n    CSLDestroy(papszLocalParameters);\n    VSIUnlink(osTmpFilenameIn);\n\n    return nRet;\n}",
    "void GTiffDataset::SetJPEGQualityAndTablesModeFromFile()\n{\n    bool bHasQuantizationTable = false;\n    bool bHasHuffmanTable = false;\n    int nQuality = GuessJPEGQuality( bHasQuantizationTable,\n                                     bHasHuffmanTable );\n    if( nQuality > 0 )\n    {\n        CPLDebug(\"GTiff\", \"Guessed JPEG quality to be %d\", nQuality);\n        nJpegQuality = nQuality;\n        TIFFSetField( hTIFF, TIFFTAG_JPEGQUALITY, nQuality );\n\n        // This means we will use the quantization tables from the\n        // JpegTables tag.\n        nJpegTablesMode = JPEGTABLESMODE_QUANT;\n    }\n    else\n    {\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( !TIFFGetField( hTIFF, TIFFTAG_JPEGTABLES,\n                            &nJPEGTableSize, &pJPEGTable) )\n        {\n            toff_t *panByteCounts = nullptr;\n            const int nBlockCount =\n                nPlanarConfig == PLANARCONFIG_SEPARATE\n                ? nBlocksPerBand * nBands\n                : nBlocksPerBand;\n            if( TIFFIsTiled( hTIFF ) )\n                TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS,\n                                &panByteCounts );\n            else\n                TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS,\n                                &panByteCounts );\n\n            bool bFoundNonEmptyBlock = false;\n            if( panByteCounts != nullptr )\n            {\n                for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n                {\n                    if( panByteCounts[iBlock] != 0 )\n                    {\n                        bFoundNonEmptyBlock = true;\n                        break;\n                    }\n                }\n            }\n            if( bFoundNonEmptyBlock )\n            {\n                CPLDebug(\"GTiff\", \"Could not guess JPEG quality. \"\n                            \"JPEG tables are missing, so going in \"\n                            \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n                // Write quantization tables in each strile.\n                nJpegTablesMode = 0;\n            }\n        }\n        else\n        {\n            if( bHasQuantizationTable )\n            {\n                // FIXME in libtiff: this is likely going to cause issues\n                // since libtiff will reuse in each strile the number of\n                // the global quantization table, which is invalid.\n                CPLDebug(\n                    \"GTiff\", \"Could not guess JPEG quality although JPEG \"\n                    \"quantization tables are present, so going in \"\n                    \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\" );\n            }\n            else\n            {\n                CPLDebug(\"GTiff\", \"Could not guess JPEG quality since JPEG \"\n                        \"quantization tables are not present, so going in \"\n                        \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n            }\n\n            // Write quantization tables in each strile.\n            nJpegTablesMode = 0;\n        }\n    }\n    if( bHasHuffmanTable )\n    {\n        // If there are Huffman tables in header use them, otherwise\n        // if we use optimized tables, libtiff will currently reuse\n        // the number of the Huffman tables of the header for the\n        // optimized version of each strile, which is illegal.\n        nJpegTablesMode |= JPEGTABLESMODE_HUFF;\n    }\n    if( nJpegTablesMode >= 0 )\n        TIFFSetField( hTIFF, TIFFTAG_JPEGTABLESMODE,\n                        nJpegTablesMode);\n}",
    "GDALDataset *GTiffDataset::Create( const char * pszFilename,\n                                   int nXSize, int nYSize, int l_nBands,\n                                   GDALDataType eType,\n                                   char **papszParmList )\n\n{\n    VSILFILE* l_fpL = nullptr;\n    CPLString l_osTmpFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Create the underlying TIFF file.                                */\n/* -------------------------------------------------------------------- */\n    TIFF *l_hTIFF = CreateLL(\n        pszFilename,\n        nXSize, nYSize, l_nBands,\n        eType, 0, papszParmList, &l_fpL, l_osTmpFilename );\n    const bool bStreaming = !l_osTmpFilename.empty();\n\n    if( l_hTIFF == nullptr )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Create the new GTiffDataset object.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->hTIFF = l_hTIFF;\n    poDS->fpL = l_fpL;\n    if( bStreaming )\n    {\n        poDS->bStreamingOut = true;\n        poDS->osTmpFilename = l_osTmpFilename;\n        poDS->fpToWrite = VSIFOpenL( pszFilename, \"wb\" );\n        if( poDS->fpToWrite == nullptr )\n        {\n            VSIUnlink(l_osTmpFilename);\n            delete poDS;\n            return nullptr;\n        }\n    }\n    poDS->poActiveDS = poDS;\n    poDS->ppoActiveDSRef = &(poDS->poActiveDS);\n\n    poDS->nRasterXSize = nXSize;\n    poDS->nRasterYSize = nYSize;\n    poDS->eAccess = GA_Update;\n    poDS->bCrystalized = false;\n    poDS->nSamplesPerPixel = static_cast<uint16>(l_nBands);\n    poDS->osFilename = pszFilename;\n\n    // Don't try to load external metadata files (#6597).\n    poDS->bIMDRPCMetadataLoaded = true;\n\n    // Avoid premature crystalization that will cause directory re-writing if\n    // GetProjectionRef() or GetGeoTransform() are called on the newly created\n    // GeoTIFF.\n    poDS->bLookedForProjection = true;\n\n    TIFFGetField( l_hTIFF, TIFFTAG_SAMPLEFORMAT, &(poDS->nSampleFormat) );\n    TIFFGetField( l_hTIFF, TIFFTAG_PLANARCONFIG, &(poDS->nPlanarConfig) );\n    // Weird that we need this, but otherwise we get a Valgrind warning on\n    // tiff_write_124.\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, &(poDS->nPhotometric) ) )\n        poDS->nPhotometric = PHOTOMETRIC_MINISBLACK;\n    TIFFGetField( l_hTIFF, TIFFTAG_BITSPERSAMPLE, &(poDS->nBitsPerSample) );\n    TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, &(poDS->nCompression) );\n\n    if( TIFFIsTiled(l_hTIFF) )\n    {\n        TIFFGetField( l_hTIFF, TIFFTAG_TILEWIDTH, &(poDS->nBlockXSize) );\n        TIFFGetField( l_hTIFF, TIFFTAG_TILELENGTH, &(poDS->nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( l_hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(poDS->nRowsPerStrip) ) )\n            poDS->nRowsPerStrip = 1;  // Dummy value.\n\n        poDS->nBlockXSize = nXSize;\n        poDS->nBlockYSize =\n            std::min( static_cast<int>(poDS->nRowsPerStrip) , nYSize );\n    }\n\n    poDS->nBlocksPerBand =\n        DIV_ROUND_UP(nYSize, poDS->nBlockYSize)\n        * DIV_ROUND_UP(nXSize, poDS->nBlockXSize);\n\n    if( CSLFetchNameValue( papszParmList, \"PROFILE\" ) != nullptr )\n        poDS->osProfile = CSLFetchNameValue( papszParmList, \"PROFILE\" );\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( poDS->nCompression == COMPRESSION_JPEG\n        && poDS->nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\") ) )\n    {\n        int nColorMode = 0;\n\n        poDS->SetMetadataItem(\"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\");\n        if( !TIFFGetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n            nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n#ifdef HAVE_LERC\n    if( poDS->nCompression == COMPRESSION_LERC )\n    {\n        uint32 nLercParamCount = 0;\n        uint32* panLercParms = nullptr;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_LERC_PARAMETERS, &nLercParamCount,\n                          &panLercParms ) &&\n            nLercParamCount == 2 )\n        {\n            memcpy( poDS->anLercAddCompressionAndVersion, panLercParms,\n                    sizeof(poDS->anLercAddCompressionAndVersion) );\n        }\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Read palette back as a color table if it has one.               */\n/* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( poDS->nPhotometric == PHOTOMETRIC_PALETTE\n        && TIFFGetField( l_hTIFF, TIFFTAG_COLORMAP,\n                         &panRed, &panGreen, &panBlue) )\n    {\n\n        poDS->poColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 << poDS->nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast<short>(panRed[iColor] / divisor),\n                static_cast<short>(panGreen[iColor] / divisor),\n                static_cast<short>(panBlue[iColor] / divisor),\n                static_cast<short>(255)\n            };\n\n            poDS->poColorTable->SetColorEntry( iColor, &oEntry );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we want to ensure all blocks get written out on close to     */\n/*      avoid sparse files?                                             */\n/* -------------------------------------------------------------------- */\n    if( !CPLFetchBool( papszParmList, \"SPARSE_OK\", false ) )\n        poDS->bFillEmptyTilesAtClosing = true;\n\n    poDS->bWriteEmptyTiles = bStreaming ||\n        (poDS->nCompression != COMPRESSION_NONE &&\n         poDS->bFillEmptyTilesAtClosing);\n    // Only required for people writing non-compressed stripped files in the\n    // right order and wanting all tstrips to be written in the same order\n    // so that the end result can be memory mapped without knowledge of each\n    // strip offset.\n    if( CPLTestBool( CSLFetchNameValueDef( papszParmList,\n                              \"WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) ||\n         CPLTestBool( CSLFetchNameValueDef( papszParmList,\n                              \"@WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) )\n    {\n        poDS->bWriteEmptyTiles = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Preserve creation options for consulting later (for instance    */\n/*      to decide if a TFW file should be written).                     */\n/* -------------------------------------------------------------------- */\n    poDS->papszCreationOptions = CSLDuplicate( papszParmList );\n\n    poDS->nZLevel = GTiffGetZLevel(papszParmList);\n    poDS->nLZMAPreset = GTiffGetLZMAPreset(papszParmList);\n    poDS->nZSTDLevel = GTiffGetZSTDPreset(papszParmList);\n    poDS->nWebPLevel = GTiffGetWebPLevel(papszParmList);\n    poDS->bWebPLossless = GTiffGetWebPLossless(papszParmList);\n    poDS->nJpegQuality = GTiffGetJpegQuality(papszParmList);\n    poDS->nJpegTablesMode = GTiffGetJpegTablesMode(papszParmList);\n#if HAVE_LERC\n    poDS->dfMaxZError = GTiffGetLERCMaxZError(papszParmList);\n#endif\n    poDS->InitCreationOrOpenOptions(papszParmList);\n\n#if !defined(BIGTIFF_SUPPORT)\n/* -------------------------------------------------------------------- */\n/*      If we are writing jpeg compression we need to write some        */\n/*      imagery to force the jpegtables to get created.  This is,       */\n/*      likely only needed with libtiff >= 3.9.3 (#3633)                */\n/* -------------------------------------------------------------------- */\n    if( poDS->nCompression == COMPRESSION_JPEG\n        && strstr(TIFFLIB_VERSION_STR, \"Version 3.9\") != nullptr )\n    {\n        CPLDebug( \"GDAL\",\n                  \"Writing zero block to force creation of JPEG tables.\" );\n        if( TIFFIsTiled( l_hTIFF ) )\n        {\n            const int cc = TIFFTileSize( l_hTIFF );\n            unsigned char *pabyZeros =\n                static_cast<unsigned char *>(CPLCalloc(cc, 1));\n            TIFFWriteEncodedTile(l_hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        else\n        {\n            const int cc = TIFFStripSize( l_hTIFF );\n            unsigned char *pabyZeros =\n                static_cast<unsigned char *>(CPLCalloc(cc, 1));\n            TIFFWriteEncodedStrip(l_hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        poDS->bDontReloadFirstBlock = true;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < l_nBands; ++iBand )\n    {\n        if( poDS->nBitsPerSample == 8 ||\n            (poDS->nBitsPerSample == 16 && eType != GDT_Float32) ||\n            poDS->nBitsPerSample == 32 ||\n            poDS->nBitsPerSample == 64 ||\n            poDS->nBitsPerSample == 128)\n        {\n            poDS->SetBand( iBand + 1, new GTiffRasterBand( poDS, iBand + 1 ) );\n        }\n        else\n        {\n            poDS->SetBand( iBand + 1, new GTiffOddBitsBand( poDS, iBand + 1 ) );\n            poDS->GetRasterBand( iBand + 1 )->\n                SetMetadataItem( \"NBITS\",\n                                 CPLString().Printf(\"%d\",poDS->nBitsPerSample),\n                                 \"IMAGE_STRUCTURE\" );\n        }\n    }\n\n    poDS->GetDiscardLsbOption(papszParmList);\n\n    if( poDS->nPlanarConfig == PLANARCONFIG_CONTIG && l_nBands != 1 )\n        poDS->SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        poDS->SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    poDS->oOvManager.Initialize( poDS, pszFilename );\n\n    return poDS;\n}",
    "const char *GTiffDataset::GetMetadataItem( const char *pszName,\n                                           const char *pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain,\"ProxyOverviewRequest\") )\n    {\n        return GDALPamDataset::GetMetadataItem( pszName, pszDomain );\n    }\n    else if( pszDomain != nullptr && (EQUAL(pszDomain, MD_DOMAIN_RPC) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMD) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMAGERY)) )\n    {\n        LoadMetadata();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"SUBDATASETS\") )\n    {\n        ScanDirectories();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"EXIF\") )\n    {\n        LoadEXIFMetadata();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        LoadICCProfile();\n    }\n    else if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) &&\n        pszName != nullptr && EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LoadMDAreaOrPoint();  // To set GDALMD_AREA_OR_POINT.\n    }\n\n#ifdef DEBUG_REACHED_VIRTUAL_MEM_IO\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"_DEBUG_\") &&\n             pszName != nullptr &&\n             EQUAL(pszName, \"UNREACHED_VIRTUALMEMIO_CODE_PATH\") )\n    {\n        CPLString osMissing;\n        for( int i = 0; i < static_cast<int>(\n                                CPL_ARRAYSIZE(anReachedVirtualMemIO)); ++i )\n        {\n            if( !anReachedVirtualMemIO[i] )\n            {\n                if( !osMissing.empty() ) osMissing += \",\";\n                osMissing += CPLSPrintf(\"%d\", i);\n            }\n        }\n        return (osMissing.size()) ? CPLSPrintf(\"%s\", osMissing.c_str()) : nullptr;\n    }\n#endif\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"_DEBUG_\") &&\n             pszName != nullptr && EQUAL(pszName, \"TIFFTAG_EXTRASAMPLES\") )\n    {\n        CPLString osRet;\n        uint16 *v = nullptr;\n        uint16 count = 0;\n\n        if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            for( int i = 0; i < static_cast<int>(count); ++i )\n            {\n                if( i > 0 ) osRet += \",\";\n                osRet += CPLSPrintf(\"%d\", v[i]);\n            }\n        }\n        return (osRet.size()) ? CPLSPrintf(\"%s\", osRet.c_str()) : nullptr;\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"_DEBUG_\") &&\n             pszName != nullptr && EQUAL(pszName, \"TIFFTAG_PHOTOMETRIC\") )\n    {\n        return CPLSPrintf(\"%d\", nPhotometric);\n    }\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"_DEBUG_\") &&\n             pszName != nullptr && EQUAL( pszName, \"TIFFTAG_GDAL_METADATA\") )\n    {\n        char* pszText = nullptr;\n        if( !TIFFGetField( hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n            return nullptr;\n\n        return CPLSPrintf(\"%s\", pszText);\n    }\n\n    return oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}",
    "void GTiffDataset::LoadEXIFMetadata()\n{\n    if( bEXIFMetadataLoaded )\n        return;\n    bEXIFMetadataLoaded = true;\n\n    if( !SetDirectory() )\n        return;\n\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n\n    GByte abyHeader[2] = { 0 };\n    if( VSIFSeekL(fp, 0, SEEK_SET) != 0 ||\n        VSIFReadL(abyHeader, 1, 2, fp) != 2 )\n        return;\n\n    const bool bLittleEndian = abyHeader[0] == 'I' && abyHeader[1] == 'I';\n    const bool bLeastSignificantBit = CPL_IS_LSB != 0;\n    const bool bSwabflag = bLittleEndian != bLeastSignificantBit;  // != is XOR.\n\n    char** papszMetadata = nullptr;\n    toff_t nOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n\n    if( TIFFGetField(hTIFF, TIFFTAG_EXIFIFD, &nOffset) )\n    {\n        int nExifOffset = static_cast<int>(nOffset);\n        int nInterOffset = 0;\n        int nGPSOffset = 0;\n        EXIFExtractMetadata( papszMetadata,\n                             fp, static_cast<int>(nOffset),\n                             bSwabflag, 0,\n                             nExifOffset, nInterOffset, nGPSOffset);\n    }\n\n    if( TIFFGetField(hTIFF, TIFFTAG_GPSIFD, &nOffset) )\n    {\n        int nExifOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n        int nInterOffset = 0;\n        int nGPSOffset = static_cast<int>(nOffset);\n        EXIFExtractMetadata( papszMetadata,\n                             fp, static_cast<int>(nOffset),\n                             bSwabflag, 0,\n                             nExifOffset, nInterOffset, nGPSOffset );\n    }\n\n    if( papszMetadata )\n    {\n        oGTiffMDMD.SetMetadata( papszMetadata, \"EXIF\" );\n        CSLDestroy( papszMetadata );\n    }\n}",
    "CPLErr GTiffDataset::CreateMaskBand(int nFlagsIn)\n{\n    ScanDirectories();\n\n    if( poMaskDS != nullptr )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"This TIFF dataset has already an internal mask band\" );\n        return CE_Failure;\n    }\n    else if( CPLTestBool(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\")) )\n    {\n        if( nFlagsIn != GMF_PER_DATASET )\n        {\n            CPLError(\n                CE_Failure, CPLE_AppDefined,\n                \"The only flag value supported for internal mask is \"\n                \"GMF_PER_DATASET\" );\n            return CE_Failure;\n        }\n\n        int l_nCompression = COMPRESSION_PACKBITS;\n        if( strstr(GDALGetMetadataItem(GDALGetDriverByName( \"GTiff\" ),\n                                       GDAL_DMD_CREATIONOPTIONLIST, nullptr ),\n                   \"<Value>DEFLATE</Value>\") != nullptr )\n            l_nCompression = COMPRESSION_ADOBE_DEFLATE;\n\n    /* -------------------------------------------------------------------- */\n    /*      If we don't have read access, then create the mask externally.  */\n    /* -------------------------------------------------------------------- */\n        if( GetAccess() != GA_Update )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined,\n                      \"File open for read-only accessing, \"\n                      \"creating mask externally.\" );\n\n            return GDALPamDataset::CreateMaskBand(nFlagsIn);\n        }\n\n        if( poBaseDS && !poBaseDS->SetDirectory() )\n            return CE_Failure;\n\n        if( !SetDirectory() )\n            return CE_Failure;\n\n        bool bIsOverview = false;\n        uint32 nSubType = 0;\n        if( TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n        {\n            bIsOverview = (nSubType & FILETYPE_REDUCEDIMAGE) != 0;\n\n            if( (nSubType & FILETYPE_MASK) != 0 )\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"Cannot create a mask on a TIFF mask IFD !\" );\n                return CE_Failure;\n            }\n        }\n\n        const int bIsTiled = TIFFIsTiled(hTIFF);\n\n        FlushDirectory();\n\n        const toff_t nOffset =\n            GTIFFWriteDirectory(\n                hTIFF,\n                bIsOverview ?\n                FILETYPE_REDUCEDIMAGE | FILETYPE_MASK : FILETYPE_MASK,\n                nRasterXSize, nRasterYSize,\n                1, PLANARCONFIG_CONTIG, 1,\n                nBlockXSize, nBlockYSize,\n                bIsTiled, l_nCompression,\n                PHOTOMETRIC_MASK, PREDICTOR_NONE,\n                SAMPLEFORMAT_UINT, nullptr, nullptr, nullptr, 0, nullptr, \"\", nullptr, nullptr,\n                nullptr, nullptr );\n        if( nOffset == 0 )\n            return CE_Failure;\n\n        poMaskDS = new GTiffDataset();\n        poMaskDS->bPromoteTo8Bits =\n            CPLTestBool(\n                CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n        if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nOffset,\n                                  false, GA_Update ) != CE_None)\n        {\n            delete poMaskDS;\n            poMaskDS = nullptr;\n            return CE_Failure;\n        }\n\n        return CE_None;\n    }\n\n    return GDALPamDataset::CreateMaskBand(nFlagsIn);\n}",
    "CPLErr GTIFWktFromMemBufEx( int nSize, unsigned char *pabyBuffer,\n                            char **ppszWKT, double *padfGeoTransform,\n                            int *pnGCPCount, GDAL_GCP **ppasGCPList,\n                            int *pbPixelIsPoint, char*** ppapszRPCMD )\n\n{\n    char szFilename[100] = {};\n\n    snprintf( szFilename, sizeof(szFilename),\n              \"/vsimem/wkt_from_mem_buf_%ld.tif\",\n              static_cast<long>( CPLGetPID() ) );\n\n/* -------------------------------------------------------------------- */\n/*      Make sure we have hooked CSVFilename().                         */\n/* -------------------------------------------------------------------- */\n    GTiffOneTimeInit();  // For RPC tag.\n    LibgeotiffOneTimeInit();\n\n/* -------------------------------------------------------------------- */\n/*      Create a memory file from the buffer.                           */\n/* -------------------------------------------------------------------- */\n    VSILFILE *fp = VSIFileFromMemBuffer( szFilename, pabyBuffer, nSize, FALSE );\n    if( fp == nullptr )\n        return CE_Failure;\n\n/* -------------------------------------------------------------------- */\n/*      Initialize access to the memory geotiff structure.              */\n/* -------------------------------------------------------------------- */\n    TIFF *hTIFF = VSI_TIFFOpen( szFilename, \"rc\", fp );\n\n    if( hTIFF == nullptr )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"TIFF/GeoTIFF structure is corrupt.\" );\n        VSIUnlink( szFilename );\n        CPL_IGNORE_RET_VAL(VSIFCloseL( fp ));\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get the projection definition.                                  */\n/* -------------------------------------------------------------------- */\n    bool bPixelIsPoint = false;\n    bool bPointGeoIgnore = false;\n    short nRasterType = 0;\n\n    GTIF *hGTIF = GTIFNew(hTIFF);\n\n    if( hGTIF != nullptr && GDALGTIFKeyGetSHORT(hGTIF, GTRasterTypeGeoKey,\n                                             &nRasterType, 0, 1 ) == 1\n        && nRasterType == static_cast<short>( RasterPixelIsPoint ) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore =\n            CPLTestBool( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                            \"FALSE\") );\n    }\n    if( pbPixelIsPoint )\n        *pbPixelIsPoint = bPixelIsPoint;\n    if( ppapszRPCMD )\n        *ppapszRPCMD = nullptr;\n\n#if LIBGEOTIFF_VERSION >= 1410\n    GTIFDefn *psGTIFDefn = GTIFAllocDefn();\n#else\n    GTIFDefn *psGTIFDefn = static_cast<GTIFDefn *>(\n        CPLCalloc(1, sizeof(GTIFDefn)) );\n#endif\n\n    if( hGTIF != nullptr && GTIFGetDefn( hGTIF, psGTIFDefn ) )\n        *ppszWKT = GTIFGetOGISDefn( hGTIF, psGTIFDefn );\n    else\n        *ppszWKT = nullptr;\n\n    if( hGTIF )\n        GTIFFree( hGTIF );\n\n#if LIBGEOTIFF_VERSION >= 1410\n    GTIFFreeDefn(psGTIFDefn);\n#else\n    CPLFree(psGTIFDefn);\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Get geotransform or tiepoints.                                  */\n/* -------------------------------------------------------------------- */\n    double *padfTiePoints = nullptr;\n    double *padfScale = nullptr;\n    double *padfMatrix = nullptr;\n    int16 nCount = 0;\n\n    padfGeoTransform[0] = 0.0;\n    padfGeoTransform[1] = 1.0;\n    padfGeoTransform[2] = 0.0;\n    padfGeoTransform[3] = 0.0;\n    padfGeoTransform[4] = 0.0;\n    padfGeoTransform[5] = 1.0;\n\n    *pnGCPCount = 0;\n    *ppasGCPList = nullptr;\n\n    if( TIFFGetField(hTIFF, TIFFTAG_GEOPIXELSCALE, &nCount, &padfScale )\n        && nCount >= 2 )\n    {\n        padfGeoTransform[1] = padfScale[0];\n        padfGeoTransform[5] = -std::abs(padfScale[1]);\n\n        if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && nCount >= 6 )\n        {\n            padfGeoTransform[0] =\n                padfTiePoints[3] - padfTiePoints[0] * padfGeoTransform[1];\n            padfGeoTransform[3] =\n                padfTiePoints[4] - padfTiePoints[1] * padfGeoTransform[5];\n\n            // Adjust for pixel is point in transform.\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                padfGeoTransform[0] -=\n                    padfGeoTransform[1] * 0.5 + padfGeoTransform[2] * 0.5;\n                padfGeoTransform[3] -=\n                    padfGeoTransform[4] * 0.5 + padfGeoTransform[5] * 0.5;\n            }\n        }\n    }\n    else if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n             && nCount >= 6 )\n    {\n        *pnGCPCount = nCount / 6;\n        *ppasGCPList = static_cast<GDAL_GCP *>(\n            CPLCalloc(sizeof(GDAL_GCP), *pnGCPCount) );\n\n        for( int iGCP = 0; iGCP < *pnGCPCount; iGCP++ )\n        {\n            char szID[32] = {};\n            GDAL_GCP *psGCP = *ppasGCPList + iGCP;\n\n            snprintf( szID, sizeof(szID), \"%d\", iGCP + 1 );\n            psGCP->pszId = CPLStrdup( szID );\n            psGCP->pszInfo = CPLStrdup(\"\");\n            psGCP->dfGCPPixel = padfTiePoints[iGCP*6+0];\n            psGCP->dfGCPLine = padfTiePoints[iGCP*6+1];\n            psGCP->dfGCPX = padfTiePoints[iGCP*6+3];\n            psGCP->dfGCPY = padfTiePoints[iGCP*6+4];\n            psGCP->dfGCPZ = padfTiePoints[iGCP*6+5];\n        }\n    }\n    else if( TIFFGetField(hTIFF,TIFFTAG_GEOTRANSMATRIX,&nCount,&padfMatrix )\n             && nCount == 16 )\n    {\n        padfGeoTransform[0] = padfMatrix[3];\n        padfGeoTransform[1] = padfMatrix[0];\n        padfGeoTransform[2] = padfMatrix[1];\n        padfGeoTransform[3] = padfMatrix[7];\n        padfGeoTransform[4] = padfMatrix[4];\n        padfGeoTransform[5] = padfMatrix[5];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read RPC                                                        */\n/* -------------------------------------------------------------------- */\n    if( ppapszRPCMD != nullptr )\n    {\n        *ppapszRPCMD = GTiffDatasetReadRPCTag( hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup.                                                        */\n/* -------------------------------------------------------------------- */\n    XTIFFClose( hTIFF );\n    CPL_IGNORE_RET_VAL(VSIFCloseL( fp ));\n\n    VSIUnlink( szFilename );\n\n    if( *ppszWKT == nullptr )\n        return CE_Failure;\n\n    return CE_None;\n}",
    "static\nvoid GTIFF_Set_TIFFTAG_JPEGTABLES( TIFF* hTIFF,\n                                   jpeg_decompress_struct& sDInfo,\n                                   jpeg_compress_struct& sCInfo )\n{\n    char szTmpFilename[128] = { '\\0' };\n    snprintf(szTmpFilename, sizeof(szTmpFilename),\n             \"/vsimem/tables_%p\", &sDInfo);\n    VSILFILE* fpTABLES = VSIFOpenL(szTmpFilename, \"wb+\");\n\n    uint16 nPhotometric = 0;\n    TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &nPhotometric );\n\n    jpeg_vsiio_dest( &sCInfo, fpTABLES );\n\n    // Avoid unnecessary tables to be emitted.\n    if( nPhotometric != PHOTOMETRIC_YCBCR )\n    {\n        JQUANT_TBL* qtbl = sCInfo.quant_tbl_ptrs[1];\n        if( qtbl != nullptr )\n            qtbl->sent_table = TRUE;\n        JHUFF_TBL* htbl = sCInfo.dc_huff_tbl_ptrs[1];\n        if( htbl != nullptr )\n            htbl->sent_table = TRUE;\n        htbl = sCInfo.ac_huff_tbl_ptrs[1];\n        if( htbl != nullptr )\n            htbl->sent_table = TRUE;\n    }\n    jpeg_write_tables( &sCInfo );\n\n    CPL_IGNORE_RET_VAL(VSIFCloseL(fpTABLES));\n\n    vsi_l_offset nSizeTables = 0;\n    GByte* pabyJPEGTablesData =\n        VSIGetMemFileBuffer(szTmpFilename, &nSizeTables, FALSE);\n    TIFFSetField( hTIFF, TIFFTAG_JPEGTABLES,\n                  static_cast<int>(nSizeTables),\n                  pabyJPEGTablesData );\n\n    VSIUnlink(szTmpFilename);\n}",
    "CPLErr GTIFF_CopyFromJPEG_WriteAdditionalTags( TIFF* hTIFF,\n                                               GDALDataset* poSrcDS )\n{\n    poSrcDS = GetUnderlyingDataset(poSrcDS);\n    if( poSrcDS == nullptr )\n        return CE_Failure;\n\n/* -------------------------------------------------------------------- */\n/*      Write TIFFTAG_JPEGTABLES                                        */\n/* -------------------------------------------------------------------- */\n\n    VSILFILE* fpJPEG = VSIFOpenL(poSrcDS->GetDescription(), \"rb\");\n    if( fpJPEG == nullptr )\n        return CE_Failure;\n\n    struct jpeg_error_mgr sJErr;\n    struct jpeg_decompress_struct sDInfo;\n    jmp_buf setjmp_buffer;\n    if( setjmp(setjmp_buffer) )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpJPEG));\n        return CE_Failure;\n    }\n\n    sDInfo.err = jpeg_std_error( &sJErr );\n    sJErr.error_exit = GTIFF_ErrorExitJPEG;\n    sDInfo.client_data = &setjmp_buffer;\n\n    jpeg_create_decompress(&sDInfo);\n\n    jpeg_vsiio_src( &sDInfo, fpJPEG );\n    jpeg_read_header( &sDInfo, TRUE );\n\n    struct jpeg_compress_struct sCInfo;\n\n    sCInfo.err = jpeg_std_error( &sJErr );\n    sJErr.error_exit = GTIFF_ErrorExitJPEG;\n    sCInfo.client_data = &setjmp_buffer;\n\n    jpeg_create_compress(&sCInfo);\n    jpeg_copy_critical_parameters(&sDInfo, &sCInfo);\n    GTIFF_Set_TIFFTAG_JPEGTABLES(hTIFF, sDInfo, sCInfo);\n    jpeg_abort_compress(&sCInfo);\n    jpeg_destroy_compress(&sCInfo);\n\n/* -------------------------------------------------------------------- */\n/*      Write TIFFTAG_REFERENCEBLACKWHITE if needed.                    */\n/* -------------------------------------------------------------------- */\n\n    uint16 nPhotometric = 0;\n    if( !TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    uint16 nBitsPerSample = 0;\n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &(nBitsPerSample)) )\n        nBitsPerSample = 1;\n\n    if( nPhotometric == PHOTOMETRIC_YCBCR )\n    {\n        /*\n         * A ReferenceBlackWhite field *must* be present since the\n         * default value is inappropriate for YCbCr.  Fill in the\n         * proper value if application didn't set it.\n         */\n        float *ref = nullptr;\n        if( !TIFFGetField(hTIFF, TIFFTAG_REFERENCEBLACKWHITE, &ref) )\n        {\n            long top = 1L << nBitsPerSample;\n            float refbw[6] = { 0.0 };\n            refbw[1] = static_cast<float>(top - 1L);\n            refbw[2] = static_cast<float>(top >> 1);\n            refbw[3] = refbw[1];\n            refbw[4] = refbw[2];\n            refbw[5] = refbw[1];\n            TIFFSetField( hTIFF, TIFFTAG_REFERENCEBLACKWHITE,\n                          refbw );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write TIFFTAG_YCBCRSUBSAMPLING if needed.                       */\n/* -------------------------------------------------------------------- */\n\n    if( nPhotometric == PHOTOMETRIC_YCBCR && sDInfo.num_components == 3 )\n    {\n        if( (sDInfo.comp_info[0].h_samp_factor == 1 ||\n             sDInfo.comp_info[0].h_samp_factor == 2) &&\n            (sDInfo.comp_info[0].v_samp_factor == 1 ||\n             sDInfo.comp_info[0].v_samp_factor == 2) &&\n            sDInfo.comp_info[1].h_samp_factor == 1 &&\n            sDInfo.comp_info[1].v_samp_factor == 1 &&\n            sDInfo.comp_info[2].h_samp_factor == 1 &&\n            sDInfo.comp_info[2].v_samp_factor == 1 )\n        {\n            TIFFSetField(hTIFF, TIFFTAG_YCBCRSUBSAMPLING,\n                         sDInfo.comp_info[0].h_samp_factor,\n                         sDInfo.comp_info[0].v_samp_factor);\n        }\n        else\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"Unusual sampling factors. \"\n                \"TIFFTAG_YCBCRSUBSAMPLING not written.\" );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup.                                                        */\n/* -------------------------------------------------------------------- */\n\n    jpeg_abort_decompress( &sDInfo );\n    jpeg_destroy_decompress( &sDInfo );\n\n    if( VSIFCloseL(fpJPEG) != 0 )\n        return CE_Failure;\n\n    return CE_None;\n}",
    "CPLErr GTIFF_CopyFromJPEG(GDALDataset* poDS, GDALDataset* poSrcDS,\n                          GDALProgressFunc pfnProgress, void * pProgressData,\n                          bool& bShouldFallbackToNormalCopyIfFail)\n{\n    bShouldFallbackToNormalCopyIfFail = true;\n\n    poSrcDS = GetUnderlyingDataset(poSrcDS);\n    if( poSrcDS == nullptr )\n        return CE_Failure;\n\n    VSILFILE* fpJPEG = VSIFOpenL(poSrcDS->GetDescription(), \"rb\");\n    if( fpJPEG == nullptr )\n        return CE_Failure;\n\n    CPLErr eErr = CE_None;\n\n/* -------------------------------------------------------------------- */\n/*      Initialization of the decompressor                              */\n/* -------------------------------------------------------------------- */\n    struct jpeg_error_mgr sJErr;\n    struct jpeg_decompress_struct sDInfo;\n    memset(&sDInfo, 0, sizeof(sDInfo));\n    jmp_buf setjmp_buffer;\n    if( setjmp(setjmp_buffer) )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpJPEG));\n        jpeg_destroy_decompress(&sDInfo);\n        return CE_Failure;\n    }\n\n    sDInfo.err = jpeg_std_error( &sJErr );\n    sJErr.error_exit = GTIFF_ErrorExitJPEG;\n    sDInfo.client_data = &setjmp_buffer;\n\n    jpeg_create_decompress(&sDInfo);\n\n    // This is to address bug related in ticket #1795.\n    if( CPLGetConfigOption(\"JPEGMEM\", nullptr) == nullptr )\n    {\n        // If the user doesn't provide a value for JPEGMEM, be sure that at\n        // least 500 MB will be used before creating the temporary file.\n        const long nMinMemory = 500 * 1024 * 1024;\n        sDInfo.mem->max_memory_to_use =\n            std::max(sDInfo.mem->max_memory_to_use, nMinMemory);\n    }\n\n    jpeg_vsiio_src( &sDInfo, fpJPEG );\n    jpeg_read_header( &sDInfo, TRUE );\n\n    jvirt_barray_ptr* pSrcCoeffs = jpeg_read_coefficients(&sDInfo);\n\n/* -------------------------------------------------------------------- */\n/*      Compute MCU dimensions                                          */\n/* -------------------------------------------------------------------- */\n    int iMCU_sample_width = 8;\n    int iMCU_sample_height = 8;\n    if( sDInfo.num_components != 1 )\n    {\n        iMCU_sample_width = sDInfo.max_h_samp_factor * 8;\n        iMCU_sample_height = sDInfo.max_v_samp_factor * 8;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get raster and block dimensions                                 */\n/* -------------------------------------------------------------------- */\n    int nBlockXSize = 0;\n    int nBlockYSize = 0;\n\n    const int nXSize = poDS->GetRasterXSize();\n    const int nYSize = poDS->GetRasterYSize();\n    // nBands = poDS->GetRasterCount();\n\n    // Don't use the GDAL block dimensions because of the split-band\n    // mechanism that can expose a pseudo one-line-strip whereas the\n    // real layout is a single big strip.\n\n    TIFF* hTIFF = static_cast<TIFF*>( poDS->GetInternalHandle(nullptr) );\n    if( TIFFIsTiled(hTIFF) )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(nBlockXSize) );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(nBlockYSize) );\n    }\n    else\n    {\n        uint32 nRowsPerStrip = 0;\n        if( !TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP,\n                        &(nRowsPerStrip) ) )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined,\n                      \"RowsPerStrip not defined ... assuming all one strip.\" );\n            nRowsPerStrip = nYSize;  // Dummy value.\n        }\n\n        // If the rows per strip is larger than the file we will get\n        // confused.  libtiff internally will treat the rowsperstrip as\n        // the image height and it is best if we do too. (#4468)\n        if( nRowsPerStrip > static_cast<uint32>(nYSize) )\n            nRowsPerStrip = nYSize;\n\n        nBlockXSize = nXSize;\n        nBlockYSize = nRowsPerStrip;\n    }\n\n    const int nXBlocks = (nXSize + nBlockXSize - 1) / nBlockXSize;\n    const int nYBlocks = (nYSize + nBlockYSize - 1) / nBlockYSize;\n\n/* -------------------------------------------------------------------- */\n/*      Copy blocks.                                                    */\n/* -------------------------------------------------------------------- */\n\n    bShouldFallbackToNormalCopyIfFail = false;\n\n    for( int iY = 0; iY < nYBlocks && eErr == CE_None; iY++ )\n    {\n        for( int iX = 0; iX < nXBlocks && eErr == CE_None; iX++ )\n        {\n            GTIFF_CopyBlockFromJPEGArgs sArgs;\n            sArgs.hTIFF = hTIFF;\n            sArgs.psDInfo = &sDInfo;\n            sArgs.iX = iX;\n            sArgs.iY = iY;\n            sArgs.nXBlocks = nXBlocks;\n            sArgs.nXSize = nXSize;\n            sArgs.nYSize = nYSize;\n            sArgs.nBlockXSize = nBlockXSize;\n            sArgs.nBlockYSize = nBlockYSize;\n            sArgs.iMCU_sample_width = iMCU_sample_width;\n            sArgs.iMCU_sample_height = iMCU_sample_height;\n            sArgs.pSrcCoeffs = pSrcCoeffs;\n\n            eErr = GTIFF_CopyBlockFromJPEG( &sArgs );\n\n            if( !pfnProgress((iY * nXBlocks + iX + 1) * 1.0 /\n                                (nXBlocks * nYBlocks),\n                             nullptr, pProgressData ) )\n                eErr = CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup.                                                        */\n/* -------------------------------------------------------------------- */\n\n    jpeg_finish_decompress( &sDInfo );\n    jpeg_destroy_decompress( &sDInfo );\n\n    if( VSIFCloseL(fpJPEG) != 0 )\n        eErr = CE_Failure;\n\n    return eErr;\n}",
    "bool CxImageTIF::Decode(CxFile * hFile)\r\n{\r\n\t//Comment this line if you need more information on errors\r\n\t// TIFFSetErrorHandler(NULL);\t//<Patrick Hoffmann>\r\n\r\n\t//Open file and fill the TIFF structure\r\n\t// m_tif = TIFFOpen(imageFileName,\"rb\");\r\n\tTIFF* m_tif = _TIFFOpenEx(hFile, \"rb\");\r\n\r\n\tuint32 height=0;\r\n\tuint32 width=0;\r\n\tuint16 bitspersample=1;\r\n\tuint16 samplesperpixel=1;\r\n\tuint32 rowsperstrip=(DWORD)-1;\r\n\tuint16 photometric=0;\r\n\tuint16 compression=1;\r\n\tuint16 orientation=ORIENTATION_TOPLEFT; //<vho>\r\n\tuint16 res_unit; //<Trifon>\r\n\tuint32 x, y;\r\n\tfloat resolution, offset;\r\n\tBOOL isRGB;\r\n\tBYTE *bits;\t\t//pointer to source data\r\n\tBYTE *bits2;\t//pointer to destination data\r\n\r\n  try{\r\n\t//check if it's a tiff file\r\n\tif (!m_tif)\r\n\t\tthrow \"Error encountered while opening TIFF file\";\r\n\r\n\t// <Robert Abram> - 12/2002 : get NumFrames directly, instead of looping\r\n\t// info.nNumFrames=0;\r\n\t// while(TIFFSetDirectory(m_tif,(uint16)info.nNumFrames)) info.nNumFrames++;\r\n\tinfo.nNumFrames = TIFFNumberOfDirectories(m_tif);\r\n\r\n\tif (!TIFFSetDirectory(m_tif, (uint16)info.nFrame))\r\n\t\tthrow \"Error: page not present in TIFF file\";\t\t\t\r\n\r\n\t//get image info\r\n\tTIFFGetField(m_tif, TIFFTAG_IMAGEWIDTH, &width);\r\n\tTIFFGetField(m_tif, TIFFTAG_IMAGELENGTH, &height);\r\n\tTIFFGetField(m_tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\r\n\tTIFFGetField(m_tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\r\n\tTIFFGetField(m_tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);   \r\n\tTIFFGetField(m_tif, TIFFTAG_PHOTOMETRIC, &photometric);\r\n\tTIFFGetField(m_tif, TIFFTAG_ORIENTATION, &orientation);\r\n\r\n\tif (info.nEscape == -1) {\r\n\t\t// Return output dimensions only\r\n\t\thead.biWidth = width;\r\n\t\thead.biHeight = height;\r\n\t\tthrow \"output dimensions returned\";\r\n\t}\r\n\r\n\tTIFFGetFieldDefaulted(m_tif, TIFFTAG_RESOLUTIONUNIT, &res_unit);\r\n\tif (TIFFGetField(m_tif, TIFFTAG_XRESOLUTION, &resolution))\r\n\t{\r\n\t\tif (res_unit == RESUNIT_CENTIMETER) resolution = (float)(resolution*2.54f + 0.5f);\r\n\t\tSetXDPI((long)resolution);\r\n\t}\r\n\tif (TIFFGetField(m_tif, TIFFTAG_YRESOLUTION, &resolution))\r\n\t{\r\n\t\tif (res_unit == RESUNIT_CENTIMETER) resolution = (float)(resolution*2.54f + 0.5f);\r\n\t\tSetYDPI((long)resolution);\r\n\t}\r\n\r\n\tif (TIFFGetField(m_tif, TIFFTAG_XPOSITION, &offset))\tinfo.xOffset = (long)offset;\r\n\tif (TIFFGetField(m_tif, TIFFTAG_YPOSITION, &offset))\tinfo.yOffset = (long)offset;\r\n\r\n\thead.biClrUsed=0;\r\n\tinfo.nBkgndIndex =-1;\r\n\r\n\tif (rowsperstrip>height){\r\n\t\trowsperstrip=height;\r\n\t\tTIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\r\n\t}\r\n\r\n\tisRGB = (bitspersample >= 8) &&\r\n\t\t(photometric == PHOTOMETRIC_RGB) ||\r\n\t\t(photometric == PHOTOMETRIC_YCBCR) ||\r\n\t\t(photometric == PHOTOMETRIC_SEPARATED) ||\r\n\t\t(photometric == PHOTOMETRIC_LOGL) ||\r\n\t\t(photometric == PHOTOMETRIC_LOGLUV);\r\n\r\n\tif (isRGB){\r\n\t\thead.biBitCount=24;\r\n\t}else{\r\n\t\tif ((photometric==PHOTOMETRIC_MINISBLACK)||(photometric==PHOTOMETRIC_MINISWHITE)){\r\n\t\t\tif\t(bitspersample == 1){\r\n\t\t\t\thead.biBitCount=1;\t\t//B&W image\r\n\t\t\t\thead.biClrUsed =2;\r\n\t\t\t} else if (bitspersample == 4) {\r\n\t\t\t\thead.biBitCount=4;\t\t//16 colors gray scale\r\n\t\t\t\thead.biClrUsed =16;\r\n\t\t\t} else {\r\n\t\t\t\thead.biBitCount=8;\t\t//gray scale\r\n\t\t\t\thead.biClrUsed =256;\r\n\t\t\t}\r\n\t\t} else if (bitspersample == 4) {\r\n\t\t\thead.biBitCount=4;\t\t\t// 16 colors\r\n\t\t\thead.biClrUsed=16;\r\n\t\t} else {\r\n\t\t\thead.biBitCount=8;\t\t\t//256 colors\r\n\t\t\thead.biClrUsed=256;\r\n\t\t}\r\n\t}\r\n\r\n\tif (info.nEscape) throw \"Cancelled\"; // <vho> - cancel decoding\r\n\r\n\tCreate(width,height,head.biBitCount,CXIMAGE_FORMAT_TIF);\t//image creation\r\n\tif (!pDib) throw \"CxImageTIF can't create image\";\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (samplesperpixel==4) AlphaCreate();\t//add alpha support for 32bpp tiffs\r\n\tif (samplesperpixel==2 && bitspersample==8) AlphaCreate();\t//add alpha support for 8bpp + alpha\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n\tTIFFGetField(m_tif, TIFFTAG_COMPRESSION, &compression);\r\n\tSetCodecOption(compression); // <DPR> save original compression type\r\n\r\n\tif (isRGB) {\r\n\t\t// Read the whole image into one big RGBA buffer using\r\n\t\t// the traditional TIFFReadRGBAImage() API that we trust.\r\n\t\tuint32* raster;\t\t// retrieve RGBA image\r\n\t\tuint32 *row;\r\n\r\n\t\traster = (uint32*)_TIFFmalloc(width * height * sizeof (uint32));\r\n\t\tif (raster == NULL) throw \"No space for raster buffer\";\r\n\t\t\t\r\n\t\t// Read the image in one chunk into an RGBA array\r\n\t\tif(!TIFFReadRGBAImage(m_tif, width, height, raster, 1)) {\r\n\t\t\t\t_TIFFfree(raster);\r\n\t\t\t\tthrow \"Corrupted TIFF file!\";\r\n\t\t}\r\n\r\n\t\t// read the raster lines and save them in the DIB\r\n\t\t// with RGB mode, we have to change the order of the 3 samples RGB\r\n\t\trow = &raster[0];\r\n\t\tbits2 = info.pImage;\r\n\t\tfor (y = 0; y < height; y++) {\r\n\r\n\t\t\tif (info.nEscape){ // <vho> - cancel decoding\r\n\t\t\t\t_TIFFfree(raster);\r\n\t\t\t\tthrow \"Cancelled\";\r\n\t\t\t}\r\n\r\n\t\t\tbits = bits2;\r\n\t\t\tfor (x = 0; x < width; x++) {\r\n\t\t\t\t*bits++ = (BYTE)TIFFGetB(row[x]);\r\n\t\t\t\t*bits++ = (BYTE)TIFFGetG(row[x]);\r\n\t\t\t\t*bits++ = (BYTE)TIFFGetR(row[x]);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\tif (samplesperpixel==4) AlphaSet(x,y,(BYTE)TIFFGetA(row[x]));\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t}\r\n\t\t\trow += width;\r\n\t\t\tbits2 += info.dwEffWidth;\r\n\t\t}\r\n\t\t_TIFFfree(raster);\r\n\t} else {\r\n\t\tRGBQUAD *pal;\r\n\t\tpal=(RGBQUAD*)calloc(256,sizeof(RGBQUAD));\r\n\t\tif (pal==NULL) throw \"Unable to allocate TIFF palette\";\r\n\r\n\t\t// set up the colormap based on photometric\t\r\n\t\tswitch(photometric) {\r\n\t\t\tcase PHOTOMETRIC_MINISBLACK:\t// bitmap and greyscale image types\r\n\t\t\tcase PHOTOMETRIC_MINISWHITE:\r\n\t\t\t\tif (bitspersample == 1) {\t// Monochrome image\r\n\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISBLACK) {\r\n\t\t\t\t\t\tpal[1].rgbRed = pal[1].rgbGreen = pal[1].rgbBlue = 255;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpal[0].rgbRed = pal[0].rgbGreen = pal[0].rgbBlue = 255;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\t\t// need to build the scale for greyscale images\r\n\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISBLACK) {\r\n\t\t\t\t\t\tfor (DWORD i=0; i<head.biClrUsed; i++){\r\n\t\t\t\t\t\t\tpal[i].rgbRed = pal[i].rgbGreen = pal[i].rgbBlue = (BYTE)(i*(255/(head.biClrUsed-1)));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (DWORD i=0; i<head.biClrUsed; i++){\r\n\t\t\t\t\t\t\tpal[i].rgbRed = pal[i].rgbGreen = pal[i].rgbBlue = (BYTE)(255-i*(255/(head.biClrUsed-1)));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase PHOTOMETRIC_PALETTE:\t// color map indexed\r\n\t\t\t\tuint16 *red;\r\n\t\t\t\tuint16 *green;\r\n\t\t\t\tuint16 *blue;\r\n\t\t\t\tTIFFGetField(m_tif, TIFFTAG_COLORMAP, &red, &green, &blue); \r\n\r\n\t\t\t\t// Is the palette 16 or 8 bits ?\r\n\t\t\t\tBOOL Palette16Bits = FALSE;\r\n\t\t\t\tint n=1<<bitspersample;\r\n\t\t\t\twhile (n-- > 0) {\r\n\t\t\t\t\tif (red[n] >= 256 || green[n] >= 256 || blue[n] >= 256) {\r\n\t\t\t\t\t\tPalette16Bits=TRUE;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// load the palette in the DIB\r\n\t\t\t\tfor (int i = (1 << bitspersample) - 1; i >= 0; i--) {\r\n\t\t\t\t\tif (Palette16Bits) {\r\n\t\t\t\t\t\tpal[i].rgbRed =(BYTE) CVT(red[i]);\r\n\t\t\t\t\t\tpal[i].rgbGreen = (BYTE) CVT(green[i]);\r\n\t\t\t\t\t\tpal[i].rgbBlue = (BYTE) CVT(blue[i]);           \r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpal[i].rgbRed = (BYTE) red[i];\r\n\t\t\t\t\t\tpal[i].rgbGreen = (BYTE) green[i];\r\n\t\t\t\t\t\tpal[i].rgbBlue = (BYTE) blue[i];        \r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tSetPalette(pal,head.biClrUsed);\t//palette assign\r\n\t\tfree(pal);\r\n\r\n\t\t// read the tiff lines and save them in the DIB\r\n\t\tuint32 nrow;\r\n\t\tuint32 ys;\r\n\t\tint line = CalculateLine(width, bitspersample * samplesperpixel);\r\n\t\tlong bitsize= TIFFStripSize(m_tif);\r\n\t\t//verify bitsize: could be wrong if StripByteCounts is missing.\r\n\t\tif (bitsize>(long)(head.biSizeImage*samplesperpixel)) bitsize=head.biSizeImage*samplesperpixel;\r\n\r\n\t\tint tiled_image = TIFFIsTiled(m_tif);\r\n\t\tuint32 tw, tl;\r\n\t\tBYTE* tilebuf;\r\n\t\tif (tiled_image){\r\n\t\t\tTIFFGetField(m_tif, TIFFTAG_TILEWIDTH, &tw);\r\n\t\t\tTIFFGetField(m_tif, TIFFTAG_TILELENGTH, &tl);\r\n\t\t\trowsperstrip = tl;\r\n\t\t\tbitsize = TIFFTileSize(m_tif) * (int)(1+width/tw);\r\n\t\t\ttilebuf = (BYTE*)malloc(TIFFTileSize(m_tif));\r\n\t\t}\r\n\t\t\r\n\t\tbits = (BYTE*)malloc(bitsize);\r\n\t\tif (bits==NULL){\r\n\t\t\tthrow \"CxImageTIF can't allocate memory\";\r\n\t\t}\r\n\r\n\t\tfor (ys = 0; ys < height; ys += rowsperstrip) {\r\n\r\n\t\t\tif (info.nEscape){ // <vho> - cancel decoding\r\n\t\t\t\tfree(bits);\r\n\t\t\t\tthrow \"Cancelled\";\r\n\t\t\t}\r\n\r\n\t\t\tnrow = (ys + rowsperstrip > height ? height - ys : rowsperstrip);\r\n\r\n\t\t\tif (tiled_image){\r\n\t\t\t\tuint32 imagew = TIFFScanlineSize(m_tif);\r\n\t\t\t\tuint32 tilew  = TIFFTileRowSize(m_tif);\r\n\t\t\t\tint iskew = imagew - tilew;\r\n\t\t\t\tuint8* bufp = (uint8*) bits;\r\n\r\n\t\t\t\tuint32 colb = 0;\r\n\t\t\t\tfor (uint32 col = 0; col < width; col += tw) {\r\n\t\t\t\t\tif (TIFFReadTile(m_tif, tilebuf, col, ys, 0, 0) < 0){\r\n\t\t\t\t\t\tfree(tilebuf);\r\n\t\t\t\t\t\tfree(bits);\r\n\t\t\t\t\t\tthrow \"Corrupted tiled TIFF file!\";\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (colb + tw > imagew) {\r\n\t\t\t\t\t\tuint32 owidth = imagew - colb;\r\n\t\t\t\t\t\tuint32 oskew = tilew - owidth;\r\n\t\t\t\t\t\tTileToStrip(bufp + colb, tilebuf, nrow, owidth, oskew + iskew, oskew );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tTileToStrip(bufp + colb, tilebuf, nrow, tilew, iskew, 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcolb += tilew;\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\t\t\t\tif (TIFFReadEncodedStrip(m_tif, TIFFComputeStrip(m_tif, ys, 0), bits, nrow * line) == -1) {\r\n\t\t\t\t\tfree(bits);\r\n\t\t\t\t\tthrow \"Corrupted TIFF file!\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor (y = 0; y < nrow; y++) {\r\n\t\t\t\tlong offset=(nrow-y-1)*line;\r\n\t\t\t\tif (bitspersample==16) for (DWORD xi=0;xi<width;xi++) bits[xi+offset]=bits[xi*2+offset+1];\r\n\t\t\t\tif (samplesperpixel==1) { //simple 8bpp image\r\n\t\t\t\t\tmemcpy(info.pImage+info.dwEffWidth*(height-ys-nrow+y),bits+offset,info.dwEffWidth);\r\n\t\t\t\t} else if (samplesperpixel==2) { //8bpp image with alpha layer\r\n\t\t\t\t\tint xi=0;\r\n\t\t\t\t\tint ii=0;\r\n\t\t\t\t\tint yi=height-ys-nrow+y;\r\n\t\t\t\t\twhile (ii<line){\r\n\t\t\t\t\t\tSetPixelIndex(xi,yi,bits[ii+offset]);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tAlphaSet(xi,yi,bits[ii+offset+1]);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tii+=2;\r\n\t\t\t\t\t\txi++;\r\n\t\t\t\t\t\tif (xi>=(int)width){\r\n\t\t\t\t\t\t\tyi--;\r\n\t\t\t\t\t\t\txi=0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { //photometric==PHOTOMETRIC_CIELAB\r\n\t\t\t\t\tif (head.biBitCount!=24){ //fix image\r\n\t\t\t\t\t\tCreate(width,height,24,CXIMAGE_FORMAT_TIF);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tif (samplesperpixel==4) AlphaCreate();\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tint xi=0;\r\n\t\t\t\t\tint ii=0;\r\n\t\t\t\t\tint yi=height-ys-nrow+y;\r\n\t\t\t\t\tRGBQUAD c;\r\n\t\t\t\t\tint l,a,b,bitsoffset;\r\n\t\t\t\t\tdouble p,cx,cy,cz,cr,cg,cb;\r\n\t\t\t\t\twhile (ii<line){\r\n\t\t\t\t\t\tbitsoffset = ii*samplesperpixel+offset;\r\n\t\t\t\t\t\tl=bits[bitsoffset];\r\n\t\t\t\t\t\ta=bits[bitsoffset+1];\r\n\t\t\t\t\t\tb=bits[bitsoffset+2];\r\n\t\t\t\t\t\tif (a>127) a-=256;\r\n\t\t\t\t\t\tif (b>127) b-=256;\r\n\t\t\t\t\t\t// lab to xyz\r\n\t\t\t\t\t\tp = (l/2.55 + 16) / 116.0;\r\n\t\t\t\t\t\tcx = pow( p + a * 0.002, 3);\r\n\t\t\t\t\t\tcy = pow( p, 3);\r\n\t\t\t\t\t\tcz = pow( p - b * 0.005, 3);\r\n\t\t\t\t\t\t// white point\r\n\t\t\t\t\t\tcx*=0.95047;\r\n\t\t\t\t\t\t//cy*=1.000;\r\n\t\t\t\t\t\tcz*=1.0883;\r\n\t\t\t\t\t\t// xyz to rgb\r\n\t\t\t\t\t\tcr =  3.240479 * cx - 1.537150 * cy - 0.498535 * cz;\r\n\t\t\t\t\t\tcg = -0.969256 * cx + 1.875992 * cy + 0.041556 * cz;\r\n\t\t\t\t\t\tcb =  0.055648 * cx - 0.204043 * cy + 1.057311 * cz;\r\n\r\n\t\t\t\t\t\tif ( cr > 0.00304 ) cr = 1.055 * pow(cr,0.41667) - 0.055;\r\n\t\t\t\t\t\t\telse            cr = 12.92 * cr;\r\n\t\t\t\t\t\tif ( cg > 0.00304 ) cg = 1.055 * pow(cg,0.41667) - 0.055;\r\n\t\t\t\t\t\t\telse            cg = 12.92 * cg;\r\n\t\t\t\t\t\tif ( cb > 0.00304 ) cb = 1.055 * pow(cb,0.41667) - 0.055;\r\n\t\t\t\t\t\t\telse            cb = 12.92 * cb;\r\n\r\n\t\t\t\t\t\tc.rgbRed  =(BYTE)max(0,min(255,(int)(cr*255)));\r\n\t\t\t\t\t\tc.rgbGreen=(BYTE)max(0,min(255,(int)(cg*255)));\r\n\t\t\t\t\t\tc.rgbBlue =(BYTE)max(0,min(255,(int)(cb*255)));\r\n\r\n\t\t\t\t\t\tSetPixelColor(xi,yi,c);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tif (samplesperpixel==4) AlphaSet(xi,yi,bits[bitsoffset+3]);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tii++;\r\n\t\t\t\t\t\txi++;\r\n\t\t\t\t\t\tif (xi>=(int)width){\r\n\t\t\t\t\t\t\tyi--;\r\n\t\t\t\t\t\t\txi=0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfree(bits);\r\n\t\tif (tiled_image) free(tilebuf);\r\n\r\n\t\tswitch(orientation){\r\n\t\tcase ORIENTATION_TOPRIGHT: /* row 0 top, col 0 rhs */\r\n\t\t\tMirror();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_BOTRIGHT: /* row 0 bottom, col 0 rhs */\r\n\t\t\tFlip();\r\n\t\t\tMirror();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_BOTLEFT: /* row 0 bottom, col 0 lhs */\r\n\t\t\tFlip();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_LEFTTOP: /* row 0 lhs, col 0 top */\r\n\t\t\tRotateRight();\r\n\t\t\tMirror();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_RIGHTTOP: /* row 0 rhs, col 0 top */\r\n\t\t\tRotateLeft();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_RIGHTBOT: /* row 0 rhs, col 0 bottom */\r\n\t\t\tRotateLeft();\r\n\t\t\tMirror();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_LEFTBOT: /* row 0 lhs, col 0 bottom */\r\n\t\t\tRotateRight();\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t}\r\n  } catch (char *message) {\r\n\t  strncpy(info.szLastError,message,255);\r\n\t  if (m_tif) TIFFClose(m_tif);\r\n\t  if (info.nEscape==-1) return true;\r\n\t  return false;\r\n  }\r\n\tTIFFClose(m_tif);\r\n\treturn true;\r\n}",
    "ref<Image> vl::loadTIFF(VirtualFile* file)\r\n{\r\n  file->open(OM_ReadOnly);\r\n  ref<Image> img = new Image;\r\n\r\n  TIFFSetErrorHandler(tiff_error);\r\n  TIFFSetWarningHandler(tiff_warning);\r\n\r\n  TIFF* tif = TIFFClientOpen(\"tiffread\", \"r\", reinterpret_cast<thandle_t>(file),\r\n                tiff_io_read_func,\r\n                tiff_io_write_func,\r\n                tiff_io_seek_func,\r\n                tiff_io_close_func,\r\n                tiff_io_size_func,\r\n                tiff_io_map_func,\r\n                tiff_io_unmap_func);\r\n\r\n  if (tif)\r\n  {\r\n    uint32 w, h;\r\n    size_t npixels;\r\n    uint32* raster;\r\n\r\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\r\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\r\n    npixels = w * h;\r\n    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\r\n    if (raster != NULL)\r\n    {\r\n      if (TIFFReadRGBAImage(tif, w, h, raster, 0))\r\n      {\r\n        img->allocate2D(w,h,1,vl::IF_RGBA,vl::IT_UNSIGNED_BYTE);\r\n        memcpy(img->pixels(), raster, img->requiredMemory());\r\n      }\r\n      _TIFFfree(raster);\r\n    }\r\n    uint16 orientation = ORIENTATION_TOPLEFT; // default\r\n    TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation);\r\n    if (orientation == ORIENTATION_LEFTBOT )\r\n      img->flipVertically();\r\n    TIFFClose(tif);\r\n  }\r\n\r\n  file->close();\r\n  return img;\r\n}",
    "ByteImage::Ptr\nload_tiff_file (std::string const& filename)\n{\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetErrorHandler(tiff_error_handler);\n\n    TIFF* tif = TIFFOpen(filename.c_str(), \"r\");\n    if (!tif)\n        throw util::Exception(\"TIFF file format not recognized\");\n\n    try\n    {\n        /* Read width and height from TIFF and create MVE image. */\n        uint32 width, height;\n        uint16 channels, bits;\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n        if (bits != 8)\n            throw util::Exception(\"Expected 8 bit TIFF file\");\n        ByteImage::Ptr image = ByteImage::create(width, height, channels);\n\n        /* Scanline based TIFF reading. */\n        uint32 rowstride = TIFFScanlineSize(tif);\n        ByteImage::ImageData& data = image->get_data();\n        for (uint32 row = 0; row < height; row++)\n        {\n            tdata_t row_pointer = &data[row * rowstride];\n            TIFFReadScanline(tif, row_pointer, row);\n        }\n\n        TIFFClose(tif);\n        return image;\n    }\n    catch (std::exception& e)\n    {\n        TIFFClose(tif);\n        throw;\n    }\n}",
    "RawImage::Ptr\nload_tiff_16_file (std::string const& filename)\n{\n    if (sizeof(uint16_t) != 2)\n        throw util::Exception(\"Need 16bit data type for TIFF image.\");\n\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetErrorHandler(tiff_error_handler);\n\n    TIFF* tif = TIFFOpen(filename.c_str(), \"r\");\n    if (!tif)\n        throw util::Exception(\"TIFF file format not recognized\");\n\n    try\n    {\n        /* Read width and height from TIFF and create MVE image. */\n        uint32 width, height;\n        uint16 channels, bits;\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n        if (bits != 16)\n            throw util::Exception(\"TIFF file bits per sample don't match\");\n\n        RawImage::Ptr image = Image<uint16_t>::create(width, height, channels);\n\n        /* Scanline based TIFF reading. */\n        uint32 rowstride = TIFFScanlineSize(tif) / sizeof(uint16_t);\n        Image<uint16_t>::ImageData& data = image->get_data();\n        for (uint32 row = 0; row < height; row++)\n        {\n            tdata_t row_pointer = &data[row * rowstride];\n            TIFFReadScanline(tif, row_pointer, row);\n        }\n\n        TIFFClose(tif);\n        return image;\n    }\n    catch (std::exception& e)\n    {\n        TIFFClose(tif);\n        throw;\n    }\n}",
    "bool ImageReaderTIFF::readHeader()\n{\n\tTIFFSetErrorHandler(TIFFSilentWarningHandler);\n\tTIFFSetWarningHandler(TIFFSilentWarningHandler);\n\t// Don't allow memory mapping, read only.\n\tm_Tiff = TIFFClientOpen(\"None\", \"rm\", m_Source, tiffRead, tiffWrite, tiffSeek, tiffClose, tiffSize, tiffMap, tiffUnmap);\n\tint width = 0;\n\tint height = 0;\n\tif( m_Tiff == NULL ) {\n\t\treturn false;\n\t}\n\tif( TIFFGetField(m_Tiff, TIFFTAG_IMAGEWIDTH, &width) == 0 || TIFFGetField(m_Tiff, TIFFTAG_IMAGELENGTH, &height) == 0 ) {\n\t\treturn false;\n\t}\n\tm_Width = width > 0 ? width : 0;\n\tm_Height = height > 0 ? height : 0;\n\treturn true;\n}",
    "void Image::readTiff(\n  const char* p_name,\n  const size_t i_border) {\n\n  //! Open the tiff file\n  TIFF *tif = TIFFOpen(p_name, \"r\");\n\n  //! Check that the file has been open\n  if (!tif) {\n    cout << \"Unable to read TIFF file \" << p_name << \". Abort.\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  //! Initialization\n  uint32 w = 0, h = 0;\n  uint16 spp = 0, bps = 0, fmt = 0;\n\n  //! Get the metadata\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n  TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &fmt);\n\n  //! Check the metadata\n  if (spp != 1 || bps != (uint16) sizeof(float) * 8 ||\n      fmt != SAMPLEFORMAT_IEEEFP) {\n    cout << \"readTiff: metadata non-conform. Abort.\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  //! Allocate the image\n  new (this) Image(w, h, 1, i_border);\n\n  //! Read the values\n  for (size_t i = 0; i < m_height; i++) {\n    float* oI = this->getPtr(0, i);\n    if (TIFFReadScanline(tif, oI, i, 0) < 0) {\n      cout << \"readTiff: error reading row \" << i << endl;\n      exit(EXIT_FAILURE);\n    }\n  }\n\n  //! Close the file\n  TIFFClose(tif);\n}",
    "GTiffGrid::GTiffGrid(PJ_CONTEXT *ctx, TIFF *hTIFF, BlockCache &cache, File *fp,\n                     uint32 ifdIdx, const std::string &nameIn, int widthIn,\n                     int heightIn, const ExtentAndRes &extentIn,\n                     TIFFDataType dtIn, uint16 samplesPerPixelIn,\n                     uint16 planarConfig, bool bottomUpIn)\n    : Grid(nameIn, widthIn, heightIn, extentIn), m_ctx(ctx), m_hTIFF(hTIFF),\n      m_cache(cache), m_fp(fp), m_ifdIdx(ifdIdx), m_dt(dtIn),\n      m_samplesPerPixel(samplesPerPixelIn), m_planarConfig(planarConfig),\n      m_bottomUp(bottomUpIn), m_dirOffset(TIFFCurrentDirOffset(hTIFF)),\n      m_tiled(TIFFIsTiled(hTIFF) != 0) {\n\n    if (m_tiled) {\n        TIFFGetField(m_hTIFF, TIFFTAG_TILEWIDTH, &m_blockWidth);\n        TIFFGetField(m_hTIFF, TIFFTAG_TILELENGTH, &m_blockHeight);\n    } else {\n        m_blockWidth = widthIn;\n        TIFFGetField(m_hTIFF, TIFFTAG_ROWSPERSTRIP, &m_blockHeight);\n        if (m_blockHeight > static_cast<unsigned>(m_height))\n            m_blockHeight = m_height;\n    }\n\n    TIFFGetField(m_hTIFF, TIFFTAG_SUBFILETYPE, &m_subfileType);\n\n    m_blocksPerRow = (m_width + m_blockWidth - 1) / m_blockWidth;\n    m_blocksPerCol = (m_height + m_blockHeight - 1) / m_blockHeight;\n\n    const char *text = nullptr;\n    // Poor-man XML parsing of TIFFTAG_GDAL_METADATA tag. Hopefully good\n    // enough for our purposes.\n    if (TIFFGetField(m_hTIFF, TIFFTAG_GDAL_METADATA, &text)) {\n        const char *ptr = text;\n        while (true) {\n            ptr = strstr(ptr, \"<Item \");\n            if (ptr == nullptr)\n                break;\n            const char *endTag = strchr(ptr, '>');\n            if (endTag == nullptr)\n                break;\n            const char *endValue = strchr(endTag, '<');\n            if (endValue == nullptr)\n                break;\n\n            std::string tag;\n            tag.append(ptr, endTag - ptr);\n\n            std::string value;\n            value.append(endTag + 1, endValue - (endTag + 1));\n\n            std::string gridName;\n            auto namePos = tag.find(\"name=\\\"\");\n            if (namePos == std::string::npos)\n                break;\n            {\n                namePos += strlen(\"name=\\\"\");\n                const auto endQuote = tag.find('\"', namePos);\n                if (endQuote == std::string::npos)\n                    break;\n                gridName = tag.substr(namePos, endQuote - namePos);\n            }\n\n            const auto samplePos = tag.find(\"sample=\\\"\");\n            int sample = -1;\n            if (samplePos != std::string::npos) {\n                sample = atoi(tag.c_str() + samplePos + strlen(\"sample=\\\"\"));\n            }\n\n            m_metadata[std::pair<int, std::string>(sample, gridName)] = value;\n\n            auto rolePos = tag.find(\"role=\\\"\");\n            if (rolePos != std::string::npos) {\n                rolePos += strlen(\"role=\\\"\");\n                const auto endQuote = tag.find('\"', rolePos);\n                if (endQuote == std::string::npos)\n                    break;\n                const auto role = tag.substr(rolePos, endQuote - rolePos);\n                if (role == \"offset\") {\n                    if (sample >= 0) {\n                        try {\n                            m_mapOffset[sample] = c_locale_stod(value);\n                        } catch (const std::exception &) {\n                        }\n                    }\n                } else if (role == \"scale\") {\n                    if (sample >= 0) {\n                        try {\n                            m_mapScale[sample] = c_locale_stod(value);\n                        } catch (const std::exception &) {\n                        }\n                    }\n                }\n            }\n\n            ptr = endValue + 1;\n        }\n    }\n\n    if (TIFFGetField(m_hTIFF, TIFFTAG_GDAL_NODATA, &text)) {\n        try {\n            m_noData = static_cast<float>(c_locale_stod(text));\n            m_hasNodata = true;\n        } catch (const std::exception &) {\n        }\n    }\n\n    auto oIter = m_metadata.find(std::pair<int, std::string>(-1, \"grid_name\"));\n    if (oIter != m_metadata.end()) {\n        m_name += \", \" + oIter->second;\n    }\n}",
    "std::unique_ptr<GTiffGrid> GTiffDataset::nextGrid() {\n    if (!m_hasNextGrid)\n        return nullptr;\n    if (m_nextDirOffset) {\n        TIFFSetSubDirectory(m_hTIFF, m_nextDirOffset);\n    }\n\n    uint32 width = 0;\n    uint32 height = 0;\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGELENGTH, &height);\n    if (width == 0 || height == 0 || width > INT_MAX || height > INT_MAX) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Invalid image size\");\n        return nullptr;\n    }\n\n    uint16 samplesPerPixel = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Missing SamplesPerPixel tag\");\n        return nullptr;\n    }\n    if (samplesPerPixel == 0) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Invalid SamplesPerPixel value\");\n        return nullptr;\n    }\n\n    uint16 bitsPerSample = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_BITSPERSAMPLE, &bitsPerSample)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Missing BitsPerSample tag\");\n        return nullptr;\n    }\n\n    uint16 planarConfig = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PLANARCONFIG, &planarConfig)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Missing PlanarConfig tag\");\n        return nullptr;\n    }\n\n    uint16 sampleFormat = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLEFORMAT, &sampleFormat)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Missing SampleFormat tag\");\n        return nullptr;\n    }\n\n    TIFFDataType dt;\n    if (sampleFormat == SAMPLEFORMAT_INT && bitsPerSample == 16)\n        dt = TIFFDataType::Int16;\n    else if (sampleFormat == SAMPLEFORMAT_UINT && bitsPerSample == 16)\n        dt = TIFFDataType::UInt16;\n    else if (sampleFormat == SAMPLEFORMAT_INT && bitsPerSample == 32)\n        dt = TIFFDataType::Int32;\n    else if (sampleFormat == SAMPLEFORMAT_UINT && bitsPerSample == 32)\n        dt = TIFFDataType::UInt32;\n    else if (sampleFormat == SAMPLEFORMAT_IEEEFP && bitsPerSample == 32)\n        dt = TIFFDataType::Float32;\n    else if (sampleFormat == SAMPLEFORMAT_IEEEFP && bitsPerSample == 64)\n        dt = TIFFDataType::Float64;\n    else {\n        pj_log(\n            m_ctx, PJ_LOG_ERROR,\n            \"Unsupported combination of SampleFormat and BitsPerSample values\");\n        return nullptr;\n    }\n\n    uint16 photometric = PHOTOMETRIC_MINISBLACK;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PHOTOMETRIC, &photometric))\n        photometric = PHOTOMETRIC_MINISBLACK;\n    if (photometric != PHOTOMETRIC_MINISBLACK) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Unsupported Photometric value\");\n        return nullptr;\n    }\n\n    uint16 compression = COMPRESSION_NONE;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_COMPRESSION, &compression))\n        compression = COMPRESSION_NONE;\n\n    if (compression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(compression)) {\n        pj_log(m_ctx, PJ_LOG_ERROR,\n               \"Cannot open TIFF file due to missing codec.\");\n        return nullptr;\n    }\n    // We really don't want to try dealing with old-JPEG images\n    if (compression == COMPRESSION_OJPEG) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Unsupported compression method.\");\n        return nullptr;\n    }\n\n    const auto blockSize = TIFFIsTiled(m_hTIFF) ? TIFFTileSize64(m_hTIFF)\n                                                : TIFFStripSize64(m_hTIFF);\n    if (blockSize == 0 || blockSize > 64 * 1024 * 2014) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Unsupported block size.\");\n        return nullptr;\n    }\n\n    unsigned short count = 0;\n    unsigned short *geokeys = nullptr;\n    bool pixelIsArea = false;\n\n    ExtentAndRes extent;\n    extent.isGeographic = true;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_GEOKEYDIRECTORY, &count, &geokeys)) {\n        pj_log(m_ctx, PJ_LOG_DEBUG_MINOR, \"No GeoKeys tag\");\n    } else {\n        if (count < 4 || (count % 4) != 0) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   \"Wrong number of values in GeoKeys tag\");\n            return nullptr;\n        }\n\n        if (geokeys[0] != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, \"Unsupported GeoTIFF major version\");\n            return nullptr;\n        }\n        // We only know that we support GeoTIFF 1.0 and 1.1 at that time\n        if (geokeys[1] != 1 || geokeys[2] > 1) {\n            pj_log(m_ctx, PJ_LOG_DEBUG_MINOR,\n                   \"GeoTIFF %d.%d possibly not handled\", geokeys[1],\n                   geokeys[2]);\n        }\n\n        for (unsigned int i = 4; i + 3 < count; i += 4) {\n            constexpr unsigned short GTModelTypeGeoKey = 1024;\n            constexpr unsigned short ModelTypeProjected = 1;\n            constexpr unsigned short ModelTypeGeographic = 2;\n\n            constexpr unsigned short GTRasterTypeGeoKey = 1025;\n            constexpr unsigned short RasterPixelIsArea = 1;\n            // constexpr unsigned short RasterPixelIsPoint = 2;\n\n            if (geokeys[i] == GTModelTypeGeoKey) {\n                if (geokeys[i + 3] == ModelTypeProjected) {\n                    extent.isGeographic = false;\n                } else if (geokeys[i + 3] != ModelTypeGeographic) {\n                    pj_log(m_ctx, PJ_LOG_ERROR,\n                           \"Only GTModelTypeGeoKey = \"\n                           \"ModelTypeGeographic or ModelTypeProjected are \"\n                           \"supported\");\n                    return nullptr;\n                }\n            } else if (geokeys[i] == GTRasterTypeGeoKey) {\n                if (geokeys[i + 3] == RasterPixelIsArea) {\n                    pixelIsArea = true;\n                }\n            }\n        }\n    }\n\n    double hRes = 0;\n    double vRes = 0;\n    double west = 0;\n    double north = 0;\n\n    double *matrix = nullptr;\n    if (TIFFGetField(m_hTIFF, TIFFTAG_GEOTRANSMATRIX, &count, &matrix) &&\n        count == 16) {\n        // If using GDAL to produce a bottom-up georeferencing, it will produce\n        // a GeoTransformationMatrix, since negative values in GeoPixelScale\n        // have historically been implementation bugs.\n        if (matrix[1] != 0 || matrix[4] != 0) {\n            pj_log(m_ctx, PJ_LOG_ERROR, \"Rotational terms not supported in \"\n                                        \"GeoTransformationMatrix tag\");\n            return nullptr;\n        }\n\n        west = matrix[3];\n        hRes = matrix[0];\n        north = matrix[7];\n        vRes = -matrix[5]; // negation to simulate GeoPixelScale convention\n    } else {\n        double *geopixelscale = nullptr;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_GEOPIXELSCALE, &count,\n                         &geopixelscale) != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, \"No GeoPixelScale tag\");\n            return nullptr;\n        }\n        if (count != 3) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   \"Wrong number of values in GeoPixelScale tag\");\n            return nullptr;\n        }\n        hRes = geopixelscale[0];\n        vRes = geopixelscale[1];\n\n        double *geotiepoints = nullptr;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_GEOTIEPOINTS, &count,\n                         &geotiepoints) != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, \"No GeoTiePoints tag\");\n            return nullptr;\n        }\n        if (count != 6) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   \"Wrong number of values in GeoTiePoints tag\");\n            return nullptr;\n        }\n\n        west = geotiepoints[3] - geotiepoints[0] * hRes;\n        north = geotiepoints[4] + geotiepoints[1] * vRes;\n    }\n\n    if (pixelIsArea) {\n        west += 0.5 * hRes;\n        north -= 0.5 * vRes;\n    }\n\n    const double mulFactor = extent.isGeographic ? DEG_TO_RAD : 1;\n    extent.west = west * mulFactor;\n    extent.north = north * mulFactor;\n    extent.resX = hRes * mulFactor;\n    extent.resY = fabs(vRes) * mulFactor;\n    extent.east = (west + hRes * (width - 1)) * mulFactor;\n    extent.south = (north - vRes * (height - 1)) * mulFactor;\n\n    if (vRes < 0) {\n        std::swap(extent.north, extent.south);\n    }\n\n    if (!((!extent.isGeographic ||\n           (fabs(extent.west) <= 4 * M_PI && fabs(extent.east) <= 4 * M_PI &&\n            fabs(extent.north) <= M_PI + 1e-5 &&\n            fabs(extent.south) <= M_PI + 1e-5)) &&\n          extent.west < extent.east && extent.south < extent.north &&\n          extent.resX > 1e-10 && extent.resY > 1e-10)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Inconsistent georeferencing for %s\",\n               m_filename.c_str());\n        return nullptr;\n    }\n\n    auto ret = std::unique_ptr<GTiffGrid>(new GTiffGrid(\n        m_ctx, m_hTIFF, m_cache, m_fp.get(), m_ifdIdx, m_filename, width,\n        height, extent, dt, samplesPerPixel, planarConfig, vRes < 0));\n    m_ifdIdx++;\n    m_hasNextGrid = TIFFReadDirectory(m_hTIFF) != 0;\n    m_nextDirOffset = TIFFCurrentDirOffset(m_hTIFF);\n    return ret;\n}",
    "GTiffRasterBand::GTiffRasterBand( GTiffDataset *poDSIn, int nBandIn ):\n    m_poGDS(poDSIn)\n{\n    poDS = poDSIn;\n    nBand = nBandIn;\n\n/* -------------------------------------------------------------------- */\n/*      Get the GDAL data type.                                         */\n/* -------------------------------------------------------------------- */\n    const uint16 nBitsPerSample = m_poGDS->m_nBitsPerSample;\n    const uint16 nSampleFormat = m_poGDS->m_nSampleFormat;\n\n    eDataType = GDT_Unknown;\n\n    if( nBitsPerSample <= 8 )\n    {\n        eDataType = GDT_Byte;\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            m_oGTiffMDMD.SetMetadataItem( \"PIXELTYPE\", \"SIGNEDBYTE\",\n                                        \"IMAGE_STRUCTURE\" );\n    }\n    else if( nBitsPerSample <= 16 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int16;\n        else\n            eDataType = GDT_UInt16;\n    }\n    else if( nBitsPerSample == 32 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt16;\n        else if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float32;\n        else if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int32;\n        else\n            eDataType = GDT_UInt32;\n    }\n    else if( nBitsPerSample == 64 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float64;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat32;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt32;\n    }\n    else if( nBitsPerSample == 128 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat64;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try to work out band color interpretation.                      */\n/* -------------------------------------------------------------------- */\n    bool bLookForExtraSamples = false;\n\n    if( m_poGDS->m_poColorTable != nullptr && nBand == 1 )\n    {\n        m_eBandInterp = GCI_PaletteIndex;\n    }\n    else if( m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB\n             || (m_poGDS->m_nPhotometric == PHOTOMETRIC_YCBCR\n                 && m_poGDS->m_nCompression == COMPRESSION_JPEG\n                 && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                    \"YES\") )) )\n    {\n        if( nBand == 1 )\n            m_eBandInterp = GCI_RedBand;\n        else if( nBand == 2 )\n            m_eBandInterp = GCI_GreenBand;\n        else if( nBand == 3 )\n            m_eBandInterp = GCI_BlueBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( m_poGDS->m_nPhotometric == PHOTOMETRIC_YCBCR )\n    {\n        if( nBand == 1 )\n            m_eBandInterp = GCI_YCbCr_YBand;\n        else if( nBand == 2 )\n            m_eBandInterp = GCI_YCbCr_CbBand;\n        else if( nBand == 3 )\n            m_eBandInterp = GCI_YCbCr_CrBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( m_poGDS->m_nPhotometric == PHOTOMETRIC_SEPARATED )\n    {\n        if( nBand == 1 )\n            m_eBandInterp = GCI_CyanBand;\n        else if( nBand == 2 )\n            m_eBandInterp = GCI_MagentaBand;\n        else if( nBand == 3 )\n            m_eBandInterp = GCI_YellowBand;\n        else if( nBand == 4 )\n            m_eBandInterp = GCI_BlackBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISBLACK && nBand == 1 )\n    {\n        m_eBandInterp = GCI_GrayIndex;\n    }\n    else\n    {\n        bLookForExtraSamples = true;\n    }\n\n    if( bLookForExtraSamples )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n\n        if( TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            const int nBaseSamples = m_poGDS->m_nSamplesPerPixel - count;\n            const int nExpectedBaseSamples =\n                (m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISBLACK) ? 1 :\n                (m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISWHITE) ? 1 :\n                (m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB) ? 3 :\n                (m_poGDS->m_nPhotometric == PHOTOMETRIC_YCBCR) ? 3 :\n                (m_poGDS->m_nPhotometric == PHOTOMETRIC_SEPARATED) ? 4 : 0;\n\n            if( nExpectedBaseSamples > 0 &&\n                nBand == nExpectedBaseSamples + 1 &&\n                nBaseSamples != nExpectedBaseSamples )\n            {\n                ReportError(CE_Warning, CPLE_AppDefined,\n                         \"Wrong number of ExtraSamples : %d. %d were expected\",\n                         count, m_poGDS->m_nSamplesPerPixel - nExpectedBaseSamples);\n            }\n\n            if( nBand > nBaseSamples\n                && nBand-nBaseSamples-1 < count\n                && (v[nBand-nBaseSamples-1] == EXTRASAMPLE_ASSOCALPHA\n                    || v[nBand-nBaseSamples-1] == EXTRASAMPLE_UNASSALPHA) )\n                m_eBandInterp = GCI_AlphaBand;\n            else\n                m_eBandInterp = GCI_Undefined;\n        }\n        else\n        {\n            m_eBandInterp = GCI_Undefined;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Establish block size for strip or tiles.                        */\n/* -------------------------------------------------------------------- */\n    nBlockXSize = m_poGDS->m_nBlockXSize;\n    nBlockYSize = m_poGDS->m_nBlockYSize;\n}",
    "int GTiffRasterBand::DirectIO( GDALRWFlag eRWFlag,\n                               int nXOff, int nYOff, int nXSize, int nYSize,\n                               void * pData, int nBufXSize, int nBufYSize,\n                               GDALDataType eBufType,\n                               GSpacing nPixelSpace, GSpacing nLineSpace,\n                               GDALRasterIOExtraArg* psExtraArg )\n{\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(eRWFlag == GF_Read &&\n          m_poGDS->m_nCompression == COMPRESSION_NONE &&\n          (m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB ||\n           m_poGDS->m_nPhotometric == PHOTOMETRIC_PALETTE) &&\n          m_poGDS->m_nBitsPerSample == nDTSizeBits) )\n    {\n        return -1;\n    }\n    m_poGDS->Crystalize();\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) &&\n        psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"DirectIO(%d,%d,%d,%d -> %dx%d)\",\n              nXOff, nYOff, nXSize, nYSize,\n              nBufXSize, nBufYSize );\n#endif\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( m_poGDS->GetAccess() == GA_Update )\n    {\n        m_poGDS->FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( m_poGDS->m_hTIFF ) );\n    }\n\n    if( TIFFIsTiled( m_poGDS->m_hTIFF ) )\n    {\n        const int nDTSize = nDTSizeBits / 8;\n        const size_t nTempBufferForCommonDirectIOSize =\n                static_cast<size_t>(\n                    static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize * nDTSize *\n                    (m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG ?\n                     m_poGDS->nBands : 1) );\n        if( m_poGDS->m_pTempBufferForCommonDirectIO == nullptr )\n        {\n            m_poGDS->m_pTempBufferForCommonDirectIO =\n                static_cast<GByte *>( VSI_MALLOC_VERBOSE(\n                    nTempBufferForCommonDirectIOSize ) );\n            if( m_poGDS->m_pTempBufferForCommonDirectIO == nullptr )\n                return CE_Failure;\n        }\n\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_poGDS->m_hTIFF ));\n        FetchBufferDirectIO oFetcher(fp, m_poGDS->m_pTempBufferForCommonDirectIO,\n                                     nTempBufferForCommonDirectIOSize);\n\n        return m_poGDS->CommonDirectIO(\n            oFetcher,\n            nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize,\n            eBufType,\n            1, &nBand,\n            nPixelSpace, nLineSpace,\n            0 );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    // TODO(schwehr): Make ppData be GByte**.\n    void** ppData = static_cast<void **>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void*)) );\n    vsi_l_offset* panOffsets = static_cast<vsi_l_offset *>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)) );\n    size_t* panSizes = static_cast<size_t *>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)) );\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void* pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands =\n        m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG ? m_poGDS->nBands : 1;\n    int nSrcPixelSize = nDTSize * nContigBands;\n\n    if( ppData == nullptr || panOffsets == nullptr || panSizes == nullptr )\n        eErr = CE_Failure;\n    else if( nXSize != nBufXSize || nYSize != nBufYSize ||\n             eBufType != eDataType ||\n             nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n             nContigBands > 1 )\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC_VERBOSE(nReqXSize * nReqYSize * nSrcPixelSize);\n        if( pTmpBuffer == nullptr )\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    for( int iLine = 0; eErr == CE_None && iLine < nReqYSize; ++iLine )\n    {\n        if( pTmpBuffer == nullptr )\n            ppData[iLine] = static_cast<GByte *>(pData) + iLine * nLineSpace;\n        else\n            ppData[iLine] =\n                static_cast<GByte *>(pTmpBuffer) +\n                iLine * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if( nBufYSize < nYSize )  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast<int>((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n        if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            nBlockId += (nBand-1) * m_poGDS->m_nBlocksPerBand;\n        }\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if( panOffsets[iLine] == 0 )  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff + nYOffsetInBlock * nBlockXSize) * nSrcPixelSize;\n        panSizes[iLine] = nReqXSize * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if( eErr == CE_None )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_poGDS->m_hTIFF ));\n        const int nRet =\n            VSIFReadMultiRangeL( nReqYSize, ppData, panOffsets, panSizes, fp );\n        if( nRet != 0 )\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if( eErr == CE_None && TIFFIsByteSwapped(m_poGDS->m_hTIFF) )\n    {\n        for( int iLine = 0; iLine < nReqYSize; ++iLine )\n        {\n            if( GDALDataTypeIsComplex(eDataType) )\n                GDALSwapWords( ppData[iLine], nDTSize / 2,\n                               2 * nReqXSize * nContigBands, nDTSize / 2 );\n            else\n                GDALSwapWords( ppData[iLine], nDTSize,\n                               nReqXSize * nContigBands, nDTSize );\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    if( eErr == CE_None && pTmpBuffer != nullptr )\n    {\n        for( int iY=0; iY < nBufYSize; ++iY )\n        {\n            const int iSrcY =\n                nBufYSize <= nYSize ?\n                iY : static_cast<int>((iY + 0.5) * dfSrcYInc);\n\n            GByte* pabySrcData =\n                static_cast<GByte*>(ppData[iSrcY]) +\n                (nContigBands > 1 ? (nBand-1) : 0) * nDTSize;\n            GByte* pabyDstData =\n                static_cast<GByte *>(pData) + iY * nLineSpace;\n            if( nBufXSize == nXSize )\n            {\n                GDALCopyWords( pabySrcData,\n                               eDataType,\n                               nSrcPixelSize,\n                               pabyDstData,\n                               eBufType,\n                               static_cast<int>(nPixelSpace),\n                               nBufXSize );\n            }\n            else\n            {\n                if( eDataType == GDT_Byte && eBufType == GDT_Byte )\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for( int iX = 0; iX < nBufXSize; ++iX, dfSrcX += dfSrcXInc )\n                    {\n                        const int iSrcX = static_cast<int>(dfSrcX);\n                        pabyDstData[iX * nPixelSpace] =\n                            pabySrcData[iSrcX * nSrcPixelSize];\n                    }\n                }\n                else\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for( int iX = 0; iX < nBufXSize; ++iX, dfSrcX += dfSrcXInc )\n                    {\n                        const int iSrcX = static_cast<int>(dfSrcX);\n                        GDALCopyWords( pabySrcData + iSrcX * nSrcPixelSize,\n                                       eDataType, 0,\n                                       pabyDstData + iX * nPixelSpace,\n                                       eBufType, 0, 1 );\n                    }\n                }\n            }\n        }\n    }\n\n    // Cleanup.\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}",
    "CPLVirtualMem* GTiffRasterBand::GetVirtualMemAutoInternal( GDALRWFlag eRWFlag,\n                                                           int *pnPixelSpace,\n                                                           GIntBig *pnLineSpace,\n                                                           char **papszOptions )\n{\n    int nLineSize = nBlockXSize * GDALGetDataTypeSizeBytes(eDataType);\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n        nLineSize *= m_poGDS->nBands;\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        // In case of a pixel interleaved file, we save virtual memory space\n        // by reusing a base mapping that embraces the whole imagery.\n        if( m_poGDS->m_pBaseMapping != nullptr )\n        {\n            // Offset between the base mapping and the requested mapping.\n            vsi_l_offset nOffset =\n                static_cast<vsi_l_offset>(nBand - 1) *\n                GDALGetDataTypeSizeBytes(eDataType);\n\n            GTiffRasterBand** ppoSelf =\n                static_cast<GTiffRasterBand** >(\n                    CPLCalloc(1, sizeof(GTiffRasterBand*)) );\n            *ppoSelf = this;\n\n            CPLVirtualMem* pVMem = CPLVirtualMemDerivedNew(\n                m_poGDS->m_pBaseMapping,\n                nOffset,\n                CPLVirtualMemGetSize(m_poGDS->m_pBaseMapping) - nOffset,\n                GTiffRasterBand::DropReferenceVirtualMem,\n                ppoSelf);\n            if( pVMem == nullptr )\n            {\n                CPLFree(ppoSelf);\n                return nullptr;\n            }\n\n            // Mechanism used so that the memory mapping object can be\n            // destroyed after the raster band.\n            m_aSetPSelf.insert(ppoSelf);\n            ++m_poGDS->m_nRefBaseMapping;\n            *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n            if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                *pnPixelSpace *= m_poGDS->nBands;\n            *pnLineSpace = nLineSize;\n            return pVMem;\n        }\n    }\n\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_poGDS->m_hTIFF ));\n\n    vsi_l_offset nLength = static_cast<vsi_l_offset>(nRasterYSize) * nLineSize;\n\n    if( !(CPLIsVirtualMemFileMapAvailable() &&\n          VSIFGetNativeFileDescriptorL(fp) != nullptr &&\n#if SIZEOF_VOIDP == 4\n          nLength == static_cast<size_t>(nLength) &&\n#endif\n          m_poGDS->m_nCompression == COMPRESSION_NONE &&\n          (m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB ||\n           m_poGDS->m_nPhotometric == PHOTOMETRIC_PALETTE) &&\n          m_poGDS->m_nBitsPerSample == GDALGetDataTypeSizeBits(eDataType) &&\n          !TIFFIsTiled( m_poGDS->m_hTIFF ) && !TIFFIsByteSwapped(m_poGDS->m_hTIFF)) )\n    {\n        return nullptr;\n    }\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( m_poGDS->GetAccess() == GA_Update )\n    {\n        m_poGDS->FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( m_poGDS->m_hTIFF ) );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return nullptr;\n    }\n\n    GPtrDiff_t nBlockSize =\n        static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize * GDALGetDataTypeSizeBytes(eDataType);\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n        nBlockSize *= m_poGDS->nBands;\n\n    int nBlocks = m_poGDS->m_nBlocksPerBand;\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlocks *= m_poGDS->nBands;\n    int i = 0;  // Used after for.\n    for( ; i < nBlocks; ++i )\n    {\n        if( panTIFFOffsets[i] != 0 )\n            break;\n    }\n    if( i == nBlocks )\n    {\n        // All zeroes.\n        if( m_poGDS->eAccess == GA_Update )\n        {\n            // Initialize the file with empty blocks so that the file has\n            // the appropriate size.\n\n            toff_t* panByteCounts = nullptr;\n            if( !TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_STRIPBYTECOUNTS,\n                               &panByteCounts ) ||\n                panByteCounts == nullptr )\n            {\n                return nullptr;\n            }\n            if( VSIFSeekL(fp, 0, SEEK_END) != 0 )\n                return nullptr;\n            vsi_l_offset nBaseOffset = VSIFTellL(fp);\n\n            // Just write one tile with libtiff to put it in appropriate state.\n            GByte* pabyData =\n                static_cast<GByte*>(VSI_CALLOC_VERBOSE(1, nBlockSize));\n            if( pabyData == nullptr )\n            {\n                return nullptr;\n            }\n            const auto ret =\n                    TIFFWriteEncodedStrip( m_poGDS->m_hTIFF, 0, pabyData,\n                                           nBlockSize );\n            VSI_TIFFFlushBufferedWrite( TIFFClientdata( m_poGDS->m_hTIFF ) );\n            VSIFree(pabyData);\n            if( ret != nBlockSize )\n            {\n                return nullptr;\n            }\n            CPLAssert(panTIFFOffsets[0] == nBaseOffset);\n            CPLAssert(panByteCounts[0] == static_cast<toff_t>(nBlockSize));\n\n            // Now simulate the writing of other blocks.\n            const vsi_l_offset nDataSize =\n                static_cast<vsi_l_offset>(nBlockSize) * nBlocks;\n            if( VSIFTruncateL(fp, nBaseOffset + nDataSize) != 0 )\n                return nullptr;\n\n            for( i = 1; i < nBlocks; ++i)\n            {\n                panTIFFOffsets[i] =\n                    nBaseOffset + i * static_cast<toff_t>(nBlockSize);\n                panByteCounts[i] = nBlockSize;\n            }\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"Sparse files not supported in file mapping\" );\n            return nullptr;\n        }\n    }\n\n    GIntBig nBlockSpacing = 0;\n    bool bCompatibleSpacing = true;\n    toff_t nPrevOffset = 0;\n    for( i = 0; i < m_poGDS->m_nBlocksPerBand; ++i )\n    {\n        toff_t nCurOffset = 0;\n        if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n            nCurOffset =\n                panTIFFOffsets[m_poGDS->m_nBlocksPerBand * (nBand - 1) + i];\n        else\n            nCurOffset = panTIFFOffsets[i];\n        if( nCurOffset == 0 )\n        {\n            bCompatibleSpacing = false;\n            break;\n        }\n        if( i > 0 )\n        {\n            const GIntBig nCurSpacing = nCurOffset - nPrevOffset;\n            if( i == 1 )\n            {\n                if( nCurSpacing !=\n                    static_cast<GIntBig>(nBlockYSize) * nLineSize )\n                {\n                    bCompatibleSpacing = false;\n                    break;\n                }\n                nBlockSpacing = nCurSpacing;\n            }\n            else if( nBlockSpacing != nCurSpacing )\n            {\n                bCompatibleSpacing = false;\n                break;\n            }\n        }\n        nPrevOffset = nCurOffset;\n    }\n\n    if( !bCompatibleSpacing )\n    {\n        return nullptr;\n    }\n\n    vsi_l_offset nOffset = 0;\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        CPLAssert( m_poGDS->m_pBaseMapping == nullptr );\n        nOffset = panTIFFOffsets[0];\n    }\n    else\n    {\n        nOffset = panTIFFOffsets[m_poGDS->m_nBlocksPerBand * (nBand - 1)];\n    }\n    CPLVirtualMem* pVMem = CPLVirtualMemFileMapNew(\n        fp, nOffset, nLength,\n        eRWFlag == GF_Write ? VIRTUALMEM_READWRITE : VIRTUALMEM_READONLY,\n        nullptr, nullptr);\n    if( pVMem == nullptr )\n    {\n        return nullptr;\n    }\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        // TODO(schwehr): Revisit this block.\n        m_poGDS->m_pBaseMapping = pVMem;\n        pVMem = GetVirtualMemAutoInternal( eRWFlag,\n                                           pnPixelSpace,\n                                           pnLineSpace,\n                                           papszOptions );\n        // Drop ref on base mapping.\n        CPLVirtualMemFree(m_poGDS->m_pBaseMapping);\n        if( pVMem == nullptr )\n            m_poGDS->m_pBaseMapping = nullptr;\n    }\n    else\n    {\n        *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n        if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n            *pnPixelSpace *= m_poGDS->nBands;\n        *pnLineSpace = nLineSize;\n    }\n    return pVMem;\n}",
    "CPLErr GTiffDataset::CommonDirectIO(\n    FetchBuffer& oFetcher,\n    int nXOff, int nYOff, int nXSize, int nYSize,\n    void * pData, int nBufXSize, int nBufYSize,\n    GDALDataType eBufType,\n    int nBandCount, int *panBandMap,\n    GSpacing nPixelSpace, GSpacing nLineSpace,\n    GSpacing nBandSpace )\n{\n    const GDALDataType eDataType = GetRasterBand(1)->GetRasterDataType();\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    const bool bIsComplex = CPL_TO_BOOL(GDALDataTypeIsComplex(eDataType));\n    const int nBufDTSize = GDALGetDataTypeSizeBytes(eBufType);\n\n    // Get strip offsets.\n    toff_t *panOffsets = nullptr;\n    if( !TIFFGetField( m_hTIFF, (TIFFIsTiled( m_hTIFF )) ?\n                       TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                       &panOffsets ) ||\n        panOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    bool bUseContigImplementation =\n        m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        nBandCount > 1 &&\n        nBandSpace == nBufDTSize;\n    if( bUseContigImplementation )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            const int nBand = panBandMap[iBand];\n            if( nBand != iBand + 1 )\n            {\n                bUseContigImplementation = false;\n                break;\n            }\n        }\n    }\n\n    const int nBandsPerBlock =\n        m_nPlanarConfig == PLANARCONFIG_SEPARATE ? 1 : nBands;\n    const int nBandsPerBlockDTSize = nBandsPerBlock * nDTSize;\n    const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n    const bool bNoTypeChange = (eDataType == eBufType);\n    const bool bNoXResampling = (nXSize == nBufXSize );\n    const bool bNoXResamplingNoTypeChange = (bNoTypeChange && bNoXResampling);\n    const bool bByteOnly = (bNoTypeChange && nDTSize == 1 );\n    const bool bByteNoXResampling = ( bByteOnly && bNoXResamplingNoTypeChange );\n    const bool bIsByteSwapped = CPL_TO_BOOL(TIFFIsByteSwapped(m_hTIFF));\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    int bNoDataSetIn = FALSE;\n    double dfNoData = GetRasterBand(1)->GetNoDataValue( &bNoDataSetIn );\n    GByte abyNoData = 0;\n    if( !bNoDataSetIn )\n        dfNoData = 0;\n    else if( dfNoData >= 0 && dfNoData <= 255 )\n        abyNoData = static_cast<GByte>(dfNoData + 0.5);\n\n    if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( m_hTIFF ) && bNoXResampling && (nYSize == nBufYSize ) &&\n             m_nPlanarConfig == PLANARCONFIG_CONTIG && nBandCount > 1 )\n    {\n        GByte* pabyData = static_cast<GByte *>(pData);\n        for( int y = 0; y < nBufYSize; )\n        {\n            const int nSrcLine = nYOff + y;\n            const int nBlockYOff = nSrcLine / m_nBlockYSize;\n            const int nYOffsetInBlock = nSrcLine % m_nBlockYSize;\n            const int nUsedBlockHeight =\n                std::min( nBufYSize - y,\n                          m_nBlockYSize - nYOffsetInBlock );\n\n            int nBlockXOff = nXOff / m_nBlockXSize;\n            int nXOffsetInBlock = nXOff % m_nBlockXSize;\n            int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n            int x = 0;\n            while( x < nBufXSize )\n            {\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                const int nUsedBlockWidth =\n                    std::min( m_nBlockXSize - nXOffsetInBlock,\n                              nBufXSize - x );\n\n                if( nCurOffset == 0 )\n                {\n                    REACHED(30);\n                    for( int k = 0; k < nUsedBlockHeight; ++k )\n                    {\n                        GByte* pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for( int iBand = 0; iBand < nBandCount; ++iBand )\n                        {\n                            GByte* pabyLocalDataBand =\n                                pabyLocalData + iBand * nBandSpace;\n\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalDataBand, eBufType,\n                                static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth );\n                        }\n                    }\n                }\n                else\n                {\n                    const int nByteOffsetInBlock =\n                        nYOffsetInBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n                    const GByte* pabyLocalSrcDataK0 = oFetcher.FetchBytes(\n                            nCurOffset + nByteOffsetInBlock,\n                            m_nBlockXSize *\n                            nUsedBlockHeight * nBandsPerBlock,\n                            nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                    if( pabyLocalSrcDataK0 == nullptr )\n                        return CE_Failure;\n\n                    for( int k = 0; k < nUsedBlockHeight; ++k )\n                    {\n                        GByte* pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        const GByte* pabyLocalSrcData =\n                            pabyLocalSrcDataK0 +\n                            (k * m_nBlockXSize + nXOffsetInBlock) *\n                            nBandsPerBlockDTSize;\n\n                        if( bUseContigImplementation && nBands == nBandCount &&\n                            nPixelSpace == nBandsPerBlockDTSize )\n                        {\n                            REACHED(31);\n                            GDALCopyWords( pabyLocalSrcData,\n                                           eDataType, nDTSize,\n                                           pabyLocalData,\n                                           eBufType, nBufDTSize,\n                                           nUsedBlockWidth * nBands );\n                        }\n                        else\n                        {\n                            REACHED(32);\n                            for( int iBand = 0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand]-1) * nDTSize;\n\n                                GDALCopyWords(\n                                    pabyLocalSrcDataBand,\n                                    eDataType, nBandsPerBlockDTSize,\n                                    pabyLocalDataBand,\n                                    eBufType, static_cast<int>(nPixelSpace),\n                                    nUsedBlockWidth );\n                            }\n                        }\n                    }\n                }\n\n                nXOffsetInBlock = 0;\n                ++nBlockXOff;\n                ++nBlockId;\n                x += nUsedBlockWidth;\n            }\n\n            y += nUsedBlockHeight;\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( m_hTIFF ) && bNoXResampling &&\n             (nYSize == nBufYSize ) )\n             // && (m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            GByte* pabyData = static_cast<GByte *>(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            for( int y = 0; y < nBufYSize; )\n            {\n                const int nSrcLine = nYOff + y;\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int nUsedBlockHeight =\n                    std::min( nBufYSize - y,\n                              m_nBlockYSize - nYOffsetIm_nBlock);\n\n                int nBlockXOff = nXOff / m_nBlockXSize;\n                int nXOffsetInBlock = nXOff % m_nBlockXSize;\n                int nBlockId = nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                {\n                    REACHED(33);\n                    nBlockId += m_nBlocksPerBand * (nBand - 1);\n                }\n                else\n                {\n                    REACHED(34);\n                }\n\n                int x = 0;\n                while( x < nBufXSize )\n                {\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    const int nUsedBlockWidth =\n                        std::min(\n                            m_nBlockXSize - nXOffsetInBlock,\n                            nBufXSize - x);\n\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(35);\n                        for( int k = 0; k < nUsedBlockHeight; ++k )\n                        {\n                            GByte* pabyLocalData =\n                                pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData, eBufType,\n                                static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth );\n                        }\n                    }\n                    else\n                    {\n                        const int nByteOffsetIm_nBlock =\n                            nYOffsetIm_nBlock * m_nBlockXSize *\n                            nBandsPerBlockDTSize;\n                        const GByte* pabyLocalSrcDataK0 =\n                            oFetcher.FetchBytes(\n                                nCurOffset + nByteOffsetIm_nBlock,\n                                m_nBlockXSize *\n                                nUsedBlockHeight * nBandsPerBlock,\n                                nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                        if( pabyLocalSrcDataK0 == nullptr )\n                            return CE_Failure;\n\n                        if( m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                        {\n                            REACHED(36);\n                            pabyLocalSrcDataK0 += (nBand - 1) * nDTSize;\n                        }\n                        else\n                        {\n                            REACHED(37);\n                        }\n\n                        for( int k = 0; k < nUsedBlockHeight; ++k )\n                        {\n                            GByte* pabyLocalData =\n                                pabyData + (y + k) * nLineSpace +\n                                x * nPixelSpace;\n                            const GByte* pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (k * m_nBlockXSize + nXOffsetInBlock) *\n                                nBandsPerBlockDTSize;\n\n                            GDALCopyWords(\n                                pabyLocalSrcData,\n                                eDataType, nBandsPerBlockDTSize,\n                                pabyLocalData,\n                                eBufType, static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth);\n                        }\n                    }\n\n                    nXOffsetInBlock = 0;\n                    ++nBlockXOff;\n                    ++nBlockId;\n                    x += nUsedBlockWidth;\n                }\n\n                y += nUsedBlockHeight;\n            }\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( m_hTIFF ) &&\n             m_nPlanarConfig == PLANARCONFIG_CONTIG && nBandCount > 1 )\n    {\n        GByte* pabyData = static_cast<GByte *>(pData);\n        int anSrcYOffset[256] = { 0 };\n        for( int y = 0; y < nBufYSize; )\n        {\n            const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n            const int nSrcLine = static_cast<int>(dfYOffStart);\n            const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n            const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n            const int nBaseByteOffsetIm_nBlock =\n                nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n            int ychunk = 1;\n            int nLastSrcLineK = nSrcLine;\n            anSrcYOffset[0] = 0;\n            for( int k = 1; k < nBufYSize - y; ++k )\n            {\n                int nSrcLineK =\n                    nYOff + static_cast<int>((y + k + 0.5) * dfSrcYInc);\n                const int nBlockYOffK = nSrcLineK / m_nBlockYSize;\n                if( k < 256)\n                    anSrcYOffset[k] =\n                        ((nSrcLineK % m_nBlockYSize) - nYOffsetIm_nBlock) *\n                        m_nBlockXSize * nBandsPerBlockDTSize;\n                if( nBlockYOffK != m_nBlockYOff )\n                {\n                    break;\n                }\n                ++ychunk;\n                nLastSrcLineK = nSrcLineK;\n            }\n            const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n            // CPLAssert(nUsedBlockHeight <= m_nBlockYSize);\n\n            double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n            int nCurBlockXOff = 0;\n            int nNextBlockXOff = 0;\n            toff_t nCurOffset = 0;\n            const GByte* pabyLocalSrcDataStartLine = nullptr;\n            for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc)\n            {\n                const int nSrcPixel = static_cast<int>(dfSrcX);\n                if( nSrcPixel >= nNextBlockXOff )\n                {\n                    const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                    nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                    nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                    const int nBlockId =\n                        nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                    nCurOffset = panOffsets[nBlockId];\n                    if( nCurOffset != 0 )\n                    {\n                        pabyLocalSrcDataStartLine =\n                            oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetIm_nBlock,\n                                m_nBlockXSize *\n                                nBandsPerBlock * nUsedBlockHeight,\n                                nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId);\n                        if( pabyLocalSrcDataStartLine == nullptr )\n                            return CE_Failure;\n                    }\n                }\n\n                if( nCurOffset == 0 )\n                {\n                    REACHED(38);\n\n                    for( int k = 0; k < ychunk; ++k )\n                    {\n                        GByte* const pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for( int iBand = 0; iBand < nBandCount; ++iBand )\n                        {\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData + nBandSpace * iBand, eBufType, 0,\n                                1);\n                        }\n                    }\n                }\n                else\n                {\n                    const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                    double dfYOff = dfYOffStart;\n                    const GByte* const pabyLocalSrcDataK0 =\n                        pabyLocalSrcDataStartLine +\n                        nXOffsetInBlock * nBandsPerBlockDTSize;\n                    GByte* pabyLocalData =\n                        pabyData + y * nLineSpace + x * nPixelSpace;\n                    for( int k = 0;\n                         k < ychunk;\n                         ++k, pabyLocalData += nLineSpace )\n                    {\n                        const GByte* pabyLocalSrcData = nullptr;\n                        if( ychunk <= 256 )\n                        {\n                            REACHED(39);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 + anSrcYOffset[k];\n                        }\n                        else\n                        {\n                            REACHED(40);\n                            const int nYOffsetIm_nBlockK =\n                                static_cast<int>(dfYOff) % m_nBlockYSize;\n                            // CPLAssert(\n                            //     nYOffsetIm_nBlockK - nYOffsetIm_nBlock <=\n                            //     nUsedBlockHeight);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (nYOffsetIm_nBlockK - nYOffsetIm_nBlock) *\n                                m_nBlockXSize * nBandsPerBlockDTSize;\n                            dfYOff += dfSrcYInc;\n                        }\n\n                        if( bByteOnly )\n                        {\n                            REACHED(41);\n                            for( int iBand=0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData + (panBandMap[iBand]-1);\n                                *pabyLocalDataBand = *pabyLocalSrcDataBand;\n                            }\n                        }\n                        else\n                        {\n                            REACHED(42);\n                            for( int iBand = 0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand]-1) * nDTSize;\n\n                                GDALCopyWords( pabyLocalSrcDataBand,\n                                               eDataType, 0,\n                                               pabyLocalDataBand,\n                                               eBufType, 0,\n                                               1 );\n                            }\n                        }\n                    }\n                }\n            }\n\n            y += ychunk;\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( m_hTIFF ) )\n             // && (m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            GByte* pabyData = static_cast<GByte*>(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            int anSrcYOffset[256] = { 0 };\n            for( int y = 0; y < nBufYSize; )\n            {\n                const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n                const int nSrcLine = static_cast<int>(dfYOffStart);\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nBaseByteOffsetIm_nBlock =\n                    nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n                int ychunk = 1;\n                int nLastSrcLineK = nSrcLine;\n                anSrcYOffset[0] = 0;\n                for( int k = 1; k < nBufYSize - y; ++k )\n                {\n                    const int nSrcLineK =\n                        nYOff + static_cast<int>((y + k + 0.5) * dfSrcYInc);\n                    const int nBlockYOffK = nSrcLineK / m_nBlockYSize;\n                    if( k < 256)\n                        anSrcYOffset[k] =\n                            ((nSrcLineK % m_nBlockYSize) - nYOffsetIm_nBlock) *\n                            m_nBlockXSize * nBandsPerBlockDTSize;\n                    if( nBlockYOffK != m_nBlockYOff )\n                    {\n                        break;\n                    }\n                    ++ychunk;\n                    nLastSrcLineK = nSrcLineK;\n                }\n                const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n                // CPLAssert(nUsedBlockHeight <= m_nBlockYSize);\n\n                double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                int nCurBlockXOff = 0;\n                int nNextBlockXOff = 0;\n                toff_t nCurOffset = 0;\n                const GByte* pabyLocalSrcDataStartLine = nullptr;\n                for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc )\n                {\n                    int nSrcPixel = static_cast<int>(dfSrcX);\n                    if( nSrcPixel >= nNextBlockXOff )\n                    {\n                        const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                        nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                        nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                        int nBlockId = nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                        if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                        {\n                            REACHED(43);\n                            nBlockId += m_nBlocksPerBand * (nBand - 1);\n                        }\n                        else\n                        {\n                            REACHED(44);\n                        }\n                        nCurOffset = panOffsets[nBlockId];\n                        if( nCurOffset != 0 )\n                        {\n                            pabyLocalSrcDataStartLine =\n                                oFetcher.FetchBytes(\n                                    nCurOffset + nBaseByteOffsetIm_nBlock,\n                                    m_nBlockXSize *\n                                    nBandsPerBlock * nUsedBlockHeight,\n                                    nDTSize,\n                                    bIsByteSwapped, bIsComplex, nBlockId);\n                            if( pabyLocalSrcDataStartLine == nullptr )\n                                return CE_Failure;\n\n                            if( m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                            {\n                                REACHED(45);\n                                pabyLocalSrcDataStartLine +=\n                                    (nBand - 1) * nDTSize;\n                            }\n                            else\n                            {\n                                REACHED(46);\n                            }\n                        }\n                    }\n\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(47);\n\n                        for( int k = 0; k < ychunk; ++k )\n                        {\n                            GByte* const pabyLocalData =\n                                pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n\n                            GDALCopyWords( &dfNoData, GDT_Float64, 0,\n                                           pabyLocalData, eBufType, 0,\n                                           1 );\n                        }\n                    }\n                    else\n                    {\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                        double dfYOff = dfYOffStart;\n                        const GByte* const pabyLocalSrcDataK0 =\n                            pabyLocalSrcDataStartLine +\n                            nXOffsetInBlock * nBandsPerBlockDTSize;\n                        GByte* pabyLocalData =\n                            pabyData + y * nLineSpace + x * nPixelSpace;\n                        for( int k = 0;\n                             k < ychunk;\n                             ++k, pabyLocalData += nLineSpace )\n                        {\n                            const GByte* pabyLocalSrcData = nullptr;\n                            if( ychunk <= 256 )\n                            {\n                                REACHED(48);\n                                pabyLocalSrcData =\n                                    pabyLocalSrcDataK0 + anSrcYOffset[k];\n                            }\n                            else\n                            {\n                                REACHED(49);\n                                const int nYOffsetIm_nBlockK =\n                                    static_cast<int>(dfYOff) % m_nBlockYSize;\n                                // CPLAssert(\n                                //     nYOffsetIm_nBlockK - nYOffsetIm_nBlock <=\n                                //     nUsedBlockHeight);\n                                pabyLocalSrcData = pabyLocalSrcDataK0 +\n                                    (nYOffsetIm_nBlockK - nYOffsetIm_nBlock) *\n                                    m_nBlockXSize * nBandsPerBlockDTSize;\n                                dfYOff += dfSrcYInc;\n                            }\n\n                            if( bByteOnly )\n                            {\n                                REACHED(50);\n\n                                *pabyLocalData = *pabyLocalSrcData;\n                            }\n                            else\n                            {\n                                REACHED(51);\n\n                                GDALCopyWords( pabyLocalSrcData,\n                                               eDataType, 0,\n                                               pabyLocalData,\n                                               eBufType, 0,\n                                               1 );\n                            }\n                        }\n                    }\n                }\n\n                y += ychunk;\n            }\n        }\n    }\n    else if( bUseContigImplementation )\n    {\n        if( !FetchBuffer::bMinimizeIO && TIFFIsTiled( m_hTIFF ) )\n        {\n            GByte* pabyData = static_cast<GByte *>(pData);\n            for( int y = 0; y < nBufYSize; ++y )\n            {\n                const int nSrcLine =\n                    nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int nBaseByteOffsetIm_nBlock =\n                    nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n\n                if( bNoXResampling )\n                {\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    int nBlockXOff = nXOff / m_nBlockXSize;\n                    int nXOffsetInBlock = nXOff % m_nBlockXSize;\n                    int nBlockId = nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n\n                    int x = 0;\n                    while( x < nBufXSize )\n                    {\n                        const int nByteOffsetIm_nBlock = nBaseByteOffsetIm_nBlock +\n                                        nXOffsetInBlock * nBandsPerBlockDTSize;\n                        const toff_t nCurOffset = panOffsets[nBlockId];\n                        const int nUsedBlockWidth =\n                            std::min(\n                                m_nBlockXSize - nXOffsetInBlock,\n                                nBufXSize - x);\n\n                        int nIters = nUsedBlockWidth;\n                        if( nCurOffset == 0 )\n                        {\n                            if( bByteNoXResampling )\n                            {\n                                REACHED(0);\n                                while( nIters-- > 0 )\n                                {\n                                    for( int iBand = 0;\n                                         iBand < nBandCount;\n                                         ++iBand )\n                                    {\n                                        pabyLocalData[iBand] = abyNoData;\n                                    }\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                            else\n                            {\n                                REACHED(1);\n                                while( nIters-- > 0 )\n                                {\n                                    GDALCopyWords(\n                                        &dfNoData, GDT_Float64, 0,\n                                        pabyLocalData, eBufType,\n                                        static_cast<int>(nBandSpace),\n                                        nBandCount);\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if( bNoTypeChange && nBands == nBandCount &&\n                                nPixelSpace == nBandsPerBlockDTSize )\n                            {\n                                REACHED(2);\n                                if( !oFetcher.FetchBytes(\n                                        pabyLocalData,\n                                        nCurOffset + nByteOffsetIm_nBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId) )\n                                {\n                                    return CE_Failure;\n                                }\n                                pabyLocalData +=\n                                    nIters * nBandsPerBlock * nDTSize;\n                            }\n                            else\n                            {\n                                const GByte* pabyLocalSrcData =\n                                    oFetcher.FetchBytes(\n                                        nCurOffset + nByteOffsetIm_nBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId);\n                                if( pabyLocalSrcData == nullptr )\n                                    return CE_Failure;\n                                if( bByteNoXResampling )\n                                {\n                                    REACHED(3);\n                                    CopyContigByteMultiBand(\n                                        pabyLocalSrcData,\n                                        nBandsPerBlockDTSize,\n                                        pabyLocalData,\n                                        static_cast<int>(nPixelSpace),\n                                        nIters,\n                                        nBandCount);\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    REACHED(4);\n                                    while( nIters-- > 0 )\n                                    {\n                                        GDALCopyWords(\n                                            pabyLocalSrcData,\n                                            eDataType, nDTSize,\n                                            pabyLocalData,\n                                            eBufType,\n                                            static_cast<int>(nBandSpace),\n                                            nBandCount);\n                                        pabyLocalSrcData +=\n                                            nBandsPerBlockDTSize;\n                                        pabyLocalData += nPixelSpace;\n                                    }\n                                }\n                            }\n                        }\n\n                        nXOffsetInBlock = 0;\n                        ++nBlockXOff;\n                        ++nBlockId;\n                        x += nUsedBlockWidth;\n                    }\n                }\n                else  // Contig, tiled, potential resampling & data type change.\n                {\n                    const GByte* pabyLocalSrcDataStartLine = nullptr;\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                    int nCurBlockXOff = 0;\n                    int nNextBlockXOff = 0;\n                    toff_t nCurOffset = 0;\n                    for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc )\n                    {\n                        int nSrcPixel = static_cast<int>(dfSrcX);\n                        if( nSrcPixel >= nNextBlockXOff )\n                        {\n                            const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                            nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                            nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                            const int nBlockId =\n                                nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                            nCurOffset = panOffsets[nBlockId];\n                            if( nCurOffset != 0 )\n                            {\n                                pabyLocalSrcDataStartLine =\n                                    oFetcher.FetchBytes(\n                                        nCurOffset + nBaseByteOffsetIm_nBlock,\n                                        m_nBlockXSize *\n                                        nBandsPerBlock,\n                                        nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId);\n                                if( pabyLocalSrcDataStartLine == nullptr )\n                                    return CE_Failure;\n                            }\n                        }\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n\n                        if( nCurOffset == 0 )\n                        {\n                            REACHED(5);\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData,\n                                eBufType,\n                                static_cast<int>(nBandSpace),\n                                nBandCount );\n                            pabyLocalData += nPixelSpace;\n                        }\n                        else\n                        {\n                            const GByte* pabyLocalSrcData =\n                                pabyLocalSrcDataStartLine +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                            REACHED(6);\n                            if( bByteOnly )\n                            {\n                                for( int iBand = 0; iBand < nBands; ++iBand )\n                                    pabyLocalData[iBand] =\n                                        pabyLocalSrcData[iBand];\n                            }\n                            else\n                            {\n                                GDALCopyWords(\n                                    pabyLocalSrcData,\n                                    eDataType, nDTSize,\n                                    pabyLocalData,\n                                    eBufType,\n                                    static_cast<int>(nBandSpace),\n                                    nBandCount );\n                            }\n                            pabyLocalData += nPixelSpace;\n                        }\n                    }\n                }\n            }\n        }\n        else  // Contig, striped organized.\n        {\n            GByte* pabyData = static_cast<GByte*>(pData);\n            for( int y = 0; y < nBufYSize; ++y )\n            {\n                const int nSrcLine =\n                    nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int nBlockId = m_nBlockYOff;\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                if( nCurOffset == 0 )\n                {\n                    REACHED(7);\n                    for( int x = 0; x < nBufXSize; ++x )\n                    {\n                        GDALCopyWords(\n                            &dfNoData, GDT_Float64, 0,\n                            pabyData + y * nLineSpace + x * nPixelSpace,\n                            eBufType, static_cast<int>(nBandSpace),\n                            nBandCount);\n                    }\n                }\n                else\n                {\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    const int nBaseByteOffsetIm_nBlock =\n                        (nYOffsetIm_nBlock * m_nBlockXSize + nXOff) *\n                        nBandsPerBlockDTSize;\n\n                    if( bNoXResamplingNoTypeChange && nBands == nBandCount &&\n                        nPixelSpace == nBandsPerBlockDTSize )\n                    {\n                        REACHED(8);\n                        if( !oFetcher.FetchBytes(\n                               pabyLocalData,\n                               nCurOffset + nBaseByteOffsetIm_nBlock,\n                               nXSize * nBandsPerBlock, nDTSize, bIsByteSwapped,\n                               bIsComplex, nBlockId) )\n                        {\n                            return CE_Failure;\n                        }\n                    }\n                    else\n                    {\n                        const GByte* pabyLocalSrcData = oFetcher.FetchBytes(\n                            nCurOffset + nBaseByteOffsetIm_nBlock,\n                            nXSize * nBandsPerBlock, nDTSize, bIsByteSwapped,\n                            bIsComplex, nBlockId);\n                        if( pabyLocalSrcData == nullptr )\n                            return CE_Failure;\n\n                        if( bByteNoXResampling )\n                        {\n                            REACHED(9);\n                            CopyContigByteMultiBand(\n                                pabyLocalSrcData,\n                                nBandsPerBlockDTSize,\n                                pabyLocalData,\n                                static_cast<int>(nPixelSpace),\n                                nBufXSize,\n                                nBandCount);\n                        }\n                        else if( bByteOnly )\n                        {\n                            REACHED(10);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for( int x = 0;\n                                 x < nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc )\n                            {\n                                const int nSrcPixelMinusXOff =\n                                    static_cast<int>(dfSrcX);\n                                for( int iBand = 0;\n                                     iBand < nBandCount;\n                                     ++iBand )\n                                {\n                                    pabyLocalData[x * nPixelSpace + iBand] =\n                                        pabyLocalSrcData[nSrcPixelMinusXOff *\n                                                         nBandsPerBlockDTSize +\n                                                         iBand];\n                                }\n                            }\n                        }\n                        else\n                        {\n                            REACHED(11);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for( int x = 0;\n                                 x < nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc )\n                            {\n                                int nSrcPixelMinusXOff =\n                                    static_cast<int>(dfSrcX);\n                                GDALCopyWords(\n                                    pabyLocalSrcData +\n                                    nSrcPixelMinusXOff * nBandsPerBlockDTSize,\n                                    eDataType, nDTSize,\n                                    pabyLocalData + x * nPixelSpace,\n                                    eBufType,\n                                    static_cast<int>(nBandSpace),\n                                    nBandCount );\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else  // Non-contig reading case.\n    {\n        if( !FetchBuffer::bMinimizeIO && TIFFIsTiled( m_hTIFF ) )\n        {\n            for( int iBand = 0; iBand < nBandCount; ++iBand )\n            {\n                const int nBand = panBandMap[iBand];\n                GByte* const pabyData =\n                    static_cast<GByte*>(pData) + iBand * nBandSpace;\n                for( int y = 0; y < nBufYSize; ++y )\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                    const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                    const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n\n                    int nBaseByteOffsetIm_nBlock =\n                        nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n                    if( m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                    {\n                        REACHED(12);\n                        nBaseByteOffsetIm_nBlock += (nBand - 1) * nDTSize;\n                    }\n                    else\n                    {\n                        REACHED(13);\n                    }\n\n                    if( bNoXResampling )\n                    {\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        int nBlockXOff = nXOff / m_nBlockXSize;\n                        int nBlockId = nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                        if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                        {\n                            REACHED(14);\n                            nBlockId += m_nBlocksPerBand * (nBand - 1);\n                        }\n                        else\n                        {\n                            REACHED(15);\n                        }\n                        int nXOffsetInBlock = nXOff % m_nBlockXSize;\n\n                        int x = 0;\n                        while( x < nBufXSize )\n                        {\n                            const int nByteOffsetIm_nBlock =\n                                nBaseByteOffsetIm_nBlock +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n                            const toff_t nCurOffset = panOffsets[nBlockId];\n                            const int nUsedBlockWidth =\n                                std::min(\n                                    m_nBlockXSize - nXOffsetInBlock,\n                                    nBufXSize - x );\n                            int nIters = nUsedBlockWidth;\n\n                            if( nCurOffset == 0 )\n                            {\n                                REACHED(16);\n                                GDALCopyWords(\n                                    &dfNoData, GDT_Float64, 0,\n                                    pabyLocalData, eBufType,\n                                    static_cast<int>(nPixelSpace),\n                                    nIters);\n                                pabyLocalData += nIters * nPixelSpace;\n                            }\n                            else\n                            {\n                                if( bNoTypeChange &&\n                                    nPixelSpace == nBandsPerBlockDTSize )\n                                {\n                                    REACHED(17);\n                                    if( !oFetcher.FetchBytes(\n                                           pabyLocalData,\n                                           nCurOffset + nByteOffsetIm_nBlock,\n                                           (nIters - 1) * nBandsPerBlock + 1,\n                                           nDTSize,\n                                           bIsByteSwapped, bIsComplex,\n                                           nBlockId) )\n                                    {\n                                        return CE_Failure;\n                                    }\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    const GByte* pabyLocalSrcData =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset + nByteOffsetIm_nBlock,\n                                            (nIters - 1) * nBandsPerBlock + 1,\n                                            nDTSize,\n                                            bIsByteSwapped,\n                                            bIsComplex,\n                                            nBlockId );\n                                    if( pabyLocalSrcData == nullptr )\n                                        return CE_Failure;\n\n                                    REACHED(18);\n                                    GDALCopyWords(\n                                        pabyLocalSrcData, eDataType,\n                                        nBandsPerBlockDTSize,\n                                        pabyLocalData, eBufType,\n                                        static_cast<int>(nPixelSpace),\n                                        nIters );\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                            }\n\n                            nXOffsetInBlock = 0;\n                            ++nBlockXOff;\n                            ++nBlockId;\n                            x += nUsedBlockWidth;\n                        }\n                    }\n                    else\n                    {\n                        // Non-contig reading, tiled, potential resampling and\n                        // data type change.\n\n                        const GByte* pabyLocalSrcDataStartLine = nullptr;\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                        int nCurBlockXOff = 0;\n                        int nNextBlockXOff = 0;\n                        toff_t nCurOffset = 0;\n                        for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc)\n                        {\n                            const int nSrcPixel = static_cast<int>(dfSrcX);\n                            if( nSrcPixel >= nNextBlockXOff )\n                            {\n                                const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                                nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                                nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                                int nBlockId =\n                                    nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                                if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                                {\n                                    REACHED(19);\n                                    nBlockId += m_nBlocksPerBand * (nBand - 1);\n                                }\n                                else\n                                {\n                                    REACHED(20);\n                                }\n                                nCurOffset = panOffsets[nBlockId];\n                                if( nCurOffset != 0 )\n                                {\n                                    pabyLocalSrcDataStartLine =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset + nBaseByteOffsetIm_nBlock,\n                                            m_nBlockXSize * nBandsPerBlock,\n                                            nDTSize,\n                                            bIsByteSwapped,\n                                            bIsComplex,\n                                            nBlockId);\n                                    if( pabyLocalSrcDataStartLine == nullptr )\n                                        return CE_Failure;\n                                }\n                            }\n                            const int nXOffsetInBlock =\n                                nSrcPixel - nCurBlockXOff;\n\n                            if( nCurOffset == 0 )\n                            {\n                                REACHED(21);\n                                GDALCopyWords( &dfNoData, GDT_Float64, 0,\n                                               pabyLocalData,\n                                               eBufType, 0,\n                                               1 );\n                                pabyLocalData += nPixelSpace;\n                            }\n                            else\n                            {\n                                const GByte* pabyLocalSrcData =\n                                    pabyLocalSrcDataStartLine +\n                                    nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                                REACHED(22);\n                                if( bByteOnly )\n                                {\n                                    *pabyLocalData = *pabyLocalSrcData;\n                                }\n                                else\n                                {\n                                    GDALCopyWords(pabyLocalSrcData,\n                                                eDataType, 0,\n                                                pabyLocalData,\n                                                eBufType, 0,\n                                                1);\n                                }\n                                pabyLocalData += nPixelSpace;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else  // Non-contig reading, striped.\n        {\n            for( int iBand = 0; iBand < nBandCount; ++iBand )\n            {\n                const int nBand = panBandMap[iBand];\n                GByte* pabyData =\n                    static_cast<GByte *>(pData) + iBand * nBandSpace;\n                for( int y = 0; y < nBufYSize; ++y )\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                    const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                    const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                    int nBlockId = m_nBlockYOff;\n                    if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                    {\n                        REACHED(23);\n                        nBlockId += m_nBlocksPerBand * (nBand - 1);\n                    }\n                    else\n                    {\n                        REACHED(24);\n                    }\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(25);\n                        GDALCopyWords(\n                            &dfNoData, GDT_Float64, 0,\n                            pabyData + y * nLineSpace,\n                            eBufType,\n                            static_cast<int>(nPixelSpace),\n                            nBufXSize);\n                    }\n                    else\n                    {\n                        int nBaseByteOffsetIm_nBlock =\n                            (nYOffsetIm_nBlock * m_nBlockXSize + nXOff) *\n                            nBandsPerBlockDTSize;\n                        if( m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                            nBaseByteOffsetIm_nBlock += (nBand - 1) * nDTSize;\n\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        if( bNoXResamplingNoTypeChange &&\n                            nPixelSpace == nBandsPerBlockDTSize )\n                        {\n                            REACHED(26);\n                            if( !oFetcher.FetchBytes(\n                                pabyLocalData,\n                                nCurOffset + nBaseByteOffsetIm_nBlock,\n                                (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId) )\n                            {\n                                return CE_Failure;\n                            }\n                        }\n                        else\n                        {\n                            const GByte* pabyLocalSrcData = oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetIm_nBlock,\n                                (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId);\n                            if( pabyLocalSrcData == nullptr )\n                                return CE_Failure;\n\n                            if( bNoXResamplingNoTypeChange )\n                            {\n                                REACHED(27);\n                                GDALCopyWords(pabyLocalSrcData,\n                                              eDataType, nBandsPerBlockDTSize,\n                                              pabyLocalData, eBufType,\n                                              static_cast<int>(nPixelSpace),\n                                              nBufXSize);\n                            }\n                            else if( bByteOnly )\n                            {\n                                REACHED(28);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for( int x = 0;\n                                     x < nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc )\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast<int>(dfSrcX);\n                                    pabyLocalData[x * nPixelSpace] =\n                                        pabyLocalSrcData[nSrcPixelMinusXOff *\n                                                         nBandsPerBlockDTSize];\n                                }\n                            }\n                            else\n                            {\n                                REACHED(29);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for( int x = 0;\n                                     x < nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc )\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast<int>(dfSrcX);\n                                    GDALCopyWords(\n                                        pabyLocalSrcData +\n                                        nSrcPixelMinusXOff *\n                                        nBandsPerBlockDTSize,\n                                        eDataType, 0,\n                                        pabyLocalData + x * nPixelSpace,\n                                        eBufType, 0,\n                                        1 );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return CE_None;\n}",
    "int GTiffDataset::DirectIO( GDALRWFlag eRWFlag,\n                            int nXOff, int nYOff, int nXSize, int nYSize,\n                            void * pData, int nBufXSize, int nBufYSize,\n                            GDALDataType eBufType,\n                            int nBandCount, int *panBandMap,\n                            GSpacing nPixelSpace, GSpacing nLineSpace,\n                            GSpacing nBandSpace,\n                            GDALRasterIOExtraArg* psExtraArg )\n{\n    const GDALDataType eDataType = GetRasterBand(1)->GetRasterDataType();\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(eRWFlag == GF_Read &&\n          m_nCompression == COMPRESSION_NONE &&\n          (m_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           m_nPhotometric == PHOTOMETRIC_RGB ||\n           m_nPhotometric == PHOTOMETRIC_PALETTE) &&\n          m_nBitsPerSample == nDTSizeBits) )\n    {\n        return -1;\n    }\n    Crystalize();\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) &&\n        psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n    // If the file is band interleave or only one band is requested, then\n    // fallback to band DirectIO.\n    bool bUseBandRasterIO = false;\n    if( m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1 )\n    {\n        bUseBandRasterIO = true;\n    }\n    else\n    {\n        // For simplicity, only deals with \"naturally ordered\" bands.\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            if( panBandMap[iBand] != iBand + 1)\n            {\n                bUseBandRasterIO = true;\n                break;\n            }\n        }\n    }\n    if( bUseBandRasterIO )\n    {\n        CPLErr eErr = CE_None;\n        for( int iBand = 0; eErr == CE_None && iBand < nBandCount; ++iBand )\n        {\n            eErr = GetRasterBand(panBandMap[iBand])->RasterIO(\n                eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                static_cast<GByte *>(pData) + iBand * nBandSpace,\n                nBufXSize, nBufYSize,\n                eBufType,\n                nPixelSpace, nLineSpace,\n                psExtraArg );\n        }\n        return eErr;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"DirectIO(%d,%d,%d,%d -> %dx%d)\",\n              nXOff, nYOff, nXSize, nYSize,\n              nBufXSize, nBufYSize );\n#endif\n\n    // No need to look if overviews can satisfy the request as it has already */\n    // been done in GTiffDataset::IRasterIO().\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( GetAccess() == GA_Update )\n    {\n        FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( m_hTIFF ) );\n    }\n\n    if( TIFFIsTiled( m_hTIFF ) )\n    {\n        const int nDTSize = nDTSizeBits / 8;\n        const size_t nTempBufferForCommonDirectIOSize =\n            static_cast<size_t>(static_cast<GPtrDiff_t>(m_nBlockXSize) * m_nBlockYSize * nDTSize *\n            ((m_nPlanarConfig == PLANARCONFIG_CONTIG) ? nBands : 1));\n        if( m_pTempBufferForCommonDirectIO == nullptr )\n        {\n            m_pTempBufferForCommonDirectIO =\n                static_cast<GByte *>(\n                    VSI_MALLOC_VERBOSE(nTempBufferForCommonDirectIOSize) );\n            if( m_pTempBufferForCommonDirectIO == nullptr )\n                return CE_Failure;\n        }\n\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n        FetchBufferDirectIO oFetcher(fp, m_pTempBufferForCommonDirectIO,\n                                     nTempBufferForCommonDirectIOSize);\n\n        return CommonDirectIO( oFetcher,\n                               nXOff, nYOff, nXSize, nYSize,\n                               pData, nBufXSize, nBufYSize,\n                               eBufType,\n                               nBandCount, panBandMap,\n                               nPixelSpace, nLineSpace,\n                              nBandSpace );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    void** ppData =\n        static_cast<void **>( VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void*)) );\n    vsi_l_offset* panOffsets =\n        static_cast<vsi_l_offset *>(\n            VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)) );\n    size_t* panSizes =\n        static_cast<size_t *>( VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)) );\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void* pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands = nBands;\n    const int nSrcPixelSize = nDTSize * nContigBands;\n\n    if( ppData == nullptr || panOffsets == nullptr || panSizes == nullptr )\n    {\n        eErr = CE_Failure;\n    }\n    // For now we always allocate a temp buffer as it is easier.\n    else\n        // if( nXSize != nBufXSize || nYSize != nBufYSize ||\n        //   eBufType != eDataType ||\n        //   nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n        //   check if the user buffer is large enough )\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC_VERBOSE(nReqXSize * nReqYSize * nSrcPixelSize);\n        if( pTmpBuffer == nullptr )\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    for( int iLine = 0; eErr == CE_None && iLine < nReqYSize; ++iLine )\n    {\n        ppData[iLine] =\n            static_cast<GByte *>(pTmpBuffer) +\n            iLine * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if( nBufYSize < nYSize )  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast<int>((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / m_nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % m_nBlockYSize;\n        const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n        const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if( panOffsets[iLine] == 0)  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff + nYOffsetInBlock * m_nBlockXSize) * nSrcPixelSize;\n        panSizes[iLine] = nReqXSize * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if( eErr == CE_None )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n        const int nRet =\n            VSIFReadMultiRangeL(nReqYSize, ppData, panOffsets, panSizes, fp);\n        if( nRet != 0 )\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if( eErr == CE_None && TIFFIsByteSwapped(m_hTIFF) )\n    {\n        for( int iLine = 0; iLine < nReqYSize; ++iLine )\n        {\n            if( GDALDataTypeIsComplex(eDataType) )\n                GDALSwapWords( ppData[iLine], nDTSize / 2,\n                               2 * nReqXSize * nContigBands, nDTSize / 2);\n            else\n                GDALSwapWords( ppData[iLine], nDTSize,\n                               nReqXSize * nContigBands, nDTSize);\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    if( eErr == CE_None && pTmpBuffer != nullptr )\n    {\n        for( int iY = 0; iY < nBufYSize; ++iY )\n        {\n            const int iSrcY =\n                nBufYSize <= nYSize ?\n                iY : static_cast<int>((iY + 0.5) * dfSrcYInc);\n            // Optimization: no resampling, no data type change, number of\n            // bands requested == number of bands and buffer is packed\n            // pixel-interleaved.\n            if( nBufXSize == nXSize && nContigBands == nBandCount &&\n                eDataType == eBufType &&\n                nBandSpace == nDTSize &&\n                nPixelSpace == nBandCount * nBandSpace )\n            {\n                memcpy(\n                    static_cast<GByte *>(pData) + iY * nLineSpace,\n                    ppData[iSrcY],\n                    static_cast<size_t>(nReqXSize * nPixelSpace) );\n            }\n            // Other optimization: no resampling, no data type change,\n            // data type is Byte.\n            else if( nBufXSize == nXSize &&\n                     eDataType == eBufType && eDataType == GDT_Byte )\n            {\n                GByte* pabySrcData = static_cast<GByte *>(ppData[iSrcY]);\n                GByte* pabyDstData =\n                    static_cast<GByte *>(pData) + iY * nLineSpace;\n                if( nBandSpace == 1 && nPixelSpace > nBandCount )\n                {\n                    // Buffer is pixel-interleaved (with some stridding\n                    // between pixels).\n                    CopyContigByteMultiBand( pabySrcData, nSrcPixelSize,\n                                             pabyDstData,\n                                             static_cast<int>(nPixelSpace),\n                                             nBufXSize, nBandCount );\n                }\n                else\n                {\n                    for( int iBand = 0; iBand < nBandCount; ++iBand )\n                    {\n                        GDALCopyWords(\n                            pabySrcData + iBand, GDT_Byte, nSrcPixelSize,\n                            pabyDstData + iBand * nBandSpace,\n                            GDT_Byte, static_cast<int>(nPixelSpace),\n                            nBufXSize );\n                    }\n                }\n            }\n            else  // General case.\n            {\n                for( int iBand = 0; iBand < nBandCount; ++iBand )\n                {\n                    GByte* pabySrcData =\n                        static_cast<GByte *>(ppData[iSrcY]) + iBand * nDTSize;\n                    GByte* pabyDstData =\n                        static_cast<GByte *>(pData) +\n                        iBand * nBandSpace + iY * nLineSpace;\n                    if( eDataType == GDT_Byte && eBufType == GDT_Byte )\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for( int iX = 0;\n                             iX < nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast<int>(dfSrcX);\n                            pabyDstData[iX * nPixelSpace] =\n                                pabySrcData[iSrcX * nSrcPixelSize];\n                        }\n                    }\n                    else\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for( int iX = 0;\n                             iX < nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast<int>(dfSrcX);\n                            GDALCopyWords( pabySrcData + iSrcX * nSrcPixelSize,\n                                        eDataType, 0,\n                                        pabyDstData + iX * nPixelSpace,\n                                        eBufType, 0, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}",
    "const char *GTiffRasterBand::GetMetadataItem( const char * pszName,\n                                              const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszName != nullptr && pszDomain != nullptr && EQUAL(pszDomain, \"TIFF\") )\n    {\n        int nBlockXOff = 0;\n        int nBlockYOff = 0;\n\n        if( EQUAL(pszName, \"JPEGTABLES\") )\n        {\n            uint32 nJPEGTableSize = 0;\n            void* pJPEGTable = nullptr;\n            if( TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_JPEGTABLES,\n                              &nJPEGTableSize, &pJPEGTable ) != 1 ||\n                pJPEGTable == nullptr || nJPEGTableSize > INT_MAX )\n            {\n                return nullptr;\n            }\n            char* const pszHex =\n                CPLBinaryToHex( nJPEGTableSize, static_cast<const GByte*>(pJPEGTable) );\n            const char* pszReturn = CPLSPrintf(\"%s\", pszHex);\n            CPLFree(pszHex);\n\n            return pszReturn;\n        }\n\n        if( EQUAL(pszName, \"IFD_OFFSET\") )\n        {\n            return CPLSPrintf( CPL_FRMT_GUIB,\n                               static_cast<GUIntBig>(m_poGDS->m_nDirOffset) );\n        }\n\n        if( sscanf( pszName, \"BLOCK_OFFSET_%d_%d\",\n                         &nBlockXOff, &nBlockYOff ) == 2 )\n        {\n            nBlocksPerRow =\n                DIV_ROUND_UP(m_poGDS->nRasterXSize, m_poGDS->m_nBlockXSize);\n            nBlocksPerColumn =\n                DIV_ROUND_UP(m_poGDS->nRasterYSize, m_poGDS->m_nBlockYSize);\n            if( nBlockXOff < 0 || nBlockXOff >= nBlocksPerRow ||\n                nBlockYOff < 0 || nBlockYOff >= nBlocksPerColumn )\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n            {\n                nBlockId += (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n            }\n\n            vsi_l_offset nOffset = 0;\n            if( !m_poGDS->IsBlockAvailable(nBlockId, &nOffset) )\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf( CPL_FRMT_GUIB, static_cast<GUIntBig>(nOffset) );\n        }\n\n        if( sscanf( pszName, \"BLOCK_SIZE_%d_%d\",\n                    &nBlockXOff, &nBlockYOff ) == 2 )\n        {\n            nBlocksPerRow =\n                DIV_ROUND_UP(m_poGDS->nRasterXSize, m_poGDS->m_nBlockXSize);\n            nBlocksPerColumn =\n                DIV_ROUND_UP(m_poGDS->nRasterYSize, m_poGDS->m_nBlockYSize);\n            if( nBlockXOff < 0 || nBlockXOff >= nBlocksPerRow ||\n                nBlockYOff < 0 || nBlockYOff >= nBlocksPerColumn )\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n            {\n                nBlockId += (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n            }\n\n            vsi_l_offset nByteCount = 0;\n            if( !m_poGDS->IsBlockAvailable(nBlockId, nullptr, &nByteCount) )\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf(CPL_FRMT_GUIB, static_cast<GUIntBig>(nByteCount));\n        }\n    }\n    return m_oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}",
    "CPLErr GTiffRasterBand::SetColorInterpretation( GDALColorInterp eInterp )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( eInterp == m_eBandInterp )\n        return CE_None;\n\n    m_eBandInterp = eInterp;\n\n    if( eAccess != GA_Update )\n    {\n        CPLDebug( \"GTIFF\", \"ColorInterpretation %s for band %d goes to PAM \"\n                  \"instead of TIFF tag\",\n                  GDALGetColorInterpretationName(eInterp), nBand );\n        return GDALPamRasterBand::SetColorInterpretation( eInterp );\n    }\n\n    m_poGDS->m_bNeedsRewrite = true;\n    m_poGDS->m_bMetadataChanged = true;\n\n    // Try to autoset TIFFTAG_PHOTOMETRIC = PHOTOMETRIC_RGB if possible.\n    if( m_poGDS->nBands >= 3 &&\n        m_poGDS->m_nCompression != COMPRESSION_JPEG &&\n        m_poGDS->m_nPhotometric != PHOTOMETRIC_RGB &&\n        CSLFetchNameValue( m_poGDS->m_papszCreationOptions,\n                           \"PHOTOMETRIC\" ) == nullptr &&\n        ((nBand == 1 && eInterp == GCI_RedBand) ||\n         (nBand == 2 && eInterp == GCI_GreenBand) ||\n         (nBand == 3 && eInterp == GCI_BlueBand)) )\n    {\n        if( m_poGDS->GetRasterBand(1)->GetColorInterpretation() == GCI_RedBand &&\n            m_poGDS->GetRasterBand(2)->GetColorInterpretation() == GCI_GreenBand &&\n            m_poGDS->GetRasterBand(3)->GetColorInterpretation() == GCI_BlueBand )\n        {\n            m_poGDS->m_nPhotometric = PHOTOMETRIC_RGB;\n            TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_PHOTOMETRIC,\n                          m_poGDS->m_nPhotometric );\n\n            // We need to update the number of extra samples.\n            uint16 *v = nullptr;\n            uint16 count = 0;\n            const uint16 nNewExtraSamplesCount =\n                static_cast<uint16>(m_poGDS->nBands - 3);\n            if( m_poGDS->nBands >= 4 &&\n                TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES,\n                              &count, &v ) &&\n                count > nNewExtraSamplesCount )\n            {\n                uint16 * const pasNewExtraSamples =\n                    static_cast<uint16 *>( CPLMalloc(\n                        nNewExtraSamplesCount * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v + count - nNewExtraSamplesCount,\n                        nNewExtraSamplesCount * sizeof(uint16) );\n\n                TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES,\n                              nNewExtraSamplesCount, pasNewExtraSamples );\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n        return CE_None;\n    }\n\n    // On the contrary, cancel the above if needed\n    if( m_poGDS->m_nCompression != COMPRESSION_JPEG &&\n        m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB &&\n        CSLFetchNameValue( m_poGDS->m_papszCreationOptions,\n                           \"PHOTOMETRIC\") == nullptr &&\n        ((nBand == 1 && eInterp != GCI_RedBand) ||\n         (nBand == 2 && eInterp != GCI_GreenBand) ||\n         (nBand == 3 && eInterp != GCI_BlueBand)) )\n    {\n        m_poGDS->m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(m_poGDS->m_hTIFF, TIFFTAG_PHOTOMETRIC, m_poGDS->m_nPhotometric);\n\n        // We need to update the number of extra samples.\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        const uint16 nNewExtraSamplesCount =\n            static_cast<uint16>(m_poGDS->nBands - 1);\n        if( m_poGDS->nBands >= 2 )\n        {\n            TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v );\n            if( nNewExtraSamplesCount > count )\n            {\n                uint16 * const pasNewExtraSamples =\n                    static_cast<uint16 *>( CPLMalloc(\n                        nNewExtraSamplesCount * sizeof(uint16) ) );\n                for( int i = 0;\n                     i < static_cast<int>(nNewExtraSamplesCount - count);\n                     ++i )\n                    pasNewExtraSamples[i] = EXTRASAMPLE_UNSPECIFIED;\n                if( count > 0 )\n                {\n                    memcpy( pasNewExtraSamples + nNewExtraSamplesCount - count,\n                            v,\n                            count * sizeof(uint16) );\n                }\n\n                TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES,\n                              nNewExtraSamplesCount, pasNewExtraSamples );\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n    }\n\n    // Mark alpha band / undefined in extrasamples.\n    if( eInterp == GCI_AlphaBand || eInterp == GCI_Undefined )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        if( TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            const int nBaseSamples = m_poGDS->m_nSamplesPerPixel - count;\n\n            if( eInterp == GCI_AlphaBand )\n            {\n                for( int i = 1; i <= m_poGDS->nBands; ++i )\n                {\n                    if( i != nBand &&\n                        m_poGDS->GetRasterBand(i)->GetColorInterpretation() ==\n                        GCI_AlphaBand )\n                    {\n                        if( i == nBaseSamples + 1 &&\n                            CSLFetchNameValue( m_poGDS->m_papszCreationOptions,\n                                            \"ALPHA\" ) != nullptr )\n                        {\n                            ReportError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too. \"\n                                \"Presumably ALPHA creation option is not needed\",\n                                i, nBand );\n                        }\n                        else\n                        {\n                            ReportError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too\",\n                                i, nBand );\n                        }\n                    }\n                }\n            }\n\n            if( nBand > nBaseSamples && nBand - nBaseSamples - 1 < count )\n            {\n                // We need to allocate a new array as (current) libtiff\n                // versions will not like that we reuse the array we got from\n                // TIFFGetField().\n\n                uint16* pasNewExtraSamples =\n                    static_cast<uint16 *>(\n                        CPLMalloc( count * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v, count * sizeof(uint16) );\n                if( eInterp == GCI_AlphaBand )\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        GTiffGetAlphaValue(CPLGetConfigOption(\"GTIFF_ALPHA\", nullptr),\n                                            DEFAULT_ALPHA_TYPE);\n                }\n                else\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        EXTRASAMPLE_UNSPECIFIED;\n                }\n\n                TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES,\n                              count, pasNewExtraSamples);\n\n                CPLFree(pasNewExtraSamples);\n\n                return CE_None;\n            }\n        }\n    }\n\n    if( m_poGDS->m_nPhotometric != PHOTOMETRIC_MINISBLACK &&\n        CSLFetchNameValue( m_poGDS->m_papszCreationOptions, \"PHOTOMETRIC\") == nullptr )\n    {\n        m_poGDS->m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(m_poGDS->m_hTIFF, TIFFTAG_PHOTOMETRIC, m_poGDS->m_nPhotometric);\n    }\n\n    return CE_None;\n}",
    "int GTiffDataset::GetJPEGOverviewCount()\n{\n    if( m_nJPEGOverviewCount >= 0 )\n        return m_nJPEGOverviewCount;\n\n    m_nJPEGOverviewCount = 0;\n    if( m_poBaseDS || eAccess != GA_ReadOnly || m_nCompression != COMPRESSION_JPEG ||\n        (nRasterXSize < 256 && nRasterYSize < 256) ||\n        !CPLTestBool(CPLGetConfigOption(\"GTIFF_IMPLICIT_JPEG_OVR\", \"YES\")) ||\n        GDALGetDriverByName(\"JPEG\") == nullptr )\n    {\n        return 0;\n    }\n    const char* pszSourceColorSpace =\n        m_oGTiffMDMD.GetMetadataItem( \"SOURCE_COLOR_SPACE\", \"IMAGE_STRUCTURE\" );\n    if( pszSourceColorSpace != nullptr && EQUAL(pszSourceColorSpace, \"CMYK\") )\n    {\n        // We cannot handle implicit overviews on JPEG CMYK datasets converted\n        // to RGBA This would imply doing the conversion in\n        // GTiffJPEGOverviewBand.\n        return 0;\n    }\n\n    // libjpeg-6b only supports 2, 4 and 8 scale denominators.\n    // TODO: Later versions support more.\n    for( signed char i = 2; i >= 0; i-- )\n    {\n        if( nRasterXSize >= (256 << i) || nRasterYSize >= (256 << i) )\n        {\n            m_nJPEGOverviewCount = i + 1;\n            break;\n        }\n    }\n    if( m_nJPEGOverviewCount == 0 )\n        return 0;\n\n    // Get JPEG tables.\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    GByte abyFFD8[] = { 0xFF, 0xD8 };\n    if( TIFFGetField(m_hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize, &pJPEGTable) )\n    {\n        if( pJPEGTable == nullptr ||\n            nJPEGTableSize > INT_MAX ||\n            static_cast<GByte*>(pJPEGTable)[nJPEGTableSize-1] != 0xD9 )\n        {\n            m_nJPEGOverviewCount = 0;\n            return 0;\n        }\n        nJPEGTableSize--;  // Remove final 0xD9.\n    }\n    else\n    {\n        pJPEGTable = abyFFD8;\n        nJPEGTableSize = 2;\n    }\n\n    m_papoJPEGOverviewDS =\n        static_cast<GTiffJPEGOverviewDS **>(\n            CPLMalloc( sizeof(GTiffJPEGOverviewDS*) * m_nJPEGOverviewCount ) );\n    for( int i = 0; i < m_nJPEGOverviewCount; ++i )\n    {\n        m_papoJPEGOverviewDS[i] =\n            new GTiffJPEGOverviewDS(\n                this, i + 1,\n                pJPEGTable, static_cast<int>(nJPEGTableSize) );\n    }\n\n    m_nJPEGOverviewCountOri = m_nJPEGOverviewCount;\n\n    return m_nJPEGOverviewCount;\n}",
    "void GTiffDataset::FillEmptyTiles()\n\n{\n/* -------------------------------------------------------------------- */\n/*      How many blocks are there in this file?                         */\n/* -------------------------------------------------------------------- */\n    const int nBlockCount =\n        m_nPlanarConfig == PLANARCONFIG_SEPARATE ?\n        m_nBlocksPerBand * nBands :\n        m_nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Fetch block maps.                                               */\n/* -------------------------------------------------------------------- */\n    toff_t *panByteCounts = nullptr;\n\n    if( TIFFIsTiled( m_hTIFF ) )\n        TIFFGetField( m_hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts );\n    else\n        TIFFGetField( m_hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts );\n\n    if( panByteCounts == nullptr )\n    {\n        // Got here with libtiff 3.9.3 and tiff_write_8 test.\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"FillEmptyTiles() failed because panByteCounts == NULL\" );\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Prepare a blank data buffer to write for uninitialized blocks.  */\n/* -------------------------------------------------------------------- */\n    const GPtrDiff_t nBlockBytes =\n        TIFFIsTiled( m_hTIFF ) ?\n        static_cast<GPtrDiff_t>(TIFFTileSize(m_hTIFF)) :\n        static_cast<GPtrDiff_t>(TIFFStripSize(m_hTIFF));\n\n    GByte *pabyData =\n        static_cast<GByte *>( VSI_CALLOC_VERBOSE(nBlockBytes, 1) );\n    if( pabyData == nullptr )\n    {\n        return;\n    }\n\n    // Force tiles completely filled with the nodata value to be written.\n    m_bWriteEmptyTiles = true;\n\n/* -------------------------------------------------------------------- */\n/*      If set, fill data buffer with no data value.                    */\n/* -------------------------------------------------------------------- */\n    if( m_bNoDataSet && m_dfNoDataValue != 0.0 )\n    {\n        const GDALDataType eDataType = GetRasterBand( 1 )->GetRasterDataType();\n        const int nDataTypeSize = GDALGetDataTypeSizeBytes( eDataType );\n        if( nDataTypeSize &&\n            nDataTypeSize * 8 == static_cast<int>(m_nBitsPerSample) )\n        {\n            GDALCopyWords64( &m_dfNoDataValue, GDT_Float64, 0,\n                           pabyData, eDataType,\n                           nDataTypeSize,\n                           nBlockBytes / nDataTypeSize );\n        }\n        else if( nDataTypeSize )\n        {\n            // Handle non power-of-two depths.\n            // Ideally make a packed buffer, but that is a bit tedious,\n            // so use the normal I/O interfaces.\n\n            CPLFree( pabyData );\n\n            pabyData = static_cast<GByte *>(\n                VSI_MALLOC3_VERBOSE(m_nBlockXSize, m_nBlockYSize, nDataTypeSize) );\n            if( pabyData == nullptr )\n                return;\n            GDALCopyWords64( &m_dfNoDataValue, GDT_Float64, 0,\n                           pabyData, eDataType,\n                           nDataTypeSize,\n                           static_cast<GPtrDiff_t>(m_nBlockXSize) * m_nBlockYSize );\n            const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockYSize);\n            for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n            {\n                if( panByteCounts[iBlock] == 0 )\n                {\n                    if( m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBands == 1 )\n                    {\n                        CPL_IGNORE_RET_VAL( GetRasterBand(\n                            1 + iBlock / m_nBlocksPerBand )->WriteBlock(\n                                (iBlock % m_nBlocksPerBand) % nBlocksPerRow,\n                                (iBlock % m_nBlocksPerBand) / nBlocksPerRow,\n                                pabyData ) );\n                    }\n                    else\n                    {\n                        // In contig case, don't directly call WriteBlock(), as\n                        // it could cause useless decompression-recompression.\n                        const int nXOff =\n                            (iBlock % nBlocksPerRow) * m_nBlockXSize;\n                        const int nYOff =\n                            (iBlock / nBlocksPerRow) * m_nBlockYSize;\n                        const int nXSize =\n                            (nXOff + m_nBlockXSize <= nRasterXSize) ?\n                            m_nBlockXSize : nRasterXSize - nXOff;\n                        const int nYSize =\n                            (nYOff + m_nBlockYSize <= nRasterYSize) ?\n                            m_nBlockYSize : nRasterYSize - nYOff;\n                        for( int iBand = 1; iBand <= nBands; ++iBand )\n                        {\n                            CPL_IGNORE_RET_VAL( GetRasterBand( iBand )->\n                                RasterIO(\n                                    GF_Write, nXOff, nYOff, nXSize, nYSize,\n                                    pabyData, nXSize, nYSize,\n                                    eDataType, 0, 0, nullptr ) );\n                        }\n                    }\n                }\n            }\n            CPLFree( pabyData );\n            return;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      When we must fill with zeroes, try to create non-sparse file    */\n/*      w.r.t TIFF spec ... as a sparse file w.r.t filesystem, ie by    */\n/*      seeking to end of file instead of writing zero blocks.          */\n/* -------------------------------------------------------------------- */\n    else if( m_nCompression == COMPRESSION_NONE && (m_nBitsPerSample % 8) == 0 )\n    {\n        // Only use libtiff to write the first sparse block to ensure that it\n        // will serialize offset and count arrays back to disk.\n        int nCountBlocksToZero = 0;\n        for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n        {\n            if( panByteCounts[iBlock] == 0 )\n            {\n                if( nCountBlocksToZero == 0 )\n                {\n                    const bool bWriteEmptyTilesBak = m_bWriteEmptyTiles;\n                    m_bWriteEmptyTiles = true;\n                    const bool bOK =\n                        WriteEncodedTileOrStrip( iBlock, pabyData,\n                                                 FALSE ) == CE_None;\n                    m_bWriteEmptyTiles = bWriteEmptyTilesBak;\n                    if( !bOK )\n                        break;\n                }\n                nCountBlocksToZero++;\n            }\n        }\n        CPLFree( pabyData );\n\n        --nCountBlocksToZero;\n\n        // And then seek to end of file for other ones.\n        if( nCountBlocksToZero > 0 )\n        {\n            toff_t *panByteOffsets = nullptr;\n\n            if( TIFFIsTiled( m_hTIFF ) )\n                TIFFGetField( m_hTIFF, TIFFTAG_TILEOFFSETS, &panByteOffsets );\n            else\n                TIFFGetField( m_hTIFF, TIFFTAG_STRIPOFFSETS, &panByteOffsets );\n\n            if( panByteOffsets == nullptr )\n            {\n                ReportError(\n                    CE_Failure, CPLE_AppDefined,\n                    \"FillEmptyTiles() failed because panByteOffsets == NULL\");\n                return;\n            }\n\n            VSILFILE* fpTIF = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n            VSIFSeekL( fpTIF, 0, SEEK_END );\n            const vsi_l_offset nOffset = VSIFTellL(fpTIF);\n\n            vsi_l_offset iBlockToZero = 0;\n            for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n            {\n                if( panByteCounts[iBlock] == 0 )\n                {\n                    panByteOffsets[iBlock] = static_cast<toff_t>(\n                                        nOffset + iBlockToZero * nBlockBytes);\n                    panByteCounts[iBlock] = nBlockBytes;\n                    iBlockToZero++;\n                }\n            }\n            CPLAssert( iBlockToZero ==\n                       static_cast<vsi_l_offset>(nCountBlocksToZero) );\n\n            if( VSIFTruncateL( fpTIF,\n                               nOffset + iBlockToZero * nBlockBytes ) != 0 )\n            {\n                ReportError(CE_Failure, CPLE_FileIO,\n                         \"Cannot initialize empty blocks\");\n            }\n        }\n\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check all blocks, writing out data for uninitialized blocks.    */\n/* -------------------------------------------------------------------- */\n\n    GByte* pabyRaw = nullptr;\n    vsi_l_offset nRawSize = 0;\n    for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n    {\n        if( panByteCounts[iBlock] == 0 )\n        {\n            if( pabyRaw == nullptr )\n            {\n                if( WriteEncodedTileOrStrip( iBlock, pabyData, FALSE\n                                                                ) != CE_None )\n                    break;\n\n                vsi_l_offset nOffset = 0;\n                bool b = IsBlockAvailable( iBlock, &nOffset, &nRawSize);\n                CPL_IGNORE_RET_VAL(b);\n                CPLAssert(b);\n\n                // When using compression, get back the compressed block\n                // so we can use the raw API to write it faster.\n                if( m_nCompression != COMPRESSION_NONE )\n                {\n                    pabyRaw = static_cast<GByte*>(\n                            VSI_MALLOC_VERBOSE(static_cast<size_t>(nRawSize)));\n                    if( pabyRaw )\n                    {\n                        VSILFILE* fp = VSI_TIFFGetVSILFile(\n                                                    TIFFClientdata( m_hTIFF ));\n                        const vsi_l_offset nCurOffset = VSIFTellL(fp);\n                        VSIFSeekL(fp, nOffset, SEEK_SET);\n                        VSIFReadL(pabyRaw, 1, static_cast<size_t>(nRawSize), fp);\n                        VSIFSeekL(fp, nCurOffset, SEEK_SET);\n                    }\n                }\n            }\n            else\n            {\n                WriteRawStripOrTile( iBlock, pabyRaw,\n                                     static_cast<GPtrDiff_t>(nRawSize) );\n            }\n        }\n    }\n\n    CPLFree( pabyData );\n    VSIFree( pabyRaw );\n}",
    "void GTiffDataset::ThreadCompressionFunc( void* pData )\n{\n    GTiffCompressionJob* psJob = static_cast<GTiffCompressionJob *>(pData);\n    GTiffDataset* poDS = psJob->poDS;\n\n    VSILFILE* fpTmp = VSIFOpenL(psJob->pszTmpFilename, \"wb+\");\n    TIFF* hTIFFTmp = VSI_TIFFOpen(psJob->pszTmpFilename,\n        psJob->bTIFFIsBigEndian ? \"wb+\" : \"wl+\", fpTmp);\n    CPLAssert( hTIFFTmp != nullptr );\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGEWIDTH, poDS->m_nBlockXSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGELENGTH, psJob->nHeight);\n    TIFFSetField(hTIFFTmp, TIFFTAG_BITSPERSAMPLE, poDS->m_nBitsPerSample);\n    TIFFSetField(hTIFFTmp, TIFFTAG_COMPRESSION, poDS->m_nCompression);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, poDS->m_nPhotometric);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLEFORMAT, poDS->m_nSampleFormat);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLESPERPIXEL, poDS->m_nSamplesPerPixel);\n    TIFFSetField(hTIFFTmp, TIFFTAG_ROWSPERSTRIP, poDS->m_nBlockYSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PLANARCONFIG, poDS->m_nPlanarConfig);\n    if( psJob->nPredictor != PREDICTOR_NONE )\n        TIFFSetField(hTIFFTmp, TIFFTAG_PREDICTOR, psJob->nPredictor);\n#if HAVE_LERC\n    if( poDS->m_nCompression == COMPRESSION_LERC )\n    {\n        TIFFSetField(hTIFFTmp, TIFFTAG_LERC_PARAMETERS, 2,\n                    poDS->m_anLercAddCompressionAndVersion);\n    }\n#endif\n\n    TIFFSetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, poDS->m_nPhotometric);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLEFORMAT, poDS->m_nSampleFormat);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLESPERPIXEL, poDS->m_nSamplesPerPixel);\n    TIFFSetField(hTIFFTmp, TIFFTAG_ROWSPERSTRIP, poDS->m_nBlockYSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PLANARCONFIG, poDS->m_nPlanarConfig);\n\n    poDS->RestoreVolatileParameters(hTIFFTmp);\n\n    bool bOK =\n        TIFFWriteEncodedStrip(hTIFFTmp, 0, psJob->pabyBuffer,\n                              psJob->nBufferSize) == psJob->nBufferSize;\n\n    toff_t nOffset = 0;\n    if( bOK )\n    {\n        toff_t* panOffsets = nullptr;\n        toff_t* panByteCounts = nullptr;\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPOFFSETS, &panOffsets);\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts);\n\n        nOffset = panOffsets[0];\n        psJob->nCompressedBufferSize = static_cast<GPtrDiff_t>(panByteCounts[0]);\n    }\n    else\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Error when compressing strip/tile %d\",\n                  psJob->nStripOrTile);\n    }\n\n    XTIFFClose(hTIFFTmp);\n    if( VSIFCloseL(fpTmp) != 0 )\n    {\n        if( bOK )\n        {\n            bOK = false;\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"Error when compressing strip/tile %d\",\n                      psJob->nStripOrTile);\n        }\n    }\n\n    if( bOK )\n    {\n        vsi_l_offset nFileSize = 0;\n        GByte* pabyCompressedBuffer = VSIGetMemFileBuffer(psJob->pszTmpFilename,\n                                                          &nFileSize,\n                                                          FALSE);\n        CPLAssert( static_cast<vsi_l_offset>(nOffset + psJob->nCompressedBufferSize) <= nFileSize );\n        psJob->pabyCompressedBuffer = pabyCompressedBuffer + nOffset;\n    }\n    else\n    {\n        psJob->pabyCompressedBuffer = nullptr;\n        psJob->nCompressedBufferSize = 0;\n    }\n\n    auto mutex = poDS->m_poBaseDS ?\n        poDS->m_poBaseDS->m_hCompressThreadPoolMutex : poDS->m_hCompressThreadPoolMutex;\n    if( mutex )\n    {\n        CPLAcquireMutex(mutex, 1000.0);\n        psJob->bReady = true;\n        CPLReleaseMutex(mutex);\n    }\n}",
    "void GTiffDataset::WriteRawStripOrTile( int nStripOrTile,\n                                        GByte* pabyCompressedBuffer,\n                                        GPtrDiff_t nCompressedBufferSize )\n{\n#ifdef DEBUG_VERBOSE\n    CPLDebug(\"GTIFF\", \"Writing raw strip/tile %d, size \" CPL_FRMT_GUIB,\n             nStripOrTile, static_cast<GUIntBig>(nCompressedBufferSize));\n#endif\n    toff_t *panOffsets = nullptr;\n    toff_t* panByteCounts = nullptr;\n    bool bWriteAtEnd = true;\n    bool bWriteLeader = m_bLeaderSizeAsUInt4;\n    bool bWriteTrailer = m_bTrailerRepeatedLast4BytesRepeated;\n    if( TIFFGetField(\n            m_hTIFF,\n            TIFFIsTiled( m_hTIFF ) ?\n            TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS, &panOffsets ) &&\n            panOffsets != nullptr &&\n            panOffsets[nStripOrTile] != 0 )\n    {\n        // Forces TIFFAppendStrip() to consider if the location of the tile/strip\n        // can be reused or if the strile should be written at end of file.\n        TIFFSetWriteOffset(m_hTIFF, 0);\n\n        if( m_bBlockOrderRowMajor )\n        {\n            if( TIFFGetField(\n                m_hTIFF,\n                TIFFIsTiled( m_hTIFF ) ?\n                TIFFTAG_TILEBYTECOUNTS : TIFFTAG_STRIPBYTECOUNTS, &panByteCounts ) &&\n                panByteCounts != nullptr )\n            {\n                if( static_cast<GUIntBig>(nCompressedBufferSize) >\n                        panByteCounts[nStripOrTile] )\n                {\n                    GTiffDataset* poRootDS = m_poBaseDS ? m_poBaseDS : this;\n                    if( !poRootDS->m_bKnownIncompatibleEdition &&\n                        !poRootDS->m_bWriteKnownIncompatibleEdition )\n                    {\n                        ReportError(CE_Warning, CPLE_AppDefined,\n                            \"A strile cannot be rewritten in place, which \"\n                            \"invalidates the BLOCK_ORDER optimization.\");\n                        poRootDS->m_bKnownIncompatibleEdition = true;\n                        poRootDS->m_bWriteKnownIncompatibleEdition = true;\n                    }\n                }\n                // For mask interleaving, if the size is not exactly the same,\n                // completely give up (we could potentially move the mask in\n                // case the imagery is smaller)\n                else if( m_poMaskDS && m_bMaskInterleavedWithImagery &&\n                         static_cast<GUIntBig>(nCompressedBufferSize) !=\n                            panByteCounts[nStripOrTile] )\n                {\n                    GTiffDataset* poRootDS = m_poBaseDS ? m_poBaseDS : this;\n                    if( !poRootDS->m_bKnownIncompatibleEdition &&\n                        !poRootDS->m_bWriteKnownIncompatibleEdition )\n                    {\n                        ReportError(CE_Warning, CPLE_AppDefined,\n                            \"A strile cannot be rewritten in place, which \"\n                            \"invalidates the MASK_INTERLEAVED_WITH_IMAGERY \"\n                            \"optimization.\");\n                        poRootDS->m_bKnownIncompatibleEdition = true;\n                        poRootDS->m_bWriteKnownIncompatibleEdition = true;\n                    }\n                    bWriteLeader = false;\n                    bWriteTrailer = false;\n                    if( m_bLeaderSizeAsUInt4 )\n                    {\n                        // If there was a valid leader, invalidat it\n                        VSI_TIFFSeek( m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET );\n                        uint32 nOldSize;\n                        VSIFReadL(&nOldSize, 1, 4, VSI_TIFFGetVSILFile(TIFFClientdata(m_hTIFF)));\n                        CPL_LSBPTR32(&nOldSize);\n                        if( nOldSize == panByteCounts[nStripOrTile] )\n                        {\n                            uint32 nInvalidatedSize = 0;\n                            VSI_TIFFSeek( m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET );\n                            VSI_TIFFWrite(m_hTIFF, &nInvalidatedSize, sizeof(nInvalidatedSize));\n                        }\n                    }\n                }\n                else\n                {\n                    bWriteAtEnd = false;\n                }\n            }\n        }\n    }\n    if( bWriteLeader &&\n        static_cast<GUIntBig>(nCompressedBufferSize) <= 0xFFFFFFFFU )\n    {\n        // cppcheck-suppress knownConditionTrueFalse\n        if( bWriteAtEnd )\n        {\n            VSI_TIFFSeek( m_hTIFF, 0, SEEK_END );\n        }\n        else\n        {\n            // If we rewrite an existing strile in place with an existing leader,\n            // check that the leader is valid, before rewriting it.\n            // And if it is not valid, then do not write the trailer, as we\n            // could corrupt other data.\n            VSI_TIFFSeek( m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET );\n            uint32 nOldSize;\n            VSIFReadL(&nOldSize, 1, 4, VSI_TIFFGetVSILFile(TIFFClientdata(m_hTIFF)));\n            CPL_LSBPTR32(&nOldSize);\n            bWriteLeader = panByteCounts && nOldSize == panByteCounts[nStripOrTile];\n            bWriteTrailer = bWriteLeader;\n            VSI_TIFFSeek( m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET );\n        }\n        // cppcheck-suppress knownConditionTrueFalse\n        if( bWriteLeader )\n        {\n            uint32 nSize = static_cast<uint32>(nCompressedBufferSize);\n            CPL_LSBPTR32(&nSize);\n            if( !VSI_TIFFWrite(m_hTIFF, &nSize, sizeof(nSize)) )\n                m_bWriteError = true;\n        }\n    }\n    tmsize_t written;\n    if( TIFFIsTiled( m_hTIFF ) )\n        written = TIFFWriteRawTile( m_hTIFF, nStripOrTile, pabyCompressedBuffer,\n                          nCompressedBufferSize );\n    else\n        written = TIFFWriteRawStrip( m_hTIFF, nStripOrTile, pabyCompressedBuffer,\n                           nCompressedBufferSize );\n    if( written != nCompressedBufferSize )\n        m_bWriteError = true;\n    if( bWriteTrailer &&\n        static_cast<GUIntBig>(nCompressedBufferSize) <= 0xFFFFFFFFU )\n    {\n        GByte abyLastBytes[4] = {};\n        if( nCompressedBufferSize >= 4 )\n            memcpy(abyLastBytes, pabyCompressedBuffer + nCompressedBufferSize - 4, 4);\n        else\n            memcpy(abyLastBytes, pabyCompressedBuffer, nCompressedBufferSize);\n        if( !VSI_TIFFWrite(m_hTIFF, abyLastBytes, 4) )\n            m_bWriteError = true;\n    }\n}",
    "bool GTiffDataset::SubmitCompressionJob( int nStripOrTile, GByte* pabyData,\n                                         GPtrDiff_t cc, int nHeight )\n{\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    auto poQueue = m_poBaseDS ?\n        m_poBaseDS->m_poCompressQueue.get() : m_poCompressQueue.get();\n\n    if( poQueue == nullptr ||\n          !(m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n            m_nCompression == COMPRESSION_LZW ||\n            m_nCompression == COMPRESSION_PACKBITS ||\n            m_nCompression == COMPRESSION_LZMA ||\n            m_nCompression == COMPRESSION_ZSTD ||\n            m_nCompression == COMPRESSION_LERC ||\n            m_nCompression == COMPRESSION_WEBP ||\n            m_nCompression == COMPRESSION_JPEG) )\n    {\n        if( m_bBlockOrderRowMajor || m_bLeaderSizeAsUInt4 ||\n            m_bTrailerRepeatedLast4BytesRepeated )\n        {\n            GTiffCompressionJob sJob;\n            memset(&sJob, 0, sizeof(sJob));\n            sJob.poDS = this;\n            sJob.pszTmpFilename = CPLStrdup(CPLSPrintf(\"/vsimem/gtiff/%p\", this));\n            sJob.bTIFFIsBigEndian = CPL_TO_BOOL( TIFFIsBigEndian(m_hTIFF) );\n            sJob.pabyBuffer =\n                static_cast<GByte*>( CPLRealloc(sJob.pabyBuffer, cc) );\n            memcpy(sJob.pabyBuffer, pabyData, cc);\n            sJob.nBufferSize = cc;\n            sJob.nHeight = nHeight;\n            sJob.nStripOrTile = nStripOrTile;\n            sJob.nPredictor = PREDICTOR_NONE;\n            if( m_nCompression == COMPRESSION_LZW ||\n                m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n                m_nCompression == COMPRESSION_ZSTD )\n            {\n                TIFFGetField( m_hTIFF, TIFFTAG_PREDICTOR, &sJob.nPredictor );\n            }\n\n            ThreadCompressionFunc(&sJob);\n\n            if( sJob.nCompressedBufferSize )\n            {\n                sJob.poDS->\n                    WriteRawStripOrTile(sJob.nStripOrTile,\n                                sJob.pabyCompressedBuffer,\n                                sJob.nCompressedBufferSize);\n            }\n\n            CPLFree(sJob.pabyBuffer);\n            VSIUnlink(sJob.pszTmpFilename);\n            CPLFree(sJob.pszTmpFilename);\n            return sJob.nCompressedBufferSize > 0 && !m_bWriteError;\n        }\n\n        return false;\n    }\n\n    auto& oQueue = m_poBaseDS ? m_poBaseDS->m_asQueueJobIdx : m_asQueueJobIdx;\n    auto& asJobs = m_poBaseDS ? m_poBaseDS->m_asCompressionJobs : m_asCompressionJobs;\n\n    int nNextCompressionJobAvail = -1;\n\n    if( oQueue.size() == asJobs.size() )\n    {\n        CPLAssert( !oQueue.empty() );\n        nNextCompressionJobAvail = oQueue.front();\n        WaitCompletionForJobIdx(nNextCompressionJobAvail);\n    }\n    else\n    {\n        const int nJobs = static_cast<int>(asJobs.size());\n        for( int i = 0; i < nJobs; ++i )\n        {\n            if( asJobs[i].nBufferSize == 0 )\n            {\n                nNextCompressionJobAvail = i;\n                break;\n            }\n        }\n    }\n    CPLAssert(nNextCompressionJobAvail >= 0);\n\n    GTiffCompressionJob* psJob = &asJobs[nNextCompressionJobAvail];\n    psJob->poDS = this;\n    psJob->bTIFFIsBigEndian = CPL_TO_BOOL( TIFFIsBigEndian(m_hTIFF) );\n    psJob->pabyBuffer =\n        static_cast<GByte*>( CPLRealloc(psJob->pabyBuffer, cc) );\n    memcpy(psJob->pabyBuffer, pabyData, cc);\n    psJob->nBufferSize = cc;\n    psJob->nHeight = nHeight;\n    psJob->nStripOrTile = nStripOrTile;\n    psJob->nPredictor = PREDICTOR_NONE;\n    if( m_nCompression == COMPRESSION_LZW ||\n        m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        m_nCompression == COMPRESSION_ZSTD )\n    {\n        TIFFGetField( m_hTIFF, TIFFTAG_PREDICTOR, &psJob->nPredictor );\n    }\n\n    poQueue->SubmitJob(ThreadCompressionFunc, psJob);\n    oQueue.push(nNextCompressionJobAvail);\n\n    return true;\n}",
    "bool GTiffDataset::IsBlockAvailable( int nBlockId,\n                                     vsi_l_offset* pnOffset,\n                                     vsi_l_offset* pnSize,\n                                     bool *pbErrOccurred )\n\n{\n    if( pbErrOccurred )\n        *pbErrOccurred = false;\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    std::pair<vsi_l_offset, vsi_l_offset> oPair;\n    if( m_oCacheStrileToOffsetByteCount.tryGet(nBlockId, oPair) )\n    {\n        if( pnOffset )\n            *pnOffset = oPair.first;\n        if( pnSize )\n            *pnSize = oPair.second;\n        return oPair.first != 0;\n    }\n#endif\n    \n    WaitCompletionForBlock(nBlockId);\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    // Optimization to avoid fetching the whole Strip/TileCounts and\n    // Strip/TileOffsets arrays.\n    if( eAccess == GA_ReadOnly && !m_bStreamingIn )\n    {\n        int nErrOccurred = 0;\n        auto bytecount = TIFFGetStrileByteCountWithErr(m_hTIFF, nBlockId, &nErrOccurred);\n        if( nErrOccurred && pbErrOccurred )\n            *pbErrOccurred = true;\n        if( pnOffset )\n        {\n            *pnOffset = TIFFGetStrileOffsetWithErr(m_hTIFF, nBlockId, &nErrOccurred);\n            if( nErrOccurred && pbErrOccurred )\n                *pbErrOccurred = true;\n        }\n        if( pnSize )\n            *pnSize = bytecount;\n        return bytecount != 0;\n    }\n#endif\n\n    toff_t *panByteCounts = nullptr;\n    toff_t *panOffsets = nullptr;\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(m_hTIFF) );\n\n    if( ( bIsTiled\n          && TIFFGetField( m_hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts )\n          && (pnOffset == nullptr ||\n              TIFFGetField( m_hTIFF, TIFFTAG_TILEOFFSETS, &panOffsets )) )\n        || ( !bIsTiled\n          && TIFFGetField( m_hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts )\n          && (pnOffset == nullptr ||\n              TIFFGetField( m_hTIFF, TIFFTAG_STRIPOFFSETS, &panOffsets )) ) )\n    {\n        if( panByteCounts == nullptr || (pnOffset != nullptr && panOffsets == nullptr) )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n        const int nBlockCount =\n            bIsTiled ? TIFFNumberOfTiles(m_hTIFF) : TIFFNumberOfStrips(m_hTIFF);\n        if( nBlockId >= nBlockCount )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        if( pnOffset )\n            *pnOffset = panOffsets[nBlockId];\n        if( pnSize )\n            *pnSize = panByteCounts[nBlockId];\n        return panByteCounts[nBlockId] != 0;\n    }\n    else\n    {\n        if( pbErrOccurred )\n            *pbErrOccurred = true;\n    }\n\n    return false;\n}",
    "void GTiffDataset::FlushDirectory()\n\n{\n    if( GetAccess() == GA_Update )\n    {\n        if( m_bMetadataChanged )\n        {\n            m_bNeedsRewrite =\n                    WriteMetadata( this, m_hTIFF, true, m_eProfile, m_pszFilename,\n                                   m_papszCreationOptions );\n            m_bMetadataChanged = false;\n\n            if( m_bForceUnsetRPC )\n            {\n                double *padfRPCTag = nullptr;\n                uint16 nCount;\n                if( TIFFGetField( m_hTIFF, TIFFTAG_RPCCOEFFICIENT, &nCount, &padfRPCTag ) )\n                {\n                    std::vector<double> zeroes(92);\n                    TIFFSetField( m_hTIFF, TIFFTAG_RPCCOEFFICIENT, 92, zeroes.data() );\n                    TIFFUnsetField( m_hTIFF, TIFFTAG_RPCCOEFFICIENT );\n                    m_bNeedsRewrite = true;\n                }\n\n                GDALWriteRPCTXTFile( m_pszFilename, nullptr );\n                GDALWriteRPBFile( m_pszFilename, nullptr );\n            }\n        }\n\n        if( m_bGeoTIFFInfoChanged )\n        {\n            WriteGeoTIFFInfo();\n            m_bGeoTIFFInfoChanged = false;\n        }\n\n        if( m_bNoDataChanged )\n        {\n            if( m_bNoDataSet )\n            {\n                WriteNoDataValue( m_hTIFF, m_dfNoDataValue );\n            }\n            else\n            {\n                UnsetNoDataValue( m_hTIFF );\n            }\n            m_bNeedsRewrite = true;\n            m_bNoDataChanged = false;\n        }\n\n        if( m_bNeedsRewrite )\n        {\n            if( !m_bCrystalized)\n            {\n                Crystalize();\n            }\n            else\n            {\n                const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( m_hTIFF );\n\n                m_nDirOffset = pfnSizeProc( TIFFClientdata( m_hTIFF ) );\n                if( (m_nDirOffset % 2) == 1 )\n                    ++m_nDirOffset;\n\n                TIFFRewriteDirectory( m_hTIFF );\n\n                TIFFSetSubDirectory( m_hTIFF, m_nDirOffset );\n\n                if( m_bLayoutIFDSBeforeData &&\n                    m_bBlockOrderRowMajor &&\n                    m_bLeaderSizeAsUInt4 &&\n                    m_bTrailerRepeatedLast4BytesRepeated &&\n                    !m_bKnownIncompatibleEdition &&\n                    !m_bWriteKnownIncompatibleEdition )\n                {\n                    ReportError(CE_Warning, CPLE_AppDefined,\n                                \"The IFD has been rewritten at the end of \"\n                                \"the file, which breaks COG layout.\");\n                    m_bKnownIncompatibleEdition = true;\n                    m_bWriteKnownIncompatibleEdition = true;\n                }\n            }\n            m_bNeedsRewrite = false;\n        }\n    }\n\n    // There are some circumstances in which we can reach this point\n    // without having made this our directory (SetDirectory()) in which\n    // case we should not risk a flush.\n    if( GetAccess() == GA_Update && TIFFCurrentDirOffset(m_hTIFF) == m_nDirOffset )\n    {\n        const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( m_hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( m_hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            ++nNewDirOffset;\n\n        TIFFFlush( m_hTIFF );\n\n        if( m_nDirOffset != TIFFCurrentDirOffset( m_hTIFF ) )\n        {\n            m_nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\",\n                      \"directory moved during flush in FlushDirectory()\" );\n        }\n    }\n\n    SetDirectory();\n}",
    "CPLErr GTiffDataset::CreateOverviewsFromSrcOverviews(GDALDataset* poSrcDS,\n                                                     GDALDataset* poOvrDS)\n{\n    CPLAssert(poSrcDS->GetRasterCount() != 0);\n    CPLAssert(m_nOverviewCount == 0);\n\n    ScanDirectories();\n\n    FlushDirectory();\n\n    int nOvBitsPerSample = m_nBitsPerSample;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed;\n    std::vector<unsigned short> anTGreen;\n    std::vector<unsigned short> anTBlue;\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( m_nPhotometric == PHOTOMETRIC_PALETTE && m_poColorTable != nullptr )\n    {\n        CreateTIFFColorTable(m_poColorTable, nOvBitsPerSample,\n                             anTRed, anTGreen, anTBlue,\n                             panRed, panGreen, panBlue);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( \"NONE\", this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = nullptr;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( m_hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples,\n                      &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew =\n            static_cast<uint16*>(\n                CPLMalloc(nExtraSamples * sizeof(uint16)) );\n        memcpy( panExtraSampleValuesNew, panExtraSampleValues,\n                nExtraSamples * sizeof(uint16));\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = nullptr;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if( m_nCompression == COMPRESSION_LZW ||\n        m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        m_nCompression == COMPRESSION_ZSTD )\n        TIFFGetField( m_hTIFF, TIFFTAG_PREDICTOR, &nPredictor );\n    int nOvrBlockXSize = 0;\n    int nOvrBlockYSize = 0;\n    GTIFFGetOverviewBlockSize(GDALRasterBand::ToHandle(GetRasterBand(1)),\n                              &nOvrBlockXSize, &nOvrBlockYSize);\n\n    int nSrcOverviews = poOvrDS ?\n        poOvrDS->GetRasterBand(1)->GetOverviewCount() + 1:\n        poSrcDS->GetRasterBand(1)->GetOverviewCount();\n    CPLErr eErr = CE_None;\n\n    for( int i = 0; i < nSrcOverviews && eErr == CE_None; ++i )\n    {\n        GDALRasterBand* poOvrBand = poOvrDS ?\n            ((i == 0) ? poOvrDS->GetRasterBand(1) :\n                        poOvrDS->GetRasterBand(1)->GetOverview(i-1)):\n            poSrcDS->GetRasterBand(1)->GetOverview(i);\n\n        int nOXSize = poOvrBand->GetXSize();\n        int nOYSize = poOvrBand->GetYSize();\n\n        int nOvrJpegQuality = m_nJpegQuality;\n        if( m_nCompression == COMPRESSION_JPEG &&\n            CPLGetConfigOption( \"JPEG_QUALITY_OVERVIEW\", nullptr ) != nullptr )\n        {\n            nOvrJpegQuality =\n                atoi(CPLGetConfigOption(\"JPEG_QUALITY_OVERVIEW\",\"75\"));\n        }\n        int nOvrWebpLevel = m_nWebPLevel;\n        if( m_nCompression == COMPRESSION_WEBP &&\n            CPLGetConfigOption( \"WEBP_LEVEL_OVERVIEW\", nullptr ) != nullptr )\n        {\n            nOvrWebpLevel =\n                atoi(CPLGetConfigOption(\"WEBP_LEVEL_OVERVIEW\",\"75\"));\n        }\n\n        CPLString osNoData; // don't move this in inner scope\n        const char* pszNoData = nullptr;\n        if( m_bNoDataSet )\n        {\n            osNoData = GTiffFormatGDALNoDataTagValue(m_dfNoDataValue);\n            pszNoData = osNoData.c_str();\n        }\n\n        toff_t nOverviewOffset =\n                GTIFFWriteDirectory(m_hTIFF, FILETYPE_REDUCEDIMAGE,\n                                    nOXSize, nOYSize,\n                                    nOvBitsPerSample, m_nPlanarConfig,\n                                    m_nSamplesPerPixel,\n                                    nOvrBlockXSize,\n                                    nOvrBlockYSize,\n                                    TRUE,\n                                    m_nCompression, m_nPhotometric, m_nSampleFormat,\n                                    nPredictor,\n                                    panRed, panGreen, panBlue,\n                                    nExtraSamples, panExtraSampleValues,\n                                    osMetadata,\n                                    nOvrJpegQuality >= 0 ?\n                                        CPLSPrintf(\"%d\", nOvrJpegQuality) : nullptr,\n                                    CPLSPrintf(\"%d\", m_nJpegTablesMode),\n                                    pszNoData,\n#ifdef HAVE_LERC\n                                    m_anLercAddCompressionAndVersion,\n#else\n                                    nullptr,\n#endif\n                                    m_bWriteCOGLayout,\n                                    nOvrWebpLevel >= 0 ?\n                                        CPLSPrintf(\"%d\", nOvrWebpLevel) : nullptr\n                                   );\n\n        if( nOverviewOffset == 0 )\n            eErr = CE_Failure;\n        else\n            eErr = RegisterNewOverviewDataset(nOverviewOffset, nOvrJpegQuality, nOvrWebpLevel);\n    }\n\n    // For directory reloading, so that the chaining to the next directory is\n    // reloaded, as well as compression parameters.\n    ReloadDirectory();\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = nullptr;\n\n    return eErr;\n}",
    "CPLErr GTiffDataset::IBuildOverviews(\n    const char * pszResampling,\n    int nOverviews, int * panOverviewList,\n    int nBandsIn, int * panBandList,\n    GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    ScanDirectories();\n\n    // Make implicit JPEG overviews invisible, but do not destroy\n    // them in case they are already used (not sure that the client\n    // has the right to do that.  Behavior maybe undefined in GDAL API.\n    m_nJPEGOverviewCount = 0;\n\n/* -------------------------------------------------------------------- */\n/*      If RRD or external OVR overviews requested, then invoke         */\n/*      generic handling.                                               */\n/* -------------------------------------------------------------------- */\n    bool bUseGenericHandling = false;\n\n    if( CPLTestBool(CPLGetConfigOption( \"USE_RRD\", \"NO\" ))\n        || CPLTestBool(CPLGetConfigOption( \"TIFF_USE_OVR\", \"NO\" )) )\n    {\n        bUseGenericHandling = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have read access, then create the overviews         */\n/*      externally.                                                     */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() != GA_Update )\n    {\n        CPLDebug( \"GTiff\",\n                  \"File open for read-only accessing, \"\n                  \"creating overviews externally.\" );\n\n        bUseGenericHandling = true;\n    }\n\n    if( bUseGenericHandling )\n    {\n        if( m_nOverviewCount != 0 )\n        {\n            ReportError(\n                CE_Failure, CPLE_NotSupported,\n                \"Cannot add external overviews when there are already \"\n                \"internal overviews\" );\n            return CE_Failure;\n        }\n\n        CPLErr eErr = GDALDataset::IBuildOverviews(\n            pszResampling, nOverviews, panOverviewList,\n            nBandsIn, panBandList, pfnProgress, pProgressData );\n        if( eErr == CE_None && m_poMaskDS )\n        {\n            ReportError(CE_Warning, CPLE_NotSupported,\n                     \"Building external overviews whereas there is an internal \"\n                     \"mask is not fully supported. \"\n                     \"The overviews of the non-mask bands will be created, \"\n                     \"but not the overviews of the mask band.\");\n        }\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Our TIFF overview support currently only works safely if all    */\n/*      bands are handled at the same time.                             */\n/* -------------------------------------------------------------------- */\n    if( nBandsIn != GetRasterCount() )\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"Generation of overviews in TIFF currently only \"\n                  \"supported when operating on all bands.  \"\n                  \"Operation failed.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If zero overviews were requested, we need to clear all          */\n/*      existing overviews.                                             */\n/* -------------------------------------------------------------------- */\n    if( nOverviews == 0 )\n    {\n        if( m_nOverviewCount == 0 )\n            return GDALDataset::IBuildOverviews(\n                pszResampling, nOverviews, panOverviewList,\n                nBandsIn, panBandList, pfnProgress, pProgressData );\n\n        return CleanOverviews();\n    }\n\n    CPLErr eErr = CE_None;\n\n/* -------------------------------------------------------------------- */\n/*      Initialize progress counter.                                    */\n/* -------------------------------------------------------------------- */\n    if( !pfnProgress( 0.0, nullptr, pProgressData ) )\n    {\n        ReportError( CE_Failure, CPLE_UserInterrupt, \"User terminated\" );\n        return CE_Failure;\n    }\n\n    FlushDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      If we are averaging bit data to grayscale we need to create     */\n/*      8bit overviews.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvBitsPerSample = m_nBitsPerSample;\n\n    if( STARTS_WITH_CI(pszResampling, \"AVERAGE_BIT2\") )\n        nOvBitsPerSample = 8;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed;\n    std::vector<unsigned short> anTGreen;\n    std::vector<unsigned short> anTBlue;\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( m_nPhotometric == PHOTOMETRIC_PALETTE && m_poColorTable != nullptr )\n    {\n        CreateTIFFColorTable(m_poColorTable, nOvBitsPerSample,\n                             anTRed, anTGreen, anTBlue,\n                             panRed, panGreen, panBlue);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( pszResampling, this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = nullptr;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( m_hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples,\n                      &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew =\n            static_cast<uint16*>( CPLMalloc(nExtraSamples * sizeof(uint16)) );\n        memcpy( panExtraSampleValuesNew, panExtraSampleValues,\n                nExtraSamples * sizeof(uint16) );\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = nullptr;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if( m_nCompression == COMPRESSION_LZW ||\n        m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        m_nCompression == COMPRESSION_ZSTD )\n        TIFFGetField( m_hTIFF, TIFFTAG_PREDICTOR, &nPredictor );\n\n/* -------------------------------------------------------------------- */\n/*      Establish which of the overview levels we already have, and     */\n/*      which are new.  We assume that band 1 of the file is            */\n/*      representative.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvrBlockXSize = 0;\n    int nOvrBlockYSize = 0;\n    GTIFFGetOverviewBlockSize(GDALRasterBand::ToHandle(GetRasterBand(1)),\n                              &nOvrBlockXSize, &nOvrBlockYSize);\n    std::vector<bool> abRequireNewOverview(nOverviews, true);\n    for( int i = 0; i < nOverviews && eErr == CE_None; ++i )\n    {\n        for( int j = 0; j < m_nOverviewCount && eErr == CE_None; ++j )\n        {\n            GTiffDataset *poODS = m_papoOverviewDS[j];\n\n            const int nOvFactor =\n                GDALComputeOvFactor(poODS->GetRasterXSize(),\n                                    GetRasterXSize(),\n                                    poODS->GetRasterYSize(),\n                                    GetRasterYSize());\n\n            // If we already have a 1x1 overview and this new one would result\n            // in it too, then don't create it.\n            if( poODS->GetRasterXSize() == 1 &&\n                poODS->GetRasterYSize() == 1 &&\n                (GetRasterXSize() + panOverviewList[i] - 1)\n                    / panOverviewList[i] == 1 &&\n                (GetRasterYSize() + panOverviewList[i] - 1)\n                    / panOverviewList[i] == 1 )\n            {\n                abRequireNewOverview[i] = false;\n                break;\n            }\n\n            if( nOvFactor == panOverviewList[i]\n                || nOvFactor == GDALOvLevelAdjust2( panOverviewList[i],\n                                                    GetRasterXSize(),\n                                                    GetRasterYSize() ) )\n            {\n                abRequireNewOverview[i] = false;\n                break;\n            }\n        }\n\n        if( abRequireNewOverview[i] )\n        {\n            if( m_bLayoutIFDSBeforeData && !m_bKnownIncompatibleEdition &&\n                !m_bWriteKnownIncompatibleEdition )\n            {\n                ReportError(CE_Warning, CPLE_AppDefined,\n                         \"Adding new overviews invalidates the \"\n                         \"LAYOUT=IFDS_BEFORE_DATA property\");\n                m_bKnownIncompatibleEdition = true;\n                m_bWriteKnownIncompatibleEdition = true;\n            }\n\n            const int nOXSize =\n                (GetRasterXSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n            const int nOYSize =\n                (GetRasterYSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n\n            int nOvrJpegQuality = m_nJpegQuality;\n            if( m_nCompression == COMPRESSION_JPEG &&\n                CPLGetConfigOption( \"JPEG_QUALITY_OVERVIEW\", nullptr ) != nullptr )\n            {\n                nOvrJpegQuality =\n                    atoi(CPLGetConfigOption(\"JPEG_QUALITY_OVERVIEW\",\"75\"));\n            }\n            int nOvrWebpLevel = m_nWebPLevel;\n            if( m_nCompression == COMPRESSION_WEBP &&\n                CPLGetConfigOption( \"WEBP_LEVEL_OVERVIEW\", nullptr ) != nullptr )\n            {\n                nOvrWebpLevel =\n                    atoi(CPLGetConfigOption(\"WEBP_LEVEL_OVERVIEW\",\"75\"));\n            }\n\n            CPLString osNoData; // don't move this in inner scope\n            const char* pszNoData = nullptr;\n            if( m_bNoDataSet )\n            {\n                osNoData = GTiffFormatGDALNoDataTagValue(m_dfNoDataValue);\n                pszNoData = osNoData.c_str();\n            }\n\n            const toff_t nOverviewOffset =\n                GTIFFWriteDirectory(\n                    m_hTIFF, FILETYPE_REDUCEDIMAGE,\n                    nOXSize, nOYSize,\n                    nOvBitsPerSample, m_nPlanarConfig,\n                    m_nSamplesPerPixel, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                    m_nCompression, m_nPhotometric, m_nSampleFormat,\n                    nPredictor,\n                    panRed, panGreen, panBlue,\n                    nExtraSamples, panExtraSampleValues,\n                    osMetadata,\n                    nOvrJpegQuality >= 0 ?\n                                CPLSPrintf(\"%d\", nOvrJpegQuality) : nullptr,\n                    CPLSPrintf(\"%d\", m_nJpegTablesMode),\n                    pszNoData,\n#ifdef HAVE_LERC\n                    m_anLercAddCompressionAndVersion,\n#else\n                    nullptr,\n#endif\n                    false,\n                    nOvrWebpLevel >= 0 ?\n                                CPLSPrintf(\"%d\", nOvrWebpLevel) : nullptr\n            );\n\n            if( nOverviewOffset == 0 )\n                eErr = CE_Failure;\n            else\n                eErr = RegisterNewOverviewDataset(nOverviewOffset,\n                                                  nOvrJpegQuality,\n                                                  nOvrWebpLevel);\n        }\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = nullptr;\n\n    ReloadDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    if( eErr != CE_None )\n        return eErr;\n\n    eErr = CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n\n/* -------------------------------------------------------------------- */\n/*      Refresh overviews for the mask                                  */\n/* -------------------------------------------------------------------- */\n    if( m_poMaskDS != nullptr &&\n        m_poMaskDS->GetRasterCount() == 1 )\n    {\n        int nMaskOverviews = 0;\n\n        GDALRasterBand **papoOverviewBands = static_cast<GDALRasterBand **>(\n            CPLCalloc(sizeof(void*),m_nOverviewCount) );\n        for( int i = 0; i < m_nOverviewCount; ++i )\n        {\n            if( m_papoOverviewDS[i]->m_poMaskDS != nullptr )\n            {\n                papoOverviewBands[nMaskOverviews++] =\n                        m_papoOverviewDS[i]->m_poMaskDS->GetRasterBand(1);\n            }\n        }\n        eErr = GDALRegenerateOverviews(\n            m_poMaskDS->GetRasterBand(1),\n            nMaskOverviews,\n            reinterpret_cast<GDALRasterBandH *>( papoOverviewBands ),\n            pszResampling, GDALDummyProgress, nullptr );\n        CPLFree(papoOverviewBands);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Refresh old overviews that were listed.                         */\n/* -------------------------------------------------------------------- */\n    if( m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        GDALDataTypeIsComplex(GetRasterBand( panBandList[0] )->\n                              GetRasterDataType()) == FALSE &&\n        GetRasterBand( panBandList[0] )->GetColorTable() == nullptr &&\n        (STARTS_WITH_CI(pszResampling, \"NEAR\") ||\n         EQUAL(pszResampling, \"AVERAGE\") ||\n         EQUAL(pszResampling, \"GAUSS\") ||\n         EQUAL(pszResampling, \"CUBIC\") ||\n         EQUAL(pszResampling, \"CUBICSPLINE\") ||\n         EQUAL(pszResampling, \"LANCZOS\") ||\n         EQUAL(pszResampling, \"BILINEAR\")) )\n    {\n        // In the case of pixel interleaved compressed overviews, we want to\n        // generate the overviews for all the bands block by block, and not\n        // band after band, in order to write the block once and not loose\n        // space in the TIFF file.  We also use that logic for uncompressed\n        // overviews, since GDALRegenerateOverviewsMultiBand() will be able to\n        // trigger cascading overview regeneration even in the presence\n        // of an alpha band.\n\n        int nNewOverviews = 0;\n\n        GDALRasterBand ***papapoOverviewBands =\n            static_cast<GDALRasterBand ***>(CPLCalloc(sizeof(void*),nBandsIn));\n        GDALRasterBand **papoBandList =\n            static_cast<GDALRasterBand **>(CPLCalloc(sizeof(void*),nBandsIn));\n        for( int iBand = 0; iBand < nBandsIn; ++iBand )\n        {\n            GDALRasterBand* poBand = GetRasterBand( panBandList[iBand] );\n\n            papoBandList[iBand] = poBand;\n            papapoOverviewBands[iBand] =\n                static_cast<GDALRasterBand **>( CPLCalloc(\n                    sizeof(void*), poBand->GetOverviewCount()) );\n\n            int iCurOverview = 0;\n            std::vector<bool> abAlreadyUsedOverviewBand(\n                poBand->GetOverviewCount(), false);\n\n            for( int i = 0; i < nOverviews; ++i )\n            {\n                for( int j = 0; j < poBand->GetOverviewCount(); ++j )\n                {\n                    if( abAlreadyUsedOverviewBand[j] )\n                        continue;\n\n                    int    nOvFactor;\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    nOvFactor = GDALComputeOvFactor(poOverview->GetXSize(),\n                                                     poBand->GetXSize(),\n                                                     poOverview->GetYSize(),\n                                                     poBand->GetYSize());\n\n                    int bHasNoData = FALSE;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if( bHasNoData )\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    if( nOvFactor == panOverviewList[i]\n                        || nOvFactor == GDALOvLevelAdjust2(\n                                            panOverviewList[i],\n                                            poBand->GetXSize(),\n                                            poBand->GetYSize() ) )\n                    {\n                        abAlreadyUsedOverviewBand[j] = true;\n                        CPLAssert(iCurOverview < poBand->GetOverviewCount());\n                        papapoOverviewBands[iBand][iCurOverview] = poOverview;\n                        ++iCurOverview ;\n                        break;\n                    }\n                }\n            }\n\n            if( nNewOverviews == 0 )\n            {\n                nNewOverviews = iCurOverview;\n            }\n            else if( nNewOverviews != iCurOverview )\n            {\n                CPLAssert(false);\n                return CE_Failure;\n            }\n        }\n\n        GDALRegenerateOverviewsMultiBand( nBandsIn, papoBandList,\n                                          nNewOverviews, papapoOverviewBands,\n                                          pszResampling, pfnProgress,\n                                          pProgressData );\n\n        for( int iBand = 0; iBand < nBandsIn; ++iBand )\n        {\n            CPLFree(papapoOverviewBands[iBand]);\n        }\n        CPLFree(papapoOverviewBands);\n        CPLFree(papoBandList);\n    }\n    else\n    {\n        GDALRasterBand **papoOverviewBands = static_cast<GDALRasterBand **>(\n            CPLCalloc(sizeof(void*), nOverviews) );\n\n        for( int iBand = 0; iBand < nBandsIn && eErr == CE_None; ++iBand )\n        {\n            GDALRasterBand *poBand = GetRasterBand( panBandList[iBand] );\n            if( poBand == nullptr )\n            {\n                eErr = CE_Failure;\n                break;\n            }\n\n            std::vector<bool> abAlreadyUsedOverviewBand(\n                poBand->GetOverviewCount(), false);\n\n            int nNewOverviews = 0;\n            for( int i = 0; i < nOverviews; ++i )\n            {\n                for( int j = 0; j < poBand->GetOverviewCount(); ++j )\n                {\n                    if( abAlreadyUsedOverviewBand[j] )\n                        continue;\n\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    int bHasNoData = FALSE;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if( bHasNoData )\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    const int nOvFactor =\n                        GDALComputeOvFactor(poOverview->GetXSize(),\n                                            poBand->GetXSize(),\n                                            poOverview->GetYSize(),\n                                            poBand->GetYSize());\n\n                    if( nOvFactor == panOverviewList[i]\n                        || nOvFactor == GDALOvLevelAdjust2(\n                                            panOverviewList[i],\n                                            poBand->GetXSize(),\n                                            poBand->GetYSize() ) )\n                    {\n                        abAlreadyUsedOverviewBand[j] = true;\n                        CPLAssert(nNewOverviews < poBand->GetOverviewCount());\n                        papoOverviewBands[nNewOverviews++] = poOverview;\n                        break;\n                    }\n                }\n            }\n\n            void *pScaledProgressData =\n                GDALCreateScaledProgress(\n                    iBand / static_cast<double>( nBandsIn ),\n                    (iBand + 1) / static_cast<double>( nBandsIn ),\n                    pfnProgress, pProgressData );\n\n            eErr = GDALRegenerateOverviews(\n                poBand,\n                nNewOverviews,\n                reinterpret_cast<GDALRasterBandH *>( papoOverviewBands ),\n                pszResampling,\n                GDALScaledProgress,\n                pScaledProgressData );\n\n            GDALDestroyScaledProgress( pScaledProgressData );\n        }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup                                                         */\n    /* -------------------------------------------------------------------- */\n        CPLFree( papoOverviewBands );\n    }\n\n    pfnProgress( 1.0, nullptr, pProgressData );\n\n    return eErr;\n}",
    "static void WriteMDMetadata( GDALMultiDomainMetadata *poMDMD, TIFF *hTIFF,\n                             CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail,\n                             int nBand, GTiffProfile eProfile )\n\n{\n\n/* ==================================================================== */\n/*      Process each domain.                                            */\n/* ==================================================================== */\n    char **papszDomainList = poMDMD->GetDomainList();\n    for( int iDomain = 0;\n         papszDomainList && papszDomainList[iDomain];\n         ++iDomain )\n    {\n        char **papszMD = poMDMD->GetMetadata( papszDomainList[iDomain] );\n        bool bIsXML = false;\n\n        if( EQUAL(papszDomainList[iDomain], \"IMAGE_STRUCTURE\") )\n            continue;  // Ignored.\n        if( EQUAL(papszDomainList[iDomain], \"COLOR_PROFILE\") )\n            continue;  // Ignored.\n        if( EQUAL(papszDomainList[iDomain], MD_DOMAIN_RPC) )\n            continue;  // Handled elsewhere.\n        if( EQUAL(papszDomainList[iDomain], \"xml:ESRI\")\n            && CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n            continue;  // Handled elsewhere.\n        if( EQUAL(papszDomainList[iDomain], \"xml:XMP\") )\n            continue;  // Handled in SetMetadata.\n\n        if( STARTS_WITH_CI(papszDomainList[iDomain], \"xml:\") )\n            bIsXML = true;\n\n/* -------------------------------------------------------------------- */\n/*      Process each item in this domain.                               */\n/* -------------------------------------------------------------------- */\n        for( int iItem = 0; papszMD && papszMD[iItem]; ++iItem )\n        {\n            const char *pszItemValue = nullptr;\n            char *pszItemName = nullptr;\n\n            if( bIsXML )\n            {\n                pszItemName = CPLStrdup(\"doc\");\n                pszItemValue = papszMD[iItem];\n            }\n            else\n            {\n                pszItemValue = CPLParseNameValue( papszMD[iItem], &pszItemName);\n                if( pszItemName == nullptr )\n                {\n                    CPLDebug( \"GTiff\",\n                              \"Invalid metadata item : %s\", papszMD[iItem] );\n                    continue;\n                }\n            }\n\n/* -------------------------------------------------------------------- */\n/*      Convert into XML item or handle as a special TIFF tag.          */\n/* -------------------------------------------------------------------- */\n            if( strlen(papszDomainList[iDomain]) == 0\n                && nBand == 0 &&\n                (STARTS_WITH_CI(pszItemName, \"TIFFTAG_\") ||\n                 (EQUAL(pszItemName, \"GEO_METADATA\") &&\n                  eProfile == GTiffProfile::GDALGEOTIFF) ||\n                 (EQUAL(pszItemName, \"TIFF_RSID\") &&\n                  eProfile == GTiffProfile::GDALGEOTIFF)) )\n            {\n                if( EQUAL(pszItemName, \"TIFFTAG_RESOLUTIONUNIT\") )\n                {\n                    // ResolutionUnit can't be 0, which is the default if\n                    // atoi() fails.  Set to 1=Unknown.\n                    int v = atoi(pszItemValue);\n                    if( !v ) v = RESUNIT_NONE;\n                    TIFFSetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, v);\n                }\n                else\n                {\n                    bool bFoundTag = false;\n                    size_t iTag = 0;  // Used after for.\n                    for( ;\n                         iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n                         ++iTag )\n                    {\n                        if( EQUAL(pszItemName, asTIFFTags[iTag].pszTagName) )\n                        {\n                            bFoundTag = true;\n                            break;\n                        }\n                    }\n\n                    if( bFoundTag &&\n                        asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      pszItemValue );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      CPLAtof(pszItemValue) );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      atoi(pszItemValue) );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING )\n                    {\n                        uint32 nLen = static_cast<uint32>(strlen(pszItemValue));\n                        if( nLen )\n                        {\n                            TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                          nLen,\n                                          pszItemValue );\n                        }\n                    }\n                    else\n                        CPLError(\n                            CE_Warning, CPLE_NotSupported,\n                            \"%s metadata item is unhandled and \"\n                            \"will not be written\",\n                            pszItemName);\n                }\n            }\n            else if( nBand == 0 && EQUAL(pszItemName,GDALMD_AREA_OR_POINT) )\n            {\n                /* Do nothing, handled elsewhere. */;\n            }\n            else\n            {\n                AppendMetadataItem( ppsRoot, ppsTail,\n                                    pszItemName, pszItemValue,\n                                    nBand, nullptr, papszDomainList[iDomain] );\n            }\n\n            CPLFree( pszItemName );\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Remove TIFFTAG_xxxxxx that are already set but no longer in     */\n/*      the metadata list (#5619)                                       */\n/* -------------------------------------------------------------------- */\n        if( strlen(papszDomainList[iDomain]) == 0 && nBand == 0 )\n        {\n            for( size_t iTag = 0;\n                 iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n                 ++iTag )\n            {\n                uint32 nCount = 0;\n                char* pszText = nullptr;\n                int16 nVal = 0;\n                float fVal = 0.0f;\n                const char* pszVal =\n                    CSLFetchNameValue(papszMD, asTIFFTags[iTag].pszTagName);\n                if( pszVal == nullptr &&\n                    ((asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                    &pszText )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &nVal )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &fVal )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &nCount, &pszText ))) )\n                {\n                    TIFFUnsetField( hTIFF, asTIFFTags[iTag].nTagVal );\n                }\n            }\n        }\n    }\n}",
    "bool GTiffDataset::WriteMetadata( GDALDataset *poSrcDS, TIFF *l_hTIFF,\n                                  bool bSrcIsGeoTIFF,\n                                  GTiffProfile eProfile,\n                                  const char *pszTIFFFilename,\n                                  char **l_papszCreationOptions,\n                                  bool bExcludeRPBandIMGFileWriting)\n\n{\n/* -------------------------------------------------------------------- */\n/*      Convert all the remaining metadata into a simple XML            */\n/*      format.                                                         */\n/* -------------------------------------------------------------------- */\n    CPLXMLNode *psRoot = nullptr;\n    CPLXMLNode *psTail = nullptr;\n\n    if( bSrcIsGeoTIFF )\n    {\n        GTiffDataset* poSrcDSGTiff = cpl::down_cast<GTiffDataset *>(poSrcDS);\n        assert(poSrcDSGTiff);\n        WriteMDMetadata(\n            &poSrcDSGTiff->m_oGTiffMDMD,\n            l_hTIFF, &psRoot, &psTail, 0, eProfile );\n    }\n    else\n    {\n        char **papszMD = poSrcDS->GetMetadata();\n\n        if( CSLCount(papszMD) > 0 )\n        {\n            GDALMultiDomainMetadata l_oMDMD;\n            l_oMDMD.SetMetadata( papszMD );\n\n            WriteMDMetadata( &l_oMDMD, l_hTIFF, &psRoot, &psTail,\n                             0, eProfile );\n        }\n    }\n\n    if( !bExcludeRPBandIMGFileWriting )\n    {\n        WriteRPC(poSrcDS, l_hTIFF, bSrcIsGeoTIFF,\n                 eProfile, pszTIFFFilename,\n                 l_papszCreationOptions);\n\n/* -------------------------------------------------------------------- */\n/*      Handle metadata data written to an IMD file.                    */\n/* -------------------------------------------------------------------- */\n        char **papszIMDMD = poSrcDS->GetMetadata(MD_DOMAIN_IMD);\n        if( papszIMDMD != nullptr )\n        {\n            GDALWriteIMDFile( pszTIFFFilename, papszIMDMD );\n        }\n    }\n\n    uint16 nPhotometric = 0;\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    const bool bStardardColorInterp =\n        IsStandardColorInterpretation(poSrcDS, nPhotometric,\n                                      l_papszCreationOptions);\n\n/* -------------------------------------------------------------------- */\n/*      We also need to address band specific metadata, and special     */\n/*      \"role\" metadata.                                                */\n/* -------------------------------------------------------------------- */\n    for( int nBand = 1; nBand <= poSrcDS->GetRasterCount(); ++nBand )\n    {\n        GDALRasterBand *poBand = poSrcDS->GetRasterBand( nBand );\n\n        if( bSrcIsGeoTIFF )\n        {\n            GTiffRasterBand* poSrcBandGTiff = cpl::down_cast<GTiffRasterBand *>(poBand);\n            assert(poSrcBandGTiff);\n            WriteMDMetadata(\n                &poSrcBandGTiff->m_oGTiffMDMD,\n                l_hTIFF, &psRoot, &psTail, nBand, eProfile );\n        }\n        else\n        {\n            char **papszMD = poBand->GetMetadata();\n\n            if( CSLCount(papszMD) > 0 )\n            {\n                GDALMultiDomainMetadata l_oMDMD;\n                l_oMDMD.SetMetadata( papszMD );\n\n                WriteMDMetadata( &l_oMDMD, l_hTIFF, &psRoot, &psTail, nBand,\n                                 eProfile );\n            }\n        }\n\n        const double dfOffset = poBand->GetOffset();\n        const double dfScale = poBand->GetScale();\n        bool bGeoTIFFScaleOffsetInZ = false;\n        double adfGeoTransform[6];\n        // Check if we have already encoded scale/offset in the GeoTIFF tags\n        if( poSrcDS->GetGeoTransform(adfGeoTransform) == CE_None &&\n            adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0\n            && adfGeoTransform[5] < 0.0 &&\n            poSrcDS->GetSpatialRef() &&\n            poSrcDS->GetSpatialRef()->IsVertical() &&\n            poSrcDS->GetRasterCount() == 1 )\n        {\n            bGeoTIFFScaleOffsetInZ = true;\n        }\n\n        if( (dfOffset != 0.0 || dfScale != 1.0) && !bGeoTIFFScaleOffsetInZ )\n        {\n            char szValue[128] = {};\n\n            CPLsnprintf( szValue, sizeof(szValue), \"%.18g\", dfOffset );\n            AppendMetadataItem( &psRoot, &psTail, \"OFFSET\", szValue, nBand,\n                                \"offset\", \"\" );\n            CPLsnprintf( szValue, sizeof(szValue), \"%.18g\", dfScale );\n            AppendMetadataItem( &psRoot, &psTail, \"SCALE\", szValue, nBand,\n                                \"scale\", \"\" );\n        }\n\n        const char* pszUnitType = poBand->GetUnitType();\n        if( pszUnitType != nullptr && pszUnitType[0] != '\\0' )\n        {\n            bool bWriteUnit = true;\n            auto poSRS = poSrcDS->GetSpatialRef();\n            if( poSRS && poSRS->IsCompound() )\n            {\n                const char* pszVertUnit = nullptr;\n                poSRS->GetTargetLinearUnits(\"COMPD_CS|VERT_CS\", &pszVertUnit);\n                if( pszVertUnit && EQUAL(pszVertUnit, pszUnitType) )\n                {\n                    bWriteUnit = false;\n                }\n            }\n            if( bWriteUnit )\n            {\n                AppendMetadataItem( &psRoot, &psTail, \"UNITTYPE\",\n                                    pszUnitType, nBand,\n                                    \"unittype\", \"\" );\n            }\n        }\n\n        if( strlen(poBand->GetDescription()) > 0 )\n        {\n            AppendMetadataItem( &psRoot, &psTail, \"DESCRIPTION\",\n                                poBand->GetDescription(), nBand,\n                                \"description\", \"\" );\n        }\n\n        if( !bStardardColorInterp &&\n            !(nBand <= 3 &&  EQUAL(CSLFetchNameValueDef(\n                l_papszCreationOptions, \"PHOTOMETRIC\", \"\"), \"RGB\") ) )\n        {\n            AppendMetadataItem( &psRoot, &psTail, \"COLORINTERP\",\n                                GDALGetColorInterpretationName(\n                                    poBand->GetColorInterpretation()),\n                                nBand,\n                                \"colorinterp\", \"\" );\n        }\n    }\n\n    const char* pszTilingSchemeName =\n        CSLFetchNameValue(l_papszCreationOptions, \"@TILING_SCHEME_NAME\");\n    if( pszTilingSchemeName )\n    {\n        AppendMetadataItem( &psRoot, &psTail,\n                            \"NAME\", pszTilingSchemeName,\n                            0, nullptr, \"TILING_SCHEME\" );\n\n        const char* pszZoomLevel = CSLFetchNameValue(\n            l_papszCreationOptions, \"@TILING_SCHEME_ZOOM_LEVEL\");\n        if( pszZoomLevel )\n        {\n            AppendMetadataItem( &psRoot, &psTail,\n                                \"ZOOM_LEVEL\", pszZoomLevel,\n                                0, nullptr, \"TILING_SCHEME\" );\n        }\n\n        const char* pszAlignedLevels = CSLFetchNameValue(\n            l_papszCreationOptions, \"@TILING_SCHEME_ALIGNED_LEVELS\");\n        if( pszAlignedLevels )\n        {\n            AppendMetadataItem( &psRoot, &psTail,\n                                \"ALIGNED_LEVELS\", pszAlignedLevels,\n                                0, nullptr, \"TILING_SCHEME\" );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the generic XML metadata if there is any.             */\n/* -------------------------------------------------------------------- */\n    if( psRoot != nullptr )\n    {\n        bool bRet = true;\n\n        if( eProfile == GTiffProfile::GDALGEOTIFF )\n        {\n            char *pszXML_MD = CPLSerializeXMLTree( psRoot );\n            if( strlen(pszXML_MD) > 32000 )\n            {\n                if( bSrcIsGeoTIFF )\n                {\n                    if( cpl::down_cast<GTiffDataset *>(\n                           poSrcDS)->GetPamFlags() & GPF_DISABLED )\n                    {\n                        ReportError(\n                            pszTIFFFilename, CE_Warning, CPLE_AppDefined,\n                            \"Metadata exceeding 32000 bytes cannot be written \"\n                            \"into GeoTIFF.\" );\n                    }\n                    else\n                    {\n                        cpl::down_cast<GTiffDataset *>(poSrcDS)->\n                            PushMetadataToPam();\n                        ReportError(\n                            pszTIFFFilename, CE_Warning, CPLE_AppDefined,\n                            \"Metadata exceeding 32000 bytes cannot be written \"\n                            \"into GeoTIFF. Transferred to PAM instead.\" );\n                    }\n                }\n                else\n                {\n                    bRet = false;\n                }\n            }\n            else\n            {\n                TIFFSetField( l_hTIFF, TIFFTAG_GDAL_METADATA, pszXML_MD );\n            }\n            CPLFree( pszXML_MD );\n        }\n        else\n        {\n            if( bSrcIsGeoTIFF )\n                cpl::down_cast<GTiffDataset *>(poSrcDS)->PushMetadataToPam();\n            else\n                bRet = false;\n        }\n\n        CPLDestroyXMLNode( psRoot );\n\n        return bRet;\n    }\n\n    // If we have no more metadata but it existed before,\n    // remove the GDAL_METADATA tag.\n    if( eProfile == GTiffProfile::GDALGEOTIFF )\n    {\n        char* pszText = nullptr;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n        {\n            TIFFUnsetField( l_hTIFF, TIFFTAG_GDAL_METADATA );\n        }\n    }\n\n    return true;\n}",
    "void GTiffDataset::RestoreVolatileParameters(TIFF* hTIFF)\n{\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( m_nCompression == COMPRESSION_JPEG\n        && m_nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode = JPEGCOLORMODE_RAW;  // Initialize to 0;\n\n        TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode );\n        if( nColorMode != JPEGCOLORMODE_RGB )\n        {\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n    }\n\n    if( m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        m_nCompression == COMPRESSION_LERC )\n    {\n        GTiffSetDeflateSubCodec(hTIFF);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Propagate any quality settings.                                 */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() == GA_Update )\n    {\n        // Now, reset zip and jpeg quality.\n        if(m_nJpegQuality > 0 && m_nCompression == COMPRESSION_JPEG)\n        {\n#ifdef DEBUG_VERBOSE\n            CPLDebug( \"GTiff\", \"Propagate JPEG_QUALITY(%d) in SetDirectory()\",\n                      m_nJpegQuality );\n#endif\n            TIFFSetField(hTIFF, TIFFTAG_JPEGQUALITY, m_nJpegQuality);\n        }\n        if(m_nJpegTablesMode >= 0 && m_nCompression == COMPRESSION_JPEG)\n            TIFFSetField(hTIFF, TIFFTAG_JPEGTABLESMODE, m_nJpegTablesMode);\n        if(m_nZLevel > 0 && (m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n                           m_nCompression == COMPRESSION_LERC) )\n            TIFFSetField(hTIFF, TIFFTAG_ZIPQUALITY, m_nZLevel);\n        if(m_nLZMAPreset > 0 && m_nCompression == COMPRESSION_LZMA)\n            TIFFSetField(hTIFF, TIFFTAG_LZMAPRESET, m_nLZMAPreset);\n        if( m_nZSTDLevel > 0 && (m_nCompression == COMPRESSION_ZSTD ||\n                               m_nCompression == COMPRESSION_LERC) )\n            TIFFSetField(hTIFF, TIFFTAG_ZSTD_LEVEL, m_nZSTDLevel);\n#if HAVE_LERC\n        if( m_nCompression == COMPRESSION_LERC )\n        {\n            TIFFSetField(hTIFF, TIFFTAG_LERC_MAXZERROR, m_dfMaxZError);\n        }\n#endif\n        if( m_nWebPLevel > 0 && m_nCompression == COMPRESSION_WEBP)\n            TIFFSetField(hTIFF, TIFFTAG_WEBP_LEVEL, m_nWebPLevel);\n        if( m_bWebPLossless && m_nCompression == COMPRESSION_WEBP)\n            TIFFSetField(hTIFF, TIFFTAG_WEBP_LOSSLESS, 1);\n    }\n}",
    "GDALDataset *GTiffDataset::Open( GDALOpenInfo * poOpenInfo )\n\n{\n    const char *pszFilename = poOpenInfo->pszFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Check if it looks like a TIFF file.                             */\n/* -------------------------------------------------------------------- */\n    if( !Identify(poOpenInfo) )\n        return nullptr;\n\n    bool bAllowRGBAInterface = true;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") )\n        return OpenDir( poOpenInfo );\n\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    // Disable strip chop for now.\n    bool bStreaming = false;\n    const char* pszReadStreaming =\n        CPLGetConfigOption(\"TIFF_READ_STREAMING\", nullptr);\n    if( poOpenInfo->fpL == nullptr )\n    {\n        poOpenInfo->fpL =\n            VSIFOpenL( pszFilename,\n                       poOpenInfo->eAccess == GA_ReadOnly ? \"rb\" : \"r+b\" );\n        if( poOpenInfo->fpL == nullptr )\n            return nullptr;\n    }\n    else if( !(pszReadStreaming && !CPLTestBool(pszReadStreaming)) &&\n             poOpenInfo->nHeaderBytes >= 24 &&\n             // A pipe has no seeking capability, so its position is 0 despite\n             // having read bytes.\n             (static_cast<int>( VSIFTellL(poOpenInfo->fpL) ) ==\n              poOpenInfo->nHeaderBytes ||\n              strcmp(pszFilename, \"/vsistdin/\") == 0 ||\n              // STARTS_WITH(pszFilename, \"/vsicurl_streaming/\") ||\n              (pszReadStreaming && CPLTestBool(pszReadStreaming))) )\n    {\n        bStreaming = true;\n        if( !GTIFFMakeBufferedStream(poOpenInfo) )\n            return nullptr;\n    }\n\n    // Store errors/warnings and emit them later.\n    std::vector<CPLErrorHandlerAccumulatorStruct> aoErrors;\n    CPLInstallErrorHandlerAccumulator(aoErrors);\n    CPLSetCurrentErrorHandlerCatchDebug( FALSE );\n    const bool bDeferStrileLoading = CPLTestBool(\n        CPLGetConfigOption(\"GTIFF_USE_DEFER_STRILE_LOADING\", \"YES\"));\n    TIFF *l_hTIFF =\n        VSI_TIFFOpen( pszFilename,\n                      poOpenInfo->eAccess == GA_ReadOnly ?\n                        ((bStreaming || !bDeferStrileLoading) ? \"r\" : \"rDO\") :\n                        (!bDeferStrileLoading ? \"r+\" : \"r+D\"),\n                      poOpenInfo->fpL );\n    CPLUninstallErrorHandlerAccumulator();\n\n    // Now emit errors and change their criticality if needed\n    // We only emit failures if we didn't manage to open the file.\n    // Otherwise it makes Python bindings unhappy (#5616).\n    for( size_t iError = 0; iError < aoErrors.size(); ++iError )\n    {\n        ReportError( pszFilename,\n                  (l_hTIFF == nullptr && aoErrors[iError].type == CE_Failure) ?\n                  CE_Failure : CE_Warning,\n                  aoErrors[iError].no,\n                  \"%s\",\n                  aoErrors[iError].msg.c_str() );\n    }\n    aoErrors.resize(0);\n\n    if( l_hTIFF == nullptr )\n        return nullptr;\n\n    uint32 nXSize = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    uint32 nYSize = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n    if( nXSize > INT_MAX || nYSize > INT_MAX )\n    {\n        // GDAL only supports signed 32bit dimensions.\n        ReportError(pszFilename, CE_Failure, CPLE_NotSupported,\n                    \"Too large image size: %u x %u\",\n                    nXSize, nYSize);\n        XTIFFClose( l_hTIFF );\n        return nullptr;\n    }\n\n    uint16 l_nCompression = 0;\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, &(l_nCompression) ) )\n        l_nCompression = COMPRESSION_NONE;\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription( pszFilename );\n    poDS->m_pszFilename = CPLStrdup(pszFilename);\n    poDS->m_fpL = poOpenInfo->fpL;\n    poOpenInfo->fpL = nullptr;\n    poDS->m_bStreamingIn = bStreaming;\n    poDS->m_nCompression = l_nCompression;\n\n    // Check structural metadata (for COG)\n    const int nOffsetOfStructuralMetadata =\n        poOpenInfo->nHeaderBytes &&\n        ((poOpenInfo->pabyHeader[2] == 0x2B ||\n         poOpenInfo->pabyHeader[3] == 0x2B )) ? 16 : 8;\n    if( poOpenInfo->nHeaderBytes > nOffsetOfStructuralMetadata +\n            static_cast<int>(strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\")) &&\n        memcmp(poOpenInfo->pabyHeader + nOffsetOfStructuralMetadata,\n               \"GDAL_STRUCTURAL_METADATA_SIZE=\",\n               strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\")) == 0 )\n    {\n        const char* pszStructuralMD = reinterpret_cast<const char*>(\n            poOpenInfo->pabyHeader + nOffsetOfStructuralMetadata);\n        poDS->m_bLayoutIFDSBeforeData = strstr(pszStructuralMD,\n                            \"LAYOUT=IFDS_BEFORE_DATA\") != nullptr;\n        poDS->m_bBlockOrderRowMajor = strstr(pszStructuralMD,\n                            \"BLOCK_ORDER=ROW_MAJOR\") != nullptr;\n        poDS->m_bLeaderSizeAsUInt4 = strstr(pszStructuralMD,\n                            \"BLOCK_LEADER=SIZE_AS_UINT4\") != nullptr;\n        poDS->m_bTrailerRepeatedLast4BytesRepeated = strstr(pszStructuralMD,\n                            \"BLOCK_TRAILER=LAST_4_BYTES_REPEATED\") != nullptr;\n        poDS->m_bMaskInterleavedWithImagery = strstr(pszStructuralMD,\n                            \"MASK_INTERLEAVED_WITH_IMAGERY=YES\") != nullptr;\n        poDS->m_bKnownIncompatibleEdition = strstr(pszStructuralMD,\n                            \"KNOWN_INCOMPATIBLE_EDITION=YES\") != nullptr;\n        if( poDS->m_bKnownIncompatibleEdition )\n        {\n            poDS->ReportError(CE_Warning, CPLE_AppDefined,\n                     \"This file used to have optimizations in its layout, \"\n                     \"but those have been, at least partly, invalidated by \"\n                     \"later changes\");\n        }\n        else if( poDS->m_bLayoutIFDSBeforeData &&\n                 poDS->m_bBlockOrderRowMajor &&\n                 poDS->m_bLeaderSizeAsUInt4 &&\n                 poDS->m_bTrailerRepeatedLast4BytesRepeated )\n        {\n            poDS->m_oGTiffMDMD.SetMetadataItem(\"LAYOUT\", \"COG\", \"IMAGE_STRUCTURE\");\n        }\n    }\n\n    // In the case of GDAL_DISABLE_READDIR_ON_OPEN = NO / EMPTY_DIR\n    if( poOpenInfo->AreSiblingFilesLoaded() &&\n        CSLCount( poOpenInfo->GetSiblingFiles() ) <= 1 )\n    {\n        poDS->oOvManager.TransferSiblingFiles( CSLDuplicate(\n                                            poOpenInfo->GetSiblingFiles() ) );\n        poDS->m_bHasGotSiblingFiles = true;\n    }\n\n    if( poDS->OpenOffset( l_hTIFF,\n                          TIFFCurrentDirOffset(l_hTIFF),\n                          poOpenInfo->eAccess,\n                          bAllowRGBAInterface, true) != CE_None )\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    // Do we want blocks that are set to zero and that haven't yet being\n    // allocated as tile/strip to remain implicit?\n    if( CPLFetchBool( poOpenInfo->papszOpenOptions, \"SPARSE_OK\", false ) )\n        poDS->m_bWriteEmptyTiles = false;\n\n    if( poOpenInfo->eAccess == GA_Update )\n    {\n        poDS->InitCreationOrOpenOptions(poOpenInfo->papszOpenOptions);\n    }\n\n    poDS->m_bLoadPam = true;\n    poDS->m_bColorProfileMetadataChanged = false;\n    poDS->m_bMetadataChanged = false;\n    poDS->m_bGeoTIFFInfoChanged = false;\n    poDS->m_bNoDataChanged = false;\n    poDS->m_bForceUnsetGTOrGCPs = false;\n    poDS->m_bForceUnsetProjection = false;\n\n    // Used by GTIFFBuildOverviewsEx() for the COG driver\n    const char* pszMaskOverviewDS = CSLFetchNameValue(poOpenInfo->papszOpenOptions,\n                                                      \"MASK_OVERVIEW_DATASET\");\n    if( pszMaskOverviewDS )\n    {\n        poDS->m_poMaskExtOvrDS.reset(GDALDataset::Open(pszMaskOverviewDS,\n                                            GDAL_OF_RASTER | GDAL_OF_INTERNAL));\n        if( !poDS->m_poMaskExtOvrDS || !poDS->AssociateExternalMask() )\n        {\n            CPLDebug(\"GTiff\",\n                     \"Association with external mask overview file failed\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Initialize info for external overviews.                         */\n/* -------------------------------------------------------------------- */\n    poDS->oOvManager.Initialize( poDS, pszFilename );\n    if( poOpenInfo->AreSiblingFilesLoaded() )\n        poDS->oOvManager.TransferSiblingFiles(\n            poOpenInfo->StealSiblingFiles() );\n\n    // For backward compatibility, in case GTIFF_POINT_GEO_IGNORE is defined\n    // load georeferencing right now so as to not require it to be defined\n    // at the GetGeoTransform() time.\n    if( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\", nullptr) != nullptr )\n    {\n        poDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    return poDS;\n}",
    "void GTiffDataset::LoadICCProfile()\n{\n    if( m_bICCMetadataLoaded )\n        return;\n    m_bICCMetadataLoaded = true;\n\n    uint32 nEmbedLen = 0;\n    uint8* pEmbedBuffer = nullptr;\n\n\n    if( TIFFGetField(m_hTIFF, TIFFTAG_ICCPROFILE, &nEmbedLen, &pEmbedBuffer) )\n    {\n        char *pszBase64Profile =\n            CPLBase64Encode(nEmbedLen, reinterpret_cast<const GByte*>(pEmbedBuffer));\n\n        m_oGTiffMDMD.SetMetadataItem( \"SOURCE_ICC_PROFILE\", pszBase64Profile,\n                                    \"COLOR_PROFILE\" );\n\n        CPLFree(pszBase64Profile);\n\n        return;\n    }\n\n    // Check for colorimetric tiff.\n    float* pCHR = nullptr;\n    float* pWP = nullptr;\n    uint16 *pTFR = nullptr;\n    uint16 *pTFG = nullptr;\n    uint16 *pTFB = nullptr;\n    uint16 *pTransferRange = nullptr;\n\n    if( TIFFGetField(m_hTIFF, TIFFTAG_PRIMARYCHROMATICITIES, &pCHR) )\n    {\n        if( TIFFGetField(m_hTIFF, TIFFTAG_WHITEPOINT, &pWP) )\n        {\n            if( !TIFFGetFieldDefaulted( m_hTIFF, TIFFTAG_TRANSFERFUNCTION, &pTFR,\n                                        &pTFG, &pTFB) ||\n                pTFR == nullptr || pTFG == nullptr || pTFB == nullptr )\n            {\n                return;\n            }\n\n            const int TIFFTAG_TRANSFERRANGE = 0x0156;\n            TIFFGetFieldDefaulted( m_hTIFF, TIFFTAG_TRANSFERRANGE,\n                                   &pTransferRange);\n\n            // Set all the colorimetric metadata.\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_RED\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[0]),\n                                    static_cast<double>(pCHR[1]) ),\n                \"COLOR_PROFILE\" );\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_GREEN\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[2]),\n                                    static_cast<double>(pCHR[3]) ),\n                \"COLOR_PROFILE\" );\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_BLUE\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[4]),\n                                    static_cast<double>(pCHR[5]) ),\n                \"COLOR_PROFILE\" );\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_WHITEPOINT\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pWP[0]),\n                                    static_cast<double>(pWP[1]) ),\n                \"COLOR_PROFILE\" );\n\n            // Set transfer function metadata.\n\n            // Get length of table.\n            const uint32 nTransferFunctionLength = 1 << m_nBitsPerSample;\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_RED\",\n                ConvertTransferFunctionToString( pTFR, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n                ConvertTransferFunctionToString( pTFG, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n                ConvertTransferFunctionToString( pTFB, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            // Set transfer range.\n            if( pTransferRange )\n            {\n                m_oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_BLACK\",\n                    CPLString().Printf( \"%d, %d, %d\",\n                                        static_cast<int>(pTransferRange[0]),\n                                        static_cast<int>(pTransferRange[2]),\n                                        static_cast<int>(pTransferRange[4])),\n                    \"COLOR_PROFILE\" );\n                m_oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_WHITE\",\n                    CPLString().Printf( \"%d, %d, %d\",\n                                        static_cast<int>(pTransferRange[1]),\n                                        static_cast<int>(pTransferRange[3]),\n                                        static_cast<int>(pTransferRange[5])),\n                    \"COLOR_PROFILE\" );\n            }\n        }\n    }\n}",
    "CPLErr GTiffDataset::OpenOffset( TIFF *hTIFFIn,\n                                 toff_t nDirOffsetIn,\n                                 GDALAccess eAccessIn,\n                                 bool bAllowRGBAInterface,\n                                 bool bReadGeoTransform )\n\n{\n    if( !hTIFFIn )\n        return CE_Failure;\n\n    eAccess = eAccessIn;\n\n    m_hTIFF = hTIFFIn;\n\n    m_nDirOffset = nDirOffsetIn;\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some information from the file that is of interest.     */\n/* -------------------------------------------------------------------- */\n    uint32 nXSize = 0;\n    uint32 nYSize = 0;\n    TIFFGetField( m_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( m_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    if( nXSize > INT_MAX || nYSize > INT_MAX )\n    {\n        // GDAL only supports signed 32bit dimensions.\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"Too large image size: %u x %u\",\n                 nXSize, nYSize);\n        return CE_Failure;\n    }\n    nRasterXSize = nXSize;\n    nRasterYSize = nYSize;\n\n    if( !TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &m_nSamplesPerPixel ) )\n        nBands = 1;\n    else\n        nBands = m_nSamplesPerPixel;\n\n    if( !TIFFGetField(m_hTIFF, TIFFTAG_BITSPERSAMPLE, &(m_nBitsPerSample)) )\n        m_nBitsPerSample = 1;\n\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_PLANARCONFIG, &(m_nPlanarConfig) ) )\n        m_nPlanarConfig = PLANARCONFIG_CONTIG;\n\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_PHOTOMETRIC, &(m_nPhotometric) ) )\n        m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_SAMPLEFORMAT, &(m_nSampleFormat) ) )\n        m_nSampleFormat = SAMPLEFORMAT_UINT;\n\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_COMPRESSION, &(m_nCompression) ) )\n        m_nCompression = COMPRESSION_NONE;\n\n    if( m_nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(m_nCompression) )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"Cannot open TIFF file due to missing codec.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( m_nCompression == COMPRESSION_JPEG\n        && m_nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\") ) )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\",\n                                    \"IMAGE_STRUCTURE\" );\n        int nColorMode = 0;\n        if( !TIFFGetField( m_hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n            nColorMode != JPEGCOLORMODE_RGB )\n        {\n            TIFFSetField(m_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get strip/tile layout.                                          */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled(m_hTIFF) )\n    {\n        uint32 l_nBlockXSize = 0;\n        uint32 l_nBlockYSize = 0;\n        TIFFGetField( m_hTIFF, TIFFTAG_TILEWIDTH, &(l_nBlockXSize) );\n        TIFFGetField( m_hTIFF, TIFFTAG_TILELENGTH, &(l_nBlockYSize) );\n        if( l_nBlockXSize > INT_MAX || l_nBlockYSize > INT_MAX )\n        {\n            ReportError(CE_Failure, CPLE_NotSupported,\n                     \"Too large block size: %u x %u\",\n                     l_nBlockXSize, l_nBlockYSize);\n            return CE_Failure;\n        }\n        m_nBlockXSize = static_cast<int>(l_nBlockXSize);\n        m_nBlockYSize = static_cast<int>(l_nBlockYSize);\n    }\n    else\n    {\n        if( !TIFFGetField( m_hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(m_nRowsPerStrip) ) )\n        {\n            ReportError( CE_Warning, CPLE_AppDefined,\n                      \"RowsPerStrip not defined ... assuming all one strip.\" );\n            m_nRowsPerStrip = nYSize;  // Dummy value.\n        }\n\n        // If the rows per strip is larger than the file we will get\n        // confused.  libtiff internally will treat the rowsperstrip as\n        // the image height and it is best if we do too. (#4468)\n        if( m_nRowsPerStrip > static_cast<uint32>(nRasterYSize) )\n            m_nRowsPerStrip = nRasterYSize;\n\n        m_nBlockXSize = nRasterXSize;\n        m_nBlockYSize = m_nRowsPerStrip;\n    }\n\n    const int l_nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, m_nBlockYSize);\n    const int l_nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n    if( l_nBlocksPerColumn > INT_MAX / l_nBlocksPerRow )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"Too many blocks: %d x %d\",\n                  l_nBlocksPerRow, l_nBlocksPerColumn );\n        return CE_Failure;\n    }\n\n    // Note: we could potentially go up to UINT_MAX blocks, but currently\n    // we use a int nBlockId\n    m_nBlocksPerBand = l_nBlocksPerColumn * l_nBlocksPerRow;\n    if( m_nPlanarConfig == PLANARCONFIG_SEPARATE &&\n        m_nBlocksPerBand > INT_MAX / nBands )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"Too many blocks: %d x %d x %d bands\",\n                  l_nBlocksPerRow, l_nBlocksPerColumn, nBands );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we handle this using the GTiffBitmapBand?                */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsBitmap = false;\n\n    if( m_nBitsPerSample == 1 && nBands == 1 )\n    {\n        bTreatAsBitmap = true;\n\n        // Lets treat large \"one row\" bitmaps using the scanline api.\n        if( !TIFFIsTiled(m_hTIFF)\n            && m_nBlockYSize == nRasterYSize\n            && nRasterYSize > 2000\n            // libtiff does not support reading JBIG files with\n            // TIFFReadScanline().\n            && m_nCompression != COMPRESSION_JBIG )\n        {\n            m_bTreatAsSplitBitmap = true;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the RGBA interface?                    */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsRGBA = false;\n    if(\n#ifdef DEBUG\n        CPLTestBool(CPLGetConfigOption(\"GTIFF_FORCE_RGBA\", \"NO\")) ||\n#endif\n        (bAllowRGBAInterface &&\n        !bTreatAsBitmap && !(m_nBitsPerSample > 8)\n        && (m_nPhotometric == PHOTOMETRIC_CIELAB ||\n            m_nPhotometric == PHOTOMETRIC_LOGL ||\n            m_nPhotometric == PHOTOMETRIC_LOGLUV ||\n            m_nPhotometric == PHOTOMETRIC_SEPARATED ||\n            ( m_nPhotometric == PHOTOMETRIC_YCBCR\n              && m_nCompression != COMPRESSION_JPEG ))) )\n    {\n        char szMessage[1024] = {};\n\n        if( TIFFRGBAImageOK( m_hTIFF, szMessage ) == 1 )\n        {\n            const char* pszSourceColorSpace = nullptr;\n            nBands = 4;\n            switch( m_nPhotometric )\n            {\n                case PHOTOMETRIC_CIELAB:\n                    pszSourceColorSpace = \"CIELAB\";\n                    break;\n                case PHOTOMETRIC_LOGL:\n                    pszSourceColorSpace = \"LOGL\";\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    pszSourceColorSpace = \"LOGLUV\";\n                    break;\n                case PHOTOMETRIC_SEPARATED:\n                    pszSourceColorSpace = \"CMYK\";\n                    break;\n                case PHOTOMETRIC_YCBCR:\n                    pszSourceColorSpace = \"YCbCr\";\n                    nBands = 3; // probably true for other photometric values\n                    break;\n            }\n            if( pszSourceColorSpace )\n                m_oGTiffMDMD.SetMetadataItem( \"SOURCE_COLOR_SPACE\",\n                                            pszSourceColorSpace,\n                                            \"IMAGE_STRUCTURE\" );\n            bTreatAsRGBA = true;\n\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"TIFFRGBAImageOK says:\\n%s\", szMessage );\n        }\n    }\n\n    // libtiff has various issues with OJPEG compression and chunky-strip\n    // support with the \"classic\" scanline/strip/tile interfaces, and that\n    // wouldn't work either, so better bail out.\n    if( m_nCompression == COMPRESSION_OJPEG &&\n        !bTreatAsRGBA )\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"Old-JPEG compression only supported through RGBA interface, \"\n                 \"which cannot be used probably because the file is corrupted\");\n        return CE_Failure;\n    }\n\n    // If photometric is YCbCr, scanline/strip/tile interfaces assumes that\n    // we are ready with downsampled data. And we are not.\n    if( m_nCompression != COMPRESSION_JPEG &&\n        m_nCompression != COMPRESSION_OJPEG &&\n        m_nPhotometric == PHOTOMETRIC_YCBCR &&\n        m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        !bTreatAsRGBA )\n    {\n        uint16 nF1, nF2;\n        TIFFGetFieldDefaulted(m_hTIFF,TIFFTAG_YCBCRSUBSAMPLING,&nF1,&nF2);\n        if( nF1 != 1 || nF2 != 1 )\n        {\n            ReportError( CE_Failure, CPLE_AppDefined,\n                      \"Cannot open TIFF file with YCbCr, subsampling and \"\n                      \"BitsPerSample > 8 that is not JPEG compressed\" );\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the split interface?                   */\n/* -------------------------------------------------------------------- */\n    if( !TIFFIsTiled(m_hTIFF)\n        && m_nBitsPerSample == 8\n        && m_nBlockYSize == nRasterYSize\n        && nRasterYSize > 2000\n        && !bTreatAsRGBA\n        && CPLTestBool(CPLGetConfigOption(\"GDAL_ENABLE_TIFF_SPLIT\", \"YES\")) )\n    {\n        // libtiff 4.0.0beta5 (also\n        // 20091104) and older will crash when trying to open a\n        // all-in-one-strip YCbCr JPEG compressed TIFF (see #3259).\n#if (TIFFLIB_VERSION <= 20091104)\n        if( m_nPhotometric == PHOTOMETRIC_YCBCR &&\n            m_nCompression == COMPRESSION_JPEG )\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"Avoid using split band to open all-in-one-strip \"\n                \"YCbCr JPEG compressed TIFF because of older libtiff\" );\n        }\n        else\n#endif\n        {\n            m_bTreatAsSplit = true;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the odd bits interface?                */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsOdd = false;\n    if( m_nSampleFormat == SAMPLEFORMAT_IEEEFP )\n    {\n        if( m_nBitsPerSample == 16 || m_nBitsPerSample == 24 )\n            bTreatAsOdd = true;\n    }\n    else if( !bTreatAsRGBA && !bTreatAsBitmap\n             && m_nBitsPerSample != 8\n             && m_nBitsPerSample != 16\n             && m_nBitsPerSample != 32\n             && m_nBitsPerSample != 64\n             && m_nBitsPerSample != 128 )\n    {\n        bTreatAsOdd = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We can't support 'chunks' bigger than 2GB on 32 bit builds      */\n/* -------------------------------------------------------------------- */\n#if SIZEOF_VOIDP == 4\n    uint64 nChunkSize = 0;\n    if( m_bTreatAsSplit || m_bTreatAsSplitBitmap )\n    {\n        nChunkSize = TIFFScanlineSize64( m_hTIFF );\n    }\n    else\n    {\n        if( TIFFIsTiled(m_hTIFF) )\n            nChunkSize = TIFFTileSize64( m_hTIFF );\n        else\n            nChunkSize = TIFFStripSize64( m_hTIFF );\n    }\n    if( bTreatAsRGBA )\n    {\n        nChunkSize = std::max(nChunkSize,\n                        4 * static_cast<uint64>(m_nBlockXSize) * m_nBlockYSize);\n    }\n    if( nChunkSize > static_cast<uint64>(INT_MAX) )\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"Scanline/tile/strip size bigger than 2GB unsupported \"\n                  \"on 32-bit builds.\" );\n        return CE_Failure;\n    }\n#endif\n\n    const bool bMinIsWhite = m_nPhotometric == PHOTOMETRIC_MINISWHITE;\n\n/* -------------------------------------------------------------------- */\n/*      Check for NODATA                                                */\n/* -------------------------------------------------------------------- */\n    char *pszText = nullptr;\n    if( TIFFGetField( m_hTIFF, TIFFTAG_GDAL_NODATA, &pszText ) &&\n        !EQUAL(pszText, \"\") )\n    {\n        m_bNoDataSet = true;\n        m_dfNoDataValue = CPLAtofM( pszText );\n        if( m_nBitsPerSample == 32 && m_nSampleFormat == SAMPLEFORMAT_IEEEFP )\n        {\n            m_dfNoDataValue = GDALAdjustNoDataCloseToFloatMax(m_dfNoDataValue);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture the color table if there is one.                        */\n/* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( bTreatAsRGBA || m_nBitsPerSample > 16\n        || TIFFGetField( m_hTIFF, TIFFTAG_COLORMAP,\n                         &panRed, &panGreen, &panBlue) == 0 )\n    {\n        // Build inverted palette if we have inverted photometric.\n        // Pixel values remains unchanged.  Avoid doing this for *deep*\n        // data types (per #1882)\n        if( m_nBitsPerSample <= 16 && m_nPhotometric == PHOTOMETRIC_MINISWHITE )\n        {\n            m_poColorTable = new GDALColorTable();\n            const int nColorCount = 1 << m_nBitsPerSample;\n\n            for( int iColor = 0; iColor < nColorCount; ++iColor )\n            {\n                const short nValue =\n                    static_cast<short>(((255 * (nColorCount - 1 - iColor)) /\n                                        (nColorCount - 1)));\n                const GDALColorEntry oEntry =\n                    { nValue, nValue, nValue, static_cast<short>(255) };\n                m_poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n\n            m_nPhotometric = PHOTOMETRIC_PALETTE;\n        }\n        else\n        {\n            m_poColorTable = nullptr;\n        }\n    }\n    else\n    {\n        unsigned short nMaxColor = 0;\n\n        m_poColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 << m_nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            // TODO(schwehr): Ensure the color entries are never negative?\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast<short>(panRed[iColor] / divisor),\n                static_cast<short>(panGreen[iColor] / divisor),\n                static_cast<short>(panBlue[iColor] / divisor),\n                static_cast<short>(\n                    m_bNoDataSet && static_cast<int>(m_dfNoDataValue) == iColor\n                    ? 0\n                    : 255)\n            };\n\n            m_poColorTable->SetColorEntry( iColor, &oEntry );\n\n            nMaxColor = std::max(nMaxColor, panRed[iColor]);\n            nMaxColor = std::max(nMaxColor, panGreen[iColor]);\n            nMaxColor = std::max(nMaxColor, panBlue[iColor]);\n        }\n\n        // Bug 1384 - Some TIFF files are generated with color map entry\n        // values in range 0-255 instead of 0-65535 - try to handle these\n        // gracefully.\n        if( nMaxColor > 0 && nMaxColor < 256 )\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"TIFF ColorTable seems to be improperly scaled, fixing up.\" );\n\n            for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n            {\n                // TODO(schwehr): Ensure the color entries are never negative?\n                const GDALColorEntry oEntry = {\n                    static_cast<short>(panRed[iColor]),\n                    static_cast<short>(panGreen[iColor]),\n                    static_cast<short>(panBlue[iColor]),\n                    m_bNoDataSet &&\n                    static_cast<int>(m_dfNoDataValue) == iColor\n                    ? static_cast<short>(0)\n                    : static_cast<short>(255)\n                };\n\n                m_poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < nBands; ++iBand )\n    {\n        if( bTreatAsRGBA )\n            SetBand( iBand + 1, new GTiffRGBABand( this, iBand + 1 ) );\n        else if( m_bTreatAsSplitBitmap )\n            SetBand( iBand + 1, new GTiffSplitBitmapBand( this, iBand + 1 ) );\n        else if( m_bTreatAsSplit )\n            SetBand( iBand + 1, new GTiffSplitBand( this, iBand + 1 ) );\n        else if( bTreatAsBitmap )\n            SetBand( iBand + 1, new GTiffBitmapBand( this, iBand + 1 ) );\n        else if( bTreatAsOdd )\n            SetBand( iBand + 1, new GTiffOddBitsBand( this, iBand + 1 ) );\n        else\n            SetBand( iBand + 1, new GTiffRasterBand( this, iBand + 1 ) );\n    }\n\n    if( GetRasterBand(1)->GetRasterDataType() == GDT_Unknown )\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"Unsupported TIFF configuration: BitsPerSample(=%d) and \"\n                 \"SampleType(=%d)\",\n                 m_nBitsPerSample,\n                 m_nSampleFormat);\n        return CE_Failure;\n    }\n\n    m_bReadGeoTransform = bReadGeoTransform;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some other potentially interesting information.         */\n/* -------------------------------------------------------------------- */\n    char szWorkMDI[200] = {};\n    uint16 nShort = 0;\n\n    for( size_t iTag = 0;\n         iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n         ++iTag )\n    {\n        if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n        {\n            if( TIFFGetField( m_hTIFF, asTIFFTags[iTag].nTagVal, &pszText ) )\n                m_oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            pszText );\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT )\n        {\n            float fVal = 0.0;\n            if( TIFFGetField( m_hTIFF, asTIFFTags[iTag].nTagVal, &fVal ) )\n            {\n                CPLsnprintf( szWorkMDI, sizeof(szWorkMDI), \"%.8g\", fVal );\n                m_oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            szWorkMDI );\n            }\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT &&\n                 asTIFFTags[iTag].nTagVal != TIFFTAG_RESOLUTIONUNIT )\n        {\n            if( TIFFGetField( m_hTIFF, asTIFFTags[iTag].nTagVal, &nShort ) )\n            {\n                snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort );\n                m_oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            szWorkMDI );\n            }\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING )\n        {\n            uint32 nCount = 0;\n            if( TIFFGetField( m_hTIFF, asTIFFTags[iTag].nTagVal,\n                              &nCount, &pszText ) )\n            {\n                std::string osStr;\n                osStr.assign(pszText, nCount);\n                m_oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            osStr.c_str() );\n            }\n        }\n    }\n\n    if( TIFFGetField( m_hTIFF, TIFFTAG_RESOLUTIONUNIT, &nShort ) )\n    {\n        if( nShort == RESUNIT_NONE )\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d (unitless)\", nShort );\n        else if( nShort == RESUNIT_INCH )\n            snprintf( szWorkMDI, sizeof(szWorkMDI),\n                      \"%d (pixels/inch)\", nShort );\n        else if( nShort == RESUNIT_CENTIMETER )\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d (pixels/cm)\", nShort );\n        else\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort );\n        m_oGTiffMDMD.SetMetadataItem( \"TIFFTAG_RESOLUTIONUNIT\", szWorkMDI );\n    }\n\n    int nTagSize = 0;\n    void* pData = nullptr;\n    if( TIFFGetField( m_hTIFF, TIFFTAG_XMLPACKET, &nTagSize, &pData ) )\n    {\n        char* pszXMP =\n            static_cast<char *>( VSI_MALLOC_VERBOSE(nTagSize + 1) );\n        if( pszXMP )\n        {\n            memcpy(pszXMP, pData, nTagSize);\n            pszXMP[nTagSize] = '\\0';\n\n            char *apszMDList[2] = { pszXMP, nullptr };\n            m_oGTiffMDMD.SetMetadata(apszMDList, \"xml:XMP\");\n\n            CPLFree(pszXMP);\n        }\n    }\n\n    if( m_nCompression == COMPRESSION_NONE )\n        /* no compression tag */;\n    else if( m_nCompression == COMPRESSION_CCITTRLE )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTRLE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_CCITTFAX3 )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTFAX3\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_CCITTFAX4 )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTFAX4\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_LZW )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LZW\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_OJPEG )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"OJPEG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_JPEG )\n    {\n        if( m_nPhotometric == PHOTOMETRIC_YCBCR )\n            m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\",\n                                        \"IMAGE_STRUCTURE\" );\n        else\n            m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JPEG\",\n                                        \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_NEXT )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"NEXT\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_CCITTRLEW )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTRLEW\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_PACKBITS )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PACKBITS\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_THUNDERSCAN )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"THUNDERSCAN\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_PIXARFILM )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PIXARFILM\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_PIXARLOG )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PIXARLOG\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_DEFLATE )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DEFLATE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_ADOBE_DEFLATE )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DEFLATE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_DCS )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DCS\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_JBIG )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JBIG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_SGILOG )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"SGILOG\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_SGILOG24 )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"SGILOG24\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_JP2000 )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JP2000\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_LZMA )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LZMA\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_ZSTD )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"ZSTD\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_LERC )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC\", \"IMAGE_STRUCTURE\" );\n#if HAVE_LERC\n        uint32 nLercParamCount = 0;\n        uint32* panLercParms = nullptr;\n        if( TIFFGetField( m_hTIFF, TIFFTAG_LERC_PARAMETERS, &nLercParamCount,\n                          &panLercParms ) &&\n            nLercParamCount == 2 )\n        {\n            memcpy( m_anLercAddCompressionAndVersion, panLercParms,\n                    sizeof(m_anLercAddCompressionAndVersion) );\n        }\n\n        uint32 nAddVersion = LERC_ADD_COMPRESSION_NONE;\n        if( TIFFGetField( m_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION, &nAddVersion ) &&\n            nAddVersion != LERC_ADD_COMPRESSION_NONE )\n        {\n            if( nAddVersion == LERC_ADD_COMPRESSION_DEFLATE )\n            {\n                m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC_DEFLATE\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n            else if( nAddVersion == LERC_ADD_COMPRESSION_ZSTD )\n            {\n                m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC_ZSTD\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n        }\n        uint32 nLercVersion = LERC_VERSION_2_4;\n        if( TIFFGetField( m_hTIFF, TIFFTAG_LERC_VERSION, &nLercVersion) )\n        {\n            if( nLercVersion == LERC_VERSION_2_4 )\n            {\n                m_oGTiffMDMD.SetMetadataItem( \"LERC_VERSION\", \"2.4\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n            else\n            {\n                ReportError(CE_Warning, CPLE_AppDefined,\n                         \"Unknown Lerc version: %d\", nLercVersion);\n            }\n        }\n#endif\n    }\n    else if( m_nCompression == COMPRESSION_WEBP )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"WEBP\", \"IMAGE_STRUCTURE\" );\n    }\n    else\n    {\n        CPLString oComp;\n        oComp.Printf( \"%d\", m_nCompression);\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", oComp.c_str());\n    }\n\n    if( m_nPlanarConfig == PLANARCONFIG_CONTIG && nBands != 1 )\n        m_oGTiffMDMD.SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        m_oGTiffMDMD.SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    if( (GetRasterBand(1)->GetRasterDataType() == GDT_Byte &&\n         m_nBitsPerSample != 8 ) ||\n        (GetRasterBand(1)->GetRasterDataType() == GDT_UInt16 &&\n         m_nBitsPerSample != 16) ||\n        ((GetRasterBand(1)->GetRasterDataType() == GDT_UInt32 ||\n          GetRasterBand(1)->GetRasterDataType() == GDT_Float32) &&\n         m_nBitsPerSample != 32) )\n    {\n        for( int i = 0; i < nBands; ++i )\n            cpl::down_cast<GTiffRasterBand*>(GetRasterBand(i + 1))->\n                m_oGTiffMDMD.SetMetadataItem(\n                    \"NBITS\",\n                    CPLString().Printf(\n                        \"%d\", static_cast<int>(m_nBitsPerSample) ),\n                    \"IMAGE_STRUCTURE\" );\n    }\n\n    if( bMinIsWhite )\n        m_oGTiffMDMD.SetMetadataItem( \"MINISWHITE\", \"YES\", \"IMAGE_STRUCTURE\" );\n\n    if( TIFFGetField( m_hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n    {\n        CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n        CPLXMLNode *psItem = nullptr;\n\n        if( psRoot != nullptr && psRoot->eType == CXT_Element\n            && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n            psItem = psRoot->psChild;\n\n        for( ; psItem != nullptr; psItem = psItem->psNext )\n        {\n\n            if( psItem->eType != CXT_Element\n                || !EQUAL(psItem->pszValue,\"Item\") )\n                continue;\n\n            const char *pszKey = CPLGetXMLValue( psItem, \"name\", nullptr );\n            const char *pszValue = CPLGetXMLValue( psItem, nullptr, nullptr );\n            int nBand =\n                atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" ));\n            if( nBand < -1 || nBand > 65535 )\n                continue;\n            nBand ++;\n            const char *pszRole = CPLGetXMLValue( psItem, \"role\", \"\" );\n            const char *pszDomain = CPLGetXMLValue( psItem, \"domain\", \"\" );\n\n            if( pszKey == nullptr || pszValue == nullptr )\n                continue;\n            if( EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n                continue;\n\n            bool bIsXML = false;\n\n            if( STARTS_WITH_CI(pszDomain, \"xml:\") )\n                bIsXML = TRUE;\n\n            char *pszUnescapedValue =\n                CPLUnescapeString( pszValue, nullptr, CPLES_XML );\n            if( nBand == 0 )\n            {\n                if( bIsXML )\n                {\n                    char *apszMD[2] = { pszUnescapedValue, nullptr };\n                    m_oGTiffMDMD.SetMetadata( apszMD, pszDomain );\n                }\n                else\n                {\n                    m_oGTiffMDMD.SetMetadataItem( pszKey, pszUnescapedValue,\n                                                pszDomain );\n                }\n            }\n            else\n            {\n                GTiffRasterBand *poBand =\n                    cpl::down_cast<GTiffRasterBand*>(GetRasterBand(nBand));\n                if( poBand != nullptr )\n                {\n                    if( EQUAL(pszRole,\"scale\") )\n                    {\n                        poBand->m_bHaveOffsetScale = true;\n                        poBand->m_dfScale = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if( EQUAL(pszRole,\"offset\") )\n                    {\n                        poBand->m_bHaveOffsetScale = true;\n                        poBand->m_dfOffset = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if( EQUAL(pszRole,\"unittype\") )\n                    {\n                        poBand->m_osUnitType = pszUnescapedValue;\n                    }\n                    else if( EQUAL(pszRole,\"description\") )\n                    {\n                        poBand->m_osDescription = pszUnescapedValue;\n                    }\n                    else if( EQUAL(pszRole, \"colorinterp\") )\n                    {\n                        poBand->m_eBandInterp =\n                            GDALGetColorInterpretationByName(pszUnescapedValue);\n                    }\n                    else\n                    {\n                        if( bIsXML )\n                        {\n                            char *apszMD[2] = { pszUnescapedValue, nullptr };\n                            poBand->m_oGTiffMDMD.SetMetadata( apszMD, pszDomain );\n                        }\n                        else\n                        {\n                            poBand->m_oGTiffMDMD.SetMetadataItem(\n                                pszKey,\n                                pszUnescapedValue,\n                                pszDomain );\n                        }\n                    }\n                }\n            }\n            CPLFree( pszUnescapedValue );\n        }\n\n        CPLDestroyXMLNode( psRoot );\n    }\n\n    if( m_bStreamingIn )\n    {\n        toff_t* panOffsets = nullptr;\n        TIFFGetField( m_hTIFF,\n                      TIFFIsTiled( m_hTIFF ) ?\n                      TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                      &panOffsets );\n        if( panOffsets )\n        {\n            int nBlockCount =\n                TIFFIsTiled(m_hTIFF) ?\n                TIFFNumberOfTiles(m_hTIFF) : TIFFNumberOfStrips(m_hTIFF);\n            for( int i = 1; i < nBlockCount; ++i )\n            {\n                if( panOffsets[i] < panOffsets[i-1] )\n                {\n                    m_oGTiffMDMD.SetMetadataItem( \"UNORDERED_BLOCKS\", \"YES\",\n                                                \"TIFF\");\n                    CPLDebug(\n                        \"GTIFF\",\n                        \"Offset of block %d is lower than previous block. \"\n                        \"Reader must be careful\",\n                        i );\n                    break;\n                }\n            }\n        }\n    }\n\n    if( m_nCompression == COMPRESSION_JPEG && eAccess == GA_Update )\n    {\n        SetJPEGQualityAndTablesModeFromFile();\n    }\n\n    CPLAssert(m_bReadGeoTransform == bReadGeoTransform);\n    CPLAssert(!m_bMetadataChanged);\n    m_bMetadataChanged = false;\n\n    return CE_None;\n}",
    "void GTiffDataset::LoadGeoreferencingAndPamIfNeeded()\n\n{\n    if( !m_bReadGeoTransform && !m_bLoadPam )\n        return;\n\n    IdentifyAuthorizedGeoreferencingSources();\n\n/* -------------------------------------------------------------------- */\n/*      Get the transform or gcps from the GeoTIFF file.                */\n/* -------------------------------------------------------------------- */\n    if( m_bReadGeoTransform )\n    {\n        m_bReadGeoTransform = false;\n\n        char *pszTabWKT = nullptr;\n        double *padfTiePoints = nullptr;\n        double *padfScale = nullptr;\n        double *padfMatrix = nullptr;\n        uint16 nCount = 0;\n        bool bPixelIsPoint = false;\n        unsigned short nRasterType = 0;\n        bool bPointGeoIgnore = false;\n\n        std::set<signed char> aoSetPriorities;\n        if( m_nINTERNALGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nINTERNALGeorefSrcIndex);\n        if( m_nTABFILEGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nTABFILEGeorefSrcIndex);\n        if( m_nWORLDFILEGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nWORLDFILEGeorefSrcIndex);\n        for(const auto nIndex: aoSetPriorities )\n        {\n            if( m_nINTERNALGeorefSrcIndex == nIndex )\n            {\n                GTIF *psGTIF = GTiffDatasetGTIFNew( m_hTIFF );  // How expensive this is?\n\n                if( psGTIF )\n                {\n                    if( GDALGTIFKeyGetSHORT(psGTIF, GTRasterTypeGeoKey,\n                                            &nRasterType, 0, 1 ) == 1\n                        && nRasterType ==\n                           static_cast<short>(RasterPixelIsPoint) )\n                    {\n                        bPixelIsPoint = true;\n                        bPointGeoIgnore =\n                            CPLTestBool(\n                                CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                                   \"FALSE\") );\n                    }\n\n                    GTIFFree( psGTIF );\n                }\n\n                m_adfGeoTransform[0] = 0.0;\n                m_adfGeoTransform[1] = 1.0;\n                m_adfGeoTransform[2] = 0.0;\n                m_adfGeoTransform[3] = 0.0;\n                m_adfGeoTransform[4] = 0.0;\n                m_adfGeoTransform[5] = 1.0;\n\n                uint16 nCountScale = 0;\n                if( TIFFGetField(m_hTIFF, TIFFTAG_GEOPIXELSCALE,\n                                 &nCountScale, &padfScale )\n                    && nCountScale >= 2\n                    && padfScale[0] != 0.0 && padfScale[1] != 0.0 )\n                {\n                    m_adfGeoTransform[1] = padfScale[0];\n                    if( padfScale[1] < 0 )\n                    {\n                        const char* pszOptionVal =\n                            CPLGetConfigOption(\"GTIFF_HONOUR_NEGATIVE_SCALEY\",\n                                               nullptr);\n                        if( pszOptionVal == nullptr )\n                        {\n                            ReportError(CE_Warning, CPLE_AppDefined,\n                                \"File with negative value for ScaleY in \"\n                                \"GeoPixelScale tag. This is rather \"\n                                \"unusual. GDAL, contrary to the GeoTIFF \"\n                                \"specification, assumes that the file \"\n                                \"was intended to be north-up, and will \"\n                                \"treat this file as if ScaleY was \"\n                                \"positive. You may override this behavior \"\n                                \"by setting the GTIFF_HONOUR_NEGATIVE_SCALEY \"\n                                \"configuration option to YES\");\n                            m_adfGeoTransform[5] = padfScale[1];\n                        }\n                        else if( CPLTestBool(pszOptionVal) )\n                        {\n                            m_adfGeoTransform[5] = -padfScale[1];\n                        }\n                        else\n                        {\n                            m_adfGeoTransform[5] = padfScale[1];\n                        }\n                    }\n                    else\n                    {\n                        m_adfGeoTransform[5] = -padfScale[1];\n                    }\n\n                    if( TIFFGetField(m_hTIFF, TIFFTAG_GEOTIEPOINTS,\n                                     &nCount, &padfTiePoints )\n                        && nCount >= 6 )\n                    {\n                        m_adfGeoTransform[0] =\n                            padfTiePoints[3] -\n                            padfTiePoints[0] * m_adfGeoTransform[1];\n                        m_adfGeoTransform[3] =\n                            padfTiePoints[4] -\n                            padfTiePoints[1] * m_adfGeoTransform[5];\n\n                        if( bPixelIsPoint && !bPointGeoIgnore )\n                        {\n                            m_adfGeoTransform[0] -=\n                                (m_adfGeoTransform[1] * 0.5 +\n                                 m_adfGeoTransform[2] * 0.5);\n                            m_adfGeoTransform[3] -=\n                                (m_adfGeoTransform[4] * 0.5 +\n                                 m_adfGeoTransform[5] * 0.5);\n                        }\n\n                        m_bGeoTransformValid = true;\n                        m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                        if( nCountScale >= 3 && GetRasterCount() == 1 &&\n                            (padfScale[2] != 0.0 ||\n                             padfTiePoints[2] != 0.0 ||\n                             padfTiePoints[5] != 0.0) )\n                        {\n                            LookForProjection();\n                            if( !m_oSRS.IsEmpty() && m_oSRS.IsVertical() )\n                            {\n                                /* modelTiePointTag = (pixel, line, z0, X, Y, Z0) */\n                                /* thus Z(some_point) = (z(some_point) - z0) * scaleZ + Z0 */\n                                /* equivalently written as */\n                                /* Z(some_point) = z(some_point) * scaleZ + offsetZ with */\n                                /* offsetZ = - z0 * scaleZ + Z0 */\n                                double dfScale = padfScale[2];\n                                double dfOffset =\n                                    -padfTiePoints[2] * dfScale + padfTiePoints[5];\n                                GTiffRasterBand* poBand =\n                                    cpl::down_cast<GTiffRasterBand*>(GetRasterBand(1));\n                                poBand->m_bHaveOffsetScale = true;\n                                poBand->m_dfScale = dfScale;\n                                poBand->m_dfOffset = dfOffset;\n                            }\n                        }\n                    }\n                }\n\n                else if( TIFFGetField(m_hTIFF, TIFFTAG_GEOTRANSMATRIX,\n                                      &nCount, &padfMatrix )\n                        && nCount == 16 )\n                {\n                    m_adfGeoTransform[0] = padfMatrix[3];\n                    m_adfGeoTransform[1] = padfMatrix[0];\n                    m_adfGeoTransform[2] = padfMatrix[1];\n                    m_adfGeoTransform[3] = padfMatrix[7];\n                    m_adfGeoTransform[4] = padfMatrix[4];\n                    m_adfGeoTransform[5] = padfMatrix[5];\n\n                    if( bPixelIsPoint && !bPointGeoIgnore )\n                    {\n                        m_adfGeoTransform[0] -=\n                            m_adfGeoTransform[1] * 0.5 + m_adfGeoTransform[2] * 0.5;\n                        m_adfGeoTransform[3] -=\n                            m_adfGeoTransform[4] * 0.5 + m_adfGeoTransform[5] * 0.5;\n                    }\n\n                    m_bGeoTransformValid = true;\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                }\n                if( m_bGeoTransformValid )\n                    break;\n            }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise try looking for a .tab, .tfw, .tifw or .wld file.     */\n/* -------------------------------------------------------------------- */\n            if( m_nTABFILEGeorefSrcIndex == nIndex )\n            {\n                char* pszGeorefFilename = nullptr;\n\n                char** papszSiblingFiles = GetSiblingFiles();\n\n                // Begin with .tab since it can also have projection info.\n                const int bTabFileOK =\n                    GDALReadTabFile2( m_pszFilename, m_adfGeoTransform,\n                                        &pszTabWKT, &m_nGCPCount, &m_pasGCPList,\n                                        papszSiblingFiles, &pszGeorefFilename );\n\n                if( bTabFileOK )\n                {\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                    // if( pszTabWKT )\n                    // {\n                    //     m_nProjectionGeorefSrcIndex = nIndex;\n                    // }\n                    if( m_nGCPCount == 0 )\n                    {\n                        m_bGeoTransformValid = true;\n                    }\n                }\n\n                if( pszGeorefFilename )\n                {\n                    CPLFree(m_pszGeorefFilename);\n                    m_pszGeorefFilename = pszGeorefFilename;\n                    pszGeorefFilename = nullptr;\n                }\n                if( m_bGeoTransformValid )\n                    break;\n            }\n\n            if( m_nWORLDFILEGeorefSrcIndex == nIndex )\n            {\n                char* pszGeorefFilename = nullptr;\n\n                char** papszSiblingFiles = GetSiblingFiles();\n\n                m_bGeoTransformValid = CPL_TO_BOOL( GDALReadWorldFile2(\n                                m_pszFilename, nullptr, m_adfGeoTransform,\n                                papszSiblingFiles, &pszGeorefFilename) );\n\n                if( !m_bGeoTransformValid )\n                {\n                    m_bGeoTransformValid =\n                        CPL_TO_BOOL( GDALReadWorldFile2(\n                            m_pszFilename, \"wld\", m_adfGeoTransform,\n                            papszSiblingFiles, &pszGeorefFilename ) );\n                }\n                if( m_bGeoTransformValid )\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                if( pszGeorefFilename )\n                {\n                    CPLFree(m_pszGeorefFilename);\n                    m_pszGeorefFilename = pszGeorefFilename;\n                    pszGeorefFilename = nullptr;\n                }\n                if( m_bGeoTransformValid )\n                    break;\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Check for GCPs.                                                 */\n/* -------------------------------------------------------------------- */\n        if( m_nINTERNALGeorefSrcIndex >= 0 &&\n            TIFFGetField(m_hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && !m_bGeoTransformValid )\n        {\n            if( m_nGCPCount > 0 )\n            {\n                GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n                CPLFree( m_pasGCPList );\n            }\n            m_nGCPCount = nCount / 6;\n            m_pasGCPList =\n                static_cast<GDAL_GCP *>(CPLCalloc(sizeof(GDAL_GCP), m_nGCPCount));\n\n            for( int iGCP = 0; iGCP < m_nGCPCount; ++iGCP )\n            {\n                char szID[32] = {};\n\n                snprintf( szID, sizeof(szID), \"%d\", iGCP + 1 );\n                m_pasGCPList[iGCP].pszId = CPLStrdup( szID );\n                m_pasGCPList[iGCP].pszInfo = CPLStrdup(\"\");\n                m_pasGCPList[iGCP].dfGCPPixel = padfTiePoints[iGCP*6+0];\n                m_pasGCPList[iGCP].dfGCPLine = padfTiePoints[iGCP*6+1];\n                m_pasGCPList[iGCP].dfGCPX = padfTiePoints[iGCP*6+3];\n                m_pasGCPList[iGCP].dfGCPY = padfTiePoints[iGCP*6+4];\n                m_pasGCPList[iGCP].dfGCPZ = padfTiePoints[iGCP*6+5];\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    m_pasGCPList[iGCP].dfGCPPixel += 0.5;\n                    m_pasGCPList[iGCP].dfGCPLine += 0.5;\n                }\n            }\n            m_nGeoTransformGeorefSrcIndex = m_nINTERNALGeorefSrcIndex;\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Did we find a tab file?  If so we will use its coordinate       */\n/*      system and give it precedence.                                  */\n/* -------------------------------------------------------------------- */\n        if( pszTabWKT != nullptr && m_oSRS.IsEmpty() )\n        {\n            m_oSRS.SetFromUserInput(pszTabWKT);\n            m_bLookedForProjection = true;\n        }\n\n        CPLFree( pszTabWKT );\n    }\n\n    if( m_bLoadPam && m_nPAMGeorefSrcIndex >= 0 )\n    {\n/* -------------------------------------------------------------------- */\n/*      Initialize any PAM information.                                 */\n/* -------------------------------------------------------------------- */\n        CPLAssert(!m_bColorProfileMetadataChanged);\n        CPLAssert(!m_bMetadataChanged);\n        CPLAssert(!m_bGeoTIFFInfoChanged);\n        CPLAssert(!m_bNoDataChanged);\n\n        // We must absolutely unset m_bLoadPam now, otherwise calling\n        // GetFileList() on a .tif with a .aux will result in an (almost)\n        // endless sequence of calls.\n        m_bLoadPam = false;\n\n        TryLoadXML( GetSiblingFiles() );\n        ApplyPamInfo();\n\n        m_bColorProfileMetadataChanged = false;\n        m_bMetadataChanged = false;\n        m_bGeoTIFFInfoChanged = false;\n        m_bNoDataChanged = false;\n\n        for( int i = 1; i <= nBands; ++i )\n        {\n            GTiffRasterBand* poBand =\n                cpl::down_cast<GTiffRasterBand *>(GetRasterBand(i));\n\n            /* Load scale, offset and unittype from PAM if available */\n            if( !poBand->m_bHaveOffsetScale )\n            {\n                int nHaveOffsetScale = FALSE;\n                poBand->m_dfScale =\n                    poBand->GDALPamRasterBand::GetScale( &nHaveOffsetScale );\n                poBand->m_bHaveOffsetScale = CPL_TO_BOOL(nHaveOffsetScale);\n                poBand->m_dfOffset = poBand->GDALPamRasterBand::GetOffset();\n            }\n            if( poBand->m_osUnitType.empty() )\n            {\n                const char* pszUnitType =\n                    poBand->GDALPamRasterBand::GetUnitType();\n                if( pszUnitType )\n                    poBand->m_osUnitType = pszUnitType;\n            }\n            if( poBand->m_osDescription.empty() )\n                poBand->m_osDescription =\n                    poBand->GDALPamRasterBand::GetDescription();\n\n            GDALColorInterp ePAMColorInterp =\n                poBand->GDALPamRasterBand::GetColorInterpretation();\n            if( ePAMColorInterp != GCI_Undefined )\n                poBand->m_eBandInterp = ePAMColorInterp;\n        }\n    }\n    m_bLoadPam = false;\n}",
    "void GTiffDataset::ScanDirectories()\n\n{\n/* -------------------------------------------------------------------- */\n/*      We only scan once.  We do not scan for non-base datasets.       */\n/* -------------------------------------------------------------------- */\n    if( !m_bScanDeferred )\n        return;\n\n    m_bScanDeferred = false;\n\n    if( m_poBaseDS )\n        return;\n\n    Crystalize();\n\n    CPLDebug( \"GTiff\", \"ScanDirectories()\" );\n\n/* ==================================================================== */\n/*      Scan all directories.                                           */\n/* ==================================================================== */\n    CPLStringList aosSubdatasets;\n    int iDirIndex = 0;\n\n    FlushDirectory();\n\n    do\n    {\n        // Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if !defined(SUPPORTS_MORE_THAN_32768_DIRECTORIES)\n        if( iDirIndex == 32768 )\n            break;\n#endif\n        toff_t nTopDir = TIFFCurrentDirOffset(m_hTIFF);\n        uint32 nSubType = 0;\n\n        ++iDirIndex;\n\n        toff_t *tmpSubIFDOffsets = nullptr;\n        toff_t *subIFDOffsets = nullptr;\n        uint16 nSubIFDs = 0;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_SUBIFD, &nSubIFDs, &tmpSubIFDOffsets) && iDirIndex == 1)\n        {\n            subIFDOffsets = static_cast<toff_t *>(CPLMalloc(nSubIFDs * sizeof(toff_t)));\n            for (uint16 iSubIFD = 0; iSubIFD < nSubIFDs; iSubIFD++)\n            {\n                subIFDOffsets[iSubIFD] = tmpSubIFDOffsets[iSubIFD];\n            }\n        }\n\n        //early break for backwards compatibility: if the first directory read is also the last, and there are no subIFDs, no use continuing\n        if( iDirIndex==1 && nSubIFDs==0 && TIFFLastDirectory( m_hTIFF )) {\n            CPLFree(subIFDOffsets);\n            break;\n        }\n\n\n        for( uint16 iSubIFD = 0; iSubIFD<=nSubIFDs; iSubIFD++ ) {\n            toff_t nThisDir = nTopDir;\n            if ( iSubIFD > 0 && iDirIndex > 1 ) //don't read subIFDs if we are not in the original directory\n                break;\n            if ( iSubIFD > 0 ) {\n                // make static analyzer happy. subIFDOffsets cannot be null if iSubIFD>0\n                assert(subIFDOffsets != nullptr); \n                nThisDir = subIFDOffsets[iSubIFD-1];\n                //CPLDebug(\"GTiff\", \"Opened subIFD %d/%d at offset %llu.\", iSubIFD, nSubIFDs, nThisDir);\n                if (!TIFFSetSubDirectory(m_hTIFF,nThisDir))\n                    break;\n            }\n\n\n            if( !TIFFGetField(m_hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n                nSubType = 0;\n\n            /* Embedded overview of the main image */\n            if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                (nSubType & FILETYPE_MASK) == 0 &&\n                ((nSubIFDs==0 && iDirIndex != 1) || iSubIFD>0) &&\n                m_nOverviewCount < 30 /* to avoid DoS */ )\n            {\n                GTiffDataset *poODS = new GTiffDataset();\n                poODS->ShareLockWithParentDataset(this);\n                poODS->SetStructuralMDFromParent(this);\n                poODS->m_pszFilename = CPLStrdup(m_pszFilename);\n                if( poODS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                    eAccess ) != CE_None\n                    || poODS->GetRasterCount() != GetRasterCount() )\n                {\n                    delete poODS;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened %dx%d overview.\",\n                            poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                    ++m_nOverviewCount;\n                    m_papoOverviewDS = static_cast<GTiffDataset **>(\n                        CPLRealloc(m_papoOverviewDS,\n                                m_nOverviewCount * (sizeof(void*))) );\n                    m_papoOverviewDS[m_nOverviewCount-1] = poODS;\n                    poODS->m_poBaseDS = this;\n                    poODS->m_bIsOverview = true;\n                }\n            }\n            // Embedded mask of the main image.\n            else if( (nSubType & FILETYPE_MASK) != 0 &&\n                    (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                    ((nSubIFDs==0 && iDirIndex != 1) || iSubIFD>0) &&\n                    m_poMaskDS == nullptr )\n            {\n                m_poMaskDS = new GTiffDataset();\n                m_poMaskDS->ShareLockWithParentDataset(this);\n                m_poMaskDS->SetStructuralMDFromParent(this);\n                m_poMaskDS->m_pszFilename = CPLStrdup(m_pszFilename);\n\n                // The TIFF6 specification - page 37 - only allows 1\n                // SamplesPerPixel and 1 BitsPerSample Here we support either 1 or\n                // 8 bit per sample and we support either 1 sample per pixel or as\n                // many samples as in the main image We don't check the value of\n                // the PhotometricInterpretation tag, which should be set to\n                // \"Transparency mask\" (4) according to the specification (page\n                // 36).  However, the TIFF6 specification allows image masks to\n                // have a higher resolution than the main image, what we don't\n                // support here.\n\n                if( m_poMaskDS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                        eAccess ) != CE_None\n                    || m_poMaskDS->GetRasterCount() == 0\n                    || !(m_poMaskDS->GetRasterCount() == 1\n                        || m_poMaskDS->GetRasterCount() == GetRasterCount())\n                    || m_poMaskDS->GetRasterXSize() != GetRasterXSize()\n                    || m_poMaskDS->GetRasterYSize() != GetRasterYSize()\n                    || m_poMaskDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete m_poMaskDS;\n                    m_poMaskDS = nullptr;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened band mask.\");\n                    m_poMaskDS->m_poBaseDS = this;\n                    m_poMaskDS->m_poImageryDS = this;\n\n                    m_poMaskDS->m_bPromoteTo8Bits =\n                        CPLTestBool(\n                            CPLGetConfigOption( \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                                \"YES\" ) );\n                }\n            }\n\n            // Embedded mask of an overview.  The TIFF6 specification allows the\n            // combination of the FILETYPE_xxxx masks.\n            else if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                    (nSubType & FILETYPE_MASK) != 0 &&\n                    ((nSubIFDs==0 && iDirIndex != 1) || iSubIFD>0))\n            {\n                GTiffDataset* poDS = new GTiffDataset();\n                poDS->ShareLockWithParentDataset(this);\n                poDS->SetStructuralMDFromParent(this);\n                poDS->m_pszFilename = CPLStrdup(m_pszFilename);\n                if( poDS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                    eAccess ) != CE_None\n                    || poDS->GetRasterCount() == 0\n                    || poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poDS;\n                }\n                else\n                {\n                    int i = 0;  // Used after for.\n                    for( ; i < m_nOverviewCount; ++i )\n                    {\n                        auto poOvrDS = cpl::down_cast<GTiffDataset*>(\n                                GDALDataset::FromHandle(m_papoOverviewDS[i]));\n                        if( poOvrDS->m_poMaskDS == nullptr &&\n                            poDS->GetRasterXSize() ==\n                            m_papoOverviewDS[i]->GetRasterXSize() &&\n                            poDS->GetRasterYSize() ==\n                            m_papoOverviewDS[i]->GetRasterYSize() &&\n                            (poDS->GetRasterCount() == 1 ||\n                            poDS->GetRasterCount() == GetRasterCount()))\n                        {\n                            CPLDebug(\n                                \"GTiff\", \"Opened band mask for %dx%d overview.\",\n                                poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                            poDS->m_poImageryDS = poOvrDS;\n                            poOvrDS->m_poMaskDS = poDS;\n                            poDS->m_bPromoteTo8Bits =\n                                CPLTestBool(\n                                    CPLGetConfigOption(\n                                        \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                        \"YES\" ) );\n                            poDS->m_poBaseDS = this;\n                            break;\n                        }\n                    }\n                    if( i == m_nOverviewCount )\n                    {\n                        delete poDS;\n                    }\n                }\n            }\n            else if( !m_bSingleIFDOpened && (nSubType == 0 || nSubType == FILETYPE_PAGE) )\n            {\n                uint32 nXSize = 0;\n                uint32 nYSize = 0;\n\n                TIFFGetField( m_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n                TIFFGetField( m_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n                // For Geodetic TIFF grids (GTG)\n                // (https://proj.org/specifications/geodetictiffgrids.html)\n                // extract the grid_name to put it in the description\n                std::string osFriendlyName;\n                char* pszText = nullptr;\n                if( TIFFGetField( m_hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) &&\n                    strstr(pszText, \"grid_name\") != nullptr )\n                {\n                    CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n                    CPLXMLNode *psItem = nullptr;\n\n                    if( psRoot != nullptr && psRoot->eType == CXT_Element\n                        && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n                        psItem = psRoot->psChild;\n\n                    for( ; psItem != nullptr; psItem = psItem->psNext )\n                    {\n\n                        if( psItem->eType != CXT_Element\n                            || !EQUAL(psItem->pszValue,\"Item\") )\n                            continue;\n\n                        const char *pszKey = CPLGetXMLValue( psItem, \"name\", nullptr );\n                        const char *pszValue = CPLGetXMLValue( psItem, nullptr, nullptr );\n                        int nBand =\n                            atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" ));\n                        if( pszKey && pszValue && nBand <= 0 &&\n                            EQUAL(pszKey, \"grid_name\") )\n                        {\n                            osFriendlyName = \": \";\n                            osFriendlyName += pszValue;\n                            break;\n                        }\n                    }\n\n                    CPLDestroyXMLNode(psRoot);\n                }\n\n                if( nXSize > INT_MAX || nYSize > INT_MAX )\n                {\n                    CPLDebug(\"GTiff\",\n                            \"Skipping directory with too large image: %u x %u\",\n                            nXSize, nYSize);\n                }\n                else\n                {\n                    uint16 nSPP = 0;\n                    if( !TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP ) )\n                        nSPP = 1;\n\n                    CPLString osName, osDesc;\n                    osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\",\n                                iDirIndex, iDirIndex, m_pszFilename );\n                    osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\",\n                                iDirIndex, iDirIndex,\n                                static_cast<int>(nXSize),\n                                static_cast<int>(nYSize),\n                                nSPP );\n                    osDesc += osFriendlyName;\n\n                    aosSubdatasets.AddString(osName);\n                    aosSubdatasets.AddString(osDesc);\n                }\n            }\n        }\n        CPLFree(subIFDOffsets);\n\n        // Make sure we are stepping from the expected directory regardless\n        // of churn done processing the above.\n        if( TIFFCurrentDirOffset(m_hTIFF) != nTopDir )\n            TIFFSetSubDirectory( m_hTIFF, nTopDir );\n    } while( !m_bSingleIFDOpened && !TIFFLastDirectory( m_hTIFF ) && TIFFReadDirectory( m_hTIFF ) != 0 );\n\n\n    ReloadDirectory();\n\n    // If we have a mask for the main image, loop over the overviews, and if\n    // they have a mask, let's set this mask as an overview of the main mask.\n    if( m_poMaskDS != nullptr )\n    {\n        for( int i = 0; i < m_nOverviewCount; ++i )\n        {\n            if( cpl::down_cast<GTiffDataset *>(GDALDataset::FromHandle(\n                   m_papoOverviewDS[i]))->m_poMaskDS != nullptr)\n            {\n                ++m_poMaskDS->m_nOverviewCount;\n                m_poMaskDS->m_papoOverviewDS = static_cast<GTiffDataset **>(\n                    CPLRealloc(m_poMaskDS->m_papoOverviewDS,\n                               m_poMaskDS->m_nOverviewCount * (sizeof(void*))) );\n                m_poMaskDS->m_papoOverviewDS[m_poMaskDS->m_nOverviewCount-1] =\n                    cpl::down_cast<GTiffDataset*>(GDALDataset::FromHandle(\n                        m_papoOverviewDS[i]))->m_poMaskDS;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n    if( aosSubdatasets.size() > 2 )\n    {\n        m_oGTiffMDMD.SetMetadata( aosSubdatasets.List(), \"SUBDATASETS\" );\n    }\n}",
    "void GTiffWriteJPEGTables( TIFF* hTIFF,\n                           const char* pszPhotometric,\n                           const char* pszJPEGQuality,\n                           const char* pszJPEGTablesMode )\n{\n    // This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n    uint16 nBands = 0;\n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL,\n                        &nBands ) )\n        nBands = 1;\n\n    uint16 l_nBitsPerSample = 0;\n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE,\n                        &(l_nBitsPerSample)) )\n        l_nBitsPerSample = 1;\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf(\"%s%p\", szJPEGGTiffDatasetTmpPrefix, hTIFF);\n    VSILFILE* fpTmp = nullptr;\n    CPLString osTmp;\n    char** papszLocalParameters = nullptr;\n    const int nInMemImageWidth = 16;\n    const int nInMemImageHeight = 16;\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\" );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEG_QUALITY\",\n                                            pszJPEGQuality );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"PHOTOMETRIC\", pszPhotometric );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"BLOCKYSIZE\",\n                                            CPLSPrintf(\"%u\", nInMemImageHeight)\n                                          );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"NBITS\",\n                                            CPLSPrintf(\"%u\", l_nBitsPerSample));\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEGTABLESMODE\",\n                                            pszJPEGTablesMode );\n\n    TIFF* hTIFFTmp = GTiffDataset::CreateLL(\n                    osTmpFilenameIn, nInMemImageWidth, nInMemImageHeight,\n                    (nBands <= 4) ? nBands : 1,\n                    (l_nBitsPerSample <= 8) ? GDT_Byte : GDT_UInt16, 0.0,\n                    papszLocalParameters, &fpTmp, osTmp );\n    CSLDestroy(papszLocalParameters);\n    if( hTIFFTmp )\n    {\n        uint16 l_nPhotometric = 0;\n        int nJpegTablesModeIn = 0;\n        TIFFGetField( hTIFFTmp, TIFFTAG_PHOTOMETRIC, &(l_nPhotometric) );\n        TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                        &nJpegTablesModeIn );\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now, reset quality and jpegcolormode.\n        const int l_nJpegQuality = pszJPEGQuality ? atoi(pszJPEGQuality) : 0;\n        if(l_nJpegQuality > 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGQUALITY, l_nJpegQuality);\n        if( l_nPhotometric == PHOTOMETRIC_YCBCR\n            && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGCOLORMODE,\n                            JPEGCOLORMODE_RGB);\n        }\n        if( nJpegTablesModeIn >= 0 )\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                            nJpegTablesModeIn);\n\n        GPtrDiff_t nBlockSize = static_cast<GPtrDiff_t>(nInMemImageWidth) * nInMemImageHeight *\n                                        ((nBands <= 4) ? nBands : 1);\n        if( l_nBitsPerSample == 12 )\n            nBlockSize = (nBlockSize * 3) / 2;\n        std::vector<GByte> abyZeroData( nBlockSize, 0 );\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, &abyZeroData[0], nBlockSize);\n\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSize,\n                            &pJPEGTable) )\n            TIFFSetField( hTIFF, TIFFTAG_JPEGTABLES, nJPEGTableSize,\n                            pJPEGTable);\n\n        float *ref = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_REFERENCEBLACKWHITE, &ref) )\n            TIFFSetField(hTIFF, TIFFTAG_REFERENCEBLACKWHITE, ref);\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n    VSIUnlink(osTmpFilenameIn);\n}",
    "int GTiffDataset::GuessJPEGQuality( bool& bOutHasQuantizationTable,\n                                    bool& bOutHasHuffmanTable )\n{\n    CPLAssert( m_nCompression == COMPRESSION_JPEG );\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    if( !TIFFGetField(m_hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize, &pJPEGTable) )\n    {\n        bOutHasQuantizationTable = false;\n        bOutHasHuffmanTable = false;\n        return -1;\n    }\n\n    bOutHasQuantizationTable =\n        GTIFFFindNextTable( static_cast<const GByte*>(pJPEGTable), 0xDB,\n                            nJPEGTableSize, nullptr) != nullptr;\n    bOutHasHuffmanTable =\n        GTIFFFindNextTable( static_cast<const GByte*>(pJPEGTable), 0xC4,\n                            nJPEGTableSize, nullptr) != nullptr;\n    if( !bOutHasQuantizationTable )\n        return -1;\n\n    char** papszLocalParameters = nullptr;\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\");\n    if( m_nPhotometric == PHOTOMETRIC_YCBCR )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"YCBCR\");\n    else if( m_nPhotometric == PHOTOMETRIC_SEPARATED )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"CMYK\");\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"BLOCKYSIZE\", \"16\");\n    if( m_nBitsPerSample == 12 )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                \"NBITS\", \"12\");\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf( \"/vsimem/gtiffdataset_guess_jpeg_quality_tmp_%p\",\n                            this );\n\n    int nRet = -1;\n    for( int nQuality = 0; nQuality <= 100 && nRet < 0; ++nQuality )\n    {\n        VSILFILE* fpTmp = nullptr;\n        if( nQuality == 0 )\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                   \"JPEG_QUALITY\", \"75\");\n        else\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                \"JPEG_QUALITY\", CPLSPrintf(\"%d\", nQuality));\n\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        CPLString osTmp;\n        TIFF* hTIFFTmp =\n            CreateLL( osTmpFilenameIn, 16, 16, (nBands <= 4) ? nBands : 1,\n                      GetRasterBand(1)->GetRasterDataType(), 0.0,\n                      papszLocalParameters, &fpTmp, osTmp );\n        CPLPopErrorHandler();\n        if( !hTIFFTmp )\n        {\n            break;\n        }\n\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now reset jpegcolormode.\n        if( m_nPhotometric == PHOTOMETRIC_YCBCR\n            && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n\n        GByte abyZeroData[(16*16*4*3)/2] = {};\n        const int nBlockSize =\n            (16 * 16 * ((nBands <= 4) ? nBands : 1) * m_nBitsPerSample) / 8;\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, abyZeroData, nBlockSize);\n\n        uint32 nJPEGTableSizeTry = 0;\n        void* pJPEGTableTry = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES,\n                         &nJPEGTableSizeTry, &pJPEGTableTry) )\n        {\n            if( GTIFFQuantizationTablesEqual(\n                   static_cast<GByte *>(pJPEGTable), nJPEGTableSize,\n                   static_cast<GByte *>(pJPEGTableTry), nJPEGTableSizeTry) )\n            {\n                nRet = (nQuality == 0 ) ? 75 : nQuality;\n            }\n        }\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n\n    CSLDestroy(papszLocalParameters);\n    VSIUnlink(osTmpFilenameIn);\n\n    return nRet;\n}",
    "void GTiffDataset::SetJPEGQualityAndTablesModeFromFile()\n{\n    bool bHasQuantizationTable = false;\n    bool bHasHuffmanTable = false;\n    int nQuality = GuessJPEGQuality( bHasQuantizationTable,\n                                     bHasHuffmanTable );\n    if( nQuality > 0 )\n    {\n        CPLDebug(\"GTiff\", \"Guessed JPEG quality to be %d\", nQuality);\n        m_nJpegQuality = static_cast<signed char>(nQuality);\n        TIFFSetField( m_hTIFF, TIFFTAG_JPEGQUALITY, nQuality );\n\n        // This means we will use the quantization tables from the\n        // JpegTables tag.\n        m_nJpegTablesMode = JPEGTABLESMODE_QUANT;\n    }\n    else\n    {\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( !TIFFGetField( m_hTIFF, TIFFTAG_JPEGTABLES,\n                            &nJPEGTableSize, &pJPEGTable) )\n        {\n            toff_t *panByteCounts = nullptr;\n            const int nBlockCount =\n                m_nPlanarConfig == PLANARCONFIG_SEPARATE\n                ? m_nBlocksPerBand * nBands\n                : m_nBlocksPerBand;\n            if( TIFFIsTiled( m_hTIFF ) )\n                TIFFGetField( m_hTIFF, TIFFTAG_TILEBYTECOUNTS,\n                                &panByteCounts );\n            else\n                TIFFGetField( m_hTIFF, TIFFTAG_STRIPBYTECOUNTS,\n                                &panByteCounts );\n\n            bool bFoundNonEmptyBlock = false;\n            if( panByteCounts != nullptr )\n            {\n                for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n                {\n                    if( panByteCounts[iBlock] != 0 )\n                    {\n                        bFoundNonEmptyBlock = true;\n                        break;\n                    }\n                }\n            }\n            if( bFoundNonEmptyBlock )\n            {\n                CPLDebug(\"GTiff\", \"Could not guess JPEG quality. \"\n                            \"JPEG tables are missing, so going in \"\n                            \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n                // Write quantization tables in each strile.\n                m_nJpegTablesMode = 0;\n            }\n        }\n        else\n        {\n            if( bHasQuantizationTable )\n            {\n                // FIXME in libtiff: this is likely going to cause issues\n                // since libtiff will reuse in each strile the number of\n                // the global quantization table, which is invalid.\n                CPLDebug(\n                    \"GTiff\", \"Could not guess JPEG quality although JPEG \"\n                    \"quantization tables are present, so going in \"\n                    \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\" );\n            }\n            else\n            {\n                CPLDebug(\"GTiff\", \"Could not guess JPEG quality since JPEG \"\n                        \"quantization tables are not present, so going in \"\n                        \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n            }\n\n            // Write quantization tables in each strile.\n            m_nJpegTablesMode = 0;\n        }\n    }\n    if( bHasHuffmanTable )\n    {\n        // If there are Huffman tables in header use them, otherwise\n        // if we use optimized tables, libtiff will currently reuse\n        // the number of the Huffman tables of the header for the\n        // optimized version of each strile, which is illegal.\n        m_nJpegTablesMode |= JPEGTABLESMODE_HUFF;\n    }\n    if( m_nJpegTablesMode >= 0 )\n        TIFFSetField( m_hTIFF, TIFFTAG_JPEGTABLESMODE,\n                        m_nJpegTablesMode);\n}",
    "GDALDataset *GTiffDataset::Create( const char * pszFilename,\n                                   int nXSize, int nYSize, int l_nBands,\n                                   GDALDataType eType,\n                                   char **papszParmList )\n\n{\n    VSILFILE* l_fpL = nullptr;\n    CPLString l_osTmpFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Create the underlying TIFF file.                                */\n/* -------------------------------------------------------------------- */\n    TIFF *l_hTIFF = CreateLL(\n        pszFilename,\n        nXSize, nYSize, l_nBands,\n        eType, 0, papszParmList, &l_fpL, l_osTmpFilename );\n    const bool bStreaming = !l_osTmpFilename.empty();\n\n    if( l_hTIFF == nullptr )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Create the new GTiffDataset object.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->m_hTIFF = l_hTIFF;\n    poDS->m_fpL = l_fpL;\n    if( bStreaming )\n    {\n        poDS->m_bStreamingOut = true;\n        poDS->m_pszTmpFilename = CPLStrdup(l_osTmpFilename);\n        poDS->m_fpToWrite = VSIFOpenL( pszFilename, \"wb\" );\n        if( poDS->m_fpToWrite == nullptr )\n        {\n            VSIUnlink(l_osTmpFilename);\n            delete poDS;\n            return nullptr;\n        }\n    }\n    poDS->nRasterXSize = nXSize;\n    poDS->nRasterYSize = nYSize;\n    poDS->eAccess = GA_Update;\n    poDS->m_bCrystalized = false;\n    poDS->m_nSamplesPerPixel = static_cast<uint16>(l_nBands);\n    poDS->m_pszFilename = CPLStrdup(pszFilename);\n\n    // Don't try to load external metadata files (#6597).\n    poDS->m_bIMDRPCMetadataLoaded = true;\n\n    // Avoid premature crystalization that will cause directory re-writing if\n    // GetProjectionRef() or GetGeoTransform() are called on the newly created\n    // GeoTIFF.\n    poDS->m_bLookedForProjection = true;\n\n    TIFFGetField( l_hTIFF, TIFFTAG_SAMPLEFORMAT, &(poDS->m_nSampleFormat) );\n    TIFFGetField( l_hTIFF, TIFFTAG_PLANARCONFIG, &(poDS->m_nPlanarConfig) );\n    // Weird that we need this, but otherwise we get a Valgrind warning on\n    // tiff_write_124.\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, &(poDS->m_nPhotometric) ) )\n        poDS->m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n    TIFFGetField( l_hTIFF, TIFFTAG_BITSPERSAMPLE, &(poDS->m_nBitsPerSample) );\n    TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, &(poDS->m_nCompression) );\n\n    if( TIFFIsTiled(l_hTIFF) )\n    {\n        TIFFGetField( l_hTIFF, TIFFTAG_TILEWIDTH, &(poDS->m_nBlockXSize) );\n        TIFFGetField( l_hTIFF, TIFFTAG_TILELENGTH, &(poDS->m_nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( l_hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(poDS->m_nRowsPerStrip) ) )\n            poDS->m_nRowsPerStrip = 1;  // Dummy value.\n\n        poDS->m_nBlockXSize = nXSize;\n        poDS->m_nBlockYSize =\n            std::min( static_cast<int>(poDS->m_nRowsPerStrip) , nYSize );\n    }\n\n    poDS->m_nBlocksPerBand =\n        DIV_ROUND_UP(nYSize, poDS->m_nBlockYSize)\n        * DIV_ROUND_UP(nXSize, poDS->m_nBlockXSize);\n\n    poDS->m_eProfile = GetProfile(\n        CSLFetchNameValue( papszParmList, \"PROFILE\" ) );\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( poDS->m_nCompression == COMPRESSION_JPEG\n        && poDS->m_nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\") ) )\n    {\n        int nColorMode = 0;\n\n        poDS->SetMetadataItem(\"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\");\n        if( !TIFFGetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n            nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n#ifdef HAVE_LERC\n    if( poDS->m_nCompression == COMPRESSION_LERC )\n    {\n        uint32 nLercParamCount = 0;\n        uint32* panLercParms = nullptr;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_LERC_PARAMETERS, &nLercParamCount,\n                          &panLercParms ) &&\n            nLercParamCount == 2 )\n        {\n            memcpy( poDS->m_anLercAddCompressionAndVersion, panLercParms,\n                    sizeof(poDS->m_anLercAddCompressionAndVersion) );\n        }\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Read palette back as a color table if it has one.               */\n/* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( poDS->m_nPhotometric == PHOTOMETRIC_PALETTE\n        && TIFFGetField( l_hTIFF, TIFFTAG_COLORMAP,\n                         &panRed, &panGreen, &panBlue) )\n    {\n\n        poDS->m_poColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 << poDS->m_nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast<short>(panRed[iColor] / divisor),\n                static_cast<short>(panGreen[iColor] / divisor),\n                static_cast<short>(panBlue[iColor] / divisor),\n                static_cast<short>(255)\n            };\n\n            poDS->m_poColorTable->SetColorEntry( iColor, &oEntry );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we want to ensure all blocks get written out on close to     */\n/*      avoid sparse files?                                             */\n/* -------------------------------------------------------------------- */\n    if( !CPLFetchBool( papszParmList, \"SPARSE_OK\", false ) )\n        poDS->m_bFillEmptyTilesAtClosing = true;\n\n    poDS->m_bWriteEmptyTiles = bStreaming ||\n        (poDS->m_nCompression != COMPRESSION_NONE &&\n         poDS->m_bFillEmptyTilesAtClosing);\n    // Only required for people writing non-compressed striped files in the\n    // right order and wanting all tstrips to be written in the same order\n    // so that the end result can be memory mapped without knowledge of each\n    // strip offset.\n    if( CPLTestBool( CSLFetchNameValueDef( papszParmList,\n                              \"WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) ||\n         CPLTestBool( CSLFetchNameValueDef( papszParmList,\n                              \"@WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) )\n    {\n        poDS->m_bWriteEmptyTiles = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Preserve creation options for consulting later (for instance    */\n/*      to decide if a TFW file should be written).                     */\n/* -------------------------------------------------------------------- */\n    poDS->m_papszCreationOptions = CSLDuplicate( papszParmList );\n\n    poDS->m_nZLevel = GTiffGetZLevel(papszParmList);\n    poDS->m_nLZMAPreset = GTiffGetLZMAPreset(papszParmList);\n    poDS->m_nZSTDLevel = GTiffGetZSTDPreset(papszParmList);\n    poDS->m_nWebPLevel = GTiffGetWebPLevel(papszParmList);\n    poDS->m_bWebPLossless = GTiffGetWebPLossless(papszParmList);\n    poDS->m_nJpegQuality = GTiffGetJpegQuality(papszParmList);\n    poDS->m_nJpegTablesMode = GTiffGetJpegTablesMode(papszParmList);\n#if HAVE_LERC\n    poDS->m_dfMaxZError = GTiffGetLERCMaxZError(papszParmList);\n#endif\n    poDS->InitCreationOrOpenOptions(papszParmList);\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < l_nBands; ++iBand )\n    {\n        if( poDS->m_nBitsPerSample == 8 ||\n            (poDS->m_nBitsPerSample == 16 && eType != GDT_Float32) ||\n            poDS->m_nBitsPerSample == 32 ||\n            poDS->m_nBitsPerSample == 64 ||\n            poDS->m_nBitsPerSample == 128)\n        {\n            poDS->SetBand( iBand + 1, new GTiffRasterBand( poDS, iBand + 1 ) );\n        }\n        else\n        {\n            poDS->SetBand( iBand + 1, new GTiffOddBitsBand( poDS, iBand + 1 ) );\n            poDS->GetRasterBand( iBand + 1 )->\n                SetMetadataItem( \"NBITS\",\n                                 CPLString().Printf(\"%d\",poDS->m_nBitsPerSample),\n                                 \"IMAGE_STRUCTURE\" );\n        }\n    }\n\n    poDS->GetDiscardLsbOption(papszParmList);\n\n    if( poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG && l_nBands != 1 )\n        poDS->SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        poDS->SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    poDS->oOvManager.Initialize( poDS, pszFilename );\n\n    return poDS;\n}",
    "const char *GTiffDataset::GetMetadataItem( const char *pszName,\n                                           const char *pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain,\"ProxyOverviewRequest\") )\n    {\n        return GDALPamDataset::GetMetadataItem( pszName, pszDomain );\n    }\n    else if( pszDomain != nullptr && (EQUAL(pszDomain, MD_DOMAIN_RPC) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMD) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMAGERY)) )\n    {\n        LoadMetadata();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"SUBDATASETS\") )\n    {\n        ScanDirectories();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"EXIF\") )\n    {\n        LoadEXIFMetadata();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        LoadICCProfile();\n    }\n    else if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) &&\n        pszName != nullptr && EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LoadMDAreaOrPoint();  // To set GDALMD_AREA_OR_POINT.\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"_DEBUG_\") &&\n             pszName != nullptr )\n    {\n#ifdef DEBUG_REACHED_VIRTUAL_MEM_IO\n        if( EQUAL(pszName, \"UNREACHED_VIRTUALMEMIO_CODE_PATH\") )\n        {\n            CPLString osMissing;\n            for( int i = 0; i < static_cast<int>(\n                                    CPL_ARRAYSIZE(anReachedVirtualMemIO)); ++i )\n            {\n                if( !anReachedVirtualMemIO[i] )\n                {\n                    if( !osMissing.empty() ) osMissing += \",\";\n                    osMissing += CPLSPrintf(\"%d\", i);\n                }\n            }\n            return (osMissing.size()) ? CPLSPrintf(\"%s\", osMissing.c_str()) : nullptr;\n        }\n        else\n#endif\n        if( EQUAL(pszName, \"TIFFTAG_EXTRASAMPLES\") )\n        {\n            CPLString osRet;\n            uint16 *v = nullptr;\n            uint16 count = 0;\n\n            if( TIFFGetField( m_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n            {\n                for( int i = 0; i < static_cast<int>(count); ++i )\n                {\n                    if( i > 0 ) osRet += \",\";\n                    osRet += CPLSPrintf(\"%d\", v[i]);\n                }\n            }\n            return (osRet.size()) ? CPLSPrintf(\"%s\", osRet.c_str()) : nullptr;\n        }\n        else if( EQUAL(pszName, \"TIFFTAG_PHOTOMETRIC\") )\n        {\n            return CPLSPrintf(\"%d\", m_nPhotometric);\n        }\n\n        else if( EQUAL( pszName, \"TIFFTAG_GDAL_METADATA\") )\n        {\n            char* pszText = nullptr;\n            if( !TIFFGetField( m_hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n                return nullptr;\n\n            return CPLSPrintf(\"%s\", pszText);\n        }\n        else if( EQUAL( pszName, \"HAS_USED_READ_ENCODED_API\") )\n        {\n            return m_bHasUsedReadEncodedAPI ? \"1\" : \"0\";\n        }\n        return nullptr;\n    }\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"TIFF\") &&\n             pszName != nullptr )\n    {\n        if( EQUAL(pszName, \"GDAL_STRUCTURAL_METADATA\") )\n        {\n            const auto nOffset = VSIFTellL(m_fpL);\n            VSIFSeekL( m_fpL, 0, SEEK_SET );\n            GByte abyData[1024];\n            size_t nRead = VSIFReadL(abyData, 1, sizeof(abyData)-1, m_fpL);\n            abyData[nRead] = 0;\n            VSIFSeekL( m_fpL, nOffset, SEEK_SET );\n            if( nRead > 4 )\n            {\n                const int nOffsetOfStructuralMetadata =\n                    (abyData[2] == 0x2B || abyData[3] == 0x2B ) ? 16 : 8;\n                const int nSizePatternLen = static_cast<int>(strlen(\"XXXXXX bytes\\n\"));\n                if( nRead > nOffsetOfStructuralMetadata +\n                            strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\") + nSizePatternLen &&\n                    memcmp(abyData + nOffsetOfStructuralMetadata,\n                            \"GDAL_STRUCTURAL_METADATA_SIZE=\",\n                            strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\")) == 0 )\n                {\n                    char* pszStructuralMD = reinterpret_cast<char*>(\n                        abyData + nOffsetOfStructuralMetadata);\n                    const int nLenMD = atoi(pszStructuralMD +\n                                    strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\"));\n                    if( nOffsetOfStructuralMetadata +\n                        strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\") +\n                        nSizePatternLen + nLenMD <= nRead )\n                    {\n                        pszStructuralMD[\n                            strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\") +\n                            nSizePatternLen + nLenMD] = 0;\n                        return CPLSPrintf(\"%s\", pszStructuralMD);\n                    }\n                }\n            }\n            return nullptr;\n        }\n    }\n\n    return m_oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}",
    "void GTiffDataset::LoadEXIFMetadata()\n{\n    if( m_bEXIFMetadataLoaded )\n        return;\n    m_bEXIFMetadataLoaded = true;\n\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n\n    GByte abyHeader[2] = { 0 };\n    if( VSIFSeekL(fp, 0, SEEK_SET) != 0 ||\n        VSIFReadL(abyHeader, 1, 2, fp) != 2 )\n        return;\n\n    const bool bLittleEndian = abyHeader[0] == 'I' && abyHeader[1] == 'I';\n    const bool bLeastSignificantBit = CPL_IS_LSB != 0;\n    const bool bSwabflag = bLittleEndian != bLeastSignificantBit;  // != is XOR.\n\n    char** papszMetadata = nullptr;\n    toff_t nOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n\n    if( TIFFGetField(m_hTIFF, TIFFTAG_EXIFIFD, &nOffset) )\n    {\n        int nExifOffset = static_cast<int>(nOffset);\n        int nInterOffset = 0;\n        int nGPSOffset = 0;\n        EXIFExtractMetadata( papszMetadata,\n                             fp, static_cast<int>(nOffset),\n                             bSwabflag, 0,\n                             nExifOffset, nInterOffset, nGPSOffset);\n    }\n\n    if( TIFFGetField(m_hTIFF, TIFFTAG_GPSIFD, &nOffset) )\n    {\n        int nExifOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n        int nInterOffset = 0;\n        int nGPSOffset = static_cast<int>(nOffset);\n        EXIFExtractMetadata( papszMetadata,\n                             fp, static_cast<int>(nOffset),\n                             bSwabflag, 0,\n                             nExifOffset, nInterOffset, nGPSOffset );\n    }\n\n    if( papszMetadata )\n    {\n        m_oGTiffMDMD.SetMetadata( papszMetadata, \"EXIF\" );\n        CSLDestroy( papszMetadata );\n    }\n}",
    "CPLErr GTiffDataset::CreateMaskBand(int nFlagsIn)\n{\n    ScanDirectories();\n\n    if( m_poMaskDS != nullptr )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"This TIFF dataset has already an internal mask band\" );\n        return CE_Failure;\n    }\n    else if( MustCreateInternalMask() )\n    {\n        if( nFlagsIn != GMF_PER_DATASET )\n        {\n            ReportError(\n                CE_Failure, CPLE_AppDefined,\n                \"The only flag value supported for internal mask is \"\n                \"GMF_PER_DATASET\" );\n            return CE_Failure;\n        }\n\n        int l_nCompression = COMPRESSION_PACKBITS;\n        if( strstr(GDALGetMetadataItem(GDALGetDriverByName( \"GTiff\" ),\n                                       GDAL_DMD_CREATIONOPTIONLIST, nullptr ),\n                   \"<Value>DEFLATE</Value>\") != nullptr )\n            l_nCompression = COMPRESSION_ADOBE_DEFLATE;\n\n    /* -------------------------------------------------------------------- */\n    /*      If we don't have read access, then create the mask externally.  */\n    /* -------------------------------------------------------------------- */\n        if( GetAccess() != GA_Update )\n        {\n            ReportError( CE_Warning, CPLE_AppDefined,\n                      \"File open for read-only accessing, \"\n                      \"creating mask externally.\" );\n\n            return GDALPamDataset::CreateMaskBand(nFlagsIn);\n        }\n\n        if( m_bLayoutIFDSBeforeData && !m_bKnownIncompatibleEdition &&\n            !m_bWriteKnownIncompatibleEdition )\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                        \"Adding a mask invalidates the \"\n                        \"LAYOUT=IFDS_BEFORE_DATA property\");\n            m_bKnownIncompatibleEdition = true;\n            m_bWriteKnownIncompatibleEdition = true;\n        }\n\n        bool bIsOverview = false;\n        uint32 nSubType = 0;\n        if( TIFFGetField(m_hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n        {\n            bIsOverview = (nSubType & FILETYPE_REDUCEDIMAGE) != 0;\n\n            if( (nSubType & FILETYPE_MASK) != 0 )\n            {\n                ReportError( CE_Failure, CPLE_AppDefined,\n                          \"Cannot create a mask on a TIFF mask IFD !\" );\n                return CE_Failure;\n            }\n        }\n\n        const int bIsTiled = TIFFIsTiled(m_hTIFF);\n\n        FlushDirectory();\n\n        const toff_t nOffset =\n            GTIFFWriteDirectory(\n                m_hTIFF,\n                bIsOverview ?\n                FILETYPE_REDUCEDIMAGE | FILETYPE_MASK : FILETYPE_MASK,\n                nRasterXSize, nRasterYSize,\n                1, PLANARCONFIG_CONTIG, 1,\n                m_nBlockXSize, m_nBlockYSize,\n                bIsTiled, l_nCompression,\n                PHOTOMETRIC_MASK, PREDICTOR_NONE,\n                SAMPLEFORMAT_UINT, nullptr, nullptr, nullptr, 0, nullptr, \"\", nullptr, nullptr,\n                nullptr, nullptr, m_bWriteCOGLayout, nullptr );\n\n        ReloadDirectory();\n\n        if( nOffset == 0 )\n            return CE_Failure;\n\n        m_poMaskDS = new GTiffDataset();\n        m_poMaskDS->m_poBaseDS = this;\n        m_poMaskDS->m_poImageryDS = this;\n        m_poMaskDS->ShareLockWithParentDataset(this);\n        m_poMaskDS->m_bPromoteTo8Bits =\n            CPLTestBool(\n                CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n        if( m_poMaskDS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nOffset,\n                                  GA_Update ) != CE_None)\n        {\n            delete m_poMaskDS;\n            m_poMaskDS = nullptr;\n            return CE_Failure;\n        }\n\n        return CE_None;\n    }\n\n    return GDALPamDataset::CreateMaskBand(nFlagsIn);\n}",
    "bool GTiffDataset::GetRawBinaryLayout(GDALDataset::RawBinaryLayout& sLayout)\n{\n    if( eAccess == GA_Update )\n    {\n        FlushCache();\n        Crystalize();\n    }\n\n    if( m_nCompression != COMPRESSION_NONE )\n        return false;\n    if( !CPLIsPowerOfTwo(m_nBitsPerSample) || m_nBitsPerSample < 8 )\n        return false;\n    const auto eDT = GetRasterBand(1)->GetRasterDataType();\n    if( GDALDataTypeIsComplex( eDT ) )\n        return false;\n\n    toff_t *panByteCounts = nullptr;\n    toff_t *panOffsets = nullptr;\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(m_hTIFF) );\n\n    if( !(( bIsTiled\n            && TIFFGetField( m_hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts )\n            && TIFFGetField( m_hTIFF, TIFFTAG_TILEOFFSETS, &panOffsets ) )\n            || ( !bIsTiled\n            && TIFFGetField( m_hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts )\n            && TIFFGetField( m_hTIFF, TIFFTAG_STRIPOFFSETS, &panOffsets ) )) )\n    {\n        return false;\n    }\n\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDT);\n    vsi_l_offset        nImgOffset = panOffsets[0];\n    GIntBig             nPixelOffset = ( m_nPlanarConfig == PLANARCONFIG_CONTIG ) ? static_cast<GIntBig>(nDTSize) * nBands : nDTSize;\n    GIntBig             nLineOffset = nPixelOffset * nRasterXSize;\n    GIntBig             nBandOffset = ( m_nPlanarConfig == PLANARCONFIG_CONTIG && nBands > 1 ) ? nDTSize : 0;\n    RawBinaryLayout::Interleaving eInterleaving =\n        (nBands == 1) ?                             RawBinaryLayout::Interleaving::UNKNOWN :\n        (m_nPlanarConfig == PLANARCONFIG_CONTIG ) ? RawBinaryLayout::Interleaving::BIP :\n                                                    RawBinaryLayout::Interleaving::BSQ;\n    if( bIsTiled )\n    {\n        // Only a single block tiled file with same dimension as the raster\n        // might be acceptable\n        if( m_nBlockXSize != nRasterXSize || m_nBlockYSize != nRasterYSize )\n            return false;\n        if( nBands > 1 && m_nPlanarConfig != PLANARCONFIG_CONTIG )\n        {\n            nBandOffset = static_cast<GIntBig>(panOffsets[1]) - static_cast<GIntBig>(panOffsets[0]);\n            for( int i = 2; i < nBands; i++ )\n            {\n                if( static_cast<GIntBig>(panOffsets[i]) - static_cast<GIntBig>(panOffsets[i - 1]) != nBandOffset )\n                    return false;\n            }\n        }\n    }\n    else\n    {\n        const int nStrips = DIV_ROUND_UP(nRasterYSize, m_nRowsPerStrip);\n        if( nBands == 1 || m_nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            vsi_l_offset nLastStripEnd = panOffsets[0] + panByteCounts[0];\n            for( int iStrip = 1; iStrip < nStrips; iStrip++ )\n            {\n                if( nLastStripEnd != panOffsets[iStrip] )\n                    return false;\n                nLastStripEnd = panOffsets[iStrip] + panByteCounts[iStrip];\n            }\n        }\n        else\n        {\n            // Note: we could potentially have BIL order with m_nRowsPerStrip == 1\n            // and if strips are ordered strip_line_1_band_1, ..., strip_line_1_band_N, strip_line2_band1, ... strip_line2_band_N, etc....\n            // but that'd be faily exotic !\n            // So only detect BSQ layout here\n            nBandOffset = static_cast<GIntBig>(panOffsets[nStrips]) - static_cast<GIntBig>(panOffsets[0]);\n            for( int i = 0; i < nBands; i++ )\n            {\n                uint32 iStripOffset = nStrips * i;\n                vsi_l_offset nLastStripEnd = panOffsets[iStripOffset] + panByteCounts[iStripOffset];\n                for( int iStrip = 1; iStrip < nStrips; iStrip++ )\n                {\n                    if( nLastStripEnd != panOffsets[iStripOffset + iStrip] )\n                        return false;\n                    nLastStripEnd = panOffsets[iStripOffset + iStrip] + panByteCounts[iStripOffset + iStrip];\n                }\n                if( i >= 2 &&\n                     static_cast<GIntBig>(panOffsets[iStripOffset]) -\n                        static_cast<GIntBig>(panOffsets[iStripOffset - nStrips]) != nBandOffset )\n                {\n                    return false;\n                }\n            }\n        }\n    }\n\n    sLayout.osRawFilename = m_pszFilename;\n    sLayout.eInterleaving = eInterleaving;\n    sLayout.eDataType = eDT;\n#ifdef CPL_LSB\n    sLayout.bLittleEndianOrder = !TIFFIsByteSwapped(m_hTIFF);\n#else\n    sLayout.bLittleEndianOrder = TIFFIsByteSwapped(m_hTIFF);\n#endif\n    sLayout.nImageOffset = nImgOffset;\n    sLayout.nPixelOffset = nPixelOffset;\n    sLayout.nLineOffset = nLineOffset;\n    sLayout.nBandOffset = nBandOffset;\n\n    return true;\n}",
    "CPLErr GTIFWktFromMemBufEx( int nSize, unsigned char *pabyBuffer,\n                            char **ppszWKT, double *padfGeoTransform,\n                            int *pnGCPCount, GDAL_GCP **ppasGCPList,\n                            int *pbPixelIsPoint, char*** ppapszRPCMD )\n\n{\n    char szFilename[100] = {};\n\n    snprintf( szFilename, sizeof(szFilename),\n              \"/vsimem/wkt_from_mem_buf_%ld.tif\",\n              static_cast<long>( CPLGetPID() ) );\n\n/* -------------------------------------------------------------------- */\n/*      Initialization of libtiff and libgeotiff.                       */\n/* -------------------------------------------------------------------- */\n    GTiffOneTimeInit();  // For RPC tag.\n    LibgeotiffOneTimeInit();\n\n/* -------------------------------------------------------------------- */\n/*      Create a memory file from the buffer.                           */\n/* -------------------------------------------------------------------- */\n    VSILFILE *fp = VSIFileFromMemBuffer( szFilename, pabyBuffer, nSize, FALSE );\n    if( fp == nullptr )\n        return CE_Failure;\n\n/* -------------------------------------------------------------------- */\n/*      Initialize access to the memory geotiff structure.              */\n/* -------------------------------------------------------------------- */\n    TIFF *hTIFF = VSI_TIFFOpen( szFilename, \"rc\", fp );\n\n    if( hTIFF == nullptr )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"TIFF/GeoTIFF structure is corrupt.\" );\n        VSIUnlink( szFilename );\n        CPL_IGNORE_RET_VAL(VSIFCloseL( fp ));\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get the projection definition.                                  */\n/* -------------------------------------------------------------------- */\n    bool bPixelIsPoint = false;\n    bool bPointGeoIgnore = false;\n    unsigned short nRasterType = 0;\n\n    GTIF *hGTIF = GTIFNew(hTIFF);\n\n    if( hGTIF != nullptr && GDALGTIFKeyGetSHORT(hGTIF, GTRasterTypeGeoKey,\n                                             &nRasterType, 0, 1 ) == 1\n        && nRasterType == static_cast<unsigned short>( RasterPixelIsPoint ) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore =\n            CPLTestBool( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                            \"FALSE\") );\n    }\n    if( pbPixelIsPoint )\n        *pbPixelIsPoint = bPixelIsPoint;\n    if( ppapszRPCMD )\n        *ppapszRPCMD = nullptr;\n\n    GTIFDefn *psGTIFDefn = GTIFAllocDefn();\n\n    if( hGTIF != nullptr && GTIFGetDefn( hGTIF, psGTIFDefn ) )\n        *ppszWKT = GTIFGetOGISDefn( hGTIF, psGTIFDefn );\n    else\n        *ppszWKT = nullptr;\n\n    if( hGTIF )\n        GTIFFree( hGTIF );\n\n    GTIFFreeDefn(psGTIFDefn);\n\n/* -------------------------------------------------------------------- */\n/*      Get geotransform or tiepoints.                                  */\n/* -------------------------------------------------------------------- */\n    double *padfTiePoints = nullptr;\n    double *padfScale = nullptr;\n    double *padfMatrix = nullptr;\n    int16 nCount = 0;\n\n    padfGeoTransform[0] = 0.0;\n    padfGeoTransform[1] = 1.0;\n    padfGeoTransform[2] = 0.0;\n    padfGeoTransform[3] = 0.0;\n    padfGeoTransform[4] = 0.0;\n    padfGeoTransform[5] = 1.0;\n\n    *pnGCPCount = 0;\n    *ppasGCPList = nullptr;\n\n    if( TIFFGetField(hTIFF, TIFFTAG_GEOPIXELSCALE, &nCount, &padfScale )\n        && nCount >= 2 )\n    {\n        padfGeoTransform[1] = padfScale[0];\n        padfGeoTransform[5] = -std::abs(padfScale[1]);\n\n        if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && nCount >= 6 )\n        {\n            padfGeoTransform[0] =\n                padfTiePoints[3] - padfTiePoints[0] * padfGeoTransform[1];\n            padfGeoTransform[3] =\n                padfTiePoints[4] - padfTiePoints[1] * padfGeoTransform[5];\n\n            // Adjust for pixel is point in transform.\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                padfGeoTransform[0] -=\n                    padfGeoTransform[1] * 0.5 + padfGeoTransform[2] * 0.5;\n                padfGeoTransform[3] -=\n                    padfGeoTransform[4] * 0.5 + padfGeoTransform[5] * 0.5;\n            }\n        }\n    }\n    else if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n             && nCount >= 6 )\n    {\n        *pnGCPCount = nCount / 6;\n        *ppasGCPList = static_cast<GDAL_GCP *>(\n            CPLCalloc(sizeof(GDAL_GCP), *pnGCPCount) );\n\n        for( int iGCP = 0; iGCP < *pnGCPCount; iGCP++ )\n        {\n            char szID[32] = {};\n            GDAL_GCP *psGCP = *ppasGCPList + iGCP;\n\n            snprintf( szID, sizeof(szID), \"%d\", iGCP + 1 );\n            psGCP->pszId = CPLStrdup( szID );\n            psGCP->pszInfo = CPLStrdup(\"\");\n            psGCP->dfGCPPixel = padfTiePoints[iGCP*6+0];\n            psGCP->dfGCPLine = padfTiePoints[iGCP*6+1];\n            psGCP->dfGCPX = padfTiePoints[iGCP*6+3];\n            psGCP->dfGCPY = padfTiePoints[iGCP*6+4];\n            psGCP->dfGCPZ = padfTiePoints[iGCP*6+5];\n        }\n    }\n    else if( TIFFGetField(hTIFF,TIFFTAG_GEOTRANSMATRIX,&nCount,&padfMatrix )\n             && nCount == 16 )\n    {\n        padfGeoTransform[0] = padfMatrix[3];\n        padfGeoTransform[1] = padfMatrix[0];\n        padfGeoTransform[2] = padfMatrix[1];\n        padfGeoTransform[3] = padfMatrix[7];\n        padfGeoTransform[4] = padfMatrix[4];\n        padfGeoTransform[5] = padfMatrix[5];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read RPC                                                        */\n/* -------------------------------------------------------------------- */\n    if( ppapszRPCMD != nullptr )\n    {\n        *ppapszRPCMD = GTiffDatasetReadRPCTag( hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup.                                                        */\n/* -------------------------------------------------------------------- */\n    XTIFFClose( hTIFF );\n    CPL_IGNORE_RET_VAL(VSIFCloseL( fp ));\n\n    VSIUnlink( szFilename );\n\n    if( *ppszWKT == nullptr )\n        return CE_Failure;\n\n    return CE_None;\n}",
    "bool imread_tiff(string input_image_filename, matrix<float> &returnmatrix,\n\t\tExiv2::ExifData &exifData)\n{\n    TIFFSetWarningHandler(NULL);\n    TIFF* tif = TIFFOpen(input_image_filename.c_str(), \"r\");\n    if (!tif)\n\t{\n        cerr << \"imread_tiff: Could not read input file!\" << endl;\n        return true;\n\t}\n\tuint32 imagelength;\n\tuint32 imagewidth;\n\tuint16 num_chan;//number of color channels\n\tunsigned short * buf16;\n\tunsigned char  * buf8;\n\tuint16 bits_per_sample;\n\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imagelength);\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &imagewidth);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &num_chan);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits_per_sample);\n\n\treturnmatrix.set_size(imagelength,imagewidth*3);\n\n    //The matrix is 3x wider than the image, interleaving the channels.\n\tif(bits_per_sample == 16)\n\t{\n\t  buf16 = (unsigned short *)_TIFFmalloc(TIFFScanlineSize(tif));\n      for ( unsigned int row = 0; row < imagelength; row++)\n\t  {\n\t      TIFFReadScanline(tif, buf16, row);\n          for( unsigned int col = 0; col < imagewidth; col++)\n\t\t  {\n\t\t\t  returnmatrix(row,col*3    ) = buf16[col*num_chan    ];\n\t\t\t  returnmatrix(row,col*3 + 1) = buf16[col*num_chan + 1];\n              returnmatrix(row,col*3 + 2) = buf16[col*num_chan + 2];\n\t\t  }\n\t  }\n\t  _TIFFfree(buf16);\n\t}\n\telse\n\t{\n\t  buf8 = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n      for ( unsigned int row = 0; row < imagelength; row++)\n\t  {\n\t      TIFFReadScanline(tif, buf8, row);\n          for( unsigned int col = 0; col < imagewidth; col++)\n\t\t  {\n\t\t\t  returnmatrix(row,col*3    ) = buf8[col*num_chan    ];\n\t\t\t  returnmatrix(row,col*3    ) *= 257;\n\t\t\t  returnmatrix(row,col*3 + 1) = buf8[col*num_chan + 1];\n\t\t\t  returnmatrix(row,col*3 + 1) *= 257;\n              returnmatrix(row,col*3 + 2) = buf8[col*num_chan + 2];\n              returnmatrix(row,col*3 + 2) *= 257;\n\t\t  }\n\t  }\n\t  _TIFFfree(buf8 );\n\t}\n\tTIFFClose(tif);\n\n    cout << \"imread_tiff exiv filename: \" << input_image_filename << endl;\n    auto image = Exiv2::ImageFactory::open(input_image_filename);\n\tassert(image.get() != 0);\n    image->readMetadata();\n\texifData = image->exifData();\n\n\treturn false;\n}",
    "Grid Grid::load_tiff(const std::filesystem::path& path) {\n    auto tiff = TiffPtr(TIFFOpen(path.c_str(), \"r\"));\n    if (!tiff) {\n        throw Error(\"Failed to open\");\n    }\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n    uint16_t depth = 0;\n\n    do {\n        uint32_t layer_width, layer_height;\n        TIFFGetField(tiff.get(), TIFFTAG_IMAGEWIDTH, &layer_width);\n        TIFFGetField(tiff.get(), TIFFTAG_IMAGELENGTH, &layer_height);\n\n        if (layer_width == 0 || layer_height == 0) {\n            throw Error(\"Layer {} has invalid dimensions ({}x{})\", depth, layer_width, layer_height);\n        } else if (width == 0) {\n            width = layer_width;\n            height = layer_height;\n        } else if (layer_width != width && layer_height != height) {\n            throw Error(\"Dimensions of layer {} differ from previous dimensions ({}x{}, previously {}x{})\",\n                depth,\n                layer_width,\n                layer_height,\n                width,\n                height\n            );\n        }\n\n        ++depth;\n    } while (TIFFReadDirectory(tiff.get()));\n\n    const size_t size = static_cast<size_t>(depth) * width * height;\n    auto data = std::make_unique<Pixel[]>(size);\n\n    fmt::print(\"{}x{}x{} = {} pixels\\n\", width, height, depth, size);\n\n    size_t layer_stride = width * height;\n    for (uint16_t i = 0; i < depth; ++i) {\n        TIFFSetDirectory(tiff.get(), i);\n\n        // TIFFReadRGBAImage writes uint32_t's to the raster, which are in the form ABGR. This means\n        // that in-memory, their layout is RGBA if the host machine is little-endian, so instead of\n        // an expensive copy routine just do a reinterpret cast.\n        TIFFReadRGBAImage(tiff.get(), width, height, reinterpret_cast<uint32_t*>(&data.get()[layer_stride * i]));\n    }\n\n    return Grid(\n        {width, height, depth},\n        std::move(data)\n    );\n}",
    "bool wxTIFFHandler::LoadFile( wxImage *image, wxInputStream& stream, bool verbose, int index )\n{\n    if (index == -1)\n        index = 0;\n\n    image->Destroy();\n\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"r\" );\n\n    if (!tif)\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Error loading image.\") );\n\n        return false;\n    }\n\n    if (!TIFFSetDirectory( tif, (tdir_t)index ))\n    {\n        if (verbose)\n            wxLogError( _(\"Invalid TIFF image index.\") );\n\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    uint32 w, h;\n    uint32 *raster;\n\n    TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &w );\n    TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &h );\n\n    uint16 extraSamples;\n    uint16* samplesInfo;\n    TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,\n                          &extraSamples, &samplesInfo);\n    const bool hasAlpha = (extraSamples == 1 &&\n                           (samplesInfo[0] == EXTRASAMPLE_ASSOCALPHA ||\n                            samplesInfo[0] == EXTRASAMPLE_UNASSALPHA));\n\n    // guard against integer overflow during multiplication which could result\n    // in allocating a too small buffer and then overflowing it\n    const double bytesNeeded = (double)w * (double)h * sizeof(uint32);\n    if ( bytesNeeded >= 4294967295U /* UINT32_MAX */ )\n    {\n        if ( verbose )\n            wxLogError( _(\"TIFF: Image size is abnormally big.\") );\n\n        TIFFClose(tif);\n\n        return false;\n    }\n\n    raster = (uint32*) _TIFFmalloc( bytesNeeded );\n\n    if (!raster)\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    image->Create( (int)w, (int)h );\n    if (!image->Ok())\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n\n        _TIFFfree( raster );\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    if ( hasAlpha )\n        image->SetAlpha();\n\n    if (!TIFFReadRGBAImage( tif, w, h, raster, 0 ))\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Error reading image.\") );\n\n        _TIFFfree( raster );\n        image->Destroy();\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    unsigned char *ptr = image->GetData();\n    ptr += w*3*(h-1);\n\n    unsigned char *alpha = hasAlpha ? image->GetAlpha() : NULL;\n    if ( hasAlpha )\n        alpha += w*(h-1);\n\n    uint32 pos = 0;\n\n    for (uint32 i = 0; i < h; i++)\n    {\n        for (uint32 j = 0; j < w; j++)\n        {\n            *(ptr++) = (unsigned char)TIFFGetR(raster[pos]);\n            *(ptr++) = (unsigned char)TIFFGetG(raster[pos]);\n            *(ptr++) = (unsigned char)TIFFGetB(raster[pos]);\n            if ( hasAlpha )\n                *(alpha++) = (unsigned char)TIFFGetA(raster[pos]);\n\n            pos++;\n        }\n\n        // subtract line we just added plus one line:\n        ptr -= 2*w*3;\n        if ( hasAlpha )\n            alpha -= 2*w;\n    }\n\n    _TIFFfree( raster );\n\n    TIFFClose( tif );\n\n    return true;\n}",
    "bool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = TIFFOpen( m_filename.c_str(), \"r\" );\n\n    if( tif )\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            uint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if( bpp > 8 &&\n               ((photometric != 2 && photometric != 1) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? 3 : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? 3 : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.data;\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 ||\n                (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const size_t buffer_size = bpp * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer( buffer_size );\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += img.step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                    icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, buffer_size ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    close();\n    return result;\n}",
    "static void im_peek(const std::string& path, bob::io::base::array::typeinfo& info)\n{\n  // 1. TIFF file opening\n  boost::shared_ptr<TIFF> in_file = make_cfile(path.c_str(), \"r\");\n\n  // 2. Get file information\n  uint32 w, h;\n  TIFFGetField(in_file.get(), TIFFTAG_IMAGEWIDTH, &w);\n  TIFFGetField(in_file.get(), TIFFTAG_IMAGELENGTH, &h);\n  size_t width = (size_t)w;\n  size_t height = (size_t)h;\n\n  uint16 bps, spp;\n  TIFFGetField(in_file.get(), TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetField(in_file.get(), TIFFTAG_SAMPLESPERPIXEL, &spp);\n\n  // 3. Set typeinfo variables\n  info.dtype = (bps <= 8 ? bob::io::base::array::t_uint8 : bob::io::base::array::t_uint16);\n  if(spp == 1)\n    info.nd = 2;\n  else if (spp == 3)\n    info.nd = 3;\n  else { // Unsupported color type\n    boost::format m(\"TIFF: found unsupported object of type `%s' at file `%s': unsupported color type\");\n    m % info.str() % path;\n    throw std::runtime_error(m.str());\n  }\n  if(info.nd == 2)\n  {\n    info.shape[0] = height;\n    info.shape[1] = width;\n  }\n  else\n  {\n    info.shape[0] = 3;\n    info.shape[1] = height;\n    info.shape[2] = width;\n  }\n  info.update_strides();\n}",
    "static\nvoid im_load_gray(boost::shared_ptr<TIFF> in_file, bob::io::base::array::interface& b)\n{\n  const bob::io::base::array::typeinfo& info = b.type();\n  const size_t height = info.shape[0];\n  const size_t width = info.shape[1];\n\n  // Read in the possibly multiple strips\n  tsize_t strip_size = TIFFStripSize(in_file.get());\n  tstrip_t n_strips = TIFFNumberOfStrips(in_file.get());\n\n  unsigned long buffer_size = n_strips * strip_size;\n  boost::shared_array<unsigned char> buffer_(new unsigned char[buffer_size]);\n  unsigned char* buffer = buffer_.get();\n  if(buffer == 0) throw std::runtime_error(\"TIFF: error while getting the color buffer\");\n\n  tsize_t result;\n  tsize_t image_offset = 0;\n  for(tstrip_t strip_count=0; strip_count<n_strips; ++strip_count)\n  {\n    if((result = TIFFReadEncodedStrip(in_file.get(), strip_count, buffer+image_offset, strip_size)) == -1)\n      throw std::runtime_error(\"TIFF: error in function TIFFReadEncodedStrip()\");\n    image_offset += result;\n  }\n\n  //Comment just to document\n  //PHOTOMETRIC_PALETTE: In this model, a color is described with a single component. The value of the component is used as an index into the red, green and blue curves in the ColorMap field to retrieve an RGB triplet that defines the color. When PhotometricInterpretation=3\n\n  // Deal with photometric interpretations\n  uint16 photo = PHOTOMETRIC_MINISBLACK;\n  if(TIFFGetField(in_file.get(), TIFFTAG_PHOTOMETRIC, &photo) == 0 || (photo != PHOTOMETRIC_MINISBLACK && photo != PHOTOMETRIC_MINISWHITE && photo != PHOTOMETRIC_PALETTE)){\n    throw std::runtime_error(\"TIFF: error in function TIFFGetField()\");\n  }\n\n  if(photo == PHOTOMETRIC_MINISWHITE)\n  {\n    // Flip bits\n    for(unsigned long count=0; count<buffer_size; ++count)\n      buffer[count] = ~buffer[count];\n  }\n\n  // Deal with fillorder\n  uint16 fillorder = FILLORDER_MSB2LSB;\n  TIFFGetField(in_file.get(), TIFFTAG_FILLORDER, &fillorder);\n\n  if(fillorder != FILLORDER_MSB2LSB) {\n    // We need to swap bits -- ABCDEFGH becomes HGFEDCBA\n    for(unsigned long count=0; count<buffer_size; ++count)\n    {\n      unsigned char tempbyte = 0;\n      if(buffer[count] & 128) tempbyte += 1;\n      if(buffer[count] & 64) tempbyte += 2;\n      if(buffer[count] & 32) tempbyte += 4;\n      if(buffer[count] & 16) tempbyte += 8;\n      if(buffer[count] & 8) tempbyte += 16;\n      if(buffer[count] & 4) tempbyte += 32;\n      if(buffer[count] & 2) tempbyte += 64;\n      if(buffer[count] & 1) tempbyte += 128;\n      buffer[count] = tempbyte;\n    }\n  }\n\n  // Copy to output array\n  T *element = reinterpret_cast<T*>(b.ptr());\n  T *b_in = reinterpret_cast<T*>(buffer);\n  memcpy(element, b_in, height*width*sizeof(T));\n}",
    "static\nvoid im_load_color(boost::shared_ptr<TIFF> in_file, bob::io::base::array::interface& b)\n{\n  const bob::io::base::array::typeinfo& info = b.type();\n  const size_t height = info.shape[1];\n  const size_t width = info.shape[2];\n  const size_t frame_size = height*width;\n  const size_t row_stride = width;\n  const size_t row_color_stride = 3*width;\n\n  // Read in the possibly multiple strips\n  tsize_t strip_size = TIFFStripSize(in_file.get());\n  tstrip_t n_strips = TIFFNumberOfStrips(in_file.get());\n\n  unsigned long buffer_size = n_strips * strip_size;\n  boost::shared_array<unsigned char> buffer_(new unsigned char[buffer_size]);\n  unsigned char* buffer = buffer_.get();\n  if(buffer == 0) throw std::runtime_error(\"TIFF: error while getting the color buffer\");\n\n  tsize_t result;\n  tsize_t image_offset = 0;\n  for(tstrip_t strip_count=0; strip_count<n_strips; ++strip_count)\n  {\n    if((result = TIFFReadEncodedStrip(in_file.get(), strip_count, buffer+image_offset, strip_size)) == -1)\n      throw std::runtime_error(\"TIFF: error in function TIFFReadEncodedStrip()\");\n\n    image_offset += result;\n  }\n\n  // Deal with photometric interpretations\n  uint16 photo = PHOTOMETRIC_RGB;\n  if(TIFFGetField(in_file.get(), TIFFTAG_PHOTOMETRIC, &photo) == 0 || photo != PHOTOMETRIC_RGB)\n    throw std::runtime_error(\"TIFF: error in function TIFFGetField()\");\n\n  // Deal with fillorder\n  uint16 fillorder = FILLORDER_MSB2LSB;\n  TIFFGetField(in_file.get(), TIFFTAG_FILLORDER, &fillorder);\n\n  if(fillorder != FILLORDER_MSB2LSB) {\n    // We need to swap bits -- ABCDEFGH becomes HGFEDCBA\n    for(unsigned long count=0; count<(unsigned long)image_offset; ++count)\n    {\n      unsigned char tempbyte = 0;\n      if(buffer[count] & 128) tempbyte += 1;\n      if(buffer[count] & 64) tempbyte += 2;\n      if(buffer[count] & 32) tempbyte += 4;\n      if(buffer[count] & 16) tempbyte += 8;\n      if(buffer[count] & 8) tempbyte += 16;\n      if(buffer[count] & 4) tempbyte += 32;\n      if(buffer[count] & 2) tempbyte += 64;\n      if(buffer[count] & 1) tempbyte += 128;\n      buffer[count] = tempbyte;\n    }\n  }\n\n  // Read the image (one row at a time)\n  // This can deal with interlacing\n  T *element_r = reinterpret_cast<T*>(b.ptr());\n  T *element_g = element_r + frame_size;\n  T *element_b = element_g + frame_size;\n  unsigned char *row_pointer = buffer;\n  // Loop over the rows\n  for(size_t y=0; y<height; ++y)\n  {\n    imbuffer_to_rgb(row_stride, reinterpret_cast<T*>(row_pointer), element_r, element_g, element_b);\n    element_r += row_stride;\n    element_g += row_stride;\n    element_b += row_stride;\n    row_pointer += row_color_stride * sizeof(T);\n  }\n}",
    "float * read_tiff_image(const char* inputFile, uint32 *widthOut, uint32 *heightOut, uint32 *nChannels)\n{\n\n\tTIFF *tifFile=TIFFOpen(inputFile, \"r\");\n\t//get height and width of image\n\tTIFFGetField(tifFile, TIFFTAG_IMAGEWIDTH, widthOut);           // uint32 width;\n\tTIFFGetField(tifFile, TIFFTAG_IMAGELENGTH, heightOut);        // uint32 height;\n\tTIFFGetField(tifFile, TIFFTAG_IMAGEDEPTH, nChannels);\n\t*nChannels = (int)fmax((float)*nChannels,(float)1.0);\n\t*nChannels = (int)fmin((float)*nChannels,(float)MAX_CHANNELS);\n\n\tstd::cout << \"Image size : \" << *widthOut << \" x \" <<\n\t\t\t*heightOut << \" x \" << *nChannels << std::endl;\n\tuint32 width = *widthOut;\n\tuint32 height = *heightOut;\n\n\t//reserve temporary space for the image\n\tuint32 npixels=(uint32)(width*height);\n\tuint32* raster=(uint32*) _TIFFmalloc(npixels *sizeof(uint32));\n\n\tfloat *outputImg = new float[npixels*(*nChannels)];\n\t//read the image\n\tif (raster != NULL)\n\t{\n\t\tif (TIFFReadRGBAImage(tifFile, width, height, raster, 0) != 0)\n\t\t{\n\t\t\t//copy image information into the matrix\n\t\t\tfor (uint32 i=0; i<height; i++)\n\t\t\t\tfor (uint32 j=0; j<width; j++)\n\t\t\t\t\tfor (uint32 c=0; c<(*nChannels); c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint iRaster = height-i-1;\t//note, the libtiff stores the image from the bottom left as the origin\n\t\t\t\t\t\tswitch(c)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\toutputImg[j + i*width] = (float)TIFFGetR(raster[ iRaster*width + j]);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\toutputImg[j + i*width + width*height] =\n\t\t\t\t\t\t\t\t(float)TIFFGetG(raster[ iRaster*width + j]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\toutputImg[j + i*width + 2*width*height] =\n\t\t\t\t\t\t\t\t(float)TIFFGetB(raster[ iRaster*width + j]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n  \t\t\t\t\t\t\t\tstd::cout << \"Error in reading the tiff file, too many channels.\" << std::endl;\n  \t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout << \"Error reading the image file with TIFFReadRGBAImage\" << std::endl;\n\t\t}\n    }\n\telse\n\t{\n\t\tstd::cout << \"Error, could not read the input image.\" << std::endl;\n\t\tstd::cout << \"File name : \" << inputFile << std::endl;\n\t\tTIFFClose(tifFile);\n\t\treturn(NULL);\n\t}\n    _TIFFfree(raster);\n\n\t//close image\n\tTIFFClose(tifFile);\n\treturn(outputImg);\n}",
    "bool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif);\n    if (!m_tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n    }\n\n    if( tif )\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            uint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if((bpp == 32 && ncn == 3) || photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? wanted_channels : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? wanted_channels : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    if(m_hdr && img.type() == CV_32FC3)\n    {\n        return readData_32FC3(img);\n    }\n    if(img.type() == CV_32FC1)\n    {\n        return readData_32FC1(img);\n    }\n    bool result = false;\n    bool color = img.channels() > 1;\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        TIFFGetField( tif, TIFFTAG_ORIENTATION, &img_orientation);\n        bool vert_flip = (img_orientation == ORIENTATION_BOTRIGHT) || (img_orientation == ORIENTATION_RIGHTBOT) ||\n                         (img_orientation == ORIENTATION_BOTLEFT) || (img_orientation == ORIENTATION_LEFTBOT);\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 ||\n               (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            if(dst_bpp == 8) {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            const size_t buffer_size = (bpp/bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer( buffer_size );\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                uchar* data = img.ptr(vert_flip ? m_height - y - tile_height : y);\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R( bstart + i*tile_width0*4, 0,\n                                                             data + x*4 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 4, 0,\n                                                cvSize(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 3, 0,\n                                                cvSize(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, buffer_size ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    return result;\n}",
    "bool TiffDecoder::readData_32FC3(Mat& img)\n{\n    int rows_per_strip = 0, photometric = 0;\n    if(!m_tif)\n    {\n        return false;\n    }\n    TIFF *tif = static_cast<TIFF*>(m_tif);\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);\n    TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    int size = 3 * m_width * m_height * sizeof (float);\n    tstrip_t strip_size = 3 * m_width * rows_per_strip;\n    float *ptr = img.ptr<float>();\n    for (tstrip_t i = 0; i < TIFFNumberOfStrips(tif); i++, ptr += strip_size)\n    {\n        TIFFReadEncodedStrip(tif, i, ptr, size);\n        size -= strip_size * sizeof(float);\n    }\n    close();\n    if(photometric == PHOTOMETRIC_LOGLUV)\n    {\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    else\n    {\n        cvtColor(img, img, COLOR_RGB2BGR);\n    }\n    return true;\n}",
    "bool TiffDecoder::readData_32FC1(Mat& img)\n{\n    if(!m_tif)\n    {\n        return false;\n    }\n    TIFF *tif = static_cast<TIFF*>(m_tif);\n\n    uint32 img_width, img_height;\n    TIFFGetField(tif,TIFFTAG_IMAGEWIDTH, &img_width);\n    TIFFGetField(tif,TIFFTAG_IMAGELENGTH, &img_height);\n    if(img.size() != Size(img_width,img_height))\n    {\n        close();\n        return false;\n    }\n    tsize_t scanlength = TIFFScanlineSize(tif);\n    tdata_t buf = _TIFFmalloc(scanlength);\n    float* data;\n    bool result = true;\n    for (uint32 row = 0; row < img_height; row++)\n    {\n        if (TIFFReadScanline(tif, buf, row) != 1)\n        {\n            result = false;\n            break;\n        }\n        data=(float*)buf;\n        for (uint32 i=0; i<img_width; i++)\n        {\n            img.at<float>(row,i) = data[i];\n        }\n    }\n    _TIFFfree(buf);\n    close();\n\n    return result;\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    if(m_hdr && img.type() == CV_32FC3)\n    {\n        return readHdrData(img);\n    }\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.ptr();\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 ||\n               (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            if(dst_bpp == 8) {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            const size_t buffer_size = (bpp/bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer( buffer_size );\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += img.step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R( bstart + i*tile_width0*4, 0,\n                                                             data + x*4 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 4, 0,\n                                                cvSize(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 3, 0,\n                                                cvSize(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, buffer_size ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    return result;\n}",
    "int main(int argc, char* argv[]) {\n\n    TIFFSetWarningHandler(DummyHandler);\n\n    if (argc != 3) {\n        cerr << \"Usage:  \" << argv[0] << \" FILE.TIFF OUTPUT_FILENAME\" << endl;\n        return -1;\n    }\n\n    filename = argv[1];\n    out_filename = argv[2];\n\n\n    printf(\"Converting %s to %s: \", filename, out_filename);\n\n    FILE *fp = fopen(filename, \"rb\");\n    if (!fp) {\n        cout << \"FP is null\" << endl;\n        return -1;\n    };\n    fclose(fp);\n\n\n    TIFF *tif=TIFFOpen(filename, \"r\");\n    fp = fopen(out_filename, \"wb\");\n\n\n    uint32_t width = 0, height = 0, bits_per_sample = 0, samples_per_pixel = 0, sample_format = 0;\n\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);           // uint32 width;\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);        // uint32 height;\n\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits_per_sample);\n    TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel);\n    TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sample_format);\n\n\n    printf(\"(%d x %d, %d bit) \", width, height, bits_per_sample);\n\n    if ( (bits_per_sample != 16) || (sample_format != 2) || (samples_per_pixel != 1) ) {\n        printf(\"ERROR: Bad format. Aborted. \\n\\n\");\n        fclose(fp);\n        TIFFClose(tif);\n        return -1;\n    }\n\n\n    int16_t *buf;\n    tsize_t scanline = TIFFScanlineSize(tif);\n\n\n    buf = (int16_t*) _TIFFmalloc(scanline);\n    for (uint32_t row = 0; row < height; row++) {\n        TIFFReadScanline(tif, buf, row);\n\n\n        for (int i = 0; i < width; i++) {\n            buf[i] /= 2;\n        }\n\n        fwrite( buf, scanline, 1, fp );\n\n    };\n    _TIFFfree(buf);\n\n\n\n    TIFFClose(tif);\n    fclose(fp);\n\n    printf(\"Done.\\n\");\n\n    return 0;\n}",
    "int main(int argc, char* argv[]) {\n\n    TIFFSetWarningHandler(DummyHandler);\n\n    if (argc != 5) {\n        cerr << \"Usage:  \" << argv[0] << \" <background.tiff> <overlay.tiff> <mask.tiff> <output_filename.tiff>\" << endl;\n        return -1;\n    }\n\n    char *fn_tiff1 = argv[1];\n    char *fn_tiff2 = argv[2];\n    char *fn_tiff_mask = argv[3];\n    char *fn_tiff_out = argv[4];\n\n    // only check\n    FILE *fp;\n\n    fp = fopen(fn_tiff1, \"rb\");\n    if (!fp) {\n        fprintf(stderr, \"Not found: %s. Aborted.\\n\", fn_tiff1);\n        return -1;\n    };\n    fclose(fp);\n\n    fp = fopen(fn_tiff2, \"rb\");\n    if (!fp) {\n        fprintf(stderr, \"Not found: %s. Aborted.\\n\", fn_tiff2);\n        return -1;\n    };\n    fclose(fp);\n\n    fp = fopen(fn_tiff_mask, \"rb\");\n    if (!fp) {\n        fprintf(stderr, \"Not found: %s. Aborted.\\n\", fn_tiff_mask);\n        return -1;\n    };\n    fclose(fp);\n\n\n    TIFF *tiff1 = TIFFOpen(fn_tiff1, \"rb\");\n\n    TIFF *tiff2 = TIFFOpen(fn_tiff2, \"rb\");\n\n    TIFF *tiff_mask = TIFFOpen(fn_tiff_mask, \"rb\");\n\n    TIFF *tiff_out = TIFFOpen(fn_tiff_out, \"rb+\");\n\n\n\n    uint32_t width = 0, height = 0, bits_per_sample = 0, samples_per_pixel = 0, sample_format = 0;\n\n\n\n    TIFFGetField(tiff1, TIFFTAG_IMAGEWIDTH, &width);           // uint32 width;\n    TIFFGetField(tiff1, TIFFTAG_IMAGELENGTH, &height);        // uint32 height;\n\n    TIFFGetField(tiff1, TIFFTAG_BITSPERSAMPLE, &bits_per_sample);\n    TIFFGetField(tiff1, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel);\n    TIFFGetField(tiff1, TIFFTAG_SAMPLEFORMAT, &sample_format);\n\n\n\n    printf(\"%s: (%d x %d, %d bit) (samples per pixel: %d, format: %d) \\n\", fn_tiff1, width, height, bits_per_sample, samples_per_pixel, sample_format);\n\n    if ( (bits_per_sample != 16) || (sample_format != 2) || (samples_per_pixel != 1) ) {\n        fprintf(stderr, \"ERROR: Bad format. Aborted. \\n\\n\");\n        TIFFClose(tiff1);\n        TIFFClose(tiff2);\n        TIFFClose(tiff_mask);\n        TIFFClose(tiff_out);\n        exit(-1);\n    };\n\n    uint32_t width2 = 0, height2 = 0, bits_per_sample2 = 0, samples_per_pixel2 = 0, sample_format2 = 0;\n\n    TIFFGetField(tiff2, TIFFTAG_IMAGEWIDTH, &width2);           // uint32 width;\n    TIFFGetField(tiff2, TIFFTAG_IMAGELENGTH, &height2);        // uint32 height;\n\n    TIFFGetField(tiff2, TIFFTAG_BITSPERSAMPLE, &bits_per_sample2);\n    TIFFGetField(tiff2, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel2);\n    TIFFGetField(tiff2, TIFFTAG_SAMPLEFORMAT, &sample_format2);\n\n    printf(\"%s: (%d x %d, %d bit) (samples per pixel: %d, format: %d) \\n\", fn_tiff2, width2, height2, bits_per_sample2, samples_per_pixel2, sample_format2);\n\n    if (\n        (width != width2)\n        || (height != height2)\n        || (bits_per_sample != bits_per_sample2)\n        || (samples_per_pixel != samples_per_pixel2)\n        || (sample_format != sample_format2)\n\n        ) {\n\n        fprintf(stderr, \"ERROR: Format of %s is different from %s. Aborted. \\n\", fn_tiff2, fn_tiff1 );\n\n        TIFFClose(tiff1);\n        TIFFClose(tiff2);\n        TIFFClose(tiff_mask);\n        TIFFClose(tiff_out);\n\n        exit(-1);\n\n    };\n\n\n\n    uint32_t width_mask = 0, height_mask = 0, bits_per_sample_mask = 0, samples_per_pixel_mask = 0, sample_format_mask = 0;\n\n    TIFFGetField(tiff_mask, TIFFTAG_IMAGEWIDTH, &width_mask);           // uint32 width;\n    TIFFGetField(tiff_mask, TIFFTAG_IMAGELENGTH, &height_mask);        // uint32 height;\n\n    TIFFGetField(tiff_mask, TIFFTAG_BITSPERSAMPLE, &bits_per_sample_mask);\n    TIFFGetField(tiff_mask, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel_mask);\n    TIFFGetField(tiff_mask, TIFFTAG_SAMPLEFORMAT, &sample_format_mask);\n\n    printf(\"%s: (%d x %d, %d bit) (samples per pixel: %d, format: %d) \\n\", fn_tiff_mask, width_mask, height_mask, bits_per_sample_mask, samples_per_pixel_mask, sample_format_mask);\n\n\n\n    int16_t *buf1, *buf2;\n    uint8_t *buf_mask;\n    tsize_t scanline = TIFFScanlineSize(tiff1);\n\n    if (TIFFScanlineSize(tiff2) != scanline) {\n        fprintf(stderr, \"ERROR: Scanline Size of %s (%d) is different from %s (%d).\\n\", fn_tiff2, (TIFFScanlineSize(tiff2)), fn_tiff1, scanline );\n        return -1;\n    };\n    if (2*TIFFScanlineSize(tiff_mask) != scanline) {\n        fprintf(stderr, \"ERROR: Scanline Size of %s (%d) must be 1/2 of scanline size of %s (%d).\\n\", fn_tiff_mask, (TIFFScanlineSize(tiff_mask)), fn_tiff1, scanline );\n        return -1;\n    };\n\n\n    buf1 = (int16_t*) _TIFFmalloc(scanline);\n    buf2 = (int16_t*) _TIFFmalloc(scanline);\n    buf_mask = (uint8_t*) _TIFFmalloc(scanline);\n\n\n    for (uint32_t row = 0; row < height; row++) {\n\n        TIFFReadScanline(tiff1, buf1, row);\n        TIFFReadScanline(tiff2, buf2, row);\n        TIFFReadScanline(tiff_mask, buf_mask, row);\n\n\n        for (int i = 0; i < width; i++) {\n\n            float k = 1.0 / 255.0 * buf_mask[i];\n\n            buf1[i] = (int16_t) ( (1.0-k)*buf1[i] + k*buf2[i] );\n\n        };\n\n\n        TIFFWriteScanline(tiff_out, buf1, row);\n\n    };\n\n    _TIFFfree(buf1);\n    _TIFFfree(buf2);\n    _TIFFfree(buf_mask);\n\n\n\n    TIFFClose(tiff1);\n    TIFFClose(tiff2);\n    TIFFClose(tiff_mask);\n    TIFFClose(tiff_out);\n\n\n\n    printf(\"Done.\\n\");\n\n    return 0;\n}",
    "int ReadTiff(const char * filename,\n  std::vector<unsigned char> * ptr,\n  int * w,\n  int * h,\n  int * depth)\n{\n  TIFF* tiff = TIFFOpen(filename, \"r\");\n  if (!tiff) {\n    std::cerr << \"Error: Couldn't open \" << filename << \" fopen returned 0\";\n    return 0;\n  }\n  uint16 bps, spp;\n\n  TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, w);\n  TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, h);\n  TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  *depth = bps * spp / 8;\n\n  ptr->resize((*h)*(*w)*(*depth));\n\n  if (*depth==4) {\n    if (ptr != nullptr) {\n      if (!TIFFReadRGBAImageOriented(tiff, *w, *h, (uint32*)&((*ptr)[0]), ORIENTATION_TOPLEFT, 0)) {\n        TIFFClose(tiff);\n        return 0;\n      }\n    }\n  } else {\n    for (size_t i=0; i<TIFFNumberOfStrips(tiff); ++i) {\n      if (TIFFReadEncodedStrip(tiff, i, ((uint8*)&((*ptr)[0]))+i*TIFFStripSize(tiff),(tsize_t)-1) ==\n        std::numeric_limits<tsize_t>::max()) {\n        TIFFClose(tiff);\n        return 0;\n      }\n    }\n  }\n  TIFFClose(tiff);\n  return 1;\n}",
    "TiffReader::TiffInfo::TiffInfo(const TiffHandle& tif, const TiffHeader& header)\n    : width(0),\n      height(0),\n      bitsPerSample(1),\n      samplesPerPixel(1),\n      sampleFormat(SAMPLEFORMAT_UINT),\n      photometric(PHOTOMETRIC_MINISBLACK),\n      hostBigEndian(QSysInfo::ByteOrder == QSysInfo::BigEndian),\n      fileBigEndian(header.signature() == TiffHeader::TIFF_BIG_ENDIAN) {\n  uint16 compression = 1;\n  TIFFGetField(tif.handle(), TIFFTAG_COMPRESSION, &compression);\n  switch (compression) {\n    case COMPRESSION_CCITTFAX3:\n    case COMPRESSION_CCITTFAX4:\n    case COMPRESSION_CCITTRLE:\n    case COMPRESSION_CCITTRLEW:\n      photometric = PHOTOMETRIC_MINISWHITE;\n      break;\n    default:\n      break;\n  }\n\n  TIFFGetField(tif.handle(), TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(tif.handle(), TIFFTAG_IMAGELENGTH, &height);\n  TIFFGetField(tif.handle(), TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n  TIFFGetField(tif.handle(), TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);\n  TIFFGetField(tif.handle(), TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n  TIFFGetField(tif.handle(), TIFFTAG_PHOTOMETRIC, &photometric);\n}",
    "ImageMetadata TiffReader::currentPageMetadata(const TiffHandle& tif) {\n  uint32 width = 0, height = 0;\n  float xres = 0, yres = 0;\n  uint16 resUnit = 0;\n  TIFFGetField(tif.handle(), TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(tif.handle(), TIFFTAG_IMAGELENGTH, &height);\n  TIFFGetField(tif.handle(), TIFFTAG_XRESOLUTION, &xres);\n  TIFFGetField(tif.handle(), TIFFTAG_YRESOLUTION, &yres);\n  TIFFGetFieldDefaulted(tif.handle(), TIFFTAG_RESOLUTIONUNIT, &resUnit);\n  return ImageMetadata(QSize(width, height), getDpi(xres, yres, resUnit));\n}",
    "QImage TiffReader::extractBinaryOrIndexed8Image(const TiffHandle& tif, const TiffInfo& info) {\n  QImage::Format format = QImage::Format_Indexed8;\n  if (info.bitsPerSample == 1) {\n    // Because we specify B option when opening, we can\n    // always use Format_Mono, and not Format_MonoLSB.\n    format = QImage::Format_Mono;\n  }\n\n  QImage image(info.width, info.height, format);\n  if (image.isNull()) {\n    throw std::bad_alloc();\n  }\n\n  const int numColors = 1 << info.bitsPerSample;\n  image.setColorCount(numColors);\n\n  if (info.photometric == PHOTOMETRIC_PALETTE) {\n    uint16* pr = nullptr;\n    uint16* pg = nullptr;\n    uint16* pb = nullptr;\n    TIFFGetField(tif.handle(), TIFFTAG_COLORMAP, &pr, &pg, &pb);\n    if (!pr || !pg || !pb) {\n      return QImage();\n    }\n    if (info.hostBigEndian != info.fileBigEndian) {\n      TIFFSwabArrayOfShort(pr, numColors);\n      TIFFSwabArrayOfShort(pg, numColors);\n      TIFFSwabArrayOfShort(pb, numColors);\n    }\n    const double f = 255.0 / 65535.0;\n    for (int i = 0; i < numColors; ++i) {\n      const auto r = (uint32) std::lround(pr[i] * f);\n      const auto g = (uint32) std::lround(pg[i] * f);\n      const auto b = (uint32) std::lround(pb[i] * f);\n      const uint32 a = 0xFF000000;\n      image.setColor(i, a | (r << 16) | (g << 8) | b);\n    }\n  } else if (info.photometric == PHOTOMETRIC_MINISBLACK) {\n    const double f = 255.0 / (numColors - 1);\n    for (int i = 0; i < numColors; ++i) {\n      const auto gray = (int) std::lround(i * f);\n      image.setColor(i, qRgb(gray, gray, gray));\n    }\n  } else if (info.photometric == PHOTOMETRIC_MINISWHITE) {\n    const double f = 255.0 / (numColors - 1);\n    int c = numColors - 1;\n    for (int i = 0; i < numColors; ++i, --c) {\n      const auto gray = (int) std::lround(c * f);\n      image.setColor(i, qRgb(gray, gray, gray));\n    }\n  } else {\n    return QImage();\n  }\n\n  if ((info.bitsPerSample == 1) || (info.bitsPerSample == 8)) {\n    readLines(tif, image);\n  } else {\n    readAndUnpackLines(tif, info, image);\n  }\n  return image;\n}",
    "void ScImgDataLoader_TIFF::loadEmbeddedProfile(const QString& fn, int /*page*/)\n{\n\tScColorMgmtEngine engine(ScCore->defaultEngine);\n\tm_embeddedProfile.resize(0);\n\tm_profileComponents = 0;\n\tif (!QFile::exists(fn))\n\t\treturn;\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn;\n\n\tuint32 EmbedLen = 0;\n\tvoid*  EmbedBuffer;\n\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer))\n\t{\n\t\tQByteArray profArray((const char*) EmbedBuffer, EmbedLen);\n\t\tScColorProfile tiffProf = engine.openProfileFromMem(profArray);\n\t\tif (tiffProf)\n\t\t{\n\t\t\tif (tiffProf.colorSpace() == ColorSpace_Rgb)\n\t\t\t\tm_profileComponents = 3;\n\t\t\tif (tiffProf.colorSpace() == ColorSpace_Cmyk)\n\t\t\t\tm_profileComponents = 4;\n\t\t\tif (tiffProf.colorSpace() == ColorSpace_Gray)\n\t\t\t\tm_profileComponents = 1;\n\t\t\tm_embeddedProfile = profArray;\n\t\t}\n\t}\n\tTIFFClose(tif);\n}",
    "int ScImgDataLoader_TIFF::getLayers(const QString& fn, int /*page*/)\n{\n\tint layerNum = 1;\n\tint test;\n\tstruct PSDLayer lay;\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn layerNum;\n\n\tdo\n\t{\n\t\tchar *layerName = nullptr;\n\t\tTIFFGetField(tif, TIFFTAG_PAGENAME, &layerName);\n\t\tQString name = QString(layerName);\n\t\tif (name.isEmpty())\n\t\t\tlay.layerName = QString(\"Layer #%1\").arg(layerNum);\n\t\telse\n\t\t\tlay.layerName = name;\n\t\tlay.blend = \"norm\";\n\t\tlay.opacity = 255;\n\t\tlay.flags = 0;\n\t\tm_imageInfoRecord.layerInfo.append(lay);\n\t\tm_imageInfoRecord.valid = true;\n\t\tlayerNum++;\n\t\ttest = TIFFReadDirectory(tif);\n\t}\n\twhile (test == 1);\n\tTIFFClose(tif);\n\n\treturn layerNum;\n}",
    "bool ScImgDataLoader_TIFF::testAlphaChannelAvailability(const QString& fn, int /*page*/, bool& hasAlpha)\n{\n\tint  test;\n\n\tQByteArray byteOrder(2, ' ');\n\tQFile fo(fn);\n\tif (fo.open(QIODevice::ReadOnly))\n\t{\n\t\tfo.read(byteOrder.data(), 1);\n\t\tfo.close();\n\t}\n\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn false;\n\n\tuint16 extrasamples, *extratypes;\n\thasAlpha = false;\n\tdo\n\t{\n\t\tif (TIFFGetField (tif, TIFFTAG_EXTRASAMPLES, &extrasamples, &extratypes) == 1)\n\t\t{\n\t\t\tfor (int i = 0; i < extrasamples; ++i)\n\t\t\t{\n\t\t\t\tif (extratypes[i] != EXTRASAMPLE_UNSPECIFIED)\n\t\t\t\t{\n\t\t\t\t\thasAlpha = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttest = TIFFReadDirectory(tif);\n\t}\n\twhile (test == 1);\n\n\tif (hasAlpha)\n\t{\n\t\tTIFFClose(tif);\n\t\treturn true;\n\t}\n\n\tunsigned int PhotoshopLen2 = 0;\n\tunsigned char* PhotoshopBuffer2;\n\tint gotField = TIFFGetField(tif, 37724, &PhotoshopLen2, &PhotoshopBuffer2);\n\tif (gotField && (PhotoshopLen2 > 40))\n\t{\n\t\tm_imageInfoRecord.layerInfo.clear();\n\t\tQByteArray arrayPhot = QByteArray::fromRawData((const char*)PhotoshopBuffer2, PhotoshopLen2);\n\t\tQDataStream s(&arrayPhot, QIODevice::ReadOnly);\n\t\tif (byteOrder[0] == 'M')\n\t\t\ts.setByteOrder(QDataStream::BigEndian);\n\t\telse\n\t\t\ts.setByteOrder(QDataStream::LittleEndian);\n\n\t\tQList<PSDLayer> layerInfo;\n\t\tif (loadLayerInfo(s, layerInfo))\n\t\t{\n\t\t\tfor (int layer = 0; layer < layerInfo.count(); ++layer)\n\t\t\t{\n\t\t\t\tconst PSDLayer& psdLayer = layerInfo.at(layer);\n\t\t\t\tuint channel_num = psdLayer.channelLen.count();\n\t\t\t\tfor (uint channel = 0; channel < channel_num; ++channel)\n\t\t\t\t{\n\t\t\t\t\tif (psdLayer.channelType[channel] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\thasAlpha = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hasAlpha) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tTIFFClose(tif);\n\treturn true;\n}",
    "bool ScImgDataLoader_TIFF::getImageData(TIFF* tif, RawImage *image, uint widtht, uint heightt, uint size, uint16 photometric, uint16 bitspersample, uint16 samplesperpixel, bool &bilevel, bool &isCMYK)\n{\n\tuint32 *bits = nullptr;\n\tif (photometric == PHOTOMETRIC_SEPARATED)\n\t{\n\t\tif (samplesperpixel > 5)\n\t\t{\n\t\t\tif (!getImageData_RGBA(tif, image, widtht, heightt, size, bitspersample, samplesperpixel))\n\t\t\t\treturn false;\n\t\t\tif (bitspersample == 1)\n\t\t\t\tbilevel = true;\n\t\t\tisCMYK = false;\n\t\t\tm_pixelFormat = Format_RGBA_8;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (TIFFIsTiled(tif))\n\t\t\t{\n\t\t\t\tuint32 columns, rows;\n\t\t\t\tuint32 *tile_buf;\n\t\t\t\tuint32 xt, yt;\n\t\t\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH,  &columns);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &rows);\n\t\t\t\ttile_buf = (uint32*) _TIFFmalloc(columns*rows*sizeof(uint32));\n\t\t\t\tif (tile_buf == nullptr)\n\t\t\t\t{\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tuint32 tileW = columns, tileH = rows;\n\t\t\t\tfor (yt = 0; yt < (uint32) image->height(); yt += rows)\n\t\t\t\t{\n\t\t\t\t\tif (yt > (uint) image->height())\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (image->height()-yt < rows)\n\t\t\t\t\t\ttileH = image->height()-yt;\n\t\t\t\t\ttileW = columns;\n\t\t\t\t\tuint32 yi;\n\t\t\t\t\tint chans = image->channels();\n\t\t\t\t\tfor (xt = 0; xt < (uint) image->width(); xt += columns)\n\t\t\t\t\t{\n\t\t\t\t\t\tTIFFReadTile(tif, tile_buf, xt, yt, 0, 0);\n\t\t\t\t\t\tfor (yi = 0; yi < tileH; yi++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_TIFFmemcpy(image->scanLine(yt+(tileH-1-yi))+xt, tile_buf+tileW*yi, tileW*chans);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_TIFFfree(tile_buf);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttsize_t bytesperrow = TIFFScanlineSize(tif);\n\t\t\t\tbits = (uint32 *) _TIFFmalloc(bytesperrow);\n\t\t\t\tint chans = image->channels();\n\t\t\t\tif (bits)\n\t\t\t\t{\n\t\t\t\t\tfor (unsigned int y = 0; y < heightt; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (TIFFReadScanline(tif, bits, y, 0))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* The code below allows loading of CMYK TIFFs generated by ImageMagick, \n\t\t\t\t\t\t\t   currently commented out because its an ugly hack atm\n\t\t\t\t\t\t\t   When converting 8-bit PNGs with an alpha channel to CMYK Tiff, ImageMagick\n\t\t\t\t\t\t\t   creates a 16-bit CMYK Tiff !?!??\n\t\t\t\t\t\t\tif (bitspersample > 8)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tuchar *ptrT = image->scanLine(y);\n\t\t\t\t\t\t\t\tuchar *ptrS = (uchar*)bits;\n\t\t\t\t\t\t\t\tfor (unsigned int x = 0; x < widtht; x++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tptrT[0] = ptrS[1];\n\t\t\t\t\t\t\t\t\tptrT[1] = ptrS[3];\n\t\t\t\t\t\t\t\t\tptrT[2] = ptrS[5];\n\t\t\t\t\t\t\t\t\tptrT[3] = ptrS[7];\n\t\t\t\t\t\t\t\t\tif (samplesperpixel > 4)\n\t\t\t\t\t\t\t\t\t\tptrT[4] = ptrS[9];\n\t\t\t\t\t\t\t\t\tptrT += chans;\n\t\t\t\t\t\t\t\t\tptrS += chans * 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse */\n\t\t\t\t\t\t\t\tmemcpy(image->scanLine(y), bits, chans * widtht);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_TIFFfree(bits);\n\t\t\t\t}\n\t\t\t}\n\t\t\tisCMYK = true;\n\t\t\tm_pixelFormat = (image->channels() == 5) ? Format_CMYKA_8 : Format_CMYK_8;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (!getImageData_RGBA(tif, image, widtht, heightt, size, bitspersample, samplesperpixel))\n\t\t\treturn false;\n\t\tif (bitspersample == 1)\n\t\t\tbilevel = true;\n\t\tm_pixelFormat = Format_RGBA_8;\n\t}\n\treturn true;\n}",
    "bool ScImgDataLoader_TIFF::getImageData_RGBA(TIFF* tif, RawImage *image, uint widtht, uint heightt, uint size, uint16 bitspersample, uint16 samplesperpixel)\n{\n\tuint32* bits = (uint32 *) _TIFFmalloc(size * sizeof(uint32));\n\tif (!bits)\n\t\treturn false;\n\n\tuint16  extrasamples(0), *extratypes(nullptr);\n\tif (!TIFFGetField (tif, TIFFTAG_EXTRASAMPLES, &extrasamples, &extratypes))\n\t\textrasamples = 0;\n\t\n\tbool gotData = false;\n\tif (TIFFReadRGBAImage(tif, widtht, heightt, bits, 0))\n\t{\n\t\tfor (unsigned int y = 0; y < heightt; y++)\n\t\t{\n\t\t\tmemcpy(image->scanLine(heightt - 1 - y), bits + y * widtht, widtht * image->channels());\n\t\t\tif (QSysInfo::ByteOrder == QSysInfo::BigEndian)\n\t\t\t{\n\t\t\t\tunsigned char *s = image->scanLine( heightt - 1 - y );\n\t\t\t\tunsigned char r, g, b, a;\n\t\t\t\tfor (uint xi=0; xi < widtht; ++xi)\n\t\t\t\t{\n\t\t\t\t\tr = s[0];\n\t\t\t\t\tg = s[1];\n\t\t\t\t\tb = s[2];\n\t\t\t\t\ta = s[3];\n\t\t\t\t\ts[0] = a;\n\t\t\t\t\ts[1] = b;\n\t\t\t\t\ts[2] = g;\n\t\t\t\t\ts[3] = r;\n\t\t\t\t\ts += image->channels();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (extrasamples > 0 && extratypes[0] == EXTRASAMPLE_ASSOCALPHA)\n\t\t\tunmultiplyRGBA(image);\n\t\tgotData = true;\n\t}\n\t_TIFFfree(bits);\n\n\treturn gotData;\n}",
    "bool ScImgDataLoader_TIFF::loadPicture(const QString& fn, int page, int res, bool thumbnail)\n{\n\tScColorMgmtEngine engine(ScCore->defaultEngine);\n\tbool bilevel = false;\n\tbool failedPS = false;\n\tbool foundPS = false;\n\tshort resolutionunit = RESUNIT_INCH; // Default unit is inch\n\tfloat xres = 72.0, yres = 72.0;\n\tif (!QFile::exists(fn))\n\t\treturn false;\n\tQByteArray byteOrder(2, ' ');\n\tQFile fo(fn);\n\tif (fo.open(QIODevice::ReadOnly))\n\t{\n\t\tfo.read(byteOrder.data(), 1);\n\t\tfo.close();\n\t}\n\tsrand(314159265);\n\tfor (int i = 0; i < 4096; i++)\n\t\tm_random_table[i] = rand();\n\tfor (int i = 0; i < 4096; i++)\n\t{\n\t\tint tmp;\n\t\tint swap = i + rand() % (4096 - i);\n\t\ttmp = m_random_table[i];\n\t\tm_random_table[i] = m_random_table[swap];\n\t\tm_random_table[swap] = tmp;\n\t}\n\n\tinitialize();\n\n\tint test;\n\tbool valid = m_imageInfoRecord.isRequest;\n\tQMap<int, ImageLoadRequest> req = m_imageInfoRecord.RequestProps;\n\tm_imageInfoRecord.RequestProps = req;\n\tm_imageInfoRecord.isRequest = valid;\n\tm_imageInfoRecord.type = ImageTypeTIF;\n\tgetLayers(fn, page);\n\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn false;\n\n\tbool isCMYK = false;\n\tunsigned int widtht, heightt, size;\n\tchar *description=nullptr, *copyright=nullptr, *datetime=nullptr, *artist=nullptr, *scannerMake=nullptr, *scannerModel=nullptr;\n\tuint16 bitspersample, fillorder, planar;\n\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &widtht);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &heightt);\n\tTIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres);\n\tTIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres);\n\tTIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT , &resolutionunit);\n\tsize = widtht * heightt;\n\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &m_photometric);\n\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planar);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &m_samplesperpixel);\n\tTIFFGetField(tif, TIFFTAG_FILLORDER, &fillorder);\n\n\tTIFFGetField(tif, TIFFTAG_MAKE, &scannerMake);\n\tTIFFGetField(tif, TIFFTAG_MODEL, &scannerModel);\n\tTIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &description);\n\tTIFFGetField(tif, TIFFTAG_COPYRIGHT, &copyright);\n\tTIFFGetField(tif, TIFFTAG_DATETIME, &datetime);\n\tTIFFGetField(tif, TIFFTAG_ARTIST, &artist);\n\tm_imageInfoRecord.exifInfo.cameraName = QString(scannerModel);\n\tm_imageInfoRecord.exifInfo.cameraVendor = QString(scannerMake);\n\tm_imageInfoRecord.exifInfo.comment = QString(description);\n\tm_imageInfoRecord.exifInfo.userComment = QString(copyright);\n\tm_imageInfoRecord.exifInfo.width = widtht;\n\tm_imageInfoRecord.exifInfo.height = heightt;\n\tm_imageInfoRecord.exifInfo.dateTime = QString(datetime);\n\tm_imageInfoRecord.exifInfo.artist = QString(artist);\n\tm_imageInfoRecord.exifInfo.thumbnail = QImage();\n\tm_imageInfoRecord.exifDataValid = true;\n\tuint32 EmbedLen = 0;\n\tvoid*  EmbedBuffer;\n\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer))\n\t{\n\t\tQByteArray profArray((const char*) EmbedBuffer, EmbedLen);\n\t\tScColorProfile tiffProf = engine.openProfileFromMem(profArray);\n\t\tm_embeddedProfile = profArray;\n\t\tm_imageInfoRecord.profileName = tiffProf.productDescription();\n\t\tm_imageInfoRecord.isEmbedded = true;\n\t}\n\telse\n\t{\n\t\tm_imageInfoRecord.isEmbedded = false;\n\t\tm_imageInfoRecord.profileName = \"\";\n\t}\n\tunsigned int PhotoshopLen = 0;\n\tunsigned char* PhotoshopBuffer;\n\tif (TIFFGetField(tif, TIFFTAG_PHOTOSHOP, &PhotoshopLen, &PhotoshopBuffer) )\n\t{\n\t\tif (PhotoshopLen != 0)\n\t\t{\n\t\t\tQByteArray arrayPhot = QByteArray((const char*)PhotoshopBuffer,PhotoshopLen);\n\t\t\tQDataStream strPhot(&arrayPhot,QIODevice::ReadOnly);\n\t\t\tstrPhot.setByteOrder( QDataStream::BigEndian );\n\t\t\tPSDHeader fakeHeader;\n\t\t\tfakeHeader.width = widtht;\n\t\t\tfakeHeader.height = heightt;\n\t\t\tparseRessourceData(strPhot, fakeHeader, PhotoshopLen);\n\t\t\tm_imageInfoRecord.exifInfo.width = widtht;\n\t\t\tm_imageInfoRecord.exifInfo.height = heightt;\n\t\t\tif (!m_imageInfoRecord.valid)\n\t\t\t\tm_imageInfoRecord.valid = (m_imageInfoRecord.PDSpathData.size())>0;\n\t\t\tif (thumbnail)\n\t\t\t{\n\t\t\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t\t{\n\t\t\t\t\tisCMYK = true;\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\t\t\t}\n\t\t\t\telse if (m_samplesperpixel == 1)\n\t\t\t\t{\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t\t\t\t\tisCMYK = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\t\t\tif (bitspersample == 1)\n\t\t\t\t\tbilevel = true;\n\t\t\t\tif (!m_imageInfoRecord.exifInfo.thumbnail.isNull())\n\t\t\t\t{\n\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t{\n\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 5);\n\t\t\t\t\t\tm_pixelFormat = Format_CMYKA_8;;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 4);\n\t\t\t\t\t\tm_pixelFormat = (m_imageInfoRecord.colorspace == ColorSpaceCMYK) ? Format_CMYK_8 : Format_RGBA_8;\n\t\t\t\t\t}\n\t\t\t\t\tr_image.fill(0);\n\t\t\t\t\tQRgb *s;\n\t\t\t\t\tuchar *d;\n\t\t\t\t\tunsigned char cc, cm, cy, ck;\n\t\t\t\t\tfor (int yit=0; yit < m_imageInfoRecord.exifInfo.thumbnail.height(); ++yit)\n\t\t\t\t\t{\n\t\t\t\t\t\ts = (QRgb*)(m_imageInfoRecord.exifInfo.thumbnail.scanLine( yit ));\n\t\t\t\t\t\td = r_image.scanLine( yit );\n\t\t\t\t\t\tfor (int xit=0; xit < m_imageInfoRecord.exifInfo.thumbnail.width(); ++xit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcc = 255 - qRed(*s);\n\t\t\t\t\t\t\t\tcm = 255 - qGreen(*s);\n\t\t\t\t\t\t\t\tcy = 255 - qBlue(*s);\n\t\t\t\t\t\t\t\tck = qMin(qMin(cc, cm), cy);\n\t\t\t\t\t\t\t\td[0] = cc-ck;\n\t\t\t\t\t\t\t\td[1] = cm-ck;\n\t\t\t\t\t\t\t\td[2] = cy-ck;\n\t\t\t\t\t\t\t\td[3] = ck;\n\t\t\t\t\t\t\t\td[4] = 255;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\td[0] = qRed(*s);\n\t\t\t\t\t\t\t\td[1] = qGreen(*s);\n\t\t\t\t\t\t\t\td[2] = qBlue(*s);\n\t\t\t\t\t\t\t\td[3] = 255;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\td += r_image.channels();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tunsigned int PhotoshopLen2 = 0;\n\tunsigned char* PhotoshopBuffer2;\n\tint gotField = TIFFGetField(tif, 37724, &PhotoshopLen2, &PhotoshopBuffer2);\n\tif (gotField && (PhotoshopLen2 > 40))\n\t{\n\t\tm_imageInfoRecord.layerInfo.clear();\n\t\tQByteArray arrayPhot = QByteArray::fromRawData((const char*)PhotoshopBuffer2, PhotoshopLen2);\n\t\tQDataStream s(&arrayPhot,QIODevice::ReadOnly);\n\t\tif (byteOrder[0] == 'M')\n\t\t\ts.setByteOrder( QDataStream::BigEndian );\n\t\telse\n\t\t\ts.setByteOrder( QDataStream::LittleEndian );\n\n\t\tfailedPS = !loadLayerInfo(s, m_imageInfoRecord.layerInfo); \n\t\tif (!failedPS)\n\t\t{\n\t\t\tint chans = 4;\n\t\t\tint numChannels = m_imageInfoRecord.layerInfo.last().channelType.count();\n\t\t\tint numLayers = m_imageInfoRecord.layerInfo.count();\n\t\t\tPSDHeader fakeHeader;\n\t\t\tfakeHeader.width = widtht;\n\t\t\tfakeHeader.height = heightt;\n\t\t\tfakeHeader.channel_count = numChannels;\n\t\t\tfakeHeader.depth = 8;\n\t\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t{\n\t\t\t\tisCMYK = true;\n\t\t\t\tfakeHeader.color_mode = CM_CMYK;\n\t\t\t\tchans = 5;\n\t\t\t}\n\t\t\telse if (m_samplesperpixel == 1)\n\t\t\t{\n\t\t\t\tfakeHeader.color_mode = CM_GRAYSCALE;\n\t\t\t\tisCMYK = false;\n\t\t\t\tchans = 4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfakeHeader.color_mode = CM_RGB;\n\t\t\t\tisCMYK = false;\n\t\t\t\tchans = 4;\n\t\t\t}\n\t\t\tif (!r_image.create(widtht, heightt, chans))\n\t\t\t\treturn false;\n\t\t\tr_image.fill(0);\n\t\t\tbool firstLayer = true;\n\t\t\tfor (int layer = 0; layer < numLayers; layer++)\n\t\t\t{\n\t\t\t\tloadLayerChannels( s, fakeHeader, m_imageInfoRecord.layerInfo, layer, &firstLayer );\n\t\t\t}\n\t\t\tarrayPhot.clear();\n\t\t\tTIFFClose(tif);\n\t\t\tfoundPS = true;\n\t\t\tif (m_imageInfoRecord.layerInfo.count() == 1)\n\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarrayPhot.clear();\n\t\t\tgetLayers(fn, page);\n\t\t}\n\t}\n\n\tif (xres <= 1.0 || yres <= 1.0)\n\t{\n\t\txres = yres = 72.0;\n\t\tQFileInfo qfi(fn);\n\t\tm_message = QObject::tr(\"%1 may be corrupted : missing resolution tags\").arg(qfi.fileName());\n\t\tm_msgType = warningMsg;\n\t}\n\tif ((!foundPS) || (failedPS))\n\t{\n\t\tint chans = 4;\n\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t{\n\t\t\tif (m_samplesperpixel > 5) \n\t\t\t\tchans = 4;\n\t\t\telse\n\t\t\t\tchans = m_samplesperpixel;\n\t\t}\n\t\telse\n\t\t\tchans = 4;\n\t\tif (!r_image.create(widtht, heightt, chans))\n\t\t{\n\t\t\tTIFFClose(tif);\n\t\t\treturn false;\n\t\t}\n\t\tr_image.fill(0);\n\t\tint layerNum = 0;\n\t\tdo\n\t\t{\n\t\t\tRawImage tmpImg;\n\t\t\tif (!tmpImg.create(widtht, heightt, chans))\n\t\t\t{\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttmpImg.fill(0);\n\t\t\tif (!getImageData(tif, &tmpImg, widtht, heightt, size, m_photometric, bitspersample, m_samplesperpixel, bilevel, isCMYK))\n\t\t\t{\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbool visible = true;\n\t\t\tbool useMask = true;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tvisible = m_imageInfoRecord.RequestProps[layerNum].visible;\n\t\t\tQString layBlend(\"norm\");\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tlayBlend = m_imageInfoRecord.RequestProps[layerNum].blend;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tuseMask = m_imageInfoRecord.RequestProps[layerNum].useMask;\n\t\t\tint layOpa = 255;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tlayOpa = m_imageInfoRecord.RequestProps[layerNum].opacity;\n\t\t\tif (visible)\n\t\t\t{\n\t\t\t\tif ((layerNum == 0) && (layBlend != \"diss\"))\n\t\t\t\t\tr_image = tmpImg;\n\t\t\t\telse\n\t\t\t\t\tblendOntoTarget(&tmpImg, layOpa, layBlend, isCMYK, useMask);\n\t\t\t}\n\t\t\t//JG Copy should not be necessary as QImage is implicitly shared in Qt4\n\t\t\tQImage imt; //QImage imt = tmpImg.copy();\n\t\t\tdouble sx = tmpImg.width() / 40.0;\n\t\t\tdouble sy = tmpImg.height() / 40.0;\n\t\t\timt = tmpImg.convertToQImage(chans > 4);\n\t\t\timt = sy < sx ?\timt.scaled(qRound(imt.width() / sx), qRound(imt.height() / sx), Qt::IgnoreAspectRatio, Qt::SmoothTransformation) :\n\t\t\t\t\t\t\t\t\t\timt.scaled(qRound(imt.width() / sy), qRound(imt.height() / sy), Qt::IgnoreAspectRatio, Qt::SmoothTransformation);\n\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb = imt.copy();\n\t\t\tif (chans > 4)\n\t\t\t{\n\t\t\t\tQImage imt2 = imt.createAlphaMask();\n\t\t\t\timt2.invertPixels();\n\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = imt2.copy();\n\t\t\t}\n\t\t\telse\n\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = QImage();\n\t\t\tlayerNum++;\n\n\t\t\tif ((m_imageInfoRecord.layerInfo.count() == 1) && (chans < 5))\n\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t\ttest = TIFFReadDirectory(tif);\n\n\t\t\t// #10415 : check that image size for the current directory is the same as the main one\n\t\t\t// Some progs use tiff directory to store previews, we do not handle such case\n\t\t\t// and may perform reads in non allocated blocks if we continue\n\t\t\twhile (test == 1)\n\t\t\t{\n\t\t\t\tunsigned int dirWidth(0), dirHeight(0);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &dirWidth);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &dirHeight);\n\t\t\t\tif (dirWidth == widtht && dirHeight == heightt)\n\t\t\t\t\tbreak;\n\t\t\t\ttest = TIFFReadDirectory(tif);\n\t\t\t\tlayerNum++;\n\t\t\t}\n\t\t}\n\t\twhile (test == 1);\n\t\tTIFFClose(tif);\n\t}\n\tif (resolutionunit == RESUNIT_INCH)\n\t{\n\t\tm_image.setDotsPerMeterX ((int) (xres / 0.0254));\n\t\tm_image.setDotsPerMeterY ((int) (yres / 0.0254));\n\t\tm_imageInfoRecord.xres = qRound(xres);\n\t\tm_imageInfoRecord.yres = qRound(yres);\n\t}\n\telse if (resolutionunit == RESUNIT_CENTIMETER)\n\t{\n\t\tm_image.setDotsPerMeterX ((int) (xres * 100.0));\n\t\tm_image.setDotsPerMeterY ((int) (yres * 100.0));\n\t\tm_imageInfoRecord.xres = qRound(xres*2.54);\n\t\tm_imageInfoRecord.yres = qRound(yres*2.54);\n\t}\n\tif (isCMYK)\n\t{\n\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\tm_pixelFormat = (r_image.channels() == 5) ? Format_CMYKA_8 : Format_CMYK_8;\n\t}\n\telse if (m_samplesperpixel == 1)\n\t{\n\t\t// Do not set m_pixelFormat here as the real pixel format is most probably different than gray\n\t\tif (bitspersample == 1)\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceMonochrome;\n\t\telse\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t}\n\telse\n\t{\n\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\tm_pixelFormat = Format_RGBA_8;\n\t}\n\tm_imageInfoRecord.BBoxX = 0;\n\tm_imageInfoRecord.BBoxH = r_image.height();\n\tif ((m_imageInfoRecord.layerInfo.isEmpty()) && (m_imageInfoRecord.PDSpathData.isEmpty()))\n\t\tm_imageInfoRecord.valid = false;\n\telse\n\t\tm_imageInfoRecord.valid = true;\n\treturn true;\n}",
    "int test_read_tiff()\n{\n\t// reference: http://research.cs.wisc.edu/graphics/Courses/638-f1999/libtiff_tutorial.htm\n#ifdef _MSC_VER\n\tconst std::string image_name { \"E:/GitCode/OCR_Test/test_data/eurotext.tif\" };\n#else\n\tconst std::string image_name { \"test_data/eurotext.tif\" };\n#endif\n\tTIFF* tif = TIFFOpen(image_name.c_str(), \"r\");\n\tint width{ 0 }, height{ 0 };\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\tfprintf(stdout, \"width: %d, height: %d\\n\", width, height);\n\n\tTIFFClose(tif);\n\n\t// Note: liblept library read tiff file will crash: Error in findTiffCompression: tif not opened\n\t//PIX* pixs = pixRead(image_name.c_str());\n\t//if (pixs == nullptr) {\n\t//\tfprintf(stderr, \"read image error\\n\");\n\t//\treturn -1;\n\t//}\n\n\treturn 0;\n}",
    "bool Image::initWithTiffData(const unsigned char * data, ssize_t dataLen)\n{\n    bool bRet = false;\n    do \n    {\n        // set the read call back function\n        tImageSource imageSource;\n        imageSource.data    = data;\n        imageSource.size    = dataLen;\n        imageSource.offset  = 0;\n\n        TIFF* tif = TIFFClientOpen(\"file.tif\", \"r\", (thandle_t)&imageSource, \n            tiffReadProc, tiffWriteProc,\n            tiffSeekProc, tiffCloseProc, tiffSizeProc,\n            tiffMapProc,\n            tiffUnmapProc);\n\n        CC_BREAK_IF(nullptr == tif);\n\n        uint32 w = 0, h = 0;\n        uint16 bitsPerSample = 0, samplePerPixel = 0, planarConfig = 0;\n        size_t npixels = 0;\n        \n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplePerPixel);\n        TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planarConfig);\n\n        npixels = w * h;\n        \n        _renderFormat = Texture2D::PixelFormat::RGBA8888;\n        _width = w;\n        _height = h;\n\n        _dataLen = npixels * sizeof (uint32);\n        _data = static_cast<unsigned char*>(malloc(_dataLen * sizeof(unsigned char)));\n\n        uint32* raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n        if (raster != nullptr) \n        {\n           if (TIFFReadRGBAImageOriented(tif, w, h, raster, ORIENTATION_TOPLEFT, 0))\n           {\n                /* the raster data is pre-multiplied by the alpha component \n                   after invoking TIFFReadRGBAImageOriented*/\n                _preMulti = true;\n\n               memcpy(_data, raster, npixels*sizeof (uint32));\n           }\n\n          _TIFFfree(raster);\n        }\n        \n\n        TIFFClose(tif);\n\n        bRet = true;\n    } while (0);\n    return bRet;\n}",
    "l_int32 OpenclDevice::getTiffStreamResolutionCl(TIFF     *tif,\n                        l_int32  *pxres,\n                        l_int32  *pyres)\n{\nl_uint16   resunit;\nl_int32    foundxres, foundyres;\nl_float32  fxres, fyres;\n\n    PROCNAME(\"getTiffStreamResolution\");\n\n    if (!tif)\n        return ERROR_INT(\"tif not opened\", procName, 1);\n    if (!pxres || !pyres)\n        return ERROR_INT(\"&xres and &yres not both defined\", procName, 1);\n    *pxres = *pyres = 0;\n\n    TIFFGetFieldDefaulted(tif, TIFFTAG_RESOLUTIONUNIT, &resunit);\n    foundxres = TIFFGetField(tif, TIFFTAG_XRESOLUTION, &fxres);\n    foundyres = TIFFGetField(tif, TIFFTAG_YRESOLUTION, &fyres);\n    if (!foundxres && !foundyres) return 1;\n    if (!foundxres && foundyres)\n        fxres = fyres;\n    else if (foundxres && !foundyres)\n        fyres = fxres;\n\n    if (resunit == RESUNIT_CENTIMETER) {  /* convert to ppi */\n        *pxres = (l_int32)(2.54 * fxres + 0.5);\n        *pyres = (l_int32)(2.54 * fyres + 0.5);\n    }\n    else {\n        *pxres = (l_int32)fxres;\n        *pyres = (l_int32)fyres;\n    }\n\n    return 0;\n}",
    "PIX *\nOpenclDevice::pixReadFromTiffStreamCl(TIFF  *tif)\n{\nl_uint8   *linebuf, *data;\nl_uint16   spp, bps, bpp, tiffbpl, photometry, tiffcomp, orientation;\nl_uint16  *redmap, *greenmap, *bluemap;\nl_int32    d, wpl, bpl, comptype, i, ncolors;\nl_int32    xres, yres;\nl_uint32   w, h;\nl_uint32  *line, *tiffdata;\nPIX       *pix;\nPIXCMAP   *cmap;\n\n    PROCNAME(\"pixReadFromTiffStream\");\n\n    if (!tif)\n        return (PIX *)ERROR_PTR(\"tif not defined\", procName, NULL);\n\n\n    TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    bpp = bps * spp;\n    if (bpp > 32)\n        return (PIX *)ERROR_PTR(\"can't handle bpp > 32\", procName, NULL);\n    if (spp == 1)\n        d = bps;\n    else if (spp == 3 || spp == 4)\n        d = 32;\n    else\n        return (PIX *)ERROR_PTR(\"spp not in set {1,3,4}\", procName, NULL);\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n    tiffbpl = TIFFScanlineSize(tif);\n\n    if ((pix = pixCreate(w, h, d)) == NULL)\n        return (PIX *)ERROR_PTR(\"pix not made\", procName, NULL);\n    data = (l_uint8 *)pixGetData(pix);\n    wpl = pixGetWpl(pix);\n    bpl = 4 * wpl;\n\n\n    if (spp == 1) {\n        if ((linebuf = (l_uint8 *)CALLOC(tiffbpl + 1, sizeof(l_uint8))) == NULL)\n            return (PIX *)ERROR_PTR(\"calloc fail for linebuf\", procName, NULL);\n\n        for (i = 0 ; i < h ; i++) {\n            if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {\n                FREE(linebuf);\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);\n            }\n            memcpy((char *)data, (char *)linebuf, tiffbpl);\n            data += bpl;\n        }\n        if (bps <= 8)\n            pixEndianByteSwap(pix);\n        else\n            pixEndianTwoByteSwap(pix);\n        FREE(linebuf);\n    }\n    else {\n        if ((tiffdata = (l_uint32 *)CALLOC(w * h, sizeof(l_uint32))) == NULL) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"calloc fail for tiffdata\", procName, NULL);\n        }\n        if (!TIFFReadRGBAImageOriented(tif, w, h, (uint32 *)tiffdata,\n                                       ORIENTATION_TOPLEFT, 0)) {\n            FREE(tiffdata);\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"failed to read tiffdata\", procName, NULL);\n        }\n        line = pixGetData(pix);\n\n        //Invoke the OpenCL kernel for pixReadFromTiff\n        l_uint32* output_gpu=pixReadFromTiffKernel(tiffdata,w,h,wpl,line);\n\n        pixSetData(pix, output_gpu);\n        // pix already has data allocated, it now points to output_gpu?\n        FREE(tiffdata);\n        FREE(line);\n        //FREE(output_gpu);\n    }\n\n    if (getTiffStreamResolutionCl(tif, &xres, &yres) == 0) {\n        pixSetXRes(pix, xres);\n        pixSetYRes(pix, yres);\n    }\n\n\n    TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);\n    comptype = getTiffCompressedFormat(tiffcomp);\n    pixSetInputFormat(pix, comptype);\n\n    if (TIFFGetField(tif, TIFFTAG_COLORMAP, &redmap, &greenmap, &bluemap)) {\n\n        if ((cmap = pixcmapCreate(bps)) == NULL) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"cmap not made\", procName, NULL);\n        }\n        ncolors = 1 << bps;\n        for (i = 0; i < ncolors; i++)\n            pixcmapAddColor(cmap, redmap[i] >> 8, greenmap[i] >> 8,\n                            bluemap[i] >> 8);\n        pixSetColormap(pix, cmap);\n    }\n    else {\n        if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometry)) {\n\n            if (tiffcomp == COMPRESSION_CCITTFAX3 ||\n                tiffcomp == COMPRESSION_CCITTFAX4 ||\n                tiffcomp == COMPRESSION_CCITTRLE ||\n                tiffcomp == COMPRESSION_CCITTRLEW) {\n                photometry = PHOTOMETRIC_MINISWHITE;\n            }\n            else\n                photometry = PHOTOMETRIC_MINISBLACK;\n        }\n        if ((d == 1 && photometry == PHOTOMETRIC_MINISBLACK) ||\n            (d == 8 && photometry == PHOTOMETRIC_MINISWHITE))\n            pixInvert(pix, pix);\n    }\n\n    if (TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation)) {\n        if (orientation >= 1 && orientation <= 8) {\n            struct tiff_transform *transform =\n              &tiff_orientation_transforms[orientation - 1];\n            if (transform->vflip) pixFlipTB(pix, pix);\n            if (transform->hflip) pixFlipLR(pix, pix);\n            if (transform->rotate) {\n                PIX *oldpix = pix;\n                pix = pixRotate90(oldpix, transform->rotate);\n                pixDestroy(&oldpix);\n           }\n        }\n    }\n\n    return pix;\n}",
    "RGBImage readTIFFImage(const char* imageName,IO::File& source)\n\t{\n\t/* Check if the source file is seekable: */\n\tIO::SeekableFilePtr seekableSource(&source);\n\tif(seekableSource==0)\n\t\t{\n\t\t/* Create a seekable filter for the source file: */\n\t\tseekableSource=new IO::SeekableFilter(&source);\n\t\t}\n\t\n\t/* Set the TIFF error handler: */\n\tTIFFSetErrorHandler(tiffErrorFunction);\n\tTIFFSetWarningHandler(tiffWarningFunction);\n\t\n\tTIFF* tiff=0;\n\tRGBImage result;\n\tuint32* rgbaBuffer=0;\n\ttry\n\t\t{\n\t\t/* Pretend to open the TIFF file and register the hook functions: */\n\t\ttiff=TIFFClientOpen(imageName,\"rm\",seekableSource.getPointer(),tiffReadFunction,tiffWriteFunction,tiffSeekFunction,tiffCloseFunction,tiffSizeFunction,tiffMapFileFunction,tiffUnmapFileFunction);\n\t\tif(tiff==0)\n\t\t\tthrow std::runtime_error(\"Error while opening image\");\n\t\t\n\t\t/* Get the image size: */\n\t\tuint32 width,height;\n\t\tTIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width);\n\t\tTIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height);\n\t\t\n\t\t/* Create the result image: */\n\t\tresult=RGBImage(width,height);\n\t\t\n\t\t/* Allocate a temporary RGBA buffer: */\n\t\trgbaBuffer=new uint32[height*width];\n\t\t\n\t\t/* Read the TIFF image into the temporary buffer: */\n\t\tif(!TIFFReadRGBAImage(tiff,width,height,rgbaBuffer))\n\t\t\tthrow std::runtime_error(\"Error while reading image\");\n\t\t\n\t\t/* Copy the RGB image data into the result image: */\n\t\tuint32* sPtr=rgbaBuffer;\n\t\tRGBImage::Color* dPtr=result.modifyPixels();\n\t\tfor(uint32 y=0;y<height;++y)\n\t\t\tfor(uint32 x=0;x<width;++x,++sPtr,++dPtr)\n\t\t\t\t{\n\t\t\t\t(*dPtr)[0]=RGBImage::Scalar(TIFFGetR(*sPtr));\n\t\t\t\t(*dPtr)[1]=RGBImage::Scalar(TIFFGetG(*sPtr));\n\t\t\t\t(*dPtr)[2]=RGBImage::Scalar(TIFFGetB(*sPtr));\n\t\t\t\t}\n\t\t}\n\tcatch(std::runtime_error err)\n\t\t{\n\t\t/* Clean up: */\n\t\tdelete[] rgbaBuffer;\n\t\tif(tiff!=0)\n\t\t\tTIFFClose(tiff);\n\t\t\n\t\t/* Wrap and re-throw the exception: */\n\t\tMisc::throwStdErr(\"Images::readTIFFImage: Caught exception \\\"%s\\\" while reading image \\\"%s\\\"\",err.what(),imageName);\n\t\t}\n\t\n\t/* Clean up and return the result image: */\n\tdelete[] rgbaBuffer;\n\tif(tiff!=0)\n\t\tTIFFClose(tiff);\n\treturn result;\n\t}",
    "RGBAImage readTransparentTIFFImage(const char* imageName,IO::File& source)\n\t{\n\t/* Check if the source file is seekable: */\n\tIO::SeekableFilePtr seekableSource(&source);\n\tif(seekableSource==0)\n\t\t{\n\t\t/* Create a seekable filter for the source file: */\n\t\tseekableSource=new IO::SeekableFilter(&source);\n\t\t}\n\t\n\t/* Set the TIFF error handler: */\n\tTIFFSetErrorHandler(tiffErrorFunction);\n\t\n\tTIFF* tiff=0;\n\tRGBAImage result;\n\tuint32* rgbaBuffer=0;\n\ttry\n\t\t{\n\t\t/* Pretend to open the TIFF file and register the hook functions: */\n\t\ttiff=TIFFClientOpen(imageName,\"rm\",seekableSource.getPointer(),tiffReadFunction,tiffWriteFunction,tiffSeekFunction,tiffCloseFunction,tiffSizeFunction,tiffMapFileFunction,tiffUnmapFileFunction);\n\t\tif(tiff==0)\n\t\t\tthrow std::runtime_error(\"Error while opening image\");\n\t\t\n\t\t/* Get the image size: */\n\t\tuint32 width,height;\n\t\tTIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width);\n\t\tTIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height);\n\t\t\n\t\t/* Create the result image: */\n\t\tresult=RGBAImage(width,height);\n\t\t\n\t\t/* Allocate a temporary RGBA buffer: */\n\t\trgbaBuffer=new uint32[height*width];\n\t\t\n\t\t/* Read the TIFF image into the temporary buffer: */\n\t\tif(!TIFFReadRGBAImage(tiff,width,height,rgbaBuffer))\n\t\t\tthrow std::runtime_error(\"Error while reading image\");\n\t\t\n\t\t/* Copy the RGBA image data into the result image: */\n\t\tuint32* sPtr=rgbaBuffer;\n\t\tRGBAImage::Color* dPtr=result.modifyPixels();\n\t\tfor(uint32 y=0;y<height;++y)\n\t\t\tfor(uint32 x=0;x<width;++x,++sPtr,++dPtr)\n\t\t\t\t{\n\t\t\t\t(*dPtr)[0]=RGBImage::Scalar(TIFFGetR(*sPtr));\n\t\t\t\t(*dPtr)[1]=RGBImage::Scalar(TIFFGetG(*sPtr));\n\t\t\t\t(*dPtr)[2]=RGBImage::Scalar(TIFFGetB(*sPtr));\n\t\t\t\t(*dPtr)[3]=RGBAImage::Scalar(TIFFGetA(*sPtr));\n\t\t\t\t}\n\t\t}\n\tcatch(std::runtime_error err)\n\t\t{\n\t\t/* Clean up: */\n\t\tdelete[] rgbaBuffer;\n\t\tif(tiff!=0)\n\t\t\tTIFFClose(tiff);\n\t\t\n\t\t/* Wrap and re-throw the exception: */\n\t\tMisc::throwStdErr(\"Images::readTransparentTIFFImage: Caught exception \\\"%s\\\" while reading image \\\"%s\\\"\",err.what(),imageName);\n\t\t}\n\t\n\t/* Clean up and return the result image: */\n\tdelete[] rgbaBuffer;\n\tif(tiff!=0)\n\t\tTIFFClose(tiff);\n\treturn result;\n\t}",
    "BaseImage\nreadStrippedTIFF(\n\tTIFF* tiff,\n\tuint32 width,\n\tuint32 height,\n\tunsigned int numChannels,\n\tunsigned int channelSize,\n\tGLenum format,\n\tGLenum channelType)\n\t{\n\t/* Create the result image: */\n\tBaseImage result(width,height,numChannels,channelSize,format,channelType);\n\tptrdiff_t resultStride=ptrdiff_t(width)*ptrdiff_t(numChannels);\n\t\n\t/* Extract the image's strip layout: */\n\tuint32 rowsPerStrip;\n\tTIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rowsPerStrip);\n\tuint16 planarConfig;\n\tTIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&planarConfig);\n\t\n\t/* Calculate the number of strips per image or image plane: */\n\tuint32 stripsPerPlane=(height+rowsPerStrip-1)/rowsPerStrip;\n\t\n\t/* Create a buffer to hold a strip of image data: */\n\tMisc::SelfDestructArray<ScalarParam> stripBuffer((TIFFStripSize(tiff)+sizeof(ScalarParam)-1)/sizeof(ScalarParam));\n\t\n\t/* Check whether the image is planed: */\n\tif(planarConfig==PLANARCONFIG_SEPARATE)\n\t\t{\n\t\t/* Read image data by channels: */\n\t\tfor(unsigned int channel=0;channel<numChannels;++channel)\n\t\t\t{\n\t\t\tScalarParam* rowPtr=static_cast<ScalarParam*>(result.modifyPixels())+resultStride*ptrdiff_t(height-1);\n\t\t\tuint32 rowStart=0;\n\t\t\tfor(uint32 strip=0;strip<stripsPerPlane;++strip)\n\t\t\t\t{\n\t\t\t\t/* Read the next strip of image data: */\n\t\t\t\tScalarParam* stripPtr=stripBuffer.getArray();\n\t\t\t\tTIFFReadEncodedStrip(tiff,strip,stripPtr,tsize_t(-1));\n\t\t\t\t\n\t\t\t\t/* Copy image data from the strip buffer into the result image: */\n\t\t\t\tuint32 rowEnd=rowStart+rowsPerStrip;\n\t\t\t\tif(rowEnd>height)\n\t\t\t\t\trowEnd=height;\n\t\t\t\tfor(uint32 row=rowStart;row<rowEnd;++row,rowPtr-=resultStride)\n\t\t\t\t\t{\n\t\t\t\t\tScalarParam* pPtr=rowPtr+channel;\n\t\t\t\t\tfor(uint32 x=0;x<width;++x,++stripPtr,pPtr+=numChannels)\n\t\t\t\t\t\t*rowPtr=*stripPtr;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/* Prepare for the next strip: */\n\t\t\t\trowStart=rowEnd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\t/* Read image data by rows: */\n\t\tScalarParam* rowPtr=static_cast<ScalarParam*>(result.modifyPixels())+resultStride*ptrdiff_t(height-1);\n\t\tuint32 rowStart=0;\n\t\tfor(uint32 strip=0;strip<stripsPerPlane;++strip)\n\t\t\t{\n\t\t\t/* Read the next strip of image data: */\n\t\t\tScalarParam* stripPtr=stripBuffer.getArray();\n\t\t\tTIFFReadEncodedStrip(tiff,strip,stripPtr,tsize_t(-1));\n\t\t\t\n\t\t\t/* Copy image data from the strip buffer into the result image: */\n\t\t\tuint32 rowEnd=rowStart+rowsPerStrip;\n\t\t\tif(rowEnd>height)\n\t\t\t\trowEnd=height;\n\t\t\tfor(uint32 row=rowStart;row<rowEnd;++row,rowPtr-=resultStride,stripPtr+=resultStride)\n\t\t\t\t{\n\t\t\t\t/* Copy all channels of all pixels in the current pixel row: */\n\t\t\t\tmemcpy(rowPtr,stripPtr,resultStride*sizeof(ScalarParam));\n\t\t\t\t}\n\t\t\t\n\t\t\t/* Prepare for the next strip: */\n\t\t\trowStart=rowEnd;\n\t\t\t}\n\t\t}\n\t\n\treturn result;\n\t}",
    "BaseImage readGenericTIFFImage(const char* imageName,IO::File& source)\n\t{\n\t/* Check if the source file is seekable: */\n\tIO::SeekableFilePtr seekableSource(&source);\n\tif(seekableSource==0)\n\t\t{\n\t\t/* Create a seekable filter for the source file: */\n\t\tseekableSource=new IO::SeekableFilter(&source);\n\t\t}\n\t\n\t/* Set the TIFF error handler: */\n\tTIFFSetErrorHandler(tiffErrorFunction);\n\t\n\tTIFF* tiff=0;\n\tBaseImage result;\n\ttry\n\t\t{\n\t\t/* Pretend to open the TIFF file and register the hook functions: */\n\t\ttiff=TIFFClientOpen(imageName,\"rm\",seekableSource.getPointer(),tiffReadFunction,tiffWriteFunction,tiffSeekFunction,tiffCloseFunction,tiffSizeFunction,tiffMapFileFunction,tiffUnmapFileFunction);\n\t\tif(tiff==0)\n\t\t\tthrow std::runtime_error(\"Error while opening image\");\n\t\t\n\t\t/* Extract the image header: */\n\t\tuint32 width,height;\n\t\tTIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width);\n\t\tTIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height);\n\t\tuint16 numBits,numSamples,sampleFormat;\n\t\tTIFFGetField(tiff,TIFFTAG_BITSPERSAMPLE,&numBits);\n\t\tTIFFGetField(tiff,TIFFTAG_SAMPLESPERPIXEL,&numSamples);\n\t\tTIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sampleFormat);\n\t\t\n\t\t/* Determine the result image's pixel format: */\n\t\tunsigned int numChannels=numSamples;\n\t\tGLenum format=GL_RGB;\n\t\tswitch(numChannels)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tformat=GL_LUMINANCE;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase 2:\n\t\t\t\tformat=GL_LUMINANCE_ALPHA;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase 3:\n\t\t\t\tformat=GL_RGB;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase 4:\n\t\t\t\tformat=GL_RGBA;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tdefault:\n\t\t\t\tMisc::throwStdErr(\"Unsupported number %u of channels\",numChannels);\n\t\t\t}\n\t\t\n\t\t/* Check whether the image is tiled or stripped: */\n\t\tif(TIFFIsTiled(tiff))\n\t\t\t{\n\t\t\t/* Can't do this yet: */\n\t\t\tthrow std::runtime_error(\"Tiled images not supported\");\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t/* Determine the result image's pixel type and read the image data: */\n\t\t\tif(numBits==8)\n\t\t\t\t{\n\t\t\t\tswitch(sampleFormat)\n\t\t\t\t\t{\n\t\t\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\t\t\tresult=readStrippedTIFF<Misc::UInt8>(tiff,width,height,numChannels,1,format,GL_UNSIGNED_BYTE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\t\t\tresult=readStrippedTIFF<Misc::SInt8>(tiff,width,height,numChannels,1,format,GL_BYTE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tMisc::throwStdErr(\"Unsupported 8-bit sample format %u\",sampleFormat);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse if(numBits==16)\n\t\t\t\t{\n\t\t\t\tswitch(sampleFormat)\n\t\t\t\t\t{\n\t\t\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\t\t\tresult=readStrippedTIFF<Misc::UInt16>(tiff,width,height,numChannels,2,format,GL_UNSIGNED_SHORT);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\t\t\tresult=readStrippedTIFF<Misc::SInt16>(tiff,width,height,numChannels,2,format,GL_SHORT);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tMisc::throwStdErr(\"Unsupported 16-bit sample format %u\",sampleFormat);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse if(numBits==32)\n\t\t\t\t{\n\t\t\t\tswitch(sampleFormat)\n\t\t\t\t\t{\n\t\t\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\t\t\tresult=readStrippedTIFF<Misc::UInt32>(tiff,width,height,numChannels,4,format,GL_UNSIGNED_INT);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\t\t\tresult=readStrippedTIFF<Misc::SInt32>(tiff,width,height,numChannels,4,format,GL_INT);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\t\t\tresult=readStrippedTIFF<Misc::Float32>(tiff,width,height,numChannels,4,format,GL_FLOAT);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tMisc::throwStdErr(\"Unsupported 32-bit sample format %u\",sampleFormat);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tMisc::throwStdErr(\"Unsupported channel bit size %u\",numBits);\n\t\t\t}\n\t\t}\n\tcatch(std::runtime_error err)\n\t\t{\n\t\t/* Clean up: */\n\t\tif(tiff!=0)\n\t\t\tTIFFClose(tiff);\n\t\t\n\t\t/* Wrap and re-throw the exception: */\n\t\tMisc::throwStdErr(\"Images::readGenericTIFFImage: Caught exception \\\"%s\\\" while reading image \\\"%s\\\"\",err.what(),imageName);\n\t\t}\n\t\n\t/* Clean up and return the result image: */\n\tif(tiff!=0)\n\t\tTIFFClose(tiff);\n\treturn result;\n\t}",
    "void getTiffFileSize(const char* imageFileName,unsigned int& width,unsigned int& height)\n\t{\n\t/* Set the TIFF error handler: */\n\tTIFFSetErrorHandler(tiffErrorFunction);\n\tTIFFSetWarningHandler(tiffWarningFunction);\n\t\n\t/* Open the TIFF image: */\n\tTIFF* image=TIFFOpen(imageFileName,\"r\");\n\tif(image==0)\n\t\tMisc::throwStdErr(\"Images::getTiffFileSize: Unable to open image file %s\",imageFileName);\n\t\n\t/* Get the image size: */\n\tuint32 tiffWidth,tiffHeight;\n\tTIFFGetField(image,TIFFTAG_IMAGEWIDTH,&tiffWidth);\n\tTIFFGetField(image,TIFFTAG_IMAGELENGTH,&tiffHeight);\n\twidth=tiffWidth;\n\theight=tiffHeight;\n\t}",
    "bool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif);\n    if (!m_tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n    }\n\n    if( tif )\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            uint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if((bpp == 32 && ncn == 3) || photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 1:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    result = true;\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    result = true;\n                    break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}",
    "bool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = TIFFOpen( m_filename.c_str(), \"r\" );\n\n    if( tif )\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            uint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if((bpp == 32 && ncn == 3) || photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric != 2 && photometric != 1) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? wanted_channels : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? wanted_channels : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    if(m_hdr && img.type() == CV_32FC3)\n    {\n        return readHdrData(img);\n    }\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.ptr();\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 )\n                tile_height0 = m_height;\n\n            AutoBuffer<uchar> _buffer( size_t(8) * tile_height0*tile_width0);\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += img.step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R( bstart + i*tile_width0*4, 0,\n                                                             data + x*4 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 4, 0,\n                                                cvSize(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 3, 0,\n                                                cvSize(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    close();\n    return result;\n}",
    "Image load(string filename) {\n        TIFF *tiff = TIFFOpen(filename.c_str(), \"r\");\n\n        assert(tiff, \"Could not open file %s\\n\", filename.c_str());\n\n        // Get basic information from TIFF header\n        int w;\n        assert(TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &w), \n               \"Width not set in TIFF\\n\");\n        int h;\n        assert(TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &h), \n               \"Height not set in tiff\\n\");\n        unsigned short c;\n        assert(TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &c),\n               \"Number of channels not set in tiff\\n\");\n\n        unsigned short bitsPerSample;\n        assert(TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample),\n               \"Bits per sample not set in TIFF\\n\");\n\n        unsigned short sampleFormat;\n        if (!TIFFGetField(tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat)) {\n            //printf(\"WARNING: couldn't find sample format in tiff, assuming %i bit unsigned integers\\n\", bitsPerSample);\n            sampleFormat = SAMPLEFORMAT_UINT;\n        }\n\n        Image im(w, h, 1, c);\n        int bytesPerSample = bitsPerSample / 8;\n\n        assert(im.channels * im.width * bytesPerSample == TIFFScanlineSize(tiff), \n               \"Unsupported scanline format in TIFF file, might be stored in tiles or strips.\\n\");\n\n        if (bytesPerSample == 1 && sampleFormat == SAMPLEFORMAT_UINT) {        \n            readTiff<unsigned char>(im, tiff, 0x000000ff);\n        } else if (bytesPerSample == 1 && sampleFormat == SAMPLEFORMAT_INT) {\n            readTiff<char>(im, tiff, 0x000000ff);\n        } else if (bytesPerSample == 2 && sampleFormat == SAMPLEFORMAT_UINT) {\n            readTiff<unsigned short>(im, tiff, 0x0000ffff);\n        } else if (bytesPerSample == 2 && sampleFormat == SAMPLEFORMAT_INT) {\n            readTiff<short>(im, tiff, 0x0000ffff);\n        #ifndef NO_OPENEXR\n        } else if (bytesPerSample == 2 && sampleFormat == SAMPLEFORMAT_IEEEFP) {\n            readTiff<half>(im, tiff, 1);\n        #endif\n        } else if (bytesPerSample == 4 && sampleFormat == SAMPLEFORMAT_UINT) {\n            readTiff<unsigned int>(im, tiff, 0xffffffff);\n        } else if (bytesPerSample == 4 && sampleFormat == SAMPLEFORMAT_INT) {\n            readTiff<int>(im, tiff, 0xffffffff);\n        } else if (bytesPerSample == 4 && sampleFormat == SAMPLEFORMAT_IEEEFP) {\n            readTiff<float>(im, tiff, 1);\n        } else if (bytesPerSample == 8 && sampleFormat == SAMPLEFORMAT_IEEEFP) {\n            readTiff<double>(im, tiff, 1);\n        } else if (sampleFormat == SAMPLEFORMAT_UINT || sampleFormat == SAMPLEFORMAT_INT) {\n            panic(\"%i bytes per sample for integers unsupported\\n\", bytesPerSample);\n        } else if (sampleFormat == SAMPLEFORMAT_IEEEFP) {\n            panic(\"%i bytes per sample for floats unsupported\\n\", bytesPerSample);\n        } else {\n            panic(\"Sample format unsupported (not int, unsigned int, or float)\\n\");\n        }\n\n        TIFFClose(tiff);\n\n        return im;\n    }",
    "Image load(string filename) {\n    TIFF *tiff = TIFFOpen(filename.c_str(), \"r\");\n\n    assert(tiff, \"Could not open file %s\\n\", filename.c_str());\n\n    // Get basic information from TIFF header\n    int w;\n    assert(TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &w),\n           \"Width not set in TIFF\\n\");\n    int h;\n    assert(TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &h),\n           \"Height not set in tiff\\n\");\n    unsigned short c;\n    assert(TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &c),\n           \"Number of channels not set in tiff\\n\");\n\n    unsigned short bitsPerSample;\n    assert(TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample),\n           \"Bits per sample not set in TIFF\\n\");\n\n    unsigned short sampleFormat;\n    if (!TIFFGetField(tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat)) {\n        //printf(\"WARNING: couldn't find sample format in tiff, assuming %i bit unsigned integers\\n\", bitsPerSample);\n        sampleFormat = SAMPLEFORMAT_UINT;\n    }\n\n    Image im(w, h, 1, c);\n    int bytesPerSample = bitsPerSample / 8;\n\n    assert(im.channels *im.width *bytesPerSample == TIFFScanlineSize(tiff),\n           \"Unsupported scanline format in TIFF file, might be stored in tiles or strips.\\n\");\n\n    if (bytesPerSample == 1 && sampleFormat == SAMPLEFORMAT_UINT) {\n        readTiff<uint8_t>(im, tiff, 0x000000ff);\n    } else if (bytesPerSample == 1 && sampleFormat == SAMPLEFORMAT_INT) {\n        readTiff<int8_t>(im, tiff, 0x000000ff);\n    } else if (bytesPerSample == 2 && sampleFormat == SAMPLEFORMAT_UINT) {\n        readTiff<uint16_t>(im, tiff, 0x0000ffff);\n    } else if (bytesPerSample == 2 && sampleFormat == SAMPLEFORMAT_INT) {\n        readTiff<int16_t>(im, tiff, 0x0000ffff);\n#ifndef NO_OPENEXR\n    } else if (bytesPerSample == 2 && sampleFormat == SAMPLEFORMAT_IEEEFP) {\n        readTiff<half>(im, tiff, 1);\n#endif\n    } else if (bytesPerSample == 4 && sampleFormat == SAMPLEFORMAT_UINT) {\n        readTiff<uint32_t>(im, tiff, 0xffffffff);\n    } else if (bytesPerSample == 4 && sampleFormat == SAMPLEFORMAT_INT) {\n        readTiff<int32_t>(im, tiff, 0xffffffff);\n    } else if (bytesPerSample == 4 && sampleFormat == SAMPLEFORMAT_IEEEFP) {\n        readTiff<float>(im, tiff, 1);\n    } else if (bytesPerSample == 8 && sampleFormat == SAMPLEFORMAT_IEEEFP) {\n        readTiff<double>(im, tiff, 1);\n    } else if (sampleFormat == SAMPLEFORMAT_UINT || sampleFormat == SAMPLEFORMAT_INT) {\n        panic(\"%i bytes per sample for integers unsupported\\n\", bytesPerSample);\n    } else if (sampleFormat == SAMPLEFORMAT_IEEEFP) {\n        panic(\"%i bytes per sample for floats unsupported\\n\", bytesPerSample);\n    } else {\n        panic(\"Sample format unsupported (not int, unsigned int, or float)\\n\");\n    }\n\n    TIFFClose(tiff);\n\n    return im;\n}",
    "void read_tiff_image(TIFF* tif, IMAGE* image) {\n  tdata_t buf;\n  uint32 image_width, image_height;\n  uint16 photometric;\n  inT16 bpp;\n  inT16 samples_per_pixel = 0;\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &image_width);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &image_height);\n  if (!TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n    bpp = 1;  // Binary is default if no value provided.\n  TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel);\n  TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric);\n  if (samples_per_pixel > 1)\n    bpp *= samples_per_pixel;\n  // Tesseract's internal representation is 0-is-black,\n  // so if the photometric is 1 (min is black) then high-valued pixels\n  // are 1 (white), otherwise they are 0 (black).\n  uinT8 high_value = photometric == 1;\n  image->create(image_width, image_height, bpp);\n  IMAGELINE line;\n  line.init(image_width);\n\n  buf = _TIFFmalloc(TIFFScanlineSize(tif));\n  int bytes_per_line = (image_width*bpp + 7)/8;\n  uinT8* dest_buf = image->get_buffer();\n  // This will go badly wrong with one of the more exotic tiff formats,\n  // but the majority will work OK.\n  for (int y = 0; y < image_height; ++y) {\n    TIFFReadScanline(tif, buf, y);\n    memcpy(dest_buf, buf, bytes_per_line);\n    dest_buf += bytes_per_line;\n  }\n  if (high_value == 0)\n    invert_image(image);\n  _TIFFfree(buf);\n}",
    "ImageIO::errorType ImageIO::loadTIFF(const char * filename)\n{\n#ifdef ENABLE_TIFF\n  TIFF * tiff = TIFFOpen(filename, \"r\");\n  if (!tiff)\n    return IO_ERROR;\n\n  // read the dimensions\n  uint32 tiff_width, tiff_height;\n  uint16 tiff_samplesPerPixel;\n  uint16 tiff_bits;\n  TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &tiff_width);\n  TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &tiff_height);\n  TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &tiff_samplesPerPixel);\n  TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &tiff_bits);\n\n  //printf(\"tiff_width: %d tiff_height: %d tiff_samplesPerPixel: %d tiff_bits: %d\\n\", tiff_width, tiff_height, tiff_samplesPerPixel, tiff_bits);\n\n  if ((tiff_samplesPerPixel != IMAGE_IO_RGB) && (tiff_samplesPerPixel != IMAGE_IO_RGB_ALPHA))\n  {\n    printf(\"Error in loadTIFF: Sorry, cannot handle %d-channel images.\\n\", tiff_samplesPerPixel);\n    TIFFClose(tiff);\n    return OTHER_ERROR;\n  }\n\n  if (tiff_bits != BITS_PER_CHANNEL_8)\n  {\n    printf(\"Error in loadTIFF: Sorry, cannot handle %d-bit images.\\n\", tiff_bits);\n    TIFFClose(tiff);\n    return OTHER_ERROR;\n  }\n\n  width = tiff_width;\n  height = tiff_height;\n  bytesPerPixel = tiff_samplesPerPixel;\n\n  uint32 * tiff_pixels = (uint32*) _TIFFmalloc(tiff_width * tiff_height * sizeof(uint32));\n  if (!tiff_pixels)\n  {\n    TIFFClose(tiff);\n    return MEMORY_ERROR;\n  }\n\n  printf(\"Loading TIFF image from file %s: resolution: %d x %d, %d-bit.\\n\", filename, width, height, 8 * bytesPerPixel);\n \n  int stopOnError = 1;\n  if (!TIFFReadRGBAImage(tiff, tiff_width, tiff_height, tiff_pixels, stopOnError))\n  { \n    _TIFFfree(tiff_pixels);\n    TIFFClose(tiff);\n    printf(\"Error in loadTIFF: Unknown error when calling TIFFReadRGBAImage.\\n\");\n    return IO_ERROR;\n  }\n\n  pixels = (unsigned char*) malloc (sizeof(unsigned char) * width * height * bytesPerPixel);\n\n  // write tiff_pixels into the pixels array\n  int counter = 0;\n  for(unsigned int row=0; row < height; row++)\n  {\n    for(unsigned int column=0; column < width; column++)\n    {\n      // read the uint32 pixel\n      uint32 tiff_pixel = tiff_pixels[row * tiff_width + column];\n\n      // write R,G,B,A in place into pixels\n      pixels[counter] = TIFFGetR(tiff_pixel);\n      counter++;\n\n      if (bytesPerPixel < 3) \n        continue;\n\n      pixels[counter] = TIFFGetG(tiff_pixel);\n      counter++;\n      pixels[counter] = TIFFGetB(tiff_pixel);\n      counter++;\n\n      if (bytesPerPixel < 4) \n        continue;\n\n      // alpha channel\n      pixels[counter] = TIFFGetA(tiff_pixel);\n      counter++;\n    }\n  }\n\n  _TIFFfree(tiff_pixels);\n  TIFFClose(tiff);\n\n  return OK;\n\n#else\n  return INVALID_FILE_FORMAT;\n#endif\n}",
    "bool QTiffHandler::read(QImage *image)\n{\n    if (!canRead())\n        return false;\n\n    TIFF *const tiff = TIFFClientOpen(\"foo\",\n                                      \"r\",\n                                      this,\n                                      qtiffReadProc,\n                                      qtiffWriteProc,\n                                      qtiffSeekProc,\n                                      qtiffCloseProc,\n                                      qtiffSizeProc,\n                                      qtiffMapProc,\n                                      qtiffUnmapProc);\n\n    if (!tiff) {\n        return false;\n    }\n    uint32 width;\n    uint32 height;\n    uint16 photometric;\n    if (!TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width)\n        || !TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height)\n        || !TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &photometric)) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    // BitsPerSample defaults to 1 according to the TIFF spec.\n    uint16 bitPerSample;\n    if (!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitPerSample))\n        bitPerSample = 1;\n    uint16 samplesPerPixel; // they may be e.g. grayscale with 2 samples per pixel\n    if (!TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel))\n        samplesPerPixel = 1;\n\n    bool grayscale = photometric == PHOTOMETRIC_MINISBLACK || photometric == PHOTOMETRIC_MINISWHITE;\n    if (grayscale && bitPerSample == 1 && samplesPerPixel == 1) {\n        if (image->size() != QSize(width, height) || image->format() != QImage::Format_Mono)\n            *image = QImage(width, height, QImage::Format_Mono);\n        QVector<QRgb> colortable(2);\n        if (photometric == PHOTOMETRIC_MINISBLACK) {\n            colortable[0] = 0xff000000;\n            colortable[1] = 0xffffffff;\n        } else {\n            colortable[0] = 0xffffffff;\n            colortable[1] = 0xff000000;\n        }\n        image->setColorTable(colortable);\n\n        if (!image->isNull()) {\n            for (uint32 y=0; y<height; ++y) {\n                if (TIFFReadScanline(tiff, image->scanLine(y), y, 0) < 0) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n            }\n        }\n    } else {\n        if ((grayscale || photometric == PHOTOMETRIC_PALETTE) && bitPerSample == 8 && samplesPerPixel == 1) {\n            if (image->size() != QSize(width, height) || image->format() != QImage::Format_Indexed8)\n                *image = QImage(width, height, QImage::Format_Indexed8);\n            if (!image->isNull()) {\n                const uint16 tableSize = 256;\n                QVector<QRgb> qtColorTable(tableSize);\n                if (grayscale) {\n                    for (int i = 0; i<tableSize; ++i) {\n                        const int c = (photometric == PHOTOMETRIC_MINISBLACK) ? i : (255 - i);\n                        qtColorTable[i] = qRgb(c, c, c);\n                    }\n                } else {\n                    // create the color table\n                    uint16 *redTable = 0;\n                    uint16 *greenTable = 0;\n                    uint16 *blueTable = 0;\n                    if (!TIFFGetField(tiff, TIFFTAG_COLORMAP, &redTable, &greenTable, &blueTable)) {\n                        TIFFClose(tiff);\n                        return false;\n                    }\n                    if (!redTable || !greenTable || !blueTable) {\n                        TIFFClose(tiff);\n                        return false;\n                    }\n\n                    for (int i = 0; i<tableSize ;++i) {\n                        const int red = redTable[i] / 257;\n                        const int green = greenTable[i] / 257;\n                        const int blue = blueTable[i] / 257;\n                        qtColorTable[i] = qRgb(red, green, blue);\n                    }\n                }\n\n                image->setColorTable(qtColorTable);\n                for (uint32 y=0; y<height; ++y) {\n                    if (TIFFReadScanline(tiff, image->scanLine(y), y, 0) < 0) {\n                        TIFFClose(tiff);\n                        return false;\n                    }\n                }\n\n                // free redTable, greenTable and greenTable done by libtiff\n            }\n        } else {\n            if (image->size() != QSize(width, height) || image->format() != QImage::Format_ARGB32)\n                *image = QImage(width, height, QImage::Format_ARGB32);\n            if (!image->isNull()) {\n                const int stopOnError = 1;\n                if (TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32 *>(image->bits()), ORIENTATION_TOPLEFT, stopOnError)) {\n                    for (uint32 y=0; y<height; ++y)\n                        convert32BitOrder(image->scanLine(y), width);\n                } else {\n                    TIFFClose(tiff);\n                    return false;\n                }\n            }\n        }\n    }\n\n    if (image->isNull()) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    float resX = 0;\n    float resY = 0;\n    uint16 resUnit;\n    if (!TIFFGetField(tiff, TIFFTAG_RESOLUTIONUNIT, &resUnit))\n        resUnit = RESUNIT_INCH;\n\n    if (TIFFGetField(tiff, TIFFTAG_XRESOLUTION, &resX)\n        && TIFFGetField(tiff, TIFFTAG_YRESOLUTION, &resY)) {\n        switch(resUnit) {\n        case RESUNIT_CENTIMETER:\n            image->setDotsPerMeterX(qRound(resX * 100));\n            image->setDotsPerMeterY(qRound(resY * 100));\n            break;\n        case RESUNIT_INCH:\n            image->setDotsPerMeterX(qRound(resX * (100 / 2.54)));\n            image->setDotsPerMeterY(qRound(resY * (100 / 2.54)));\n            break;\n        default:\n            // do nothing as defaults have already\n            // been set within the QImage class\n            break;\n        }\n    }\n\n    // rotate the image if the orientation is defined in the file\n    uint16 orientationTag;\n    if (TIFFGetField(tiff, TIFFTAG_ORIENTATION, &orientationTag)) {\n        if (image->format() == QImage::Format_ARGB32) {\n            // TIFFReadRGBAImageOriented() flip the image but does not rotate them\n            switch (orientationTag) {\n            case 5:\n                rotate_right_mirror_horizontal(image);\n                break;\n            case 6:\n                rotate_right_mirror_vertical(image);\n                break;\n            case 7:\n                rotate_right_mirror_horizontal(image);\n                break;\n            case 8:\n                rotate_right_mirror_vertical(image);\n                break;\n            }\n        } else {\n            switch (orientationTag) {\n            case 1: // default orientation\n                break;\n            case 2: // mirror horizontal\n                *image = image->mirrored(true, false);\n                break;\n            case 3: // mirror both\n                *image = image->mirrored(true, true);\n                break;\n            case 4: // mirror vertical\n                *image = image->mirrored(false, true);\n                break;\n            case 5: // rotate right mirror horizontal\n                {\n                    QMatrix transformation;\n                    transformation.rotate(90);\n                    *image = image->transformed(transformation);\n                    *image = image->mirrored(true, false);\n                    break;\n                }\n            case 6: // rotate right\n                {\n                    QMatrix transformation;\n                    transformation.rotate(90);\n                    *image = image->transformed(transformation);\n                    break;\n                }\n            case 7: // rotate right, mirror vertical\n                {\n                    QMatrix transformation;\n                    transformation.rotate(90);\n                    *image = image->transformed(transformation);\n                    *image = image->mirrored(false, true);\n                    break;\n                }\n            case 8: // rotate left\n                {\n                    QMatrix transformation;\n                    transformation.rotate(270);\n                    *image = image->transformed(transformation);\n                    break;\n                }\n            }\n        }\n    }\n\n\n    TIFFClose(tiff);\n    return true;\n}",
    "QVariant QTiffHandler::option(ImageOption option) const\n{\n    if (option == Size && canRead()) {\n        QSize imageSize;\n        qint64 pos = device()->pos();\n        TIFF *tiff = TIFFClientOpen(\"foo\",\n                                    \"r\",\n                                    const_cast<QTiffHandler*>(this),\n                                    qtiffReadProc,\n                                    qtiffWriteProc,\n                                    qtiffSeekProc,\n                                    qtiffCloseProc,\n                                    qtiffSizeProc,\n                                    qtiffMapProc,\n                                    qtiffUnmapProc);\n\n        if (tiff) {\n            uint32 width = 0;\n            uint32 height = 0;\n            TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n            TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n            imageSize = QSize(width, height);\n            TIFFClose(tiff);\n        }\n        device()->seek(pos);\n        if (imageSize.isValid())\n            return imageSize;\n    } else if (option == CompressionRatio) {\n        return compression;\n    } else if (option == ImageFormat) {\n        return QImage::Format_ARGB32;\n    }\n    return QVariant();\n}",
    "int main(int argc, char*argv[])\n{\n  if(argc < 2)\n  {\n    std::cerr << \"Required arguments: filename\" << std::endl;\n    return -1;\n  }\n\n  std::string filename = argv[1];\n  \n  TIFF *tif=(TIFF*)0;  /* TIFF-level descriptor */\n  GTIF *gtif=(GTIF*)0; /* GeoKey-level descriptor */\n  int versions[3];\n  int cit_length;\n  geocode_t model;    /* all key-codes are of this type */\n  char *citation;\n\n  /* Open TIFF descriptor to read GeoTIFF tags */\n  tif=XTIFFOpen(filename.c_str(),\"r\");\n  if (!tif) goto failure;\n\n  /* Open GTIF Key parser; keys will be read at this time. */\n  gtif = GTIFNew(tif);\n  if (!gtif) goto failure;\n\n  /* Get the GeoTIFF directory info */\n  GTIFFDirectoryInfo(gtif,versions,0);\n  if (versions[MAJOR] > 1)\n  {\n          printf(\"this file is too new for me\\n\"); goto failure;\n  }\n  if (!GTIFKeyGet(gtif, GTModelTypeGeoKey, &model, 0, 1))\n  {\n          printf(\"Yikes! no Model Type\\n\") goto failure;\n  }\n\n  /* ASCII keys are variable-length; compute size */\n  cit_length = GTIFKeyInfo(gtif,GTCitationGeoKey,&size,&type);\n  if (cit_length > 0)\n  {\n          citation = malloc(size*cit_length);\n          if (!citation) goto failure;\n          GTIFKeyGet(gtif, GTCitationGeoKey, citation, 0, cit_length);\n          printf(\"Citation:%s\\n\",citation);\n  }\n\n  /* Get some TIFF info on this image */\n  TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,    &width);\n\n  /* get rid of the key parser */\n  GTIFFree(gtif);\n\n  /* close the TIFF file descriptor */\n  XTIFFClose(tif);\n\n  exit (0);\nfailure:\n  exit (-1);\n}",
    "bool Tiff_Exif_GetInfo(TIFF* tif_ctx, ttag_t tag, CFX_DIBAttribute* pAttr) {\n  T val = 0;\n  TIFFGetField(tif_ctx, tag, &val);\n  if (!val)\n    return false;\n  T* ptr = FX_Alloc(T, 1);\n  *ptr = val;\n  pAttr->m_Exif[tag] = (void*)ptr;\n  return true;\n}",
    "void Tiff_Exif_GetStringInfo(TIFF* tif_ctx,\n                             ttag_t tag,\n                             CFX_DIBAttribute* pAttr) {\n  FX_CHAR* buf = nullptr;\n  TIFFGetField(tif_ctx, tag, &buf);\n  if (!buf)\n    return;\n  FX_STRSIZE size = FXSYS_strlen(buf);\n  uint8_t* ptr = FX_Alloc(uint8_t, size + 1);\n  FXSYS_memcpy(ptr, buf, size);\n  ptr[size] = 0;\n  pAttr->m_Exif[tag] = ptr;\n}",
    "bool CCodec_TiffContext::LoadFrameInfo(int32_t frame,\n                                       int32_t* width,\n                                       int32_t* height,\n                                       int32_t* comps,\n                                       int32_t* bpc,\n                                       CFX_DIBAttribute* pAttribute) {\n  if (!TIFFSetDirectory(m_tif_ctx, (uint16)frame))\n    return false;\n\n  uint32_t tif_width = 0;\n  uint32_t tif_height = 0;\n  uint16_t tif_comps = 0;\n  uint16_t tif_bpc = 0;\n  uint32_t tif_rps = 0;\n  TIFFGetField(m_tif_ctx, TIFFTAG_IMAGEWIDTH, &tif_width);\n  TIFFGetField(m_tif_ctx, TIFFTAG_IMAGELENGTH, &tif_height);\n  TIFFGetField(m_tif_ctx, TIFFTAG_SAMPLESPERPIXEL, &tif_comps);\n  TIFFGetField(m_tif_ctx, TIFFTAG_BITSPERSAMPLE, &tif_bpc);\n  TIFFGetField(m_tif_ctx, TIFFTAG_ROWSPERSTRIP, &tif_rps);\n\n  if (pAttribute) {\n    pAttribute->m_wDPIUnit = FXCODEC_RESUNIT_INCH;\n    if (TIFFGetField(m_tif_ctx, TIFFTAG_RESOLUTIONUNIT,\n                     &pAttribute->m_wDPIUnit)) {\n      pAttribute->m_wDPIUnit--;\n    }\n    Tiff_Exif_GetInfo<uint16_t>(m_tif_ctx, TIFFTAG_ORIENTATION, pAttribute);\n    if (Tiff_Exif_GetInfo<FX_FLOAT>(m_tif_ctx, TIFFTAG_XRESOLUTION,\n                                    pAttribute)) {\n      void* val = pAttribute->m_Exif[TIFFTAG_XRESOLUTION];\n      FX_FLOAT fDpi = val ? *reinterpret_cast<FX_FLOAT*>(val) : 0;\n      pAttribute->m_nXDPI = (int32_t)(fDpi + 0.5f);\n    }\n    if (Tiff_Exif_GetInfo<FX_FLOAT>(m_tif_ctx, TIFFTAG_YRESOLUTION,\n                                    pAttribute)) {\n      void* val = pAttribute->m_Exif[TIFFTAG_YRESOLUTION];\n      FX_FLOAT fDpi = val ? *reinterpret_cast<FX_FLOAT*>(val) : 0;\n      pAttribute->m_nYDPI = (int32_t)(fDpi + 0.5f);\n    }\n    Tiff_Exif_GetStringInfo(m_tif_ctx, TIFFTAG_IMAGEDESCRIPTION, pAttribute);\n    Tiff_Exif_GetStringInfo(m_tif_ctx, TIFFTAG_MAKE, pAttribute);\n    Tiff_Exif_GetStringInfo(m_tif_ctx, TIFFTAG_MODEL, pAttribute);\n  }\n  *width = pdfium::base::checked_cast<int32_t>(tif_width);\n  *height = pdfium::base::checked_cast<int32_t>(tif_height);\n  *comps = tif_comps;\n  *bpc = tif_bpc;\n  if (tif_rps > tif_height) {\n    tif_rps = tif_height;\n    TIFFSetField(m_tif_ctx, TIFFTAG_ROWSPERSTRIP, tif_rps);\n  }\n  return true;\n}",
    "bool CCodec_TiffContext::IsSupport(const CFX_DIBitmap* pDIBitmap) const {\n  if (TIFFIsTiled(m_tif_ctx))\n    return false;\n\n  uint16_t photometric = 0;\n  if (!TIFFGetField(m_tif_ctx, TIFFTAG_PHOTOMETRIC, &photometric))\n    return false;\n\n  switch (pDIBitmap->GetBPP()) {\n    case 1:\n    case 8:\n      if (photometric != PHOTOMETRIC_PALETTE) {\n        return false;\n      }\n      break;\n    case 24:\n      if (photometric != PHOTOMETRIC_RGB) {\n        return false;\n      }\n      break;\n    default:\n      return false;\n  }\n  uint16_t planarconfig = 0;\n  if (!TIFFGetFieldDefaulted(m_tif_ctx, TIFFTAG_PLANARCONFIG, &planarconfig))\n    return false;\n\n  return planarconfig != PLANARCONFIG_SEPARATE;\n}",
    "void CCodec_TiffContext::SetPalette(CFX_DIBitmap* pDIBitmap, uint16_t bps) {\n  uint16_t* red_orig = nullptr;\n  uint16_t* green_orig = nullptr;\n  uint16_t* blue_orig = nullptr;\n  TIFFGetField(m_tif_ctx, TIFFTAG_COLORMAP, &red_orig, &green_orig, &blue_orig);\n  for (int32_t i = (1L << bps) - 1; i >= 0; i--) {\n#define CVT(x) ((uint16_t)((x) >> 8))\n    red_orig[i] = CVT(red_orig[i]);\n    green_orig[i] = CVT(green_orig[i]);\n    blue_orig[i] = CVT(blue_orig[i]);\n#undef CVT\n  }\n  int32_t len = 1 << bps;\n  for (int32_t index = 0; index < len; index++) {\n    uint32_t r = red_orig[index] & 0xFF;\n    uint32_t g = green_orig[index] & 0xFF;\n    uint32_t b = blue_orig[index] & 0xFF;\n    uint32_t color = (uint32_t)b | ((uint32_t)g << 8) | ((uint32_t)r << 16) |\n                     (((uint32)0xffL) << 24);\n    pDIBitmap->SetPaletteEntry(index, color);\n  }\n}",
    "bool CCodec_TiffContext::Decode(CFX_DIBitmap* pDIBitmap) {\n  uint32_t img_wid = pDIBitmap->GetWidth();\n  uint32_t img_hei = pDIBitmap->GetHeight();\n  uint32_t width = 0;\n  uint32_t height = 0;\n  TIFFGetField(m_tif_ctx, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(m_tif_ctx, TIFFTAG_IMAGELENGTH, &height);\n  if (img_wid != width || img_hei != height)\n    return false;\n\n  if (pDIBitmap->GetBPP() == 32) {\n    uint16_t rotation = ORIENTATION_TOPLEFT;\n    TIFFGetField(m_tif_ctx, TIFFTAG_ORIENTATION, &rotation);\n    if (TIFFReadRGBAImageOriented(m_tif_ctx, img_wid, img_hei,\n                                  (uint32*)pDIBitmap->GetBuffer(), rotation,\n                                  1)) {\n      for (uint32_t row = 0; row < img_hei; row++) {\n        uint8_t* row_buf = (uint8_t*)pDIBitmap->GetScanline(row);\n        TiffBGRA2RGBA(row_buf, img_wid, 4);\n      }\n      return true;\n    }\n  }\n  uint16_t spp = 0;\n  uint16_t bps = 0;\n  TIFFGetField(m_tif_ctx, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetField(m_tif_ctx, TIFFTAG_BITSPERSAMPLE, &bps);\n  uint32_t bpp = bps * spp;\n  if (bpp == 1)\n    return Decode1bppRGB(pDIBitmap, height, width, bps, spp);\n  if (bpp <= 8)\n    return Decode8bppRGB(pDIBitmap, height, width, bps, spp);\n  if (bpp <= 24)\n    return Decode24bppRGB(pDIBitmap, height, width, bps, spp);\n  return false;\n}",
    "MStatus tiffFloatReader::open( MString pathname, MImageFileInfo* info)\n{\n#if defined(_TIFF_LIBRARY_AVAILABLE_)\n\ttry\n\t{\n\t\t// Open the tif file for read\n\t\t// (TIFF *) cast from integer required on Mac.\n\t\tfInputFile = (TIFF *) TIFFOpen( pathname.asChar(), \"r\" );\n\t}\n\tcatch( ... )\n\t{\n\t}\n\n\tif( !fInputFile)\n\t{\n\t\treturn MS::kFailure;\n\t}\n\n\tunsigned short num_samps;\n\tunsigned short bitsPerChannel;\n\tunsigned short sampleType = 0;\n\tshort config;\n\n\tif (_TIFF_SUCCESS != TIFFGetField(fInputFile, TIFFTAG_IMAGEWIDTH, &fWidth ) || \n\t\tfWidth < 1)\n\t\tgoto no_support;\n\tif (_TIFF_SUCCESS != TIFFGetField(fInputFile, TIFFTAG_IMAGELENGTH, &fHeight ) || \n\t\tfHeight < 1)\n\t\tgoto no_support;\n\n\n\t// Suport 3 and 4 channel images only\n\tif (_TIFF_SUCCESS != TIFFGetField(fInputFile, TIFFTAG_SAMPLESPERPIXEL, &num_samps))\n\t\tgoto no_support;\n\tif ((num_samps != 3) && (num_samps!= 4))\n\t\tgoto no_support;\n\tfChannels = num_samps;\n\n\t// This is more robust than TIFFTAG_SAMPLEFORMAT since it may not be supported\n\t// properly as it's an extension. \n\n\tif (_TIFF_SUCCESS != TIFFGetField(fInputFile, TIFFTAG_BITSPERSAMPLE, &bitsPerChannel))\n\t\tgoto no_support;\n\tif (bitsPerChannel != 32)\n\t\tgoto no_support;\n\n\t// Check the sample type. We only care about 32 bit \n\t// floating point samples for this reader.\n\t// SAMPLEFORMAT_IEEEFP is specified as IEEE floating point.\n\tif (_TIFF_SUCCESS != TIFFGetField(fInputFile, TIFFTAG_SAMPLEFORMAT, &sampleType) ||\n\t\tsampleType != SAMPLEFORMAT_IEEEFP)\n\t{\n\t\tgoto no_support;\n\t}\n\n\t// See how the data is stored in the scan line. Only support\n\t// contiguous scan line for now.\n\t// - PLANARCONFIG_SEPARATE is not supported.\n\tif (_TIFF_SUCCESS != TIFFGetField(fInputFile, TIFFTAG_PLANARCONFIG, &config) ||\n\t\t(config != PLANARCONFIG_CONTIG))\n\t{\n\t\tgoto no_support;\n\t}\n\n\t// Compression not supported yet.. \n#if 0\n\tunsigned short compression;\n\tif (_TIFF_SUCCESS != TIFFGetField(fInputFile, TIFFTAG_COMPRESSION, &compression) ||\n\t\t(compression != COMPRESSION_NONE))\n\t{\n\t\tgoto no_support;\n\t}\n#endif\n\n\t//printf(\"Opened tif file successfully: w=%d,h=%d, ch=%d\\n\",\n\t//\tfWidth, fHeight, fChannels );\n\n\tif( info)\n\t{\n\t\t// Set up the info structure to return\n\t\t//\n\t\tinfo->width( fWidth );\n\t\tinfo->height( fHeight );\n\t\tinfo->channels( fChannels );\n\t\tinfo->numberOfImages( 1 );\n\t\tinfo->pixelType( MImage::kFloat);\n\t}\n\treturn MS::kSuccess;\n\nno_support:\n\tclose();\n\treturn MS::kFailure;\n#else\n\treturn MS::kFailure;\n#endif\n}",
    "ImageFloatRGB *readTIFF(const char *filename)\n  {\n    TIFF* tif = TIFFOpen(filename, \"r\");\n    if (tif == NULL) {\n      fprintf(stderr, \"LibTIFF::readTIFF() -> TIFFOpen failed on %s\\n\", filename);\n      return NULL;\n    }\n\n    int width, height;\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n    \n    int dims[2]={height, width};\n    int ok;\n    Matrix<FloatRGB> *m = NULL;\n    ImageFloatRGB *res = NULL;\n    uint32_t *p = NULL;\n    \n    int npixels = width * height;\n    uint32_t *raster = (uint32_t*) _TIFFmalloc(npixels * sizeof (uint32_t));\n    if (raster == NULL) {\n      fprintf(stderr, \"LibTIFF::readTIFF() -> _TIFFMalloc failed on %s\\n\", filename);\n      goto close_file;\n    }\n\n    ok = TIFFReadRGBAImage(tif, width, height, raster, 0);\n    if (!ok) {\n      fprintf(stderr, \"LibTIFF::readTIFF() -> TIFFReadRGBAImage failed on %s\\n\", filename);\n      goto free_image_data;\n    }\n\n    m   = new Matrix<FloatRGB>(2, dims, FloatRGB(0.0f,0.0f,0.0f));\n    res = new ImageFloatRGB(m);\n    /* process raster data */\n    p = raster;\n    for (int y = 0; y < height; y++) {\n      for (int x = 0; x < width; x++) {\n        uint32_t pixel = *p++;\n        float r = TIFFGetR(pixel)/255.0f;\n        float g = TIFFGetG(pixel)/255.0f;\n        float b = TIFFGetB(pixel)/255.0f;\n        (*res)(x,height-1-y) = FloatRGB(r,g,b);\n      }\n    }\n    \n    free_image_data:\n    _TIFFfree(raster);\n    \n    close_file:\n    TIFFClose(tif);\n\n    return res;\n  }",
    "void ScImgDataLoader_TIFF::loadEmbeddedProfile(const QString& fn, int /*page*/)\n{\n\tScColorMgmtEngine engine(ScCore->defaultEngine);\n\tm_embeddedProfile.resize(0);\n\tm_profileComponents = 0;\n\tif ( !QFile::exists(fn) )\n\t\treturn;\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif(tif)\n\t{\n\t\tuint32 EmbedLen = 0;\n\t\tvoid*  EmbedBuffer;\n\t\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer))\n\t\t{\n\t\t\tQByteArray profArray((const char*) EmbedBuffer, EmbedLen);\n\t\t\tScColorProfile tiffProf = engine.openProfileFromMem(profArray);\n\t\t\tif (tiffProf)\n\t\t\t{\n\t\t\t\tif (tiffProf.colorSpace() == ColorSpace_Rgb)\n\t\t\t\t\tm_profileComponents = 3;\n\t\t\t\tif (tiffProf.colorSpace() == ColorSpace_Cmyk)\n\t\t\t\t\tm_profileComponents = 4;\n\t\t\t\tif (tiffProf.colorSpace() == ColorSpace_Gray)\n\t\t\t\t\tm_profileComponents = 1;\n\t\t\t\tm_embeddedProfile = profArray;\n\t\t\t}\n\t\t}\n\t\tTIFFClose(tif);\n\t}\n}",
    "int ScImgDataLoader_TIFF::getLayers(const QString& fn, int /*page*/)\n{\n\tint layerNum = 1;\n\tint test;\n\tstruct PSDLayer lay;\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (tif)\n\t{\n\t\tdo\n\t\t{\n\t\t\tchar *layerName=0;\n\t\t\tTIFFGetField(tif, TIFFTAG_PAGENAME, &layerName);\n\t\t\tQString name = QString(layerName);\n\t\t\tif (name.isEmpty())\n\t\t\t\tlay.layerName = QString(\"Layer #%1\").arg(layerNum);\n\t\t\telse\n\t\t\t\tlay.layerName = name;\n\t\t\tlay.blend = \"norm\";\n\t\t\tlay.opacity = 255;\n\t\t\tlay.flags = 0;\n\t\t\tm_imageInfoRecord.layerInfo.append(lay);\n\t\t\tm_imageInfoRecord.valid = true;\n\t\t\tlayerNum++;\n\t\t\ttest = TIFFReadDirectory(tif);\n\t\t}\n\t\twhile (test == 1);\n\t\tTIFFClose(tif);\n\t}\n\treturn layerNum;\n}",
    "bool ScImgDataLoader_TIFF::getImageData_RGBA(TIFF* tif, RawImage *image, uint widtht, uint heightt, uint size, uint16 bitspersample, uint16 samplesperpixel)\n{\n\tbool gotData = false;\n\tuint32* bits = (uint32 *) _TIFFmalloc(size * sizeof(uint32));\n\tuint16  extrasamples(0), *extratypes(0);\n\tif (!TIFFGetField (tif, TIFFTAG_EXTRASAMPLES, &extrasamples, &extratypes))\n\t\textrasamples = 0;\n\tif(bits)\n\t{\n\t\tif (TIFFReadRGBAImage(tif, widtht, heightt, bits, 0))\n\t\t{\n\t\t\tfor(unsigned int y = 0; y < heightt; y++)\n\t\t\t{\n\t\t\t\tmemcpy(image->scanLine(heightt - 1 - y), bits + y * widtht, widtht * image->channels());\n\t\t\t\tif (QSysInfo::ByteOrder==QSysInfo::BigEndian)\n\t\t\t\t{\n\t\t\t\t\tunsigned char *s = image->scanLine( heightt - 1 - y );\n\t\t\t\t\tunsigned char r, g, b, a;\n\t\t\t\t\tfor(uint xi=0; xi < widtht; ++xi )\n\t\t\t\t\t{\n\t\t\t\t\t\tr = s[0];\n\t\t\t\t\t\tg = s[1];\n\t\t\t\t\t\tb = s[2];\n\t\t\t\t\t\ta = s[3];\n\t\t\t\t\t\ts[0] = a;\n\t\t\t\t\t\ts[1] = b;\n\t\t\t\t\t\ts[2] = g;\n\t\t\t\t\t\ts[3] = r;\n\t\t\t\t\t\ts += image->channels();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (extrasamples > 0 && extratypes[0] == EXTRASAMPLE_ASSOCALPHA)\n\t\t\t\tunmultiplyRGBA(image);\n\t\t\tgotData = true;\n\t\t}\n\t\t_TIFFfree(bits);\n\t}\n\treturn gotData;\n}",
    "bool ScImgDataLoader_TIFF::loadPicture(const QString& fn, int page, int res, bool thumbnail)\n{\n\tScColorMgmtEngine engine(ScCore->defaultEngine);\n\tbool bilevel = false;\n\tbool failedPS = false;\n\tbool foundPS = false;\n\tshort resolutionunit = 0;\n\tfloat xres = 72.0, yres = 72.0;\n\tif (!QFile::exists(fn))\n\t\treturn false;\n\tQByteArray byteOrder(2, ' ');\n\tQFile fo(fn);\n\tif (fo.open(QIODevice::ReadOnly))\n\t{\n\t\tfo.read(byteOrder.data(), 1);\n\t\tfo.close();\n\t}\n\tsrand(314159265);\n\tfor (int i = 0; i < 4096; i++)\n\t\trandom_table[i] = rand();\n\tfor (int i = 0; i < 4096; i++)\n\t{\n\t\tint tmp;\n\t\tint swap = i + rand() % (4096 - i);\n\t\ttmp = random_table[i];\n\t\trandom_table[i] = random_table[swap];\n\t\trandom_table[swap] = tmp;\n\t}\n\tint test;\n\tbool valid = m_imageInfoRecord.isRequest;\n\tQMap<int, ImageLoadRequest> req = m_imageInfoRecord.RequestProps;\n\tinitialize();\n\tm_imageInfoRecord.RequestProps = req;\n\tm_imageInfoRecord.isRequest = valid;\n\tm_imageInfoRecord.type = ImageTypeTIF;\n\tgetLayers(fn, page);\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (tif)\n\t{\n\t\tbool isCMYK = false;\n\t\tunsigned int widtht, heightt, size;\n\t\tchar *description=0, *copyright=0, *datetime=0, *artist=0, *scannerMake=0, *scannerModel=0;\n\t\tuint16 bitspersample, fillorder, planar;\n\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &widtht);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &heightt);\n\t\tTIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres);\n\t\tTIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres);\n\t\tTIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT , &resolutionunit);\n\t\tsize = widtht * heightt;\n\t\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric);\n\t\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planar);\n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\t\tTIFFGetField(tif, TIFFTAG_FILLORDER, &fillorder);\n\n\t\tTIFFGetField(tif, TIFFTAG_MAKE, &scannerMake);\n\t\tTIFFGetField(tif, TIFFTAG_MODEL, &scannerModel);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &description);\n\t\tTIFFGetField(tif, TIFFTAG_COPYRIGHT, &copyright);\n\t\tTIFFGetField(tif, TIFFTAG_DATETIME, &datetime);\n\t\tTIFFGetField(tif, TIFFTAG_ARTIST, &artist);\n\t\tm_imageInfoRecord.exifInfo.cameraName = QString(scannerModel);\n\t\tm_imageInfoRecord.exifInfo.cameraVendor = QString(scannerMake);\n\t\tm_imageInfoRecord.exifInfo.comment = QString(description);\n\t\tm_imageInfoRecord.exifInfo.userComment = QString(copyright);\n\t\tm_imageInfoRecord.exifInfo.width = widtht;\n\t\tm_imageInfoRecord.exifInfo.height = heightt;\n\t\tm_imageInfoRecord.exifInfo.dateTime = QString(datetime);\n\t\tm_imageInfoRecord.exifInfo.artist = QString(artist);\n\t\tm_imageInfoRecord.exifInfo.thumbnail = QImage();\n\t\tm_imageInfoRecord.exifDataValid = true;\n\t\tuint32 EmbedLen = 0;\n\t\tvoid*  EmbedBuffer;\n\t\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer))\n\t\t{\n\t\t\tQByteArray profArray((const char*) EmbedBuffer, EmbedLen);\n\t\t\tScColorProfile tiffProf = engine.openProfileFromMem(profArray);\n\t\t\tm_embeddedProfile = profArray;\n\t\t\tm_imageInfoRecord.profileName = tiffProf.productDescription();\n\t\t\tm_imageInfoRecord.isEmbedded = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_imageInfoRecord.isEmbedded = false;\n\t\t\tm_imageInfoRecord.profileName = \"\";\n\t\t}\n\t\tunsigned int PhotoshopLen = 0;\n\t\tunsigned char* PhotoshopBuffer;\n\t\tif (TIFFGetField(tif, TIFFTAG_PHOTOSHOP, &PhotoshopLen, &PhotoshopBuffer) )\n\t\t{\n\t\t\tif (PhotoshopLen != 0)\n\t\t\t{\n\t\t\t\tQByteArray arrayPhot = QByteArray((const char*)PhotoshopBuffer,PhotoshopLen);\n\t\t\t\tQDataStream strPhot(&arrayPhot,QIODevice::ReadOnly);\n\t\t\t\tstrPhot.setByteOrder( QDataStream::BigEndian );\n\t\t\t\tPSDHeader fakeHeader;\n\t\t\t\tfakeHeader.width = widtht;\n\t\t\t\tfakeHeader.height = heightt;\n\t\t\t\tparseRessourceData(strPhot, fakeHeader, PhotoshopLen);\n\t\t\t\tm_imageInfoRecord.exifInfo.width = widtht;\n\t\t\t\tm_imageInfoRecord.exifInfo.height = heightt;\n\t\t\t\tif (!m_imageInfoRecord.valid)\n\t\t\t\t\tm_imageInfoRecord.valid = (m_imageInfoRecord.PDSpathData.size())>0?true:false;\n\t\t\t\tif (thumbnail)\n\t\t\t\t{\n\t\t\t\t\tif (photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t\t\t{\n\t\t\t\t\t\tisCMYK = true;\n\t\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\t\t\t\t}\n\t\t\t\t\telse if (samplesperpixel == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t\t\t\t\t\tisCMYK = false;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\t\t\t\tif (bitspersample == 1)\n\t\t\t\t\t\tbilevel = true;\n\t\t\t\t\tif (!m_imageInfoRecord.exifInfo.thumbnail.isNull())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 5);\n\t\t\t\t\t\t\tm_pixelFormat = Format_CMYKA_8;;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 4);\n\t\t\t\t\t\t\tm_pixelFormat = (m_imageInfoRecord.colorspace == ColorSpaceCMYK) ? Format_CMYK_8 : Format_RGBA_8;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_image.fill(0);\n\t\t\t\t\t\tQRgb *s;\n\t\t\t\t\t\tuchar *d;\n\t\t\t\t\t\tunsigned char cc, cm, cy, ck;\n\t\t\t\t\t\tfor( int yit=0; yit < m_imageInfoRecord.exifInfo.thumbnail.height(); ++yit )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ts = (QRgb*)(m_imageInfoRecord.exifInfo.thumbnail.scanLine( yit ));\n\t\t\t\t\t\t\td = r_image.scanLine( yit );\n\t\t\t\t\t\t\tfor(int xit=0; xit < m_imageInfoRecord.exifInfo.thumbnail.width(); ++xit )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcc = 255 - qRed(*s);\n\t\t\t\t\t\t\t\t\tcm = 255 - qGreen(*s);\n\t\t\t\t\t\t\t\t\tcy = 255 - qBlue(*s);\n\t\t\t\t\t\t\t\t\tck = qMin(qMin(cc, cm), cy);\n\t\t\t\t\t\t\t\t\td[0] = cc-ck;\n\t\t\t\t\t\t\t\t\td[1] = cm-ck;\n\t\t\t\t\t\t\t\t\td[2] = cy-ck;\n\t\t\t\t\t\t\t\t\td[3] = ck;\n\t\t\t\t\t\t\t\t\td[4] = 255;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\td[0] = qRed(*s);\n\t\t\t\t\t\t\t\t\td[1] = qGreen(*s);\n\t\t\t\t\t\t\t\t\td[2] = qBlue(*s);\n\t\t\t\t\t\t\t\t\td[3] = 255;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\t\td += r_image.channels();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tunsigned int PhotoshopLen2 = 0;\n\t\tunsigned char* PhotoshopBuffer2;\n\t\tint gotField = TIFFGetField(tif, 37724, &PhotoshopLen2, &PhotoshopBuffer2);\n\t\tif (gotField && (PhotoshopLen2 > 40))\n\t\t{\n\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t\tQByteArray arrayPhot = QByteArray::fromRawData((const char*)PhotoshopBuffer2, PhotoshopLen2);\n\t\t\tQDataStream s(&arrayPhot,QIODevice::ReadOnly);\n\t\t\tif (byteOrder[0] == 'M')\n\t\t\t\ts.setByteOrder( QDataStream::BigEndian );\n\t\t\telse\n\t\t\t\ts.setByteOrder( QDataStream::LittleEndian );\n\n\t\t\tfailedPS = !loadLayerInfo(s, m_imageInfoRecord.layerInfo); \n\t\t\tif (!failedPS)\n\t\t\t{\n\t\t\t\tint chans = 4;\n\t\t\t\tint numChannels = m_imageInfoRecord.layerInfo.last().channelType.count();\n\t\t\t\tint numLayers = m_imageInfoRecord.layerInfo.count();\n\t\t\t\tPSDHeader fakeHeader;\n\t\t\t\tfakeHeader.width = widtht;\n\t\t\t\tfakeHeader.height = heightt;\n\t\t\t\tfakeHeader.channel_count = numChannels;\n\t\t\t\tfakeHeader.depth = 8;\n\t\t\t\tif (photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t\t{\n\t\t\t\t\tisCMYK = true;\n\t\t\t\t\tfakeHeader.color_mode = CM_CMYK;\n\t\t\t\t\tchans = 5;\n\t\t\t\t}\n\t\t\t\telse if (samplesperpixel == 1)\n\t\t\t\t{\n\t\t\t\t\tfakeHeader.color_mode = CM_GRAYSCALE;\n\t\t\t\t\tisCMYK = false;\n\t\t\t\t\tchans = 4;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfakeHeader.color_mode = CM_RGB;\n\t\t\t\t\tisCMYK = false;\n\t\t\t\t\tchans = 4;\n\t\t\t\t}\n\t\t\t\tif( !r_image.create( widtht, heightt, chans ))\n\t\t\t\t\treturn false;\n\t\t\t\tr_image.fill(0);\n\t\t\t\tbool firstLayer = true;\n\t\t\t\tfor (int layer = 0; layer < numLayers; layer++)\n\t\t\t\t{\n\t\t\t\t\tloadLayerChannels( s, fakeHeader, m_imageInfoRecord.layerInfo, layer, &firstLayer );\n\t\t\t\t}\n\t\t\t\tarrayPhot.clear();\n\t\t\t\tTIFFClose(tif);\n\t\t\t\tfoundPS = true;\n\t\t\t\tif (m_imageInfoRecord.layerInfo.count() == 1)\n\t\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tarrayPhot.clear();\n\t\t\t\tgetLayers(fn, page);\n\t\t\t}\n\t\t}\n\n\t\tif( xres <= 1.0 || yres <= 1.0 )\n\t\t{\n\t\t\txres = yres = 72.0;\n\t\t\tQFileInfo qfi(fn);\n\t\t\tm_message = QObject::tr(\"%1 may be corrupted : missing resolution tags\").arg(qfi.fileName());\n\t\t\tm_msgType = warningMsg;\n\t\t}\n\t\tif ((!foundPS) || (failedPS))\n\t\t{\n\t\t\tint chans = 4;\n\t\t\tif (photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t{\n\t\t\t\tif (samplesperpixel > 5) \n\t\t\t\t\tchans = 4;\n\t\t\t\telse\n\t\t\t\t\tchans = samplesperpixel;\n\t\t\t}\n\t\t\telse\n\t\t\t\tchans = 4;\n\t\t\tif (!r_image.create(widtht, heightt, chans))\n\t\t\t{\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_image.fill(0);\n\t\t\tint layerNum = 0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tRawImage tmpImg;\n\t\t\t\tif( !tmpImg.create(widtht, heightt, chans))\n\t\t\t\t{\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\ttmpImg.fill(0);\n\t\t\t\tif (!getImageData(tif, &tmpImg, widtht, heightt, size, photometric, bitspersample, samplesperpixel, bilevel, isCMYK))\n\t\t\t\t{\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbool visible = true;\n\t\t\t\tbool useMask = true;\n\t\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\t\tvisible = m_imageInfoRecord.RequestProps[layerNum].visible;\n\t\t\t\tQString layBlend = \"norm\";\n\t\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\t\tlayBlend = m_imageInfoRecord.RequestProps[layerNum].blend;\n\t\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\t\tuseMask = m_imageInfoRecord.RequestProps[layerNum].useMask;\n\t\t\t\tint layOpa = 255;\n\t\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\t\tlayOpa = m_imageInfoRecord.RequestProps[layerNum].opacity;\n\t\t\t\tif (visible)\n\t\t\t\t{\n\t\t\t\t\tif ((layerNum == 0) && (layBlend != \"diss\"))\n\t\t\t\t\t\tr_image = tmpImg;\n\t\t\t\t\telse\n\t\t\t\t\t\tblendOntoTarget(&tmpImg, layOpa, layBlend, isCMYK, useMask);\n\t\t\t\t}\n\t\t\t\t//JG Copy should not be necessary as QImage is implicitly shared in Qt4\n\t\t\t\tQImage imt; //QImage imt = tmpImg.copy();\n\t\t\t\tdouble sx = tmpImg.width() / 40.0;\n\t\t\t\tdouble sy = tmpImg.height() / 40.0;\n\t\t\t\timt = tmpImg.convertToQImage((chans > 4) ? true : false);\n\t\t\t\timt = sy < sx ?\timt.scaled(qRound(imt.width() / sx), qRound(imt.height() / sx), Qt::IgnoreAspectRatio, Qt::SmoothTransformation) :\n\t\t\t\t\t\t\t\t\t\t\timt.scaled(qRound(imt.width() / sy), qRound(imt.height() / sy), Qt::IgnoreAspectRatio, Qt::SmoothTransformation);\n\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb = imt.copy();\n\t\t\t\tif (chans > 4)\n\t\t\t\t{\n\t\t\t\t\tQImage imt2 = imt.createAlphaMask();\n\t\t\t\t\timt2.invertPixels();\n\t\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = imt2.copy();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = QImage();\n\t\t\t\tlayerNum++;\n\n\t\t\t\tif ((m_imageInfoRecord.layerInfo.count() == 1) && (chans < 5))\n\t\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t\t\ttest = TIFFReadDirectory(tif);\n\n\t\t\t\t// #10415 : check that image size for the current directory is the same as the main one\n\t\t\t\t// Some progs use tiff directory to store previews, we do not handle such case\n\t\t\t\t// and may perform reads in non allocated blocks if we continue\n\t\t\t\twhile (test == 1)\n\t\t\t\t{\n\t\t\t\t\tunsigned int dirWidth(0), dirHeight(0);\n\t\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &dirWidth);\n\t\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &dirHeight);\n\t\t\t\t\tif (dirWidth == widtht && dirHeight == heightt)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\ttest = TIFFReadDirectory(tif);\n\t\t\t\t\tlayerNum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (test == 1);\n\t\t\tTIFFClose(tif);\n\t\t}\n\t\tif (resolutionunit == RESUNIT_INCH)\n\t\t{\n\t\t\tm_image.setDotsPerMeterX ((int) (xres / 0.0254));\n\t\t\tm_image.setDotsPerMeterY ((int) (yres / 0.0254));\n\t\t\tm_imageInfoRecord.xres = qRound(xres);\n\t\t\tm_imageInfoRecord.yres = qRound(yres);\n\t\t}\n\t\telse if (resolutionunit == RESUNIT_CENTIMETER)\n\t\t{\n\t\t\tm_image.setDotsPerMeterX ((int) (xres * 100.0));\n\t\t\tm_image.setDotsPerMeterY ((int) (yres * 100.0));\n\t\t\tm_imageInfoRecord.xres = qRound(xres*2.54);\n\t\t\tm_imageInfoRecord.yres = qRound(yres*2.54);\n\t\t}\n\t\tif (isCMYK)\n\t\t{\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\t\tm_pixelFormat = (r_image.channels() == 5) ? Format_CMYKA_8 : Format_CMYK_8;\n\t\t}\n\t\telse if (samplesperpixel == 1)\n\t\t{\n\t\t\t// Do not set m_pixelFormat here as the real pixel format is most probably different than gray\n\t\t\tif (bitspersample == 1)\n\t\t\t{\n\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceMonochrome;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\t\tm_pixelFormat = Format_RGBA_8;\n\t\t}\n\t\tm_imageInfoRecord.BBoxX = 0;\n\t\tm_imageInfoRecord.BBoxH = r_image.height();\n\t\tif ((m_imageInfoRecord.layerInfo.isEmpty()) && (m_imageInfoRecord.PDSpathData.isEmpty()))\n\t\t\tm_imageInfoRecord.valid = false;\n\t\telse\n\t\t\tm_imageInfoRecord.valid = true;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "static int\nread_whole_tiff(struct iio_image *x,\n                const char *filename)\n{\n    // tries to read data in the correct format (via scanlines)\n    // if it fails, it tries to read ABGR data\n\n    TIFF *tif = TIFFOpen(filename, \"r\");\n\n    if (!tif) {\n        fail(\"could not open TIFF file \\\"%s\\\"\", filename);\n    }\n    uint32_t w, h;\n    uint16_t spp, bps, fmt;\n    int r = 0, fmt_iio = -1;\n    r += TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n    IIO_DEBUG(\"tiff get field width %d (r=%d)\\n\", (int)w, r);\n    r += TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n    IIO_DEBUG(\"tiff get field length %d (r=%d)\\n\", (int)h, r);\n    if (r != 2) {\n        fail(\"can not read tiff of unknown size\");\n    }\n\n    r = TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    if (!r) {\n        spp = 1;\n    }\n    if (r) {\n        IIO_DEBUG(\"tiff get field spp %d (r=%d)\\n\", spp, r);\n    }\n\n    r = TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n    if (!r) {\n        bps = 1;\n    }\n    if (r) {\n        IIO_DEBUG(\"tiff get field bps %d (r=%d)\\n\", bps, r);\n    }\n\n    r = TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &fmt);\n    if (!r) {\n        fmt = SAMPLEFORMAT_UINT;\n    }\n    if (r) {\n        IIO_DEBUG(\"tiff get field fmt %d (r=%d)\\n\", fmt, r);\n    }\n    //if (r != 5) error(\"some tiff getfield failed (r=%d)\", r);\n\n    // TODO: consider the missing cases (run through PerlMagick's format database)\n\n    IIO_DEBUG(\"fmt  = %d\\n\", fmt);\n    // set appropriate size and type flags\n    if (fmt == SAMPLEFORMAT_UINT) {\n        if (1 == bps) {\n            fmt_iio = IIO_TYPE_UINT1;\n        } else if (2 == bps) {\n            fmt_iio = IIO_TYPE_UINT2;\n        } else if (4 == bps) {\n            fmt_iio = IIO_TYPE_UINT4;\n        } else if (8 == bps) {\n            fmt_iio = IIO_TYPE_UINT8;\n        } else if (16 == bps) {\n            fmt_iio = IIO_TYPE_UINT16;\n        } else if (32 == bps) {\n            fmt_iio = IIO_TYPE_UINT32;\n        } else {\n            fail(\"unrecognized UINT type of size %d bits\", bps);\n        }\n    } else if (fmt == SAMPLEFORMAT_INT) {\n        if (8 == bps) {\n            fmt_iio = IIO_TYPE_INT8;\n        } else if (16 == bps) {\n            fmt_iio = IIO_TYPE_INT16;\n        } else if (32 == bps) {\n            fmt_iio = IIO_TYPE_INT32;\n        } else {\n            fail(\"unrecognized INT type of size %d bits\", bps);\n        }\n    } else if (fmt == SAMPLEFORMAT_IEEEFP) {\n        IIO_DEBUG(\"floating tiff!\\n\");\n        if (32 == bps) {\n            fmt_iio = IIO_TYPE_FLOAT;\n        } else if (64 == bps) {\n            fmt_iio = IIO_TYPE_DOUBLE;\n        } else {\n            fail(\"unrecognized FLOAT type of size %d bits\", bps);\n        }\n    } else {\n        fail(\"unrecognized tiff sample format %d (see tiff.h)\", fmt);\n    }\n\n    if ( (bps >= 8) && ( bps != 8 * iio_type_size(fmt_iio) ) ) {\n        IIO_DEBUG(\"bps = %d\\n\", bps);\n        IIO_DEBUG(\"fmt_iio = %d\\n\", fmt_iio);\n        IIO_DEBUG( \"ts = %zu\\n\", iio_type_size(fmt_iio) );\n        IIO_DEBUG( \"8*ts = %zu\\n\", 8 * iio_type_size(fmt_iio) );\n    }\n    if (bps >= 8) {\n        assert( bps == 8 * iio_type_size(fmt_iio) );\n    }\n\n\n    // acquire memory block\n    uint32_t scanline_size = (w * spp * bps) / 8;\n    int rbps = bps / 8 ? bps / 8 : 1;\n    uint32_t uscanline_size = w * spp * rbps;\n    IIO_DEBUG(\"bps = %d\\n\", (int)bps);\n    IIO_DEBUG(\"spp = %d\\n\", (int)spp);\n    IIO_DEBUG(\"sls = %d\\n\", (int)scanline_size);\n    int sls = TIFFScanlineSize(tif);\n    IIO_DEBUG(\"sls(r) = %d\\n\", (int)sls);\n    assert( (int)scanline_size == sls );\n    scanline_size = sls;\n    uint8_t *data = (uint8_t *)xmalloc(w * h * spp * rbps);\n    //FORI(h*scanline_size) data[i] = 42;\n    uint8_t *buf = (uint8_t *)xmalloc(scanline_size);\n\n    // dump scanline data\n    FORI(h) {\n        r = TIFFReadScanline(tif, buf, i, 0);\n        if (r < 0) {\n            fail(\"error reading tiff row %d/%d\", i, (int)h);\n        }\n\n        if (bps < 8) {\n            fprintf(stderr, \"unpacking %dth scanline\\n\", i);\n            unpack_to_bytes_here(data + i * uscanline_size, buf,\n                                 scanline_size, bps);\n            fmt_iio = IIO_TYPE_UINT8;\n        } else {\n            memcpy(data + i * scanline_size, buf, scanline_size);\n        }\n    }\n    TIFFClose(tif);\n\n\n    xfree(buf);\n\n    // fill struct fields\n    x->dimension = 2;\n    x->sizes[0] = w;\n    x->sizes[1] = h;\n    x->pixel_dimension = spp;\n    x->type = fmt_iio;\n    x->format = x->meta = -42;\n    x->data = data;\n    x->contiguous_data = false;\n\n    return 0;\n}",
    "int slTerrain::loadGeoTIFF( char *file ) {\n#if HAVE_LIBTIFF\n\tTIFF* tif;\n\tfloat *row;\n\tint height, width, x, y;\n\tunsigned short depth, samples;\n\n\tif ( !( tif = TIFFOpen( file, \"r\" ) ) )\n\t\treturn -1;\n\n\tTIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &width );\n\n\tTIFFGetField( tif, TIFFTAG_IMAGELENGTH, &height );\n\n\tTIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &depth );\n\n\tTIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &samples );\n\n\tprintf( \"Loading GeoTIFF data (%d x %d) x %d x %d\\n\", height, width, depth, samples );\n\n\tif ( height < width ) resize( height );\n\telse resize( width );\n\n\trow = new float[width];\n\n\tif ( width > _side ) width = _side;\n\n\tif ( height > _side ) height = _side;\n\n\tfor ( y = 0; y < height; y++ ) {\n\t\tTIFFReadScanline( tif, row, y, 0 );\n\n\t\tfor ( x = 0; x < width; x++ ) {\n\t\t\t_matrix[x][y] = 3 * row[x * samples];\n\n\t\t\tif ( _matrix[x][y] < 90 ) _matrix[x][y] = 10;\n\t\t}\n\t}\n\n\tdelete row;\n\n\tinitialize();\n\n\tTIFFClose( tif );\n\n\t_roam->computeVariance();\n#endif\n\treturn 0;\n}",
    "void PdfImage::LoadFromTiff( const char* pszFilename )\n{\n    TIFFSetErrorHandler(TIFFErrorWarningHandler);\n    TIFFSetWarningHandler(TIFFErrorWarningHandler);\n    \n    if( !pszFilename )\n    {\n        PODOFO_RAISE_ERROR( ePdfError_InvalidHandle );\n    }\n\n    TIFF* hInfile = TIFFOpen(pszFilename, \"rb\");\n\n    if( !hInfile )\n    {\n        PODOFO_RAISE_ERROR_INFO( ePdfError_FileNotFound, pszFilename );\n    }\n\n    int32 row, width, height;\n    uint16 samplesPerPixel, bitsPerSample;\n    uint16* sampleInfo;\n    uint16 extraSamples;\n    uint16 planarConfig, photoMetric, orientation;\n    int32 resolutionUnit;\n\n    TIFFGetField(hInfile,\t   TIFFTAG_IMAGEWIDTH,\t\t&width);\n    TIFFGetField(hInfile,\t   TIFFTAG_IMAGELENGTH,\t\t&height);\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_BITSPERSAMPLE,\t&bitsPerSample);\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_SAMPLESPERPIXEL,     &samplesPerPixel);\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_PLANARCONFIG,\t&planarConfig);\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_PHOTOMETRIC,\t\t&photoMetric);\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_EXTRASAMPLES,\t&extraSamples, &sampleInfo);\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_ORIENTATION,\t\t&orientation);\n\t\n    resolutionUnit = 0;\n    float resX;\n    float resY;\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_XRESOLUTION,\t\t&resX);\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_YRESOLUTION,\t\t&resY);\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_RESOLUTIONUNIT,\t&resolutionUnit);\n\n    int colorChannels = samplesPerPixel - extraSamples;\n\n    int bitsPixel = bitsPerSample * samplesPerPixel;\n\n    // TODO: implement special cases\n    if( TIFFIsTiled(hInfile) )\n    {\n        TIFFClose(hInfile);\n        PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n    }\n\t\t\n    if ( planarConfig != PLANARCONFIG_CONTIG && colorChannels != 1 )\n    {\n        TIFFClose(hInfile);\n        PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n    }\n\n\tif ( orientation != ORIENTATION_TOPLEFT )\n    {\n        TIFFClose(hInfile);\n        PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n    }\n\n\tswitch(photoMetric)\n\t{\n\t\tcase PHOTOMETRIC_MINISBLACK:\n\t\t{\n\t\t\tif( bitsPixel == 1 )\n\t\t\t{\n\t\t\t\tPdfArray decode;\n\t\t\t\tdecode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(0) ) );\n\t\t\t\tdecode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(1) ) );\n\t\t\t\tthis->GetObject()->GetDictionary().AddKey( PdfName(\"Decode\"), decode );\n\t\t\t\tthis->GetObject()->GetDictionary().AddKey( PdfName(\"ImageMask\"), PdfVariant( true ) );\n\t\t\t\tthis->GetObject()->GetDictionary().RemoveKey( PdfName(\"ColorSpace\") );\n\t\t\t}\n\t\t\telse if ( bitsPixel == 8)\n\t            SetImageColorSpace(ePdfColorSpace_DeviceGray);\n\t\t\telse\n\t\t\t{\n\t\t\t\tTIFFClose(hInfile);\n\t\t\t\tPODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\t{\n\t\t\tif( bitsPixel == 1 )\n\t\t\t{\n\t\t\t\tPdfArray decode;\n\t\t\t\tdecode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(1) ) );\n\t\t\t\tdecode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(0) ) );\n\t\t\t\tthis->GetObject()->GetDictionary().AddKey( PdfName(\"Decode\"), decode );\n\t\t\t\tthis->GetObject()->GetDictionary().AddKey( PdfName(\"ImageMask\"), PdfVariant( true ) );\n\t\t\t\tthis->GetObject()->GetDictionary().RemoveKey( PdfName(\"ColorSpace\") );\n\t\t\t}\n\t\t\telse if ( bitsPixel == 8)\n\t            SetImageColorSpace(ePdfColorSpace_DeviceGray);\n\t\t\telse\n\t\t\t{\n\t\t\t\tTIFFClose(hInfile);\n\t\t\t\tPODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PHOTOMETRIC_RGB:\n            if ( bitsPixel != 24 )\n\t\t\t{\n\t\t\t\tTIFFClose(hInfile);\n\t\t\t\tPODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n\t\t\t}\n\t\t\tSetImageColorSpace(ePdfColorSpace_DeviceRGB);\n\t\tbreak;\n\n\t\tcase PHOTOMETRIC_SEPARATED: \n\t\t\tif( bitsPixel != 32)\n\t\t\t{\n\t\t\t\tTIFFClose(hInfile);\n\t\t\t\tPODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n\t\t\t}\n            SetImageColorSpace(ePdfColorSpace_DeviceCMYK);\n\t\tbreak;\n\n\t\tcase PHOTOMETRIC_PALETTE:\n\t\t{\n\t\t\tint numColors = (1 << bitsPixel);\n\n\t\t\tPdfArray decode;\n\t\t\tdecode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(0) ) );\n\t\t\tdecode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(numColors-1) ) );\n\t\t\tthis->GetObject()->GetDictionary().AddKey( PdfName(\"Decode\"), decode );\n\n\t\t\tuint16 * rgbRed;\n\t\t\tuint16 * rgbGreen;\n\t\t\tuint16 * rgbBlue;\n\t\t\tTIFFGetField(hInfile, TIFFTAG_COLORMAP, &rgbRed, &rgbGreen, &rgbBlue);\n\n\t\t\tchar *datap = new char[numColors*3];\n\n\t\t\tfor ( int clr = 0; clr < numColors; clr++ )\n\t\t\t{\n\t\t\t\tdatap[3*clr+0] = rgbRed[clr]/257;\n\t\t\t\tdatap[3*clr+1] = rgbGreen[clr]/257;\n\t\t\t\tdatap[3*clr+2] = rgbBlue[clr]/257;\n\t\t\t}\n\t\t    PdfMemoryInputStream stream( datap, numColors*3 );\n\n\t\t    // Create a colorspace object\n\t\t    PdfObject* pIdxObject = this->GetObject()->GetOwner()->CreateObject();\n\t\t\tpIdxObject->GetStream()->Set( &stream );\n    \n\t\t    // Add the colorspace to our image\n\t\t    PdfArray array;\n\t\t    array.push_back( PdfName(\"Indexed\") );\n\t\t    array.push_back( PdfName(\"DeviceRGB\") );\n            array.push_back( static_cast<pdf_int64>(numColors-1) );\n\t\t    array.push_back( pIdxObject->Reference() );\n\t\t    this->GetObject()->GetDictionary().AddKey( PdfName(\"ColorSpace\"), array );\n\n\t\t\tdelete[] datap;\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t        TIFFClose(hInfile);\n\t        PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n\t\tbreak;\n\t}\n\n\tint32 scanlineSize = TIFFScanlineSize(hInfile);\n    long bufferSize = scanlineSize * height;\n    char *buffer = new char[bufferSize];\n    if( !buffer ) \n    {\n        TIFFClose(hInfile);\n        PODOFO_RAISE_ERROR( ePdfError_OutOfMemory );\n    }\n\n    for(row = 0; row < height; row++)\n    {\n        if(TIFFReadScanline(hInfile,\n                            &buffer[row * scanlineSize],\n                            row) == (-1))\n        {\n            TIFFClose(hInfile);\n            PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n        }\n    }\n\n\tPdfMemoryInputStream stream(buffer, bufferSize);\n\n    SetImageData(static_cast<unsigned int>(width), \n                 static_cast<unsigned int>(height),\n                 static_cast<unsigned int>(bitsPerSample), \n                 &stream);\n\n    delete[] buffer;\n\n    TIFFClose(hInfile);\n}",
    "bool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    TIFF* tif = TIFFOpen( m_filename.c_str(), \"rb\" );\n\n    if( tif )\n    {\n        int wdth = 0, hght = 0, photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            int bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if( bpp > 8 &&\n               ((photometric != 2 && photometric != 1) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? 3 : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? 3 : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.data;\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        int tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        int photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        int bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 )\n                tile_height0 = m_height;\n\n            AutoBuffer<uchar> _buffer( size_t(8) * tile_height0*tile_width0);\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += img.step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                    icvCvt_BGRA2BGR_8u_C4C3R( buffer + i*tile_width*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( buffer + i*tile_width*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    close();\n    return result;\n}",
    "bool ZLWin32ImageManager::tiffConvert(const std::string &stringData, ZLWin32ImageData &data) const {\n\tTIFFReader reader(stringData);\n\tTIFF *tiff = TIFFClientOpen(\"ZLWin32ImageManager\", \"rM\", &reader, TIFFReader::read, TIFFReader::write, TIFFReader::seek, TIFFReader::close, TIFFReader::size, TIFFReader::map, TIFFReader::unmap);\n\tif (tiff == 0) {\n\t\treturn false;\n\t}\n\n\tint width, height;\n\tif (!TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width) ||\n\t\t\t!TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height)) {\n\t\tTIFFClose(tiff);\n\t\treturn false;\n\t}\n\n\tdata.init(width, height, true, 0);\n\n\tTIFFReadRGBAImage(tiff, width, height, (uint32*)data.myArray, 1);\n\tdata.bgr2rgb();\n\n\tTIFFClose(tiff);\n\treturn true;\n}",
    "void TIFFBuildOverviews( const char * pszTIFFFilename,\n                         int nOverviews, int * panOvList,\n                         int bUseSubIFDs )\n\n{\n    RawBlockedImage\t**papoRawBIs;\n    uint32\t\tnXSize, nYSize, nBlockXSize, nBlockYSize;\n    uint16\t\tnBitsPerPixel, nPhotometric, nCompressFlag, nSamples,\n                        nPlanarConfig;\n    int\t\t\tbTiled, nSXOff, nSYOff, i, iSample;\n    unsigned char\t*pabySrcTile;\n    TIFF\t\t*hTIFF;\n    uint16\t\t*panRedMap, *panGreenMap, *panBlueMap;\n\n/* -------------------------------------------------------------------- */\n/*      Get the base raster size.                                       */\n/* -------------------------------------------------------------------- */\n    hTIFF = TIFFOpen( pszTIFFFilename, \"r\" );\n    if( hTIFF == NULL )\n    {\n        fprintf( stderr, \"TIFFOpen(%s) failed.\\n\", pszTIFFFilename );\n        exit( 1 );\n    }\n\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n    TIFFGetField( hTIFF, TIFFTAG_BITSPERSAMPLE, &nBitsPerPixel );\n    TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSamples );\n    TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &nPlanarConfig );\n\n    TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &nPhotometric );\n    TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &nCompressFlag );\n\n    if( nBitsPerPixel < 8 )\n    {\n        TIFFError( \"TIFFBuildOverviews\",\n                   \"File `%s' has samples of %d bits per sample.  Sample\\n\"\n                   \"sizes of less than 8 bits per sample are not supported.\\n\",\n                   pszTIFFFilename, nBitsPerPixel );\n        return;\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Get the base raster block size.                                 */\n/* -------------------------------------------------------------------- */\n    if( TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP, &(nBlockYSize) ) )\n    {\n        nBlockXSize = nXSize;\n        bTiled = FALSE;\n    }\n    else\n    {\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &nBlockXSize );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &nBlockYSize );\n        bTiled = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*\tCapture the pallette if there is one.\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    if( TIFFGetField( hTIFF, TIFFTAG_COLORMAP,\n                      &panRedMap, &panGreenMap, &panBlueMap ) )\n    {\n        uint16\t\t*panRed2, *panGreen2, *panBlue2;\n\n        panRed2 = (uint16 *) calloc(2,256);\n        panGreen2 = (uint16 *) calloc(2,256);\n        panBlue2 = (uint16 *) calloc(2,256);\n\n        memcpy( panRed2, panRedMap, 512 );\n        memcpy( panGreen2, panGreenMap, 512 );\n        memcpy( panBlue2, panBlueMap, 512 );\n\n        panRedMap = panRed2;\n        panGreenMap = panGreen2;\n        panBlueMap = panBlue2;\n    }\n    else\n    {\n        panRedMap = panGreenMap = panBlueMap = NULL;\n    }\n        \n/* -------------------------------------------------------------------- */\n/*      Initialize the overview raw layers                              */\n/* -------------------------------------------------------------------- */\n    papoRawBIs = (RawBlockedImage **)\n        calloc(nOverviews*nSamples,sizeof(void*));\n\n    for( i = 0; i < nOverviews; i++ )\n    {\n        int\tnOXSize, nOYSize, nOBlockXSize, nOBlockYSize;\n\n        nOXSize = (nXSize + panOvList[i] - 1) / panOvList[i];\n        nOYSize = (nYSize + panOvList[i] - 1) / panOvList[i];\n\n        nOBlockXSize = MIN((int)nBlockXSize,nOXSize);\n        nOBlockYSize = MIN((int)nBlockYSize,nOYSize);\n\n        if( bTiled )\n        {\n            if( (nOBlockXSize % 16) != 0 )\n                nOBlockXSize = nOBlockXSize + 16 - (nOBlockXSize % 16);\n            \n            if( (nOBlockYSize % 16) != 0 )\n                nOBlockYSize = nOBlockYSize + 16 - (nOBlockYSize % 16);\n        }\n\n        for( iSample = 0; iSample < nSamples; iSample++ )\n        {\n            papoRawBIs[i*nSamples + iSample] =\n                new RawBlockedImage( nOXSize, nOYSize,\n                                     nOBlockXSize, nOBlockYSize,\n                                     nBitsPerPixel );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a buffer to hold a source block.                       */\n/* -------------------------------------------------------------------- */\n    if( bTiled )\n        pabySrcTile = (unsigned char *) malloc(TIFFTileSize(hTIFF));\n    else\n        pabySrcTile = (unsigned char *) malloc(TIFFStripSize(hTIFF));\n    \n/* -------------------------------------------------------------------- */\n/*      Loop over the source raster, applying data to the               */\n/*      destination raster.                                             */\n/* -------------------------------------------------------------------- */\n    for( nSYOff = 0; nSYOff < (int) nYSize; nSYOff += nBlockYSize )\n    {\n        for( nSXOff = 0; nSXOff < (int) nXSize; nSXOff += nBlockXSize )\n        {\n            /*\n             * Read and resample into the various overview images.\n             */\n            \n            TIFF_ProcessFullResBlock( hTIFF, nPlanarConfig,\n                                      nOverviews, panOvList,\n                                      nBitsPerPixel, nSamples, papoRawBIs,\n                                      nSXOff, nSYOff, pabySrcTile,\n                                      nBlockXSize, nBlockYSize );\n        }\n    }\n\n    free( pabySrcTile );\n\n    TIFFClose( hTIFF );\n\n/* ==================================================================== */\n/*      We now have the overview rasters built, and held as             */\n/*      RawBlockedImage's.  Now we need to write them to new TIFF       */\n/*      layers.                                                         */\n/* ==================================================================== */\n    hTIFF = TIFFOpen( pszTIFFFilename, \"a\" );\n    if( hTIFF == NULL )\n    {\n        fprintf( stderr,\n                 \"TIFFOpen(%s,\\\"a\\\") failed.  No overviews written.\\n\"\n                 \"Do you have write permissions on that file?\\n\",\n                 pszTIFFFilename );\n    }\n    else\n    {\n        for( i = 0; i < nOverviews; i++ )\n        {\n            TIFF_WriteOverview( hTIFF, nSamples, papoRawBIs + i*nSamples,\n                                bTiled, nCompressFlag, nPhotometric,\n                                panRedMap, panGreenMap, panBlueMap,\n                                bUseSubIFDs );\n        }\n        \n        TIFFClose( hTIFF );\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Cleanup the rawblockedimage files.                              */\n/* -------------------------------------------------------------------- */\n    for( i = 0; i < nOverviews*nSamples; i++ )\n    {\n        delete papoRawBIs[i];\n    }\n\n    if( papoRawBIs != NULL )\n        free( papoRawBIs );\n\n    if( panRedMap != NULL )\n    {\n        free( panRedMap );\n        free( panGreenMap );\n        free( panBlueMap );\n    }\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.data;\n    int step = (int)img.step;\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        int tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        int photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        int bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled &&\n            TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 )) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 )\n                tile_height0 = m_height;\n\n            AutoBuffer<uchar> _buffer(tile_height0*tile_width0*8);\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                    icvCvt_BGRA2BGR_8u_C4C3R( buffer + i*tile_width*4, 0,\n                                                             data + x*3 + step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( buffer + i*tile_width*4, 0,\n                                                              data + x + step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width*ncn, 0,\n                                                                  (ushort*)(data + step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + step*i)+x,\n                                               buffer16 + i*tile_width*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + step*i)+x,\n                                           buffer32 + i*tile_width*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + step*i)+x,\n                                         buffer64 + i*tile_width*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    close();\n    return result;\n}",
    "bool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    TIFF* tif = TIFFOpen( m_filename.c_str(), \"rb\" );\n\n    if( tif )\n    {\n        int width = 0, height = 0, photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &width ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &height ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            int bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n            \n            m_width = width;\n            m_height = height;\n            if( bpp > 8 &&\n               ((photometric != 2 && photometric != 1) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? 3 : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? 3 : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}",
    "GTiffRasterBand::GTiffRasterBand( GTiffDataset *poDS, int nBand )\n\n{\n    poGDS = poDS;\n\n    this->poDS = poDS;\n    this->nBand = nBand;\n\n    bHaveOffsetScale = FALSE;\n    dfOffset = 0.0;\n    dfScale = 1.0;\n\n/* -------------------------------------------------------------------- */\n/*      Get the GDAL data type.                                         */\n/* -------------------------------------------------------------------- */\n    uint16\t\tnSampleFormat = poDS->nSampleFormat;\n\n    eDataType = GDT_Unknown;\n\n    if( poDS->nBitsPerSample <= 8 )\n    {\n        eDataType = GDT_Byte;\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            SetMetadataItem( \"PIXELTYPE\", \"SIGNEDBYTE\", \"IMAGE_STRUCTURE\" );\n            \n    }\n    else if( poDS->nBitsPerSample <= 16 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int16;\n        else\n            eDataType = GDT_UInt16;\n    }\n    else if( poDS->nBitsPerSample == 32 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt16;\n        else if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float32;\n        else if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int32;\n        else\n            eDataType = GDT_UInt32;\n    }\n    else if( poDS->nBitsPerSample == 64 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float64;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat32;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt32;\n    }\n    else if( poDS->nBitsPerSample == 128 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat64;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try to work out band color interpretation.                      */\n/* -------------------------------------------------------------------- */\n    if( poDS->poColorTable != NULL && nBand == 1 ) \n        eBandInterp = GCI_PaletteIndex;\n    else if( poDS->nPhotometric == PHOTOMETRIC_RGB \n             || (poDS->nPhotometric == PHOTOMETRIC_YCBCR \n                 && poDS->nCompression == COMPRESSION_JPEG \n                 && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                       \"YES\") )) )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_RedBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_GreenBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_BlueBand;\n        else\n        {\n            uint16 *v;\n            uint16 count = 0;\n\n            if( TIFFGetField( poDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v) )\n            {\n                if( nBand - 3 <= count && v[nBand-4] == EXTRASAMPLE_ASSOCALPHA )\n                    eBandInterp = GCI_AlphaBand;\n                else\n                    eBandInterp = GCI_Undefined;\n            }\n            else if( nBand == 4 )\n                eBandInterp = GCI_AlphaBand;\n            else\n                eBandInterp = GCI_Undefined;\n        }\n    }\n    else if( poDS->nPhotometric == PHOTOMETRIC_YCBCR )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_YCbCr_YBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_YCbCr_CbBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_YCbCr_CrBand;\n        else\n        {\n            uint16 *v;\n            uint16 count = 0;\n\n            if( TIFFGetField( poDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v) )\n            {\n                if( nBand - 3 <= count && v[nBand-4] == EXTRASAMPLE_ASSOCALPHA )\n                    eBandInterp = GCI_AlphaBand;\n                else\n                    eBandInterp = GCI_Undefined;\n            }\n            else if( nBand == 4 )\n                eBandInterp = GCI_AlphaBand;\n            else\n                eBandInterp = GCI_Undefined;\n        }\n    }\n    else if( poDS->nPhotometric == PHOTOMETRIC_SEPARATED )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_CyanBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_MagentaBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_YellowBand;\n        else\n            eBandInterp = GCI_BlackBand;\n    }\n    else if( poDS->nPhotometric == PHOTOMETRIC_MINISBLACK && nBand == 1 )\n        eBandInterp = GCI_GrayIndex;\n    else\n    {\n        uint16 *v;\n        uint16 count = 0;\n\n        if( TIFFGetField( poDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            int nBaseSamples;\n            nBaseSamples = poDS->nSamplesPerPixel - count;\n\n            if( nBand > nBaseSamples \n                && v[nBand-nBaseSamples-1] == EXTRASAMPLE_ASSOCALPHA )\n                eBandInterp = GCI_AlphaBand;\n            else\n                eBandInterp = GCI_Undefined;\n        }\n        else\n            eBandInterp = GCI_Undefined;\n    }\n\n/* -------------------------------------------------------------------- */\n/*\tEstablish block size for strip or tiles.\t\t\t*/\n/* -------------------------------------------------------------------- */\n    nBlockXSize = poDS->nBlockXSize;\n    nBlockYSize = poDS->nBlockYSize;\n\n    bNoDataSet = FALSE;\n    dfNoDataValue = -9999.0;\n}",
    "void GTiffDataset::FillEmptyTiles()\n\n{\n    toff_t *panByteCounts = NULL;\n    int    nBlockCount, iBlock;\n\n    if (!SetDirectory())\n        return;\n\n/* -------------------------------------------------------------------- */\n/*      How many blocks are there in this file?                         */\n/* -------------------------------------------------------------------- */\n    if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockCount = nBlocksPerBand * nBands;\n    else\n        nBlockCount = nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Fetch block maps.                                               */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled( hTIFF ) )\n        TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts );\n    else\n        TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts );\n\n/* -------------------------------------------------------------------- */\n/*      Prepare a blank data buffer to write for uninitialized blocks.  */\n/* -------------------------------------------------------------------- */\n    int nBlockBytes;\n\n    if( TIFFIsTiled( hTIFF ) )\n        nBlockBytes = TIFFTileSize(hTIFF);\n    else\n        nBlockBytes = TIFFStripSize(hTIFF);\n\n    GByte *pabyData = (GByte *) VSICalloc(nBlockBytes,1);\n    if (pabyData == NULL)\n    {\n        CPLError(CE_Failure, CPLE_OutOfMemory,\n                 \"Cannot allocate %d bytes\", nBlockBytes);\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check all blocks, writing out data for uninitialized blocks.    */\n/* -------------------------------------------------------------------- */\n    for( iBlock = 0; iBlock < nBlockCount; iBlock++ )\n    {\n        if( panByteCounts[iBlock] == 0 )\n            WriteEncodedTileOrStrip( iBlock, pabyData, FALSE );\n    }\n\n    CPLFree( pabyData );\n}",
    "void GTiffDataset::Crystalize()\n\n{\n    if( !bCrystalized )\n    {\n        WriteMetadata( this, hTIFF, TRUE, osProfile, osFilename,\n                       papszCreationOptions );\n        WriteGeoTIFFInfo();\n\n        bMetadataChanged = FALSE;\n        bGeoTIFFInfoChanged = FALSE;\n        bNeedsRewrite = FALSE;\n\n        bCrystalized = TRUE;\n\n        TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTiffDataset::Crystalize\");\n\n \t// Keep zip and tiff quality, and jpegcolormode which get reset when we call \n        // TIFFWriteDirectory \n        int jquality = -1, zquality = -1, nColorMode = -1; \n        TIFFGetField(hTIFF, TIFFTAG_JPEGQUALITY, &jquality); \n        TIFFGetField(hTIFF, TIFFTAG_ZIPQUALITY, &zquality); \n        TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode );\n\n        TIFFWriteDirectory( hTIFF );\n        TIFFSetDirectory( hTIFF, 0 );\n\n\n        // Now, reset zip and tiff quality and jpegcolormode. \n        if(jquality > 0) \n            TIFFSetField(hTIFF, TIFFTAG_JPEGQUALITY, jquality); \n        if(zquality > 0) \n            TIFFSetField(hTIFF, TIFFTAG_ZIPQUALITY, zquality);\n        if (nColorMode >= 0)\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, nColorMode);\n\n        nDirOffset = TIFFCurrentDirOffset( hTIFF );\n    }\n}",
    "int GTiffDataset::IsBlockAvailable( int nBlockId )\n\n{\n    toff_t *panByteCounts = NULL;\n\n    if( ( TIFFIsTiled( hTIFF ) \n          && TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts ) )\n        || ( !TIFFIsTiled( hTIFF ) \n          && TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts ) ) )\n    {\n        if( panByteCounts == NULL )\n            return FALSE;\n        else\n            return panByteCounts[nBlockId] != 0;\n    }\n    else\n        return FALSE;\n}",
    "CPLErr GTiffDataset::IBuildOverviews( \n    const char * pszResampling, \n    int nOverviews, int * panOverviewList,\n    int nBands, int * panBandList,\n    GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    CPLErr       eErr = CE_None;\n    int          i;\n    GTiffDataset *poODS;\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have read access, then create the overviews         */\n/*      externally.                                                     */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() != GA_Update )\n    {\n        CPLDebug( \"GTiff\",\n                  \"File open for read-only accessing, \"\n                  \"creating overviews externally.\" );\n\n        return GDALDataset::IBuildOverviews( \n            pszResampling, nOverviews, panOverviewList, \n            nBands, panBandList, pfnProgress, pProgressData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If RRD overviews requested, then invoke generic handling.       */\n/* -------------------------------------------------------------------- */\n    if( CSLTestBoolean(CPLGetConfigOption( \"USE_RRD\", \"NO\" )) )\n    {\n        return GDALDataset::IBuildOverviews( \n            pszResampling, nOverviews, panOverviewList, \n            nBands, panBandList, pfnProgress, pProgressData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Our TIFF overview support currently only works safely if all    */\n/*      bands are handled at the same time.                             */\n/* -------------------------------------------------------------------- */\n    if( nBands != GetRasterCount() )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Generation of overviews in TIFF currently only\"\n                  \" supported when operating on all bands.\\n\" \n                  \"Operation failed.\\n\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Initialize progress counter.                                    */\n/* -------------------------------------------------------------------- */\n    if( !pfnProgress( 0.0, NULL, pProgressData ) )\n    {\n        CPLError( CE_Failure, CPLE_UserInterrupt, \"User terminated\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If zero overviews were requested, we need to clear all          */\n/*      existing overviews.                                             */\n/* -------------------------------------------------------------------- */\n    if( nOverviews == 0 )\n    {\n        if( nOverviewCount == 0 )\n            return GDALDataset::IBuildOverviews( \n                pszResampling, nOverviews, panOverviewList, \n                nBands, panBandList, pfnProgress, pProgressData );\n        else\n            return CleanOverviews();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Move to the directory for this dataset.                         */\n/* -------------------------------------------------------------------- */\n    if (!SetDirectory())\n        return CE_Failure;\n    FlushDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      If we are averaging bit data to grayscale we need to create     */\n/*      8bit overviews.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvBitsPerSample = nBitsPerSample;\n\n    if( EQUALN(pszResampling,\"AVERAGE_BIT2\",12) )\n        nOvBitsPerSample = 8;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed, anTGreen, anTBlue;\n    unsigned short      *panRed=NULL, *panGreen=NULL, *panBlue=NULL;\n\n    if( nPhotometric == PHOTOMETRIC_PALETTE && poColorTable != NULL )\n    {\n        int nColors;\n\n        if( nOvBitsPerSample == 8 )\n            nColors = 256;\n        else if( nOvBitsPerSample < 8 )\n            nColors = 1 << nOvBitsPerSample;\n        else\n            nColors = 65536;\n        \n        anTRed.resize(nColors,0);\n        anTGreen.resize(nColors,0);\n        anTBlue.resize(nColors,0);\n        \n        for( int iColor = 0; iColor < nColors; iColor++ )\n        {\n            if( iColor < poColorTable->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poColorTable->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = (unsigned short) (256 * sRGB.c1);\n                anTGreen[iColor] = (unsigned short) (256 * sRGB.c2);\n                anTBlue[iColor] = (unsigned short) (256 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = anTGreen[iColor] = anTBlue[iColor] = 0;\n            }\n        }\n\n        panRed = &(anTRed[0]);\n        panGreen = &(anTGreen[0]);\n        panBlue = &(anTBlue[0]);\n    }\n        \n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( pszResampling, this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = NULL;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples, &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew = (uint16*) CPLMalloc(nExtraSamples * sizeof(uint16));\n        memcpy(panExtraSampleValuesNew, panExtraSampleValues, nExtraSamples * sizeof(uint16));\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = NULL;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Establish which of the overview levels we already have, and     */\n/*      which are new.  We assume that band 1 of the file is            */\n/*      representative.                                                 */\n/* -------------------------------------------------------------------- */\n    for( i = 0; i < nOverviews && eErr == CE_None; i++ )\n    {\n        int   j;\n\n        for( j = 0; j < nOverviewCount; j++ )\n        {\n            int    nOvFactor;\n\n            poODS = papoOverviewDS[j];\n\n            nOvFactor = (int) \n                (0.5 + GetRasterXSize() / (double) poODS->GetRasterXSize());\n\n            if( nOvFactor == panOverviewList[i] \n                || nOvFactor == TIFF_OvLevelAdjust( panOverviewList[i],\n                                                    GetRasterXSize() ) )\n                panOverviewList[i] *= -1;\n        }\n\n        if( panOverviewList[i] > 0 )\n        {\n            toff_t\tnOverviewOffset;\n            int         nOXSize, nOYSize;\n\n            nOXSize = (GetRasterXSize() + panOverviewList[i] - 1) \n                / panOverviewList[i];\n            nOYSize = (GetRasterYSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n\n            nOverviewOffset = \n                GTIFFWriteDirectory(hTIFF, FILETYPE_REDUCEDIMAGE,\n                                    nOXSize, nOYSize, \n                                    nOvBitsPerSample, nPlanarConfig,\n                                    nSamplesPerPixel, 128, 128, TRUE,\n                                    nCompression, nPhotometric, nSampleFormat, \n                                    panRed, panGreen, panBlue,\n                                    nExtraSamples, panExtraSampleValues,\n                                    osMetadata );\n\n            if( nOverviewOffset == 0 )\n            {\n                eErr = CE_Failure;\n                continue;\n            }\n\n            poODS = new GTiffDataset();\n            if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, nOverviewOffset, FALSE, \n                                   GA_Update ) != CE_None )\n            {\n                delete poODS;\n                eErr = CE_Failure;\n            }\n            else\n            {\n                nOverviewCount++;\n                papoOverviewDS = (GTiffDataset **)\n                    CPLRealloc(papoOverviewDS, \n                               nOverviewCount * (sizeof(void*)));\n                papoOverviewDS[nOverviewCount-1] = poODS;\n                poODS->poBaseDS = this;\n            }\n        }\n        else\n            panOverviewList[i] *= -1;\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n\n    if (poMaskDS != NULL &&\n        poMaskDS->GetRasterCount() == 1 &&\n        CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\")))\n    {\n        for( i = 0; i < nOverviewCount; i++ )\n        {\n            if (papoOverviewDS[i]->poMaskDS == NULL)\n            {\n                toff_t\tnOverviewOffset;\n\n                nOverviewOffset = \n                    GTIFFWriteDirectory(hTIFF, FILETYPE_REDUCEDIMAGE | FILETYPE_MASK,\n                                        papoOverviewDS[i]->nRasterXSize, papoOverviewDS[i]->nRasterYSize, \n                                        1, PLANARCONFIG_CONTIG,\n                                        1, 128, 128, TRUE,\n                                        COMPRESSION_NONE, PHOTOMETRIC_MASK, SAMPLEFORMAT_UINT, \n                                        NULL, NULL, NULL, 0, NULL,\n                                        \"\" );\n\n                if( nOverviewOffset == 0 )\n                {\n                    eErr = CE_Failure;\n                    continue;\n                }\n\n                poODS = new GTiffDataset();\n                if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, \n                                       nOverviewOffset, FALSE, \n                                       GA_Update ) != CE_None )\n                {\n                    delete poODS;\n                    eErr = CE_Failure;\n                }\n                else\n                {\n                    poODS->poBaseDS = this;\n                    papoOverviewDS[i]->poMaskDS = poODS;\n                    poMaskDS->nOverviewCount++;\n                    poMaskDS->papoOverviewDS = (GTiffDataset **)\n                    CPLRealloc(poMaskDS->papoOverviewDS, \n                               poMaskDS->nOverviewCount * (sizeof(void*)));\n                    poMaskDS->papoOverviewDS[poMaskDS->nOverviewCount-1] = poODS;\n                }\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Refresh overviews for the mask                                  */\n/* -------------------------------------------------------------------- */\n    if (poMaskDS != NULL &&\n        poMaskDS->GetRasterCount() == 1)\n    {\n        GDALRasterBand **papoOverviewBands;\n        int nMaskOverviews = 0;\n\n        papoOverviewBands = (GDALRasterBand **) CPLCalloc(sizeof(void*),nOverviewCount);\n        for( i = 0; i < nOverviewCount; i++ )\n        {\n            if (papoOverviewDS[i]->poMaskDS != NULL)\n            {\n                papoOverviewBands[nMaskOverviews ++] =\n                        papoOverviewDS[i]->poMaskDS->GetRasterBand(1);\n            }\n        }\n        eErr = GDALRegenerateOverviews( (GDALRasterBandH) \n                                        poMaskDS->GetRasterBand(1),\n                                        nMaskOverviews, \n                                        (GDALRasterBandH *) papoOverviewBands,\n                                        pszResampling, GDALDummyProgress, NULL);\n        CPLFree(papoOverviewBands);\n    }\n\n\n/* -------------------------------------------------------------------- */\n/*      Refresh old overviews that were listed.                         */\n/* -------------------------------------------------------------------- */\n    if (nCompression != COMPRESSION_NONE &&\n        nPlanarConfig == PLANARCONFIG_CONTIG &&\n        GDALDataTypeIsComplex(GetRasterBand( panBandList[0] )->GetRasterDataType()) == FALSE &&\n        GetRasterBand( panBandList[0] )->GetColorTable() == NULL &&\n        (EQUALN(pszResampling, \"NEAR\", 4) || EQUAL(pszResampling, \"AVERAGE\") || EQUAL(pszResampling, \"GAUSS\")))\n    {\n        /* In the case of pixel interleaved compressed overviews, we want to generate */\n        /* the overviews for all the bands block by block, and not band after band, */\n        /* in order to write the block once and not loose space in the TIFF file */\n\n        GDALRasterBand ***papapoOverviewBands;\n        GDALRasterBand  **papoBandList;\n\n        int nNewOverviews = 0;\n        int iBand;\n\n        papapoOverviewBands = (GDALRasterBand ***) CPLCalloc(sizeof(void*),nBands);\n        papoBandList = (GDALRasterBand **) CPLCalloc(sizeof(void*),nBands);\n        for( iBand = 0; iBand < nBands; iBand++ )\n        {\n            GDALRasterBand* poBand = GetRasterBand( panBandList[iBand] );\n\n            papoBandList[iBand] = poBand;\n            papapoOverviewBands[iBand] = (GDALRasterBand **) CPLCalloc(sizeof(void*), poBand->GetOverviewCount());\n\n            int iCurOverview = 0;\n            for( i = 0; i < nOverviews; i++ )\n            {\n                int   j;\n\n                for( j = 0; j < poBand->GetOverviewCount(); j++ )\n                {\n                    int    nOvFactor;\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    nOvFactor = (int) \n                    (0.5 + poBand->GetXSize() / (double) poOverview->GetXSize());\n\n                    int bHasNoData;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if (bHasNoData)\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    if( nOvFactor == panOverviewList[i] \n                        || nOvFactor == TIFF_OvLevelAdjust( panOverviewList[i],\n                                                            poBand->GetXSize() ) )\n                    {\n                        papapoOverviewBands[iBand][iCurOverview] = poOverview;\n                        iCurOverview++ ;\n                        break;\n                    }\n                }\n            }\n\n            if (nNewOverviews == 0)\n                nNewOverviews = iCurOverview;\n            else if (nNewOverviews != iCurOverview)\n            {\n                CPLAssert(0);\n                return CE_Failure;\n            }\n        }\n\n        GDALRegenerateOverviewsMultiBand(nBands, papoBandList,\n                                         nNewOverviews, papapoOverviewBands,\n                                         pszResampling, pfnProgress, pProgressData );\n\n        for( iBand = 0; iBand < nBands; iBand++ )\n        {\n            CPLFree(papapoOverviewBands[iBand]);\n        }\n        CPLFree(papapoOverviewBands);\n        CPLFree(papoBandList);\n    }\n    else\n    {\n        GDALRasterBand **papoOverviewBands;\n\n        papoOverviewBands = (GDALRasterBand **) \n            CPLCalloc(sizeof(void*),nOverviews);\n\n        for( int iBand = 0; iBand < nBands && eErr == CE_None; iBand++ )\n        {\n            GDALRasterBand *poBand;\n            int            nNewOverviews;\n\n            poBand = GetRasterBand( panBandList[iBand] );\n\n            nNewOverviews = 0;\n            for( i = 0; i < nOverviews && poBand != NULL; i++ )\n            {\n                int   j;\n\n                for( j = 0; j < poBand->GetOverviewCount(); j++ )\n                {\n                    int    nOvFactor;\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    int bHasNoData;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if (bHasNoData)\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    nOvFactor = (int) \n                    (0.5 + poBand->GetXSize() / (double) poOverview->GetXSize());\n\n                    if( nOvFactor == panOverviewList[i] \n                        || nOvFactor == TIFF_OvLevelAdjust( panOverviewList[i],\n                                                            poBand->GetXSize() ) )\n                    {\n                        papoOverviewBands[nNewOverviews++] = poOverview;\n                        break;\n                    }\n                }\n            }\n\n            void         *pScaledProgressData;\n\n            pScaledProgressData = \n                GDALCreateScaledProgress( iBand / (double) nBands, \n                                        (iBand+1) / (double) nBands,\n                                        pfnProgress, pProgressData );\n\n            eErr = GDALRegenerateOverviews( (GDALRasterBandH) poBand,\n                                            nNewOverviews, \n                                            (GDALRasterBandH *) papoOverviewBands,\n                                            pszResampling, \n                                            GDALScaledProgress, \n                                            pScaledProgressData);\n\n            GDALDestroyScaledProgress( pScaledProgressData );\n        }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup                                                         */\n    /* -------------------------------------------------------------------- */\n        CPLFree( papoOverviewBands );\n    }\n\n\n    pfnProgress( 1.0, NULL, pProgressData );\n\n    return eErr;\n}",
    "void GTiffDataset::WriteGeoTIFFInfo()\n\n{\n/* -------------------------------------------------------------------- */\n/*      If the geotransform is the default, don't bother writing it.    */\n/* -------------------------------------------------------------------- */\n    if( adfGeoTransform[0] != 0.0 || adfGeoTransform[1] != 1.0\n        || adfGeoTransform[2] != 0.0 || adfGeoTransform[3] != 0.0\n        || adfGeoTransform[4] != 0.0 || ABS(adfGeoTransform[5]) != 1.0 )\n    {\n        bNeedsRewrite = TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      Clear old tags to ensure we don't end up with conflicting       */\n/*      information. (#2625)                                            */\n/* -------------------------------------------------------------------- */\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOPIXELSCALE );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTIEPOINTS );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTRANSMATRIX );\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Write the transform.  If we have a normal north-up image we     */\n/*      use the tiepoint plus pixelscale otherwise we use a matrix.     */\n/* -------------------------------------------------------------------- */\n\tif( adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0 \n            && adfGeoTransform[5] < 0.0 )\n\t{\n\t    double\tadfPixelScale[3], adfTiePoints[6];\n\n\t    adfPixelScale[0] = adfGeoTransform[1];\n\t    adfPixelScale[1] = fabs(adfGeoTransform[5]);\n\t    adfPixelScale[2] = 0.0;\n\n            if( !EQUAL(osProfile,\"BASELINE\") )\n                TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n\t    \n\t    adfTiePoints[0] = 0.0;\n\t    adfTiePoints[1] = 0.0;\n\t    adfTiePoints[2] = 0.0;\n\t    adfTiePoints[3] = adfGeoTransform[0];\n\t    adfTiePoints[4] = adfGeoTransform[3];\n\t    adfTiePoints[5] = 0.0;\n\t    \n            if( !EQUAL(osProfile,\"BASELINE\") )\n                TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n\t}\n\telse\n\t{\n\t    double\tadfMatrix[16];\n\t    \n\t    memset(adfMatrix,0,sizeof(double) * 16);\n\t    \n\t    adfMatrix[0] = adfGeoTransform[1];\n\t    adfMatrix[1] = adfGeoTransform[2];\n\t    adfMatrix[3] = adfGeoTransform[0];\n\t    adfMatrix[4] = adfGeoTransform[4];\n\t    adfMatrix[5] = adfGeoTransform[5];\n\t    adfMatrix[7] = adfGeoTransform[3];\n\t    adfMatrix[15] = 1.0;\n\t    \n            if( !EQUAL(osProfile,\"BASELINE\") )\n                TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n\t}\n\n        // Do we need a world file?\n        if( CSLFetchBoolean( papszCreationOptions, \"TFW\", FALSE ) )\n            GDALWriteWorldFile( osFilename, \"tfw\", adfGeoTransform );\n        else if( CSLFetchBoolean( papszCreationOptions, \"WORLDFILE\", FALSE ) )\n            GDALWriteWorldFile( osFilename, \"wld\", adfGeoTransform );\n    }\n    else if( GetGCPCount() > 0 )\n    {\n\tdouble\t*padfTiePoints;\n\tint\t\tiGCP;\n        bNeedsRewrite = TRUE;\n\t\n\tpadfTiePoints = (double *) \n\t    CPLMalloc( 6 * sizeof(double) * GetGCPCount() );\n\n\tfor( iGCP = 0; iGCP < GetGCPCount(); iGCP++ )\n\t{\n\n\t    padfTiePoints[iGCP*6+0] = pasGCPList[iGCP].dfGCPPixel;\n\t    padfTiePoints[iGCP*6+1] = pasGCPList[iGCP].dfGCPLine;\n\t    padfTiePoints[iGCP*6+2] = 0;\n\t    padfTiePoints[iGCP*6+3] = pasGCPList[iGCP].dfGCPX;\n\t    padfTiePoints[iGCP*6+4] = pasGCPList[iGCP].dfGCPY;\n\t    padfTiePoints[iGCP*6+5] = pasGCPList[iGCP].dfGCPZ;\n\t}\n\n        if( !EQUAL(osProfile,\"BASELINE\") )\n            TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, \n                          6 * GetGCPCount(), padfTiePoints );\n\tCPLFree( padfTiePoints );\n    }\n\n/* -------------------------------------------------------------------- */\n/*\tWrite out projection definition.\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    if( pszProjection != NULL && !EQUAL( pszProjection, \"\" )\n        && !EQUAL(osProfile,\"BASELINE\") )\n    {\n        GTIF\t*psGTIF;\n\n        bNeedsRewrite = TRUE;\n\n        // If we have existing geokeys, try to wipe them\n        // by writing a dummy goekey directory. (#2546)\n        uint16 *panVI = NULL;\n        uint16 nKeyCount;\n\n        if( TIFFGetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY, \n                          &nKeyCount, &panVI ) )\n        {\n            GUInt16 anGKVersionInfo[4] = { 1, 1, 0, 0 };\n            double  adfDummyDoubleParams[1] = { 0.0 };\n            TIFFSetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY, \n                          4, anGKVersionInfo );\n            TIFFSetField( hTIFF, TIFFTAG_GEODOUBLEPARAMS, \n                          1, adfDummyDoubleParams );\n            TIFFSetField( hTIFF, TIFFTAG_GEOASCIIPARAMS, \"\" );\n        }\n\n        psGTIF = GTIFNew( hTIFF );  \n\n        // set according to coordinate system.\n        GTIFSetFromOGISDefn( psGTIF, pszProjection );\n\n        if( GetMetadataItem( GDALMD_AREA_OR_POINT ) \n            && EQUAL(GetMetadataItem(GDALMD_AREA_OR_POINT),\n                     GDALMD_AOP_POINT) )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n}",
    "void GTiffDataset::ReadRPCTag()\n\n{\n    double *padfRPCTag;\n    char **papszMD = NULL;\n    CPLString osField;\n    CPLString osMultiField;\n    int i;\n    uint16 nCount;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, &nCount, &padfRPCTag ) \n        || nCount != 92 )\n        return;\n\n    osField.Printf( \"%.15g\", padfRPCTag[2] );\n    papszMD = CSLSetNameValue( papszMD, \"LINE_OFF\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[3] );\n    papszMD = CSLSetNameValue( papszMD, \"SAMP_OFF\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[4] );\n    papszMD = CSLSetNameValue( papszMD, \"LAT_OFF\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[5] );\n    papszMD = CSLSetNameValue( papszMD, \"LONG_OFF\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[6] );\n    papszMD = CSLSetNameValue( papszMD, \"HEIGHT_OFF\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[7] );\n    papszMD = CSLSetNameValue( papszMD, \"LINE_SCALE\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[8] );\n    papszMD = CSLSetNameValue( papszMD, \"SAMP_SCALE\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[9] );\n    papszMD = CSLSetNameValue( papszMD, \"LAT_SCALE\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[10] );\n    papszMD = CSLSetNameValue( papszMD, \"LONG_SCALE\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[11] );\n    papszMD = CSLSetNameValue( papszMD, \"HEIGHT_SCALE\", osField );\n\n    for( i = 0; i < 20; i++ )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[12+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    papszMD = CSLSetNameValue( papszMD, \"LINE_NUM_COEFF\", osMultiField );\n\n    for( i = 0; i < 20; i++ )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[32+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    papszMD = CSLSetNameValue( papszMD, \"LINE_DEN_COEFF\", osMultiField );\n\n    for( i = 0; i < 20; i++ )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[52+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    papszMD = CSLSetNameValue( papszMD, \"SAMP_NUM_COEFF\", osMultiField );\n\n    for( i = 0; i < 20; i++ )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[72+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    papszMD = CSLSetNameValue( papszMD, \"SAMP_DEN_COEFF\", osMultiField );\n\n    oGTiffMDMD.SetMetadata( papszMD, \"RPC\" );\n    CSLDestroy( papszMD );\n}",
    "int GTiffDataset::SetDirectory( toff_t nNewOffset )\n\n{\n    Crystalize();\n\n    FlushBlockBuf();\n\n    if( nNewOffset == 0 )\n        nNewOffset = nDirOffset;\n\n    if( TIFFCurrentDirOffset(hTIFF) == nNewOffset )\n    {\n        CPLAssert( *ppoActiveDSRef == this || *ppoActiveDSRef == NULL );\n        *ppoActiveDSRef = this;\n        return TRUE;\n    }\n\n    int jquality = -1, zquality = -1; \n\n    if( GetAccess() == GA_Update )\n    {\n        TIFFGetField(hTIFF, TIFFTAG_JPEGQUALITY, &jquality); \n        TIFFGetField(hTIFF, TIFFTAG_ZIPQUALITY, &zquality); \n\n        if( *ppoActiveDSRef != NULL )\n            (*ppoActiveDSRef)->FlushDirectory();\n    }\n    \n    if( nNewOffset == 0)\n        return TRUE;\n\n    (*ppoActiveDSRef) = this;\n\n    int nSetDirResult = TIFFSetSubDirectory( hTIFF, nNewOffset );\n    if (!nSetDirResult)\n        return nSetDirResult;\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n    \n    if( nCompression == COMPRESSION_JPEG \n        && nPhotometric == PHOTOMETRIC_YCBCR \n        && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode;\n\n        TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode );\n        if( nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Propogate any quality settings.                                 */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() == GA_Update )\n    {\n        // Now, reset zip and jpeg quality. \n        if(jquality > 0) \n        {\n            CPLDebug( \"GTiff\", \"Propgate JPEG_QUALITY(%d) in SetDirectory()\",\n                      jquality );\n            TIFFSetField(hTIFF, TIFFTAG_JPEGQUALITY, jquality); \n        }\n        if(zquality > 0) \n            TIFFSetField(hTIFF, TIFFTAG_ZIPQUALITY, zquality);\n    }\n\n    return nSetDirResult;\n}",
    "CPLErr GTiffDataset::OpenOffset( TIFF *hTIFFIn, \n                                 GTiffDataset **ppoActiveDSRef,\n                                 toff_t nDirOffsetIn, \n\t\t\t\t int bBaseIn, GDALAccess eAccess,\n                                 int bAllowRGBAInterface)\n\n{\n    uint32\tnXSize, nYSize;\n    int\t\tbTreatAsBitmap = FALSE;\n    int         bTreatAsOdd = FALSE;\n\n    this->eAccess = eAccess;\n\n    hTIFF = hTIFFIn;\n    this->ppoActiveDSRef = ppoActiveDSRef;\n\n    nDirOffset = nDirOffsetIn;\n\n    if (!SetDirectory( nDirOffsetIn ))\n        return CE_Failure;\n\n    bBase = bBaseIn;\n\n    this->eAccess = eAccess;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some information from the file that is of interest.     */\n/* -------------------------------------------------------------------- */\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    nRasterXSize = nXSize;\n    nRasterYSize = nYSize;\n\n    if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSamplesPerPixel ) )\n        nBands = 1;\n    else\n        nBands = nSamplesPerPixel;\n    \n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &(nBitsPerSample)) )\n        nBitsPerSample = 1;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &(nPlanarConfig) ) )\n        nPlanarConfig = PLANARCONFIG_CONTIG;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLEFORMAT, &(nSampleFormat) ) )\n        nSampleFormat = SAMPLEFORMAT_UINT;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n    \n#if defined(TIFFLIB_VERSION) && TIFFLIB_VERSION > 20031007 /* 3.6.0 */\n    if (nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(nCompression))\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Cannot open TIFF file due to missing codec.\" );\n        return CE_Failure;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( nCompression == COMPRESSION_JPEG \n        && nPhotometric == PHOTOMETRIC_YCBCR \n        && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode;\n\n        SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\" );\n        if ( !TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n              nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get strip/tile layout.                                          */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled(hTIFF) )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(nBlockXSize) );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(nRowsPerStrip) ) )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined, \n                      \"RowsPerStrip not defined ... assuming all one strip.\" );\n            nRowsPerStrip = nYSize; /* dummy value */\n        }\n\n        nBlockXSize = nRasterXSize;\n        nBlockYSize = MIN(nRowsPerStrip,nYSize);\n    }\n        \n    nBlocksPerBand =\n        ((nYSize + nBlockYSize - 1) / nBlockYSize)\n        * ((nXSize + nBlockXSize  - 1) / nBlockXSize);\n\n/* -------------------------------------------------------------------- */\n/*      Should we handle this using the GTiffBitmapBand?                */\n/* -------------------------------------------------------------------- */\n    if( nBitsPerSample == 1 && nBands == 1 )\n    {\n        bTreatAsBitmap = TRUE;\n\n        // Lets treat large \"one row\" bitmaps using the scanline api.\n        if( !TIFFIsTiled(hTIFF) \n            && nBlockYSize == nYSize \n            && nYSize > 2000 \n            && bAllowRGBAInterface )\n            bTreatAsSplitBitmap = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the RGBA interface?                    */\n/* -------------------------------------------------------------------- */\n    if( bAllowRGBAInterface &&\n        !bTreatAsBitmap && !(nBitsPerSample > 8) \n        && (nPhotometric == PHOTOMETRIC_CIELAB ||\n            nPhotometric == PHOTOMETRIC_LOGL ||\n            nPhotometric == PHOTOMETRIC_LOGLUV ||\n            nPhotometric == PHOTOMETRIC_SEPARATED ||\n            ( nPhotometric == PHOTOMETRIC_YCBCR \n              && nCompression != COMPRESSION_JPEG )) )\n    {\n        char\tszMessage[1024];\n\n        if( TIFFRGBAImageOK( hTIFF, szMessage ) == 1 )\n        {\n            const char* pszSourceColorSpace = NULL;\n            switch (nPhotometric)\n            {\n                case PHOTOMETRIC_CIELAB:\n                    pszSourceColorSpace = \"CIELAB\";\n                    break;\n                case PHOTOMETRIC_LOGL:\n                    pszSourceColorSpace = \"LOGL\";\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    pszSourceColorSpace = \"LOGLUV\";\n                    break;\n                case PHOTOMETRIC_SEPARATED:\n                    pszSourceColorSpace = \"CMYK\";\n                    break;\n                case PHOTOMETRIC_YCBCR:\n                    pszSourceColorSpace = \"YCbCr\";\n                    break;\n            }\n            if (pszSourceColorSpace)\n                SetMetadataItem( \"SOURCE_COLOR_SPACE\", pszSourceColorSpace, \"IMAGE_STRUCTURE\" );\n            bTreatAsRGBA = TRUE;\n            nBands = 4;\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"TIFFRGBAImageOK says:\\n%s\", szMessage );\n        }\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the split interface?                   */\n/* -------------------------------------------------------------------- */\n    if( !TIFFIsTiled(hTIFF) \n        && nBitsPerSample == 8\n        && nBlockYSize == nYSize \n        && nYSize > 2000\n        && !bTreatAsRGBA \n        && CSLTestBoolean(CPLGetConfigOption(\"GDAL_ENABLE_TIFF_SPLIT\", \"YES\")))\n    {\n        /* libtiff 3.9.2 (20091104) and older, libtiff 4.0.0beta5 (also 20091104) */\n        /* and older will crash when trying to open a all-in-one-strip */\n        /* YCbCr JPEG compressed TIFF (see #3259). BUG_3259_FIXED is defined */\n        /* in internal libtiff tif_config.h until a 4.0.0beta6 is released */\n#if (TIFFLIB_VERSION <= 20091104 && !defined(BIGTIFF_SUPPORT)) || \\\n    (TIFFLIB_VERSION <= 20091104 && defined(BIGTIFF_SUPPORT) && !defined(BUG_3259_FIXED))\n        if (nPhotometric == PHOTOMETRIC_YCBCR  &&\n            nCompression == COMPRESSION_JPEG)\n        {\n            CPLDebug(\"GTiff\", \"Avoid using split band to open all-in-one-strip \"\n                              \"YCbCr JPEG compressed TIFF because of older libtiff\");\n        }\n        else\n#endif\n            bTreatAsSplit = TRUE;\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the odd bits interface?                */\n/* -------------------------------------------------------------------- */\n    if ( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n    {\n        if ( nBitsPerSample == 16 || nBitsPerSample == 24 )\n            bTreatAsOdd = TRUE;\n    }\n    else if ( !bTreatAsRGBA && !bTreatAsBitmap\n              && nBitsPerSample != 8\n              && nBitsPerSample != 16\n              && nBitsPerSample != 32\n              && nBitsPerSample != 64 \n              && nBitsPerSample != 128 )\n        bTreatAsOdd = TRUE;\n\n    int bMinIsWhite = nPhotometric == PHOTOMETRIC_MINISWHITE;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the color table if there is one.                        */\n/* -------------------------------------------------------------------- */\n    unsigned short\t*panRed, *panGreen, *panBlue;\n\n    if( bTreatAsRGBA \n        || TIFFGetField( hTIFF, TIFFTAG_COLORMAP, \n                         &panRed, &panGreen, &panBlue) == 0 )\n    {\n\t// Build inverted palette if we have inverted photometric.\n\t// Pixel values remains unchanged.  Avoid doing this for *deep*\n        // data types (per #1882)\n\tif( nBitsPerSample <= 16 && nPhotometric == PHOTOMETRIC_MINISWHITE )\n\t{\n\t    GDALColorEntry  oEntry;\n\t    int\t\t    iColor, nColorCount;\n\t    \n\t    poColorTable = new GDALColorTable();\n\t    nColorCount = 1 << nBitsPerSample;\n\n\t    for ( iColor = 0; iColor < nColorCount; iColor++ )\n\t    {\n\t\toEntry.c1 = oEntry.c2 = oEntry.c3 = (short) \n                    ((255 * (nColorCount - 1 - iColor)) / (nColorCount-1));\n\t\toEntry.c4 = 255;\n\t\tpoColorTable->SetColorEntry( iColor, &oEntry );\n\t    }\n\n\t    nPhotometric = PHOTOMETRIC_PALETTE;\n\t}\n\telse\n\t    poColorTable = NULL;\n    }\n    else\n    {\n        int\tnColorCount, nMaxColor = 0;\n        GDALColorEntry oEntry;\n\n        poColorTable = new GDALColorTable();\n\n        nColorCount = 1 << nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            oEntry.c1 = panRed[iColor] / 256;\n            oEntry.c2 = panGreen[iColor] / 256;\n            oEntry.c3 = panBlue[iColor] / 256;\n            oEntry.c4 = 255;\n\n            poColorTable->SetColorEntry( iColor, &oEntry );\n\n            nMaxColor = MAX(nMaxColor,panRed[iColor]);\n            nMaxColor = MAX(nMaxColor,panGreen[iColor]);\n            nMaxColor = MAX(nMaxColor,panBlue[iColor]);\n        }\n\n        // Bug 1384 - Some TIFF files are generated with color map entry\n        // values in range 0-255 instead of 0-65535 - try to handle these\n        // gracefully.\n        if( nMaxColor > 0 && nMaxColor < 256 )\n        {\n            CPLDebug( \"GTiff\", \"TIFF ColorTable seems to be improperly scaled, fixing up.\" );\n            \n            for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n            {\n                oEntry.c1 = panRed[iColor];\n                oEntry.c2 = panGreen[iColor];\n                oEntry.c3 = panBlue[iColor];\n                oEntry.c4 = 255;\n                \n                poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n        }\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < nBands; iBand++ )\n    {\n        if( bTreatAsRGBA )\n            SetBand( iBand+1, new GTiffRGBABand( this, iBand+1 ) );\n        else if( bTreatAsSplitBitmap )\n            SetBand( iBand+1, new GTiffSplitBitmapBand( this, iBand+1 ) );\n        else if( bTreatAsSplit )\n            SetBand( iBand+1, new GTiffSplitBand( this, iBand+1 ) );\n        else if( bTreatAsBitmap )\n            SetBand( iBand+1, new GTiffBitmapBand( this, iBand+1 ) );\n        else if( bTreatAsOdd )\n            SetBand( iBand+1, new GTiffOddBitsBand( this, iBand+1 ) );\n        else\n            SetBand( iBand+1, new GTiffRasterBand( this, iBand+1 ) );\n    }\n\n    if( GetRasterBand(1)->GetRasterDataType() == GDT_Unknown )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Unsupported TIFF configuration.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get the transform or gcps from the GeoTIFF file.                */\n/* -------------------------------------------------------------------- */\n    if( bBaseIn )\n    {\n        char    *pszTabWKT = NULL;\n        double\t*padfTiePoints, *padfScale, *padfMatrix;\n        uint16\tnCount;\n\n        adfGeoTransform[0] = 0.0;\n        adfGeoTransform[1] = 1.0;\n        adfGeoTransform[2] = 0.0;\n        adfGeoTransform[3] = 0.0;\n        adfGeoTransform[4] = 0.0;\n        adfGeoTransform[5] = 1.0;\n    \n        if( TIFFGetField(hTIFF,TIFFTAG_GEOPIXELSCALE,&nCount,&padfScale )\n            && nCount >= 2 \n            && padfScale[0] != 0.0 && padfScale[1] != 0.0 )\n        {\n            adfGeoTransform[1] = padfScale[0];\n            adfGeoTransform[5] = - ABS(padfScale[1]);\n\n            if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n                && nCount >= 6 )\n            {\n                adfGeoTransform[0] =\n                    padfTiePoints[3] - padfTiePoints[0] * adfGeoTransform[1];\n                adfGeoTransform[3] =\n                    padfTiePoints[4] - padfTiePoints[1] * adfGeoTransform[5];\n\n                bGeoTransformValid = TRUE;\n            }\n        }\n\n        else if( TIFFGetField(hTIFF,TIFFTAG_GEOTRANSMATRIX,&nCount,&padfMatrix ) \n                 && nCount == 16 )\n        {\n            adfGeoTransform[0] = padfMatrix[3];\n            adfGeoTransform[1] = padfMatrix[0];\n            adfGeoTransform[2] = padfMatrix[1];\n            adfGeoTransform[3] = padfMatrix[7];\n            adfGeoTransform[4] = padfMatrix[4];\n            adfGeoTransform[5] = padfMatrix[5];\n            bGeoTransformValid = TRUE;\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise try looking for a .tfw, .tifw or .wld file.           */\n/* -------------------------------------------------------------------- */\n        else\n        {\n            bGeoTransformValid = \n                GDALReadWorldFile( osFilename, NULL, adfGeoTransform );\n\n            if( !bGeoTransformValid )\n            {\n                bGeoTransformValid = \n                    GDALReadWorldFile( osFilename, \"wld\", adfGeoTransform );\n            }\n\n            if( !bGeoTransformValid )\n            {\n                int bTabFileOK = \n                    GDALReadTabFile( osFilename, adfGeoTransform, \n                                     &pszTabWKT, &nGCPCount, &pasGCPList );\n\n                if( bTabFileOK && nGCPCount == 0 )\n                    bGeoTransformValid = TRUE;\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Check for GCPs.  Note, we will allow there to be GCPs and a     */\n/*      transform in some circumstances.                                */\n/* -------------------------------------------------------------------- */\n        if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && !bGeoTransformValid )\n        {\n            nGCPCount = nCount / 6;\n            pasGCPList = (GDAL_GCP *) CPLCalloc(sizeof(GDAL_GCP),nGCPCount);\n        \n            for( int iGCP = 0; iGCP < nGCPCount; iGCP++ )\n            {\n                char\tszID[32];\n\n                sprintf( szID, \"%d\", iGCP+1 );\n                pasGCPList[iGCP].pszId = CPLStrdup( szID );\n                pasGCPList[iGCP].pszInfo = CPLStrdup(\"\");\n                pasGCPList[iGCP].dfGCPPixel = padfTiePoints[iGCP*6+0];\n                pasGCPList[iGCP].dfGCPLine = padfTiePoints[iGCP*6+1];\n                pasGCPList[iGCP].dfGCPX = padfTiePoints[iGCP*6+3];\n                pasGCPList[iGCP].dfGCPY = padfTiePoints[iGCP*6+4];\n                pasGCPList[iGCP].dfGCPZ = padfTiePoints[iGCP*6+5];\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Did we find a tab file?  If so we will use it's coordinate      */\n/*      system and give it precidence.                                  */\n/* -------------------------------------------------------------------- */\n        if( pszTabWKT != NULL \n            && (pszProjection == NULL || pszProjection[0] == '\\0') )\n        {\n            CPLFree( pszProjection );\n            pszProjection = pszTabWKT;\n            pszTabWKT = NULL;\n            bLookedForProjection = TRUE;\n        }\n        \n        CPLFree( pszTabWKT );\n        bGeoTIFFInfoChanged = FALSE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture some other potentially interesting information.         */\n/* -------------------------------------------------------------------- */\n    char\t*pszText, szWorkMDI[200];\n    float   fResolution;\n    uint16  nShort;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_DOCUMENTNAME, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_DOCUMENTNAME\",  pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_IMAGEDESCRIPTION, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_IMAGEDESCRIPTION\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_SOFTWARE, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_SOFTWARE\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_DATETIME, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_DATETIME\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_ARTIST, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_ARTIST\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_HOSTCOMPUTER, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_HOSTCOMPUTER\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_COPYRIGHT, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_COPYRIGHT\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_XRESOLUTION, &fResolution ) )\n    {\n        sprintf( szWorkMDI, \"%.8g\", fResolution );\n        SetMetadataItem( \"TIFFTAG_XRESOLUTION\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_YRESOLUTION, &fResolution ) )\n    {\n        sprintf( szWorkMDI, \"%.8g\", fResolution );\n        SetMetadataItem( \"TIFFTAG_YRESOLUTION\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_MINSAMPLEVALUE, &nShort ) )\n    {\n        sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_MINSAMPLEVALUE\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_MAXSAMPLEVALUE, &nShort ) )\n    {\n        sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_MAXSAMPLEVALUE\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, &nShort ) )\n    {\n        if( nShort == RESUNIT_NONE )\n            sprintf( szWorkMDI, \"%d (unitless)\", nShort );\n        else if( nShort == RESUNIT_INCH )\n            sprintf( szWorkMDI, \"%d (pixels/inch)\", nShort );\n        else if( nShort == RESUNIT_CENTIMETER )\n            sprintf( szWorkMDI, \"%d (pixels/cm)\", nShort );\n        else\n            sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_RESOLUTIONUNIT\", szWorkMDI );\n    }\n\n    if( nCompression == COMPRESSION_NONE )\n        /* no compression tag */;\n    else if( nCompression == COMPRESSION_CCITTRLE )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTRLE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTFAX3 )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTFAX3\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTFAX4 )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTFAX4\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_LZW )\n        SetMetadataItem( \"COMPRESSION\", \"LZW\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_OJPEG )\n        SetMetadataItem( \"COMPRESSION\", \"OJPEG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JPEG )\n    {  \n        if ( nPhotometric == PHOTOMETRIC_YCBCR )\n            SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\", \"IMAGE_STRUCTURE\" );\n        else\n            SetMetadataItem( \"COMPRESSION\", \"JPEG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_NEXT )\n        SetMetadataItem( \"COMPRESSION\", \"NEXT\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTRLEW )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTRLEW\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PACKBITS )\n        SetMetadataItem( \"COMPRESSION\", \"PACKBITS\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_THUNDERSCAN )\n        SetMetadataItem( \"COMPRESSION\", \"THUNDERSCAN\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PIXARFILM )\n        SetMetadataItem( \"COMPRESSION\", \"PIXARFILM\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PIXARLOG )\n        SetMetadataItem( \"COMPRESSION\", \"PIXARLOG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_DEFLATE )\n        SetMetadataItem( \"COMPRESSION\", \"DEFLATE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_ADOBE_DEFLATE )\n        SetMetadataItem( \"COMPRESSION\", \"DEFLATE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_DCS )\n        SetMetadataItem( \"COMPRESSION\", \"DCS\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JBIG )\n        SetMetadataItem( \"COMPRESSION\", \"JBIG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_SGILOG )\n        SetMetadataItem( \"COMPRESSION\", \"SGILOG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_SGILOG24 )\n        SetMetadataItem( \"COMPRESSION\", \"SGILOG24\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JP2000 )\n        SetMetadataItem( \"COMPRESSION\", \"JP2000\", \"IMAGE_STRUCTURE\" );\n    else\n    {\n        CPLString oComp;\n        SetMetadataItem( \"COMPRESSION\", \n                         (const char *) oComp.Printf( \"%d\", nCompression));\n    }\n\n    if( nPlanarConfig == PLANARCONFIG_CONTIG && nBands != 1 )\n        SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    if(  (GetRasterBand(1)->GetRasterDataType() == GDT_Byte   && nBitsPerSample != 8 ) ||\n         (GetRasterBand(1)->GetRasterDataType() == GDT_UInt16 && nBitsPerSample != 16) ||\n         (GetRasterBand(1)->GetRasterDataType() == GDT_UInt32 && nBitsPerSample != 32) )\n    {\n        for (int i = 0; i < nBands; ++i)\n            GetRasterBand(i+1)->SetMetadataItem( \"NBITS\", \n                                                 CPLString().Printf( \"%d\", (int)nBitsPerSample ),\n                                                 \"IMAGE_STRUCTURE\" );\n    }\n        \n    if( bMinIsWhite )\n        SetMetadataItem( \"MINISWHITE\", \"YES\", \"IMAGE_STRUCTURE\" );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n    {\n        CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n        CPLXMLNode *psItem = NULL;\n\n        if( psRoot != NULL && psRoot->eType == CXT_Element\n            && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n            psItem = psRoot->psChild;\n\n        for( ; psItem != NULL; psItem = psItem->psNext )\n        {\n            const char *pszKey, *pszValue, *pszRole, *pszDomain; \n            char *pszUnescapedValue;\n            int nBand, bIsXML = FALSE;\n\n            if( psItem->eType != CXT_Element\n                || !EQUAL(psItem->pszValue,\"Item\") )\n                continue;\n\n            pszKey = CPLGetXMLValue( psItem, \"name\", NULL );\n            pszValue = CPLGetXMLValue( psItem, NULL, NULL );\n            nBand = atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" )) + 1;\n            pszRole = CPLGetXMLValue( psItem, \"role\", \"\" );\n            pszDomain = CPLGetXMLValue( psItem, \"domain\", \"\" );\n                \n            if( pszKey == NULL || pszValue == NULL )\n                continue;\n\n            if( EQUALN(pszDomain,\"xml:\",4) )\n                bIsXML = TRUE;\n\n            pszUnescapedValue = CPLUnescapeString( pszValue, NULL, \n                                                   CPLES_XML );\n            if( nBand == 0 )\n            {\n                if( bIsXML )\n                {\n                    char *apszMD[2] = { pszUnescapedValue, NULL };\n                    SetMetadata( apszMD, pszDomain );\n                }\n                else\n                    SetMetadataItem( pszKey, pszUnescapedValue, pszDomain );\n            }\n            else\n            {\n                GDALRasterBand *poBand = GetRasterBand(nBand);\n                if( poBand != NULL )\n                {\n                    if( EQUAL(pszRole,\"scale\") )\n                        poBand->SetScale( atof(pszUnescapedValue) );\n                    else if( EQUAL(pszRole,\"offset\") )\n                        poBand->SetOffset( atof(pszUnescapedValue) );\n                    else if( EQUAL(pszRole,\"unittype\") )\n                        poBand->SetUnitType( pszUnescapedValue );\n                    else\n                    {\n                        if( bIsXML )\n                        {\n                            char *apszMD[2] = { pszUnescapedValue, NULL };\n                            poBand->SetMetadata( apszMD, pszDomain );\n                        }\n                        else\n                            poBand->SetMetadataItem(pszKey,pszUnescapedValue,\n                                                    pszDomain );\n                    }\n                }\n            }\n            CPLFree( pszUnescapedValue );\n        }\n\n        CPLDestroyXMLNode( psRoot );\n    }\n\n    bMetadataChanged = FALSE;\n\n/* -------------------------------------------------------------------- */\n/*      Check for RPC metadata in an RPB file.                          */\n/* -------------------------------------------------------------------- */\n    if( bBaseIn )\n    {\n        char **papszRPCMD = GDALLoadRPBFile( osFilename, NULL );\n        \n        if( papszRPCMD != NULL )\n        {\n            oGTiffMDMD.SetMetadata( papszRPCMD, \"RPC\" );\n            CSLDestroy( papszRPCMD );\n            bMetadataChanged = FALSE;\n        }\n        else\n            ReadRPCTag();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check for RPC metadata in an RPB file.                          */\n/* -------------------------------------------------------------------- */\n    if( bBaseIn )\n    {\n        char **papszIMDMD = GDALLoadIMDFile( osFilename, NULL );\n\n        if( papszIMDMD != NULL )\n        {\n            oGTiffMDMD.SetMetadata( papszIMDMD, \"IMD\" );\n            CSLDestroy( papszIMDMD );\n            bMetadataChanged = FALSE;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check for NODATA                                                */\n/* -------------------------------------------------------------------- */\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_NODATA, &pszText ) )\n    {\n        bNoDataSet = TRUE;\n        dfNoDataValue = atof( pszText );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If this is a \"base\" raster, we should scan for any              */\n/*      associated overviews, internal mask bands and subdatasets.      */\n/* -------------------------------------------------------------------- */\n    if( bBase )\n    {\n        char **papszSubdatasets = NULL;\n        int  iDirIndex = 0;\n\n        FlushDirectory();  \n        while( !TIFFLastDirectory( hTIFF ) \n               && (iDirIndex == 0 || TIFFReadDirectory( hTIFF ) != 0) )\n        {\n            toff_t\tnThisDir = TIFFCurrentDirOffset(hTIFF);\n            uint32\tnSubType = 0;\n\n            *ppoActiveDSRef = NULL; // our directory no longer matches this ds\n            \n            iDirIndex++;\n\n            if( !TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n                nSubType = 0;\n\n            /* Embedded overview of the main image */\n            if ((nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                (nSubType & FILETYPE_MASK) == 0 &&\n                iDirIndex != 1 )\n            {\n                GTiffDataset\t*poODS;\n                \n                poODS = new GTiffDataset();\n                if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE, \n                                       eAccess ) != CE_None \n                    || poODS->GetRasterCount() != GetRasterCount() )\n                {\n                    delete poODS;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened %dx%d overview.\\n\", \n                              poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                    nOverviewCount++;\n                    papoOverviewDS = (GTiffDataset **)\n                        CPLRealloc(papoOverviewDS, \n                                   nOverviewCount * (sizeof(void*)));\n                    papoOverviewDS[nOverviewCount-1] = poODS;\n                    poODS->poBaseDS = this;\n                }\n            }\n            \n            /* Embedded mask of the main image */\n            else if ((nSubType & FILETYPE_MASK) != 0 &&\n                     (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                     poMaskDS == NULL )\n            {\n                poMaskDS = new GTiffDataset();\n                \n                /* The TIFF6 specification - page 37 - only allows 1 SamplesPerPixel and 1 BitsPerSample\n                   Here we support either 1 or 8 bit per sample\n                   and we support either 1 sample per pixel or as many samples as in the main image\n                   We don't check the value of the PhotometricInterpretation tag, which should be\n                   set to \"Transparency mask\" (4) according to the specification (page 36)\n                   ... But the TIFF6 specification allows image masks to have a higher resolution than\n                   the main image, what we don't support here\n                */\n\n                if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, \n                                          FALSE, eAccess ) != CE_None \n                    || poMaskDS->GetRasterCount() == 0\n                    || !(poMaskDS->GetRasterCount() == 1 || poMaskDS->GetRasterCount() == GetRasterCount())\n                    || poMaskDS->GetRasterXSize() != GetRasterXSize()\n                    || poMaskDS->GetRasterYSize() != GetRasterYSize()\n                    || poMaskDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poMaskDS;\n                    poMaskDS = NULL;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened band mask.\\n\");\n                    poMaskDS->poBaseDS = this;\n                }\n            }\n            \n            /* Embedded mask of an overview */\n            /* The TIFF6 specification allows the combination of the FILETYPE_xxxx masks */\n            else if (nSubType & (FILETYPE_REDUCEDIMAGE | FILETYPE_MASK))\n            {\n                GTiffDataset* poDS = new GTiffDataset();\n                if( poDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE, \n                                      eAccess ) != CE_None\n                    || poDS->GetRasterCount() == 0\n                    || poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poDS;\n                }\n                else\n                {\n                    int i;\n                    for(i=0;i<nOverviewCount;i++)\n                    {\n                        if (((GTiffDataset*)papoOverviewDS[i])->poMaskDS == NULL &&\n                            poDS->GetRasterXSize() == papoOverviewDS[i]->GetRasterXSize() &&\n                            poDS->GetRasterYSize() == papoOverviewDS[i]->GetRasterYSize() &&\n                            (poDS->GetRasterCount() == 1 || poDS->GetRasterCount() == GetRasterCount()))\n                        {\n                            CPLDebug( \"GTiff\", \"Opened band mask for %dx%d overview.\\n\",\n                                      poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                            ((GTiffDataset*)papoOverviewDS[i])->poMaskDS = poDS;\n                            poDS->poBaseDS = this;\n                            break;\n                        }\n                    }\n                    if (i == nOverviewCount)\n                    {\n                        delete poDS;\n                    }\n                }\n            }\n            else if( nSubType == 0 ) {\n                CPLString osName, osDesc;\n                uint32\tnXSize, nYSize;\n                uint16  nSPP;\n\n                TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n                TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n                if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP ) )\n                    nSPP = 1;\n\n                osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\", \n                               iDirIndex, iDirIndex, osFilename.c_str() );\n                osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\", \n                               iDirIndex, iDirIndex, \n                               (int)nXSize, (int)nYSize, nSPP );\n\n                papszSubdatasets = \n                    CSLAddString( papszSubdatasets, osName );\n                papszSubdatasets = \n                    CSLAddString( papszSubdatasets, osDesc );\n            }\n\n            // Make sure we are stepping from the expected directory regardless\n            // of churn done processing the above.\n            if( TIFFCurrentDirOffset(hTIFF) != nThisDir )\n                TIFFSetSubDirectory( hTIFF, nThisDir );\n            *ppoActiveDSRef = NULL;\n        }\n\n        /* If we have a mask for the main image, loop over the overviews, and if they */\n        /* have a mask, let's set this mask as an overview of the main mask... */\n        if (poMaskDS != NULL)\n        {\n            int i;\n            for(i=0;i<nOverviewCount;i++)\n            {\n                if (((GTiffDataset*)papoOverviewDS[i])->poMaskDS != NULL)\n                {\n                    poMaskDS->nOverviewCount++;\n                    poMaskDS->papoOverviewDS = (GTiffDataset **)\n                        CPLRealloc(poMaskDS->papoOverviewDS, \n                                poMaskDS->nOverviewCount * (sizeof(void*)));\n                    poMaskDS->papoOverviewDS[poMaskDS->nOverviewCount-1] =\n                            ((GTiffDataset*)papoOverviewDS[i])->poMaskDS;\n                }\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n        if( CSLCount(papszSubdatasets) > 2 )\n        {\n            oGTiffMDMD.SetMetadata( papszSubdatasets, \"SUBDATASETS\" );\n        }\n        CSLDestroy( papszSubdatasets );\n    }\n\n    return( CE_None );\n}",
    "GDALDataset *GTiffDataset::Create( const char * pszFilename,\n                                   int nXSize, int nYSize, int nBands,\n                                   GDALDataType eType,\n                                   char **papszParmList )\n\n{\n    GTiffDataset *\tpoDS;\n    TIFF\t\t*hTIFF;\n\n/* -------------------------------------------------------------------- */\n/*      Create the underlying TIFF file.                                */\n/* -------------------------------------------------------------------- */\n    hTIFF = CreateLL( pszFilename, nXSize, nYSize, nBands, \n                      eType, papszParmList );\n\n    if( hTIFF == NULL )\n        return NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Create the new GTiffDataset object.                             */\n/* -------------------------------------------------------------------- */\n    poDS = new GTiffDataset();\n    poDS->hTIFF = hTIFF;\n    poDS->poActiveDS = poDS;\n    poDS->ppoActiveDSRef = &(poDS->poActiveDS);\n\n    poDS->nRasterXSize = nXSize;\n    poDS->nRasterYSize = nYSize;\n    poDS->eAccess = GA_Update;\n    poDS->bCrystalized = FALSE;\n    poDS->nSamplesPerPixel = (uint16) nBands;\n    poDS->osFilename = pszFilename;\n\n    /* Avoid premature crystalization that will cause directory re-writting */\n    /* if GetProjectionRef() or GetGeoTransform() are called on the newly created GeoTIFF */\n    poDS->bLookedForProjection = TRUE;\n\n    TIFFGetField( hTIFF, TIFFTAG_SAMPLEFORMAT, &(poDS->nSampleFormat) );\n    TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &(poDS->nPlanarConfig) );\n    TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(poDS->nPhotometric) );\n    TIFFGetField( hTIFF, TIFFTAG_BITSPERSAMPLE, &(poDS->nBitsPerSample) );\n    TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(poDS->nCompression) );\n\n    if( TIFFIsTiled(hTIFF) )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(poDS->nBlockXSize) );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(poDS->nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(poDS->nRowsPerStrip) ) )\n            poDS->nRowsPerStrip = 1; /* dummy value */\n\n        poDS->nBlockXSize = nXSize;\n        poDS->nBlockYSize = MIN((int)poDS->nRowsPerStrip,nYSize);\n    }\n\n    poDS->nBlocksPerBand =\n        ((nYSize + poDS->nBlockYSize - 1) / poDS->nBlockYSize)\n        * ((nXSize + poDS->nBlockXSize - 1) / poDS->nBlockXSize);\n\n    if( CSLFetchNameValue( papszParmList, \"PROFILE\" ) != NULL )\n        poDS->osProfile = CSLFetchNameValue( papszParmList, \"PROFILE\" );\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( poDS->nCompression == COMPRESSION_JPEG \n        && poDS->nPhotometric == PHOTOMETRIC_YCBCR \n        && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode;\n\n        poDS->SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\" );\n        if ( !TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n             nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read palette back as a color table if it has one.               */\n/* -------------------------------------------------------------------- */\n    unsigned short\t*panRed, *panGreen, *panBlue;\n    \n    if( poDS->nPhotometric == PHOTOMETRIC_PALETTE\n        && TIFFGetField( hTIFF, TIFFTAG_COLORMAP, \n                         &panRed, &panGreen, &panBlue) )\n    {\n        int\tnColorCount;\n        GDALColorEntry oEntry;\n\n        poDS->poColorTable = new GDALColorTable();\n\n        nColorCount = 1 << poDS->nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            oEntry.c1 = panRed[iColor] / 256;\n            oEntry.c2 = panGreen[iColor] / 256;\n            oEntry.c3 = panBlue[iColor] / 256;\n            oEntry.c4 = 255;\n\n            poDS->poColorTable->SetColorEntry( iColor, &oEntry );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we want to ensure all blocks get written out on close to     */\n/*      avoid sparse files?                                             */\n/* -------------------------------------------------------------------- */\n    if( !CSLFetchBoolean( papszParmList, \"SPARSE_OK\", FALSE ) )\n        poDS->bFillEmptyTiles = TRUE;\n        \n/* -------------------------------------------------------------------- */\n/*      Preserve creation options for consulting later (for instance    */\n/*      to decide if a TFW file should be written).                     */\n/* -------------------------------------------------------------------- */\n    poDS->papszCreationOptions = CSLDuplicate( papszParmList );\n    \n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    int\t\tiBand;\n\n    for( iBand = 0; iBand < nBands; iBand++ )\n    {\n        if( poDS->nBitsPerSample == 8 ||\n            poDS->nBitsPerSample == 16 ||\n            poDS->nBitsPerSample == 32 ||\n            poDS->nBitsPerSample == 64 ||\n            poDS->nBitsPerSample == 128)\n            poDS->SetBand( iBand+1, new GTiffRasterBand( poDS, iBand+1 ) );\n        else\n        {\n            poDS->SetBand( iBand+1, new GTiffOddBitsBand( poDS, iBand+1 ) );\n            poDS->GetRasterBand( iBand+1 )->\n                SetMetadataItem( \"NBITS\", \n                                 CPLString().Printf(\"%d\",poDS->nBitsPerSample),\n                                 \"IMAGE_STRUCTURE\" );\n        }\n    }\n\n    return( poDS );\n}",
    "GDALDataset *\nGTiffDataset::CreateCopy( const char * pszFilename, GDALDataset *poSrcDS, \n                          int bStrict, char ** papszOptions, \n                          GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    TIFF\t*hTIFF;\n    int\t\tnXSize = poSrcDS->GetRasterXSize();\n    int\t\tnYSize = poSrcDS->GetRasterYSize();\n    int\t\tnBands = poSrcDS->GetRasterCount();\n    int         iBand;\n    CPLErr      eErr = CE_None;\n    uint16\tnPlanarConfig;\n    uint16\tnBitsPerSample;\n    GDALRasterBand *poPBand;\n\n    if( poSrcDS->GetRasterCount() == 0 )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Unable to export GeoTIFF files with zero bands.\" );\n        return NULL;\n    }\n        \n    poPBand = poSrcDS->GetRasterBand(1);\n    GDALDataType eType = poPBand->GetRasterDataType();\n\n/* -------------------------------------------------------------------- */\n/*      Check, whether all bands in input dataset has the same type.    */\n/* -------------------------------------------------------------------- */\n    for ( iBand = 2; iBand <= nBands; iBand++ )\n    {\n        if ( eType != poSrcDS->GetRasterBand(iBand)->GetRasterDataType() )\n        {\n            if ( bStrict )\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"Unable to export GeoTIFF file with different datatypes per\\n\"\n                          \"different bands. All bands should have the same types in TIFF.\" );\n                return NULL;\n            }\n            else\n            {\n                CPLError( CE_Warning, CPLE_AppDefined,\n                          \"Unable to export GeoTIFF file with different datatypes per\\n\"\n                          \"different bands. All bands should have the same types in TIFF.\" );\n            }\n        }\n    }\n\n    if( !pfnProgress( 0.0, NULL, pProgressData ) )\n        return NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the profile.                                            */\n/* -------------------------------------------------------------------- */\n    const char          *pszProfile;\n    int                 bGeoTIFF;\n\n    pszProfile = CSLFetchNameValue(papszOptions,\"PROFILE\");\n    if( pszProfile == NULL )\n        pszProfile = \"GDALGeoTIFF\";\n\n    if( !EQUAL(pszProfile,\"BASELINE\") \n        && !EQUAL(pszProfile,\"GeoTIFF\") \n        && !EQUAL(pszProfile,\"GDALGeoTIFF\") )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined, \n                  \"PROFILE=%s not supported in GTIFF driver.\", \n                  pszProfile );\n        return NULL;\n    }\n    \n    if( EQUAL(pszProfile,\"BASELINE\") )\n        bGeoTIFF = FALSE;\n    else\n        bGeoTIFF = TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      Special handling for NBITS.  Copy from band metadata if found.  */\n/* -------------------------------------------------------------------- */\n    char     **papszCreateOptions = CSLDuplicate( papszOptions );\n\n    if( poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" ) != NULL \n        && atoi(poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" )) > 0\n        && CSLFetchNameValue( papszCreateOptions, \"NBITS\") == NULL )\n    {\n        papszCreateOptions = \n            CSLSetNameValue( papszCreateOptions, \"NBITS\",\n                             poPBand->GetMetadataItem( \"NBITS\", \n                                                       \"IMAGE_STRUCTURE\" ) );\n    }\n\n    if( CSLFetchNameValue( papszOptions, \"PIXELTYPE\" ) == NULL\n        && eType == GDT_Byte\n        && poPBand->GetMetadataItem( \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) )\n    {\n        papszCreateOptions = \n            CSLSetNameValue( papszCreateOptions, \"PIXELTYPE\", \n                             poPBand->GetMetadataItem( \n                                 \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create the file.                                                */\n/* -------------------------------------------------------------------- */\n    hTIFF = CreateLL( pszFilename, nXSize, nYSize, nBands, \n                      eType, papszCreateOptions );\n\n    CSLDestroy( papszCreateOptions );\n\n    if( hTIFF == NULL )\n        return NULL;\n\n    TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &nPlanarConfig );\n    TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &nBitsPerSample );\n\n/* -------------------------------------------------------------------- */\n/*      Are we really producing an RGBA image?  If so, set the          */\n/*      associated alpha information.                                   */\n/* -------------------------------------------------------------------- */\n    int bForcePhotometric = \n        CSLFetchNameValue(papszOptions,\"PHOTOMETRIC\") != NULL;\n\n    if( nBands == 4 && !bForcePhotometric\n        && poSrcDS->GetRasterBand(4)->GetColorInterpretation()==GCI_AlphaBand)\n    {\n        uint16 v[1];\n\n        v[0] = EXTRASAMPLE_ASSOCALPHA;\n\tTIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n        TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the output is jpeg compressed, and the input is RGB make     */\n/*      sure we note that.                                              */\n/* -------------------------------------------------------------------- */\n    uint16      nCompression;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n\n    if( nCompression == COMPRESSION_JPEG )\n    {\n        if( nBands >= 3 \n            && (poSrcDS->GetRasterBand(1)->GetColorInterpretation() \n                == GCI_YCbCr_YBand)\n            && (poSrcDS->GetRasterBand(2)->GetColorInterpretation() \n                == GCI_YCbCr_CbBand)\n            && (poSrcDS->GetRasterBand(3)->GetColorInterpretation() \n                == GCI_YCbCr_CrBand) )\n        {\n            /* do nothing ... */\n        }\n        else\n        {\n            /* we assume RGB if it isn't explicitly YCbCr */\n            CPLDebug( \"GTiff\", \"Setting JPEGCOLORMODE_RGB\" );\n            TIFFSetField( hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );\n        }\n    }\n        \n/* -------------------------------------------------------------------- */\n/*      Does the source image consist of one band, with a palette?      */\n/*      If so, copy over.                                               */\n/* -------------------------------------------------------------------- */\n    if( nBands == 1 && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n        && eType == GDT_Byte )\n    {\n        unsigned short\tanTRed[256], anTGreen[256], anTBlue[256];\n        GDALColorTable *poCT;\n\n        poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n        \n        for( int iColor = 0; iColor < 256; iColor++ )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = (unsigned short) (257 * sRGB.c1);\n                anTGreen[iColor] = (unsigned short) (257 * sRGB.c2);\n                anTBlue[iColor] = (unsigned short) (257 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = anTGreen[iColor] = anTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, anTRed, anTGreen, anTBlue );\n    }\n    else if( nBands == 1 \n             && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n             && eType == GDT_UInt16 )\n    {\n        unsigned short\t*panTRed, *panTGreen, *panTBlue;\n        GDALColorTable *poCT;\n\n        panTRed   = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n        panTGreen = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n        panTBlue  = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n\n        poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n        \n        for( int iColor = 0; iColor < 65536; iColor++ )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                panTRed[iColor] = (unsigned short) (256 * sRGB.c1);\n                panTGreen[iColor] = (unsigned short) (256 * sRGB.c2);\n                panTBlue[iColor] = (unsigned short) (256 * sRGB.c3);\n            }\n            else\n            {\n                panTRed[iColor] = panTGreen[iColor] = panTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n    else if( poSrcDS->GetRasterBand(1)->GetColorTable() != NULL )\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"Unable to export color table to GeoTIFF file.  Color tables\\n\"\n                  \"can only be written to 1 band Byte or UInt16 GeoTIFF files.\" );\n\n/* -------------------------------------------------------------------- */\n/*      Transfer some TIFF specific metadata, if available.             */\n/*      The return value will tell us if we need to try again later with*/\n/*      PAM because the profile doesn't allow to write some metadata    */\n/*      as TIFF tag                                                     */\n/* -------------------------------------------------------------------- */\n    int bHasWrittenMDInGeotiffTAG =\n            GTiffDataset::WriteMetadata( poSrcDS, hTIFF, FALSE, pszProfile,\n                                 pszFilename, papszOptions );\n\n/* -------------------------------------------------------------------- */\n/* \tWrite NoData value, if exist.                                   */\n/* -------------------------------------------------------------------- */\n    if( EQUAL(pszProfile,\"GDALGeoTIFF\") )\n    {\n        int\t\tbSuccess;\n        double\tdfNoData;\n    \n        dfNoData = poSrcDS->GetRasterBand(1)->GetNoDataValue( &bSuccess );\n        if ( bSuccess )\n            GTiffDataset::WriteNoDataValue( hTIFF, dfNoData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write affine transform if it is meaningful.                     */\n/* -------------------------------------------------------------------- */\n    const char *pszProjection = NULL;\n    double      adfGeoTransform[6];\n    \n    if( poSrcDS->GetGeoTransform( adfGeoTransform ) == CE_None\n        && (adfGeoTransform[0] != 0.0 || adfGeoTransform[1] != 1.0\n            || adfGeoTransform[2] != 0.0 || adfGeoTransform[3] != 0.0\n            || adfGeoTransform[4] != 0.0 || ABS(adfGeoTransform[5]) != 1.0 ))\n    {\n        if( bGeoTIFF )\n        {\n            if( adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0 \n                && adfGeoTransform[5] < 0.0 )\n            {\n\n                double\tadfPixelScale[3], adfTiePoints[6];\n\n                adfPixelScale[0] = adfGeoTransform[1];\n                adfPixelScale[1] = fabs(adfGeoTransform[5]);\n                adfPixelScale[2] = 0.0;\n\n                TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n            \n                adfTiePoints[0] = 0.0;\n                adfTiePoints[1] = 0.0;\n                adfTiePoints[2] = 0.0;\n                adfTiePoints[3] = adfGeoTransform[0];\n                adfTiePoints[4] = adfGeoTransform[3];\n                adfTiePoints[5] = 0.0;\n        \n                TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n            }\n            else\n            {\n                double\tadfMatrix[16];\n\n                memset(adfMatrix,0,sizeof(double) * 16);\n\n                adfMatrix[0] = adfGeoTransform[1];\n                adfMatrix[1] = adfGeoTransform[2];\n                adfMatrix[3] = adfGeoTransform[0];\n                adfMatrix[4] = adfGeoTransform[4];\n                adfMatrix[5] = adfGeoTransform[5];\n                adfMatrix[7] = adfGeoTransform[3];\n                adfMatrix[15] = 1.0;\n\n                TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n            }\n            \n            pszProjection = poSrcDS->GetProjectionRef();\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need a TFW file?                                          */\n/* -------------------------------------------------------------------- */\n        if( CSLFetchBoolean( papszOptions, \"TFW\", FALSE ) )\n            GDALWriteWorldFile( pszFilename, \"tfw\", adfGeoTransform );\n        else if( CSLFetchBoolean( papszOptions, \"WORLDFILE\", FALSE ) )\n            GDALWriteWorldFile( pszFilename, \"wld\", adfGeoTransform );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise write tiepoints if they are available.                */\n/* -------------------------------------------------------------------- */\n    else if( poSrcDS->GetGCPCount() > 0 && bGeoTIFF )\n    {\n        const GDAL_GCP *pasGCPs = poSrcDS->GetGCPs();\n        double\t*padfTiePoints;\n\n        padfTiePoints = (double *) \n            CPLMalloc(6*sizeof(double)*poSrcDS->GetGCPCount());\n\n        for( int iGCP = 0; iGCP < poSrcDS->GetGCPCount(); iGCP++ )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPs[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPs[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPs[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPs[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPs[iGCP].dfGCPZ;\n        }\n\n        TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, \n                      6*poSrcDS->GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n        \n        pszProjection = poSrcDS->GetGCPProjection();\n        \n        if( CSLFetchBoolean( papszOptions, \"TFW\", FALSE ) \n            || CSLFetchBoolean( papszOptions, \"WORLDFILE\", FALSE ) )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"TFW=ON or WORLDFILE=ON creation options are ignored when GCPs are available\");\n        }\n    }\n\n    else\n        pszProjection = poSrcDS->GetProjectionRef();\n\n/* -------------------------------------------------------------------- */\n/*      Write the projection information, if possible.                  */\n/* -------------------------------------------------------------------- */\n    if( pszProjection != NULL && strlen(pszProjection) > 0 && bGeoTIFF )\n    {\n        GTIF\t*psGTIF;\n\n        psGTIF = GTIFNew( hTIFF );\n        GTIFSetFromOGISDefn( psGTIF, pszProjection );\n\n        if( poSrcDS->GetMetadataItem( GDALMD_AREA_OR_POINT ) \n            && EQUAL(poSrcDS->GetMetadataItem(GDALMD_AREA_OR_POINT),\n                     GDALMD_AOP_POINT) )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup                                                         */\n/* -------------------------------------------------------------------- */\n    \n    TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTiffCreateCopy()\");\n    TIFFWriteDirectory( hTIFF );\n    TIFFFlush( hTIFF );\n    XTIFFClose( hTIFF );\n    hTIFF = NULL;\n\n    if( eErr != CE_None )\n    {\n        VSIUnlink( pszFilename );\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Re-open as a dataset and copy over missing metadata using       */\n/*      PAM facilities.                                                 */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS;\n    CPLString osFileName(\"GTIFF_RAW:\");\n\n    osFileName += pszFilename;\n\n    poDS = (GTiffDataset *) GDALOpen( osFileName, GA_Update );\n    if( poDS == NULL )\n        poDS = (GTiffDataset *) GDALOpen( osFileName, GA_ReadOnly );\n\n    if ( poDS == NULL )\n    {\n        VSIUnlink( pszFilename );\n        return NULL;\n    }\n\n    poDS->osProfile = pszProfile;\n    poDS->CloneInfo( poSrcDS, GCIF_PAM_DEFAULT );\n    poDS->papszCreationOptions = CSLDuplicate( papszOptions );\n\n/* -------------------------------------------------------------------- */\n/*      CloneInfo() doesn't merge metadata, it just replaces it totally */\n/*      So we have to merge it                                          */\n/* -------------------------------------------------------------------- */\n\n    char **papszSRC_MD = poSrcDS->GetMetadata();\n    char **papszDST_MD = CSLDuplicate(poDS->GetMetadata());\n\n    papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n    poDS->SetMetadata( papszDST_MD );\n    CSLDestroy( papszDST_MD );\n\n    /* Depending on the PHOTOMETRIC tag, the TIFF file may not have */\n    /* the same band count as the source. Will fail later in GDALDatasetCopyWholeRaster anyway... */\n    for( int nBand = 1;\n         nBand <= MIN(poDS->GetRasterCount(), poSrcDS->GetRasterCount()) ;\n         nBand++ )\n    {\n        char **papszSRC_MD = poSrcDS->GetRasterBand(nBand)->GetMetadata();\n        char **papszDST_MD = CSLDuplicate(poDS->GetRasterBand(nBand)->GetMetadata());\n\n        papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n        poDS->GetRasterBand(nBand)->SetMetadata( papszDST_MD );\n        CSLDestroy( papszDST_MD );\n    }\n\n    hTIFF = (TIFF*) poDS->GetInternalHandle(NULL);\n\n/* -------------------------------------------------------------------- */\n/*      Second chance : now that we have a PAM dataset, it is possible  */\n/*      to write metadata that we couldn't be writen as TIFF tag        */\n/* -------------------------------------------------------------------- */\n    if (!bHasWrittenMDInGeotiffTAG)\n        GTiffDataset::WriteMetadata( poDS, hTIFF, TRUE, pszProfile,\n                                     pszFilename, papszOptions, TRUE /* don't write RPC and IMG file again */);\n\n    /* To avoid unnecessary directory rewriting */\n    poDS->bMetadataChanged = FALSE;\n    poDS->bGeoTIFFInfoChanged = FALSE;\n\n    /* We must re-set the compression level at this point, since it has */\n    /* been lost a few lines above when closing the newly create TIFF file */\n    /* The TIFFTAG_ZIPQUALITY & TIFFTAG_JPEGQUALITY are not store in the TIFF file. */\n    /* They are just TIFF session parameters */\n    if (nCompression == COMPRESSION_ADOBE_DEFLATE)\n    {\n        int nZLevel = GTiffGetZLevel(papszOptions);\n        if (nZLevel != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_ZIPQUALITY, nZLevel );\n        }\n    }\n    else if( nCompression == COMPRESSION_JPEG)\n    {\n        int nJpegQuality = GTiffGetJpegQuality(papszOptions);\n        if (nJpegQuality != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_JPEGQUALITY, nJpegQuality );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy actual imagery.                                            */\n/* -------------------------------------------------------------------- */\n\n    if (poDS->bTreatAsSplit || poDS->bTreatAsSplitBitmap)\n    {\n        /* For split bands, we use TIFFWriteScanline() interface */\n        CPLAssert(poDS->nBitsPerSample == 8 || poDS->nBitsPerSample == 1);\n        \n        if (poDS->nPlanarConfig == PLANARCONFIG_CONTIG && poDS->nBands > 1)\n        {\n            int j;\n            GByte* pabyScanline = (GByte *) CPLMalloc(TIFFScanlineSize(hTIFF));\n            eErr = CE_None;\n            for(j=0;j<nYSize && eErr == CE_None;j++)\n            {\n                eErr = poSrcDS->RasterIO(GF_Read, 0, j, nXSize, 1,\n                                         pabyScanline, nXSize, 1,\n                                         GDT_Byte, nBands, NULL, poDS->nBands, 0, 1);\n                if (eErr == CE_None &&\n                    TIFFWriteScanline( hTIFF, pabyScanline, j, 0) == -1)\n                {\n                    CPLError( CE_Failure, CPLE_AppDefined,\n                              \"TIFFWriteScanline() failed.\" );\n                    eErr = CE_Failure;\n                }\n                if( !pfnProgress( (j+1) * 1.0 / nYSize, NULL, pProgressData ) )\n                    eErr = CE_Failure;\n            }\n            CPLFree(pabyScanline);\n        }\n        else\n        {\n            int iBand, j;\n            GByte* pabyScanline = (GByte *) CPLMalloc(TIFFScanlineSize(hTIFF));\n            eErr = CE_None;\n            for(iBand=1;iBand<=nBands && eErr == CE_None;iBand++)\n            {\n                for(j=0;j<nYSize && eErr == CE_None;j++)\n                {\n                    eErr = poSrcDS->GetRasterBand(iBand)->RasterIO(\n                                                    GF_Read, 0, j, nXSize, 1,\n                                                    pabyScanline, nXSize, 1,\n                                                    GDT_Byte, 0, 0);\n                    if (poDS->bTreatAsSplitBitmap)\n                    {\n                        for(int i=0;i<nXSize;i++)\n                        {\n                            GByte byVal = pabyScanline[i];\n                            if ((i & 0x7) == 0)\n                                pabyScanline[i >> 3] = 0;\n                            if (byVal)\n                                pabyScanline[i >> 3] |= (0x80 >> (i & 0x7));\n                        }\n                    }\n                    if (eErr == CE_None &&\n                        TIFFWriteScanline( hTIFF, pabyScanline, j, iBand - 1) == -1)\n                    {\n                        CPLError( CE_Failure, CPLE_AppDefined,\n                                  \"TIFFWriteScanline() failed.\" );\n                        eErr = CE_Failure;\n                    }\n                    if( !pfnProgress( (j+1 + (iBand - 1) * nYSize) * 1.0 /\n                                      (nBands * nYSize), NULL, pProgressData ) )\n                        eErr = CE_Failure;\n                }\n            }\n            CPLFree(pabyScanline);\n        }\n        \n        /* Necessary to be able to read the file without re-opening */\n        TIFFFlush( hTIFF );\n    }\n    else\n    {\n        char* papszCopyWholeRasterOptions[2] = { NULL, NULL };\n        if (nCompression != COMPRESSION_NONE)\n            papszCopyWholeRasterOptions[0] = (char*) \"COMPRESSED=YES\";\n        eErr = GDALDatasetCopyWholeRaster( (GDALDatasetH) poSrcDS, \n                                            (GDALDatasetH) poDS,\n                                            papszCopyWholeRasterOptions,\n                                            pfnProgress, pProgressData );\n    }\n\n    if( eErr == CE_Failure )\n    {\n        delete poDS;\n        poDS = NULL;\n\n        VSIUnlink( pszFilename ); // should really delete more carefully.\n    }\n\n    return poDS;\n}",
    "CPLErr GTiffDataset::CreateMaskBand(int nFlags)\n{\n    if (poMaskDS != NULL)\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"This TIFF dataset has already an internal mask band\");\n        return CE_Failure;\n    }\n    else if (CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\")))\n    {\n        toff_t  nOffset;\n        int     bIsTiled;\n        int     bIsOverview = FALSE;\n        uint32\tnSubType;\n\n        if (nFlags != GMF_PER_DATASET)\n        {\n            CPLError(CE_Failure, CPLE_AppDefined,\n                     \"The only flag value supported for internal mask is GMF_PER_DATASET\");\n            return CE_Failure;\n        }\n\n    /* -------------------------------------------------------------------- */\n    /*      If we don't have read access, then create the mask externally.  */\n    /* -------------------------------------------------------------------- */\n        if( GetAccess() != GA_Update )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined,\n                    \"File open for read-only accessing, \"\n                    \"creating mask externally.\" );\n\n            return GDALPamDataset::CreateMaskBand(nFlags);\n        }\n\n        if (poBaseDS)\n        {\n            if (!poBaseDS->SetDirectory())\n                return CE_Failure;\n        }\n        if (!SetDirectory())\n            return CE_Failure;\n\n        if( TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType))\n        {\n            bIsOverview = (nSubType & FILETYPE_REDUCEDIMAGE) != 0;\n\n            if ((nSubType & FILETYPE_MASK) != 0)\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"Cannot create a mask on a TIFF mask IFD !\" );\n                return CE_Failure;\n            }\n        }\n\n        TIFFFlush( hTIFF );\n\n        bIsTiled = TIFFIsTiled(hTIFF);\n\n        nOffset = GTIFFWriteDirectory(hTIFF,\n                                      (bIsOverview) ? FILETYPE_REDUCEDIMAGE | FILETYPE_MASK : FILETYPE_MASK,\n                                       nRasterXSize, nRasterYSize,\n                                       1, PLANARCONFIG_CONTIG, 1,\n                                       nBlockXSize, nBlockYSize,\n                                       bIsTiled, COMPRESSION_NONE, PHOTOMETRIC_MASK,\n                                       SAMPLEFORMAT_UINT, NULL, NULL, NULL, 0, NULL, \"\");\n        if (nOffset == 0)\n            return CE_Failure;\n\n        poMaskDS = new GTiffDataset();\n        if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nOffset, \n                                  FALSE, GA_Update ) != CE_None)\n        {\n            delete poMaskDS;\n            poMaskDS = NULL;\n            return CE_Failure;\n        }\n\n        return CE_None;\n    }\n    else\n    {\n        return GDALPamDataset::CreateMaskBand(nFlags);\n    }\n}",
    "CPLErr GTIFWktFromMemBuf( int nSize, unsigned char *pabyBuffer, \n                          char **ppszWKT, double *padfGeoTransform,\n                          int *pnGCPCount, GDAL_GCP **ppasGCPList )\n\n{\n    TIFF        *hTIFF;\n    GTIF \t*hGTIF;\n    GTIFDefn\tsGTIFDefn;\n    char        szFilename[100];\n\n    sprintf( szFilename, \"/vsimem/wkt_from_mem_buf_%ld.tif\", \n             (long) CPLGetPID() );\n\n/* -------------------------------------------------------------------- */\n/*      Create a memory file from the buffer.                           */\n/* -------------------------------------------------------------------- */\n    FILE *fp = VSIFileFromMemBuffer( szFilename, pabyBuffer, nSize, FALSE );\n    if( fp == NULL )\n        return CE_Failure;\n    VSIFCloseL( fp );\n\n/* -------------------------------------------------------------------- */\n/*      Initialize access to the memory geotiff structure.              */\n/* -------------------------------------------------------------------- */\n    hTIFF = VSI_TIFFOpen( szFilename, \"r\" );\n\n    if( hTIFF == NULL )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"TIFF/GeoTIFF structure is corrupt.\" );\n        VSIUnlink( szFilename );\n        return CE_Failure;\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Get the projection definition.                                  */\n/* -------------------------------------------------------------------- */\n    hGTIF = GTIFNew(hTIFF);\n\n    if( hGTIF != NULL && GTIFGetDefn( hGTIF, &sGTIFDefn ) )\n        *ppszWKT = GTIFGetOGISDefn( hGTIF, &sGTIFDefn );\n    else\n        *ppszWKT = NULL;\n    \n    if( hGTIF )\n        GTIFFree( hGTIF );\n\n/* -------------------------------------------------------------------- */\n/*      Get geotransform or tiepoints.                                  */\n/* -------------------------------------------------------------------- */\n    double\t*padfTiePoints, *padfScale, *padfMatrix;\n    int16\tnCount;\n\n    padfGeoTransform[0] = 0.0;\n    padfGeoTransform[1] = 1.0;\n    padfGeoTransform[2] = 0.0;\n    padfGeoTransform[3] = 0.0;\n    padfGeoTransform[4] = 0.0;\n    padfGeoTransform[5] = 1.0;\n\n    *pnGCPCount = 0;\n    *ppasGCPList = NULL;\n    \n    if( TIFFGetField(hTIFF,TIFFTAG_GEOPIXELSCALE,&nCount,&padfScale )\n        && nCount >= 2 )\n    {\n        padfGeoTransform[1] = padfScale[0];\n        padfGeoTransform[5] = - ABS(padfScale[1]);\n\n        if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && nCount >= 6 )\n        {\n            padfGeoTransform[0] =\n                padfTiePoints[3] - padfTiePoints[0] * padfGeoTransform[1];\n            padfGeoTransform[3] =\n                padfTiePoints[4] - padfTiePoints[1] * padfGeoTransform[5];\n        }\n    }\n\n    else if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && nCount >= 6 )\n    {\n        *pnGCPCount = nCount / 6;\n        *ppasGCPList = (GDAL_GCP *) CPLCalloc(sizeof(GDAL_GCP),*pnGCPCount);\n        \n        for( int iGCP = 0; iGCP < *pnGCPCount; iGCP++ )\n        {\n            char\tszID[32];\n            GDAL_GCP\t*psGCP = *ppasGCPList + iGCP;\n\n            sprintf( szID, \"%d\", iGCP+1 );\n            psGCP->pszId = CPLStrdup( szID );\n            psGCP->pszInfo = CPLStrdup(\"\");\n            psGCP->dfGCPPixel = padfTiePoints[iGCP*6+0];\n            psGCP->dfGCPLine = padfTiePoints[iGCP*6+1];\n            psGCP->dfGCPX = padfTiePoints[iGCP*6+3];\n            psGCP->dfGCPY = padfTiePoints[iGCP*6+4];\n            psGCP->dfGCPZ = padfTiePoints[iGCP*6+5];\n        }\n    }\n\n    else if( TIFFGetField(hTIFF,TIFFTAG_GEOTRANSMATRIX,&nCount,&padfMatrix ) \n             && nCount == 16 )\n    {\n        padfGeoTransform[0] = padfMatrix[3];\n        padfGeoTransform[1] = padfMatrix[0];\n        padfGeoTransform[2] = padfMatrix[1];\n        padfGeoTransform[3] = padfMatrix[7];\n        padfGeoTransform[4] = padfMatrix[4];\n        padfGeoTransform[5] = padfMatrix[5];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup.                                                        */\n/* -------------------------------------------------------------------- */\n    XTIFFClose( hTIFF );\n\n    VSIUnlink( szFilename );\n\n    if( *ppszWKT == NULL )\n        return CE_Failure;\n    else\n        return CE_None;\n}",
    "il::image_type_ptr load_tiff( const pl::string& uri )\r\n\t{\r\n\t\tTIFF* tif = TIFFOpen( uri.c_str( ), \"r\" );\r\n\t\tif( tif == NULL )\r\n\t\t\treturn il::image_type_ptr( );\r\n\r\n\t\tint width, height, depth;\r\n\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_IMAGEWIDTH,  &width );\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_IMAGELENGTH, &height );\r\n\t\tif( !TIFFGetFieldDefaulted( tif, TIFFTAG_IMAGEDEPTH, &depth ) ) depth = 1;\r\n\r\n\t\tunsigned short config;\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_PLANARCONFIG, &config );\r\n\r\n\t\tif( config != PLANARCONFIG_CONTIG )\r\n\t\t\treturn tiff_null_image( tif );\r\n\r\n\t\tunsigned short photo, compression;\r\n\t\tunsigned short sample_format, orientation;\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_PHOTOMETRIC, &photo );\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_SAMPLEFORMAT, &sample_format );\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_COMPRESSION, &compression );\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_ORIENTATION, &orientation );\r\n\r\n\t\tbool is_float = false;\r\n\t\tswitch( photo )\r\n\t\t{\r\n\t\t\tcase PHOTOMETRIC_RGB:\r\n\t\t\t\tif( sample_format == SAMPLEFORMAT_IEEEFP )\r\n\t\t\t\t\tis_float = true;\r\n\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\tdefault:\r\n\t\t\t\treturn tiff_null_image( tif );\r\n\t\t}\r\n\t\t\r\n\t\tunsigned short bpp, components;\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_BITSPERSAMPLE,   &bpp );\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_SAMPLESPERPIXEL, &components );\r\n\r\n\t\til::image_type_ptr im = tiff_image_type_to_image_type( bpp, components, width, height, is_float );\r\n\t\tif( !im )\r\n\t\t\treturn il::image_type_ptr( );\r\n\r\n\t\til::image_type::pointer data = im->data( );\r\n\t\tint bytes_per_pixel = components * bpp / 8;\r\n\r\n\t\tif( TIFFIsTiled( tif ) )\r\n\t\t{\r\n\t\t\tint tile_width, tile_height, tile_depth;\r\n\r\n\t\t\tTIFFGetField( tif, TIFFTAG_TILEWIDTH,  &tile_width );\r\n\t\t\tTIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height );\r\n\r\n\t\t\tif( !TIFFGetField( tif, TIFFTAG_TILEDEPTH,  &tile_depth ) )\r\n\t\t\t\ttile_depth = 1;\r\n\r\n\t\t\tstd::vector<unsigned char> buf( TIFFTileSize( tif ) );\r\n\t\t\tfor( int k = 0; k < depth; k += tile_depth )\r\n\t\t\t{\r\n\t\t\t\tfor( int j = 0; j < height; j += tile_height )\r\n\t\t\t\t{\r\n\t\t\t\t\tfor( int i = 0; i < width; i += tile_width )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tTIFFReadTile( tif, &buf[ 0 ], i, j, k, 0 );\r\n\r\n\t\t\t\t\t\tfor( int l = 0; l < tile_depth; ++l )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tfor( int m = 0; m < tile_height; ++m )\r\n\t\t\t\t\t\t\t\tmemcpy( data + ( ( ( k + l ) * height + j + m ) * width + i ) * bytes_per_pixel, \r\n\t\t\t\t\t\t\t\t\t\t&buf[ 0 ] + ( l * tile_height + m ) * tile_width * bytes_per_pixel, tile_width * bytes_per_pixel );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tsize_t pitch = im->pitch( );\r\n\t\t\tif( is_float )\r\n\t\t\t\tpitch *= sizeof( float );\r\n\r\n\t\t\tunsigned int rows, strip_size;\r\n\t\t\tTIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &rows );\r\n\t\t\tstrip_size = TIFFStripSize( tif );\r\n\t\t\t\r\n\t\t\ttypedef std::vector<unsigned char> buffer_t;\r\n\t\t\tbuffer_t buf( strip_size );\r\n\t\t\t\r\n\t\t\tint linesize = strip_size / rows;\r\n\t\t\t\r\n\t\t\ttstrip_t nstrips = TIFFNumberOfStrips( tif );\r\n\t\t\tfor( tstrip_t i = 0; i < nstrips; ++i )\r\n\t\t\t{\r\n\t\t\t\tTIFFReadEncodedStrip( tif, i, &buf[ 0 ], strip_size );\r\n\t\t\t\t\r\n\t\t\t\tbuffer_t::pointer buf_data = &buf[ 0 ];\r\n\t\t\t\t\r\n\t\t\t\tfor( unsigned int j = 0; j < rows; ++j )\r\n\t\t\t\t{\r\n\t\t\t\t\tmemcpy( data, buf_data, linesize );\r\n\r\n\t\t\t\t\tbuf_data += linesize;\r\n\t\t\t\t\tdata += pitch;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tTIFFClose( tif );\r\n\r\n\t\treturn im;\r\n\t}",
    "bool CImageTIF::Load(const QString& fileName, CImageEx& outImage)\n{\n    CCryFile file;\n    if (!file.Open(fileName.toUtf8().data(), \"rb\"))\n    {\n        CLogFile::FormatLine(\"File not found %s\", fileName.toUtf8().data());\n        return false;\n    }\n\n    MemImage memImage;\n\n    std::vector<uint8> data;\n\n    memImage.size = static_cast<uint32>(file.GetLength());\n\n    data.resize(memImage.size);\n    memImage.buffer = &data[0];\n    memImage.offset = 0;\n\n    file.ReadRaw(memImage.buffer, memImage.size);\n\n\n    // Open the dummy document (which actually only exists in memory)\n    TIFF* tif = TIFFClientOpen (fileName.toUtf8().data(), \"rm\", (thandle_t)&memImage, libtiffDummyReadProc,\n            libtiffDummyWriteProc, libtiffDummySeekProc,\n            libtiffDummyCloseProc, libtiffDummySizeProc, libtiffDummyMapFileProc, libtiffDummyUnmapFileProc);\n\n    //  TIFF* tif = TIFFOpen(fileName,\"r\");\n\n    bool bRet = false;\n\n    if (tif)\n    {\n        uint32 dwWidth, dwHeight;\n        size_t npixels;\n        uint32* raster;\n        char* dccfilename = nullptr;\n\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &dwWidth);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &dwHeight);\n        TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &dccfilename);\n\n        npixels = dwWidth * dwHeight;\n\n        raster = (uint32*)_TIFFmalloc((tsize_t)(npixels * sizeof(uint32)));\n\n        if (raster)\n        {\n            if (TIFFReadRGBAImage(tif, dwWidth, dwHeight, raster, 0))\n            {\n                if (outImage.Allocate(dwWidth, dwHeight))\n                {\n                    char* dest = (char*)outImage.GetData();\n                    uint32 dwPitch = dwWidth * 4;\n\n                    for (uint32 dwY = 0; dwY < dwHeight; ++dwY)\n                    {\n                        char* src2 = (char*)&raster[(dwHeight - 1 - dwY) * dwWidth];\n                        char* dest2 = &dest[dwPitch * dwY];\n\n                        memcpy(dest2, src2, dwWidth * 4);\n                    }\n\n                    if (dccfilename)\n                    {\n                        outImage.SetDccFilename(dccfilename);\n                    }\n\n                    bRet = true;\n                }\n            }\n\n            _TIFFfree(raster);\n        }\n\n        TIFFClose(tif);\n    }\n\n    if (!bRet)\n    {\n        outImage.Detach();\n    }\n\n    return bRet;\n}",
    "bool CImageTIF::Load(const QString& fileName, CFloatImage& outImage)\n{\n    // Defined in GeoTIFF format - http://web.archive.org/web/20160403164508/http://www.remotesensing.org/geotiff/spec/geotiffhome.html\n    // Used to get the X, Y, Z scales from a GeoTIFF file\n    static const int GEOTIFF_MODELPIXELSCALE_TAG = 33550;\n\n    \n    CCryFile file;\n    if (!file.Open(fileName.toUtf8().data(), \"rb\"))\n    {\n        CLogFile::FormatLine(\"File not found %s\", fileName.toUtf8().data());\n        return false;\n    }\n\n    MemImage memImage;\n\n    std::vector<uint8> data;\n\n    memImage.size = static_cast<int>(file.GetLength());\n\n    data.resize(memImage.size);\n    memImage.buffer = &data[0];\n    memImage.offset = 0;\n\n    file.ReadRaw(memImage.buffer, memImage.size);\n\n\n    // Open the dummy document (which actually only exists in memory)\n    TIFF* tif = TIFFClientOpen(fileName.toUtf8().data(), \"rm\", (thandle_t)&memImage, libtiffDummyReadProc,\n        libtiffDummyWriteProc, libtiffDummySeekProc,\n        libtiffDummyCloseProc, libtiffDummySizeProc, libtiffDummyMapFileProc, libtiffDummyUnmapFileProc);\n\n    //  TIFF* tif = TIFFOpen(fileName,\"r\");\n\n    bool bRet = false;\n\n    if (tif)\n    {\n        uint32 width = 0, height = 0;\n        uint16 spp = 0, bpp = 0, format = 0;\n        char* dccfilename = nullptr;\n\n        TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &dccfilename);\n\n        TIFFGetFieldDefaulted(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetFieldDefaulted(tif, TIFFTAG_IMAGELENGTH, &height);\n\n        TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bpp);     // how many bits each color component is.  typically 8-bit, but could be 16-bit.\n        TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);   // how many color components per pixel?  1=greyscale, 3=RGB, 4=RGBA\n        TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &format);   // format of the pixel data - int, uint, float.  \n\n        // There are two types of 32-bit floating point TIF semantics.  Paint programs tend to use values in the 0.0 - 1.0 range.\n        // GeoTIFF files use values where 1.0 = 1 meter by default, but also have an optional ZScale parameter to provide additional\n        // scaling control.\n\n        // By default, we'll assume this is a regular TIFF that we want to leave in the 0.0 - 1.0 range.\n        float pixelValueScale = 1.0f;\n\n        // Check to see if it's a GeoTIFF, and if so, whether or not it has the ZScale parameter.\n        uint32 tagCount = 0;\n        double *pixelScales = nullptr;\n        if (TIFFGetField(tif, GEOTIFF_MODELPIXELSCALE_TAG, &tagCount, &pixelScales) == 1)\n        {\n            // if there's an xyz scale, and the Z scale isn't 0, let's use it.\n            if ((tagCount == 3) && (pixelScales != nullptr) && (pixelScales[2] != 0.0f))\n            {\n                pixelValueScale = static_cast<float>(pixelScales[2]);\n            }\n        }\n\n        uint32 linesize = static_cast<uint32>(TIFFScanlineSize(tif));\n        uint8* linebuf = static_cast<uint8*>(_TIFFmalloc(linesize));\n\n        // We assume that a scanline has all of the samples in it.  Validate the assumption.\n        assert(linesize == (width * (bpp / 8) * spp));\n\n        // Aliases for linebuf to make it easier to pull different types out of the scanline.\n        uint16* linebufUint16 = reinterpret_cast<uint16*>(linebuf);\n        uint32* linebufUint32 = reinterpret_cast<uint32*>(linebuf);\n        float* linebufFloat = reinterpret_cast<float*>(linebuf);\n\n        if (linebuf)\n        {\n            if (outImage.Allocate(width, height))\n            {\n                float* dest = outImage.GetData();\n                bRet = true;\n\n                float maxPixelValue = 0.0f;\n\n                for (uint32 y = 0; y < height; y++)\n                {\n                    TIFFReadScanline(tif, linebuf, y);\n\n                    // For each pixel, we either scale or clamp the values to a 16-bit range.  It is asymmetric behaviour, but based\n                    // on assumptions about the input data:\n                    // 8-bit values are scaled up because 8-bit textures used as heightmaps are usually scaled-down 16-bit values.\n                    // 32-bit values may or may not need to scale down, depending on the intended authoring range.  Our assumption\n                    // is that they were most likely authored with the intent of 1:1 value translations.\n\n                    for (uint32 x = 0; x < width; x++)\n                    {\n                        switch (bpp)\n                        {\n                            case 8:\n                                // Scale 0-255 to 0.0 - 1.0\n                                dest[(y * width) + x] = static_cast<float>(linebuf[x * spp]) / static_cast<float>(std::numeric_limits<uint8>::max());\n                                break;\n                            case 16:\n                                // Scale 0-65535 to 0.0 - 1.0\n                                dest[(y * width) + x] = static_cast<float>(linebufUint16[x * spp]) / static_cast<float>(std::numeric_limits<uint16>::max());\n                                break;\n                            case 32:\n                                // 32-bit values could be ints or floats.\n\n                                if (format == SAMPLEFORMAT_INT)\n                                {\n                                    // Scale 0-max int32 to 0.0 - 1.0\n                                    dest[(y * width) + x] = clamp_tpl(static_cast<float>(linebufUint32[x * spp]) / static_cast<float>(std::numeric_limits<int32>::max()), 0.0f, 1.0f);\n                                }\n                                else if (format == SAMPLEFORMAT_UINT)\n                                {\n                                    // Scale 0-max uint32 to 0.0 - 1.0\n                                    dest[(y * width) + x] = clamp_tpl(static_cast<float>(linebufUint32[x * spp]) / static_cast<float>(std::numeric_limits<uint32>::max()), 0.0f, 1.0f);\n                                }\n                                else if (format == SAMPLEFORMAT_IEEEFP)\n                                {\n                                    dest[(y * width) + x] = linebufFloat[x * spp] * pixelValueScale;\n                                }\n                                else\n                                {\n                                    // Unknown / unsupported format.\n                                    bRet = false;\n                                }\n                                break;\n                            default:\n                                // Unknown / unsupported format.\n                                bRet = false;\n                                break;\n                        }\n\n                        maxPixelValue = max(maxPixelValue, dest[(y * width) + x]);\n                    }\n                }\n\n                if (dccfilename)\n                {\n                    outImage.SetDccFilename(dccfilename);\n                }\n\n                // If this is a GeoTIFF using 32-bit floats, we will end up outside the 0.0 - 1.0 range.  Let's scale it back down to 0.0 - 1.0.\n                if (maxPixelValue > 1.0f)\n                {\n                    for (uint32 y = 0; y < height; y++)\n                    {\n                        for (uint32 x = 0; x < width; x++)\n                        {\n                            dest[(y * width) + x] = dest[(y * width) + x] / maxPixelValue;\n                        }\n                    }\n                }\n            }\n\n            _TIFFfree(linebuf);\n        }\n\n        TIFFClose(tif);\n    }\n\n    if (!bRet)\n    {\n        outImage.Detach();\n    }\n\n    return bRet;\n}",
    "const char* CImageTIF::GetPreset(const QString& fileName)\n{\n    std::vector<uint8> data;\n    CCryFile file;\n    if (!file.Open(fileName.toUtf8().data(), \"rb\"))\n    {\n        CLogFile::FormatLine(\"File not found %s\", fileName.toUtf8().data());\n        return nullptr;\n    }\n\n    MemImage memImage;\n\n    memImage.size = static_cast<uint32>(file.GetLength());\n\n    data.resize(memImage.size);\n    memImage.buffer = &data[0];\n    memImage.offset = 0;\n\n    file.ReadRaw(memImage.buffer, memImage.size);\n\n    TIFF* tif = TIFFClientOpen (fileName.toUtf8().data(), \"rm\", (thandle_t)&memImage, libtiffDummyReadProc,\n            libtiffDummyWriteProc, libtiffDummySeekProc,\n            libtiffDummyCloseProc, libtiffDummySizeProc, libtiffDummyMapFileProc, libtiffDummyUnmapFileProc);\n\n    AZStd::string strReturn;\n    char* preset = nullptr;\n    int size;\n    if (tif)\n    {\n        TIFFGetField(tif, TIFFTAG_PHOTOSHOP, &size, &preset);\n        for (int i = 0; i < size; ++i)\n        {\n            if (!strncmp((preset + i), \"preset\", 6))\n            {\n                char* presetoffset = preset + i;\n                strReturn = presetoffset;\n                if (strReturn.find('/') != -1)\n                {\n                    strReturn = strReturn.substr(0, strReturn.find('/'));\n                }\n\n                break;\n            }\n        }\n        TIFFClose(tif);\n    }\n    return strReturn.c_str();\n}",
    "GTiffGrid::GTiffGrid(PJ_CONTEXT *ctx, TIFF *hTIFF, BlockCache &cache, File *fp,\n                     uint32_t ifdIdx, const std::string &nameIn, int widthIn,\n                     int heightIn, const ExtentAndRes &extentIn,\n                     TIFFDataType dtIn, uint16_t samplesPerPixelIn,\n                     uint16_t planarConfig, bool bottomUpIn)\n    : Grid(nameIn, widthIn, heightIn, extentIn), m_ctx(ctx), m_hTIFF(hTIFF),\n      m_cache(cache), m_fp(fp), m_ifdIdx(ifdIdx), m_dt(dtIn),\n      m_samplesPerPixel(samplesPerPixelIn),\n      m_planarConfig(samplesPerPixelIn == 1 ? static_cast<uint16_t>(-1)\n                                            : planarConfig),\n      m_bottomUp(bottomUpIn), m_dirOffset(TIFFCurrentDirOffset(hTIFF)),\n      m_tiled(TIFFIsTiled(hTIFF) != 0) {\n\n    if (m_tiled) {\n        TIFFGetField(m_hTIFF, TIFFTAG_TILEWIDTH, &m_blockWidth);\n        TIFFGetField(m_hTIFF, TIFFTAG_TILELENGTH, &m_blockHeight);\n    } else {\n        m_blockWidth = widthIn;\n        TIFFGetField(m_hTIFF, TIFFTAG_ROWSPERSTRIP, &m_blockHeight);\n        if (m_blockHeight > static_cast<unsigned>(m_height))\n            m_blockHeight = m_height;\n    }\n\n    m_blockIs256Pixel = (m_blockWidth == 256) && (m_blockHeight == 256);\n    m_isSingleBlock = (m_blockWidth == static_cast<uint32_t>(m_width)) &&\n                      (m_blockHeight == static_cast<uint32_t>(m_height));\n\n    TIFFGetField(m_hTIFF, TIFFTAG_SUBFILETYPE, &m_subfileType);\n\n    m_blocksPerRow = (m_width + m_blockWidth - 1) / m_blockWidth;\n    m_blocksPerCol = (m_height + m_blockHeight - 1) / m_blockHeight;\n    m_blocks = m_blocksPerRow * m_blocksPerCol;\n\n    const char *text = nullptr;\n    // Poor-man XML parsing of TIFFTAG_GDAL_METADATA tag. Hopefully good\n    // enough for our purposes.\n    if (TIFFGetField(m_hTIFF, TIFFTAG_GDAL_METADATA, &text)) {\n        const char *ptr = text;\n        while (true) {\n            ptr = strstr(ptr, \"<Item \");\n            if (ptr == nullptr)\n                break;\n            const char *endTag = strchr(ptr, '>');\n            if (endTag == nullptr)\n                break;\n            const char *endValue = strchr(endTag, '<');\n            if (endValue == nullptr)\n                break;\n\n            std::string tag;\n            tag.append(ptr, endTag - ptr);\n\n            std::string value;\n            value.append(endTag + 1, endValue - (endTag + 1));\n\n            std::string gridName;\n            auto namePos = tag.find(\"name=\\\"\");\n            if (namePos == std::string::npos)\n                break;\n            {\n                namePos += strlen(\"name=\\\"\");\n                const auto endQuote = tag.find('\"', namePos);\n                if (endQuote == std::string::npos)\n                    break;\n                gridName = tag.substr(namePos, endQuote - namePos);\n            }\n\n            const auto samplePos = tag.find(\"sample=\\\"\");\n            int sample = -1;\n            if (samplePos != std::string::npos) {\n                sample = atoi(tag.c_str() + samplePos + strlen(\"sample=\\\"\"));\n            }\n\n            m_metadata[std::pair<int, std::string>(sample, gridName)] = value;\n\n            auto rolePos = tag.find(\"role=\\\"\");\n            if (rolePos != std::string::npos) {\n                rolePos += strlen(\"role=\\\"\");\n                const auto endQuote = tag.find('\"', rolePos);\n                if (endQuote == std::string::npos)\n                    break;\n                const auto role = tag.substr(rolePos, endQuote - rolePos);\n                if (role == \"offset\") {\n                    if (sample >= 0 &&\n                        static_cast<unsigned>(sample) <= m_samplesPerPixel) {\n                        try {\n                            if (m_adfOffset.empty()) {\n                                m_adfOffset.resize(m_samplesPerPixel);\n                                m_adfScale.resize(m_samplesPerPixel, 1);\n                            }\n                            m_adfOffset[sample] = c_locale_stod(value);\n                        } catch (const std::exception &) {\n                        }\n                    }\n                } else if (role == \"scale\") {\n                    if (sample >= 0 &&\n                        static_cast<unsigned>(sample) <= m_samplesPerPixel) {\n                        try {\n                            if (m_adfOffset.empty()) {\n                                m_adfOffset.resize(m_samplesPerPixel);\n                                m_adfScale.resize(m_samplesPerPixel, 1);\n                            }\n                            m_adfScale[sample] = c_locale_stod(value);\n                        } catch (const std::exception &) {\n                        }\n                    }\n                }\n            }\n\n            ptr = endValue + 1;\n        }\n    }\n\n    if (TIFFGetField(m_hTIFF, TIFFTAG_GDAL_NODATA, &text)) {\n        try {\n            m_noData = static_cast<float>(c_locale_stod(text));\n            m_hasNodata = true;\n        } catch (const std::exception &) {\n        }\n    }\n\n    auto oIter = m_metadata.find(std::pair<int, std::string>(-1, \"grid_name\"));\n    if (oIter != m_metadata.end()) {\n        m_name += \", \" + oIter->second;\n    }\n}",
    "std::unique_ptr<GTiffGrid> GTiffDataset::nextGrid() {\n    if (!m_hasNextGrid)\n        return nullptr;\n    if (m_nextDirOffset) {\n        TIFFSetSubDirectory(m_hTIFF, m_nextDirOffset);\n    }\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGELENGTH, &height);\n    if (width == 0 || height == 0 || width > INT_MAX || height > INT_MAX) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Invalid image size\"));\n        return nullptr;\n    }\n\n    uint16_t samplesPerPixel = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Missing SamplesPerPixel tag\"));\n        return nullptr;\n    }\n    if (samplesPerPixel == 0) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Invalid SamplesPerPixel value\"));\n        return nullptr;\n    }\n\n    uint16_t bitsPerSample = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_BITSPERSAMPLE, &bitsPerSample)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Missing BitsPerSample tag\"));\n        return nullptr;\n    }\n\n    uint16_t planarConfig = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PLANARCONFIG, &planarConfig)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Missing PlanarConfig tag\"));\n        return nullptr;\n    }\n\n    uint16_t sampleFormat = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLEFORMAT, &sampleFormat)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Missing SampleFormat tag\"));\n        return nullptr;\n    }\n\n    TIFFDataType dt;\n    if (sampleFormat == SAMPLEFORMAT_INT && bitsPerSample == 16)\n        dt = TIFFDataType::Int16;\n    else if (sampleFormat == SAMPLEFORMAT_UINT && bitsPerSample == 16)\n        dt = TIFFDataType::UInt16;\n    else if (sampleFormat == SAMPLEFORMAT_INT && bitsPerSample == 32)\n        dt = TIFFDataType::Int32;\n    else if (sampleFormat == SAMPLEFORMAT_UINT && bitsPerSample == 32)\n        dt = TIFFDataType::UInt32;\n    else if (sampleFormat == SAMPLEFORMAT_IEEEFP && bitsPerSample == 32)\n        dt = TIFFDataType::Float32;\n    else if (sampleFormat == SAMPLEFORMAT_IEEEFP && bitsPerSample == 64)\n        dt = TIFFDataType::Float64;\n    else {\n        pj_log(m_ctx, PJ_LOG_ERROR,\n               _(\"Unsupported combination of SampleFormat \"\n                 \"and BitsPerSample values\"));\n        return nullptr;\n    }\n\n    uint16_t photometric = PHOTOMETRIC_MINISBLACK;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PHOTOMETRIC, &photometric))\n        photometric = PHOTOMETRIC_MINISBLACK;\n    if (photometric != PHOTOMETRIC_MINISBLACK) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Unsupported Photometric value\"));\n        return nullptr;\n    }\n\n    uint16_t compression = COMPRESSION_NONE;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_COMPRESSION, &compression))\n        compression = COMPRESSION_NONE;\n\n    if (compression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(compression)) {\n        pj_log(m_ctx, PJ_LOG_ERROR,\n               _(\"Cannot open TIFF file due to missing codec.\"));\n        return nullptr;\n    }\n    // We really don't want to try dealing with old-JPEG images\n    if (compression == COMPRESSION_OJPEG) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Unsupported compression method.\"));\n        return nullptr;\n    }\n\n    const auto blockSize = TIFFIsTiled(m_hTIFF) ? TIFFTileSize64(m_hTIFF)\n                                                : TIFFStripSize64(m_hTIFF);\n    if (blockSize == 0 || blockSize > 64 * 1024 * 2014) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Unsupported block size.\"));\n        return nullptr;\n    }\n\n    unsigned short count = 0;\n    unsigned short *geokeys = nullptr;\n    bool pixelIsArea = false;\n\n    ExtentAndRes extent;\n    extent.isGeographic = true;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_GEOKEYDIRECTORY, &count, &geokeys)) {\n        pj_log(m_ctx, PJ_LOG_TRACE, \"No GeoKeys tag\");\n    } else {\n        if (count < 4 || (count % 4) != 0) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   _(\"Wrong number of values in GeoKeys tag\"));\n            return nullptr;\n        }\n\n        if (geokeys[0] != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, _(\"Unsupported GeoTIFF major version\"));\n            return nullptr;\n        }\n        // We only know that we support GeoTIFF 1.0 and 1.1 at that time\n        if (geokeys[1] != 1 || geokeys[2] > 1) {\n            pj_log(m_ctx, PJ_LOG_TRACE, \"GeoTIFF %d.%d possibly not handled\",\n                   geokeys[1], geokeys[2]);\n        }\n\n        for (unsigned int i = 4; i + 3 < count; i += 4) {\n            constexpr unsigned short GTModelTypeGeoKey = 1024;\n            constexpr unsigned short ModelTypeProjected = 1;\n            constexpr unsigned short ModelTypeGeographic = 2;\n\n            constexpr unsigned short GTRasterTypeGeoKey = 1025;\n            constexpr unsigned short RasterPixelIsArea = 1;\n            // constexpr unsigned short RasterPixelIsPoint = 2;\n\n            if (geokeys[i] == GTModelTypeGeoKey) {\n                if (geokeys[i + 3] == ModelTypeProjected) {\n                    extent.isGeographic = false;\n                } else if (geokeys[i + 3] != ModelTypeGeographic) {\n                    pj_log(m_ctx, PJ_LOG_ERROR,\n                           _(\"Only GTModelTypeGeoKey = \"\n                             \"ModelTypeGeographic or ModelTypeProjected are \"\n                             \"supported\"));\n                    return nullptr;\n                }\n            } else if (geokeys[i] == GTRasterTypeGeoKey) {\n                if (geokeys[i + 3] == RasterPixelIsArea) {\n                    pixelIsArea = true;\n                }\n            }\n        }\n    }\n\n    double hRes = 0;\n    double vRes = 0;\n    double west = 0;\n    double north = 0;\n\n    double *matrix = nullptr;\n    if (TIFFGetField(m_hTIFF, TIFFTAG_GEOTRANSMATRIX, &count, &matrix) &&\n        count == 16) {\n        // If using GDAL to produce a bottom-up georeferencing, it will produce\n        // a GeoTransformationMatrix, since negative values in GeoPixelScale\n        // have historically been implementation bugs.\n        if (matrix[1] != 0 || matrix[4] != 0) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   _(\"Rotational terms not supported in \"\n                     \"GeoTransformationMatrix tag\"));\n            return nullptr;\n        }\n\n        west = matrix[3];\n        hRes = matrix[0];\n        north = matrix[7];\n        vRes = -matrix[5]; // negation to simulate GeoPixelScale convention\n    } else {\n        double *geopixelscale = nullptr;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_GEOPIXELSCALE, &count,\n                         &geopixelscale) != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, _(\"No GeoPixelScale tag\"));\n            return nullptr;\n        }\n        if (count != 3) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   _(\"Wrong number of values in GeoPixelScale tag\"));\n            return nullptr;\n        }\n        hRes = geopixelscale[0];\n        vRes = geopixelscale[1];\n\n        double *geotiepoints = nullptr;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_GEOTIEPOINTS, &count,\n                         &geotiepoints) != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, _(\"No GeoTiePoints tag\"));\n            return nullptr;\n        }\n        if (count != 6) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   _(\"Wrong number of values in GeoTiePoints tag\"));\n            return nullptr;\n        }\n\n        west = geotiepoints[3] - geotiepoints[0] * hRes;\n        north = geotiepoints[4] + geotiepoints[1] * vRes;\n    }\n\n    if (pixelIsArea) {\n        west += 0.5 * hRes;\n        north -= 0.5 * vRes;\n    }\n\n    const double mulFactor = extent.isGeographic ? DEG_TO_RAD : 1;\n    extent.west = west * mulFactor;\n    extent.north = north * mulFactor;\n    extent.resX = hRes * mulFactor;\n    extent.resY = fabs(vRes) * mulFactor;\n    extent.east = (west + hRes * (width - 1)) * mulFactor;\n    extent.south = (north - vRes * (height - 1)) * mulFactor;\n    extent.computeInvRes();\n\n    if (vRes < 0) {\n        std::swap(extent.north, extent.south);\n    }\n\n    if (!((!extent.isGeographic ||\n           (fabs(extent.west) <= 4 * M_PI && fabs(extent.east) <= 4 * M_PI &&\n            fabs(extent.north) <= M_PI + 1e-5 &&\n            fabs(extent.south) <= M_PI + 1e-5)) &&\n          extent.west < extent.east && extent.south < extent.north &&\n          extent.resX > 1e-10 && extent.resY > 1e-10)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Inconsistent georeferencing for %s\"),\n               m_filename.c_str());\n        return nullptr;\n    }\n\n    auto ret = std::unique_ptr<GTiffGrid>(new GTiffGrid(\n        m_ctx, m_hTIFF, m_cache, m_fp.get(), m_ifdIdx, m_filename, width,\n        height, extent, dt, samplesPerPixel, planarConfig, vRes < 0));\n    m_ifdIdx++;\n    m_hasNextGrid = TIFFReadDirectory(m_hTIFF) != 0;\n    m_nextDirOffset = TIFFCurrentDirOffset(m_hTIFF);\n\n    // If the TIFF file contains multiple grids, append the index of the grid\n    // in the grid name to help debugging.\n    if (m_ifdIdx >= 2 || m_hasNextGrid) {\n        ret->m_name += \" (index \";\n        ret->m_name += std::to_string(m_ifdIdx); // 1-based\n        ret->m_name += ')';\n    }\n\n    return ret;\n}",
    "unsigned char *tifread(const char *url, int *w, int *h, int *nc)\n{\n    static int firstTime = 1;\n    TIFF *tif;\n    if (firstTime)\n    {\n        firstTime = 0;\n        TIFFSetWarningHandler(myWarn);\n    }\n\n/*tiffDoRGBA = 1;*/\n#ifdef _WIN32\n    tif = TIFFOpen(url, \"r\");\n#else\n    tif = TIFFOpen(url, \"r\");\n#endif\n    if (tif)\n    {\n        int samples = 4;\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, w);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, h);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samples);\n        size_t npixels = *w * *h;\n        uint32 *raster = (uint32 *)malloc(npixels * sizeof(uint32));\n        if (raster != NULL)\n        {\n            if (TIFFReadRGBAImage(tif, *w, *h, raster, 0))\n            {\n                *nc = 4;\n                if (samples < 4)\n                {\n                    /* ugly hack by Uwe for grey scale/b/w images */\n                    *nc = 40;\n                }\n\n                unsigned char *raster2 = (unsigned char *)malloc(npixels * sizeof(uint32));\n                unsigned char *image = (unsigned char *)raster;\n                size_t widthbytes = *w * sizeof(uint32);\n                for (int i = 0; i < *h; i++)\n                {\n                    memcpy(raster2 + (npixels * sizeof(uint32)) - ((i + 1) * widthbytes), image + (i * widthbytes), widthbytes);\n                }\n                free(raster);\n\n/* We have to byteswap on SGI ! */\n#ifdef BIG_ENDIAN\n                {\n                    uint32_t *iPtr = (uint32_t *)raster2;\n                    for (int i = 0; i < npixels; i++, iPtr++)\n                        *iPtr = ((*iPtr & 0x000000ff) << 24) | ((*iPtr & 0x0000ff00) << 8) | ((*iPtr & 0x00ff0000) >> 8) | ((*iPtr & 0xff000000) >> 24);\n                }\n#endif\n\n                /*TIFFClose(tif);*/\n                return (unsigned char *)raster2;\n            }\n            free(raster);\n        }\n    }\n    return NULL;\n}",
    "char **GTiffDatasetReadRPCTag(TIFF *hTIFF)\n\n{\n    double *padfRPCTag = nullptr;\n    uint16_t nCount;\n\n    if (!TIFFGetField(hTIFF, TIFFTAG_RPCCOEFFICIENT, &nCount, &padfRPCTag) ||\n        nCount != 92)\n        return nullptr;\n\n    return gdal::tiff_common::TIFFRPCTagToRPCMetadata(padfRPCTag).StealList();\n}",
    "void GTiffWriteJPEGTables(TIFF *hTIFF, const char *pszPhotometric,\n                          const char *pszJPEGQuality,\n                          const char *pszJPEGTablesMode)\n{\n    // This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n    uint16_t nBands = 0;\n    if (!TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nBands))\n        nBands = 1;\n\n    uint16_t l_nBitsPerSample = 0;\n    if (!TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &(l_nBitsPerSample)))\n        l_nBitsPerSample = 1;\n\n    const CPLString osTmpFilenameIn(\n        VSIMemGenerateHiddenFilename(\"gtiffdataset_jpg_tmp\"));\n    VSILFILE *fpTmp = nullptr;\n    CPLString osTmp;\n    char **papszLocalParameters = nullptr;\n    const int nInMemImageWidth = 16;\n    const int nInMemImageHeight = 16;\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"COMPRESS\", \"JPEG\");\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"JPEG_QUALITY\", pszJPEGQuality);\n    if (nBands <= 4)\n    {\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                               \"PHOTOMETRIC\", pszPhotometric);\n    }\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters, \"BLOCKYSIZE\",\n                                           CPLSPrintf(\"%u\", nInMemImageHeight));\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters, \"NBITS\",\n                                           CPLSPrintf(\"%u\", l_nBitsPerSample));\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                           \"JPEGTABLESMODE\", pszJPEGTablesMode);\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"WRITE_JPEGTABLE_TAG\", \"NO\");\n\n    bool bTileInterleaving;\n    TIFF *hTIFFTmp =\n        GTiffDataset::CreateLL(osTmpFilenameIn, nInMemImageWidth,\n                               nInMemImageHeight, (nBands <= 4) ? nBands : 1,\n                               (l_nBitsPerSample <= 8) ? GDT_Byte : GDT_UInt16,\n                               0.0, 0, papszLocalParameters, &fpTmp, osTmp,\n                               /* bCreateCopy=*/false, bTileInterleaving);\n    CSLDestroy(papszLocalParameters);\n    if (hTIFFTmp)\n    {\n        uint16_t l_nPhotometric = 0;\n        int nJpegTablesModeIn = 0;\n        TIFFGetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, &(l_nPhotometric));\n        TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLESMODE, &nJpegTablesModeIn);\n        TIFFWriteCheck(hTIFFTmp, FALSE, \"CreateLL\");\n        TIFFWriteDirectory(hTIFFTmp);\n        TIFFSetDirectory(hTIFFTmp, 0);\n        // Now, reset quality and jpegcolormode.\n        const int l_nJpegQuality = pszJPEGQuality ? atoi(pszJPEGQuality) : 0;\n        if (l_nJpegQuality > 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGQUALITY, l_nJpegQuality);\n        if (l_nPhotometric == PHOTOMETRIC_YCBCR &&\n            CPLTestBool(CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\")))\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n        if (nJpegTablesModeIn >= 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGTABLESMODE, nJpegTablesModeIn);\n\n        GPtrDiff_t nBlockSize = static_cast<GPtrDiff_t>(nInMemImageWidth) *\n                                nInMemImageHeight *\n                                ((nBands <= 4) ? nBands : 1);\n        if (l_nBitsPerSample == 12)\n            nBlockSize = (nBlockSize * 3) / 2;\n        std::vector<GByte> abyZeroData(nBlockSize, 0);\n        TIFFWriteEncodedStrip(hTIFFTmp, 0, &abyZeroData[0], nBlockSize);\n\n        uint32_t nJPEGTableSize = 0;\n        void *pJPEGTable = nullptr;\n        if (TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSize,\n                         &pJPEGTable))\n            TIFFSetField(hTIFF, TIFFTAG_JPEGTABLES, nJPEGTableSize, pJPEGTable);\n\n        float *ref = nullptr;\n        if (TIFFGetField(hTIFFTmp, TIFFTAG_REFERENCEBLACKWHITE, &ref))\n            TIFFSetField(hTIFF, TIFFTAG_REFERENCEBLACKWHITE, ref);\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n    VSIUnlink(osTmpFilenameIn);\n}",
    "TImageP TImageReaderTZP::load() {\n  /*\nFILE *fp;\nif ((fp = _wfopen(getFilePath().getWideString().c_str(), L\"rb\")) == NULL)\n{\nthrow TImageException(getFilePath(),\"can't open file\");\n}\n\n//{\n//  fclose(fp);\n//  throw TImageException(getFilePath(),\"invalid file format\");\n//}\n\nTRaster32P raster(lx,ly);\nTPixel32* row;\n\nTRasterImageP rasImage(raster);\n\nTImageP image(rasImage);\n\n*/\n\n  wstring fn = getFilePath().getWideString();\n  TIFF *tfp;\n  IMAGE *image = NIL;\n  TZUP_FIELDS tzup_f;\n  // char pltname[1024];\n  USHORT *window = NIL;\n  USHORT *palette; /*  [TOONZPALETTE_COUNT] */\n  // int max_n_colors, max_n_pencils;\n\n  /*\nCHECK_IMAGEDLL_LICENSE_AND_GET_IMG_LICENSE_ATTR\nSET_READ_WITH_EXTRA\n*/\n\n  Silent_tiff_print_error               = 1;\n  Tiff_ignore_missing_internal_colormap = 1;\n  tfp                                   = TIFFOpen(fn.c_str(), \"r\");\n  if (!tfp) return TImageP();\n\n  if (!get_tzup_fields(tfp, &tzup_f)) return TImageP();\n\n  /*\nif (tzup_f.edu_file && !(Img_license_attr & TA_TOONZ_EDU))\n{\nchar str[1024];\nBUILD_EDU_ERROR_STRING(str)\ntmsg_error (str);\ngoto bad;\n}\n*/\n\n  // image = new IMAGE; // new_img();\n  // if (!image)\n  //  goto bad;\n\n  if (!TIFFGetField(tfp, TIFFTAG_TOONZPALETTE, &palette)) {\n    // image->cmap.info = Tcm_old_default_info;\n  } else {\n    //// image->cmap.info.tone_offs   = palette[3]; sempre 0\n    /*\nimage->cmap.info.tone_bits   = (UCHAR)palette[4];\nimage->cmap.info.color_offs  = (UCHAR)palette[5];\nimage->cmap.info.color_bits  = (UCHAR)palette[6];\nimage->cmap.info.pencil_offs = (UCHAR)palette[7];\nimage->cmap.info.pencil_bits = (UCHAR)palette[8];\nimage->cmap.info.offset_mask = palette[9];\nimage->cmap.info.n_tones     = 1 << palette[4];\nimage->cmap.info.n_colors    = palette[10];\nimage->cmap.info.n_pencils   = palette[11];\nimage->cmap.info.default_val = (image->cmap.info.n_tones-1) |\n                      image->cmap.info.offset_mask;\n*/\n  }\n\n  /* estendo la palette */\n\n  /*\nmax_n_colors  = 1 << image->cmap.info.color_bits;\nmax_n_pencils = 1 << image->cmap.info.pencil_bits;\nif (max_n_colors  > image->cmap.info.n_colors ||\nmax_n_pencils > image->cmap.info.n_pencils)\n{\nimage->cmap.info.n_colors  = max_n_colors;\nimage->cmap.info.n_pencils = max_n_pencils;\nimage->cmap.color_n  = image->cmap.info.n_colors;\nimage->cmap.pencil_n = image->cmap.info.n_pencils;\n}\n*/\n\n  TRasterCM16P raster(tzup_f.xsize, tzup_f.ysize);\n\n  ///===========\n  {\n    bool swapNeeded = scanline_needs_swapping(tfp);\n\n    int x0    = tzup_f.x0;\n    int y0    = tzup_f.y0;\n    int lx    = tzup_f.xSBsize;\n    int ly    = tzup_f.ySBsize;\n    int x1    = x0 + lx - 1;\n    int y1    = y0 + ly - 1;\n    int xsize = tzup_f.xsize;\n    int ysize = tzup_f.ysize;\n\n    int wrap = tzup_f.xsize;\n\n    assert(raster->getBounds().contains(TRect(x0, y0, x1, y1)));\n    raster->fillOutside(TRect(x0, y0, x1, y1), TPixelCM16(0, 0, 15));\n    raster->lock();\n    for (int y = y0; y <= y1; y++) {\n      TPixelCM16 *row = raster->pixels(y) + x0;\n      if (TIFFReadScanline(tfp, (UCHAR *)row, y - y0, 0) < 0)\n        if (swapNeeded) TIFFSwabArrayOfShort((USHORT *)row, lx);\n    }\n    raster->unlock();\n    /*\nbuf   = image->pixmap.buffer;\ndefault_val = image->cmap.info.default_val;\nfor (y = 0; y < y0; y++)\n{\npix = buf + y * wrap;\nfor (x = 0; x < xsize; x++)\n*pix++ = default_val;\n}\nfor ( ; y <= y1; y++)\n{\npix = buf + y * wrap;\nfor (x = 0; x < x0; x++)\n*pix++ = default_val;\nif (TIFFReadScanline (tf, (UCHAR *)pix, y - y0, 0) < 0)\n{\nstatic int gia_dato = FALSE;\nif ( !gia_dato)\n{\n//tmsg_error(\"bad data read on line %d\", y);\ngia_dato = TRUE;\n}\nmemset (pix, 0, lx * sizeof(*pix));\n}\nif (swap_needed)\nTIFFSwabArrayOfShort((USHORT *)pix, lx);\npix += lx;\nfor (x = x1 + 1; x < xsize; x++)\n*pix++ = default_val;\n}\nfor ( ; y < ysize; y++)\n{\npix = buf + y * wrap;\nfor (x = 0; x < xsize; x++)\n*pix++ = default_val;\n}\n*/\n  }\n  ///===========\n\n  switch (tzup_f.photometric) {\n    CASE PHOTOMETRIC_MINISBLACK : __OR PHOTOMETRIC_MINISWHITE\n                                  : __OR PHOTOMETRIC_RGB\n                                    :;  // image->type = RGB;\n\n    CASE PHOTOMETRIC_PALETTE :\n        /*\nif (tzup_f.bits_per_sample == 32)\nimage->type = CMAPPED24;\nelse\nimage->type = CMAPPED;\n*/\n\n        DEFAULT:\n        // tmsg_error(\"bad photometric interpretation in file %s\", filename);\n        // goto bad;\n        ;\n  }\n\n  // if (!get_history(tfp, &image->history))\n  //  image->history = NIL;\n\n  // image->pixmap.extra_mask = tzup_f.extra_mask;\n\n  // if (!allocate_pixmap(image, tzup_f.xsize, tzup_f.ysize))\n  // image->pixmap.buffer = new USHORT[tzup_f.xsize*tzup_f.ysize];\n  // if(!image->pixmap.buffer)\n  //  goto bad;\n\n  // image->pixmap.xD      = tzup_f.x0;\n  // image->pixmap.yD      = tzup_f.y0;\n  // image->pixmap.xSBsize = tzup_f.xSBsize;\n  // image->pixmap.ySBsize = tzup_f.ySBsize;\n\n  /*\nif (!get_image(tfp, image))\n{\n//tmsg_error(\"no image while reading file %s\", filename);\ngoto bad;\n}\nif (!get_icon(tfp, image))\n{\n//make_icon(image, ICON_WIDTH, ICON_HEIGHT);\n}\nif (image->pixmap.extra)\nif ( !get_extra (tfp, image))\n{\n//tmsg_error(\"missing extra information while reading file %s\", filename);\ngoto bad;\n}\nimage->pixmap.x_dpi = tzup_f.x_dpi;\nimage->pixmap.y_dpi = tzup_f.y_dpi;\nimage->pixmap.h_pos = tzup_f.h_pos;\n\nSilent_tiff_print_error = 0;\nTiff_ignore_missing_internal_colormap = 0;\n*/\n\n  TIFFClose(tfp);\n\n  // image->filename = 0; // strsave(filename);\n\n  // get_plt_name(filename, pltname);\n  // image->cmap.name = 0; // strsave(pltname);\n\n  assert(0);\n  return 0;\n  // TToonzImageP toonzImage(raster);\n  // return TImageP(toonzImage);\n\n  /*\nbad:\nif (image)\n{\n//free_img(image);\n}\nSilent_tiff_print_error = 0;\nTiff_ignore_missing_internal_colormap = 0;\nif (tfp)\nTIFFClose(tfp);\nreturn NIL;\n\n*/\n}",
    "static bool scanline_needs_swapping(TIFF *tfp) {\n  USHORT compression;\n\n  TIFFGetField(tfp, TIFFTAG_COMPRESSION, &compression);\n  return compression == COMPRESSION_LZW && TIFFNeedSwab(tfp);\n}",
    "static int read_region_extra(IMAGE *image, TIFF *tfp, char *filename,\n                             INFO_REGION *region, int scale, UCHAR *buf,\n                             int wrap_out, int xD_offset, int yD_offset) {\n  UCHAR *inp = NIL, *outp = NIL, *appo_outp = NIL;\n  int row, nrow, rrow;\n  int scanline_size, rowperstrip;\n\n  if (!TIFFReadDirectory(tfp)) return FALSE;\n\n  scanline_size = TIFFScanlineSize(tfp);\n  if (!TIFFGetField(tfp, TIFFTAG_ROWSPERSTRIP, &rowperstrip))\n    rowperstrip = MAXINT / 2;\n\n  appo_outp = image->pixmap.extra + yD_offset * wrap_out + xD_offset;\n\n  if (Verbose)\n    printf(\"Posizione in uscita (extra): %d, %d\\n\", xD_offset, yD_offset);\n\n  /* Puntatore per avanzamento nel buffer della regione */\n  outp = appo_outp;\n\n  row = region->startScanRow;\n  /*\n* Questa serie di scanline viene fatta perche' non viene\n* accettato un accesso random alle righe del file.\n*/\n  if (row > 0) {\n    int c;\n    c = (row / rowperstrip) * rowperstrip;\n    for (; c < row; c++) {\n      if (TIFFReadScanline(tfp, buf, c, 0) < 0) {\n        // tmsg_error(\"bad extra data read on line %d of file %s\", c, filename);\n        return FALSE;\n      }\n    }\n  }\n  for (nrow = 0; nrow < region->scanNrow; nrow++) {\n    appo_outp = outp;\n    if (TIFFReadScanline(tfp, buf, row, 0) < 0) {\n      // tmsg_error(\"bad extra data read at line %d of file %s\", row, filename);\n      return FALSE;\n    }\n\n    inp = buf + region->startScanCol;\n    for (rrow = 0; rrow < region->scanNcol; rrow++) {\n      *outp++ = *inp;\n      inp += scale;\n    }\n    if (scale > 1) {\n      register currRow = 0, stepRow = 1, nextRow = 0;\n      if (row + scale > region->ly_in)\n        break;\n      else\n        nextRow = row + scale;\n      stepRow   = (nextRow / rowperstrip) * rowperstrip;\n      for (currRow = stepRow; currRow < nextRow; currRow++) {\n        if (TIFFReadScanline(tfp, buf, currRow, 0) < 0) {\n          // tmsg_error(\"bad extra data in file %s at line %d\", filename,\n          // currRow);\n          return FALSE;\n        }\n      }\n    }\n    outp = appo_outp + wrap_out;\n    row += scale;\n  }\n  return TRUE;\n}",
    "IMAGE *img_read_region_tzup(unsigned short *filename, int x1, int y1, int x2,\n                            int y2, int scale) {\n  TIFF *tfp    = NIL;\n  IMAGE *image = NIL;\n  INFO_REGION region;\n  TZUP_FIELDS tzup_f;\n  char pltname[1024];\n  UCHAR *buf = NIL;\n  USHORT planarconfig;\n  int rowperstrip;\n  int xsize_out, ysize_out, clear_xsize, clear_ysize;\n  int xD_offset, yD_offset;\n  int x1_reg, y1_reg, x2_reg, y2_reg;\n  int box_x1, box_y1, box_x2, box_y2;\n  USHORT *palette; /*  [TOONZPALETTE_COUNT] */\n  int scanline_size;\n  int ret;\n  int max_n_colors, max_n_pencils;\n\n  /*\nCHECK_IMAGEDLL_LICENSE_AND_GET_IMG_LICENSE_ATTR\nSET_READ_WITH_EXTRA\n*/\n\n  Silent_tiff_print_error               = 1;\n  Tiff_ignore_missing_internal_colormap = 1;\n  tfp                                   = TIFFOpen(filename, \"r\");\n  if (!tfp) return NIL;\n\n  if (!get_tzup_fields(tfp, &tzup_f)) goto bad;\n\n  /*\nif (tzup_f.edu_file && !(Img_license_attr & TA_TOONZ_EDU))\n{\nchar str[1024];\nBUILD_EDU_ERROR_STRING(str)\ntmsg_error (str);\ngoto bad;\n}\n*/\n\n  TIFFGetField(tfp, TIFFTAG_ROWSPERSTRIP, &rowperstrip);\n\n  TIFFGetField(tfp, TIFFTAG_PLANARCONFIG, &planarconfig);\n  if (planarconfig == PLANARCONFIG_SEPARATE) {\n    // tmsg_error(\"separate buffer image in file %s not supported\n    // yet\",filename);\n    goto bad;\n  }\n\n  image = new IMAGE;  // new_img();\n  if (!image) goto bad;\n\n  if (!TIFFGetField(tfp, TIFFTAG_TOONZPALETTE, &palette)) {\n    image->cmap.info = Tcm_old_default_info;\n  } else {\n    /*image->cmap.info.tone_offs   = palette[3]; */\n    image->cmap.info.tone_bits   = (UCHAR)palette[4];\n    image->cmap.info.color_offs  = (UCHAR)palette[5];\n    image->cmap.info.color_bits  = (UCHAR)palette[6];\n    image->cmap.info.pencil_offs = (UCHAR)palette[7];\n    image->cmap.info.pencil_bits = (UCHAR)palette[8];\n    image->cmap.info.offset_mask = palette[9];\n    image->cmap.info.n_tones     = 1 << palette[4];\n    image->cmap.info.n_colors    = palette[10];\n    image->cmap.info.n_pencils   = palette[11];\n    image->cmap.info.default_val =\n        (image->cmap.info.n_tones - 1) | image->cmap.info.offset_mask;\n  }\n\n  /* estendo la palette */\n\n  max_n_colors  = 1 << image->cmap.info.color_bits;\n  max_n_pencils = 1 << image->cmap.info.pencil_bits;\n  if (max_n_colors > image->cmap.info.n_colors ||\n      max_n_pencils > image->cmap.info.n_pencils) {\n    image->cmap.info.n_colors  = max_n_colors;\n    image->cmap.info.n_pencils = max_n_pencils;\n    image->cmap.color_n        = image->cmap.info.n_colors;\n    image->cmap.pencil_n       = image->cmap.info.n_pencils;\n  }\n\n  switch (tzup_f.photometric) {\n    CASE PHOTOMETRIC_MINISBLACK : __OR PHOTOMETRIC_MINISWHITE\n                                  : __OR PHOTOMETRIC_RGB : image->type = RGB;\n\n    CASE PHOTOMETRIC_PALETTE : if (tzup_f.bits_per_sample == 32) image->type =\n        CMAPPED24;\n    else image->type = CMAPPED;\n\n  DEFAULT:\n    // tmsg_error(\"bad photometric interpretation in file %s\", filename);\n    goto bad;\n  }\n\n  x1_reg = x1 - tzup_f.x0;\n  y1_reg = y1 - tzup_f.y0;\n\n  x2_reg = x2 - tzup_f.x0;\n  y2_reg = y2 - tzup_f.y0;\n\n  xsize_out = (x2 - x1) / scale + 1;\n  ysize_out = (y2 - y1) / scale + 1;\n\n  getInfoRegion(&region, x1_reg, y1_reg, x2_reg, y2_reg, scale, tzup_f.xSBsize,\n                tzup_f.ySBsize);\n\n  xD_offset = region.x_offset;\n  yD_offset = region.y_offset;\n\n  // if (Verbose)\n  //  printInfoRegion(&region);\n\n  image->pixmap.extra_mask = tzup_f.extra_mask;\n\n  // if (!allocate_pixmap(image, xsize_out, ysize_out))\n  image->pixmap.buffer = new USHORT[xsize_out * ysize_out];\n  if (image->pixmap.buffer) goto bad;\n\n  if (TRUE /* x1 != 0 || x2 != tzup_f.xsize - 1 ||\n             y1 != 0 || y2 != tzup_f.ysize - 1 */) {\n    clear_xsize = xsize_out;\n    clear_ysize = ysize_out;\n    if (image->type == CMAPPED)\n      clear_image_region_buffer_16(image->pixmap.buffer, 0, 0, clear_xsize,\n                                   clear_ysize, xsize_out,\n                                   image->cmap.info.offset_mask + 15);\n    else if (image->type == CMAPPED24)\n      clear_image_region_buffer_24((ULONG *)image->pixmap.buffer, 0, 0,\n                                   clear_xsize, clear_ysize, xsize_out, 255);\n    else\n      abort();\n  } else {\n    clear_xsize = 0;\n    clear_ysize = 0;\n  }\n  if (Verbose) {\n    printf(\"Clear xsize/xsize_out: %d/%d in %d:\\n\", clear_xsize, xsize_out,\n           tzup_f.xsize);\n    printf(\"Clear ysize/ysize_out: %d/%d in %d:\\n\", clear_ysize, ysize_out,\n           tzup_f.ysize);\n  }\n  if (image->pixmap.extra)\n    clear_extra_region(image->pixmap.extra, 0, 0, clear_xsize, clear_ysize,\n                       xsize_out, 0);\n  box_x1 = tzup_f.x0;\n  box_y1 = tzup_f.y0;\n  box_x2 = tzup_f.x0 + tzup_f.xSBsize - 1;\n  box_y2 = tzup_f.y0 + tzup_f.ySBsize - 1;\n  if (x1 > box_x2 || x2 < box_x1 || y1 > box_y2 || y2 < box_y1) {\n    image->pixmap.xsize   = xsize_out;\n    image->pixmap.ysize   = ysize_out;\n    image->pixmap.xSBsize = xsize_out;\n    image->pixmap.ySBsize = ysize_out;\n    image->pixmap.xD      = 0;\n    image->pixmap.yD      = 0;\n    image->pixmap.x_dpi   = tzup_f.x_dpi;\n    image->pixmap.y_dpi   = tzup_f.y_dpi;\n    image->pixmap.h_pos   = tzup_f.h_pos;\n    image->filename       = strsave(filename);\n    get_plt_name(filename, pltname);\n    image->cmap.name = strsave(pltname);\n    goto ok;\n  }\n  image->pixmap.xD      = xD_offset;\n  image->pixmap.yD      = yD_offset;\n  image->pixmap.xSBsize = region.scanNcol;\n  image->pixmap.ySBsize = region.scanNrow;\n\n  /* Buffer per la scanline */\n  scanline_size = TIFFScanlineSize(tfp);\n  TMALLOC(buf, scanline_size)\n  if (!buf) goto bad;\n\n  switch (image->type) {\n    CASE CMAPPED : ret = read_region_tzup_16(\n                       image, tfp, filename, &region, scale, buf, scanline_size,\n                       rowperstrip, xsize_out, xD_offset, yD_offset);\n    CASE CMAPPED24\n        : ret = read_region_tzup_24(image, tfp, filename, &region, scale, buf,\n                                    scanline_size, rowperstrip, xsize_out,\n                                    xD_offset, yD_offset);\n  DEFAULT:\n    ret = FALSE;\n    abort();\n  }\n  if (!ret) goto bad;\n\n  image->pixmap.x_dpi = tzup_f.x_dpi;\n  image->pixmap.y_dpi = tzup_f.y_dpi;\n  image->pixmap.h_pos = tzup_f.h_pos;\n\n  image->filename = strsave(filename);\n  get_plt_name(filename, pltname);\n  image->cmap.name = strsave(pltname);\n\n  if (!get_icon(tfp, image)) make_icon(image, ICON_WIDTH, ICON_HEIGHT);\n\n  if (image->pixmap.extra) {\n    ret = read_region_extra(image, tfp, filename, &region, scale, buf,\n                            xsize_out, xD_offset, yD_offset);\n    if (!ret) goto bad;\n  }\n\nok:\n  Silent_tiff_print_error               = 0;\n  Tiff_ignore_missing_internal_colormap = 0;\n  TIFFClose(tfp);\n  TFREE(buf);\n  return image;\n\nbad:\n  if (image) free_img(image);\n  Silent_tiff_print_error               = 0;\n  Tiff_ignore_missing_internal_colormap = 0;\n  TIFFClose(tfp);\n  TFREE(buf);\n  return NIL;\n}",
    "IMAGE *img_read_tzup_info(unsigned short *filename) {\n  TIFF *tfp;\n  IMAGE *image = NIL;\n  TZUP_FIELDS tzup_f;\n  USHORT *palette; /*  [TOONZPALETTE_COUNT] */\n  int max_n_colors, max_n_pencils;\n\n  /* CHECK_IMAGEDLL_LICENSE_AND_GET_IMG_LICENSE_ATTR */\n\n  Silent_tiff_print_error               = 1;\n  Tiff_ignore_missing_internal_colormap = 1;\n\n  tfp = TIFFOpen((wchar_t *)filename, \"r\");\n  if (!tfp) goto bad;\n\n  if (!get_tzup_fields(tfp, &tzup_f)) goto bad;\n\n  /*if (tzup_f.edu_file && !(Img_license_attr & TA_TOONZ_EDU))\n{\nchar str[1024];\nBUILD_EDU_ERROR_STRING(str)\ntmsg_warning (str);\n}\n*/\n\n  image = new IMAGE;  // new_img();\n  if (!image) goto bad;\n\n  if (!TIFFGetField(tfp, TIFFTAG_TOONZPALETTE, &palette)) {\n    image->cmap.info = Tcm_old_default_info;\n  } else {\n    /*image->cmap.info.tone_offs   = palette[3]; */\n    image->cmap.info.tone_bits   = (UCHAR)palette[4];\n    image->cmap.info.color_offs  = (UCHAR)palette[5];\n    image->cmap.info.color_bits  = (UCHAR)palette[6];\n    image->cmap.info.pencil_offs = (UCHAR)palette[7];\n    image->cmap.info.pencil_bits = (UCHAR)palette[8];\n    image->cmap.info.offset_mask = palette[9];\n    image->cmap.info.n_tones     = 1 << palette[4];\n    image->cmap.info.n_colors    = palette[10];\n    image->cmap.info.n_pencils   = palette[11];\n    image->cmap.info.default_val =\n        (image->cmap.info.n_tones - 1) | image->cmap.info.offset_mask;\n  }\n\n  /* estendo la palette */\n\n  max_n_colors  = 1 << image->cmap.info.color_bits;\n  max_n_pencils = 1 << image->cmap.info.pencil_bits;\n  if (max_n_colors > image->cmap.info.n_colors ||\n      max_n_pencils > image->cmap.info.n_pencils) {\n    image->cmap.info.n_colors  = max_n_colors;\n    image->cmap.info.n_pencils = max_n_pencils;\n    image->cmap.color_n        = image->cmap.info.n_colors;\n    image->cmap.pencil_n       = image->cmap.info.n_pencils;\n  }\n\n  switch (tzup_f.photometric) {\n    CASE PHOTOMETRIC_MINISBLACK : __OR PHOTOMETRIC_MINISWHITE\n                                  : __OR PHOTOMETRIC_RGB : image->type = RGB;\n\n    CASE PHOTOMETRIC_PALETTE : if (tzup_f.bits_per_sample == 32) image->type =\n        CMAPPED24;\n    else image->type = CMAPPED;\n\n  DEFAULT:\n    // tmsg_error(\"bad photometric interpretation in file %s\", filename);\n    goto bad;\n  }\n  image->pixmap.extra_mask = tzup_f.extra_mask;\n\n  if (!get_history(tfp, &image->history)) {\n    image->history = NIL;\n  }\n  image->pixmap.xsize   = tzup_f.xsize;\n  image->pixmap.ysize   = tzup_f.ysize;\n  image->pixmap.xD      = tzup_f.x0;\n  image->pixmap.yD      = tzup_f.y0;\n  image->pixmap.xSBsize = tzup_f.xSBsize;\n  image->pixmap.ySBsize = tzup_f.ySBsize;\n  image->pixmap.x_dpi   = tzup_f.x_dpi;\n  image->pixmap.y_dpi   = tzup_f.y_dpi;\n  image->pixmap.h_pos   = tzup_f.h_pos;\n\n  Silent_tiff_print_error               = 0;\n  Tiff_ignore_missing_internal_colormap = 0;\n  TIFFClose(tfp);\n  return image;\n\nbad:\n  if (image) {\n    // free_img(image);\n  }\n  Silent_tiff_print_error               = 0;\n  Tiff_ignore_missing_internal_colormap = 0;\n  if (tfp) TIFFClose(tfp);\n  return NIL;\n}",
    "IMAGE *img_read_tzup_icon(char *filename) {\n  TIFF *tfp;\n  IMAGE *image = NIL;\n  TZUP_FIELDS tzup_f;\n  char pltname[1024];\n  USHORT *palette; /*  [TOONZPALETTE_COUNT] */\n  int max_n_colors, max_n_pencils;\n\n  Silent_tiff_print_error               = 1;\n  Tiff_ignore_missing_internal_colormap = 1;\n  tfp                                   = TIFFOpen(filename, \"r\");\n  if (!tfp) return NIL;\n\n  if (!get_tzup_fields(tfp, &tzup_f)) goto bad;\n\n  image = new_img();\n  if (!image) goto bad;\n\n  image->type           = (tzup_f.bits_per_sample == 32) ? CMAPPED24 : CMAPPED;\n  image->pixmap.xsize   = tzup_f.xsize;\n  image->pixmap.ysize   = tzup_f.ysize;\n  image->pixmap.xSBsize = tzup_f.xSBsize;\n  image->pixmap.ySBsize = tzup_f.ySBsize;\n  image->pixmap.xD      = tzup_f.x0;\n  image->pixmap.yD      = tzup_f.y0;\n\n  get_plt_name(filename, pltname);\n  image->cmap.name = strsave(pltname);\n\n  if (!TIFFGetField(tfp, TIFFTAG_TOONZPALETTE, &palette)) {\n    image->cmap.info = Tcm_old_default_info;\n  } else {\n    /*image->cmap.info.tone_offs   = palette[3]; */\n    image->cmap.info.tone_bits   = palette[4];\n    image->cmap.info.color_offs  = palette[5];\n    image->cmap.info.color_bits  = palette[6];\n    image->cmap.info.pencil_offs = palette[7];\n    image->cmap.info.pencil_bits = palette[8];\n    image->cmap.info.offset_mask = palette[9];\n    image->cmap.info.n_tones     = 1 << palette[4];\n    image->cmap.info.n_colors    = palette[10];\n    image->cmap.info.n_pencils   = palette[11];\n    image->cmap.info.default_val =\n        (image->cmap.info.n_tones - 1) | image->cmap.info.offset_mask;\n  }\n\n  /* estendo la palette */\n\n  max_n_colors  = 1 << image->cmap.info.color_bits;\n  max_n_pencils = 1 << image->cmap.info.pencil_bits;\n  if (max_n_colors > image->cmap.info.n_colors ||\n      max_n_pencils > image->cmap.info.n_pencils) {\n    image->cmap.info.n_colors  = max_n_colors;\n    image->cmap.info.n_pencils = max_n_pencils;\n    image->cmap.color_n        = image->cmap.info.n_colors;\n    image->cmap.pencil_n       = image->cmap.info.n_pencils;\n  }\n\n  if (!get_icon(tfp, image)) {\n    // tmsg_error(\"unable to read icon image of file %s\", filename);\n    goto bad;\n  }\n  Silent_tiff_print_error               = 0;\n  Tiff_ignore_missing_internal_colormap = 0;\n  TIFFClose(tfp);\n  return image;\n\nbad:\n  if (image) free_img(image);\n  Silent_tiff_print_error               = 0;\n  Tiff_ignore_missing_internal_colormap = 0;\n  TIFFClose(tfp);\n  return NIL;\n}",
    "static int get_bits_per_sample(TIFF *tif, USHORT *bps) {\n  if (!TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, bps)) {\n    *bps = 0;\n    return FALSE;\n  }\n  switch (*bps) {\n    CASE 1 : __OR 2 : __OR 4 : __OR 8 : __OR 16 : __OR 32 : return TRUE;\n  }\n  return FALSE;\n}",
    "static int get_samples_per_pixel(TIFF *tif, USHORT *spp) {\n  if (!TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, spp)) {\n    *spp = 0;\n    return FALSE;\n  }\n  switch (*spp) { CASE 1 : __OR 3 : __OR 4 : return TRUE; }\n  return FALSE;\n}",
    "static int get_image_sizes(TIFF *tif, int *xsize, int *ysize) {\n  *ysize = 0;\n  if (!TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, xsize)) return FALSE;\n  if (!TIFFGetField(tif, TIFFTAG_IMAGELENGTH, ysize)) return FALSE;\n  return TRUE;\n}",
    "static void get_image_offsets_and_dimensions(TIFF *tfp, int xSBsize,\n                                             int ySBsize, int *x0, int *y0,\n                                             int *xsize, int *ysize,\n                                             double *h_pos, UCHAR *extra_mask,\n                                             TBOOL *edu_file) {\n  USHORT *window, orientation;\n  float xposition, dpi;\n  // int i;\n\n  if (!TIFFGetField(tfp, TIFFTAG_TOONZWINDOW, &window)) {\n    *x0         = 0;\n    *y0         = 0;\n    *xsize      = xSBsize;\n    *ysize      = ySBsize;\n    *extra_mask = 0;\n\n    *edu_file = FALSE;\n  } else {\n    *x0                     = window[0];\n    *y0                     = window[1];\n    *xsize                  = window[2];\n    *ysize                  = window[3];\n    if (*xsize == 0) *xsize = xSBsize + *x0;\n    if (*ysize == 0) *ysize = ySBsize + *y0;\n    *extra_mask             = Read_with_extra ? window[4] : 0;\n\n    *edu_file = window[TOONZWINDOW_COUNT - 1] & 1;\n  }\n  if (!TIFFGetField(tfp, TIFFTAG_XPOSITION, &xposition)) xposition = 8.0;\n  if (!TIFFGetField(tfp, TIFFTAG_ORIENTATION, &orientation))\n    orientation = ORIENTATION_TOPLEFT;\n  switch (orientation) {\n    CASE ORIENTATION_BOTLEFT\n        : __OR ORIENTATION_BOTRIGHT\n          : __OR ORIENTATION_TOPLEFT\n            : __OR ORIENTATION_TOPRIGHT\n              : if (!TIFFGetField(tfp, TIFFTAG_XRESOLUTION, &dpi)) dpi = 0.0;\n    CASE ORIENTATION_LEFTBOT\n        : __OR ORIENTATION_RIGHTBOT\n          : __OR ORIENTATION_LEFTTOP\n            : __OR ORIENTATION_RIGHTTOP\n              : if (!TIFFGetField(tfp, TIFFTAG_YRESOLUTION, &dpi)) dpi = 0.0;\n  }\n  *h_pos = (xposition - 8.0) * dpi;\n}",
    "static int get_photometric(TIFF *tif, USHORT *pm) {\n  if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, pm)) return FALSE;\n  return TRUE;\n}",
    "static int get_resolutions(TIFF *tif, double *x_dpi, double *y_dpi) {\n  float xdpi, ydpi;\n  // USHORT resunit;\n\n  if (!TIFFGetField(tif, TIFFTAG_XRESOLUTION, &xdpi) ||\n      !TIFFGetField(tif, TIFFTAG_YRESOLUTION, &ydpi)) {\n    *x_dpi = *y_dpi = 0.0;\n    return FALSE;\n  }\n  *x_dpi = (double)xdpi;\n  *y_dpi = (double)ydpi;\n  return TRUE;\n}",
    "static int get_orientation(TIFF *tif, int *orientation) {\n  if (!TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation)) return FALSE;\n  return TRUE;\n}",
    "static int get_rows_per_strip(TIFF *tif, long *rowperstrip) {\n  if (!TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowperstrip)) return FALSE;\n  return TRUE;\n}",
    "static int get_compression(TIFF *tif, int *compression) {\n  if (!TIFFGetField(tif, TIFFTAG_COMPRESSION, &compression)) return FALSE;\n  return TRUE;\n}",
    "static int get_tag_software(TIFF *tif, char *tag_software) {\n  if (!TIFFGetField(tif, TIFFTAG_SOFTWARE, tag_software)) return FALSE;\n  return TRUE;\n}",
    "static void get_planarconfig(TIFF *tif, USHORT *planarconfig) {\n  TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planarconfig);\n}",
    "static int get_history(TIFF *tif, char **history) {\n  if (!TIFFGetField(tif, TIFFTAG_TOONZHISTORY, history)) return FALSE;\n  //*history = strsave(*history);\n  return TRUE;\n}",
    "static int get_image(TIFF *tf, IMAGE *image) {\n  USHORT planarconfig;\n  // int i;\n\n  TIFFGetField(tf, TIFFTAG_PLANARCONFIG, &planarconfig);\n  if (planarconfig == PLANARCONFIG_SEPARATE) {\n    // tmsg_error(\"separate buffer image not supported yet in .tz(up) files\");\n    return FALSE;\n  }\n  switch (image->type) {\n    CASE CMAPPED : return get_image_contig_16(tf, image);\n    CASE CMAPPED24 : return get_image_contig_24(tf, image);\n  DEFAULT:\n    abort();\n  }\n  return FALSE;\n}",
    "void TifReader::open(FILE *file) {\n  int fd = fileno(file);\n#if 0\n\tm_tiff = TIFFFdOpenNoCloseProc(fd, \"\", \"rb\");\n#elif defined(_WIN32) && defined(__GNUC__)\n  m_tiff = TIFFFdOpen((int)_get_osfhandle(dup(fd)), \"\", \"rb\");\n#else\n  m_tiff = TIFFFdOpen(dup(fd), \"\", \"rb\");\n#endif\n  if (!m_tiff) {\n    std::string str(\"Tiff file closed\");\n    throw(str);\n  }\n\n  uint32 w = 0, h = 0, rps = 0;\n  uint16 bps = 0, spp = 0;\n  uint32 tileWidth = 0, tileLength = 0;\n\n  // TIFFSetDirectory(m_tiff,1);\n  // TIFFGetField(m_tiff, TIFFTAG_PAGENUMBER, &pn);\n  // int pn = TIFFNumberOfDirectories(m_tiff);\n  // TIFFSetDirectory(m_tiff,1);\n  TIFFGetField(m_tiff, TIFFTAG_IMAGEWIDTH, &w);\n  TIFFGetField(m_tiff, TIFFTAG_IMAGELENGTH, &h);\n  TIFFGetField(m_tiff, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetField(m_tiff, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetField(m_tiff, TIFFTAG_ROWSPERSTRIP, &rps);\n  // int stripCount = TIFFNumberOfStrips(m_tiff);\n  // int tileCount = TIFFNumberOfTiles(m_tiff);\n  TIFFGetField(m_tiff, TIFFTAG_TILEWIDTH, &tileWidth);\n  TIFFGetField(m_tiff, TIFFTAG_TILELENGTH, &tileLength);\n  Tiio::TifWriterProperties *prop = new Tiio::TifWriterProperties();\n  m_info.m_properties             = prop;\n  uint16 orient                   = Tiio::TOP2BOTTOM;\n  if (TIFFGetField(m_tiff, TIFFTAG_ORIENTATION, &orient)) {\n    switch (orient) {\n    case ORIENTATION_TOPLEFT: /* row 0 top, col 0 lhs */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_TOPLEFT);\n      m_rowOrder = Tiio::TOP2BOTTOM;\n      break;\n    case ORIENTATION_TOPRIGHT: /* row 0 top, col 0 rhs */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_TOPRIGHT);\n      m_rowOrder = Tiio::TOP2BOTTOM;\n      break;\n    case ORIENTATION_LEFTTOP: /* row 0 lhs, col 0 top */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_LEFTTOP);\n      m_rowOrder = Tiio::TOP2BOTTOM;\n      break;\n    case ORIENTATION_RIGHTTOP: /* row 0 rhs, col 0 top */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_RIGHTTOP);\n      m_rowOrder = Tiio::TOP2BOTTOM;\n      break;\n\n    case ORIENTATION_BOTRIGHT: /* row 0 bottom, col 0 rhs */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_BOTRIGHT);\n      m_rowOrder = Tiio::BOTTOM2TOP;\n      break;\n    case ORIENTATION_BOTLEFT: /* row 0 bottom, col 0 lhs */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_BOTLEFT);\n      m_rowOrder = Tiio::BOTTOM2TOP;\n      break;\n    case ORIENTATION_RIGHTBOT: /* row 0 rhs, col 0 bottom */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_RIGHTBOT);\n      m_rowOrder = Tiio::BOTTOM2TOP;\n      break;\n    case ORIENTATION_LEFTBOT: /* row 0 lhs, col 0 bottom */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_LEFTBOT);\n      m_rowOrder = Tiio::BOTTOM2TOP;\n      break;\n    default:\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_NONE);\n      m_rowOrder = Tiio::TOP2BOTTOM;\n      break;\n    }\n  }\n\n  USHORT compression;\n  TIFFGetField(m_tiff, TIFFTAG_COMPRESSION, &compression);\n  switch (compression) {\n  case COMPRESSION_LZW:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_LZW);\n    break;\n  case COMPRESSION_PACKBITS:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_PACKBITS);\n    break;\n  case COMPRESSION_THUNDERSCAN:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_THUNDERSCAN);\n    break;\n  case COMPRESSION_CCITTFAX3:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_CCITTFAX3);\n    break;\n  case COMPRESSION_CCITTFAX4:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_CCITTFAX4);\n    break;\n  case COMPRESSION_CCITTRLE:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_CCITTRLE);\n    break;\n  case COMPRESSION_JPEG:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_JPEG);\n    break;\n  case COMPRESSION_OJPEG:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_OJPEG);\n    break;\n  case COMPRESSION_NONE:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_NONE);\n    break;\n  case COMPRESSION_SGILOG:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_SGILOG);\n    break;\n  case COMPRESSION_SGILOG24:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_SGILOG24);\n    break;\n  case COMPRESSION_ADOBE_DEFLATE:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_ADOBE_DEFLATE);\n    break;\n  case COMPRESSION_DEFLATE:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_DEFLATE);\n    break;\n  /*default :\nprop->m_compressionType.setValue(TNZ_INFO_COMPRESS_UNKNOWN);\nbreak;*/\n  default:\n    assert(0);\n  }\n\n  float xdpi = 0, ydpi = 0;\n  TIFFGetField(m_tiff, TIFFTAG_XRESOLUTION, &xdpi);\n  TIFFGetField(m_tiff, TIFFTAG_YRESOLUTION, &ydpi);\n\n  bool swapxy = false;  // orient == ORIENTATION_RIGHTTOP;\n\n  if (swapxy) {\n    std::swap(w, h);\n    std::swap(xdpi, ydpi);\n  }\n\n  m_xdpi        = xdpi;\n  m_ydpi        = ydpi;\n  m_info.m_lx   = w;\n  m_info.m_ly   = h;\n  m_info.m_dpix = xdpi;\n  m_info.m_dpiy = ydpi;\n\n  m_info.m_samplePerPixel = spp;\n\n  if (bps == 64 && spp == 3) bps = 16;  // immagine con bpp = 192\n\n  uint16 photometric;  // codice di controllo\n  TIFFGetField(m_tiff, TIFFTAG_PHOTOMETRIC, &photometric);\n  if (photometric == 3 &&\n      (bps == 2 || bps == 4))  // immagini con PHOTOMATRIC_PALETTE\n    bps = 8;\n\n  if (photometric == 1 && (bps == 12 || bps == 24)) bps = 16;\n\n  if (bps == 6) bps = 4;  // immagini con bps = 6\n\n  if (bps == 10 || bps == 12 ||\n      bps == 14)  // immagini con bps = 10 , 12 , 14 , 24 , 32\n    bps = 8;\n  if (bps == 24 || bps == 32) bps = 16;\n\n  m_info.m_bitsPerSample = bps;\n\n  if (bps == 8) switch (spp) {\n    case 1: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\" 8(GREYTONES)\");\n      break;\n    case 3: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"24(RGB)\");\n      break;\n    case 4: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    }\n  else if (bps == 16)\n    switch (spp) {\n    case 1: /* row 0 top, col 0 lhs */\n      // prop->m_bitsPerPixel.setValue(L\"16(GREYTONES)\");\n      break;\n    case 3: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"48(RGB)\");\n      break;\n    case 4: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"64(RGBM)\");\n      break;\n    }\n\n  else if (bps == 2)\n    switch (spp) {\n    case 1: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    case 3: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    case 4: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    }\n\n  else if (bps == 1)\n    switch (spp) {\n    case 1: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\" 1(BW)\");\n      break;\n    case 3: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    case 4: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    }\n\n  else if (bps == 4)\n    switch (spp) {\n    case 1: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\" 8(GREYTONES)\");\n      break;\n    case 3: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    case 4: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    }\n\n  else if (bps == 64 && spp == 3)\n    prop->m_bitsPerPixel.setValue(L\"64(RGBM)\");\n\n  else\n    assert(false);\n\n  if (TIFFIsTiled(m_tiff)) {\n    m_rowsPerStrip  = tileLength;\n    int tilesPerRow = (w + tileWidth - 1) / tileWidth;\n    // m_rowLength = tileWidth * tilesPerRow;\n    m_rowLength   = m_info.m_lx;\n    int pixelSize = bps == 16 ? 8 : 4;\n    int stripSize = m_rowsPerStrip * m_rowLength * pixelSize;\n\n    m_tmpRas = TRasterGR8P(stripSize, 1);\n    m_tmpRas->lock();\n\n    m_stripBuffer = m_tmpRas->getRawData();\n  } else {\n    m_rowsPerStrip = rps;\n    // if(m_rowsPerStrip<=0) m_rowsPerStrip = 1;\t\t\t//potrei\n    // mettere\n    // qualsiasi\n    // valore\n    // purchè sia lo stesso in tif_getimage.c linea 2512\n    // if(m_rowsPerStrip==-1) assert(0);\n\n    if (m_rowsPerStrip <= 0) m_rowsPerStrip = m_info.m_ly;\n\n    int stripSize = m_rowsPerStrip * w * 4;  // + 4096;  TIFFStripSize(m_tiff);\n\n    if (bps == 16) stripSize *= 2;\n\n    m_tmpRas = TRasterGR8P(stripSize, 1);\n    m_tmpRas->lock();\n\n    m_stripBuffer = m_tmpRas->getRawData();\n\n    m_rowLength = m_info.m_lx;  // w;\n  }\n\n  /*\nint TIFFTileRowSize(m_tiff);\n\nm_rowsPerStrip = 0;\nif(TIFFGetField(m_tiff, TIFFTAG_ROWSPERSTRIP, &rps) )\n{\nint stripSize = TIFFStripSize(m_tiff);\nif(stripSize>0)\n {\n }\n}\n*/\n  if (m_isTzi) {\n    USHORT risCount  = 0;\n    USHORT *risArray = 0;\n\n    if (TIFFGetField(m_tiff, TIFFTAG_TOONZWINDOW, &risCount, &risArray)) {\n      if (m_info.m_lx == risArray[2] &&\n          m_info.m_ly ==\n              risArray[3])  // se sono diverse, la lettura tif crasha....\n      {\n        // m_info.m_lx = risArray[2];\n        // m_info.m_ly = risArray[3];\n        m_info.m_x0 = risArray[0];\n        m_info.m_y0 = risArray[1];\n      }\n      //      USHORT extraMask = risArray[4];\n      // bool isEduFile = risArray[TOONZWINDOW_COUNT - 1] & 1;\n    } else {\n      m_info.m_x0 = 0;\n      m_info.m_y0 = 0;\n    }\n    if (swapxy) {\n      std::swap(m_info.m_x0, m_info.m_y0);\n      std::swap(m_info.m_lx, m_info.m_ly);\n    }\n    m_info.m_x1 = m_info.m_x0 + w;\n    m_info.m_y1 = m_info.m_y0 + h;\n  } else {\n    m_info.m_x0 = m_info.m_y0 = 0;\n    m_info.m_x1               = m_info.m_x0 + m_info.m_lx - 1;\n    m_info.m_y1               = m_info.m_y0 + m_info.m_ly - 1;\n  }\n}\n",
    "void PltReader::open(FILE *file) {\n  char *data;\n  uint32 count;\n  int i;\n  for (i = 0; i < 256; i++) ComboInkIndex[i] = -1;\n\n  int fd = fileno(file);\n\n  TIFFErrorHandler oldhandler;\n  oldhandler = TIFFSetWarningHandler(NULL);\n  m_tiff     = TIFFFdOpen(fd, \"\", \"rb\");\n  TIFFSetWarningHandler(oldhandler);\n\n  if (!m_tiff) return;\n\n  uint32 w = 0, h = 0, rps = 0;\n  uint32 tileWidth = 0, tileLength = 0;\n  uint16 bps = 0, spp = 0;\n\n  TIFFGetField(m_tiff, TIFFTAG_IMAGEWIDTH, &w);\n  TIFFGetField(m_tiff, TIFFTAG_IMAGELENGTH, &h);\n  TIFFGetField(m_tiff, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetField(m_tiff, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetField(m_tiff, TIFFTAG_ROWSPERSTRIP, &rps);\n\n  float xdpi, ydpi;\n  TIFFGetField(m_tiff, TIFFTAG_XRESOLUTION, &xdpi);\n  TIFFGetField(m_tiff, TIFFTAG_YRESOLUTION, &ydpi);\n  m_info.m_dpix = xdpi;\n  m_info.m_dpiy = ydpi;\n\n  TIFFGetField(m_tiff, TIFFTAG_TILEWIDTH, &tileWidth);\n  TIFFGetField(m_tiff, TIFFTAG_TILELENGTH, &tileLength);\n\n  uint32 risCount  = 0;\n  USHORT *risArray = 0;\n\n  m_info.m_lx = w;\n  m_info.m_ly = h;\n  m_x         = 0;\n  m_y         = 0;\n  m_lx        = w;\n  m_ly        = h;\n\n  assert(h == 1);\n  m_ly = m_info.m_ly = 2;  // per l'infoRow\n\n  if (TIFFGetField(m_tiff, TIFFTAG_TOONZWINDOW, &risCount, &risArray)) {\n    m_info.m_x0 = m_x = risArray[0];\n    m_info.m_y0 = m_y = risArray[1];\n    m_info.m_lx       = risArray[2];\n    m_info.m_ly       = risArray[3];\n  } else {\n    m_info.m_x0 = 0;\n    m_info.m_y0 = 0;\n  }\n\n  m_info.m_x1 = m_info.m_x0 + w;\n  m_info.m_y1 = m_info.m_y0 + h;\n\n  if (TIFFIsTiled(m_tiff)) {\n    m_rowsPerStrip  = tileLength;\n    int tilesPerRow = (w + tileWidth - 1) / tileWidth;\n    m_rowLength     = tileWidth * tilesPerRow;\n    int stripSize   = m_rowsPerStrip * m_rowLength * 4;\n    m_stripBuffer   = new UCHAR[stripSize];\n  } else {\n    m_rowsPerStrip = rps;\n    int stripSize  = rps * w * 4 + 4096;  // TIFFStripSize(m_tiff);\n\n    m_stripBuffer = new UCHAR[stripSize];\n    m_rowLength   = w;\n  }\n\n  uint32 paletteCount;\n  USHORT *palette;\n\n  TIFFGetField(m_tiff, TIFFTAG_TOONZPALETTE, &paletteCount, &palette);\n  assert(paletteCount);\n\n  m_pltType = palette[0];\n\n  m_nColor  = palette[10];\n  m_nPencil = palette[11];\n\n  bool isOldCmap13Plt = false;\n  if (m_nColor == 128 && m_nPencil == 32) {\n    isOldCmap13Plt = true;\n  }\n\n  std::string colorNames;\n  if (TIFFGetField(m_tiff, TIFFTAG_TOONZCOLORNAMES, &count, &data))\n    colorNames = data;\n\n  TREE *names = cdb_decode_all(data, Tcm_24_default_info);\n\n  CDB_TREE_ITEM *item;\n\n  char *pageName;\n  int key, sisterIndex;\n\n  int maxCount = m_nColor + m_nPencil;\n  m_infoRow.resize(maxCount, TPixel32(0, 0, 0, 0));\n\n  for (i = 0; i < maxCount; i++) {\n    item = (CDB_TREE_ITEM *)avl_locate(names, i);\n    if (!item) continue;\n    decode_group_name(item->group, &pageName, &key, &sisterIndex);\n\n    if (strcmp(pageName, \"_UNUSED_PAGE\") == 0) continue;\n    if (sisterIndex == -1 || i < m_nColor) m_infoRow[i].r = 255;\n    if (i < m_nColor) m_infoRow[i].g = 255;\n\n    while (isdigit(item->name[0]))  // in toonz colors cannot begin with digits\n      item->name++;\n\n    std::map<int, std::pair<std::string, std::string>>::iterator it;\n    if ((it = m_pltNames.find(i)) == m_pltNames.end() ||\n        isDefaultName(it->second.second))\n      m_pltNames[i] = std::pair<std::string, std::string>(pageName, item->name);\n\n    if (sisterIndex != -1) {\n      int comboindex;\n      if (isOldCmap13Plt) {\n        comboindex = (i < 128) ? (sisterIndex >> 11) + 128 : sisterIndex >> 4;\n        if (i == 128)\n          ComboInkIndex[0] = 0;\n        else if (i > 128)\n          ComboInkIndex[i - 128] = comboindex;\n      } else {\n        comboindex = (i < 256) ? (sisterIndex >> 16) + 256 : sisterIndex >> 8;\n        if (i >= 256) ComboInkIndex[i - 256] = comboindex;\n      }\n      std::map<int, std::pair<std::string, std::string>>::iterator it;\n      if ((it = m_pltNames.find(comboindex)) == m_pltNames.end() ||\n          isDefaultName(it->second.second)) {\n        m_pltNames[comboindex] =\n            std::pair<std::string, std::string>(pageName, item->name);\n        if (comboindex < m_nColor)\n          m_infoRow[comboindex].r = m_infoRow[comboindex].g = 255;\n      }\n    }\n  }\n\n  if (TIFFGetField(m_tiff, TIFFTAG_TOONZHISTORY, &count, &data))\n    m_history = data;\n\n  uint16 photometric, planarconfig;\n\n  TIFFGetField(m_tiff, TIFFTAG_PHOTOMETRIC, &photometric);\n  TIFFGetField(m_tiff, TIFFTAG_PLANARCONFIG, &planarconfig);\n\n  if (photometric != PHOTOMETRIC_RGB || planarconfig != PLANARCONFIG_CONTIG) {\n    // tmsg_error(\"bad !\");\n  }\n}",
    "void TzpReader::open(FILE *file) {\n  int fd = fileno(file);\n  TIFFErrorHandler oldhandler;\n  oldhandler = TIFFSetWarningHandler(NULL);\n  m_tiff     = TIFFFdOpen(fd, \"\", \"rb\");\n  TIFFSetWarningHandler(oldhandler);\n  if (!m_tiff) return;\n\n  uint32 w = 0, h = 0, bps = 0, spp = 0, rps = 0;\n  uint32 tileWidth = 0, tileLength = 0;\n\n  TIFFGetField(m_tiff, TIFFTAG_IMAGEWIDTH, &w);\n  TIFFGetField(m_tiff, TIFFTAG_IMAGELENGTH, &h);\n  TIFFGetField(m_tiff, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetField(m_tiff, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetField(m_tiff, TIFFTAG_ROWSPERSTRIP, &rps);\n\n  float xdpi, ydpi;\n  TIFFGetField(m_tiff, TIFFTAG_XRESOLUTION, &xdpi);\n  TIFFGetField(m_tiff, TIFFTAG_YRESOLUTION, &ydpi);\n  m_info.m_dpix = xdpi;\n  m_info.m_dpiy = ydpi;\n\n  TIFFGetField(m_tiff, TIFFTAG_TILEWIDTH, &tileWidth);\n  TIFFGetField(m_tiff, TIFFTAG_TILELENGTH, &tileLength);\n\n  uint32 risCount  = 0;\n  USHORT *risArray = 0;\n\n  m_info.m_lx = w;\n  m_info.m_ly = h;\n  m_x         = 0;\n  m_y         = 0;\n  m_lx        = w;\n  m_ly        = h;\n\n  if (TIFFGetField(m_tiff, TIFFTAG_TOONZWINDOW, &risCount, &risArray)) {\n    m_info.m_x0 = m_x = risArray[0];\n    m_info.m_y0 = m_y = risArray[1];\n    m_info.m_lx       = risArray[2];\n    m_info.m_ly       = risArray[3];\n  } else {\n    m_info.m_x0 = 0;\n    m_info.m_y0 = 0;\n  }\n\n  m_info.m_x1 = m_info.m_x0 + w;\n  m_info.m_y1 = m_info.m_y0 + h;\n\n  if (TIFFIsTiled(m_tiff)) {\n    m_rowsPerStrip  = tileLength;\n    int tilesPerRow = (w + tileWidth - 1) / tileWidth;\n    m_rowLength     = tileWidth * tilesPerRow;\n    int stripSize   = m_rowsPerStrip * m_rowLength * 4;\n    m_stripBuffer   = new UCHAR[stripSize];\n  } else {\n    m_rowsPerStrip = rps;\n    int stripSize  = rps * w * 4 + 4096;  // TIFFStripSize(m_tiff);\n\n    m_stripBuffer = new UCHAR[stripSize];\n    m_rowLength   = w;\n  }\n\n  uint32 paletteCount;\n  USHORT *palette;\n\n  TIFFGetField(m_tiff, TIFFTAG_TOONZPALETTE, &paletteCount, &palette);\n\n  m_nColor  = palette[10];\n  m_nPencil = palette[11];\n\n  // Old 4.1 palette : 4bit paint, 4bit tone, 5bit ink\n  if (m_nColor == 128 && m_nPencil == 32) {\n    m_isOldCmap13 = true;\n  }\n\n  if (bps == 32)\n    m_isCmap24 = true;\n  else\n    m_isCmap24 = false;\n\n  char *data;\n  uint32 count;\n  TIFFGetField(m_tiff, TIFFTAG_TOONZHISTORY, &count, &data);\n  std::string history(data);\n\n  uint16 planarconfig;\n  TIFFGetField(m_tiff, TIFFTAG_PLANARCONFIG, &planarconfig);\n  if (planarconfig == PLANARCONFIG_SEPARATE) {\n    // tmsg_error(\"separate buffer image not supported yet in .tz(up) files\");\n  }\n}",
    "static int Toonz1Decode(TIFF* tif, tidataval_t* buffer, tsize_t bytes,\n                        tsample_t s) {\n  int enc, dec;\n  short bitspersample;\n  // USHORT *palette;\n  int tone_bits, color_offs, color_bits, pencil_offs, pencil_bits;\n  USHORT offset_mask;\n\n  if (!TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample)) assert(0);\n  enc = dec = 0;\n  switch (bitspersample) {\n  case 8:\n    assert(!\"Not Implemented\");\n    /*\ndec = tif_toonz1_decode_extra ((UCHAR *)tif->tif_rawcp, &enc,\n                       (UCHAR *)buffer);\n*/\n    break;\n\n  case 16: {\n    USHORT* palette;\n    USHORT paletteCount;\n    if (TIFFGetField(tif, TIFFTAG_TOONZPALETTE, &paletteCount, &palette)) {\n      tone_bits   = palette[4];\n      color_offs  = palette[5];\n      color_bits  = palette[6];\n      pencil_offs = palette[7];\n      pencil_bits = palette[8];\n      offset_mask = palette[9];\n    } else {\n      tone_bits   = 4;\n      color_offs  = 4;\n      color_bits  = 7;\n      pencil_offs = 11;\n      pencil_bits = 5;\n      offset_mask = 0;\n    }\n    dec = tif_toonz1_decode_cm16((UCHAR*)tif->tif_rawcp, &enc, (USHORT*)buffer,\n                                 tone_bits, color_offs, color_bits, pencil_offs,\n                                 pencil_bits, offset_mask);\n  } break;\n\n  case 32:\n    dec =\n        tif_toonz1_decode_cm24((UCHAR*)tif->tif_rawcp, &enc, (TUINT32*)buffer);\n    break;\n\n  default:\n    assert(0);\n  }\n  assert(enc);\n  assert(dec * bitspersample == bytes * 8);\n  tif->tif_rawcc += enc;\n  tif->tif_rawcp += enc;\n\n  return 1;\n}",
    "unsigned char *tifread(const char *filename, int *w, int *h, int *nc)\n{\n    TIFF *tif = TIFFOpen(filename, \"r\");\n    if (tif)\n    {\n        int samples = 4;\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, w);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, h);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samples);\n        size_t npixels = *w * *h;\n        uint32 *raster = (uint32 *)malloc(npixels * sizeof(uint32));\n        if (raster != NULL)\n        {\n            if (TIFFReadRGBAImage(tif, *w, *h, raster, 0))\n            {\n                *nc = 4;\n\n                unsigned char *raster2 = (unsigned char *)malloc(npixels * sizeof(uint32));\n                unsigned char *image = (unsigned char *)raster;\n                size_t widthbytes = *w * sizeof(uint32);\n                for (int i = 0; i < *h; i++)\n                {\n                    memcpy(raster2 + (npixels * sizeof(uint32)) - ((i + 1) * widthbytes), image + (i * widthbytes), widthbytes);\n                }\n                free(raster);\n                return (unsigned char *)raster2;\n            }\n            free(raster);\n        }\n        TIFFClose(tif);\n    }\n    return NULL;\n}",
    "Expected<TiffParameters> readTifParameters( TIFF* tiff )\n{\n    TiffParameters params;\n\n    int bitsPerSample = 0;\n    TIFFGetField( tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample );\n    params.bytesPerSample = bitsPerSample >> 3; // convert to bytes\n\n    int samplePerPixel = 0;\n    TIFFGetField( tiff, TIFFTAG_SAMPLESPERPIXEL, &samplePerPixel );\n    if ( samplePerPixel == 0 )\n    {\n        // incorrect tiff format, treat like Scalar\n        samplePerPixel = 1;\n    }\n    if ( samplePerPixel == 1 )\n        params.valueType = TiffParameters::ValueType::Scalar;\n    else if ( samplePerPixel == 3 )\n        params.valueType = TiffParameters::ValueType::RGB;\n    else if ( samplePerPixel == 4 )\n        params.valueType = TiffParameters::ValueType::RGBA;\n\n    int sampleFormat = 0;\n    TIFFGetField( tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat );\n    if ( sampleFormat == SAMPLEFORMAT_UINT || sampleFormat == 0 )\n        params.sampleType = TiffParameters::SampleType::Uint;\n    else if ( sampleFormat == SAMPLEFORMAT_INT )\n        params.sampleType = TiffParameters::SampleType::Int;\n    else if ( sampleFormat == SAMPLEFORMAT_IEEEFP )\n        params.sampleType = TiffParameters::SampleType::Float;\n\n    TIFFGetField( tiff, TIFFTAG_IMAGEWIDTH, &params.imageSize.x );\n    TIFFGetField( tiff, TIFFTAG_IMAGELENGTH, &params.imageSize.y );\n\n    params.tiled = bool( TIFFIsTiled( tiff ) );\n    if ( params.tiled )\n    {\n        TIFFGetField( tiff, TIFFTAG_TILEWIDTH, &params.tileSize.x );\n        TIFFGetField( tiff, TIFFTAG_TILELENGTH, &params.tileSize.y );\n\n        TIFFGetField( tiff, TIFFTAG_TILEDEPTH, &params.depth );\n        if ( params.depth != 0 )\n            params.layers = int( TIFFNumberOfTiles( tiff ) );\n    }\n\n    if ( params.valueType == TiffParameters::ValueType::Unknown ||\n        params.sampleType == TiffParameters::SampleType::Unknown )\n        return unexpected( \"Unsupported pixel format\" );\n\n    if ( params.depth != 0 )\n        return unexpected( \"Unsupported tiles format\" );\n\n    return params;\n}",
    "Expected<void> readRawTiff( const std::filesystem::path& path, RawTiffOutput& output )\n{\n    assert( output.size != 0 );\n    if ( output.size == 0 )\n        return unexpected( \"Cannot read file to empty buffer\" );\n    TiffHolder tiff( path, \"r\" );\n    if ( !tiff )\n        return unexpected( \"Cannot read file: \" + utf8string( path ) );\n    auto localParams = readTifParameters( tiff );\n    if ( !localParams.has_value() )\n        return unexpected( localParams.error() + \": \" + utf8string( path ) );\n    if ( output.params )\n        *output.params = *localParams;\n\n    if ( output.p2wXf )\n    {\n        // http://geotiff.maptools.org/spec/geotiff2.6.html\n        constexpr uint32_t TIFFTAG_ModelTiePointTag = 33922;\t/* GeoTIFF */\n        constexpr uint32_t TIFFTAG_ModelPixelScaleTag = 33550;\t/* GeoTIFF */\n        constexpr uint32_t TIFFTAG_ModelTransformationTag = 34264;\t/* GeoTIFF */\n        Matrix4d matrix;\n        if ( TIFFGetField( tiff, TIFFTAG_ModelTransformationTag, &matrix ) )\n        {\n            *output.p2wXf = AffineXf3f( Matrix4f( matrix ) );\n        }\n        else\n        {\n            double* dataTie;// will be freed with tiff\n            uint32_t count;\n            auto statusT = TIFFGetField( tiff, TIFFTAG_ModelTiePointTag, &count, &dataTie );\n            if ( statusT && count == 6 )\n            {\n                Vector3d tiePoints[2];\n                tiePoints[0] = { dataTie[0],dataTie[1],dataTie[2] };\n                tiePoints[0] = { dataTie[3],dataTie[4],dataTie[5] };\n\n                double* dataScale;// will be freed with tiff\n                Vector3d scale;\n                auto statusS = TIFFGetField( tiff, TIFFTAG_ModelPixelScaleTag, &count, &dataScale );\n                if ( statusS && count == 3 )\n                {\n                    scale = { dataScale[0],dataScale[1],dataScale[2] };\n\n                    output.p2wXf->A = Matrix3f::scale( float( scale.x ), -float( scale.y ),\n                        scale.z == 0.0 ? 1.0f : float( scale.z ) );\n                    output.p2wXf->b = Vector3f( tiePoints[1] );\n\n                    output.p2wXf->b.x += float( tiePoints[0].x );\n                    output.p2wXf->b.y += float( tiePoints[0].y );\n                    if ( scale.z != 0.0 )\n                        output.p2wXf->b.z += float( tiePoints[0].z );\n                }\n            }\n        }\n    }\n\n    if ( localParams->sampleType == TiffParameters::SampleType::Uint )\n    {\n        if ( localParams->bytesPerSample == sizeof( uint8_t ) )\n            readRawTiff<uint8_t>( tiff, output.bytes, output.size, *localParams, output.convertToFloat, output.min, output.max );\n        else if ( localParams->bytesPerSample == sizeof( uint16_t ) )\n            readRawTiff<uint16_t>( tiff, output.bytes, output.size, *localParams, output.convertToFloat, output.min, output.max );\n        else if ( localParams->bytesPerSample == sizeof( uint32_t ) )\n            readRawTiff<uint32_t>( tiff, output.bytes, output.size, *localParams, output.convertToFloat, output.min, output.max );\n        else if ( localParams->bytesPerSample == sizeof( uint64_t ) )\n            readRawTiff<uint64_t>( tiff, output.bytes, output.size, *localParams, output.convertToFloat, output.min, output.max );\n    }\n    else if ( localParams->sampleType == TiffParameters::SampleType::Int )\n    {\n        if ( localParams->bytesPerSample == sizeof( int8_t ) )\n            readRawTiff<int8_t>( tiff, output.bytes, output.size, *localParams, output.convertToFloat, output.min, output.max );\n        else if ( localParams->bytesPerSample == sizeof( int16_t ) )\n            readRawTiff<int16_t>( tiff, output.bytes, output.size, *localParams, output.convertToFloat, output.min, output.max );\n        else if ( localParams->bytesPerSample == sizeof( int32_t ) )\n            readRawTiff<int32_t>( tiff, output.bytes, output.size, *localParams, output.convertToFloat, output.min, output.max );\n        else if ( localParams->bytesPerSample == sizeof( int64_t ) )\n            readRawTiff<int64_t>( tiff, output.bytes, output.size, *localParams, output.convertToFloat, output.min, output.max );\n    }\n    else if ( localParams->sampleType == TiffParameters::SampleType::Float )\n    {\n        if ( localParams->bytesPerSample == sizeof( float ) )\n            readRawTiff<float>( tiff, output.bytes, output.size, *localParams, output.convertToFloat, output.min, output.max );\n        else if ( localParams->bytesPerSample == sizeof( double ) )\n            readRawTiff<double>( tiff, output.bytes, output.size, *localParams, output.convertToFloat, output.min, output.max );\n    }\n    return {};\n}",
    "void VICARDataset::BuildLabelPropertyGeoTIFF(CPLJSONObject &oLabel)\n{\n    auto oProperty = GetOrCreateJSONObject(oLabel, \"PROPERTY\");\n    auto oGeoTIFF = GetOrCreateJSONObject(oProperty, \"GEOTIFF\");\n\n    // Ported from Vicar Open Source: Afids expects to be able to read\n    // NITF_NROWS and NITF_NCOLS\n\n    oGeoTIFF.Add(\"NITF_NROWS\", nRasterYSize);\n    oGeoTIFF.Add(\"NITF_NCOLS\", nRasterXSize);\n\n    // Create a in-memory GeoTIFF file\n\n    const std::string osTmpFilename(\n        VSIMemGenerateHiddenFilename(\"vicar_tmp.tif\"));\n    GDALDriver *poGTiffDriver =\n        GDALDriver::FromHandle(GDALGetDriverByName(\"GTiff\"));\n    if (poGTiffDriver == nullptr)\n    {\n        CPLError(CE_Failure, CPLE_AppDefined, \"GTiff driver not available\");\n        return;\n    }\n    const char *const apszOptions[] = {\"GEOTIFF_VERSION=1.0\", nullptr};\n    auto poDS = std::unique_ptr<GDALDataset>(poGTiffDriver->Create(\n        osTmpFilename.c_str(), 1, 1, 1, GDT_Byte, apszOptions));\n    if (!poDS)\n        return;\n    poDS->SetSpatialRef(&m_oSRS);\n    if (m_bGotTransform)\n        poDS->SetGeoTransform(&m_adfGeoTransform[0]);\n    poDS->SetMetadataItem(GDALMD_AREA_OR_POINT,\n                          GetMetadataItem(GDALMD_AREA_OR_POINT));\n    poDS.reset();\n\n    // Open it with libtiff/libgeotiff\n    VSILFILE *fpL = VSIFOpenL(osTmpFilename.c_str(), \"r\");\n    if (fpL == nullptr)\n    {\n        VSIUnlink(osTmpFilename.c_str());\n        return;\n    }\n\n    TIFF *hTIFF = VSI_TIFFOpen(osTmpFilename.c_str(), \"r\", fpL);\n    CPLAssert(hTIFF);\n\n    GTIF *hGTIF = GTIFNew(hTIFF);\n    CPLAssert(hGTIF);\n\n    // Get geotiff keys and write them as VICAR metadata\n    for (const auto &gkey : GTiffShortKeys)\n    {\n        unsigned short val = 0;\n        if (GDALGTIFKeyGetSHORT(hGTIF, gkey, &val, 0, 1))\n        {\n            oGeoTIFF.Add(\n                CPLString(GTIFKeyName(gkey)).toupper(),\n                CPLSPrintf(\"%d(%s)\", val, GTIFValueNameEx(hGTIF, gkey, val)));\n        }\n    }\n\n    for (const auto &gkey : GTiffDoubleKeys)\n    {\n        double val = 0;\n        if (GDALGTIFKeyGetDOUBLE(hGTIF, gkey, &val, 0, 1))\n        {\n            oGeoTIFF.Add(CPLString(GTIFKeyName(gkey)).toupper(),\n                         CPLSPrintf(\"%.17g\", val));\n        }\n    }\n\n    for (const auto &gkey : GTiffAsciiKeys)\n    {\n        char szAscii[1024];\n        if (GDALGTIFKeyGetASCII(hGTIF, gkey, szAscii,\n                                static_cast<int>(sizeof(szAscii))))\n        {\n            oGeoTIFF.Add(CPLString(GTIFKeyName(gkey)).toupper(), szAscii);\n        }\n    }\n\n    GTIFFree(hGTIF);\n\n    // Get geotiff tags and write them as VICAR metadata\n    const std::map<int, const char *> oMapTagCodeToName = {\n        {TIFFTAG_GEOPIXELSCALE, \"MODELPIXELSCALETAG\"},\n        {TIFFTAG_GEOTIEPOINTS, \"MODELTIEPOINTTAG\"},\n        {TIFFTAG_GEOTRANSMATRIX, \"MODELTRANSFORMATIONTAG\"}};\n\n    for (const auto &kv : oMapTagCodeToName)\n    {\n        uint16_t nCount = 0;\n        double *padfValues = nullptr;\n        if (TIFFGetField(hTIFF, kv.first, &nCount, &padfValues))\n        {\n            std::string osVal(\"(\");\n            for (uint16_t i = 0; i < nCount; ++i)\n            {\n                if (i > 0)\n                    osVal += ',';\n                osVal += CPLSPrintf(\"%.17g\", padfValues[i]);\n            }\n            osVal += ')';\n            oGeoTIFF.Add(kv.second, osVal);\n        }\n    }\n\n    XTIFFClose(hTIFF);\n    CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n    VSIUnlink(osTmpFilename.c_str());\n}",
    "CPLErr GTIFWktFromMemBufEx(int nSize, unsigned char *pabyBuffer,\n                           OGRSpatialReferenceH *phSRS,\n                           double *padfGeoTransform, int *pnGCPCount,\n                           GDAL_GCP **ppasGCPList, int *pbPixelIsPoint,\n                           char ***ppapszRPCMD)\n\n{\n    const std::string osFilename(\n        VSIMemGenerateHiddenFilename(\"wkt_from_mem_buf.tif\"));\n\n    /* -------------------------------------------------------------------- */\n    /*      Initialization of libtiff and libgeotiff.                       */\n    /* -------------------------------------------------------------------- */\n    GTiffOneTimeInit();  // For RPC tag.\n    LibgeotiffOneTimeInit();\n\n    /* -------------------------------------------------------------------- */\n    /*      Create a memory file from the buffer.                           */\n    /* -------------------------------------------------------------------- */\n    VSILFILE *fp =\n        VSIFileFromMemBuffer(osFilename.c_str(), pabyBuffer, nSize, FALSE);\n    if (fp == nullptr)\n        return CE_Failure;\n\n    /* -------------------------------------------------------------------- */\n    /*      Initialize access to the memory geotiff structure.              */\n    /* -------------------------------------------------------------------- */\n    TIFF *hTIFF = VSI_TIFFOpen(osFilename.c_str(), \"rc\", fp);\n\n    if (hTIFF == nullptr)\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"TIFF/GeoTIFF structure is corrupt.\");\n        VSIUnlink(osFilename.c_str());\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n        return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Get the projection definition.                                  */\n    /* -------------------------------------------------------------------- */\n    bool bPixelIsPoint = false;\n    bool bPointGeoIgnore = false;\n    unsigned short nRasterType = 0;\n\n    GTIF *hGTIF = GTIFNew(hTIFF);\n    if (hGTIF)\n        GTIFAttachPROJContext(hGTIF, OSRGetProjTLSContext());\n\n    if (hGTIF != nullptr &&\n        GDALGTIFKeyGetSHORT(hGTIF, GTRasterTypeGeoKey, &nRasterType, 0, 1) ==\n            1 &&\n        nRasterType == static_cast<unsigned short>(RasterPixelIsPoint))\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore =\n            CPLTestBool(CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\", \"FALSE\"));\n    }\n    if (pbPixelIsPoint)\n        *pbPixelIsPoint = bPixelIsPoint;\n    if (ppapszRPCMD)\n        *ppapszRPCMD = nullptr;\n\n    if (phSRS)\n    {\n        *phSRS = nullptr;\n        if (hGTIF != nullptr)\n        {\n            GTIFDefn *psGTIFDefn = GTIFAllocDefn();\n            if (GTIFGetDefn(hGTIF, psGTIFDefn))\n            {\n                *phSRS = GTIFGetOGISDefnAsOSR(hGTIF, psGTIFDefn);\n            }\n            GTIFFreeDefn(psGTIFDefn);\n        }\n    }\n    if (hGTIF)\n        GTIFFree(hGTIF);\n\n    /* -------------------------------------------------------------------- */\n    /*      Get geotransform or tiepoints.                                  */\n    /* -------------------------------------------------------------------- */\n    double *padfTiePoints = nullptr;\n    double *padfScale = nullptr;\n    double *padfMatrix = nullptr;\n    int16_t nCount = 0;\n\n    padfGeoTransform[0] = 0.0;\n    padfGeoTransform[1] = 1.0;\n    padfGeoTransform[2] = 0.0;\n    padfGeoTransform[3] = 0.0;\n    padfGeoTransform[4] = 0.0;\n    padfGeoTransform[5] = 1.0;\n\n    *pnGCPCount = 0;\n    *ppasGCPList = nullptr;\n\n    if (TIFFGetField(hTIFF, TIFFTAG_GEOPIXELSCALE, &nCount, &padfScale) &&\n        nCount >= 2)\n    {\n        padfGeoTransform[1] = padfScale[0];\n        padfGeoTransform[5] = -std::abs(padfScale[1]);\n\n        if (TIFFGetField(hTIFF, TIFFTAG_GEOTIEPOINTS, &nCount,\n                         &padfTiePoints) &&\n            nCount >= 6)\n        {\n            padfGeoTransform[0] =\n                padfTiePoints[3] - padfTiePoints[0] * padfGeoTransform[1];\n            padfGeoTransform[3] =\n                padfTiePoints[4] - padfTiePoints[1] * padfGeoTransform[5];\n\n            // Adjust for pixel is point in transform.\n            if (bPixelIsPoint && !bPointGeoIgnore)\n            {\n                padfGeoTransform[0] -=\n                    padfGeoTransform[1] * 0.5 + padfGeoTransform[2] * 0.5;\n                padfGeoTransform[3] -=\n                    padfGeoTransform[4] * 0.5 + padfGeoTransform[5] * 0.5;\n            }\n        }\n    }\n    else if (TIFFGetField(hTIFF, TIFFTAG_GEOTIEPOINTS, &nCount,\n                          &padfTiePoints) &&\n             nCount >= 6)\n    {\n        *pnGCPCount = nCount / 6;\n        *ppasGCPList =\n            static_cast<GDAL_GCP *>(CPLCalloc(sizeof(GDAL_GCP), *pnGCPCount));\n\n        for (int iGCP = 0; iGCP < *pnGCPCount; iGCP++)\n        {\n            char szID[32] = {};\n            GDAL_GCP *psGCP = *ppasGCPList + iGCP;\n\n            snprintf(szID, sizeof(szID), \"%d\", iGCP + 1);\n            psGCP->pszId = CPLStrdup(szID);\n            psGCP->pszInfo = CPLStrdup(\"\");\n            psGCP->dfGCPPixel = padfTiePoints[iGCP * 6 + 0];\n            psGCP->dfGCPLine = padfTiePoints[iGCP * 6 + 1];\n            psGCP->dfGCPX = padfTiePoints[iGCP * 6 + 3];\n            psGCP->dfGCPY = padfTiePoints[iGCP * 6 + 4];\n            psGCP->dfGCPZ = padfTiePoints[iGCP * 6 + 5];\n        }\n    }\n    else if (TIFFGetField(hTIFF, TIFFTAG_GEOTRANSMATRIX, &nCount,\n                          &padfMatrix) &&\n             nCount == 16)\n    {\n        padfGeoTransform[0] = padfMatrix[3];\n        padfGeoTransform[1] = padfMatrix[0];\n        padfGeoTransform[2] = padfMatrix[1];\n        padfGeoTransform[3] = padfMatrix[7];\n        padfGeoTransform[4] = padfMatrix[4];\n        padfGeoTransform[5] = padfMatrix[5];\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Read RPC                                                        */\n    /* -------------------------------------------------------------------- */\n    if (ppapszRPCMD != nullptr)\n    {\n        *ppapszRPCMD = GTiffDatasetReadRPCTag(hTIFF);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup.                                                        */\n    /* -------------------------------------------------------------------- */\n    XTIFFClose(hTIFF);\n    CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n\n    VSIUnlink(osFilename.c_str());\n\n    if (phSRS && *phSRS == nullptr)\n        return CE_Failure;\n\n    return CE_None;\n}",
    "float\nLogo::changeFileName()\n{\n    // open file\n    bild_ = TIFFOpen(p_file_->getValue(), \"r\");\n    if (bild_ == NULL)\n    {\n        sendError(\"Could not open file.\");\n        return -1.0;\n    }\n    // read width in pixels\n    if (TIFFGetField(bild_, TIFFTAG_IMAGEWIDTH, &w_) != 1)\n    {\n        sendError(\"Could not allocate memory for raster_.\");\n        TIFFClose(bild_);\n        bild_ = NULL;\n        return -1.0;\n    }\n    // read height in pixels\n    if (TIFFGetField(bild_, TIFFTAG_IMAGELENGTH, &h_) != 1)\n    {\n        sendError(\"Could not read image.\");\n        TIFFClose(bild_);\n        bild_ = NULL;\n        return -1.0;\n    }\n    // @@@ problems with segmented memory (Windows...)\n    delete[] raster_;\n    raster_ = new uint32[w_ * h_];\n\n    if (raster_ == NULL)\n    {\n        sendError(\"Could not allocate memory for raster_.\");\n        TIFFClose(bild_);\n        bild_ = NULL;\n        return -1.0;\n    }\n    // read image content\n    if (TIFFReadRGBAImage(bild_, w_, h_, raster_, 0) != 1)\n    {\n        sendError(\"Could not read TIFF image.\");\n        TIFFClose(bild_);\n        delete[] raster_; // @@@ problems with segmented memory (Windows...)\n        bild_ = NULL;\n        raster_ = NULL;\n        return -1.0;\n    }\n\n    float XResolution, YResolution;\n    if (TIFFGetField(bild_, TIFFTAG_XRESOLUTION, &XResolution) != 1)\n    {\n        sendError(\"Could not read X Resolution.\");\n        return -1.0;\n    }\n    else if (TIFFGetField(bild_, TIFFTAG_YRESOLUTION, &YResolution) != 1)\n    {\n        sendInfo(\"Could not read Y Resolution. Assuming the same value as for the X dimension.\");\n        YResolution = XResolution;\n    }\n    TIFFClose(bild_);\n    bild_ = NULL;\n\n    float Width, Height;\n    Width = w_ / XResolution;\n    Height = h_ / YResolution;\n\n    if (p_size_->getValue() <= 0.0)\n    {\n        sendError(\"A positive value is expected in SizeX\");\n        return -1.0;\n    }\n\n    return p_size_->getValue() * Height / Width;\n}",
    "static void GTIFF_Set_TIFFTAG_JPEGTABLES(TIFF *hTIFF,\n                                         jpeg_compress_struct &sCInfo)\n{\n    const std::string osTmpFilename(VSIMemGenerateHiddenFilename(\"tables\"));\n    VSILFILE *fpTABLES = VSIFOpenL(osTmpFilename.c_str(), \"wb+\");\n\n    uint16_t nPhotometric = 0;\n    TIFFGetField(hTIFF, TIFFTAG_PHOTOMETRIC, &nPhotometric);\n\n    jpeg_vsiio_dest(&sCInfo, fpTABLES);\n\n    // Avoid unnecessary tables to be emitted.\n    if (nPhotometric != PHOTOMETRIC_YCBCR)\n    {\n        JQUANT_TBL *qtbl = sCInfo.quant_tbl_ptrs[1];\n        if (qtbl != nullptr)\n            qtbl->sent_table = TRUE;\n        JHUFF_TBL *htbl = sCInfo.dc_huff_tbl_ptrs[1];\n        if (htbl != nullptr)\n            htbl->sent_table = TRUE;\n        htbl = sCInfo.ac_huff_tbl_ptrs[1];\n        if (htbl != nullptr)\n            htbl->sent_table = TRUE;\n    }\n    jpeg_write_tables(&sCInfo);\n\n    CPL_IGNORE_RET_VAL(VSIFCloseL(fpTABLES));\n\n    vsi_l_offset nSizeTables = 0;\n    GByte *pabyJPEGTablesData =\n        VSIGetMemFileBuffer(osTmpFilename.c_str(), &nSizeTables, FALSE);\n    TIFFSetField(hTIFF, TIFFTAG_JPEGTABLES, static_cast<int>(nSizeTables),\n                 pabyJPEGTablesData);\n\n    VSIUnlink(osTmpFilename.c_str());\n}",
    "CPLErr GTIFF_CopyFromJPEG_WriteAdditionalTags(TIFF *hTIFF, GDALDataset *poSrcDS)\n{\n    poSrcDS = GetUnderlyingDataset(poSrcDS);\n    if (poSrcDS == nullptr)\n        return CE_Failure;\n\n    /* -------------------------------------------------------------------- */\n    /*      Write TIFFTAG_JPEGTABLES                                        */\n    /* -------------------------------------------------------------------- */\n\n    VSILFILE *fpJPEG = VSIFOpenL(poSrcDS->GetDescription(), \"rb\");\n    if (fpJPEG == nullptr)\n        return CE_Failure;\n\n    struct jpeg_error_mgr sJErr;\n    struct jpeg_decompress_struct sDInfo;\n    jmp_buf setjmp_buffer;\n\n    volatile bool bCallDestroyDecompress = false;\n    volatile bool bCallDestroyCompress = false;\n\n    struct jpeg_compress_struct sCInfo;\n\n    if (setjmp(setjmp_buffer))\n    {\n        if (bCallDestroyCompress)\n        {\n            jpeg_abort_compress(&sCInfo);\n            jpeg_destroy_compress(&sCInfo);\n        }\n        if (bCallDestroyDecompress)\n        {\n            jpeg_abort_decompress(&sDInfo);\n            jpeg_destroy_decompress(&sDInfo);\n        }\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpJPEG));\n        return CE_Failure;\n    }\n\n    sDInfo.err = jpeg_std_error(&sJErr);\n    sJErr.error_exit = GTIFF_ErrorExitJPEG;\n    sDInfo.client_data = &setjmp_buffer;\n\n    bCallDestroyDecompress = true;\n    jpeg_CreateDecompress(&sDInfo, JPEG_LIB_VERSION, sizeof(sDInfo));\n\n    jpeg_vsiio_src(&sDInfo, fpJPEG);\n    jpeg_read_header(&sDInfo, TRUE);\n\n    sCInfo.err = jpeg_std_error(&sJErr);\n    sJErr.error_exit = GTIFF_ErrorExitJPEG;\n    sCInfo.client_data = &setjmp_buffer;\n\n    jpeg_CreateCompress(&sCInfo, JPEG_LIB_VERSION, sizeof(sCInfo));\n    bCallDestroyCompress = true;\n    jpeg_copy_critical_parameters(&sDInfo, &sCInfo);\n    GTIFF_Set_TIFFTAG_JPEGTABLES(hTIFF, sCInfo);\n    bCallDestroyCompress = false;\n    jpeg_abort_compress(&sCInfo);\n    jpeg_destroy_compress(&sCInfo);\n    CPL_IGNORE_RET_VAL(bCallDestroyCompress);\n\n    /* -------------------------------------------------------------------- */\n    /*      Write TIFFTAG_REFERENCEBLACKWHITE if needed.                    */\n    /* -------------------------------------------------------------------- */\n\n    uint16_t nPhotometric = 0;\n    if (!TIFFGetField(hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric)))\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    uint16_t nBitsPerSample = 0;\n    if (!TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &(nBitsPerSample)))\n        nBitsPerSample = 1;\n\n    if (nPhotometric == PHOTOMETRIC_YCBCR)\n    {\n        /*\n         * A ReferenceBlackWhite field *must* be present since the\n         * default value is inappropriate for YCbCr.  Fill in the\n         * proper value if application didn't set it.\n         */\n        float *ref = nullptr;\n        if (!TIFFGetField(hTIFF, TIFFTAG_REFERENCEBLACKWHITE, &ref))\n        {\n            long top = 1L << nBitsPerSample;\n            float refbw[6] = {0.0};\n            refbw[1] = static_cast<float>(top - 1L);\n            refbw[2] = static_cast<float>(top >> 1);\n            refbw[3] = refbw[1];\n            refbw[4] = refbw[2];\n            refbw[5] = refbw[1];\n            TIFFSetField(hTIFF, TIFFTAG_REFERENCEBLACKWHITE, refbw);\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write TIFFTAG_YCBCRSUBSAMPLING if needed.                       */\n    /* -------------------------------------------------------------------- */\n\n    if (nPhotometric == PHOTOMETRIC_YCBCR && sDInfo.num_components == 3)\n    {\n        if ((sDInfo.comp_info[0].h_samp_factor == 1 ||\n             sDInfo.comp_info[0].h_samp_factor == 2) &&\n            (sDInfo.comp_info[0].v_samp_factor == 1 ||\n             sDInfo.comp_info[0].v_samp_factor == 2) &&\n            sDInfo.comp_info[1].h_samp_factor == 1 &&\n            sDInfo.comp_info[1].v_samp_factor == 1 &&\n            sDInfo.comp_info[2].h_samp_factor == 1 &&\n            sDInfo.comp_info[2].v_samp_factor == 1)\n        {\n            TIFFSetField(hTIFF, TIFFTAG_YCBCRSUBSAMPLING,\n                         sDInfo.comp_info[0].h_samp_factor,\n                         sDInfo.comp_info[0].v_samp_factor);\n        }\n        else\n        {\n            CPLDebug(\"GTiff\", \"Unusual sampling factors. \"\n                              \"TIFFTAG_YCBCRSUBSAMPLING not written.\");\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup.                                                        */\n    /* -------------------------------------------------------------------- */\n\n    bCallDestroyDecompress = false;\n    jpeg_abort_decompress(&sDInfo);\n    jpeg_destroy_decompress(&sDInfo);\n    CPL_IGNORE_RET_VAL(bCallDestroyDecompress);\n\n    if (VSIFCloseL(fpJPEG) != 0)\n        return CE_Failure;\n\n    return CE_None;\n}",
    "CPLErr GTIFF_CopyFromJPEG(GDALDataset *poDS, GDALDataset *poSrcDS,\n                          GDALProgressFunc pfnProgress, void *pProgressData,\n                          bool &bShouldFallbackToNormalCopyIfFail)\n{\n    bShouldFallbackToNormalCopyIfFail = true;\n\n    poSrcDS = GetUnderlyingDataset(poSrcDS);\n    if (poSrcDS == nullptr)\n        return CE_Failure;\n\n    VSILFILE *fpJPEG = VSIFOpenL(poSrcDS->GetDescription(), \"rb\");\n    if (fpJPEG == nullptr)\n        return CE_Failure;\n\n    CPLErr eErr = CE_None;\n\n    /* -------------------------------------------------------------------- */\n    /*      Initialization of the decompressor                              */\n    /* -------------------------------------------------------------------- */\n    struct jpeg_error_mgr sJErr;\n    struct jpeg_decompress_struct sDInfo;\n    memset(&sDInfo, 0, sizeof(sDInfo));\n    jmp_buf setjmp_buffer;\n    if (setjmp(setjmp_buffer))\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpJPEG));\n        jpeg_destroy_decompress(&sDInfo);\n        return CE_Failure;\n    }\n\n    sDInfo.err = jpeg_std_error(&sJErr);\n    sJErr.error_exit = GTIFF_ErrorExitJPEG;\n    sDInfo.client_data = &setjmp_buffer;\n\n    jpeg_CreateDecompress(&sDInfo, JPEG_LIB_VERSION, sizeof(sDInfo));\n\n    // This is to address bug related in ticket #1795.\n    if (CPLGetConfigOption(\"JPEGMEM\", nullptr) == nullptr)\n    {\n        // If the user doesn't provide a value for JPEGMEM, be sure that at\n        // least 500 MB will be used before creating the temporary file.\n        const long nMinMemory = 500 * 1024 * 1024;\n        sDInfo.mem->max_memory_to_use =\n            std::max(sDInfo.mem->max_memory_to_use, nMinMemory);\n    }\n\n    jpeg_vsiio_src(&sDInfo, fpJPEG);\n    jpeg_read_header(&sDInfo, TRUE);\n\n    jvirt_barray_ptr *pSrcCoeffs = jpeg_read_coefficients(&sDInfo);\n\n    /* -------------------------------------------------------------------- */\n    /*      Compute MCU dimensions                                          */\n    /* -------------------------------------------------------------------- */\n    int iMCU_sample_width = 8;\n    int iMCU_sample_height = 8;\n    if (sDInfo.num_components != 1)\n    {\n        iMCU_sample_width = sDInfo.max_h_samp_factor * 8;\n        iMCU_sample_height = sDInfo.max_v_samp_factor * 8;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Get raster and block dimensions                                 */\n    /* -------------------------------------------------------------------- */\n    int nBlockXSize = 0;\n    int nBlockYSize = 0;\n\n    const int nXSize = poDS->GetRasterXSize();\n    const int nYSize = poDS->GetRasterYSize();\n    // nBands = poDS->GetRasterCount();\n\n    // Don't use the GDAL block dimensions because of the split-band\n    // mechanism that can expose a pseudo one-line-strip whereas the\n    // real layout is a single big strip.\n\n    TIFF *hTIFF = static_cast<TIFF *>(poDS->GetInternalHandle(nullptr));\n    if (TIFFIsTiled(hTIFF))\n    {\n        TIFFGetField(hTIFF, TIFFTAG_TILEWIDTH, &(nBlockXSize));\n        TIFFGetField(hTIFF, TIFFTAG_TILELENGTH, &(nBlockYSize));\n    }\n    else\n    {\n        uint32_t nRowsPerStrip = 0;\n        if (!TIFFGetField(hTIFF, TIFFTAG_ROWSPERSTRIP, &(nRowsPerStrip)))\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"RowsPerStrip not defined ... assuming all one strip.\");\n            nRowsPerStrip = nYSize;  // Dummy value.\n        }\n\n        // If the rows per strip is larger than the file we will get\n        // confused.  libtiff internally will treat the rowsperstrip as\n        // the image height and it is best if we do too. (#4468)\n        if (nRowsPerStrip > static_cast<uint32_t>(nYSize))\n            nRowsPerStrip = nYSize;\n\n        nBlockXSize = nXSize;\n        nBlockYSize = nRowsPerStrip;\n    }\n\n    const int nXBlocks = (nXSize + nBlockXSize - 1) / nBlockXSize;\n    const int nYBlocks = (nYSize + nBlockYSize - 1) / nBlockYSize;\n\n    /* -------------------------------------------------------------------- */\n    /*      Copy blocks.                                                    */\n    /* -------------------------------------------------------------------- */\n\n    bShouldFallbackToNormalCopyIfFail = false;\n\n    for (int iY = 0; iY < nYBlocks && eErr == CE_None; iY++)\n    {\n        for (int iX = 0; iX < nXBlocks && eErr == CE_None; iX++)\n        {\n            GTIFF_CopyBlockFromJPEGArgs sArgs;\n            sArgs.hTIFF = hTIFF;\n            sArgs.psDInfo = &sDInfo;\n            sArgs.iX = iX;\n            sArgs.iY = iY;\n            sArgs.nXBlocks = nXBlocks;\n            sArgs.nXSize = nXSize;\n            sArgs.nYSize = nYSize;\n            sArgs.nBlockXSize = nBlockXSize;\n            sArgs.nBlockYSize = nBlockYSize;\n            sArgs.iMCU_sample_width = iMCU_sample_width;\n            sArgs.iMCU_sample_height = iMCU_sample_height;\n            sArgs.pSrcCoeffs = pSrcCoeffs;\n\n            eErr = GTIFF_CopyBlockFromJPEG(&sArgs);\n\n            if (!pfnProgress((iY * nXBlocks + iX + 1) * 1.0 /\n                                 (nXBlocks * nYBlocks),\n                             nullptr, pProgressData))\n                eErr = CE_Failure;\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup.                                                        */\n    /* -------------------------------------------------------------------- */\n\n    jpeg_finish_decompress(&sDInfo);\n    jpeg_destroy_decompress(&sDInfo);\n\n    if (VSIFCloseL(fpJPEG) != 0)\n        eErr = CE_Failure;\n\n    return eErr;\n}",
    "bool GTiffDataset::IsBlockAvailable(int nBlockId, vsi_l_offset *pnOffset,\n                                    vsi_l_offset *pnSize, bool *pbErrOccurred)\n\n{\n    if (pbErrOccurred)\n        *pbErrOccurred = false;\n\n    std::pair<vsi_l_offset, vsi_l_offset> oPair;\n    if (m_oCacheStrileToOffsetByteCount.tryGet(nBlockId, oPair))\n    {\n        if (pnOffset)\n            *pnOffset = oPair.first;\n        if (pnSize)\n            *pnSize = oPair.second;\n        return oPair.first != 0;\n    }\n\n    WaitCompletionForBlock(nBlockId);\n\n    // Optimization to avoid fetching the whole Strip/TileCounts and\n    // Strip/TileOffsets arrays.\n    if (eAccess == GA_ReadOnly && !m_bStreamingIn)\n    {\n        int nErrOccurred = 0;\n        auto bytecount =\n            TIFFGetStrileByteCountWithErr(m_hTIFF, nBlockId, &nErrOccurred);\n        if (nErrOccurred && pbErrOccurred)\n            *pbErrOccurred = true;\n        if (pnOffset)\n        {\n            *pnOffset =\n                TIFFGetStrileOffsetWithErr(m_hTIFF, nBlockId, &nErrOccurred);\n            if (nErrOccurred && pbErrOccurred)\n                *pbErrOccurred = true;\n        }\n        if (pnSize)\n            *pnSize = bytecount;\n        return bytecount != 0;\n    }\n\n    if (!m_bCrystalized)\n    {\n        // If this is a fresh new file not yet crystalized, do not try to\n        // read the [Strip|Tile][ByteCounts|Offsets] tags as they do not yet\n        // exist. Trying would set *pbErrOccurred=true, which is not desirable.\n        if (pnOffset)\n            *pnOffset = 0;\n        if (pnSize)\n            *pnSize = 0;\n        return false;\n    }\n\n    toff_t *panByteCounts = nullptr;\n    toff_t *panOffsets = nullptr;\n    const bool bIsTiled = CPL_TO_BOOL(TIFFIsTiled(m_hTIFF));\n\n    if ((bIsTiled &&\n         TIFFGetField(m_hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts) &&\n         (pnOffset == nullptr ||\n          TIFFGetField(m_hTIFF, TIFFTAG_TILEOFFSETS, &panOffsets))) ||\n        (!bIsTiled &&\n         TIFFGetField(m_hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts) &&\n         (pnOffset == nullptr ||\n          TIFFGetField(m_hTIFF, TIFFTAG_STRIPOFFSETS, &panOffsets))))\n    {\n        if (panByteCounts == nullptr ||\n            (pnOffset != nullptr && panOffsets == nullptr))\n        {\n            if (pbErrOccurred)\n                *pbErrOccurred = true;\n            return false;\n        }\n        const int nBlockCount =\n            bIsTiled ? TIFFNumberOfTiles(m_hTIFF) : TIFFNumberOfStrips(m_hTIFF);\n        if (nBlockId >= nBlockCount)\n        {\n            if (pbErrOccurred)\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        if (pnOffset)\n            *pnOffset = panOffsets[nBlockId];\n        if (pnSize)\n            *pnSize = panByteCounts[nBlockId];\n        return panByteCounts[nBlockId] != 0;\n    }\n    else\n    {\n        if (pbErrOccurred)\n            *pbErrOccurred = true;\n    }\n\n    return false;\n}",
    "void GTiffDataset::RestoreVolatileParameters(TIFF *hTIFF)\n{\n\n    /* -------------------------------------------------------------------- */\n    /*      YCbCr JPEG compressed images should be translated on the fly    */\n    /*      to RGB by libtiff/libjpeg unless specifically requested         */\n    /*      otherwise.                                                      */\n    /* -------------------------------------------------------------------- */\n    if (m_nCompression == COMPRESSION_JPEG &&\n        m_nPhotometric == PHOTOMETRIC_YCBCR &&\n        CPLTestBool(CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\")))\n    {\n        int nColorMode = JPEGCOLORMODE_RAW;  // Initialize to 0;\n\n        TIFFGetField(hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode);\n        if (nColorMode != JPEGCOLORMODE_RGB)\n        {\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n    }\n\n    if (m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        m_nCompression == COMPRESSION_LERC)\n    {\n        GTiffSetDeflateSubCodec(hTIFF);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Propagate any quality settings.                                 */\n    /* -------------------------------------------------------------------- */\n    if (eAccess == GA_Update)\n    {\n        // Now, reset zip and jpeg quality.\n        if (m_nJpegQuality > 0 && m_nCompression == COMPRESSION_JPEG)\n        {\n#ifdef DEBUG_VERBOSE\n            CPLDebug(\"GTiff\", \"Propagate JPEG_QUALITY(%d) in SetDirectory()\",\n                     m_nJpegQuality);\n#endif\n            TIFFSetField(hTIFF, TIFFTAG_JPEGQUALITY, m_nJpegQuality);\n        }\n        if (m_nJpegTablesMode >= 0 && m_nCompression == COMPRESSION_JPEG)\n            TIFFSetField(hTIFF, TIFFTAG_JPEGTABLESMODE, m_nJpegTablesMode);\n        if (m_nZLevel > 0 && (m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n                              m_nCompression == COMPRESSION_LERC))\n            TIFFSetField(hTIFF, TIFFTAG_ZIPQUALITY, m_nZLevel);\n        if (m_nLZMAPreset > 0 && m_nCompression == COMPRESSION_LZMA)\n            TIFFSetField(hTIFF, TIFFTAG_LZMAPRESET, m_nLZMAPreset);\n        if (m_nZSTDLevel > 0 && (m_nCompression == COMPRESSION_ZSTD ||\n                                 m_nCompression == COMPRESSION_LERC))\n            TIFFSetField(hTIFF, TIFFTAG_ZSTD_LEVEL, m_nZSTDLevel);\n        if (m_nCompression == COMPRESSION_LERC)\n        {\n            TIFFSetField(hTIFF, TIFFTAG_LERC_MAXZERROR, m_dfMaxZError);\n        }\n        if (m_nWebPLevel > 0 && m_nCompression == COMPRESSION_WEBP)\n            TIFFSetField(hTIFF, TIFFTAG_WEBP_LEVEL, m_nWebPLevel);\n        if (m_bWebPLossless && m_nCompression == COMPRESSION_WEBP)\n            TIFFSetField(hTIFF, TIFFTAG_WEBP_LOSSLESS, 1);\n#ifdef HAVE_JXL\n        if (m_nCompression == COMPRESSION_JXL ||\n            m_nCompression == COMPRESSION_JXL_DNG_1_7)\n        {\n            TIFFSetField(hTIFF, TIFFTAG_JXL_LOSSYNESS,\n                         m_bJXLLossless ? JXL_LOSSLESS : JXL_LOSSY);\n            TIFFSetField(hTIFF, TIFFTAG_JXL_EFFORT, m_nJXLEffort);\n            TIFFSetField(hTIFF, TIFFTAG_JXL_DISTANCE, m_fJXLDistance);\n            TIFFSetField(hTIFF, TIFFTAG_JXL_ALPHA_DISTANCE,\n                         m_fJXLAlphaDistance);\n        }\n#endif\n    }\n}",
    "void GTiffDataset::ScanDirectories()\n\n{\n    /* -------------------------------------------------------------------- */\n    /*      We only scan once.  We do not scan for non-base datasets.       */\n    /* -------------------------------------------------------------------- */\n    if (!m_bScanDeferred)\n        return;\n\n    m_bScanDeferred = false;\n\n    if (m_poBaseDS)\n        return;\n\n    Crystalize();\n\n    CPLDebug(\"GTiff\", \"ScanDirectories()\");\n\n    /* ==================================================================== */\n    /*      Scan all directories.                                           */\n    /* ==================================================================== */\n    CPLStringList aosSubdatasets;\n    int iDirIndex = 0;\n\n    FlushDirectory();\n\n    do\n    {\n        toff_t nTopDir = TIFFCurrentDirOffset(m_hTIFF);\n        uint32_t nSubType = 0;\n\n        ++iDirIndex;\n\n        toff_t *tmpSubIFDOffsets = nullptr;\n        toff_t *subIFDOffsets = nullptr;\n        uint16_t nSubIFDs = 0;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_SUBIFD, &nSubIFDs,\n                         &tmpSubIFDOffsets) &&\n            iDirIndex == 1)\n        {\n            subIFDOffsets =\n                static_cast<toff_t *>(CPLMalloc(nSubIFDs * sizeof(toff_t)));\n            for (uint16_t iSubIFD = 0; iSubIFD < nSubIFDs; iSubIFD++)\n            {\n                subIFDOffsets[iSubIFD] = tmpSubIFDOffsets[iSubIFD];\n            }\n        }\n\n        // early break for backwards compatibility: if the first directory read\n        // is also the last, and there are no subIFDs, no use continuing\n        if (iDirIndex == 1 && nSubIFDs == 0 && TIFFLastDirectory(m_hTIFF))\n        {\n            CPLFree(subIFDOffsets);\n            break;\n        }\n\n        for (uint16_t iSubIFD = 0; iSubIFD <= nSubIFDs; iSubIFD++)\n        {\n            toff_t nThisDir = nTopDir;\n            if (iSubIFD > 0 && iDirIndex > 1)  // don't read subIFDs if we are\n                                               // not in the original directory\n                break;\n            if (iSubIFD > 0)\n            {\n                // make static analyzer happy. subIFDOffsets cannot be null if\n                // iSubIFD>0\n                assert(subIFDOffsets != nullptr);\n                nThisDir = subIFDOffsets[iSubIFD - 1];\n                // CPLDebug(\"GTiff\", \"Opened subIFD %d/%d at offset %llu.\",\n                // iSubIFD, nSubIFDs, nThisDir);\n                if (!TIFFSetSubDirectory(m_hTIFF, nThisDir))\n                    break;\n            }\n\n            if (!TIFFGetField(m_hTIFF, TIFFTAG_SUBFILETYPE, &nSubType))\n                nSubType = 0;\n\n            /* Embedded overview of the main image */\n            if ((nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                (nSubType & FILETYPE_MASK) == 0 &&\n                ((nSubIFDs == 0 && iDirIndex != 1) || iSubIFD > 0) &&\n                m_nOverviewCount < 30 /* to avoid DoS */)\n            {\n                GTiffDataset *poODS = new GTiffDataset();\n                poODS->ShareLockWithParentDataset(this);\n                poODS->SetStructuralMDFromParent(this);\n                if (m_bHasGotSiblingFiles)\n                    poODS->oOvManager.TransferSiblingFiles(\n                        CSLDuplicate(GetSiblingFiles()));\n                poODS->m_pszFilename = CPLStrdup(m_pszFilename);\n                poODS->m_nColorTableMultiplier = m_nColorTableMultiplier;\n                if (poODS->OpenOffset(VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                      eAccess) != CE_None ||\n                    poODS->GetRasterCount() != GetRasterCount())\n                {\n                    delete poODS;\n                }\n                else\n                {\n                    CPLDebug(\"GTiff\", \"Opened %dx%d overview.\",\n                             poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                    ++m_nOverviewCount;\n                    m_papoOverviewDS = static_cast<GTiffDataset **>(CPLRealloc(\n                        m_papoOverviewDS, m_nOverviewCount * (sizeof(void *))));\n                    m_papoOverviewDS[m_nOverviewCount - 1] = poODS;\n                    poODS->m_poBaseDS = this;\n                    poODS->m_bIsOverview = true;\n\n                    // Propagate a few compression related settings that are\n                    // no preserved at the TIFF tag level, but may be set in\n                    // the GDAL_METADATA tag in the IMAGE_STRUCTURE domain\n                    // Note: this might not be totally reflecting the reality\n                    // if users have created overviews with different settings\n                    // but this is probably better than the default ones\n                    poODS->m_nWebPLevel = m_nWebPLevel;\n                    // below is not a copy & paste error: we transfer the\n                    // m_dfMaxZErrorOverview overview of the parent to\n                    // m_dfMaxZError of the overview\n                    poODS->m_dfMaxZError = m_dfMaxZErrorOverview;\n                    poODS->m_dfMaxZErrorOverview = m_dfMaxZErrorOverview;\n#if HAVE_JXL\n                    poODS->m_bJXLLossless = m_bJXLLossless;\n                    poODS->m_fJXLDistance = m_fJXLDistance;\n                    poODS->m_fJXLAlphaDistance = m_fJXLAlphaDistance;\n                    poODS->m_nJXLEffort = m_nJXLEffort;\n#endif\n                    // Those ones are not serialized currently..\n                    // poODS->m_nZLevel = m_nZLevel;\n                    // poODS->m_nLZMAPreset = m_nLZMAPreset;\n                    // poODS->m_nZSTDLevel = m_nZSTDLevel;\n                }\n            }\n            // Embedded mask of the main image.\n            else if ((nSubType & FILETYPE_MASK) != 0 &&\n                     (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                     ((nSubIFDs == 0 && iDirIndex != 1) || iSubIFD > 0) &&\n                     m_poMaskDS == nullptr)\n            {\n                m_poMaskDS = new GTiffDataset();\n                m_poMaskDS->ShareLockWithParentDataset(this);\n                m_poMaskDS->SetStructuralMDFromParent(this);\n                m_poMaskDS->m_pszFilename = CPLStrdup(m_pszFilename);\n\n                // The TIFF6 specification - page 37 - only allows 1\n                // SamplesPerPixel and 1 BitsPerSample Here we support either 1\n                // or 8 bit per sample and we support either 1 sample per pixel\n                // or as many samples as in the main image We don't check the\n                // value of the PhotometricInterpretation tag, which should be\n                // set to \"Transparency mask\" (4) according to the specification\n                // (page 36).  However, the TIFF6 specification allows image\n                // masks to have a higher resolution than the main image, what\n                // we don't support here.\n\n                if (m_poMaskDS->OpenOffset(VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                           eAccess) != CE_None ||\n                    m_poMaskDS->GetRasterCount() == 0 ||\n                    !(m_poMaskDS->GetRasterCount() == 1 ||\n                      m_poMaskDS->GetRasterCount() == GetRasterCount()) ||\n                    m_poMaskDS->GetRasterXSize() != GetRasterXSize() ||\n                    m_poMaskDS->GetRasterYSize() != GetRasterYSize() ||\n                    m_poMaskDS->GetRasterBand(1)->GetRasterDataType() !=\n                        GDT_Byte)\n                {\n                    delete m_poMaskDS;\n                    m_poMaskDS = nullptr;\n                }\n                else\n                {\n                    CPLDebug(\"GTiff\", \"Opened band mask.\");\n                    m_poMaskDS->m_poBaseDS = this;\n                    m_poMaskDS->m_poImageryDS = this;\n\n                    m_poMaskDS->m_bPromoteTo8Bits =\n                        CPLTestBool(CPLGetConfigOption(\n                            \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n                }\n            }\n\n            // Embedded mask of an overview.  The TIFF6 specification allows the\n            // combination of the FILETYPE_xxxx masks.\n            else if ((nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                     (nSubType & FILETYPE_MASK) != 0 &&\n                     ((nSubIFDs == 0 && iDirIndex != 1) || iSubIFD > 0))\n            {\n                GTiffDataset *poDS = new GTiffDataset();\n                poDS->ShareLockWithParentDataset(this);\n                poDS->SetStructuralMDFromParent(this);\n                poDS->m_pszFilename = CPLStrdup(m_pszFilename);\n                if (poDS->OpenOffset(VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                     eAccess) != CE_None ||\n                    poDS->GetRasterCount() == 0 ||\n                    poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poDS;\n                }\n                else\n                {\n                    int i = 0;  // Used after for.\n                    for (; i < m_nOverviewCount; ++i)\n                    {\n                        auto poOvrDS = cpl::down_cast<GTiffDataset *>(\n                            GDALDataset::FromHandle(m_papoOverviewDS[i]));\n                        if (poOvrDS->m_poMaskDS == nullptr &&\n                            poDS->GetRasterXSize() ==\n                                m_papoOverviewDS[i]->GetRasterXSize() &&\n                            poDS->GetRasterYSize() ==\n                                m_papoOverviewDS[i]->GetRasterYSize() &&\n                            (poDS->GetRasterCount() == 1 ||\n                             poDS->GetRasterCount() == GetRasterCount()))\n                        {\n                            CPLDebug(\n                                \"GTiff\", \"Opened band mask for %dx%d overview.\",\n                                poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                            poDS->m_poImageryDS = poOvrDS;\n                            poOvrDS->m_poMaskDS = poDS;\n                            poDS->m_bPromoteTo8Bits =\n                                CPLTestBool(CPLGetConfigOption(\n                                    \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n                            poDS->m_poBaseDS = this;\n                            break;\n                        }\n                    }\n                    if (i == m_nOverviewCount)\n                    {\n                        delete poDS;\n                    }\n                }\n            }\n            else if (!m_bSingleIFDOpened &&\n                     (nSubType == 0 || nSubType == FILETYPE_PAGE))\n            {\n                uint32_t nXSize = 0;\n                uint32_t nYSize = 0;\n\n                TIFFGetField(m_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize);\n                TIFFGetField(m_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize);\n\n                // For Geodetic TIFF grids (GTG)\n                // (https://proj.org/specifications/geodetictiffgrids.html)\n                // extract the grid_name to put it in the description\n                std::string osFriendlyName;\n                char *pszText = nullptr;\n                if (TIFFGetField(m_hTIFF, TIFFTAG_GDAL_METADATA, &pszText) &&\n                    strstr(pszText, \"grid_name\") != nullptr)\n                {\n                    CPLXMLNode *psRoot = CPLParseXMLString(pszText);\n                    const CPLXMLNode *psItem =\n                        psRoot ? CPLGetXMLNode(psRoot, \"=GDALMetadata\")\n                               : nullptr;\n                    if (psItem)\n                        psItem = psItem->psChild;\n                    for (; psItem != nullptr; psItem = psItem->psNext)\n                    {\n\n                        if (psItem->eType != CXT_Element ||\n                            !EQUAL(psItem->pszValue, \"Item\"))\n                            continue;\n\n                        const char *pszKey =\n                            CPLGetXMLValue(psItem, \"name\", nullptr);\n                        const char *pszValue =\n                            CPLGetXMLValue(psItem, nullptr, nullptr);\n                        int nBand =\n                            atoi(CPLGetXMLValue(psItem, \"sample\", \"-1\"));\n                        if (pszKey && pszValue && nBand <= 0 &&\n                            EQUAL(pszKey, \"grid_name\"))\n                        {\n                            osFriendlyName = \": \";\n                            osFriendlyName += pszValue;\n                            break;\n                        }\n                    }\n\n                    CPLDestroyXMLNode(psRoot);\n                }\n\n                if (nXSize > INT_MAX || nYSize > INT_MAX)\n                {\n                    CPLDebug(\"GTiff\",\n                             \"Skipping directory with too large image: %u x %u\",\n                             nXSize, nYSize);\n                }\n                else\n                {\n                    uint16_t nSPP = 0;\n                    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP))\n                        nSPP = 1;\n\n                    CPLString osName, osDesc;\n                    osName.Printf(\"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\",\n                                  iDirIndex, iDirIndex, m_pszFilename);\n                    osDesc.Printf(\n                        \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\",\n                        iDirIndex, iDirIndex, static_cast<int>(nXSize),\n                        static_cast<int>(nYSize), nSPP);\n                    osDesc += osFriendlyName;\n\n                    aosSubdatasets.AddString(osName);\n                    aosSubdatasets.AddString(osDesc);\n                }\n            }\n        }\n        CPLFree(subIFDOffsets);\n\n        // Make sure we are stepping from the expected directory regardless\n        // of churn done processing the above.\n        if (TIFFCurrentDirOffset(m_hTIFF) != nTopDir)\n            TIFFSetSubDirectory(m_hTIFF, nTopDir);\n    } while (!m_bSingleIFDOpened && !TIFFLastDirectory(m_hTIFF) &&\n             TIFFReadDirectory(m_hTIFF) != 0);\n\n    ReloadDirectory();\n\n    // If we have a mask for the main image, loop over the overviews, and if\n    // they have a mask, let's set this mask as an overview of the main mask.\n    if (m_poMaskDS != nullptr)\n    {\n        for (int i = 0; i < m_nOverviewCount; ++i)\n        {\n            if (cpl::down_cast<GTiffDataset *>(\n                    GDALDataset::FromHandle(m_papoOverviewDS[i]))\n                    ->m_poMaskDS != nullptr)\n            {\n                ++m_poMaskDS->m_nOverviewCount;\n                m_poMaskDS->m_papoOverviewDS =\n                    static_cast<GTiffDataset **>(CPLRealloc(\n                        m_poMaskDS->m_papoOverviewDS,\n                        m_poMaskDS->m_nOverviewCount * (sizeof(void *))));\n                m_poMaskDS->m_papoOverviewDS[m_poMaskDS->m_nOverviewCount - 1] =\n                    cpl::down_cast<GTiffDataset *>(\n                        GDALDataset::FromHandle(m_papoOverviewDS[i]))\n                        ->m_poMaskDS;\n            }\n        }\n    }\n\n    // Assign color interpretation from main dataset\n    const int l_nBands = GetRasterCount();\n    for (int iOvr = 0; iOvr < m_nOverviewCount; ++iOvr)\n    {\n        for (int i = 1; i <= l_nBands; i++)\n        {\n            auto poBand = dynamic_cast<GTiffRasterBand *>(\n                m_papoOverviewDS[iOvr]->GetRasterBand(i));\n            if (poBand)\n                poBand->m_eBandInterp =\n                    GetRasterBand(i)->GetColorInterpretation();\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Only keep track of subdatasets if we have more than one         */\n    /*      subdataset (pair).                                              */\n    /* -------------------------------------------------------------------- */\n    if (aosSubdatasets.size() > 2)\n    {\n        m_oGTiffMDMD.SetMetadata(aosSubdatasets.List(), \"SUBDATASETS\");\n    }\n}",
    "bool GTiffDataset::GetRawBinaryLayout(GDALDataset::RawBinaryLayout &sLayout)\n{\n    if (eAccess == GA_Update)\n    {\n        FlushCache(false);\n        Crystalize();\n    }\n\n    if (m_nCompression != COMPRESSION_NONE)\n        return false;\n    if (!CPLIsPowerOfTwo(m_nBitsPerSample) || m_nBitsPerSample < 8)\n        return false;\n    const auto eDT = GetRasterBand(1)->GetRasterDataType();\n    if (GDALDataTypeIsComplex(eDT))\n        return false;\n\n    toff_t *panByteCounts = nullptr;\n    toff_t *panOffsets = nullptr;\n    const bool bIsTiled = CPL_TO_BOOL(TIFFIsTiled(m_hTIFF));\n\n    if (!((bIsTiled &&\n           TIFFGetField(m_hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts) &&\n           TIFFGetField(m_hTIFF, TIFFTAG_TILEOFFSETS, &panOffsets)) ||\n          (!bIsTiled &&\n           TIFFGetField(m_hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts) &&\n           TIFFGetField(m_hTIFF, TIFFTAG_STRIPOFFSETS, &panOffsets))))\n    {\n        return false;\n    }\n\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDT);\n    vsi_l_offset nImgOffset = panOffsets[0];\n    GIntBig nPixelOffset = (m_nPlanarConfig == PLANARCONFIG_CONTIG)\n                               ? static_cast<GIntBig>(nDTSize) * nBands\n                               : nDTSize;\n    GIntBig nLineOffset = nPixelOffset * nRasterXSize;\n    GIntBig nBandOffset =\n        (m_nPlanarConfig == PLANARCONFIG_CONTIG && nBands > 1) ? nDTSize : 0;\n    RawBinaryLayout::Interleaving eInterleaving =\n        (nBands == 1) ? RawBinaryLayout::Interleaving::UNKNOWN\n        : (m_nPlanarConfig == PLANARCONFIG_CONTIG)\n            ? RawBinaryLayout::Interleaving::BIP\n            : RawBinaryLayout::Interleaving::BSQ;\n    if (bIsTiled)\n    {\n        // Only a single block tiled file with same dimension as the raster\n        // might be acceptable\n        if (m_nBlockXSize != nRasterXSize || m_nBlockYSize != nRasterYSize)\n            return false;\n        if (nBands > 1 && m_nPlanarConfig != PLANARCONFIG_CONTIG)\n        {\n            nBandOffset = static_cast<GIntBig>(panOffsets[1]) -\n                          static_cast<GIntBig>(panOffsets[0]);\n            for (int i = 2; i < nBands; i++)\n            {\n                if (static_cast<GIntBig>(panOffsets[i]) -\n                        static_cast<GIntBig>(panOffsets[i - 1]) !=\n                    nBandOffset)\n                    return false;\n            }\n        }\n    }\n    else\n    {\n        const int nStrips = DIV_ROUND_UP(nRasterYSize, m_nRowsPerStrip);\n        if (nBands == 1 || m_nPlanarConfig == PLANARCONFIG_CONTIG)\n        {\n            vsi_l_offset nLastStripEnd = panOffsets[0] + panByteCounts[0];\n            for (int iStrip = 1; iStrip < nStrips; iStrip++)\n            {\n                if (nLastStripEnd != panOffsets[iStrip])\n                    return false;\n                nLastStripEnd = panOffsets[iStrip] + panByteCounts[iStrip];\n            }\n        }\n        else\n        {\n            // Note: we could potentially have BIL order with m_nRowsPerStrip ==\n            // 1 and if strips are ordered strip_line_1_band_1, ...,\n            // strip_line_1_band_N, strip_line2_band1, ... strip_line2_band_N,\n            // etc.... but that'd be faily exotic ! So only detect BSQ layout\n            // here\n            nBandOffset = static_cast<GIntBig>(panOffsets[nStrips]) -\n                          static_cast<GIntBig>(panOffsets[0]);\n            for (int i = 0; i < nBands; i++)\n            {\n                uint32_t iStripOffset = nStrips * i;\n                vsi_l_offset nLastStripEnd =\n                    panOffsets[iStripOffset] + panByteCounts[iStripOffset];\n                for (int iStrip = 1; iStrip < nStrips; iStrip++)\n                {\n                    if (nLastStripEnd != panOffsets[iStripOffset + iStrip])\n                        return false;\n                    nLastStripEnd = panOffsets[iStripOffset + iStrip] +\n                                    panByteCounts[iStripOffset + iStrip];\n                }\n                if (i >= 2 && static_cast<GIntBig>(panOffsets[iStripOffset]) -\n                                      static_cast<GIntBig>(\n                                          panOffsets[iStripOffset - nStrips]) !=\n                                  nBandOffset)\n                {\n                    return false;\n                }\n            }\n        }\n    }\n\n    sLayout.osRawFilename = m_pszFilename;\n    sLayout.eInterleaving = eInterleaving;\n    sLayout.eDataType = eDT;\n#ifdef CPL_LSB\n    sLayout.bLittleEndianOrder = !TIFFIsByteSwapped(m_hTIFF);\n#else\n    sLayout.bLittleEndianOrder = TIFFIsByteSwapped(m_hTIFF);\n#endif\n    sLayout.nImageOffset = nImgOffset;\n    sLayout.nPixelOffset = nPixelOffset;\n    sLayout.nLineOffset = nLineOffset;\n    sLayout.nBandOffset = nBandOffset;\n\n    return true;\n}",
    "bool tiff_read(const char *name, float scale, ctl::dpx::fb<float> *pixels,\n               format_t *format) {\n\tTIFF *t;\n\tuint16_t samples_per_pixel;\n\tuint16_t bits_per_sample;\n\tuint16_t sample_format;\n\tuint16_t planar_config;\n\tuint16_t photometric;\n\tuint16_t orientation;\n\n\tTIFFSetErrorHandler(ErrorHandler);\n\tTIFFSetWarningHandler(WarningHandler);\n\n\tt=TIFFOpen(name, \"r\");\n\tif(t==NULL) {\n\t\t// This is set if the file is not a tiff, we just sort of punt.\n\t\treturn FALSE;\n\t}\n\n\tTIFFGetFieldDefaulted(t, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel);\n\tTIFFGetFieldDefaulted(t, TIFFTAG_BITSPERSAMPLE, &bits_per_sample);\n\tformat->src_bps=bits_per_sample;\n\tTIFFGetFieldDefaulted(t, TIFFTAG_SAMPLEFORMAT, &sample_format);\n\tTIFFGetFieldDefaulted(t, TIFFTAG_PHOTOMETRIC, &photometric);\n\tTIFFGetFieldDefaulted(t, TIFFTAG_ORIENTATION, &orientation);\n\n//\ttiff_read_failsafe(t, scale, pixels);\n//\treturn TRUE;\n\n\tif(!(bits_per_sample==16 && sample_format<3) &&\n\t   !(bits_per_sample==32 && sample_format==3) &&\n\t   photometric!=PHOTOMETRIC_RGB &&\n\t   orientation!=ORIENTATION_TOPLEFT &&\n\t   orientation!=ORIENTATION_BOTLEFT) {\n\n\t\tif(bits_per_sample!=8) {\n\t\t\tfprintf(stderr, \"falling back to failsafe TIFF reader. Reading \"\n\t\t\t        \"as \\n8 bits per sample RGBA.\\n\");\n\t\t}\n\t\ttiff_read_failsafe(t, scale, pixels);\n\t\tTIFFClose(t);\n\t\treturn TRUE;\n\t}\n\n\tTIFFGetField(t, TIFFTAG_PLANARCONFIG, &planar_config);\n\tif(planar_config==PLANARCONFIG_CONTIG) {\n\t\ttiff_read_interleaved(t, scale, pixels);\n\t} else if(planar_config==PLANARCONFIG_SEPARATE) {\n\t\ttiff_read_multiplane(t, scale, pixels);\n\t}\n\n\tTIFFClose(t);\n\n\treturn TRUE;\n}",
    "TiffParameters readTiffParameters( TIFF* tiff )\n{\n    TiffParameters params;\n\n    TIFFGetField( tiff, TIFFTAG_BITSPERSAMPLE, &params.bytesPerSample );\n    params.bytesPerSample >>= 3; // convert to bytes\n\n    int samplePerPixel = 0;\n    TIFFGetField( tiff, TIFFTAG_SAMPLESPERPIXEL, &samplePerPixel );\n    if ( samplePerPixel == 0 )\n    {\n        // incorrect tiff format, treat like Scalar\n        samplePerPixel = 1;\n    }\n    params.valueType = TiffParameters::ValueType( samplePerPixel );\n\n    int sampleFormat = 0;\n    TIFFGetField( tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat );\n    if ( sampleFormat == 0 )\n    {\n        // incorrect tiff format, treat like UInt\n        sampleFormat = SAMPLEFORMAT_UINT;\n    }\n    params.sampleType = TiffParameters::SampleType( sampleFormat );\n\n    TIFFGetField( tiff, TIFFTAG_IMAGEWIDTH, &params.imageSize.x );\n    TIFFGetField( tiff, TIFFTAG_IMAGELENGTH, &params.imageSize.y );\n\n    if ( TIFFIsTiled( tiff ) )\n    {\n        params.tileSize.emplace();\n        TIFFGetField( tiff, TIFFTAG_TILEWIDTH, &params.tileSize->x );\n        TIFFGetField( tiff, TIFFTAG_TILELENGTH, &params.tileSize->y );\n    }\n\n    return params;\n}",
    "bool tiff_image::load(std::string const& filename)\n{\n#if VSNRAY_COMMON_HAVE_TIFF\n    tiff_file file(filename.c_str(), \"r\");\n\n    if (!file.good())\n    {\n        return false;\n    }\n\n    uint32_t w = 0;\n    uint32_t h = 0;\n    TIFFGetField(file.get(), TIFFTAG_IMAGEWIDTH, &w);\n    TIFFGetField(file.get(), TIFFTAG_IMAGELENGTH, &h);\n\n    format_ = PF_RGBA8; // TODO\n\n    auto pitch = w * 4;\n\n    data_.resize(pitch * h);\n\n    if (TIFFReadRGBAImage(file.get(), w, h, reinterpret_cast<uint32_t*>(data_.data()), 0))\n    {\n        width_ = static_cast<int>(w);\n        height_ = static_cast<int>(h);\n    }\n\n    return true;\n#else\n    VSNRAY_UNUSED(filename);\n\n    return false;\n#endif\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16_t photometric = (uint16_t)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16_t bpp = 8, ncn = isGrayScale ? 1 : 3;\n        if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n        {\n            // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n            bpp = 1;\n        }\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16_t img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        constexpr const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n        bool doReadScanline = false;\n\n        uint32_t tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32_t>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n\n            if (dst_bpp == 8)\n            {\n                const int _ncn = 4; // Read RGBA\n                const int _bpp = 8; // Read 8bit\n\n                // if buffer_size(as 32bit RGBA) >= MAX_TILE_SIZE*95%,\n                // we will use TIFFReadScanline function.\n\n                if (\n                    (uint64_t)tile_width0 * tile_height0 * _ncn * std::max(1, (int)(_bpp / bitsPerByte))\n                    >=\n                    ( (uint64_t) MAX_TILE_SIZE * 95 / 100)\n                )\n                {\n                    uint16_t planerConfig = (uint16_t)-1;\n                    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planerConfig));\n\n                    doReadScanline = (!is_tiled) // no tile\n                                     &&\n                                     ( ( ncn == 1 ) || ( ncn == 3 ) || ( ncn == 4 ) )\n                                     &&\n                                     ( ( bpp == 8 ) || ( bpp == 16 ) )\n                                     &&\n                                     (tile_height0 == (uint32_t) m_height) // single strip\n                                     &&\n                                     (\n                                         (photometric == PHOTOMETRIC_MINISWHITE)\n                                         ||\n                                         (photometric == PHOTOMETRIC_MINISBLACK)\n                                         ||\n                                         (photometric == PHOTOMETRIC_RGB)\n                                     )\n                                     &&\n                                     (planerConfig != PLANARCONFIG_SEPARATE);\n\n                    // Currently only EXTRASAMPLE_ASSOCALPHA is supported.\n                    if ( doReadScanline && ( ncn == 4 ) )\n                    {\n                        uint16_t extra_samples_num;\n                        uint16_t *extra_samples = NULL;\n                        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_EXTRASAMPLES, &extra_samples_num, &extra_samples ));\n                        doReadScanline = ( extra_samples_num == 1 ) && ( extra_samples[0] == EXTRASAMPLE_ASSOCALPHA );\n                    }\n                }\n\n                if ( !doReadScanline )\n                {\n                    // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                    bpp = 8;\n                    ncn = 4;\n\n                    char errmsg[1024];\n                    if (!TIFFRGBAImageOK(tif, errmsg))\n                    {\n                        CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                        close();\n                        return false;\n                    }\n                }\n            }\n            else if (dst_bpp == 16)\n            {\n                // if buffer_size >= MAX_TILE_SIZE*95%,\n                // we will use TIFFReadScanline function.\n                if (\n                    (uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte))\n                    >=\n                    MAX_TILE_SIZE * 95 / 100\n                )\n                {\n                    uint16_t planerConfig = (uint16_t)-1;\n                    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planerConfig));\n\n                    doReadScanline = (!is_tiled) // no tile\n                                     &&\n                                     ( ( ncn == 1 ) || ( ncn == 3 ) || ( ncn == 4 ) )\n                                     &&\n                                     ( ( bpp == 8 ) || ( bpp == 16 ) )\n                                     &&\n                                     (tile_height0 == (uint32_t) m_height) // single strip\n                                     &&\n                                     (\n                                         (photometric == PHOTOMETRIC_MINISWHITE)\n                                         ||\n                                         (photometric == PHOTOMETRIC_MINISBLACK)\n                                         ||\n                                         (photometric == PHOTOMETRIC_RGB)\n                                     )\n                                     &&\n                                     (planerConfig != PLANARCONFIG_SEPARATE);\n\n                    // Currently only EXTRASAMPLE_ASSOCALPHA is supported.\n                    if ( doReadScanline && ( ncn == 4 ) )\n                    {\n                        uint16_t extra_samples_num;\n                        uint16_t *extra_samples = NULL;\n                        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_EXTRASAMPLES, &extra_samples_num, &extra_samples ));\n                        doReadScanline = ( extra_samples_num == 1 ) && ( extra_samples[0] == EXTRASAMPLE_ASSOCALPHA );\n                    }\n                }\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n\n            if ( doReadScanline )\n            {\n                // Read each scanlines.\n                tile_height0 = 1;\n            }\n\n            const size_t src_buffer_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_size = tile_height0 * src_buffer_bytes_per_row;\n            CV_CheckLT(src_buffer_size, MAX_TILE_SIZE, \"buffer_size is too large: >= 1Gb\");\n            const size_t src_buffer_unpacked_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * dst_bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_unpacked_size = tile_height0 * src_buffer_unpacked_bytes_per_row;\n            const bool needsUnpacking = (bpp < dst_bpp);\n            AutoBuffer<uchar> _src_buffer(src_buffer_size);\n            uchar* src_buffer = _src_buffer.data();\n            AutoBuffer<uchar> _src_buffer_unpacked(needsUnpacking ? src_buffer_unpacked_size : 0);\n            uchar* src_buffer_unpacked = needsUnpacking ? _src_buffer_unpacked.data() : nullptr;\n\n            if ( doReadScanline )\n            {\n                CV_CheckGE(src_buffer_size,\n                           static_cast<size_t>(TIFFScanlineSize(tif)),\n                           \"src_buffer_size is smaller than TIFFScanlineSize().\");\n            }\n\n            int tileidx = 0;\n\n            #define MAKE_FLAG(a,b) ( (a << 8) | b )\n            const int  convert_flag = MAKE_FLAG( ncn, wanted_channels );\n            const bool isNeedConvert16to8 = ( doReadScanline ) && ( bpp == 16 ) && ( dst_bpp == 8);\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = src_buffer;\n                            if (doReadScanline)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadScanline(tif, (uint32_t*)src_buffer, y) >= 0);\n\n                                if ( isNeedConvert16to8 )\n                                {\n                                    // Convert buffer image from 16bit to 8bit.\n                                    int ix;\n                                    for ( ix = 0 ; ix < tile_width * ncn - 4; ix += 4 )\n                                    {\n                                        src_buffer[ ix     ] = src_buffer[ ix * 2 + 1 ];\n                                        src_buffer[ ix + 1 ] = src_buffer[ ix * 2 + 3 ];\n                                        src_buffer[ ix + 2 ] = src_buffer[ ix * 2 + 5 ];\n                                        src_buffer[ ix + 3 ] = src_buffer[ ix * 2 + 7 ];\n                                    }\n\n                                    for (        ; ix < tile_width * ncn ; ix ++ )\n                                    {\n                                        src_buffer[ ix ] = src_buffer[ ix * 2 + 1];\n                                    }\n                                }\n                            }\n                            else if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32_t*)src_buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32_t*)src_buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            uchar* img_line_buffer = (uchar*) img.ptr(y, 0);\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (doReadScanline)\n                                {\n                                    switch ( convert_flag )\n                                    {\n                                    case MAKE_FLAG( 1, 1 ): // GRAY to GRAY\n                                        std::memcpy( (void*) img_line_buffer,\n                                                     (void*) bstart,\n                                                     tile_width * sizeof(uchar) );\n                                        break;\n\n                                    case MAKE_FLAG( 1, 3 ): // GRAY to BGR\n                                        icvCvt_Gray2BGR_8u_C1C3R( bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1) );\n                                        break;\n\n                                    case MAKE_FLAG( 3, 1): // RGB to GRAY\n                                        icvCvt_BGR2Gray_8u_C3C1R( bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1) );\n                                        break;\n\n                                    case MAKE_FLAG( 3, 3 ): // RGB to BGR\n                                        if (m_use_rgb)\n                                            std::memcpy( (void*) img_line_buffer,\n                                                         (void*) bstart,\n                                                         tile_width * sizeof(uchar) );\n                                        else\n                                            icvCvt_BGR2RGB_8u_C3R( bstart, 0,\n                                                    img_line_buffer, 0,\n                                                    Size(tile_width, 1) );\n                                        break;\n\n                                    case MAKE_FLAG( 4, 1 ): // RGBA to GRAY\n                                        icvCvt_BGRA2Gray_8u_C4C1R( bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1) );\n                                        break;\n\n                                    case MAKE_FLAG( 4, 3 ): // RGBA to BGR\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1), m_use_rgb ? 0 : 2);\n                                        break;\n\n                                    case MAKE_FLAG( 4, 4 ): // RGBA to BGRA\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1) );\n                                        break;\n\n                                    default:\n                                        CV_LOG_ONCE_ERROR(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): Unsupported convertion :\"\n                                                               << \" bpp = \" << bpp << \" ncn = \" << (int)ncn\n                                                               << \" wanted_channels =\" << wanted_channels  );\n                                        break;\n                                    }\n                                    #undef MAKE_FLAG\n                                }\n                                else if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), m_use_rgb ? 0 : 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (doReadScanline)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadScanline(tif, (uint32_t*)src_buffer, y) >= 0);\n                            }\n                            else if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32_t*)src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32_t*)src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                ushort* buffer16 = (ushort*)(src_buffer+i*src_buffer_bytes_per_row);\n                                if (needsUnpacking)\n                                {\n                                    const uchar* src_packed = src_buffer+i*src_buffer_bytes_per_row;\n                                    uchar* dst_unpacked = src_buffer_unpacked+i*src_buffer_unpacked_bytes_per_row;\n                                    if (bpp == 10)\n                                        _unpack10To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 12)\n                                        _unpack12To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 14)\n                                        _unpack14To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    buffer16 = (ushort*)dst_unpacked;\n                                }\n\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        if (m_use_rgb)\n                                            std::memcpy(buffer16, img.ptr<ushort>(img_y + i, x), tile_width * sizeof(ushort));\n                                        else\n                                            icvCvt_RGB2BGR_16u_C3R(buffer16, 0,\n                                                    img.ptr<ushort>(img_y + i, x), 0,\n                                                    Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), m_use_rgb ? 0 : 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        std::memcpy(img.ptr<ushort>(img_y + i, x),\n                                                    buffer16,\n                                                    tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? (depth == CV_32S ? CV_32S : CV_32F) : CV_64F, ncn), src_buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3 && !m_use_rgb)\n                                extend_cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                extend_cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        if (bpp < dst_bpp)\n          img *= (1<<(dst_bpp-bpp));\n\n        // If TIFFReadRGBA* function is used -> fixOrientationPartial().\n        // Otherwise                         -> fixOrientationFull().\n        fixOrientation(img, img_orientation,\n                       ( ( dst_bpp != 8 ) && ( !doReadScanline ) ) );\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        if (m_use_rgb)\n            cvtColor(img, img, COLOR_XYZ2RGB);\n        else\n            cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}",
    "bool CTIFFReader::Open()\n{\n\tZFUNCTRACE_RUNTIME();\n\n\t//\n\t// Used for reading lengths of TIFF custom tags.  Different tags\n\t// return length as uint8, uint16, uint16[2], or uint32\n\t//\n\tunion\n\t{\n\t\tuint32_t Long;\n\t\tuint16_t Short1;\n\t\tuint16_t Short2[2];\n\t\tuint8_t Char[4];\n\t} unionLong{ 0 };\n\n\t// Used to read pointer to data when reading custom tags\n\tvoid* pVoidArray{ nullptr };\n\n\tbool\t\t\tbResult = false;\n\tQSettings\t\tsettings;\n\n\tconst auto dwSkipExifInfo = settings.value(\"SkipTIFFExifInfo\", uint(0)).toUInt();\n\n\t//\n\t// Quietly attempt to open the putative TIFF file \n\t//\n\tTIFFErrorHandler\toldHandler = TIFFSetErrorHandler(nullptr);\n\tTIFFErrorHandlerExt\toldHandlerExt = TIFFSetErrorHandlerExt(nullptr);\n#ifdef Q_OS_WIN\n\tm_tiff = TIFFOpenW(file.wstring().c_str(), \"r\");\n#else\n\tm_tiff = TIFFOpen(reinterpret_cast<const char*>(file.u8string().c_str()), \"r\");\n#endif\n\tTIFFSetErrorHandler(oldHandler);\n\tTIFFSetErrorHandlerExt(oldHandlerExt);\n\n\tif (m_tiff != nullptr)\n\t{\n\t\tZTRACE_RUNTIME(\"Opened %s\", file.generic_u8string().c_str());\n\n\t\tcfa = false;\n\t\tcfatype = CFATYPE_NONE;\n\t\tmaster = 0;\n\t\tsamplemin = 0;\n\t\tsamplemax = 1.0;\n\t\texposureTime = 0.0;\n\t\tisospeed = 0;\n\t\tgain = -1;\n\n\t\tTIFFGetField(m_tiff,TIFFTAG_IMAGEWIDTH, &w);\n        TIFFGetField(m_tiff,TIFFTAG_IMAGELENGTH, &h);\n\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_COMPRESSION, &compression))\n\t\t\tcompression = COMPRESSION_NONE;\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_BITSPERSAMPLE, &bps))\n\t\t\tbps = 1;\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_SAMPLESPERPIXEL, &spp))\n\t\t\tspp = 1;\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_PLANARCONFIG, &planarconfig))\n\t\t\tplanarconfig = PLANARCONFIG_CONTIG;\n\t\tTIFFGetField(m_tiff, TIFFTAG_PHOTOMETRIC, &photo);\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_SAMPLEFORMAT, &sampleformat))\n\t\t\tsampleformat = SAMPLEFORMAT_UINT;\n\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_DSS_MASTER, &master))\n\t\t\tmaster = 0;\n\n\t\tchar *\t\t\t\tszMake = nullptr;\n\t\tchar *\t\t\t\tszModel = nullptr;\n\n\t\tif (TIFFGetField(m_tiff, TIFFTAG_MODEL, &szModel))\n\t\t\tstrMakeModel = szModel;\n\t\telse if (TIFFGetField(m_tiff, TIFFTAG_MAKE, &szMake))\n\t\t\tstrMakeModel = szMake;\n\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_DSS_ISO, &isospeed))\n\t\t\tisospeed = 0;\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_DSS_GAIN, &gain))\n\t\t\tgain = -1;\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_DSS_APERTURE, &aperture))\n\t\t\taperture = 0.0;\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_DSS_TOTALEXPOSURE, &exposureTime))\n\t\t{\n\t\t\tint\t\t\tlExposure;\n\t\t\tif (TIFFGetField(m_tiff, TIFFTAG_DSS_TOTALEXPOSUREOLD, &lExposure))\n\t\t\t\texposureTime = lExposure;\n\t\t}\n\n\t\t// Check that this is a compatible TIFF format\n\t\t// Support is :\n\t\t// 8, 16, 32 bits per pixels (with slight restriction on format)\n\t\t// No compression or LZW compression or ZIP (deflate) compression\n\t\t// sample per pixel 1 (gray levels) or 3 (rgb)\n\t\tif ((planarconfig == PLANARCONFIG_CONTIG) &&\n\t\t\t((compression == COMPRESSION_NONE) ||\n\t\t\t (compression == COMPRESSION_LZW) ||\n\t\t\t (compression == COMPRESSION_DEFLATE) ||\n\t\t\t (compression == COMPRESSION_ADOBE_DEFLATE)) &&\n\t\t\t((spp == 3) || (spp==4) || (spp == 1)))\n\t\t{\n\t\t\tif ((bps == 8) || (bps == 16))\n\t\t\t{\n\t\t\t\tbResult = (sampleformat == SAMPLEFORMAT_UINT) ||\n\t\t\t\t\t\t  (sampleformat == SAMPLEFORMAT_INT);\n\t\t\t}\n\t\t\telse if (bps == 32)\n\t\t\t{\n\t\t\t\tbResult = (sampleformat == SAMPLEFORMAT_UINT) ||\n\t\t\t\t\t(sampleformat == SAMPLEFORMAT_INT) ||\n\t\t\t\t\t(sampleformat == SAMPLEFORMAT_IEEEFP);\n\n\t\t\t\tif (sampleformat == SAMPLEFORMAT_IEEEFP)\n\t\t\t\t{\n\t\t\t\t\t// Read min/max values\n\t\t\t\t\tTIFFGetField(m_tiff, TIFFTAG_SMINSAMPLEVALUE, &samplemin);\n\t\t\t\t\tTIFFGetField(m_tiff, TIFFTAG_SMAXSAMPLEVALUE, &samplemax);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bResult)\n\t\t\t{\n\t\t\t\tif ((spp == 3) || (spp == 4))\n\t\t\t\t\tbResult = (PHOTOMETRIC_RGB == photo);\n\t\t\t\telse if (spp == 1)\n\t\t\t\t\tbResult = (PHOTOMETRIC_MINISBLACK == photo || PHOTOMETRIC_CFA == photo);\n\t\t\t}\n\t\t}\n\n\t\t// Retrieve the Date/Time as in the TIFF TAG\n\t\tchar* szDateTime;\n\n\t\tif (TIFFGetField(m_tiff, TIFFTAG_DATETIME, &szDateTime))\n\t\t{\n\t\t\tQString\tstrDateTime{ szDateTime };\n\n\t\t\t// Decode 2007:11:02 22:07:03\n\t\t\t//        0123456789012345678\n\n\t\t\tif (strDateTime.length() >= 19)\n\t\t\t{\n\t\t\t\tm_DateTime = QDateTime::fromString(strDateTime, \"yyyy:MM:dd hh:mm:ss\");\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Attempt to read the CFA from the root IFD if this is could be a CFA image\n\t\t//\n\t\tif (bResult && 1 == spp)\n\t\t{\n\t\t\tif (PHOTOMETRIC_CFA == photo) ZTRACE_RUNTIME(\"TIFFTAG_PHOTOMETRIC is set to PHOTOMETRIC_CFA\");\n\t\t\telse ZTRACE_RUNTIME(\"TIFFTAG_PHOTOMETRIC is set to PHOTOMETRIC_MINISBLACK\");\n\t\t\tint count{ 0 };\n\n\t\t\tZTRACE_RUNTIME(\"Checking for TIFFTAG_CFAREPEATPATTERNDIM, TIFFTAG_CFAPATTERN\");\n\n\t\t\tif (TIFFGetField(m_tiff, TIFFTAG_CFAREPEATPATTERNDIM, &pVoidArray))\n\t\t\t{\n\t\t\t\tZTRACE_RUNTIME(\"TIFFTAG_CFAREPEATPATTERNDIM read OK\");\n\t\t\t\tcfaDimPat = {};\t\t// clear the Dimension and Pattern structure\n\t\t\t\tmemcpy(&cfaDimPat.dim, pVoidArray, sizeof(cfaDimPat.dim));\n\n\t\t\t\tint patternSize{ cfaDimPat.dim[0] * cfaDimPat.dim[1] };\n\n\t\t\t\tif (TIFFGetField(m_tiff, TIFFTAG_CFAPATTERN, &unionLong, &pVoidArray))\n\t\t\t\t{\n\t\t\t\t\tZTRACE_RUNTIME(\"TIFFTAG_CFAPATTERN read OK\");\n\t\t\t\t\tcount = unionLong.Short1;\n\t\t\t\t\tZASSERT(count == patternSize && count <= sizeof(cfaDimPat.cfa));\n\t\t\t\t\tmemcpy(&cfaDimPat.cfa, pVoidArray, count);\n\t\t\t\t\tdecodeCfaDimPat(patternSize, \"TIFFTAG_CFAPATTERN\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dwSkipExifInfo == 0)\n\t\t{\n\t\t\t// Try to read EXIF data\n\t\t\tuint64_t ExifID;\n\n\t\t\tif (TIFFGetField(m_tiff, TIFFTAG_EXIFIFD, &ExifID))\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Get current TIFF Directory so we can return to it\n\t\t\t\t//\n\t\t\t\tauto currentIFD = TIFFCurrentDirectory(m_tiff);\n\t\t\t\tif (TIFFReadEXIFDirectory(m_tiff, ExifID))\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFGetField(m_tiff, EXIFTAG_EXPOSURETIME, &exposureTime))\n\t\t\t\t\t\texposureTime = 0.0;\n\n\t\t\t\t\tif (!TIFFGetField(m_tiff, EXIFTAG_FNUMBER, &aperture))\n\t\t\t\t\t\taperture = 0.0;\n\n\t\t\t\t\t// EXIFTAG_ISOSPEEDRATINGS is an array of uint16 according to the EXIF spec\n\t\t\t\t\tisospeed = 0;\n\t\t\t\t\tuint16_t\tcount = 0;\n\t\t\t\t\tuint16_t* iso_setting = nullptr;\n\t\t\t\t\tif (TIFFGetField(m_tiff, EXIFTAG_ISOSPEEDRATINGS, &count, &iso_setting))\n\t\t\t\t\t{\n\t\t\t\t\t\tisospeed = iso_setting[0];\n\t\t\t\t\t}\n\t\t\t\t\telse isospeed = 0;\n\n\t\t\t\t\t// EXIFTAG_GAINCONTROL does not represent a gain value, so ignore it.\n\n\t\t\t\t\t//\n\t\t\t\t\t// If we've not yet detected a cfa pattern interrogate EXIFTAG_CFAPATTERN\n\t\t\t\t\t//\n\t\t\t\t\tif (!cfa && spp == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tZTRACE_RUNTIME(\"Checking for EXIF_CFAPATTERN tag\");\n\n\t\t\t\t\t\tif (TIFFGetField(m_tiff, EXIFTAG_CFAPATTERN, &unionLong, &pVoidArray))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemcpy(&cfaDimPat, pVoidArray, unionLong.Short1);\n\t\t\t\t\t\t\tdecodeCfaDimPat(cfaDimPat.dim[0] * cfaDimPat.dim[1], \"EXIFTAG_CFAPATTERN\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Revert IFD to status quo ante TIFFReadEXIFDirectory\n\t\t\t\t\t//\n\t\t\t\t\tTIFFSetDirectory(m_tiff, currentIFD);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCBitmapInfo\t\t\tBitmapInfo;\n\t\t\tif (RetrieveEXIFInfo(file, BitmapInfo))\n\t\t\t{\n\t\t\t\texposureTime = BitmapInfo.m_fExposure;\n\t\t\t\taperture\t = BitmapInfo.m_fAperture;\n\t\t\t\tisospeed\t = BitmapInfo.m_lISOSpeed;\n\t\t\t\tgain\t\t = BitmapInfo.m_lGain;\n\t\t\t\tm_DateTime\t = BitmapInfo.m_DateTime;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// If we have not yet found a setting for the CFA look to see if\n\t\t// it is recorded in our private TIFF tags.\n\t\t//\n\t\tif (!cfa && spp == 1)\n\t\t{\n\t\t\tZTRACE_RUNTIME(\"CFAType not yet set: Checking DSS private TIFF tags\");\n\t\t\tint32_t cfaValue = 0;\n\n\t\t\tif (!TIFFGetField(m_tiff, TIFFTAG_DSS_CFA, &cfaValue))\n\t\t\t\tcfaValue = 0;\n\t\t\tif (0 != cfaValue)\n\t\t\t\tcfa = true;\n\t\t\tif (TIFFGetField(m_tiff, TIFFTAG_DSS_CFATYPE, &cfatype))\n\t\t\t{\n\t\t\t\tZTRACE_RUNTIME(\"CFAType set to %u\", cfatype);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tcfa = false;\n\t\t\t\tcfatype = CFATYPE_NONE;\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\t\t// If this file is an eight bit TIFF, and purports to have a Bayer pattern\n\t\t// inform the the user that we aren't going to play\n\t\t//\n\t\tif ((1 == spp) && (8 == bps) && cfa)\n\t\t{\n\t\t\t// \n\t\t\t// Set CFA type to none even if the TIFF tags specified otherwise\n\t\t\t//\n\t\t\tcfatype = CFATYPE_NONE;\n\t\t\tcfa = false;\n\t\t\tQString errorMessage{ QCoreApplication::translate(\"TIFFUtil\",\n\t\t\t\t\t\t\t\t\t\"DeepSkyStacker will not de-Bayer 8 bit images\",\n\t\t\t\t\t\t\t\t\t\"IDS_8BIT_FITS_NODEBAYER\") };\n\t\t\tDSSBase::instance()->reportError(\n\t\t\t\terrorMessage,\n\t\t\t\t\"Will not de-Bayer 8 bit images\",\n\t\t\t\tDSSBase::Severity::Warning,\n\t\t\t\tDSSBase::Method::QErrorMessage);\n\t\t}\n\n\n\n\n\t\tif (bResult)\n\t\t\tbResult = OnOpen();\n\t\tif (!bResult)\n\t\t{\n\t\t\tTIFFClose(m_tiff);\n\t\t\tm_tiff = nullptr;\n\t\t}\n\t}\n\n\treturn bResult;\n}",
    "GTiffRasterBand::GTiffRasterBand(GTiffDataset *poDSIn, int nBandIn)\n    : m_poGDS(poDSIn)\n{\n    poDS = poDSIn;\n    nBand = nBandIn;\n\n    /* -------------------------------------------------------------------- */\n    /*      Get the GDAL data type.                                         */\n    /* -------------------------------------------------------------------- */\n    const uint16_t nBitsPerSample = m_poGDS->m_nBitsPerSample;\n    const uint16_t nSampleFormat = m_poGDS->m_nSampleFormat;\n\n    eDataType = GDT_Unknown;\n\n    if (nBitsPerSample <= 8)\n    {\n        if (nSampleFormat == SAMPLEFORMAT_INT)\n            eDataType = GDT_Int8;\n        else\n            eDataType = GDT_Byte;\n    }\n    else if (nBitsPerSample <= 16)\n    {\n        if (nSampleFormat == SAMPLEFORMAT_INT)\n            eDataType = GDT_Int16;\n        else\n            eDataType = GDT_UInt16;\n    }\n    else if (nBitsPerSample == 32)\n    {\n        if (nSampleFormat == SAMPLEFORMAT_COMPLEXINT)\n            eDataType = GDT_CInt16;\n        else if (nSampleFormat == SAMPLEFORMAT_IEEEFP)\n            eDataType = GDT_Float32;\n        else if (nSampleFormat == SAMPLEFORMAT_INT)\n            eDataType = GDT_Int32;\n        else\n            eDataType = GDT_UInt32;\n    }\n    else if (nBitsPerSample == 64)\n    {\n        if (nSampleFormat == SAMPLEFORMAT_IEEEFP)\n            eDataType = GDT_Float64;\n        else if (nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP)\n            eDataType = GDT_CFloat32;\n        else if (nSampleFormat == SAMPLEFORMAT_COMPLEXINT)\n            eDataType = GDT_CInt32;\n        else if (nSampleFormat == SAMPLEFORMAT_INT)\n            eDataType = GDT_Int64;\n        else\n            eDataType = GDT_UInt64;\n    }\n    else if (nBitsPerSample == 128)\n    {\n        if (nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP)\n            eDataType = GDT_CFloat64;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Try to work out band color interpretation.                      */\n    /* -------------------------------------------------------------------- */\n    bool bLookForExtraSamples = false;\n\n    if (m_poGDS->m_poColorTable != nullptr && nBand == 1)\n    {\n        m_eBandInterp = GCI_PaletteIndex;\n    }\n    else if (m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB ||\n             (m_poGDS->m_nPhotometric == PHOTOMETRIC_YCBCR &&\n              m_poGDS->m_nCompression == COMPRESSION_JPEG &&\n              CPLTestBool(CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\"))))\n    {\n        if (nBand == 1)\n            m_eBandInterp = GCI_RedBand;\n        else if (nBand == 2)\n            m_eBandInterp = GCI_GreenBand;\n        else if (nBand == 3)\n            m_eBandInterp = GCI_BlueBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if (m_poGDS->m_nPhotometric == PHOTOMETRIC_YCBCR)\n    {\n        if (nBand == 1)\n            m_eBandInterp = GCI_YCbCr_YBand;\n        else if (nBand == 2)\n            m_eBandInterp = GCI_YCbCr_CbBand;\n        else if (nBand == 3)\n            m_eBandInterp = GCI_YCbCr_CrBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if (m_poGDS->m_nPhotometric == PHOTOMETRIC_SEPARATED)\n    {\n        if (nBand == 1)\n            m_eBandInterp = GCI_CyanBand;\n        else if (nBand == 2)\n            m_eBandInterp = GCI_MagentaBand;\n        else if (nBand == 3)\n            m_eBandInterp = GCI_YellowBand;\n        else if (nBand == 4)\n            m_eBandInterp = GCI_BlackBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if (m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISBLACK && nBand == 1)\n    {\n        m_eBandInterp = GCI_GrayIndex;\n    }\n    else\n    {\n        bLookForExtraSamples = true;\n    }\n\n    if (bLookForExtraSamples)\n    {\n        uint16_t *v = nullptr;\n        uint16_t count = 0;\n\n        if (TIFFGetField(m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v))\n        {\n            const int nBaseSamples = m_poGDS->m_nSamplesPerPixel - count;\n            const int nExpectedBaseSamples =\n                (m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISBLACK)   ? 1\n                : (m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISWHITE) ? 1\n                : (m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB)        ? 3\n                : (m_poGDS->m_nPhotometric == PHOTOMETRIC_YCBCR)      ? 3\n                : (m_poGDS->m_nPhotometric == PHOTOMETRIC_SEPARATED)  ? 4\n                                                                      : 0;\n\n            if (nExpectedBaseSamples > 0 && nBand == nExpectedBaseSamples + 1 &&\n                nBaseSamples != nExpectedBaseSamples)\n            {\n                ReportError(\n                    CE_Warning, CPLE_AppDefined,\n                    \"Wrong number of ExtraSamples : %d. %d were expected\",\n                    count, m_poGDS->m_nSamplesPerPixel - nExpectedBaseSamples);\n            }\n\n            if (nBand > nBaseSamples && nBand - nBaseSamples - 1 < count &&\n                (v[nBand - nBaseSamples - 1] == EXTRASAMPLE_ASSOCALPHA ||\n                 v[nBand - nBaseSamples - 1] == EXTRASAMPLE_UNASSALPHA))\n            {\n                if (v[nBand - nBaseSamples - 1] == EXTRASAMPLE_ASSOCALPHA)\n                    m_oGTiffMDMD.SetMetadataItem(\"ALPHA\", \"PREMULTIPLIED\",\n                                                 \"IMAGE_STRUCTURE\");\n                m_eBandInterp = GCI_AlphaBand;\n            }\n            else\n                m_eBandInterp = GCI_Undefined;\n        }\n        else\n        {\n            m_eBandInterp = GCI_Undefined;\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Establish block size for strip or tiles.                        */\n    /* -------------------------------------------------------------------- */\n    nBlockXSize = m_poGDS->m_nBlockXSize;\n    nBlockYSize = m_poGDS->m_nBlockYSize;\n    nRasterXSize = m_poGDS->nRasterXSize;\n    nRasterYSize = m_poGDS->nRasterYSize;\n    nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, nBlockYSize);\n}",
    "QPair<QString, QString> getColorSpaceForColorType(uint16_t sampletype,\n                                                  uint16_t color_type,\n                                                  uint16_t color_nb_bits,\n                                                  TIFF *image,\n                                                  uint16_t &nbchannels,\n                                                  uint16_t &extrasamplescount,\n                                                  uint8_t &destDepth)\n{\n    const int bits32 = 32;\n    const int bits16 = 16;\n    const int bits8 = 8;\n\n    if (sampletype == SAMPLEFORMAT_INT) {\n        dbgFile << \"Detected signed TIFF image\" << color_type << color_nb_bits;\n    }\n\n    if (color_type == PHOTOMETRIC_MINISWHITE\n        || color_type == PHOTOMETRIC_MINISBLACK) {\n        if (nbchannels == 0)\n            nbchannels = 1;\n        extrasamplescount =\n            nbchannels - 1; // FIX the extrasamples count in case of\n        if (sampletype == SAMPLEFORMAT_IEEEFP) {\n            if (color_nb_bits == 16) {\n#ifdef HAVE_OPENEXR\n                destDepth = 16;\n                return {GrayAColorModelID.id(), Float16BitsColorDepthID.id()};\n#endif\n            } else if (color_nb_bits == 32) {\n                destDepth = 32;\n                return {GrayAColorModelID.id(), Float32BitsColorDepthID.id()};\n            }\n            return {}; // sanity check; no support for float of\n                       // higher or lower bit depth\n        }\n        if (color_nb_bits <= 8) {\n            destDepth = 8;\n            return {GrayAColorModelID.id(), Integer8BitsColorDepthID.id()};\n        } else /* if (color_nb_bits == bits16) */ {\n            destDepth = 16;\n            return {GrayAColorModelID.id(), Integer16BitsColorDepthID.id()};\n        }\n\n    } else if (color_type == PHOTOMETRIC_RGB /*|| color_type == */) {\n        if (nbchannels == 0)\n            nbchannels = 3;\n        extrasamplescount =\n            nbchannels - 3; // FIX the extrasamples count in case of\n        if (sampletype == SAMPLEFORMAT_IEEEFP) {\n            if (color_nb_bits == 16) {\n#ifdef HAVE_OPENEXR\n                destDepth = 16;\n                return {RGBAColorModelID.id(), Float16BitsColorDepthID.id()};\n#endif\n            } else if (color_nb_bits == 32) {\n                destDepth = 32;\n                return {RGBAColorModelID.id(), Float32BitsColorDepthID.id()};\n            }\n            return {}; // sanity check; no support for float of\n                       // higher or lower bit depth\n        } else {\n            if (color_nb_bits <= 8) {\n                destDepth = 8;\n                return {RGBAColorModelID.id(), Integer8BitsColorDepthID.id()};\n            } else /* if (color_nb_bits == bits16) */ {\n                destDepth = 16;\n                return {RGBAColorModelID.id(), Integer16BitsColorDepthID.id()};\n            }\n        }\n    } else if (color_type == PHOTOMETRIC_YCBCR) {\n        if (nbchannels == 0)\n            nbchannels = 3;\n        extrasamplescount =\n            nbchannels - 3; // FIX the extrasamples count in case of\n        if (sampletype == SAMPLEFORMAT_IEEEFP) {\n            if (color_nb_bits == 16) {\n#ifdef HAVE_OPENEXR\n                destDepth = 16;\n                return {YCbCrAColorModelID.id(), Float16BitsColorDepthID.id()};\n#endif\n            } else if (color_nb_bits == 32) {\n                destDepth = 32;\n                return {YCbCrAColorModelID.id(), Float32BitsColorDepthID.id()};\n            }\n            return {}; // sanity check; no support for float of\n                       // higher or lower bit depth\n        } else {\n            if (color_nb_bits <= 8) {\n                destDepth = 8;\n                return {YCbCrAColorModelID.id(), Integer8BitsColorDepthID.id()};\n            } else /* if (color_nb_bits == bits16) */ {\n                destDepth = 16;\n                return {YCbCrAColorModelID.id(),\n                        Integer16BitsColorDepthID.id()};\n            }\n        }\n        if (color_nb_bits <= 8) {\n            destDepth = 8;\n            return {YCbCrAColorModelID.id(), Integer8BitsColorDepthID.id()};\n        } else if (color_nb_bits == bits16) {\n            destDepth = 16;\n            return {YCbCrAColorModelID.id(), Integer16BitsColorDepthID.id()};\n        } else {\n            return {}; // sanity check; no support\n                       // integers of higher bit depth\n        }\n    } else if (color_type == PHOTOMETRIC_SEPARATED) {\n        if (nbchannels == 0)\n            nbchannels = 4;\n        // SEPARATED is in general CMYK but not always, so we check\n        uint16_t inkset = 0;\n        if ((TIFFGetField(image, TIFFTAG_INKSET, &inkset) == 0)) {\n            dbgFile << \"Image does not define the inkset.\";\n            inkset = 2;\n        }\n        if (inkset != INKSET_CMYK) {\n            dbgFile << \"Unsupported inkset (right now, only CMYK is supported)\";\n            char **ink_names = nullptr;\n            uint16_t numberofinks = 0;\n            if (TIFFGetField(image, TIFFTAG_INKNAMES, &ink_names) == 1\n                && TIFFGetField(image, TIFFTAG_NUMBEROFINKS, &numberofinks)\n                    == 1) {\n                dbgFile << \"Inks are :\";\n                for (uint32_t i = 0; i < numberofinks; i++) {\n                    dbgFile << ink_names[i];\n                }\n            } else {\n                dbgFile << \"inknames are not defined !\";\n                // To be able to read stupid adobe files, if there are no\n                // information about inks and four channels, then it's a CMYK\n                // file :\n                if (nbchannels - extrasamplescount != 4) {\n                    return {};\n                }\n                // else - assume it's CMYK and proceed\n            }\n        }\n        if (sampletype == SAMPLEFORMAT_IEEEFP) {\n            if (color_nb_bits == 16) {\n#ifdef HAVE_OPENEXR\n                destDepth = 16;\n                return {CMYKAColorModelID.id(), Float16BitsColorDepthID.id()};\n#endif\n            } else if (color_nb_bits == 32) {\n                destDepth = 32;\n                return {CMYKAColorModelID.id(), Float32BitsColorDepthID.id()};\n            }\n            return {}; // sanity check; no support for float of\n                       // higher or lower bit depth\n        }\n        if (color_nb_bits <= 8) {\n            destDepth = 8;\n            return {CMYKAColorModelID.id(), Integer8BitsColorDepthID.id()};\n        } else if (color_nb_bits == 16) {\n            destDepth = 16;\n            return {CMYKAColorModelID.id(), Integer16BitsColorDepthID.id()};\n        } else {\n            return {}; // no support for other bit depths\n        }\n    } else if (color_type == PHOTOMETRIC_CIELAB\n               || color_type == PHOTOMETRIC_ICCLAB) {\n        if (nbchannels == 0)\n            nbchannels = 3;\n        extrasamplescount = nbchannels - 3; // FIX the extrasamples count\n\n        switch (color_nb_bits) {\n        case bits32: {\n            destDepth = bits32;\n            if (sampletype == SAMPLEFORMAT_IEEEFP) {\n                return {LABAColorModelID.id(), Float32BitsColorDepthID.id()};\n            } else {\n                return {}; // no support for other bit depths\n            }\n        }\n        case bits16: {\n            destDepth = bits16;\n            if (sampletype == SAMPLEFORMAT_IEEEFP) {\n#ifdef HAVE_OPENEXR\n                return {LABAColorModelID.id(), Float16BitsColorDepthID.id()};\n#endif\n            } else {\n                return {LABAColorModelID.id(), Integer16BitsColorDepthID.id()};\n            }\n            return {}; // no support for other bit depths\n        }\n        case bits8: {\n            destDepth = bits8;\n            return {LABAColorModelID.id(), Integer8BitsColorDepthID.id()};\n        }\n        default: {\n            return {};\n        }\n        }\n    } else if (color_type == PHOTOMETRIC_PALETTE) {\n        destDepth = 16;\n        if (nbchannels == 0)\n            nbchannels = 2;\n        extrasamplescount = nbchannels - 2; // FIX the extrasamples count\n        // <-- we will convert the index image to RGBA16 as the palette is\n        // always on 16bits colors\n        return {RGBAColorModelID.id(), Integer16BitsColorDepthID.id()};\n    }\n    return {};\n}",
    "KisImportExportErrorCode KisTIFFImport::readImageFromPsd(KisDocument *m_doc, TIFF *image, KisTiffBasicInfo &basicInfo)\n{\n#ifdef TIFF_HAS_PSD_TAGS\n  // Attempt to parse Photoshop metadata\n    // if it succeeds, divert and load as PSD\n\n    if (!m_photoshopBlockParsed) {\n        QBuffer photoshopLayerData;\n\n        KisTiffPsdLayerRecord photoshopLayerRecord(TIFFIsBigEndian(image),\n                                                   basicInfo.width,\n                                                   basicInfo.height,\n                                                   basicInfo.depth,\n                                                   basicInfo.nbchannels,\n                                                   basicInfo.color_type);\n\n        KisTiffPsdResourceRecord photoshopImageResourceRecord;\n\n        {\n            // Determine if we have Photoshop metadata\n            uint32_t length{0};\n            uint8_t *data{nullptr};\n\n            if (TIFFGetField(image, TIFFTAG_IMAGESOURCEDATA, &length, &data)\n                == 1) {\n                dbgFile << \"There are Photoshop layers, processing them now. \"\n                           \"Section size: \"\n                        << length;\n\n                QByteArray buf(reinterpret_cast<char *>(data),\n                               static_cast<int>(length));\n                photoshopLayerData.setData(buf);\n                photoshopLayerData.open(QIODevice::ReadOnly);\n\n                if (!photoshopLayerRecord.read(photoshopLayerData)) {\n                    dbgFile << \"TIFF: failed reading Photoshop layer metadata: \"\n                            << photoshopLayerRecord.record()->error;\n                }\n            }\n        }\n\n        {\n            // Determine if we have Photoshop metadata\n            uint32_t length{0};\n            uint8_t *data{nullptr};\n\n            if (TIFFGetField(image, TIFFTAG_PHOTOSHOP, &length, &data) == 1\n                && data != nullptr) {\n                dbgFile << \"There is Photoshop metadata, processing it now. \"\n                           \"Section size: \"\n                        << length;\n\n                QByteArray photoshopImageResourceData(\n                    reinterpret_cast<char *>(data),\n                    static_cast<int>(length));\n\n                QBuffer buf(&photoshopImageResourceData);\n                buf.open(QIODevice::ReadOnly);\n\n                if (!photoshopImageResourceRecord.read(buf)) {\n                    dbgFile << \"TIFF: failed reading Photoshop image metadata: \"\n                            << photoshopImageResourceRecord.error;\n                }\n            }\n        }\n\n        if (photoshopLayerRecord.valid()\n            && photoshopImageResourceRecord.valid()) {\n\n            if (importUserFeedBackInterface()) {\n\n                bool usePsd = true;\n                importUserFeedBackInterface()->askUser([&] (QWidget *parent) {\n                    usePsd = QMessageBox::question(parent, i18nc(\"@title:window\", \"TIFF image with PSD data\"),\n                                            i18nc(\"the choice for the user on loading a TIFF file\",\n                                                \"The TIFF image contains valid PSD data embedded. \"\n                                                \"Would you like to use PSD data instead of normal TIFF data?\"))\n                        == QMessageBox::Yes;\n\n                    return true;\n                });\n\n                if (!usePsd) {\n                    return ImportExportCodes::Cancelled;\n                }\n            }\n\n            KisImportExportErrorCode result =\n                readImageFromPsdRecords(m_doc,\n                                        photoshopLayerRecord,\n                                        photoshopImageResourceRecord,\n                                        photoshopLayerData,\n                                        basicInfo);\n\n            if (!result.isOk()) {\n                dbgFile << \"Photoshop import failed\";\n            }\n            return result;\n        }\n    }\n\n    return ImportExportCodes::FormatFeaturesUnsupported;\n\n#else\n    return ImportExportCodes::FormatFeaturesUnsupported;\n#endif\n}",
    "KisImportExportErrorCode KisTIFFImport::readTIFFDirectory(KisDocument *m_doc,\n                                                          TIFF *image)\n{\n    // Read information about the tiff\n\n    KisTiffBasicInfo basicInfo;\n\n    if (TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &basicInfo.width) == 0) {\n        dbgFile << \"Image does not define its width\";\n        return ImportExportCodes::FileFormatIncorrect;\n    }\n\n    if (TIFFGetField(image, TIFFTAG_IMAGELENGTH, &basicInfo.height) == 0) {\n        dbgFile << \"Image does not define its height\";\n        return ImportExportCodes::FileFormatIncorrect;\n    }\n\n    if (TIFFGetField(image, TIFFTAG_XRESOLUTION, &basicInfo.xres) == 0 || basicInfo.xres == 0) {\n        dbgFile << \"Image does not define x resolution\";\n        // but we don't stop\n        basicInfo.xres = 100;\n    }\n\n    if (TIFFGetField(image, TIFFTAG_YRESOLUTION, &basicInfo.yres) == 0 || basicInfo.yres == 0) {\n        dbgFile << \"Image does not define y resolution\";\n        // but we don't stop\n        basicInfo.yres = 100;\n    }\n\n    if (TIFFGetField(image, TIFFTAG_RESOLUTIONUNIT, &basicInfo.resolution) == 0) {\n        dbgFile << \"Image does not define resolution unit\";\n        // but we don't stop\n        basicInfo.resolution = TiffResolution::INCH;\n    }\n\n    if (TIFFGetField(image, TIFFTAG_XPOSITION, &basicInfo.x) == 0) {\n        dbgFile << \"Image does not define a horizontal offset\";\n        basicInfo.x = 0;\n    }\n\n    if (TIFFGetField(image, TIFFTAG_YPOSITION, &basicInfo.y) == 0) {\n        dbgFile << \"Image does not define a vertical offset\";\n        basicInfo.y = 0;\n    }\n\n    if ((TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &basicInfo.depth) == 0)) {\n        dbgFile << \"Image does not define its depth\";\n        basicInfo.depth = 1;\n    }\n\n    if ((TIFFGetField(image, TIFFTAG_SAMPLEFORMAT, &basicInfo.sampletype)\n         == 0)) {\n        dbgFile << \"Image does not define its sample type\";\n        basicInfo.sampletype = SAMPLEFORMAT_UINT;\n    }\n\n    // Determine the number of channels (useful to know if a file has an alpha\n    // or not\n    if (TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &basicInfo.nbchannels)\n        == 0) {\n        dbgFile << \"Image has an undefined number of samples per pixel\";\n        basicInfo.nbchannels = 0;\n    }\n\n    // Get the number of extrasamples and information about them\n    if (TIFFGetField(image,\n                     TIFFTAG_EXTRASAMPLES,\n                     &basicInfo.extrasamplescount,\n                     &basicInfo.sampleinfo)\n        == 0) {\n        basicInfo.extrasamplescount = 0;\n    }\n\n    // Determine the colorspace\n    if (TIFFGetField(image, TIFFTAG_PHOTOMETRIC, &basicInfo.color_type) == 0) {\n        dbgFile << \"Image has an undefined photometric interpretation\";\n        basicInfo.color_type = PHOTOMETRIC_MINISWHITE;\n    }\n\n    basicInfo.colorSpaceIdTag =\n        getColorSpaceForColorType(basicInfo.sampletype,\n                                  basicInfo.color_type,\n                                  basicInfo.depth,\n                                  image,\n                                  basicInfo.nbchannels,\n                                  basicInfo.extrasamplescount,\n                                  basicInfo.dstDepth);\n\n    if (basicInfo.colorSpaceIdTag.first.isEmpty()) {\n        dbgFile << \"Image has an unsupported colorspace :\"\n                << basicInfo.color_type\n                << \" for this depth :\" << basicInfo.depth;\n        return ImportExportCodes::FormatColorSpaceUnsupported;\n    }\n    dbgFile << \"Color space is :\" << basicInfo.colorSpaceIdTag.first\n            << basicInfo.colorSpaceIdTag.second << \" with a depth of\"\n            << basicInfo.depth << \" and with a nb of channels of\"\n            << basicInfo.nbchannels;\n\n    // Read image profile\n    dbgFile << \"Reading profile\";\n    const KoColorProfile *profile = nullptr;\n    quint32 EmbedLen = 0;\n    uint8_t *EmbedBuffer = nullptr;\n\n    if (TIFFGetField(image, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer) == 1) {\n        dbgFile << \"Profile found\";\n        QByteArray rawdata(reinterpret_cast<char *>(EmbedBuffer),\n                           static_cast<int>(EmbedLen));\n        profile = KoColorSpaceRegistry::instance()->createColorProfile(\n            basicInfo.colorSpaceIdTag.first,\n            basicInfo.colorSpaceIdTag.second,\n            rawdata);\n    }\n\n    const QString colorSpaceId = KoColorSpaceRegistry::instance()->colorSpaceId(\n        basicInfo.colorSpaceIdTag.first,\n        basicInfo.colorSpaceIdTag.second);\n\n    // Check that the profile is used by the color space\n    if (profile\n        && !KoColorSpaceRegistry::instance()->profileIsCompatible(\n            profile,\n            colorSpaceId)) {\n        dbgFile << \"The profile \" << profile->name()\n                << \" is not compatible with the color space model \"\n                << basicInfo.colorSpaceIdTag.first << \" \"\n                << basicInfo.colorSpaceIdTag.second;\n        profile = nullptr;\n    }\n\n    // Do not use the linear gamma profile for 16 bits/channel by default, tiff\n    // files are usually created with gamma correction. XXX: Should we ask the\n    // user?\n    if (!profile) {\n        dbgFile << \"No profile found; trying to assign a default one.\";\n        if (basicInfo.colorSpaceIdTag.first == RGBAColorModelID.id()) {\n            profile = KoColorSpaceRegistry::instance()->profileByName(\n                \"sRGB-elle-V2-srgbtrc.icc\");\n        } else if (basicInfo.colorSpaceIdTag.first == GrayAColorModelID.id()) {\n            profile = KoColorSpaceRegistry::instance()->profileByName(\n                \"Gray-D50-elle-V2-srgbtrc.icc\");\n        } else if (basicInfo.colorSpaceIdTag.first == CMYKAColorModelID.id()) {\n            profile = KoColorSpaceRegistry::instance()->profileByName(\n                \"Chemical proof\");\n        } else if (basicInfo.colorSpaceIdTag.first == LABAColorModelID.id()) {\n            profile = KoColorSpaceRegistry::instance()->profileByName(\n                \"Lab identity built-in\");\n        } else if (basicInfo.colorSpaceIdTag.first == YCbCrAColorModelID.id()) {\n            profile = KoColorSpaceRegistry::instance()->profileByName(\n                \"ITU-R BT.709-6 YCbCr ICC V4 profile\");\n        }\n        if (!profile) {\n            dbgFile << \"No suitable default profile found.\";\n        }\n    }\n\n    // Retrieve a pointer to the colorspace\n    if (profile && profile->isSuitableForOutput()) {\n        dbgFile << \"image has embedded profile:\" << profile->name() << \"\";\n        basicInfo.cs = KoColorSpaceRegistry::instance()->colorSpace(\n            basicInfo.colorSpaceIdTag.first,\n            basicInfo.colorSpaceIdTag.second,\n            profile);\n    } else {\n        // Ensure an empty profile name is supplied so that the fallback logic\n        // in KoColorSpaceRegistry is triggered. BUG:464848\n        basicInfo.cs = KoColorSpaceRegistry::instance()->colorSpace(basicInfo.colorSpaceIdTag.first,\n                                                                    basicInfo.colorSpaceIdTag.second,\n                                                                    \"\");\n    }\n\n    if (basicInfo.cs == nullptr) {\n        dbgFile << \"Color space\" << basicInfo.colorSpaceIdTag.first\n                << basicInfo.colorSpaceIdTag.second\n                << \" is not available, please check your installation.\";\n        return ImportExportCodes::FormatColorSpaceUnsupported;\n    }\n\n    // Create the cmsTransform if needed\n    if (profile && !profile->isSuitableForOutput()) {\n        dbgFile << \"The profile can't be used in krita, need conversion\";\n        basicInfo.transform =\n            KoColorSpaceRegistry::instance()\n                ->colorSpace(basicInfo.colorSpaceIdTag.first,\n                             basicInfo.colorSpaceIdTag.second,\n                             profile)\n                ->createColorConverter(\n                    basicInfo.cs,\n                    KoColorConversionTransformation::internalRenderingIntent(),\n                    KoColorConversionTransformation::internalConversionFlags());\n    }\n\n    KisImportExportErrorCode result = readImageFromPsd(m_doc, image, basicInfo);\n    if (!result.isOk()) {\n        result = readImageFromTiff(m_doc, image, basicInfo);\n    }\n\n    return result;\n}",
    "int GTiffDataset::GetJPEGOverviewCount()\n{\n    if (m_nJPEGOverviewCount >= 0)\n        return m_nJPEGOverviewCount;\n\n    m_nJPEGOverviewCount = 0;\n    if (m_poBaseDS || eAccess != GA_ReadOnly ||\n        m_nCompression != COMPRESSION_JPEG ||\n        (nRasterXSize < 256 && nRasterYSize < 256) ||\n        !CPLTestBool(CPLGetConfigOption(\"GTIFF_IMPLICIT_JPEG_OVR\", \"YES\")) ||\n        GDALGetDriverByName(\"JPEG\") == nullptr)\n    {\n        return 0;\n    }\n    const char *pszSourceColorSpace =\n        m_oGTiffMDMD.GetMetadataItem(\"SOURCE_COLOR_SPACE\", \"IMAGE_STRUCTURE\");\n    if (pszSourceColorSpace != nullptr && EQUAL(pszSourceColorSpace, \"CMYK\"))\n    {\n        // We cannot handle implicit overviews on JPEG CMYK datasets converted\n        // to RGBA This would imply doing the conversion in\n        // GTiffJPEGOverviewBand.\n        return 0;\n    }\n\n    // libjpeg-6b only supports 2, 4 and 8 scale denominators.\n    // TODO: Later versions support more.\n    for (signed char i = 2; i >= 0; i--)\n    {\n        if (nRasterXSize >= (256 << i) || nRasterYSize >= (256 << i))\n        {\n            m_nJPEGOverviewCount = i + 1;\n            break;\n        }\n    }\n    if (m_nJPEGOverviewCount == 0)\n        return 0;\n\n    // Get JPEG tables.\n    uint32_t nJPEGTableSize = 0;\n    void *pJPEGTable = nullptr;\n    GByte abyFFD8[] = {0xFF, 0xD8};\n    if (TIFFGetField(m_hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize, &pJPEGTable))\n    {\n        if (pJPEGTable == nullptr || nJPEGTableSize < 2 ||\n            nJPEGTableSize > INT_MAX ||\n            static_cast<GByte *>(pJPEGTable)[nJPEGTableSize - 1] != 0xD9)\n        {\n            m_nJPEGOverviewCount = 0;\n            return 0;\n        }\n        nJPEGTableSize--;  // Remove final 0xD9.\n    }\n    else\n    {\n        pJPEGTable = abyFFD8;\n        nJPEGTableSize = 2;\n    }\n\n    m_papoJPEGOverviewDS = static_cast<GTiffJPEGOverviewDS **>(\n        CPLMalloc(sizeof(GTiffJPEGOverviewDS *) * m_nJPEGOverviewCount));\n    for (int i = 0; i < m_nJPEGOverviewCount; ++i)\n    {\n        m_papoJPEGOverviewDS[i] = new GTiffJPEGOverviewDS(\n            this, i + 1, pJPEGTable, static_cast<int>(nJPEGTableSize));\n    }\n\n    m_nJPEGOverviewCountOri = m_nJPEGOverviewCount;\n\n    return m_nJPEGOverviewCount;\n}",
    "CPLErr GTiffDataset::ReadCompressedData(const char *pszFormat, int nXOff,\n                                        int nYOff, int nXSize, int nYSize,\n                                        int nBandCount, const int *panBandList,\n                                        void **ppBuffer, size_t *pnBufferSize,\n                                        char **ppszDetailedFormat)\n{\n    if (m_nCompression != COMPRESSION_NONE &&\n        IsWholeBlock(nXOff, nYOff, nXSize, nYSize) &&\n        ((nBandCount == 1 && (panBandList != nullptr || nBands == 1) &&\n          m_nPlanarConfig == PLANARCONFIG_SEPARATE) ||\n         (IsAllBands(nBandCount, panBandList) &&\n          m_nPlanarConfig == PLANARCONFIG_CONTIG)))\n    {\n        const CPLStringList aosTokens(CSLTokenizeString2(pszFormat, \";\", 0));\n        if (aosTokens.size() != 1)\n            return CE_Failure;\n\n        // We don't want to handle CMYK JPEG for now\n        if ((m_nCompression == COMPRESSION_JPEG &&\n             EQUAL(aosTokens[0], \"JPEG\") &&\n             (m_nPlanarConfig == PLANARCONFIG_SEPARATE ||\n              m_nPhotometric != PHOTOMETRIC_SEPARATED)) ||\n            (m_nCompression == COMPRESSION_WEBP &&\n             EQUAL(aosTokens[0], \"WEBP\")) ||\n            ((m_nCompression == COMPRESSION_JXL ||\n              m_nCompression == COMPRESSION_JXL_DNG_1_7) &&\n             EQUAL(aosTokens[0], \"JXL\")))\n        {\n            std::string osDetailedFormat = aosTokens[0];\n\n            int nBlockId = (nXOff / m_nBlockXSize) +\n                           (nYOff / m_nBlockYSize) * m_nBlocksPerRow;\n            if (m_nPlanarConfig == PLANARCONFIG_SEPARATE &&\n                panBandList != nullptr)\n                nBlockId += panBandList[0] * m_nBlocksPerBand;\n\n            vsi_l_offset nOffset = 0;\n            vsi_l_offset nSize = 0;\n            if (IsBlockAvailable(nBlockId, &nOffset, &nSize, nullptr) &&\n                nSize < static_cast<vsi_l_offset>(\n                            std::numeric_limits<tmsize_t>::max()))\n            {\n                uint32_t nJPEGTableSize = 0;\n                void *pJPEGTable = nullptr;\n                if (m_nCompression == COMPRESSION_JPEG)\n                {\n                    if (TIFFGetField(m_hTIFF, TIFFTAG_JPEGTABLES,\n                                     &nJPEGTableSize, &pJPEGTable) &&\n                        pJPEGTable != nullptr && nJPEGTableSize > 4 &&\n                        static_cast<GByte *>(pJPEGTable)[0] == 0xFF &&\n                        static_cast<GByte *>(pJPEGTable)[1] == 0xD8 &&\n                        static_cast<GByte *>(pJPEGTable)[nJPEGTableSize - 2] ==\n                            0xFF &&\n                        static_cast<GByte *>(pJPEGTable)[nJPEGTableSize - 1] ==\n                            0xD9)\n                    {\n                        pJPEGTable = static_cast<GByte *>(pJPEGTable) + 2;\n                        nJPEGTableSize -= 4;\n                    }\n                    else\n                    {\n                        nJPEGTableSize = 0;\n                    }\n                }\n\n                size_t nSizeSize = static_cast<size_t>(nSize + nJPEGTableSize);\n                if (ppBuffer)\n                {\n                    if (!pnBufferSize)\n                        return CE_Failure;\n                    bool bFreeOnError = false;\n                    if (*ppBuffer)\n                    {\n                        if (*pnBufferSize < nSizeSize)\n                            return CE_Failure;\n                    }\n                    else\n                    {\n                        *ppBuffer = VSI_MALLOC_VERBOSE(nSizeSize);\n                        if (*ppBuffer == nullptr)\n                            return CE_Failure;\n                        bFreeOnError = true;\n                    }\n                    const auto nTileSize = static_cast<tmsize_t>(nSize);\n                    bool bOK;\n                    if (TIFFIsTiled(m_hTIFF))\n                    {\n                        bOK = TIFFReadRawTile(m_hTIFF, nBlockId, *ppBuffer,\n                                              nTileSize) == nTileSize;\n                    }\n                    else\n                    {\n                        bOK = TIFFReadRawStrip(m_hTIFF, nBlockId, *ppBuffer,\n                                               nTileSize) == nTileSize;\n                    }\n                    if (!bOK)\n                    {\n                        if (bFreeOnError)\n                        {\n                            VSIFree(*ppBuffer);\n                            *ppBuffer = nullptr;\n                        }\n                        return CE_Failure;\n                    }\n                    if (nJPEGTableSize > 0)\n                    {\n                        GByte *pabyBuffer = static_cast<GByte *>(*ppBuffer);\n                        memmove(pabyBuffer + 2 + nJPEGTableSize, pabyBuffer + 2,\n                                static_cast<size_t>(nSize) - 2);\n                        memcpy(pabyBuffer + 2, pJPEGTable, nJPEGTableSize);\n                    }\n\n                    if (m_nCompression == COMPRESSION_JPEG)\n                    {\n                        osDetailedFormat = GDALGetCompressionFormatForJPEG(\n                            *ppBuffer, nSizeSize);\n                        const CPLStringList aosTokens2(CSLTokenizeString2(\n                            osDetailedFormat.c_str(), \";\", 0));\n                        if (m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n                            nBands == 4 && m_nPhotometric == PHOTOMETRIC_RGB &&\n                            GetRasterBand(4)->GetColorInterpretation() ==\n                                GCI_AlphaBand)\n                        {\n                            osDetailedFormat = aosTokens2[0];\n                            for (int i = 1; i < aosTokens2.size(); ++i)\n                            {\n                                if (!STARTS_WITH_CI(aosTokens2[i],\n                                                    \"colorspace=\"))\n                                {\n                                    osDetailedFormat += ';';\n                                    osDetailedFormat += aosTokens2[i];\n                                }\n                            }\n                            osDetailedFormat += \";colorspace=RGBA\";\n                        }\n                    }\n                }\n                if (ppszDetailedFormat)\n                    *ppszDetailedFormat = VSIStrdup(osDetailedFormat.c_str());\n                if (pnBufferSize)\n                    *pnBufferSize = nSizeSize;\n                return CE_None;\n            }\n        }\n    }\n    return CE_Failure;\n}",
    "CPLErr GTiffDataset::MultiThreadedRead(int nXOff, int nYOff, int nXSize,\n                                       int nYSize, void *pData,\n                                       GDALDataType eBufType, int nBandCount,\n                                       const int *panBandMap,\n                                       GSpacing nPixelSpace,\n                                       GSpacing nLineSpace, GSpacing nBandSpace)\n{\n    auto poQueue = m_poThreadPool->CreateJobQueue();\n    if (poQueue == nullptr)\n    {\n        return CE_Failure;\n    }\n\n    const int nBlockXStart = nXOff / m_nBlockXSize;\n    const int nBlockYStart = nYOff / m_nBlockYSize;\n    const int nBlockXEnd = (nXOff + nXSize - 1) / m_nBlockXSize;\n    const int nBlockYEnd = (nYOff + nYSize - 1) / m_nBlockYSize;\n    const int nXBlocks = nBlockXEnd - nBlockXStart + 1;\n    const int nYBlocks = nBlockYEnd - nBlockYStart + 1;\n    const int nStrilePerBlock =\n        m_nPlanarConfig == PLANARCONFIG_CONTIG ? 1 : nBandCount;\n    const int nBlocks = nXBlocks * nYBlocks * nStrilePerBlock;\n\n    GTiffDecompressContext sContext;\n    sContext.poHandle = VSI_TIFFGetVSILFile(TIFFClientdata(m_hTIFF));\n    sContext.bHasPRead =\n        sContext.poHandle->HasPRead()\n#ifdef DEBUG\n        && CPLTestBool(CPLGetConfigOption(\"GTIFF_ALLOW_PREAD\", \"YES\"))\n#endif\n        ;\n    sContext.poDS = this;\n    sContext.eDT = GetRasterBand(1)->GetRasterDataType();\n    sContext.nXOff = nXOff;\n    sContext.nYOff = nYOff;\n    sContext.nXSize = nXSize;\n    sContext.nYSize = nYSize;\n    sContext.nBlockXStart = nBlockXStart;\n    sContext.nBlockXEnd = nBlockXEnd;\n    sContext.nBlockYStart = nBlockYStart;\n    sContext.nBlockYEnd = nBlockYEnd;\n    sContext.pabyData = static_cast<GByte *>(pData);\n    sContext.eBufType = eBufType;\n    sContext.nBufDTSize = GDALGetDataTypeSizeBytes(eBufType);\n    sContext.nBandCount = nBandCount;\n    sContext.panBandMap = panBandMap;\n    sContext.nPixelSpace = nPixelSpace;\n    sContext.nLineSpace = nLineSpace;\n    // Setting nBandSpace to a dummy value when nBandCount == 1 helps detecting\n    // bad computations of target buffer address\n    // (https://github.com/rasterio/rasterio/issues/2847)\n    sContext.nBandSpace = nBandCount == 1 ? 0xDEADBEEF : nBandSpace;\n    sContext.bIsTiled = CPL_TO_BOOL(TIFFIsTiled(m_hTIFF));\n    sContext.bTIFFIsBigEndian = CPL_TO_BOOL(TIFFIsBigEndian(m_hTIFF));\n    sContext.nPredictor = PREDICTOR_NONE;\n    sContext.nBlocksPerRow = m_nBlocksPerRow;\n\n    if (m_bDirectIO)\n    {\n        sContext.bSkipBlockCache = true;\n    }\n    else if (nXOff == 0 && nYOff == 0 && nXSize == nRasterXSize &&\n             nYSize == nRasterYSize)\n    {\n        if (m_nPlanarConfig == PLANARCONFIG_SEPARATE)\n        {\n            sContext.bSkipBlockCache = true;\n        }\n        else if (nBandCount == nBands)\n        {\n            sContext.bSkipBlockCache = true;\n            for (int i = 0; i < nBands; ++i)\n            {\n                if (panBandMap[i] != i + 1)\n                {\n                    sContext.bSkipBlockCache = false;\n                    break;\n                }\n            }\n        }\n    }\n\n    if (m_nPlanarConfig == PLANARCONFIG_CONTIG && nBandCount == nBands &&\n        nPixelSpace == nBands * static_cast<GSpacing>(sContext.nBufDTSize))\n    {\n        sContext.bUseBIPOptim = true;\n        for (int i = 0; i < nBands; ++i)\n        {\n            if (panBandMap[i] != i + 1)\n            {\n                sContext.bUseBIPOptim = false;\n                break;\n            }\n        }\n    }\n\n    if (m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        (nBands == 3 || nBands == 4) && nBands == nBandCount &&\n        (sContext.eDT == GDT_Byte || sContext.eDT == GDT_Int16 ||\n         sContext.eDT == GDT_UInt16))\n    {\n        if (sContext.bSkipBlockCache)\n        {\n            if (sContext.eBufType == sContext.eDT &&\n                nPixelSpace == sContext.nBufDTSize)\n            {\n                sContext.bUseDeinterleaveOptimNoBlockCache = true;\n            }\n        }\n        else\n        {\n            sContext.bUseDeinterleaveOptimBlockCache = true;\n            for (int i = 0; i < nBands; ++i)\n            {\n                if (panBandMap[i] != i + 1)\n                {\n                    sContext.bUseDeinterleaveOptimBlockCache = false;\n                    break;\n                }\n            }\n        }\n    }\n\n    // In contig mode, if only one band is requested, check if we have\n    // enough cache to cache all bands.\n    if (!sContext.bSkipBlockCache && nBands != 1 &&\n        m_nPlanarConfig == PLANARCONFIG_CONTIG && nBandCount == 1)\n    {\n        const GIntBig nRequiredMem = static_cast<GIntBig>(nBands) * nXBlocks *\n                                     nYBlocks * m_nBlockXSize * m_nBlockYSize *\n                                     GDALGetDataTypeSizeBytes(sContext.eDT);\n        if (nRequiredMem > GDALGetCacheMax64())\n        {\n            if (!m_bHasWarnedDisableAggressiveBandCaching)\n            {\n                CPLDebug(\"GTiff\",\n                         \"Disable aggressive band caching. \"\n                         \"Cache not big enough. \"\n                         \"At least \" CPL_FRMT_GIB \" bytes necessary\",\n                         nRequiredMem);\n                m_bHasWarnedDisableAggressiveBandCaching = true;\n            }\n        }\n        else\n        {\n            sContext.bCacheAllBands = true;\n            if ((nBands == 3 || nBands == 4) &&\n                (sContext.eDT == GDT_Byte || sContext.eDT == GDT_Int16 ||\n                 sContext.eDT == GDT_UInt16))\n            {\n                sContext.bUseDeinterleaveOptimBlockCache = true;\n            }\n        }\n    }\n\n    if (eAccess == GA_Update)\n    {\n        std::vector<int> anBandsToCheck;\n        if (m_nPlanarConfig == PLANARCONFIG_CONTIG && nBands > 1)\n        {\n            for (int i = 0; i < nBands; ++i)\n            {\n                anBandsToCheck.push_back(i);\n            }\n        }\n        else\n        {\n            for (int i = 0; i < nBandCount; ++i)\n            {\n                anBandsToCheck.push_back(panBandMap[i] - 1);\n            }\n        }\n        if (!anBandsToCheck.empty())\n        {\n            // If at least one block in the region of intersest is dirty,\n            // fallback to normal reading code path to be able to retrieve\n            // content partly from the block cache.\n            // An alternative that was implemented in GDAL 3.6 to 3.8.0 was\n            // to flush dirty blocks, but this could cause many write&read&write\n            // cycles in some gdalwarp scenarios.\n            // Cf https://github.com/OSGeo/gdal/issues/8729\n            bool bUseBaseImplementation = false;\n            for (int y = 0; y < nYBlocks; ++y)\n            {\n                for (int x = 0; x < nXBlocks; ++x)\n                {\n                    for (const int iBand : anBandsToCheck)\n                    {\n                        if (m_nLoadedBlock >= 0 && m_bLoadedBlockDirty &&\n                            cpl::down_cast<GTiffRasterBand *>(papoBands[iBand])\n                                    ->ComputeBlockId(nBlockXStart + x,\n                                                     nBlockYStart + y) ==\n                                m_nLoadedBlock)\n                        {\n                            bUseBaseImplementation = true;\n                            goto after_loop;\n                        }\n                        auto poBlock = papoBands[iBand]->TryGetLockedBlockRef(\n                            nBlockXStart + x, nBlockYStart + y);\n                        if (poBlock)\n                        {\n                            if (poBlock->GetDirty())\n                            {\n                                poBlock->DropLock();\n                                bUseBaseImplementation = true;\n                                goto after_loop;\n                            }\n                            poBlock->DropLock();\n                        }\n                    }\n                }\n            }\n        after_loop:\n            if (bUseBaseImplementation)\n            {\n                ++m_nDisableMultiThreadedRead;\n                GDALRasterIOExtraArg sExtraArg;\n                INIT_RASTERIO_EXTRA_ARG(sExtraArg);\n                const CPLErr eErr = GDALDataset::IRasterIO(\n                    GF_Read, nXOff, nYOff, nXSize, nYSize, pData, nXSize,\n                    nYSize, eBufType, nBandCount, const_cast<int *>(panBandMap),\n                    nPixelSpace, nLineSpace, nBandSpace, &sExtraArg);\n                --m_nDisableMultiThreadedRead;\n                return eErr;\n            }\n        }\n\n        // Make sure that all blocks that we are going to read and that are\n        // being written by a worker thread are completed.\n        // cppcheck-suppress constVariableReference\n        auto &oQueue =\n            m_poBaseDS ? m_poBaseDS->m_asQueueJobIdx : m_asQueueJobIdx;\n        if (!oQueue.empty())\n        {\n            for (int y = 0; y < nYBlocks; ++y)\n            {\n                for (int x = 0; x < nXBlocks; ++x)\n                {\n                    for (int i = 0; i < nStrilePerBlock; ++i)\n                    {\n                        int nBlockId =\n                            nBlockXStart + x +\n                            (nBlockYStart + y) * sContext.nBlocksPerRow;\n                        if (m_nPlanarConfig == PLANARCONFIG_SEPARATE)\n                            nBlockId += (panBandMap[i] - 1) * m_nBlocksPerBand;\n\n                        WaitCompletionForBlock(nBlockId);\n                    }\n                }\n            }\n        }\n\n        // Flush to file, and then to disk if using pread() interface\n        VSI_TIFFFlushBufferedWrite(TIFFClientdata(m_hTIFF));\n        if (sContext.bHasPRead)\n            sContext.poHandle->Flush();\n    }\n\n    if (GTIFFSupportsPredictor(m_nCompression))\n    {\n        TIFFGetField(m_hTIFF, TIFFTAG_PREDICTOR, &sContext.nPredictor);\n    }\n    else if (m_nCompression == COMPRESSION_JPEG)\n    {\n        TIFFGetField(m_hTIFF, TIFFTAG_JPEGTABLES, &sContext.nJPEGTableSize,\n                     &sContext.pJPEGTable);\n        if (m_nPhotometric == PHOTOMETRIC_YCBCR)\n        {\n            TIFFGetFieldDefaulted(m_hTIFF, TIFFTAG_YCBCRSUBSAMPLING,\n                                  &sContext.nYCrbCrSubSampling0,\n                                  &sContext.nYCrbCrSubSampling1);\n        }\n    }\n    if (m_nPlanarConfig == PLANARCONFIG_CONTIG)\n    {\n        TIFFGetField(m_hTIFF, TIFFTAG_EXTRASAMPLES, &sContext.nExtraSampleCount,\n                     &sContext.pExtraSamples);\n    }\n\n    // Create one job per tile/strip\n    vsi_l_offset nFileSize = 0;\n    std::vector<GTiffDecompressJob> asJobs(nBlocks);\n    std::vector<vsi_l_offset> anOffsets(nBlocks);\n    std::vector<size_t> anSizes(nBlocks);\n    int iJob = 0;\n    int nAdviseReadRanges = 0;\n    const size_t nAdviseReadTotalBytesLimit =\n        sContext.poHandle->GetAdviseReadTotalBytesLimit();\n    size_t nAdviseReadAccBytes = 0;\n    for (int y = 0; y < nYBlocks; ++y)\n    {\n        for (int x = 0; x < nXBlocks; ++x)\n        {\n            for (int i = 0; i < nStrilePerBlock; ++i)\n            {\n                asJobs[iJob].psContext = &sContext;\n                asJobs[iJob].iSrcBandIdxSeparate =\n                    m_nPlanarConfig == PLANARCONFIG_CONTIG ? -1\n                                                           : panBandMap[i] - 1;\n                asJobs[iJob].iDstBandIdxSeparate =\n                    m_nPlanarConfig == PLANARCONFIG_CONTIG ? -1 : i;\n                asJobs[iJob].nXBlock = nBlockXStart + x;\n                asJobs[iJob].nYBlock = nBlockYStart + y;\n\n                int nBlockId = asJobs[iJob].nXBlock +\n                               asJobs[iJob].nYBlock * sContext.nBlocksPerRow;\n                if (m_nPlanarConfig == PLANARCONFIG_SEPARATE)\n                    nBlockId +=\n                        asJobs[iJob].iSrcBandIdxSeparate * m_nBlocksPerBand;\n\n                bool bErrorInIsBlockAvailable = false;\n                if (!sContext.bHasPRead)\n                {\n                    // Taking the mutex here is only needed when bHasPRead ==\n                    // false since we could have concurrent uses of the handle,\n                    // when when reading the TIFF TileOffsets / TileByteCounts\n                    // array\n                    std::lock_guard<std::recursive_mutex> oLock(\n                        sContext.oMutex);\n\n                    CPL_IGNORE_RET_VAL(IsBlockAvailable(\n                        nBlockId, &asJobs[iJob].nOffset, &asJobs[iJob].nSize,\n                        &bErrorInIsBlockAvailable));\n                }\n                else\n                {\n                    CPL_IGNORE_RET_VAL(IsBlockAvailable(\n                        nBlockId, &asJobs[iJob].nOffset, &asJobs[iJob].nSize,\n                        &bErrorInIsBlockAvailable));\n                }\n                if (bErrorInIsBlockAvailable)\n                {\n                    ReportError(CE_Failure, CPLE_AppDefined,\n                                \"Error while getting location of block %d\",\n                                nBlockId);\n                    std::lock_guard<std::recursive_mutex> oLock(\n                        sContext.oMutex);\n                    sContext.bSuccess = false;\n                    return CE_Failure;\n                }\n\n                // Sanity check on block size\n                if (asJobs[iJob].nSize > 100U * 1024 * 1024)\n                {\n                    if (nFileSize == 0)\n                    {\n                        std::lock_guard<std::recursive_mutex> oLock(\n                            sContext.oMutex);\n                        sContext.poHandle->Seek(0, SEEK_END);\n                        nFileSize = sContext.poHandle->Tell();\n                    }\n                    if (asJobs[iJob].nSize > nFileSize)\n                    {\n                        CPLError(CE_Failure, CPLE_AppDefined,\n                                 \"Cannot read \" CPL_FRMT_GUIB\n                                 \" bytes at offset \" CPL_FRMT_GUIB,\n                                 static_cast<GUIntBig>(asJobs[iJob].nSize),\n                                 static_cast<GUIntBig>(asJobs[iJob].nOffset));\n\n                        std::lock_guard<std::recursive_mutex> oLock(\n                            sContext.oMutex);\n                        sContext.bSuccess = false;\n                        return CE_Failure;\n                    }\n                }\n\n                // Only request in AdviseRead() ranges for blocks we don't\n                // have in cache.\n                bool bAddToAdviseRead = true;\n                if (m_nPlanarConfig == PLANARCONFIG_SEPARATE)\n                {\n                    auto poBlock =\n                        GetRasterBand(panBandMap[i])\n                            ->TryGetLockedBlockRef(asJobs[iJob].nXBlock,\n                                                   asJobs[iJob].nYBlock);\n                    if (poBlock)\n                    {\n                        poBlock->DropLock();\n                        bAddToAdviseRead = false;\n                    }\n                }\n                else\n                {\n                    bool bAllCached = true;\n                    for (int iBand = 0; iBand < nBandCount; ++iBand)\n                    {\n                        auto poBlock =\n                            GetRasterBand(panBandMap[iBand])\n                                ->TryGetLockedBlockRef(asJobs[iJob].nXBlock,\n                                                       asJobs[iJob].nYBlock);\n                        if (poBlock)\n                        {\n                            poBlock->DropLock();\n                        }\n                        else\n                        {\n                            bAllCached = false;\n                            break;\n                        }\n                    }\n                    if (bAllCached)\n                        bAddToAdviseRead = false;\n                }\n\n                if (bAddToAdviseRead)\n                {\n                    anOffsets[nAdviseReadRanges] = asJobs[iJob].nOffset;\n                    anSizes[nAdviseReadRanges] =\n                        static_cast<size_t>(std::min<vsi_l_offset>(\n                            std::numeric_limits<size_t>::max(),\n                            asJobs[iJob].nSize));\n\n                    // If the total number of bytes we must read excess the\n                    // capacity of AdviseRead(), then split the RasterIO()\n                    // request in 2 halves.\n                    if (nAdviseReadTotalBytesLimit > 0 &&\n                        anSizes[nAdviseReadRanges] <\n                            nAdviseReadTotalBytesLimit &&\n                        anSizes[nAdviseReadRanges] >\n                            nAdviseReadTotalBytesLimit - nAdviseReadAccBytes &&\n                        nYBlocks >= 2)\n                    {\n                        const int nYOff2 =\n                            (nBlockYStart + nYBlocks / 2) * m_nBlockYSize;\n                        CPLDebugOnly(\"GTiff\",\n                                     \"Splitting request (%d,%d,%dx%d) into \"\n                                     \"(%d,%d,%dx%d) and (%d,%d,%dx%d)\",\n                                     nXOff, nYOff, nXSize, nYSize, nXOff, nYOff,\n                                     nXSize, nYOff2 - nYOff, nXOff, nYOff2,\n                                     nXSize, nYOff + nYSize - nYOff2);\n\n                        asJobs.clear();\n                        anOffsets.clear();\n                        anSizes.clear();\n                        poQueue.reset();\n\n                        CPLErr eErr = MultiThreadedRead(\n                            nXOff, nYOff, nXSize, nYOff2 - nYOff, pData,\n                            eBufType, nBandCount, panBandMap, nPixelSpace,\n                            nLineSpace, nBandSpace);\n                        if (eErr == CE_None)\n                        {\n                            eErr = MultiThreadedRead(\n                                nXOff, nYOff2, nXSize, nYOff + nYSize - nYOff2,\n                                static_cast<GByte *>(pData) +\n                                    (nYOff2 - nYOff) * nLineSpace,\n                                eBufType, nBandCount, panBandMap, nPixelSpace,\n                                nLineSpace, nBandSpace);\n                        }\n                        return eErr;\n                    }\n                    nAdviseReadAccBytes += anSizes[nAdviseReadRanges];\n\n                    ++nAdviseReadRanges;\n                }\n\n                ++iJob;\n            }\n        }\n    }\n\n    if (sContext.bSuccess)\n    {\n        // Potentially start asynchronous fetching of ranges depending on file\n        // implementation\n        if (nAdviseReadRanges > 0)\n        {\n            sContext.poHandle->AdviseRead(nAdviseReadRanges, anOffsets.data(),\n                                          anSizes.data());\n        }\n\n        // We need to do that as threads will access the block cache\n        TemporarilyDropReadWriteLock();\n\n        for (auto &sJob : asJobs)\n        {\n            poQueue->SubmitJob(ThreadDecompressionFunc, &sJob);\n        }\n\n        // Wait for all jobs to have been completed\n        poQueue->WaitCompletion();\n\n        // Undo effect of above TemporarilyDropReadWriteLock()\n        ReacquireReadWriteLock();\n\n        sContext.oErrorAccumulator.ReplayErrors();\n    }\n\n    return sContext.bSuccess ? CE_None : CE_Failure;\n}",
    "CPLErr GTiffDataset::CommonDirectIO(FetchBuffer &oFetcher, int nXOff, int nYOff,\n                                    int nXSize, int nYSize, void *pData,\n                                    int nBufXSize, int nBufYSize,\n                                    GDALDataType eBufType, int nBandCount,\n                                    const int *panBandMap, GSpacing nPixelSpace,\n                                    GSpacing nLineSpace, GSpacing nBandSpace)\n{\n    const auto poFirstBand =\n        cpl::down_cast<GTiffRasterBand *>(GetRasterBand(1));\n    const GDALDataType eDataType = poFirstBand->GetRasterDataType();\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    const bool bIsComplex = CPL_TO_BOOL(GDALDataTypeIsComplex(eDataType));\n    const int nBufDTSize = GDALGetDataTypeSizeBytes(eBufType);\n\n    // Get strip offsets.\n    toff_t *panOffsets = nullptr;\n    if (!TIFFGetField(m_hTIFF,\n                      (TIFFIsTiled(m_hTIFF)) ? TIFFTAG_TILEOFFSETS\n                                             : TIFFTAG_STRIPOFFSETS,\n                      &panOffsets) ||\n        panOffsets == nullptr)\n    {\n        return CE_Failure;\n    }\n\n    bool bUseContigImplementation = m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n                                    nBandCount > 1 && nBandSpace == nBufDTSize;\n    if (bUseContigImplementation)\n    {\n        for (int iBand = 0; iBand < nBandCount; ++iBand)\n        {\n            const int nBand = panBandMap[iBand];\n            if (nBand != iBand + 1)\n            {\n                bUseContigImplementation = false;\n                break;\n            }\n        }\n    }\n\n    const int nBandsPerBlock =\n        m_nPlanarConfig == PLANARCONFIG_SEPARATE ? 1 : nBands;\n    const int nBandsPerBlockDTSize = nBandsPerBlock * nDTSize;\n    const bool bNoTypeChange = (eDataType == eBufType);\n    const bool bNoXResampling = (nXSize == nBufXSize);\n    const bool bNoXResamplingNoTypeChange = (bNoTypeChange && bNoXResampling);\n    const bool bByteOnly = (bNoTypeChange && nDTSize == 1);\n    const bool bByteNoXResampling = (bByteOnly && bNoXResamplingNoTypeChange);\n    const bool bIsByteSwapped = CPL_TO_BOOL(TIFFIsByteSwapped(m_hTIFF));\n    const double dfSrcXInc = nXSize / static_cast<double>(nBufXSize);\n    const double dfSrcYInc = nYSize / static_cast<double>(nBufYSize);\n\n    int bNoDataSetIn = FALSE;\n    double dfNoData = poFirstBand->GetNoDataValue(&bNoDataSetIn);\n    GByte abyNoData = 0;\n    if (!bNoDataSetIn)\n        dfNoData = 0;\n    else if (dfNoData >= 0 && dfNoData <= 255)\n        abyNoData = static_cast<GByte>(dfNoData + 0.5);\n\n    // cppcheck-suppress knownConditionTrueFalse\n    if (FetchBuffer::bMinimizeIO && TIFFIsTiled(m_hTIFF) && bNoXResampling &&\n        (nYSize == nBufYSize) && m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        nBandCount > 1)\n    {\n        GByte *pabyData = static_cast<GByte *>(pData);\n        for (int y = 0; y < nBufYSize;)\n        {\n            const int nSrcLine = nYOff + y;\n            const int nBlockYOff = nSrcLine / m_nBlockYSize;\n            const int nYOffsetInBlock = nSrcLine % m_nBlockYSize;\n            const int nUsedBlockHeight =\n                std::min(nBufYSize - y, m_nBlockYSize - nYOffsetInBlock);\n\n            int nBlockXOff = nXOff / m_nBlockXSize;\n            int nXOffsetInBlock = nXOff % m_nBlockXSize;\n            int nBlockId = poFirstBand->ComputeBlockId(nBlockXOff, nBlockYOff);\n\n            int x = 0;\n            while (x < nBufXSize)\n            {\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                const int nUsedBlockWidth =\n                    std::min(m_nBlockXSize - nXOffsetInBlock, nBufXSize - x);\n\n                if (nCurOffset == 0)\n                {\n                    REACHED(30);\n                    for (int k = 0; k < nUsedBlockHeight; ++k)\n                    {\n                        GByte *pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for (int iBand = 0; iBand < nBandCount; ++iBand)\n                        {\n                            GByte *pabyLocalDataBand =\n                                pabyLocalData + iBand * nBandSpace;\n\n                            GDALCopyWords(&dfNoData, GDT_Float64, 0,\n                                          pabyLocalDataBand, eBufType,\n                                          static_cast<int>(nPixelSpace),\n                                          nUsedBlockWidth);\n                        }\n                    }\n                }\n                else\n                {\n                    const int nByteOffsetInBlock =\n                        nYOffsetInBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n                    const GByte *pabyLocalSrcDataK0 = oFetcher.FetchBytes(\n                        nCurOffset + nByteOffsetInBlock,\n                        m_nBlockXSize * nUsedBlockHeight * nBandsPerBlock,\n                        nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                    if (pabyLocalSrcDataK0 == nullptr)\n                        return CE_Failure;\n\n                    for (int k = 0; k < nUsedBlockHeight; ++k)\n                    {\n                        GByte *pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        const GByte *pabyLocalSrcData =\n                            pabyLocalSrcDataK0 +\n                            (k * m_nBlockXSize + nXOffsetInBlock) *\n                                nBandsPerBlockDTSize;\n\n                        if (bUseContigImplementation && nBands == nBandCount &&\n                            nPixelSpace == nBandsPerBlockDTSize)\n                        {\n                            REACHED(31);\n                            GDALCopyWords(pabyLocalSrcData, eDataType, nDTSize,\n                                          pabyLocalData, eBufType, nBufDTSize,\n                                          nUsedBlockWidth * nBands);\n                        }\n                        else\n                        {\n                            REACHED(32);\n                            for (int iBand = 0; iBand < nBandCount; ++iBand)\n                            {\n                                GByte *pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte *pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand] - 1) * nDTSize;\n\n                                GDALCopyWords(pabyLocalSrcDataBand, eDataType,\n                                              nBandsPerBlockDTSize,\n                                              pabyLocalDataBand, eBufType,\n                                              static_cast<int>(nPixelSpace),\n                                              nUsedBlockWidth);\n                            }\n                        }\n                    }\n                }\n\n                nXOffsetInBlock = 0;\n                ++nBlockXOff;\n                ++nBlockId;\n                x += nUsedBlockWidth;\n            }\n\n            y += nUsedBlockHeight;\n        }\n    }\n    // cppcheck-suppress knownConditionTrueFalse\n    else if (FetchBuffer::bMinimizeIO && TIFFIsTiled(m_hTIFF) &&\n             bNoXResampling && (nYSize == nBufYSize))\n    // && (m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for (int iBand = 0; iBand < nBandCount; ++iBand)\n        {\n            GByte *pabyData = static_cast<GByte *>(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            auto poCurBand =\n                cpl::down_cast<GTiffRasterBand *>(GetRasterBand(nBand));\n            for (int y = 0; y < nBufYSize;)\n            {\n                const int nSrcLine = nYOff + y;\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int nUsedBlockHeight =\n                    std::min(nBufYSize - y, m_nBlockYSize - nYOffsetIm_nBlock);\n\n                int nBlockXOff = nXOff / m_nBlockXSize;\n                int nXOffsetInBlock = nXOff % m_nBlockXSize;\n                int nBlockId =\n                    poCurBand->ComputeBlockId(nBlockXOff, m_nBlockYOff);\n\n                int x = 0;\n                while (x < nBufXSize)\n                {\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    const int nUsedBlockWidth = std::min(\n                        m_nBlockXSize - nXOffsetInBlock, nBufXSize - x);\n\n                    if (nCurOffset == 0)\n                    {\n                        REACHED(35);\n                        for (int k = 0; k < nUsedBlockHeight; ++k)\n                        {\n                            GByte *pabyLocalData = pabyData +\n                                                   (y + k) * nLineSpace +\n                                                   x * nPixelSpace;\n\n                            GDALCopyWords(&dfNoData, GDT_Float64, 0,\n                                          pabyLocalData, eBufType,\n                                          static_cast<int>(nPixelSpace),\n                                          nUsedBlockWidth);\n                        }\n                    }\n                    else\n                    {\n                        const int nByteOffsetIm_nBlock = nYOffsetIm_nBlock *\n                                                         m_nBlockXSize *\n                                                         nBandsPerBlockDTSize;\n                        const GByte *pabyLocalSrcDataK0 = oFetcher.FetchBytes(\n                            nCurOffset + nByteOffsetIm_nBlock,\n                            m_nBlockXSize * nUsedBlockHeight * nBandsPerBlock,\n                            nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                        if (pabyLocalSrcDataK0 == nullptr)\n                            return CE_Failure;\n\n                        if (m_nPlanarConfig == PLANARCONFIG_CONTIG)\n                        {\n                            REACHED(36);\n                            pabyLocalSrcDataK0 += (nBand - 1) * nDTSize;\n                        }\n                        else\n                        {\n                            REACHED(37);\n                        }\n\n                        for (int k = 0; k < nUsedBlockHeight; ++k)\n                        {\n                            GByte *pabyLocalData = pabyData +\n                                                   (y + k) * nLineSpace +\n                                                   x * nPixelSpace;\n                            const GByte *pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (k * m_nBlockXSize + nXOffsetInBlock) *\n                                    nBandsPerBlockDTSize;\n\n                            GDALCopyWords(\n                                pabyLocalSrcData, eDataType,\n                                nBandsPerBlockDTSize, pabyLocalData, eBufType,\n                                static_cast<int>(nPixelSpace), nUsedBlockWidth);\n                        }\n                    }\n\n                    nXOffsetInBlock = 0;\n                    ++nBlockXOff;\n                    ++nBlockId;\n                    x += nUsedBlockWidth;\n                }\n\n                y += nUsedBlockHeight;\n            }\n        }\n    }\n    // cppcheck-suppress knownConditionTrueFalse\n    else if (FetchBuffer::bMinimizeIO && TIFFIsTiled(m_hTIFF) &&\n             m_nPlanarConfig == PLANARCONFIG_CONTIG && nBandCount > 1)\n    {\n        GByte *pabyData = static_cast<GByte *>(pData);\n        int anSrcYOffset[256] = {0};\n        for (int y = 0; y < nBufYSize;)\n        {\n            const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n            const int nSrcLine = static_cast<int>(dfYOffStart);\n            const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n            const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n            const int nBaseByteOffsetIm_nBlock =\n                nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n            int ychunk = 1;\n            int nLastSrcLineK = nSrcLine;\n            anSrcYOffset[0] = 0;\n            for (int k = 1; k < nBufYSize - y; ++k)\n            {\n                int nSrcLineK =\n                    nYOff + static_cast<int>((y + k + 0.5) * dfSrcYInc);\n                const int nBlockYOffK = nSrcLineK / m_nBlockYSize;\n                if (k < 256)\n                    anSrcYOffset[k] =\n                        ((nSrcLineK % m_nBlockYSize) - nYOffsetIm_nBlock) *\n                        m_nBlockXSize * nBandsPerBlockDTSize;\n                if (nBlockYOffK != m_nBlockYOff)\n                {\n                    break;\n                }\n                ++ychunk;\n                nLastSrcLineK = nSrcLineK;\n            }\n            const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n            // CPLAssert(nUsedBlockHeight <= m_nBlockYSize);\n\n            double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n            int nCurBlockXOff = 0;\n            int nNextBlockXOff = 0;\n            toff_t nCurOffset = 0;\n            const GByte *pabyLocalSrcDataStartLine = nullptr;\n            for (int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc)\n            {\n                const int nSrcPixel = static_cast<int>(dfSrcX);\n                if (nSrcPixel >= nNextBlockXOff)\n                {\n                    const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                    nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                    nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                    const int nBlockId =\n                        poFirstBand->ComputeBlockId(nBlockXOff, m_nBlockYOff);\n                    nCurOffset = panOffsets[nBlockId];\n                    if (nCurOffset != 0)\n                    {\n                        pabyLocalSrcDataStartLine = oFetcher.FetchBytes(\n                            nCurOffset + nBaseByteOffsetIm_nBlock,\n                            m_nBlockXSize * nBandsPerBlock * nUsedBlockHeight,\n                            nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                        if (pabyLocalSrcDataStartLine == nullptr)\n                            return CE_Failure;\n                    }\n                }\n\n                if (nCurOffset == 0)\n                {\n                    REACHED(38);\n\n                    for (int k = 0; k < ychunk; ++k)\n                    {\n                        GByte *const pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for (int iBand = 0; iBand < nBandCount; ++iBand)\n                        {\n                            GDALCopyWords(&dfNoData, GDT_Float64, 0,\n                                          pabyLocalData + nBandSpace * iBand,\n                                          eBufType, 0, 1);\n                        }\n                    }\n                }\n                else\n                {\n                    const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                    double dfYOff = dfYOffStart;\n                    const GByte *const pabyLocalSrcDataK0 =\n                        pabyLocalSrcDataStartLine +\n                        nXOffsetInBlock * nBandsPerBlockDTSize;\n                    GByte *pabyLocalData =\n                        pabyData + y * nLineSpace + x * nPixelSpace;\n                    for (int k = 0; k < ychunk;\n                         ++k, pabyLocalData += nLineSpace)\n                    {\n                        const GByte *pabyLocalSrcData = nullptr;\n                        if (ychunk <= 256)\n                        {\n                            REACHED(39);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 + anSrcYOffset[k];\n                        }\n                        else\n                        {\n                            REACHED(40);\n                            const int nYOffsetIm_nBlockK =\n                                static_cast<int>(dfYOff) % m_nBlockYSize;\n                            // CPLAssert(\n                            //     nYOffsetIm_nBlockK - nYOffsetIm_nBlock <=\n                            //     nUsedBlockHeight);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (nYOffsetIm_nBlockK - nYOffsetIm_nBlock) *\n                                    m_nBlockXSize * nBandsPerBlockDTSize;\n                            dfYOff += dfSrcYInc;\n                        }\n\n                        if (bByteOnly)\n                        {\n                            REACHED(41);\n                            for (int iBand = 0; iBand < nBandCount; ++iBand)\n                            {\n                                GByte *pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte *pabyLocalSrcDataBand =\n                                    pabyLocalSrcData + (panBandMap[iBand] - 1);\n                                *pabyLocalDataBand = *pabyLocalSrcDataBand;\n                            }\n                        }\n                        else\n                        {\n                            REACHED(42);\n                            for (int iBand = 0; iBand < nBandCount; ++iBand)\n                            {\n                                GByte *pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte *pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand] - 1) * nDTSize;\n\n                                GDALCopyWords(pabyLocalSrcDataBand, eDataType,\n                                              0, pabyLocalDataBand, eBufType, 0,\n                                              1);\n                            }\n                        }\n                    }\n                }\n            }\n\n            y += ychunk;\n        }\n    }\n    // cppcheck-suppress knownConditionTrueFalse\n    else if (FetchBuffer::bMinimizeIO && TIFFIsTiled(m_hTIFF))\n    // && (m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for (int iBand = 0; iBand < nBandCount; ++iBand)\n        {\n            GByte *pabyData = static_cast<GByte *>(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            auto poCurBand =\n                cpl::down_cast<GTiffRasterBand *>(GetRasterBand(nBand));\n            int anSrcYOffset[256] = {0};\n            for (int y = 0; y < nBufYSize;)\n            {\n                const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n                const int nSrcLine = static_cast<int>(dfYOffStart);\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nBaseByteOffsetIm_nBlock =\n                    nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n                int ychunk = 1;\n                int nLastSrcLineK = nSrcLine;\n                anSrcYOffset[0] = 0;\n                for (int k = 1; k < nBufYSize - y; ++k)\n                {\n                    const int nSrcLineK =\n                        nYOff + static_cast<int>((y + k + 0.5) * dfSrcYInc);\n                    const int nBlockYOffK = nSrcLineK / m_nBlockYSize;\n                    if (k < 256)\n                        anSrcYOffset[k] =\n                            ((nSrcLineK % m_nBlockYSize) - nYOffsetIm_nBlock) *\n                            m_nBlockXSize * nBandsPerBlockDTSize;\n                    if (nBlockYOffK != m_nBlockYOff)\n                    {\n                        break;\n                    }\n                    ++ychunk;\n                    nLastSrcLineK = nSrcLineK;\n                }\n                const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n                // CPLAssert(nUsedBlockHeight <= m_nBlockYSize);\n\n                double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                int nCurBlockXOff = 0;\n                int nNextBlockXOff = 0;\n                toff_t nCurOffset = 0;\n                const GByte *pabyLocalSrcDataStartLine = nullptr;\n                for (int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc)\n                {\n                    int nSrcPixel = static_cast<int>(dfSrcX);\n                    if (nSrcPixel >= nNextBlockXOff)\n                    {\n                        const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                        nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                        nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                        const int nBlockId =\n                            poCurBand->ComputeBlockId(nBlockXOff, m_nBlockYOff);\n                        nCurOffset = panOffsets[nBlockId];\n                        if (nCurOffset != 0)\n                        {\n                            pabyLocalSrcDataStartLine = oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetIm_nBlock,\n                                m_nBlockXSize * nBandsPerBlock *\n                                    nUsedBlockHeight,\n                                nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                            if (pabyLocalSrcDataStartLine == nullptr)\n                                return CE_Failure;\n\n                            if (m_nPlanarConfig == PLANARCONFIG_CONTIG)\n                            {\n                                REACHED(45);\n                                pabyLocalSrcDataStartLine +=\n                                    (nBand - 1) * nDTSize;\n                            }\n                            else\n                            {\n                                REACHED(46);\n                            }\n                        }\n                    }\n\n                    if (nCurOffset == 0)\n                    {\n                        REACHED(47);\n\n                        for (int k = 0; k < ychunk; ++k)\n                        {\n                            GByte *const pabyLocalData = pabyData +\n                                                         (y + k) * nLineSpace +\n                                                         x * nPixelSpace;\n\n                            GDALCopyWords(&dfNoData, GDT_Float64, 0,\n                                          pabyLocalData, eBufType, 0, 1);\n                        }\n                    }\n                    else\n                    {\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                        double dfYOff = dfYOffStart;\n                        const GByte *const pabyLocalSrcDataK0 =\n                            pabyLocalSrcDataStartLine +\n                            nXOffsetInBlock * nBandsPerBlockDTSize;\n                        GByte *pabyLocalData =\n                            pabyData + y * nLineSpace + x * nPixelSpace;\n                        for (int k = 0; k < ychunk;\n                             ++k, pabyLocalData += nLineSpace)\n                        {\n                            const GByte *pabyLocalSrcData = nullptr;\n                            if (ychunk <= 256)\n                            {\n                                REACHED(48);\n                                pabyLocalSrcData =\n                                    pabyLocalSrcDataK0 + anSrcYOffset[k];\n                            }\n                            else\n                            {\n                                REACHED(49);\n                                const int nYOffsetIm_nBlockK =\n                                    static_cast<int>(dfYOff) % m_nBlockYSize;\n                                // CPLAssert(\n                                //     nYOffsetIm_nBlockK - nYOffsetIm_nBlock <=\n                                //     nUsedBlockHeight);\n                                pabyLocalSrcData =\n                                    pabyLocalSrcDataK0 +\n                                    (nYOffsetIm_nBlockK - nYOffsetIm_nBlock) *\n                                        m_nBlockXSize * nBandsPerBlockDTSize;\n                                dfYOff += dfSrcYInc;\n                            }\n\n                            if (bByteOnly)\n                            {\n                                REACHED(50);\n\n                                *pabyLocalData = *pabyLocalSrcData;\n                            }\n                            else\n                            {\n                                REACHED(51);\n\n                                GDALCopyWords(pabyLocalSrcData, eDataType, 0,\n                                              pabyLocalData, eBufType, 0, 1);\n                            }\n                        }\n                    }\n                }\n\n                y += ychunk;\n            }\n        }\n    }\n    else if (bUseContigImplementation)\n    {\n        // cppcheck-suppress knownConditionTrueFalse\n        if (!FetchBuffer::bMinimizeIO && TIFFIsTiled(m_hTIFF))\n        {\n            GByte *pabyData = static_cast<GByte *>(pData);\n            for (int y = 0; y < nBufYSize; ++y)\n            {\n                const int nSrcLine =\n                    nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int nBaseByteOffsetIm_nBlock =\n                    nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n\n                if (bNoXResampling)\n                {\n                    GByte *pabyLocalData = pabyData + y * nLineSpace;\n                    int nBlockXOff = nXOff / m_nBlockXSize;\n                    int nXOffsetInBlock = nXOff % m_nBlockXSize;\n                    int nBlockId =\n                        poFirstBand->ComputeBlockId(nBlockXOff, m_nBlockYOff);\n\n                    int x = 0;\n                    while (x < nBufXSize)\n                    {\n                        const int nByteOffsetIm_nBlock =\n                            nBaseByteOffsetIm_nBlock +\n                            nXOffsetInBlock * nBandsPerBlockDTSize;\n                        const toff_t nCurOffset = panOffsets[nBlockId];\n                        const int nUsedBlockWidth = std::min(\n                            m_nBlockXSize - nXOffsetInBlock, nBufXSize - x);\n\n                        int nIters = nUsedBlockWidth;\n                        if (nCurOffset == 0)\n                        {\n                            if (bByteNoXResampling)\n                            {\n                                REACHED(0);\n                                while (nIters-- > 0)\n                                {\n                                    for (int iBand = 0; iBand < nBandCount;\n                                         ++iBand)\n                                    {\n                                        pabyLocalData[iBand] = abyNoData;\n                                    }\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                            else\n                            {\n                                REACHED(1);\n                                while (nIters-- > 0)\n                                {\n                                    GDALCopyWords(&dfNoData, GDT_Float64, 0,\n                                                  pabyLocalData, eBufType,\n                                                  static_cast<int>(nBandSpace),\n                                                  nBandCount);\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if (bNoTypeChange && nBands == nBandCount &&\n                                nPixelSpace == nBandsPerBlockDTSize)\n                            {\n                                REACHED(2);\n                                if (!oFetcher.FetchBytes(\n                                        pabyLocalData,\n                                        nCurOffset + nByteOffsetIm_nBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId))\n                                {\n                                    return CE_Failure;\n                                }\n                                pabyLocalData +=\n                                    nIters * nBandsPerBlock * nDTSize;\n                            }\n                            else\n                            {\n                                const GByte *pabyLocalSrcData =\n                                    oFetcher.FetchBytes(\n                                        nCurOffset + nByteOffsetIm_nBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId);\n                                if (pabyLocalSrcData == nullptr)\n                                    return CE_Failure;\n                                if (bByteNoXResampling)\n                                {\n                                    REACHED(3);\n                                    CopyContigByteMultiBand(\n                                        pabyLocalSrcData, nBandsPerBlockDTSize,\n                                        pabyLocalData,\n                                        static_cast<int>(nPixelSpace), nIters,\n                                        nBandCount);\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    REACHED(4);\n                                    while (nIters-- > 0)\n                                    {\n                                        GDALCopyWords(\n                                            pabyLocalSrcData, eDataType,\n                                            nDTSize, pabyLocalData, eBufType,\n                                            static_cast<int>(nBandSpace),\n                                            nBandCount);\n                                        pabyLocalSrcData +=\n                                            nBandsPerBlockDTSize;\n                                        pabyLocalData += nPixelSpace;\n                                    }\n                                }\n                            }\n                        }\n\n                        nXOffsetInBlock = 0;\n                        ++nBlockXOff;\n                        ++nBlockId;\n                        x += nUsedBlockWidth;\n                    }\n                }\n                else  // Contig, tiled, potential resampling & data type change.\n                {\n                    const GByte *pabyLocalSrcDataStartLine = nullptr;\n                    GByte *pabyLocalData = pabyData + y * nLineSpace;\n                    double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                    int nCurBlockXOff = 0;\n                    int nNextBlockXOff = 0;\n                    toff_t nCurOffset = 0;\n                    for (int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc)\n                    {\n                        int nSrcPixel = static_cast<int>(dfSrcX);\n                        if (nSrcPixel >= nNextBlockXOff)\n                        {\n                            const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                            nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                            nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                            const int nBlockId = poFirstBand->ComputeBlockId(\n                                nBlockXOff, m_nBlockYOff);\n                            nCurOffset = panOffsets[nBlockId];\n                            if (nCurOffset != 0)\n                            {\n                                pabyLocalSrcDataStartLine = oFetcher.FetchBytes(\n                                    nCurOffset + nBaseByteOffsetIm_nBlock,\n                                    m_nBlockXSize * nBandsPerBlock, nDTSize,\n                                    bIsByteSwapped, bIsComplex, nBlockId);\n                                if (pabyLocalSrcDataStartLine == nullptr)\n                                    return CE_Failure;\n                            }\n                        }\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n\n                        if (nCurOffset == 0)\n                        {\n                            REACHED(5);\n                            GDALCopyWords(&dfNoData, GDT_Float64, 0,\n                                          pabyLocalData, eBufType,\n                                          static_cast<int>(nBandSpace),\n                                          nBandCount);\n                            pabyLocalData += nPixelSpace;\n                        }\n                        else\n                        {\n                            const GByte *pabyLocalSrcData =\n                                pabyLocalSrcDataStartLine +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                            REACHED(6);\n                            if (bByteOnly)\n                            {\n                                for (int iBand = 0; iBand < nBands; ++iBand)\n                                    pabyLocalData[iBand] =\n                                        pabyLocalSrcData[iBand];\n                            }\n                            else\n                            {\n                                GDALCopyWords(pabyLocalSrcData, eDataType,\n                                              nDTSize, pabyLocalData, eBufType,\n                                              static_cast<int>(nBandSpace),\n                                              nBandCount);\n                            }\n                            pabyLocalData += nPixelSpace;\n                        }\n                    }\n                }\n            }\n        }\n        else  // Contig, striped organized.\n        {\n            GByte *pabyData = static_cast<GByte *>(pData);\n            for (int y = 0; y < nBufYSize; ++y)\n            {\n                const int nSrcLine =\n                    nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int nBlockId = m_nBlockYOff;\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                if (nCurOffset == 0)\n                {\n                    REACHED(7);\n                    for (int x = 0; x < nBufXSize; ++x)\n                    {\n                        GDALCopyWords(\n                            &dfNoData, GDT_Float64, 0,\n                            pabyData + y * nLineSpace + x * nPixelSpace,\n                            eBufType, static_cast<int>(nBandSpace), nBandCount);\n                    }\n                }\n                else\n                {\n                    GByte *pabyLocalData = pabyData + y * nLineSpace;\n                    const int nBaseByteOffsetIm_nBlock =\n                        (nYOffsetIm_nBlock * m_nBlockXSize + nXOff) *\n                        nBandsPerBlockDTSize;\n\n                    if (bNoXResamplingNoTypeChange && nBands == nBandCount &&\n                        nPixelSpace == nBandsPerBlockDTSize)\n                    {\n                        REACHED(8);\n                        if (!oFetcher.FetchBytes(\n                                pabyLocalData,\n                                nCurOffset + nBaseByteOffsetIm_nBlock,\n                                nXSize * nBandsPerBlock, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId))\n                        {\n                            return CE_Failure;\n                        }\n                    }\n                    else\n                    {\n                        const GByte *pabyLocalSrcData = oFetcher.FetchBytes(\n                            nCurOffset + nBaseByteOffsetIm_nBlock,\n                            nXSize * nBandsPerBlock, nDTSize, bIsByteSwapped,\n                            bIsComplex, nBlockId);\n                        if (pabyLocalSrcData == nullptr)\n                            return CE_Failure;\n\n                        if (bByteNoXResampling)\n                        {\n                            REACHED(9);\n                            CopyContigByteMultiBand(\n                                pabyLocalSrcData, nBandsPerBlockDTSize,\n                                pabyLocalData, static_cast<int>(nPixelSpace),\n                                nBufXSize, nBandCount);\n                        }\n                        else if (bByteOnly)\n                        {\n                            REACHED(10);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for (int x = 0; x < nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc)\n                            {\n                                const int nSrcPixelMinusXOff =\n                                    static_cast<int>(dfSrcX);\n                                for (int iBand = 0; iBand < nBandCount; ++iBand)\n                                {\n                                    pabyLocalData[x * nPixelSpace + iBand] =\n                                        pabyLocalSrcData\n                                            [nSrcPixelMinusXOff *\n                                                 nBandsPerBlockDTSize +\n                                             iBand];\n                                }\n                            }\n                        }\n                        else\n                        {\n                            REACHED(11);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for (int x = 0; x < nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc)\n                            {\n                                int nSrcPixelMinusXOff =\n                                    static_cast<int>(dfSrcX);\n                                GDALCopyWords(\n                                    pabyLocalSrcData + nSrcPixelMinusXOff *\n                                                           nBandsPerBlockDTSize,\n                                    eDataType, nDTSize,\n                                    pabyLocalData + x * nPixelSpace, eBufType,\n                                    static_cast<int>(nBandSpace), nBandCount);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else  // Non-contig reading case.\n    {\n        // cppcheck-suppress knownConditionTrueFalse\n        if (!FetchBuffer::bMinimizeIO && TIFFIsTiled(m_hTIFF))\n        {\n            for (int iBand = 0; iBand < nBandCount; ++iBand)\n            {\n                const int nBand = panBandMap[iBand];\n                auto poCurBand =\n                    cpl::down_cast<GTiffRasterBand *>(GetRasterBand(nBand));\n                GByte *const pabyData =\n                    static_cast<GByte *>(pData) + iBand * nBandSpace;\n                for (int y = 0; y < nBufYSize; ++y)\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                    const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                    const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n\n                    int nBaseByteOffsetIm_nBlock = nYOffsetIm_nBlock *\n                                                   m_nBlockXSize *\n                                                   nBandsPerBlockDTSize;\n                    if (m_nPlanarConfig == PLANARCONFIG_CONTIG)\n                    {\n                        REACHED(12);\n                        nBaseByteOffsetIm_nBlock += (nBand - 1) * nDTSize;\n                    }\n                    else\n                    {\n                        REACHED(13);\n                    }\n\n                    if (bNoXResampling)\n                    {\n                        GByte *pabyLocalData = pabyData + y * nLineSpace;\n                        int nBlockXOff = nXOff / m_nBlockXSize;\n                        int nBlockId =\n                            poCurBand->ComputeBlockId(nBlockXOff, m_nBlockYOff);\n                        int nXOffsetInBlock = nXOff % m_nBlockXSize;\n\n                        int x = 0;\n                        while (x < nBufXSize)\n                        {\n                            const int nByteOffsetIm_nBlock =\n                                nBaseByteOffsetIm_nBlock +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n                            const toff_t nCurOffset = panOffsets[nBlockId];\n                            const int nUsedBlockWidth = std::min(\n                                m_nBlockXSize - nXOffsetInBlock, nBufXSize - x);\n                            int nIters = nUsedBlockWidth;\n\n                            if (nCurOffset == 0)\n                            {\n                                REACHED(16);\n                                GDALCopyWords(&dfNoData, GDT_Float64, 0,\n                                              pabyLocalData, eBufType,\n                                              static_cast<int>(nPixelSpace),\n                                              nIters);\n                                pabyLocalData += nIters * nPixelSpace;\n                            }\n                            else\n                            {\n                                if (bNoTypeChange &&\n                                    nPixelSpace == nBandsPerBlockDTSize)\n                                {\n                                    REACHED(17);\n                                    if (!oFetcher.FetchBytes(\n                                            pabyLocalData,\n                                            nCurOffset + nByteOffsetIm_nBlock,\n                                            (nIters - 1) * nBandsPerBlock + 1,\n                                            nDTSize, bIsByteSwapped, bIsComplex,\n                                            nBlockId))\n                                    {\n                                        return CE_Failure;\n                                    }\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    const GByte *pabyLocalSrcData =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset + nByteOffsetIm_nBlock,\n                                            (nIters - 1) * nBandsPerBlock + 1,\n                                            nDTSize, bIsByteSwapped, bIsComplex,\n                                            nBlockId);\n                                    if (pabyLocalSrcData == nullptr)\n                                        return CE_Failure;\n\n                                    REACHED(18);\n                                    GDALCopyWords(pabyLocalSrcData, eDataType,\n                                                  nBandsPerBlockDTSize,\n                                                  pabyLocalData, eBufType,\n                                                  static_cast<int>(nPixelSpace),\n                                                  nIters);\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                            }\n\n                            nXOffsetInBlock = 0;\n                            ++nBlockXOff;\n                            ++nBlockId;\n                            x += nUsedBlockWidth;\n                        }\n                    }\n                    else\n                    {\n                        // Non-contig reading, tiled, potential resampling and\n                        // data type change.\n\n                        const GByte *pabyLocalSrcDataStartLine = nullptr;\n                        GByte *pabyLocalData = pabyData + y * nLineSpace;\n                        double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                        int nCurBlockXOff = 0;\n                        int nNextBlockXOff = 0;\n                        toff_t nCurOffset = 0;\n                        for (int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc)\n                        {\n                            const int nSrcPixel = static_cast<int>(dfSrcX);\n                            if (nSrcPixel >= nNextBlockXOff)\n                            {\n                                const int nBlockXOff =\n                                    nSrcPixel / m_nBlockXSize;\n                                nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                                nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                                const int nBlockId = poCurBand->ComputeBlockId(\n                                    nBlockXOff, m_nBlockYOff);\n                                nCurOffset = panOffsets[nBlockId];\n                                if (nCurOffset != 0)\n                                {\n                                    pabyLocalSrcDataStartLine =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset +\n                                                nBaseByteOffsetIm_nBlock,\n                                            m_nBlockXSize * nBandsPerBlock,\n                                            nDTSize, bIsByteSwapped, bIsComplex,\n                                            nBlockId);\n                                    if (pabyLocalSrcDataStartLine == nullptr)\n                                        return CE_Failure;\n                                }\n                            }\n                            const int nXOffsetInBlock =\n                                nSrcPixel - nCurBlockXOff;\n\n                            if (nCurOffset == 0)\n                            {\n                                REACHED(21);\n                                GDALCopyWords(&dfNoData, GDT_Float64, 0,\n                                              pabyLocalData, eBufType, 0, 1);\n                                pabyLocalData += nPixelSpace;\n                            }\n                            else\n                            {\n                                const GByte *pabyLocalSrcData =\n                                    pabyLocalSrcDataStartLine +\n                                    nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                                REACHED(22);\n                                if (bByteOnly)\n                                {\n                                    *pabyLocalData = *pabyLocalSrcData;\n                                }\n                                else\n                                {\n                                    GDALCopyWords(pabyLocalSrcData, eDataType,\n                                                  0, pabyLocalData, eBufType, 0,\n                                                  1);\n                                }\n                                pabyLocalData += nPixelSpace;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else  // Non-contig reading, striped.\n        {\n            for (int iBand = 0; iBand < nBandCount; ++iBand)\n            {\n                const int nBand = panBandMap[iBand];\n                GByte *pabyData =\n                    static_cast<GByte *>(pData) + iBand * nBandSpace;\n                for (int y = 0; y < nBufYSize; ++y)\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                    const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                    const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                    int nBlockId = m_nBlockYOff;\n                    if (m_nPlanarConfig == PLANARCONFIG_SEPARATE)\n                    {\n                        REACHED(23);\n                        nBlockId += m_nBlocksPerBand * (nBand - 1);\n                    }\n                    else\n                    {\n                        REACHED(24);\n                    }\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    if (nCurOffset == 0)\n                    {\n                        REACHED(25);\n                        GDALCopyWords(&dfNoData, GDT_Float64, 0,\n                                      pabyData + y * nLineSpace, eBufType,\n                                      static_cast<int>(nPixelSpace), nBufXSize);\n                    }\n                    else\n                    {\n                        int nBaseByteOffsetIm_nBlock =\n                            (nYOffsetIm_nBlock * m_nBlockXSize + nXOff) *\n                            nBandsPerBlockDTSize;\n                        if (m_nPlanarConfig == PLANARCONFIG_CONTIG)\n                            nBaseByteOffsetIm_nBlock += (nBand - 1) * nDTSize;\n\n                        GByte *pabyLocalData = pabyData + y * nLineSpace;\n                        if (bNoXResamplingNoTypeChange &&\n                            nPixelSpace == nBandsPerBlockDTSize)\n                        {\n                            REACHED(26);\n                            if (!oFetcher.FetchBytes(\n                                    pabyLocalData,\n                                    nCurOffset + nBaseByteOffsetIm_nBlock,\n                                    (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                    bIsByteSwapped, bIsComplex, nBlockId))\n                            {\n                                return CE_Failure;\n                            }\n                        }\n                        else\n                        {\n                            const GByte *pabyLocalSrcData = oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetIm_nBlock,\n                                (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId);\n                            if (pabyLocalSrcData == nullptr)\n                                return CE_Failure;\n\n                            if (bNoXResamplingNoTypeChange)\n                            {\n                                REACHED(27);\n                                GDALCopyWords(pabyLocalSrcData, eDataType,\n                                              nBandsPerBlockDTSize,\n                                              pabyLocalData, eBufType,\n                                              static_cast<int>(nPixelSpace),\n                                              nBufXSize);\n                            }\n                            else if (bByteOnly)\n                            {\n                                REACHED(28);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for (int x = 0; x < nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc)\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast<int>(dfSrcX);\n                                    pabyLocalData[x * nPixelSpace] =\n                                        pabyLocalSrcData[nSrcPixelMinusXOff *\n                                                         nBandsPerBlockDTSize];\n                                }\n                            }\n                            else\n                            {\n                                REACHED(29);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for (int x = 0; x < nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc)\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast<int>(dfSrcX);\n                                    GDALCopyWords(pabyLocalSrcData +\n                                                      nSrcPixelMinusXOff *\n                                                          nBandsPerBlockDTSize,\n                                                  eDataType, 0,\n                                                  pabyLocalData +\n                                                      x * nPixelSpace,\n                                                  eBufType, 0, 1);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return CE_None;\n}",
    "int GTiffDataset::DirectIO(GDALRWFlag eRWFlag, int nXOff, int nYOff, int nXSize,\n                           int nYSize, void *pData, int nBufXSize,\n                           int nBufYSize, GDALDataType eBufType, int nBandCount,\n                           const int *panBandMap, GSpacing nPixelSpace,\n                           GSpacing nLineSpace, GSpacing nBandSpace,\n                           GDALRasterIOExtraArg *psExtraArg)\n{\n    auto poProtoBand = cpl::down_cast<GTiffRasterBand *>(papoBands[0]);\n    const GDALDataType eDataType = poProtoBand->GetRasterDataType();\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if (!(eRWFlag == GF_Read && m_nCompression == COMPRESSION_NONE &&\n          (m_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           m_nPhotometric == PHOTOMETRIC_RGB ||\n           m_nPhotometric == PHOTOMETRIC_PALETTE) &&\n          poProtoBand->IsBaseGTiffClass()))\n    {\n        return -1;\n    }\n    Crystalize();\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if ((nXSize != nBufXSize || nYSize != nBufYSize) && psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour)\n    {\n        return -1;\n    }\n\n    // If the file is band interleave or only one band is requested, then\n    // fallback to band DirectIO.\n    bool bUseBandRasterIO = false;\n    if (m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1)\n    {\n        bUseBandRasterIO = true;\n    }\n    else\n    {\n        // For simplicity, only deals with \"naturally ordered\" bands.\n        for (int iBand = 0; iBand < nBandCount; ++iBand)\n        {\n            if (panBandMap[iBand] != iBand + 1)\n            {\n                bUseBandRasterIO = true;\n                break;\n            }\n        }\n    }\n    if (bUseBandRasterIO)\n    {\n        CPLErr eErr = CE_None;\n        for (int iBand = 0; eErr == CE_None && iBand < nBandCount; ++iBand)\n        {\n            eErr =\n                GetRasterBand(panBandMap[iBand])\n                    ->RasterIO(eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                               static_cast<GByte *>(pData) + iBand * nBandSpace,\n                               nBufXSize, nBufYSize, eBufType, nPixelSpace,\n                               nLineSpace, psExtraArg);\n        }\n        return eErr;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug(\"GTiff\", \"DirectIO(%d,%d,%d,%d -> %dx%d)\", nXOff, nYOff, nXSize,\n             nYSize, nBufXSize, nBufYSize);\n#endif\n\n    // No need to look if overviews can satisfy the request as it has already */\n    // been done in GTiffDataset::IRasterIO().\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if (eAccess == GA_Update)\n    {\n        FlushCache(false);\n        VSI_TIFFFlushBufferedWrite(TIFFClientdata(m_hTIFF));\n    }\n\n    if (TIFFIsTiled(m_hTIFF))\n    {\n        const int nDTSize = nDTSizeBits / 8;\n        const size_t nTempBufferForCommonDirectIOSize = static_cast<size_t>(\n            static_cast<GPtrDiff_t>(m_nBlockXSize) * m_nBlockYSize * nDTSize *\n            ((m_nPlanarConfig == PLANARCONFIG_CONTIG) ? nBands : 1));\n        if (m_pTempBufferForCommonDirectIO == nullptr)\n        {\n            m_pTempBufferForCommonDirectIO = static_cast<GByte *>(\n                VSI_MALLOC_VERBOSE(nTempBufferForCommonDirectIOSize));\n            if (m_pTempBufferForCommonDirectIO == nullptr)\n                return CE_Failure;\n        }\n\n        VSILFILE *fp = VSI_TIFFGetVSILFile(TIFFClientdata(m_hTIFF));\n        FetchBufferDirectIO oFetcher(fp, m_pTempBufferForCommonDirectIO,\n                                     nTempBufferForCommonDirectIOSize);\n\n        return CommonDirectIOClassic(oFetcher, nXOff, nYOff, nXSize, nYSize,\n                                     pData, nBufXSize, nBufYSize, eBufType,\n                                     nBandCount, panBandMap, nPixelSpace,\n                                     nLineSpace, nBandSpace);\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets) ||\n        panTIFFOffsets == nullptr)\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    void **ppData =\n        static_cast<void **>(VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void *)));\n    vsi_l_offset *panOffsets = static_cast<vsi_l_offset *>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)));\n    size_t *panSizes =\n        static_cast<size_t *>(VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)));\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void *pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands = nBands;\n    const int nSrcPixelSize = nDTSize * nContigBands;\n\n    if (ppData == nullptr || panOffsets == nullptr || panSizes == nullptr)\n    {\n        eErr = CE_Failure;\n    }\n    // For now we always allocate a temp buffer as it is easier.\n    else\n    // if( nXSize != nBufXSize || nYSize != nBufYSize ||\n    //   eBufType != eDataType ||\n    //   nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n    //   check if the user buffer is large enough )\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC3_VERBOSE(nReqXSize, nReqYSize, nSrcPixelSize);\n        if (pTmpBuffer == nullptr)\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast<double>(nBufYSize);\n\n    for (int iLine = 0; eErr == CE_None && iLine < nReqYSize; ++iLine)\n    {\n        ppData[iLine] = static_cast<GByte *>(pTmpBuffer) +\n                        static_cast<size_t>(iLine) * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if (nBufYSize < nYSize)  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast<int>((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / m_nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % m_nBlockYSize;\n        const int nBlockId =\n            poProtoBand->ComputeBlockId(nBlockXOff, nBlockYOff);\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if (panOffsets[iLine] == 0)  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff +\n             static_cast<vsi_l_offset>(nYOffsetInBlock) * m_nBlockXSize) *\n            nSrcPixelSize;\n        panSizes[iLine] = static_cast<size_t>(nReqXSize) * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if (eErr == CE_None)\n    {\n        VSILFILE *fp = VSI_TIFFGetVSILFile(TIFFClientdata(m_hTIFF));\n        const int nRet =\n            VSIFReadMultiRangeL(nReqYSize, ppData, panOffsets, panSizes, fp);\n        if (nRet != 0)\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if (eErr == CE_None && TIFFIsByteSwapped(m_hTIFF))\n    {\n        for (int iLine = 0; iLine < nReqYSize; ++iLine)\n        {\n            if (GDALDataTypeIsComplex(eDataType))\n                GDALSwapWords(ppData[iLine], nDTSize / 2,\n                              2 * nReqXSize * nContigBands, nDTSize / 2);\n            else\n                GDALSwapWords(ppData[iLine], nDTSize, nReqXSize * nContigBands,\n                              nDTSize);\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast<double>(nBufXSize);\n    if (eErr == CE_None && pTmpBuffer != nullptr)\n    {\n        for (int iY = 0; iY < nBufYSize; ++iY)\n        {\n            const int iSrcY = nBufYSize <= nYSize\n                                  ? iY\n                                  : static_cast<int>((iY + 0.5) * dfSrcYInc);\n            // Optimization: no resampling, no data type change, number of\n            // bands requested == number of bands and buffer is packed\n            // pixel-interleaved.\n            if (nBufXSize == nXSize && nContigBands == nBandCount &&\n                eDataType == eBufType && nBandSpace == nDTSize &&\n                nPixelSpace == nBandCount * nBandSpace)\n            {\n                memcpy(static_cast<GByte *>(pData) + iY * nLineSpace,\n                       ppData[iSrcY],\n                       static_cast<size_t>(nReqXSize * nPixelSpace));\n            }\n            // Other optimization: no resampling, no data type change,\n            // data type is Byte/Int8.\n            else if (nBufXSize == nXSize && eDataType == eBufType &&\n                     (eDataType == GDT_Byte || eDataType == GDT_Int8))\n            {\n                GByte *pabySrcData = static_cast<GByte *>(ppData[iSrcY]);\n                GByte *pabyDstData =\n                    static_cast<GByte *>(pData) + iY * nLineSpace;\n                if (nBandSpace == 1 && nPixelSpace > nBandCount)\n                {\n                    // Buffer is pixel-interleaved (with some stridding\n                    // between pixels).\n                    CopyContigByteMultiBand(\n                        pabySrcData, nSrcPixelSize, pabyDstData,\n                        static_cast<int>(nPixelSpace), nBufXSize, nBandCount);\n                }\n                else\n                {\n                    for (int iBand = 0; iBand < nBandCount; ++iBand)\n                    {\n                        GDALCopyWords(\n                            pabySrcData + iBand, GDT_Byte, nSrcPixelSize,\n                            pabyDstData + iBand * nBandSpace, GDT_Byte,\n                            static_cast<int>(nPixelSpace), nBufXSize);\n                    }\n                }\n            }\n            else  // General case.\n            {\n                for (int iBand = 0; iBand < nBandCount; ++iBand)\n                {\n                    GByte *pabySrcData =\n                        static_cast<GByte *>(ppData[iSrcY]) + iBand * nDTSize;\n                    GByte *pabyDstData = static_cast<GByte *>(pData) +\n                                         iBand * nBandSpace + iY * nLineSpace;\n                    if ((eDataType == GDT_Byte && eBufType == GDT_Byte) ||\n                        (eDataType == GDT_Int8 && eBufType == GDT_Int8))\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for (int iX = 0; iX < nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast<int>(dfSrcX);\n                            pabyDstData[iX * nPixelSpace] =\n                                pabySrcData[iSrcX * nSrcPixelSize];\n                        }\n                    }\n                    else\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for (int iX = 0; iX < nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast<int>(dfSrcX);\n                            GDALCopyWords(pabySrcData + iSrcX * nSrcPixelSize,\n                                          eDataType, 0,\n                                          pabyDstData + iX * nPixelSpace,\n                                          eBufType, 0, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}",
    "GDALDataset *GTiffDataset::Open(GDALOpenInfo *poOpenInfo)\n\n{\n    const char *pszFilename = poOpenInfo->pszFilename;\n\n    /* -------------------------------------------------------------------- */\n    /*      Check if it looks like a TIFF file.                             */\n    /* -------------------------------------------------------------------- */\n    if (!Identify(poOpenInfo))\n        return nullptr;\n\n    bool bAllowRGBAInterface = true;\n    if (STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\"))\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      We have a special hook for handling opening a specific          */\n    /*      directory of a TIFF file.                                       */\n    /* -------------------------------------------------------------------- */\n    if (STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\"))\n        return OpenDir(poOpenInfo);\n\n    GTiffOneTimeInit();\n\n    /* -------------------------------------------------------------------- */\n    /*      Try opening the dataset.                                        */\n    /* -------------------------------------------------------------------- */\n    bool bStreaming = false;\n    const char *pszReadStreaming =\n        CPLGetConfigOption(\"TIFF_READ_STREAMING\", nullptr);\n    if (poOpenInfo->fpL == nullptr)\n    {\n        poOpenInfo->fpL = VSIFOpenL(\n            pszFilename, poOpenInfo->eAccess == GA_ReadOnly ? \"rb\" : \"r+b\");\n        if (poOpenInfo->fpL == nullptr)\n            return nullptr;\n    }\n    else if (!(pszReadStreaming && !CPLTestBool(pszReadStreaming)) &&\n             poOpenInfo->nHeaderBytes >= 24 &&\n             // A pipe has no seeking capability, so its position is 0 despite\n             // having read bytes.\n             (static_cast<int>(VSIFTellL(poOpenInfo->fpL)) ==\n                  poOpenInfo->nHeaderBytes ||\n              strcmp(pszFilename, \"/vsistdin/\") == 0 ||\n              // STARTS_WITH(pszFilename, \"/vsicurl_streaming/\") ||\n              (pszReadStreaming && CPLTestBool(pszReadStreaming))))\n    {\n        bStreaming = true;\n        if (!GTIFFMakeBufferedStream(poOpenInfo))\n            return nullptr;\n    }\n\n    // Store errors/warnings and emit them later.\n    TIFF *l_hTIFF;\n    CPLErrorAccumulator oErrorAccumulator;\n    {\n        auto oAccumulator = oErrorAccumulator.InstallForCurrentScope();\n        CPL_IGNORE_RET_VAL(oAccumulator);\n        CPLSetCurrentErrorHandlerCatchDebug(FALSE);\n        const bool bDeferStrileLoading = CPLTestBool(\n            CPLGetConfigOption(\"GTIFF_USE_DEFER_STRILE_LOADING\", \"YES\"));\n        l_hTIFF = VSI_TIFFOpen(\n            pszFilename,\n            poOpenInfo->eAccess == GA_ReadOnly\n                ? ((bStreaming || !bDeferStrileLoading) ? \"rC\" : \"rDOC\")\n                : (!bDeferStrileLoading ? \"r+C\" : \"r+DC\"),\n            poOpenInfo->fpL);\n    };\n\n    // Now emit errors and change their criticality if needed\n    // We only emit failures if we didn't manage to open the file.\n    // Otherwise it makes Python bindings unhappy (#5616).\n    for (const auto &oError : oErrorAccumulator.GetErrors())\n    {\n        ReportError(pszFilename,\n                    (l_hTIFF == nullptr && oError.type == CE_Failure)\n                        ? CE_Failure\n                        : CE_Warning,\n                    oError.no, \"%s\", oError.msg.c_str());\n    }\n\n    if (l_hTIFF == nullptr)\n        return nullptr;\n\n    uint32_t nXSize = 0;\n    TIFFGetField(l_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize);\n    uint32_t nYSize = 0;\n    TIFFGetField(l_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize);\n\n    if (nXSize > INT_MAX || nYSize > INT_MAX)\n    {\n        // GDAL only supports signed 32bit dimensions.\n        ReportError(pszFilename, CE_Failure, CPLE_NotSupported,\n                    \"Too large image size: %u x %u\", nXSize, nYSize);\n        XTIFFClose(l_hTIFF);\n        return nullptr;\n    }\n\n    uint16_t l_nCompression = 0;\n    if (!TIFFGetField(l_hTIFF, TIFFTAG_COMPRESSION, &(l_nCompression)))\n        l_nCompression = COMPRESSION_NONE;\n\n    /* -------------------------------------------------------------------- */\n    /*      Create a corresponding GDALDataset.                             */\n    /* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription(pszFilename);\n    poDS->m_pszFilename = CPLStrdup(pszFilename);\n    poDS->m_fpL = poOpenInfo->fpL;\n    poOpenInfo->fpL = nullptr;\n    poDS->m_bStreamingIn = bStreaming;\n    poDS->m_nCompression = l_nCompression;\n\n    // Check structural metadata (for COG)\n    const int nOffsetOfStructuralMetadata =\n        poOpenInfo->nHeaderBytes && ((poOpenInfo->pabyHeader[2] == 0x2B ||\n                                      poOpenInfo->pabyHeader[3] == 0x2B))\n            ? 16\n            : 8;\n    if (poOpenInfo->nHeaderBytes >\n            nOffsetOfStructuralMetadata +\n                static_cast<int>(strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\")) &&\n        memcmp(poOpenInfo->pabyHeader + nOffsetOfStructuralMetadata,\n               \"GDAL_STRUCTURAL_METADATA_SIZE=\",\n               strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\")) == 0)\n    {\n        const char *pszStructuralMD = reinterpret_cast<const char *>(\n            poOpenInfo->pabyHeader + nOffsetOfStructuralMetadata);\n        poDS->m_bLayoutIFDSBeforeData =\n            strstr(pszStructuralMD, \"LAYOUT=IFDS_BEFORE_DATA\") != nullptr;\n        poDS->m_bBlockOrderRowMajor =\n            strstr(pszStructuralMD, \"BLOCK_ORDER=ROW_MAJOR\") != nullptr;\n        poDS->m_bLeaderSizeAsUInt4 =\n            strstr(pszStructuralMD, \"BLOCK_LEADER=SIZE_AS_UINT4\") != nullptr &&\n            (strstr(pszStructuralMD, \"INTERLEAVE=\") == nullptr ||\n             strstr(pszStructuralMD, \"INTERLEAVE=BAND\") != nullptr ||\n             strstr(pszStructuralMD, \"INTERLEAVE=TILE\") != nullptr);\n        poDS->m_bTrailerRepeatedLast4BytesRepeated =\n            strstr(pszStructuralMD, \"BLOCK_TRAILER=LAST_4_BYTES_REPEATED\") !=\n                nullptr &&\n            (strstr(pszStructuralMD, \"INTERLEAVE=\") == nullptr ||\n             strstr(pszStructuralMD, \"INTERLEAVE=BAND\") != nullptr ||\n             strstr(pszStructuralMD, \"INTERLEAVE=TILE\") != nullptr);\n        poDS->m_bMaskInterleavedWithImagery =\n            strstr(pszStructuralMD, \"MASK_INTERLEAVED_WITH_IMAGERY=YES\") !=\n                nullptr &&\n            strstr(pszStructuralMD, \"INTERLEAVE=\") == nullptr;\n        poDS->m_bKnownIncompatibleEdition =\n            strstr(pszStructuralMD, \"KNOWN_INCOMPATIBLE_EDITION=YES\") !=\n            nullptr;\n        if (poDS->m_bKnownIncompatibleEdition)\n        {\n            poDS->ReportError(\n                CE_Warning, CPLE_AppDefined,\n                \"This file used to have optimizations in its layout, \"\n                \"but those have been, at least partly, invalidated by \"\n                \"later changes\");\n        }\n        else if (poDS->m_bLayoutIFDSBeforeData && poDS->m_bBlockOrderRowMajor &&\n                 poDS->m_bLeaderSizeAsUInt4 &&\n                 poDS->m_bTrailerRepeatedLast4BytesRepeated)\n        {\n            if (poOpenInfo->eAccess == GA_Update &&\n                !CPLTestBool(CSLFetchNameValueDef(poOpenInfo->papszOpenOptions,\n                                                  \"IGNORE_COG_LAYOUT_BREAK\",\n                                                  \"FALSE\")))\n            {\n                CPLError(CE_Failure, CPLE_AppDefined,\n                         \"File %s has C(loud) O(ptimized) G(eoTIFF) layout. \"\n                         \"Updating it will generally result in losing part of \"\n                         \"the optimizations (but will still produce a valid \"\n                         \"GeoTIFF file). If this is acceptable, open the file \"\n                         \"with the IGNORE_COG_LAYOUT_BREAK open option set \"\n                         \"to YES.\",\n                         pszFilename);\n                XTIFFClose(l_hTIFF);\n                delete poDS;\n                return nullptr;\n            }\n            poDS->m_oGTiffMDMD.SetMetadataItem(\"LAYOUT\", \"COG\",\n                                               \"IMAGE_STRUCTURE\");\n        }\n    }\n\n    // In the case of GDAL_DISABLE_READDIR_ON_OPEN = NO / EMPTY_DIR\n    if (poOpenInfo->AreSiblingFilesLoaded() &&\n        CSLCount(poOpenInfo->GetSiblingFiles()) <= 1)\n    {\n        poDS->oOvManager.TransferSiblingFiles(\n            CSLDuplicate(poOpenInfo->GetSiblingFiles()));\n        poDS->m_bHasGotSiblingFiles = true;\n    }\n\n    // Should be capped by 257, to avoid 65535 / m_nColorTableMultiplier to overflow 255\n    poDS->m_nColorTableMultiplier = std::max(\n        0, std::min(257,\n                    atoi(CSLFetchNameValueDef(poOpenInfo->papszOpenOptions,\n                                              \"COLOR_TABLE_MULTIPLIER\", \"0\"))));\n\n    if (poDS->OpenOffset(l_hTIFF, TIFFCurrentDirOffset(l_hTIFF),\n                         poOpenInfo->eAccess, bAllowRGBAInterface,\n                         true) != CE_None)\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    // Do we want blocks that are set to zero and that haven't yet being\n    // allocated as tile/strip to remain implicit?\n    if (CPLFetchBool(poOpenInfo->papszOpenOptions, \"SPARSE_OK\", false))\n        poDS->m_bWriteEmptyTiles = false;\n\n    poDS->InitCreationOrOpenOptions(poOpenInfo->eAccess == GA_Update,\n                                    poOpenInfo->papszOpenOptions);\n\n    poDS->m_bLoadPam = true;\n    poDS->m_bColorProfileMetadataChanged = false;\n    poDS->m_bMetadataChanged = false;\n    poDS->m_bGeoTIFFInfoChanged = false;\n    poDS->m_bNoDataChanged = false;\n    poDS->m_bForceUnsetGTOrGCPs = false;\n    poDS->m_bForceUnsetProjection = false;\n\n    // Used by GTIFFBuildOverviewsEx() for the COG driver\n    const char *pszMaskOverviewDS = CSLFetchNameValue(\n        poOpenInfo->papszOpenOptions, \"MASK_OVERVIEW_DATASET\");\n    if (pszMaskOverviewDS)\n    {\n        poDS->m_poMaskExtOvrDS.reset(GDALDataset::Open(\n            pszMaskOverviewDS, GDAL_OF_RASTER | GDAL_OF_INTERNAL));\n        if (!poDS->m_poMaskExtOvrDS || !poDS->AssociateExternalMask())\n        {\n            CPLDebug(\"GTiff\",\n                     \"Association with external mask overview file failed\");\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Initialize info for external overviews.                         */\n    /* -------------------------------------------------------------------- */\n    poDS->oOvManager.Initialize(poDS, poOpenInfo, pszFilename);\n\n    // For backward compatibility, in case GTIFF_POINT_GEO_IGNORE is defined\n    // load georeferencing right now so as to not require it to be defined\n    // at the GetGeoTransform() time.\n    if (CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\", nullptr) != nullptr)\n    {\n        poDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    return poDS;\n}",
    "void GTiffDataset::LoadICCProfile()\n{\n    if (m_bICCMetadataLoaded)\n        return;\n    m_bICCMetadataLoaded = true;\n\n    uint32_t nEmbedLen = 0;\n    uint8_t *pEmbedBuffer = nullptr;\n\n    if (TIFFGetField(m_hTIFF, TIFFTAG_ICCPROFILE, &nEmbedLen, &pEmbedBuffer))\n    {\n        char *pszBase64Profile = CPLBase64Encode(\n            nEmbedLen, reinterpret_cast<const GByte *>(pEmbedBuffer));\n\n        m_oGTiffMDMD.SetMetadataItem(\"SOURCE_ICC_PROFILE\", pszBase64Profile,\n                                     \"COLOR_PROFILE\");\n\n        CPLFree(pszBase64Profile);\n\n        return;\n    }\n\n    // Check for colorimetric tiff.\n    float *pCHR = nullptr;\n    float *pWP = nullptr;\n    uint16_t *pTFR = nullptr;\n    uint16_t *pTFG = nullptr;\n    uint16_t *pTFB = nullptr;\n    uint16_t *pTransferRange = nullptr;\n\n    if (TIFFGetField(m_hTIFF, TIFFTAG_PRIMARYCHROMATICITIES, &pCHR))\n    {\n        if (TIFFGetField(m_hTIFF, TIFFTAG_WHITEPOINT, &pWP))\n        {\n            if (m_nBitsPerSample > 24 ||\n                !TIFFGetFieldDefaulted(m_hTIFF, TIFFTAG_TRANSFERFUNCTION, &pTFR,\n                                       &pTFG, &pTFB) ||\n                pTFR == nullptr || pTFG == nullptr || pTFB == nullptr)\n            {\n                return;\n            }\n\n            const int TIFFTAG_TRANSFERRANGE = 0x0156;\n            TIFFGetFieldDefaulted(m_hTIFF, TIFFTAG_TRANSFERRANGE,\n                                  &pTransferRange);\n\n            // Set all the colorimetric metadata.\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_RED\",\n                CPLString().Printf(\"%.9f, %.9f, 1.0\",\n                                   static_cast<double>(pCHR[0]),\n                                   static_cast<double>(pCHR[1])),\n                \"COLOR_PROFILE\");\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_GREEN\",\n                CPLString().Printf(\"%.9f, %.9f, 1.0\",\n                                   static_cast<double>(pCHR[2]),\n                                   static_cast<double>(pCHR[3])),\n                \"COLOR_PROFILE\");\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_BLUE\",\n                CPLString().Printf(\"%.9f, %.9f, 1.0\",\n                                   static_cast<double>(pCHR[4]),\n                                   static_cast<double>(pCHR[5])),\n                \"COLOR_PROFILE\");\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_WHITEPOINT\",\n                CPLString().Printf(\"%.9f, %.9f, 1.0\",\n                                   static_cast<double>(pWP[0]),\n                                   static_cast<double>(pWP[1])),\n                \"COLOR_PROFILE\");\n\n            // Set transfer function metadata.\n\n            // Get length of table.\n            const uint32_t nTransferFunctionLength = 1 << m_nBitsPerSample;\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_RED\",\n                ConvertTransferFunctionToString(pTFR, nTransferFunctionLength),\n                \"COLOR_PROFILE\");\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n                ConvertTransferFunctionToString(pTFG, nTransferFunctionLength),\n                \"COLOR_PROFILE\");\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n                ConvertTransferFunctionToString(pTFB, nTransferFunctionLength),\n                \"COLOR_PROFILE\");\n\n            // Set transfer range.\n            if (pTransferRange)\n            {\n                m_oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_BLACK\",\n                    CPLString().Printf(\"%d, %d, %d\",\n                                       static_cast<int>(pTransferRange[0]),\n                                       static_cast<int>(pTransferRange[2]),\n                                       static_cast<int>(pTransferRange[4])),\n                    \"COLOR_PROFILE\");\n                m_oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_WHITE\",\n                    CPLString().Printf(\"%d, %d, %d\",\n                                       static_cast<int>(pTransferRange[1]),\n                                       static_cast<int>(pTransferRange[3]),\n                                       static_cast<int>(pTransferRange[5])),\n                    \"COLOR_PROFILE\");\n            }\n        }\n    }\n}",
    "CPLErr GTiffDataset::OpenOffset(TIFF *hTIFFIn, toff_t nDirOffsetIn,\n                                GDALAccess eAccessIn, bool bAllowRGBAInterface,\n                                bool bReadGeoTransform)\n\n{\n    if (!hTIFFIn)\n        return CE_Failure;\n\n    eAccess = eAccessIn;\n\n    m_hTIFF = hTIFFIn;\n\n    m_nDirOffset = nDirOffsetIn;\n\n    if (!SetDirectory())\n        return CE_Failure;\n\n    /* -------------------------------------------------------------------- */\n    /*      Capture some information from the file that is of interest.     */\n    /* -------------------------------------------------------------------- */\n    uint32_t nXSize = 0;\n    uint32_t nYSize = 0;\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize);\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize);\n\n    // Unlikely to occur, but could happen on a disk full situation.\n    if (nXSize == 0 || nYSize == 0)\n        return CE_Failure;\n\n    if (nXSize > INT_MAX || nYSize > INT_MAX)\n    {\n        // GDAL only supports signed 32bit dimensions.\n        ReportError(CE_Failure, CPLE_NotSupported,\n                    \"Too large image size: %u x %u\", nXSize, nYSize);\n        return CE_Failure;\n    }\n    nRasterXSize = nXSize;\n    nRasterYSize = nYSize;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &m_nSamplesPerPixel))\n        nBands = 1;\n    else\n        nBands = m_nSamplesPerPixel;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_BITSPERSAMPLE, &(m_nBitsPerSample)))\n        m_nBitsPerSample = 1;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PLANARCONFIG, &(m_nPlanarConfig)))\n        m_nPlanarConfig = PLANARCONFIG_CONTIG;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PHOTOMETRIC, &(m_nPhotometric)))\n        m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLEFORMAT, &(m_nSampleFormat)))\n        m_nSampleFormat = SAMPLEFORMAT_UINT;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_COMPRESSION, &(m_nCompression)))\n        m_nCompression = COMPRESSION_NONE;\n\n    if (m_nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(m_nCompression))\n    {\n        const char *pszCompressionMethodName =\n            GTIFFGetCompressionMethodName(m_nCompression);\n        if (pszCompressionMethodName)\n        {\n            ReportError(CE_Failure, CPLE_AppDefined,\n                        \"Cannot open TIFF file due to missing codec %s.\",\n                        pszCompressionMethodName);\n        }\n        else\n        {\n            ReportError(\n                CE_Failure, CPLE_AppDefined,\n                \"Cannot open TIFF file due to missing codec of code %d.\",\n                m_nCompression);\n        }\n        return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      YCbCr JPEG compressed images should be translated on the fly    */\n    /*      to RGB by libtiff/libjpeg unless specifically requested         */\n    /*      otherwise.                                                      */\n    /* -------------------------------------------------------------------- */\n    if (m_nCompression == COMPRESSION_JPEG &&\n        m_nPhotometric == PHOTOMETRIC_YCBCR &&\n        CPLTestBool(CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\")))\n    {\n        m_oGTiffMDMD.SetMetadataItem(\"SOURCE_COLOR_SPACE\", \"YCbCr\",\n                                     \"IMAGE_STRUCTURE\");\n        int nColorMode = 0;\n        if (!TIFFGetField(m_hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode) ||\n            nColorMode != JPEGCOLORMODE_RGB)\n        {\n            TIFFSetField(m_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Get strip/tile layout.                                          */\n    /* -------------------------------------------------------------------- */\n    if (TIFFIsTiled(m_hTIFF))\n    {\n        uint32_t l_nBlockXSize = 0;\n        uint32_t l_nBlockYSize = 0;\n        TIFFGetField(m_hTIFF, TIFFTAG_TILEWIDTH, &(l_nBlockXSize));\n        TIFFGetField(m_hTIFF, TIFFTAG_TILELENGTH, &(l_nBlockYSize));\n        if (l_nBlockXSize > INT_MAX || l_nBlockYSize > INT_MAX)\n        {\n            ReportError(CE_Failure, CPLE_NotSupported,\n                        \"Too large block size: %u x %u\", l_nBlockXSize,\n                        l_nBlockYSize);\n            return CE_Failure;\n        }\n        m_nBlockXSize = static_cast<int>(l_nBlockXSize);\n        m_nBlockYSize = static_cast<int>(l_nBlockYSize);\n    }\n    else\n    {\n        if (!TIFFGetField(m_hTIFF, TIFFTAG_ROWSPERSTRIP, &(m_nRowsPerStrip)))\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                        \"RowsPerStrip not defined ... assuming all one strip.\");\n            m_nRowsPerStrip = nYSize;  // Dummy value.\n        }\n\n        // If the rows per strip is larger than the file we will get\n        // confused.  libtiff internally will treat the rowsperstrip as\n        // the image height and it is best if we do too. (#4468)\n        if (m_nRowsPerStrip > static_cast<uint32_t>(nRasterYSize))\n            m_nRowsPerStrip = nRasterYSize;\n\n        m_nBlockXSize = nRasterXSize;\n        m_nBlockYSize = m_nRowsPerStrip;\n    }\n\n    if (!ComputeBlocksPerColRowAndBand(nBands))\n        return CE_Failure;\n\n    /* -------------------------------------------------------------------- */\n    /*      Should we handle this using the GTiffBitmapBand?                */\n    /* -------------------------------------------------------------------- */\n    bool bTreatAsBitmap = false;\n\n    if (m_nBitsPerSample == 1 && nBands == 1)\n    {\n        bTreatAsBitmap = true;\n\n        // Lets treat large \"one row\" bitmaps using the scanline api.\n        if (!TIFFIsTiled(m_hTIFF) && m_nBlockYSize == nRasterYSize &&\n            nRasterYSize > 2000\n            // libtiff does not support reading JBIG files with\n            // TIFFReadScanline().\n            && m_nCompression != COMPRESSION_JBIG)\n        {\n            m_bTreatAsSplitBitmap = true;\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Should we treat this via the RGBA interface?                    */\n    /* -------------------------------------------------------------------- */\n    bool bTreatAsRGBA = false;\n    if (\n#ifdef DEBUG\n        CPLTestBool(CPLGetConfigOption(\"GTIFF_FORCE_RGBA\", \"NO\")) ||\n#endif\n        (bAllowRGBAInterface && !bTreatAsBitmap && !(m_nBitsPerSample > 8) &&\n         (m_nPhotometric == PHOTOMETRIC_CIELAB ||\n          m_nPhotometric == PHOTOMETRIC_LOGL ||\n          m_nPhotometric == PHOTOMETRIC_LOGLUV ||\n          m_nPhotometric == PHOTOMETRIC_SEPARATED ||\n          (m_nPhotometric == PHOTOMETRIC_YCBCR &&\n           m_nCompression != COMPRESSION_JPEG))))\n    {\n        char szMessage[1024] = {};\n\n        if (TIFFRGBAImageOK(m_hTIFF, szMessage) == 1)\n        {\n            const char *pszSourceColorSpace = nullptr;\n            nBands = 4;\n            switch (m_nPhotometric)\n            {\n                case PHOTOMETRIC_CIELAB:\n                    pszSourceColorSpace = \"CIELAB\";\n                    break;\n                case PHOTOMETRIC_LOGL:\n                    pszSourceColorSpace = \"LOGL\";\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    pszSourceColorSpace = \"LOGLUV\";\n                    break;\n                case PHOTOMETRIC_SEPARATED:\n                    pszSourceColorSpace = \"CMYK\";\n                    break;\n                case PHOTOMETRIC_YCBCR:\n                    pszSourceColorSpace = \"YCbCr\";\n                    nBands = 3;  // probably true for other photometric values\n                    break;\n            }\n            if (pszSourceColorSpace)\n                m_oGTiffMDMD.SetMetadataItem(\"SOURCE_COLOR_SPACE\",\n                                             pszSourceColorSpace,\n                                             \"IMAGE_STRUCTURE\");\n            bTreatAsRGBA = true;\n        }\n        else\n        {\n            CPLDebug(\"GTiff\", \"TIFFRGBAImageOK says:\\n%s\", szMessage);\n        }\n    }\n\n    // libtiff has various issues with OJPEG compression and chunky-strip\n    // support with the \"classic\" scanline/strip/tile interfaces, and that\n    // wouldn't work either, so better bail out.\n    if (m_nCompression == COMPRESSION_OJPEG && !bTreatAsRGBA)\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Old-JPEG compression only supported through RGBA interface, \"\n            \"which cannot be used probably because the file is corrupted\");\n        return CE_Failure;\n    }\n\n    // If photometric is YCbCr, scanline/strip/tile interfaces assumes that\n    // we are ready with downsampled data. And we are not.\n    if (m_nCompression != COMPRESSION_JPEG &&\n        m_nCompression != COMPRESSION_OJPEG &&\n        m_nPhotometric == PHOTOMETRIC_YCBCR &&\n        m_nPlanarConfig == PLANARCONFIG_CONTIG && !bTreatAsRGBA)\n    {\n        uint16_t nF1, nF2;\n        TIFFGetFieldDefaulted(m_hTIFF, TIFFTAG_YCBCRSUBSAMPLING, &nF1, &nF2);\n        if (nF1 != 1 || nF2 != 1)\n        {\n            ReportError(CE_Failure, CPLE_AppDefined,\n                        \"Cannot open TIFF file with YCbCr, subsampling and \"\n                        \"BitsPerSample > 8 that is not JPEG compressed\");\n            return CE_Failure;\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Should we treat this via the split interface?                   */\n    /* -------------------------------------------------------------------- */\n    if (!TIFFIsTiled(m_hTIFF) && m_nBitsPerSample == 8 &&\n        m_nBlockYSize == nRasterYSize && nRasterYSize > 2000 && !bTreatAsRGBA &&\n        CPLTestBool(CPLGetConfigOption(\"GDAL_ENABLE_TIFF_SPLIT\", \"YES\")))\n    {\n        m_bTreatAsSplit = true;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Should we treat this via the odd bits interface?                */\n    /* -------------------------------------------------------------------- */\n    bool bTreatAsOdd = false;\n    if (m_nSampleFormat == SAMPLEFORMAT_IEEEFP)\n    {\n        if (m_nBitsPerSample == 16 || m_nBitsPerSample == 24)\n            bTreatAsOdd = true;\n        else if (m_nBitsPerSample != 32 && m_nBitsPerSample != 64)\n        {\n            ReportError(CE_Failure, CPLE_AppDefined,\n                        \"Cannot open TIFF file with SampleFormat=IEEEFP \"\n                        \"and BitsPerSample=%d\",\n                        m_nBitsPerSample);\n            return CE_Failure;\n        }\n    }\n    else if (!bTreatAsRGBA && !bTreatAsBitmap && m_nBitsPerSample != 8 &&\n             m_nBitsPerSample != 16 && m_nBitsPerSample != 32 &&\n             m_nBitsPerSample != 64 && m_nBitsPerSample != 128)\n    {\n        bTreatAsOdd = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We can't support 'chunks' bigger than 2GB on 32 bit builds      */\n/* -------------------------------------------------------------------- */\n#if SIZEOF_VOIDP == 4\n    uint64_t nChunkSize = 0;\n    if (m_bTreatAsSplit || m_bTreatAsSplitBitmap)\n    {\n        nChunkSize = TIFFScanlineSize64(m_hTIFF);\n    }\n    else\n    {\n        if (TIFFIsTiled(m_hTIFF))\n            nChunkSize = TIFFTileSize64(m_hTIFF);\n        else\n            nChunkSize = TIFFStripSize64(m_hTIFF);\n    }\n    if (bTreatAsRGBA)\n    {\n        nChunkSize =\n            std::max(nChunkSize,\n                     4 * static_cast<uint64_t>(m_nBlockXSize) * m_nBlockYSize);\n    }\n    if (nChunkSize > static_cast<uint64_t>(INT_MAX))\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                    \"Scanline/tile/strip size bigger than 2GB unsupported \"\n                    \"on 32-bit builds.\");\n        return CE_Failure;\n    }\n#endif\n\n    const bool bMinIsWhite = m_nPhotometric == PHOTOMETRIC_MINISWHITE;\n\n    /* -------------------------------------------------------------------- */\n    /*      Check for NODATA                                                */\n    /* -------------------------------------------------------------------- */\n    char *pszText = nullptr;\n    if (TIFFGetField(m_hTIFF, TIFFTAG_GDAL_NODATA, &pszText) &&\n        !EQUAL(pszText, \"\"))\n    {\n        if (m_nBitsPerSample > 32 && m_nBitsPerSample <= 64 &&\n            m_nSampleFormat == SAMPLEFORMAT_INT)\n        {\n            m_bNoDataSetAsInt64 = true;\n            m_nNoDataValueInt64 =\n                static_cast<int64_t>(std::strtoll(pszText, nullptr, 10));\n        }\n        else if (m_nBitsPerSample > 32 && m_nBitsPerSample <= 64 &&\n                 m_nSampleFormat == SAMPLEFORMAT_UINT)\n        {\n            m_bNoDataSetAsUInt64 = true;\n            m_nNoDataValueUInt64 =\n                static_cast<uint64_t>(std::strtoull(pszText, nullptr, 10));\n        }\n        else\n        {\n            m_bNoDataSet = true;\n            m_dfNoDataValue = CPLAtofM(pszText);\n            if (m_nBitsPerSample == 32 &&\n                m_nSampleFormat == SAMPLEFORMAT_IEEEFP)\n            {\n                m_dfNoDataValue =\n                    GDALAdjustNoDataCloseToFloatMax(m_dfNoDataValue);\n                m_dfNoDataValue = static_cast<float>(m_dfNoDataValue);\n            }\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Capture the color table if there is one.                        */\n    /* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if (bTreatAsRGBA || m_nBitsPerSample > 16 ||\n        TIFFGetField(m_hTIFF, TIFFTAG_COLORMAP, &panRed, &panGreen, &panBlue) ==\n            0)\n    {\n        // Build inverted palette if we have inverted photometric.\n        // Pixel values remains unchanged.  Avoid doing this for *deep*\n        // data types (per #1882)\n        if (m_nBitsPerSample <= 16 && m_nPhotometric == PHOTOMETRIC_MINISWHITE)\n        {\n            m_poColorTable = std::make_unique<GDALColorTable>();\n            const int nColorCount = 1 << m_nBitsPerSample;\n\n            for (int iColor = 0; iColor < nColorCount; ++iColor)\n            {\n                const short nValue = static_cast<short>(\n                    ((255 * (nColorCount - 1 - iColor)) / (nColorCount - 1)));\n                const GDALColorEntry oEntry = {nValue, nValue, nValue,\n                                               static_cast<short>(255)};\n                m_poColorTable->SetColorEntry(iColor, &oEntry);\n            }\n\n            m_nPhotometric = PHOTOMETRIC_PALETTE;\n        }\n        else\n        {\n            m_poColorTable.reset();\n        }\n    }\n    else\n    {\n        const int nColorCount = 1 << m_nBitsPerSample;\n        m_poColorTable = gdal::tiff_common::TIFFColorMapTagToColorTable(\n            panRed, panGreen, panBlue, nColorCount, m_nColorTableMultiplier,\n            DEFAULT_COLOR_TABLE_MULTIPLIER_257, m_bNoDataSet, m_dfNoDataValue);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Create band information objects.                                */\n    /* -------------------------------------------------------------------- */\n    for (int iBand = 0; iBand < nBands; ++iBand)\n    {\n        if (bTreatAsRGBA)\n            SetBand(iBand + 1, new GTiffRGBABand(this, iBand + 1));\n        else if (m_bTreatAsSplitBitmap)\n            SetBand(iBand + 1, new GTiffSplitBitmapBand(this, iBand + 1));\n        else if (m_bTreatAsSplit)\n            SetBand(iBand + 1, new GTiffSplitBand(this, iBand + 1));\n        else if (bTreatAsBitmap)\n            SetBand(iBand + 1, new GTiffBitmapBand(this, iBand + 1));\n        else if (bTreatAsOdd)\n            SetBand(iBand + 1, new GTiffOddBitsBand(this, iBand + 1));\n        else\n            SetBand(iBand + 1, new GTiffRasterBand(this, iBand + 1));\n    }\n\n    if (GetRasterBand(1)->GetRasterDataType() == GDT_Unknown)\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                    \"Unsupported TIFF configuration: BitsPerSample(=%d) and \"\n                    \"SampleType(=%d)\",\n                    m_nBitsPerSample, m_nSampleFormat);\n        return CE_Failure;\n    }\n\n    m_bReadGeoTransform = bReadGeoTransform;\n\n    /* -------------------------------------------------------------------- */\n    /*      Capture some other potentially interesting information.         */\n    /* -------------------------------------------------------------------- */\n    char szWorkMDI[200] = {};\n    uint16_t nShort = 0;\n\n    const auto *pasTIFFTags = GetTIFFTags();\n    for (size_t iTag = 0; pasTIFFTags[iTag].pszTagName; ++iTag)\n    {\n        if (pasTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING)\n        {\n            if (TIFFGetField(m_hTIFF, pasTIFFTags[iTag].nTagVal, &pszText))\n                m_oGTiffMDMD.SetMetadataItem(pasTIFFTags[iTag].pszTagName,\n                                             pszText);\n        }\n        else if (pasTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT)\n        {\n            float fVal = 0.0;\n            if (TIFFGetField(m_hTIFF, pasTIFFTags[iTag].nTagVal, &fVal))\n            {\n                CPLsnprintf(szWorkMDI, sizeof(szWorkMDI), \"%.8g\", fVal);\n                m_oGTiffMDMD.SetMetadataItem(pasTIFFTags[iTag].pszTagName,\n                                             szWorkMDI);\n            }\n        }\n        else if (pasTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT &&\n                 pasTIFFTags[iTag].nTagVal != TIFFTAG_RESOLUTIONUNIT)\n        {\n            if (TIFFGetField(m_hTIFF, pasTIFFTags[iTag].nTagVal, &nShort))\n            {\n                snprintf(szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort);\n                m_oGTiffMDMD.SetMetadataItem(pasTIFFTags[iTag].pszTagName,\n                                             szWorkMDI);\n            }\n        }\n        else if (pasTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING)\n        {\n            uint32_t nCount = 0;\n            if (TIFFGetField(m_hTIFF, pasTIFFTags[iTag].nTagVal, &nCount,\n                             &pszText))\n            {\n                std::string osStr;\n                osStr.assign(pszText, nCount);\n                m_oGTiffMDMD.SetMetadataItem(pasTIFFTags[iTag].pszTagName,\n                                             osStr.c_str());\n            }\n        }\n    }\n\n    if (TIFFGetField(m_hTIFF, TIFFTAG_RESOLUTIONUNIT, &nShort))\n    {\n        if (nShort == RESUNIT_NONE)\n            snprintf(szWorkMDI, sizeof(szWorkMDI), \"%d (unitless)\", nShort);\n        else if (nShort == RESUNIT_INCH)\n            snprintf(szWorkMDI, sizeof(szWorkMDI), \"%d (pixels/inch)\", nShort);\n        else if (nShort == RESUNIT_CENTIMETER)\n            snprintf(szWorkMDI, sizeof(szWorkMDI), \"%d (pixels/cm)\", nShort);\n        else\n            snprintf(szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort);\n        m_oGTiffMDMD.SetMetadataItem(\"TIFFTAG_RESOLUTIONUNIT\", szWorkMDI);\n    }\n\n    int nTagSize = 0;\n    void *pData = nullptr;\n    if (TIFFGetField(m_hTIFF, TIFFTAG_XMLPACKET, &nTagSize, &pData))\n    {\n        char *pszXMP = static_cast<char *>(VSI_MALLOC_VERBOSE(nTagSize + 1));\n        if (pszXMP)\n        {\n            memcpy(pszXMP, pData, nTagSize);\n            pszXMP[nTagSize] = '\\0';\n\n            char *apszMDList[2] = {pszXMP, nullptr};\n            m_oGTiffMDMD.SetMetadata(apszMDList, \"xml:XMP\");\n\n            CPLFree(pszXMP);\n        }\n    }\n\n    if (m_nCompression != COMPRESSION_NONE)\n    {\n        const char *pszCompressionMethodName =\n            GTIFFGetCompressionMethodName(m_nCompression);\n        if (pszCompressionMethodName)\n        {\n            m_oGTiffMDMD.SetMetadataItem(\n                \"COMPRESSION\", pszCompressionMethodName, \"IMAGE_STRUCTURE\");\n        }\n        else\n        {\n            CPLString oComp;\n            oComp.Printf(\"%d\", m_nCompression);\n            m_oGTiffMDMD.SetMetadataItem(\"COMPRESSION\", oComp.c_str());\n        }\n    }\n\n    if (m_nCompression == COMPRESSION_JPEG &&\n        m_nPhotometric == PHOTOMETRIC_YCBCR)\n    {\n        m_oGTiffMDMD.SetMetadataItem(\"COMPRESSION\", \"YCbCr JPEG\",\n                                     \"IMAGE_STRUCTURE\");\n    }\n    else if (m_nCompression == COMPRESSION_LERC)\n    {\n        uint32_t nLercParamCount = 0;\n        uint32_t *panLercParams = nullptr;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_LERC_PARAMETERS, &nLercParamCount,\n                         &panLercParams) &&\n            nLercParamCount == 2)\n        {\n            memcpy(m_anLercAddCompressionAndVersion, panLercParams,\n                   sizeof(m_anLercAddCompressionAndVersion));\n        }\n\n        uint32_t nAddVersion = LERC_ADD_COMPRESSION_NONE;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION, &nAddVersion) &&\n            nAddVersion != LERC_ADD_COMPRESSION_NONE)\n        {\n            if (nAddVersion == LERC_ADD_COMPRESSION_DEFLATE)\n            {\n                m_oGTiffMDMD.SetMetadataItem(\"COMPRESSION\", \"LERC_DEFLATE\",\n                                             \"IMAGE_STRUCTURE\");\n            }\n            else if (nAddVersion == LERC_ADD_COMPRESSION_ZSTD)\n            {\n                m_oGTiffMDMD.SetMetadataItem(\"COMPRESSION\", \"LERC_ZSTD\",\n                                             \"IMAGE_STRUCTURE\");\n            }\n        }\n        uint32_t nLercVersion = LERC_VERSION_2_4;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_LERC_VERSION, &nLercVersion))\n        {\n            if (nLercVersion == LERC_VERSION_2_4)\n            {\n                m_oGTiffMDMD.SetMetadataItem(\"LERC_VERSION\", \"2.4\",\n                                             \"IMAGE_STRUCTURE\");\n            }\n            else\n            {\n                ReportError(CE_Warning, CPLE_AppDefined,\n                            \"Unknown Lerc version: %d\", nLercVersion);\n            }\n        }\n    }\n\n    if (m_nPlanarConfig == PLANARCONFIG_CONTIG && nBands != 1)\n        m_oGTiffMDMD.SetMetadataItem(\"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\");\n    else\n        m_oGTiffMDMD.SetMetadataItem(\"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\");\n\n    if ((GetRasterBand(1)->GetRasterDataType() == GDT_Byte &&\n         m_nBitsPerSample != 8) ||\n        (GetRasterBand(1)->GetRasterDataType() == GDT_UInt16 &&\n         m_nBitsPerSample != 16) ||\n        ((GetRasterBand(1)->GetRasterDataType() == GDT_UInt32 ||\n          GetRasterBand(1)->GetRasterDataType() == GDT_Float32) &&\n         m_nBitsPerSample != 32))\n    {\n        for (int i = 0; i < nBands; ++i)\n            cpl::down_cast<GTiffRasterBand *>(GetRasterBand(i + 1))\n                ->m_oGTiffMDMD.SetMetadataItem(\n                    \"NBITS\",\n                    CPLString().Printf(\"%d\",\n                                       static_cast<int>(m_nBitsPerSample)),\n                    \"IMAGE_STRUCTURE\");\n    }\n\n    if (bMinIsWhite)\n        m_oGTiffMDMD.SetMetadataItem(\"MINISWHITE\", \"YES\", \"IMAGE_STRUCTURE\");\n\n    if (TIFFGetField(m_hTIFF, TIFFTAG_GDAL_METADATA, &pszText))\n    {\n        CPLXMLNode *psRoot = CPLParseXMLString(pszText);\n        const CPLXMLNode *psItem =\n            psRoot ? CPLGetXMLNode(psRoot, \"=GDALMetadata\") : nullptr;\n        if (psItem)\n            psItem = psItem->psChild;\n        bool bMaxZErrorFound = false;\n        bool bMaxZErrorOverviewFound = false;\n        for (; psItem != nullptr; psItem = psItem->psNext)\n        {\n\n            if (psItem->eType != CXT_Element ||\n                !EQUAL(psItem->pszValue, \"Item\"))\n                continue;\n\n            const char *pszKey = CPLGetXMLValue(psItem, \"name\", nullptr);\n            const char *pszValue = CPLGetXMLValue(psItem, nullptr, nullptr);\n            int nBand = atoi(CPLGetXMLValue(psItem, \"sample\", \"-1\"));\n            if (nBand < -1 || nBand > 65535)\n                continue;\n            nBand++;\n            const char *pszRole = CPLGetXMLValue(psItem, \"role\", \"\");\n            const char *pszDomain = CPLGetXMLValue(psItem, \"domain\", \"\");\n\n            if (pszKey == nullptr || pszValue == nullptr)\n                continue;\n            if (EQUAL(pszDomain, \"IMAGE_STRUCTURE\"))\n            {\n                if (EQUAL(pszKey, \"INTERLEAVE\"))\n                {\n                    if (EQUAL(pszValue, \"TILE\"))\n                    {\n                        m_bTileInterleave = true;\n                        m_oGTiffMDMD.SetMetadataItem(\"INTERLEAVE\", \"TILE\",\n                                                     \"IMAGE_STRUCTURE\");\n                    }\n                    else\n                    {\n                        CPLDebug(\"GTiff\",\n                                 \"Unhandled INTERLEAVE=%s found in \"\n                                 \"GDAL_METADATA tag\",\n                                 pszValue);\n                    }\n                }\n                else if (m_nCompression == COMPRESSION_WEBP &&\n                         EQUAL(pszKey, \"COMPRESSION_REVERSIBILITY\"))\n                {\n                    if (EQUAL(pszValue, \"LOSSLESS\"))\n                        m_bWebPLossless = true;\n                    else if (EQUAL(pszValue, \"LOSSY\"))\n                        m_bWebPLossless = false;\n                }\n                else if (m_nCompression == COMPRESSION_WEBP &&\n                         EQUAL(pszKey, \"WEBP_LEVEL\"))\n                {\n                    const int nLevel = atoi(pszValue);\n                    if (nLevel >= 1 && nLevel <= 100)\n                    {\n                        m_oGTiffMDMD.SetMetadataItem(\n                            \"COMPRESSION_REVERSIBILITY\", \"LOSSY\",\n                            \"IMAGE_STRUCTURE\");\n                        m_bWebPLossless = false;\n                        m_nWebPLevel = static_cast<signed char>(nLevel);\n                    }\n                }\n                else if (m_nCompression == COMPRESSION_LERC &&\n                         EQUAL(pszKey, \"MAX_Z_ERROR\"))\n                {\n                    bMaxZErrorFound = true;\n                    m_dfMaxZError = CPLAtof(pszValue);\n                }\n                else if (m_nCompression == COMPRESSION_LERC &&\n                         EQUAL(pszKey, \"MAX_Z_ERROR_OVERVIEW\"))\n                {\n                    bMaxZErrorOverviewFound = true;\n                    m_dfMaxZErrorOverview = CPLAtof(pszValue);\n                }\n#if HAVE_JXL\n                else if ((m_nCompression == COMPRESSION_JXL ||\n                          m_nCompression == COMPRESSION_JXL_DNG_1_7) &&\n                         EQUAL(pszKey, \"COMPRESSION_REVERSIBILITY\"))\n                {\n                    if (EQUAL(pszValue, \"LOSSLESS\"))\n                        m_bJXLLossless = true;\n                    else if (EQUAL(pszValue, \"LOSSY\"))\n                        m_bJXLLossless = false;\n                }\n                else if ((m_nCompression == COMPRESSION_JXL ||\n                          m_nCompression == COMPRESSION_JXL_DNG_1_7) &&\n                         EQUAL(pszKey, \"JXL_DISTANCE\"))\n                {\n                    const double dfVal = CPLAtof(pszValue);\n                    if (dfVal > 0 && dfVal <= 15)\n                    {\n                        m_oGTiffMDMD.SetMetadataItem(\n                            \"COMPRESSION_REVERSIBILITY\", \"LOSSY\",\n                            \"IMAGE_STRUCTURE\");\n                        m_bJXLLossless = false;\n                        m_fJXLDistance = static_cast<float>(dfVal);\n                    }\n                }\n                else if ((m_nCompression == COMPRESSION_JXL ||\n                          m_nCompression == COMPRESSION_JXL_DNG_1_7) &&\n                         EQUAL(pszKey, \"JXL_ALPHA_DISTANCE\"))\n                {\n                    const double dfVal = CPLAtof(pszValue);\n                    if (dfVal > 0 && dfVal <= 15)\n                    {\n                        m_oGTiffMDMD.SetMetadataItem(\n                            \"COMPRESSION_REVERSIBILITY\", \"LOSSY\",\n                            \"IMAGE_STRUCTURE\");\n                        m_fJXLAlphaDistance = static_cast<float>(dfVal);\n                    }\n                }\n                else if ((m_nCompression == COMPRESSION_JXL ||\n                          m_nCompression == COMPRESSION_JXL_DNG_1_7) &&\n                         EQUAL(pszKey, \"JXL_EFFORT\"))\n                {\n                    const int nEffort = atoi(pszValue);\n                    if (nEffort >= 1 && nEffort <= 9)\n                    {\n                        m_nJXLEffort = nEffort;\n                    }\n                }\n#endif\n                else\n                {\n                    continue;\n                }\n            }\n\n            bool bIsXML = false;\n\n            if (STARTS_WITH_CI(pszDomain, \"xml:\"))\n                bIsXML = TRUE;\n\n            // Note: this un-escaping should not normally be done, as the\n            // deserialization of the tree from XML also does it, so we end up\n            // width double XML escaping, but keep it for backward\n            // compatibility.\n            char *pszUnescapedValue =\n                CPLUnescapeString(pszValue, nullptr, CPLES_XML);\n            if (nBand == 0)\n            {\n                if (bIsXML)\n                {\n                    char *apszMD[2] = {pszUnescapedValue, nullptr};\n                    m_oGTiffMDMD.SetMetadata(apszMD, pszDomain);\n                }\n                else\n                {\n                    m_oGTiffMDMD.SetMetadataItem(pszKey, pszUnescapedValue,\n                                                 pszDomain);\n                }\n            }\n            else\n            {\n                GTiffRasterBand *poBand =\n                    cpl::down_cast<GTiffRasterBand *>(GetRasterBand(nBand));\n                if (poBand != nullptr)\n                {\n                    if (EQUAL(pszRole, \"scale\"))\n                    {\n                        poBand->m_bHaveOffsetScale = true;\n                        poBand->m_dfScale = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if (EQUAL(pszRole, \"offset\"))\n                    {\n                        poBand->m_bHaveOffsetScale = true;\n                        poBand->m_dfOffset = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if (EQUAL(pszRole, \"unittype\"))\n                    {\n                        poBand->m_osUnitType = pszUnescapedValue;\n                    }\n                    else if (EQUAL(pszRole, \"description\"))\n                    {\n                        poBand->m_osDescription = pszUnescapedValue;\n                    }\n                    else if (EQUAL(pszRole, \"colorinterp\"))\n                    {\n                        if (EQUAL(pszUnescapedValue, \"undefined\"))\n                            poBand->m_eBandInterp = GCI_Undefined;\n                        else\n                        {\n                            poBand->m_eBandInterp =\n                                GDALGetColorInterpretationByName(\n                                    pszUnescapedValue);\n                            if (poBand->m_eBandInterp == GCI_Undefined)\n                            {\n                                poBand->m_oGTiffMDMD.SetMetadataItem(\n                                    \"COLOR_INTERPRETATION\", pszUnescapedValue);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        if (bIsXML)\n                        {\n                            char *apszMD[2] = {pszUnescapedValue, nullptr};\n                            poBand->m_oGTiffMDMD.SetMetadata(apszMD, pszDomain);\n                        }\n                        else\n                        {\n                            poBand->m_oGTiffMDMD.SetMetadataItem(\n                                pszKey, pszUnescapedValue, pszDomain);\n                        }\n                    }\n                }\n            }\n            CPLFree(pszUnescapedValue);\n        }\n\n        if (bMaxZErrorFound && !bMaxZErrorOverviewFound)\n        {\n            m_dfMaxZErrorOverview = m_dfMaxZError;\n        }\n\n        CPLDestroyXMLNode(psRoot);\n    }",
    "void GTiffDataset::LoadGeoreferencingAndPamIfNeeded()\n\n{\n    if (!m_bReadGeoTransform && !m_bLoadPam)\n        return;\n\n    IdentifyAuthorizedGeoreferencingSources();\n\n    /* -------------------------------------------------------------------- */\n    /*      Get the transform or gcps from the GeoTIFF file.                */\n    /* -------------------------------------------------------------------- */\n    if (m_bReadGeoTransform)\n    {\n        m_bReadGeoTransform = false;\n\n        char *pszTabWKT = nullptr;\n        double *padfTiePoints = nullptr;\n        double *padfScale = nullptr;\n        double *padfMatrix = nullptr;\n        uint16_t nCount = 0;\n        bool bPixelIsPoint = false;\n        unsigned short nRasterType = 0;\n        bool bPointGeoIgnore = false;\n\n        std::set<signed char> aoSetPriorities;\n        if (m_nINTERNALGeorefSrcIndex >= 0)\n            aoSetPriorities.insert(m_nINTERNALGeorefSrcIndex);\n        if (m_nTABFILEGeorefSrcIndex >= 0)\n            aoSetPriorities.insert(m_nTABFILEGeorefSrcIndex);\n        if (m_nWORLDFILEGeorefSrcIndex >= 0)\n            aoSetPriorities.insert(m_nWORLDFILEGeorefSrcIndex);\n        for (const auto nIndex : aoSetPriorities)\n        {\n            if (m_nINTERNALGeorefSrcIndex == nIndex)\n            {\n                GTIF *psGTIF =\n                    GTiffDataset::GTIFNew(m_hTIFF);  // How expensive this is?\n\n                if (psGTIF)\n                {\n                    if (GDALGTIFKeyGetSHORT(psGTIF, GTRasterTypeGeoKey,\n                                            &nRasterType, 0, 1) == 1 &&\n                        nRasterType == static_cast<short>(RasterPixelIsPoint))\n                    {\n                        bPixelIsPoint = true;\n                        bPointGeoIgnore = CPLTestBool(CPLGetConfigOption(\n                            \"GTIFF_POINT_GEO_IGNORE\", \"FALSE\"));\n                    }\n\n                    GTIFFree(psGTIF);\n                }\n\n                m_adfGeoTransform[0] = 0.0;\n                m_adfGeoTransform[1] = 1.0;\n                m_adfGeoTransform[2] = 0.0;\n                m_adfGeoTransform[3] = 0.0;\n                m_adfGeoTransform[4] = 0.0;\n                m_adfGeoTransform[5] = 1.0;\n\n                uint16_t nCountScale = 0;\n                if (TIFFGetField(m_hTIFF, TIFFTAG_GEOPIXELSCALE, &nCountScale,\n                                 &padfScale) &&\n                    nCountScale >= 2 && padfScale[0] != 0.0 &&\n                    padfScale[1] != 0.0)\n                {\n                    m_adfGeoTransform[1] = padfScale[0];\n                    if (padfScale[1] < 0)\n                    {\n                        const char *pszOptionVal = CPLGetConfigOption(\n                            \"GTIFF_HONOUR_NEGATIVE_SCALEY\", nullptr);\n                        if (pszOptionVal == nullptr)\n                        {\n                            ReportError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"File with negative value for ScaleY in \"\n                                \"GeoPixelScale tag. This is rather \"\n                                \"unusual. GDAL, contrary to the GeoTIFF \"\n                                \"specification, assumes that the file \"\n                                \"was intended to be north-up, and will \"\n                                \"treat this file as if ScaleY was \"\n                                \"positive. You may override this behavior \"\n                                \"by setting the GTIFF_HONOUR_NEGATIVE_SCALEY \"\n                                \"configuration option to YES\");\n                            m_adfGeoTransform[5] = padfScale[1];\n                        }\n                        else if (CPLTestBool(pszOptionVal))\n                        {\n                            m_adfGeoTransform[5] = -padfScale[1];\n                        }\n                        else\n                        {\n                            m_adfGeoTransform[5] = padfScale[1];\n                        }\n                    }\n                    else\n                    {\n                        m_adfGeoTransform[5] = -padfScale[1];\n                    }\n\n                    if (TIFFGetField(m_hTIFF, TIFFTAG_GEOTIEPOINTS, &nCount,\n                                     &padfTiePoints) &&\n                        nCount >= 6)\n                    {\n                        m_adfGeoTransform[0] =\n                            padfTiePoints[3] -\n                            padfTiePoints[0] * m_adfGeoTransform[1];\n                        m_adfGeoTransform[3] =\n                            padfTiePoints[4] -\n                            padfTiePoints[1] * m_adfGeoTransform[5];\n\n                        if (bPixelIsPoint && !bPointGeoIgnore)\n                        {\n                            m_adfGeoTransform[0] -=\n                                (m_adfGeoTransform[1] * 0.5 +\n                                 m_adfGeoTransform[2] * 0.5);\n                            m_adfGeoTransform[3] -=\n                                (m_adfGeoTransform[4] * 0.5 +\n                                 m_adfGeoTransform[5] * 0.5);\n                        }\n\n                        m_bGeoTransformValid = true;\n                        m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                        if (nCountScale >= 3 && GetRasterCount() == 1 &&\n                            (padfScale[2] != 0.0 || padfTiePoints[2] != 0.0 ||\n                             padfTiePoints[5] != 0.0))\n                        {\n                            LookForProjection();\n                            if (!m_oSRS.IsEmpty() && m_oSRS.IsVertical())\n                            {\n                                /* modelTiePointTag = (pixel, line, z0, X, Y,\n                                 * Z0) */\n                                /* thus Z(some_point) = (z(some_point) - z0) *\n                                 * scaleZ + Z0 */\n                                /* equivalently written as */\n                                /* Z(some_point) = z(some_point) * scaleZ +\n                                 * offsetZ with */\n                                /* offsetZ = - z0 * scaleZ + Z0 */\n                                double dfScale = padfScale[2];\n                                double dfOffset = -padfTiePoints[2] * dfScale +\n                                                  padfTiePoints[5];\n                                GTiffRasterBand *poBand =\n                                    cpl::down_cast<GTiffRasterBand *>(\n                                        GetRasterBand(1));\n                                poBand->m_bHaveOffsetScale = true;\n                                poBand->m_dfScale = dfScale;\n                                poBand->m_dfOffset = dfOffset;\n                            }\n                        }\n                    }\n                }\n\n                else if (TIFFGetField(m_hTIFF, TIFFTAG_GEOTRANSMATRIX, &nCount,\n                                      &padfMatrix) &&\n                         nCount == 16)\n                {\n                    m_adfGeoTransform[0] = padfMatrix[3];\n                    m_adfGeoTransform[1] = padfMatrix[0];\n                    m_adfGeoTransform[2] = padfMatrix[1];\n                    m_adfGeoTransform[3] = padfMatrix[7];\n                    m_adfGeoTransform[4] = padfMatrix[4];\n                    m_adfGeoTransform[5] = padfMatrix[5];\n\n                    if (bPixelIsPoint && !bPointGeoIgnore)\n                    {\n                        m_adfGeoTransform[0] -= m_adfGeoTransform[1] * 0.5 +\n                                                m_adfGeoTransform[2] * 0.5;\n                        m_adfGeoTransform[3] -= m_adfGeoTransform[4] * 0.5 +\n                                                m_adfGeoTransform[5] * 0.5;\n                    }\n\n                    m_bGeoTransformValid = true;\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                }\n                if (m_bGeoTransformValid)\n                    break;\n            }\n\n            /* --------------------------------------------------------------------\n             */\n            /*      Otherwise try looking for a .tab, .tfw, .tifw or .wld file.\n             */\n            /* --------------------------------------------------------------------\n             */\n            if (m_nTABFILEGeorefSrcIndex == nIndex)\n            {\n                char *pszGeorefFilename = nullptr;\n\n                CSLConstList papszSiblingFiles = GetSiblingFiles();\n\n                // Begin with .tab since it can also have projection info.\n                int nGCPCount = 0;\n                GDAL_GCP *pasGCPList = nullptr;\n                const int bTabFileOK = GDALReadTabFile2(\n                    m_pszFilename, m_adfGeoTransform, &pszTabWKT, &nGCPCount,\n                    &pasGCPList, papszSiblingFiles, &pszGeorefFilename);\n\n                if (bTabFileOK)\n                {\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                    // if( pszTabWKT )\n                    // {\n                    //     m_nProjectionGeorefSrcIndex = nIndex;\n                    // }\n                    m_aoGCPs = gdal::GCP::fromC(pasGCPList, nGCPCount);\n                    if (m_aoGCPs.empty())\n                    {\n                        m_bGeoTransformValid = true;\n                    }\n                }\n\n                if (nGCPCount)\n                {\n                    GDALDeinitGCPs(nGCPCount, pasGCPList);\n                    CPLFree(pasGCPList);\n                }\n\n                if (pszGeorefFilename)\n                {\n                    CPLFree(m_pszGeorefFilename);\n                    m_pszGeorefFilename = pszGeorefFilename;\n                    pszGeorefFilename = nullptr;\n                }\n                if (m_bGeoTransformValid)\n                    break;\n            }\n\n            if (m_nWORLDFILEGeorefSrcIndex == nIndex)\n            {\n                char *pszGeorefFilename = nullptr;\n\n                CSLConstList papszSiblingFiles = GetSiblingFiles();\n\n                m_bGeoTransformValid = CPL_TO_BOOL(GDALReadWorldFile2(\n                    m_pszFilename, nullptr, m_adfGeoTransform,\n                    papszSiblingFiles, &pszGeorefFilename));\n\n                if (!m_bGeoTransformValid)\n                {\n                    m_bGeoTransformValid = CPL_TO_BOOL(GDALReadWorldFile2(\n                        m_pszFilename, \"wld\", m_adfGeoTransform,\n                        papszSiblingFiles, &pszGeorefFilename));\n                }\n                if (m_bGeoTransformValid)\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                if (pszGeorefFilename)\n                {\n                    CPLFree(m_pszGeorefFilename);\n                    m_pszGeorefFilename = pszGeorefFilename;\n                    pszGeorefFilename = nullptr;\n                }\n                if (m_bGeoTransformValid)\n                    break;\n            }\n        }\n\n        /* --------------------------------------------------------------------\n         */\n        /*      Check for GCPs. */\n        /* --------------------------------------------------------------------\n         */\n        if (m_nINTERNALGeorefSrcIndex >= 0 &&\n            TIFFGetField(m_hTIFF, TIFFTAG_GEOTIEPOINTS, &nCount,\n                         &padfTiePoints) &&\n            !m_bGeoTransformValid)\n        {\n            m_aoGCPs.clear();\n            const int nNewGCPCount = nCount / 6;\n            for (int iGCP = 0; iGCP < nNewGCPCount; ++iGCP)\n            {\n                m_aoGCPs.emplace_back(CPLSPrintf(\"%d\", iGCP + 1), \"\",\n                                      /* pixel = */ padfTiePoints[iGCP * 6 + 0],\n                                      /* line = */ padfTiePoints[iGCP * 6 + 1],\n                                      /* X = */ padfTiePoints[iGCP * 6 + 3],\n                                      /* Y = */ padfTiePoints[iGCP * 6 + 4],\n                                      /* Z = */ padfTiePoints[iGCP * 6 + 5]);\n\n                if (bPixelIsPoint && !bPointGeoIgnore)\n                {\n                    m_aoGCPs.back().Pixel() += 0.5;\n                    m_aoGCPs.back().Line() += 0.5;\n                }\n            }\n            m_nGeoTransformGeorefSrcIndex = m_nINTERNALGeorefSrcIndex;\n        }\n\n        /* --------------------------------------------------------------------\n         */\n        /*      Did we find a tab file?  If so we will use its coordinate */\n        /*      system and give it precedence. */\n        /* --------------------------------------------------------------------\n         */\n        if (pszTabWKT != nullptr && m_oSRS.IsEmpty())\n        {\n            m_oSRS.importFromWkt(pszTabWKT);\n            m_bLookedForProjection = true;\n        }\n\n        CPLFree(pszTabWKT);\n    }\n\n    if (m_bLoadPam && m_nPAMGeorefSrcIndex >= 0)\n    {\n        /* --------------------------------------------------------------------\n         */\n        /*      Initialize any PAM information. */\n        /* --------------------------------------------------------------------\n         */\n        CPLAssert(!m_bColorProfileMetadataChanged);\n        CPLAssert(!m_bMetadataChanged);\n        CPLAssert(!m_bGeoTIFFInfoChanged);\n        CPLAssert(!m_bNoDataChanged);\n\n        // We must absolutely unset m_bLoadPam now, otherwise calling\n        // GetFileList() on a .tif with a .aux will result in an (almost)\n        // endless sequence of calls.\n        m_bLoadPam = false;\n\n        TryLoadXML(GetSiblingFiles());\n        ApplyPamInfo();\n\n        m_bColorProfileMetadataChanged = false;\n        m_bMetadataChanged = false;\n        m_bGeoTIFFInfoChanged = false;\n        m_bNoDataChanged = false;\n    }\n    m_bLoadPam = false;\n}",
    "const char *GTiffDataset::GetMetadataItem(const char *pszName,\n                                          const char *pszDomain)\n\n{\n    if (pszDomain != nullptr && EQUAL(pszDomain, \"IMAGE_STRUCTURE\"))\n    {\n        if ((m_nCompression == COMPRESSION_WEBP ||\n             m_nCompression == COMPRESSION_JXL ||\n             m_nCompression == COMPRESSION_JXL_DNG_1_7) &&\n            EQUAL(pszName, \"COMPRESSION_REVERSIBILITY\") &&\n            m_oGTiffMDMD.GetMetadataItem(\"COMPRESSION_REVERSIBILITY\",\n                                         \"IMAGE_STRUCTURE\") == nullptr)\n        {\n            const char *pszDriverName =\n                m_nCompression == COMPRESSION_WEBP ? \"WEBP\" : \"JPEGXL\";\n            auto poTileDriver = GDALGetDriverByName(pszDriverName);\n            if (poTileDriver)\n            {\n                vsi_l_offset nOffset = 0;\n                vsi_l_offset nSize = 0;\n                IsBlockAvailable(0, &nOffset, &nSize, nullptr);\n                if (nSize > 0)\n                {\n                    const std::string osSubfile(\n                        CPLSPrintf(\"/vsisubfile/\" CPL_FRMT_GUIB \"_%d,%s\",\n                                   static_cast<GUIntBig>(nOffset),\n                                   static_cast<int>(std::min(\n                                       static_cast<vsi_l_offset>(1024), nSize)),\n                                   m_pszFilename));\n                    const char *const apszDrivers[] = {pszDriverName, nullptr};\n                    auto poWebPDataset =\n                        std::unique_ptr<GDALDataset>(GDALDataset::Open(\n                            osSubfile.c_str(), GDAL_OF_RASTER, apszDrivers));\n                    if (poWebPDataset)\n                    {\n                        const char *pszReversibility =\n                            poWebPDataset->GetMetadataItem(\n                                \"COMPRESSION_REVERSIBILITY\", \"IMAGE_STRUCTURE\");\n                        if (pszReversibility)\n                            m_oGTiffMDMD.SetMetadataItem(\n                                \"COMPRESSION_REVERSIBILITY\", pszReversibility,\n                                \"IMAGE_STRUCTURE\");\n                    }\n                }\n            }\n        }\n    }\n    else\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if (pszDomain != nullptr && EQUAL(pszDomain, \"ProxyOverviewRequest\"))\n    {\n        return GDALPamDataset::GetMetadataItem(pszName, pszDomain);\n    }\n    else if (pszDomain != nullptr && (EQUAL(pszDomain, MD_DOMAIN_RPC) ||\n                                      EQUAL(pszDomain, MD_DOMAIN_IMD) ||\n                                      EQUAL(pszDomain, MD_DOMAIN_IMAGERY)))\n    {\n        LoadMetadata();\n    }\n    else if (pszDomain != nullptr && EQUAL(pszDomain, \"SUBDATASETS\"))\n    {\n        ScanDirectories();\n    }\n    else if (pszDomain != nullptr && EQUAL(pszDomain, \"EXIF\"))\n    {\n        LoadEXIFMetadata();\n    }\n    else if (pszDomain != nullptr && EQUAL(pszDomain, \"COLOR_PROFILE\"))\n    {\n        LoadICCProfile();\n    }\n    else if ((pszDomain == nullptr || EQUAL(pszDomain, \"\")) &&\n             pszName != nullptr && EQUAL(pszName, GDALMD_AREA_OR_POINT))\n    {\n        LoadMDAreaOrPoint();  // To set GDALMD_AREA_OR_POINT.\n    }\n    else if (pszDomain != nullptr && EQUAL(pszDomain, \"_DEBUG_\") &&\n             pszName != nullptr)\n    {\n#ifdef DEBUG_REACHED_VIRTUAL_MEM_IO\n        if (EQUAL(pszName, \"UNREACHED_VIRTUALMEMIO_CODE_PATH\"))\n        {\n            CPLString osMissing;\n            for (int i = 0;\n                 i < static_cast<int>(CPL_ARRAYSIZE(anReachedVirtualMemIO));\n                 ++i)\n            {\n                if (!anReachedVirtualMemIO[i])\n                {\n                    if (!osMissing.empty())\n                        osMissing += \",\";\n                    osMissing += CPLSPrintf(\"%d\", i);\n                }\n            }\n            return (osMissing.size()) ? CPLSPrintf(\"%s\", osMissing.c_str())\n                                      : nullptr;\n        }\n        else\n#endif\n            if (EQUAL(pszName, \"TIFFTAG_EXTRASAMPLES\"))\n        {\n            CPLString osRet;\n            uint16_t *v = nullptr;\n            uint16_t count = 0;\n\n            if (TIFFGetField(m_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v))\n            {\n                for (int i = 0; i < static_cast<int>(count); ++i)\n                {\n                    if (i > 0)\n                        osRet += \",\";\n                    osRet += CPLSPrintf(\"%d\", v[i]);\n                }\n            }\n            return (osRet.size()) ? CPLSPrintf(\"%s\", osRet.c_str()) : nullptr;\n        }\n        else if (EQUAL(pszName, \"TIFFTAG_PHOTOMETRIC\"))\n        {\n            return CPLSPrintf(\"%d\", m_nPhotometric);\n        }\n\n        else if (EQUAL(pszName, \"TIFFTAG_GDAL_METADATA\"))\n        {\n            char *pszText = nullptr;\n            if (!TIFFGetField(m_hTIFF, TIFFTAG_GDAL_METADATA, &pszText))\n                return nullptr;\n\n            return pszText;\n        }\n        else if (EQUAL(pszName, \"HAS_USED_READ_ENCODED_API\"))\n        {\n            return m_bHasUsedReadEncodedAPI ? \"1\" : \"0\";\n        }\n        else if (EQUAL(pszName, \"WEBP_LOSSLESS\"))\n        {\n            return m_bWebPLossless ? \"1\" : \"0\";\n        }\n        else if (EQUAL(pszName, \"WEBP_LEVEL\"))\n        {\n            return CPLSPrintf(\"%d\", m_nWebPLevel);\n        }\n        else if (EQUAL(pszName, \"MAX_Z_ERROR\"))\n        {\n            return CPLSPrintf(\"%f\", m_dfMaxZError);\n        }\n        else if (EQUAL(pszName, \"MAX_Z_ERROR_OVERVIEW\"))\n        {\n            return CPLSPrintf(\"%f\", m_dfMaxZErrorOverview);\n        }\n#if HAVE_JXL\n        else if (EQUAL(pszName, \"JXL_LOSSLESS\"))\n        {\n            return m_bJXLLossless ? \"1\" : \"0\";\n        }\n        else if (EQUAL(pszName, \"JXL_DISTANCE\"))\n        {\n            return CPLSPrintf(\"%f\", m_fJXLDistance);\n        }\n        else if (EQUAL(pszName, \"JXL_ALPHA_DISTANCE\"))\n        {\n            return CPLSPrintf(\"%f\", m_fJXLAlphaDistance);\n        }\n        else if (EQUAL(pszName, \"JXL_EFFORT\"))\n        {\n            return CPLSPrintf(\"%u\", m_nJXLEffort);\n        }\n#endif\n        return nullptr;\n    }\n\n    else if (pszDomain != nullptr && EQUAL(pszDomain, \"TIFF\") &&\n             pszName != nullptr)\n    {\n        if (EQUAL(pszName, \"GDAL_STRUCTURAL_METADATA\"))\n        {\n            const auto nOffset = VSIFTellL(m_fpL);\n            VSIFSeekL(m_fpL, 0, SEEK_SET);\n            GByte abyData[1024];\n            size_t nRead = VSIFReadL(abyData, 1, sizeof(abyData) - 1, m_fpL);\n            abyData[nRead] = 0;\n            VSIFSeekL(m_fpL, nOffset, SEEK_SET);\n            if (nRead > 4)\n            {\n                const int nOffsetOfStructuralMetadata =\n                    (abyData[2] == 0x2B || abyData[3] == 0x2B) ? 16 : 8;\n                const int nSizePatternLen =\n                    static_cast<int>(strlen(\"XXXXXX bytes\\n\"));\n                if (nRead > nOffsetOfStructuralMetadata +\n                                strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\") +\n                                nSizePatternLen &&\n                    memcmp(abyData + nOffsetOfStructuralMetadata,\n                           \"GDAL_STRUCTURAL_METADATA_SIZE=\",\n                           strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\")) == 0)\n                {\n                    char *pszStructuralMD = reinterpret_cast<char *>(\n                        abyData + nOffsetOfStructuralMetadata);\n                    const int nLenMD =\n                        atoi(pszStructuralMD +\n                             strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\"));\n                    if (nOffsetOfStructuralMetadata +\n                            strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\") +\n                            nSizePatternLen + nLenMD <=\n                        nRead)\n                    {\n                        pszStructuralMD[strlen(\n                                            \"GDAL_STRUCTURAL_METADATA_SIZE=\") +\n                                        nSizePatternLen + nLenMD] = 0;\n                        return CPLSPrintf(\"%s\", pszStructuralMD);\n                    }\n                }\n            }\n            return nullptr;\n        }\n    }\n\n    return m_oGTiffMDMD.GetMetadataItem(pszName, pszDomain);\n}",
    "void GTiffDataset::LoadEXIFMetadata()\n{\n    if (m_bEXIFMetadataLoaded)\n        return;\n    m_bEXIFMetadataLoaded = true;\n\n    VSILFILE *fp = VSI_TIFFGetVSILFile(TIFFClientdata(m_hTIFF));\n\n    GByte abyHeader[2] = {0};\n    if (VSIFSeekL(fp, 0, SEEK_SET) != 0 || VSIFReadL(abyHeader, 1, 2, fp) != 2)\n        return;\n\n    const bool bLittleEndian = abyHeader[0] == 'I' && abyHeader[1] == 'I';\n    const bool bLeastSignificantBit = CPL_IS_LSB != 0;\n    const bool bSwabflag = bLittleEndian != bLeastSignificantBit;  // != is XOR.\n\n    char **papszMetadata = nullptr;\n    toff_t nOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n\n    if (TIFFGetField(m_hTIFF, TIFFTAG_EXIFIFD, &nOffset))\n    {\n        int nExifOffset = static_cast<int>(nOffset);\n        int nInterOffset = 0;\n        int nGPSOffset = 0;\n        EXIFExtractMetadata(papszMetadata, fp, static_cast<int>(nOffset),\n                            bSwabflag, 0, nExifOffset, nInterOffset,\n                            nGPSOffset);\n    }\n\n    if (TIFFGetField(m_hTIFF, TIFFTAG_GPSIFD, &nOffset))\n    {\n        int nExifOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n        int nInterOffset = 0;\n        int nGPSOffset = static_cast<int>(nOffset);\n        EXIFExtractMetadata(papszMetadata, fp, static_cast<int>(nOffset),\n                            bSwabflag, 0, nExifOffset, nInterOffset,\n                            nGPSOffset);\n    }\n\n    if (papszMetadata)\n    {\n        m_oGTiffMDMD.SetMetadata(papszMetadata, \"EXIF\");\n        CSLDestroy(papszMetadata);\n    }\n}",
    "CPLErr GTiffDataset::FillEmptyTiles()\n\n{\n    /* -------------------------------------------------------------------- */\n    /*      How many blocks are there in this file?                         */\n    /* -------------------------------------------------------------------- */\n    const int nBlockCount = m_nPlanarConfig == PLANARCONFIG_SEPARATE\n                                ? m_nBlocksPerBand * nBands\n                                : m_nBlocksPerBand;\n\n    /* -------------------------------------------------------------------- */\n    /*      Fetch block maps.                                               */\n    /* -------------------------------------------------------------------- */\n    toff_t *panByteCounts = nullptr;\n\n    if (TIFFIsTiled(m_hTIFF))\n        TIFFGetField(m_hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts);\n    else\n        TIFFGetField(m_hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts);\n\n    if (panByteCounts == nullptr)\n    {\n        // Got here with libtiff 3.9.3 and tiff_write_8 test.\n        ReportError(CE_Failure, CPLE_AppDefined,\n                    \"FillEmptyTiles() failed because panByteCounts == NULL\");\n        return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Prepare a blank data buffer to write for uninitialized blocks.  */\n    /* -------------------------------------------------------------------- */\n    const GPtrDiff_t nBlockBytes =\n        TIFFIsTiled(m_hTIFF) ? static_cast<GPtrDiff_t>(TIFFTileSize(m_hTIFF))\n                             : static_cast<GPtrDiff_t>(TIFFStripSize(m_hTIFF));\n\n    GByte *pabyData = static_cast<GByte *>(VSI_CALLOC_VERBOSE(nBlockBytes, 1));\n    if (pabyData == nullptr)\n    {\n        return CE_Failure;\n    }\n\n    // Force tiles completely filled with the nodata value to be written.\n    m_bWriteEmptyTiles = true;\n\n    /* -------------------------------------------------------------------- */\n    /*      If set, fill data buffer with no data value.                    */\n    /* -------------------------------------------------------------------- */\n    if ((m_bNoDataSet && m_dfNoDataValue != 0.0) ||\n        (m_bNoDataSetAsInt64 && m_nNoDataValueInt64 != 0) ||\n        (m_bNoDataSetAsUInt64 && m_nNoDataValueUInt64 != 0))\n    {\n        const GDALDataType eDataType = GetRasterBand(1)->GetRasterDataType();\n        const int nDataTypeSize = GDALGetDataTypeSizeBytes(eDataType);\n        if (nDataTypeSize &&\n            nDataTypeSize * 8 == static_cast<int>(m_nBitsPerSample))\n        {\n            if (m_bNoDataSetAsInt64)\n            {\n                GDALCopyWords64(&m_nNoDataValueInt64, GDT_Int64, 0, pabyData,\n                                eDataType, nDataTypeSize,\n                                nBlockBytes / nDataTypeSize);\n            }\n            else if (m_bNoDataSetAsUInt64)\n            {\n                GDALCopyWords64(&m_nNoDataValueUInt64, GDT_UInt64, 0, pabyData,\n                                eDataType, nDataTypeSize,\n                                nBlockBytes / nDataTypeSize);\n            }\n            else\n            {\n                double dfNoData = m_dfNoDataValue;\n                GDALCopyWords64(&dfNoData, GDT_Float64, 0, pabyData, eDataType,\n                                nDataTypeSize, nBlockBytes / nDataTypeSize);\n            }\n        }\n        else if (nDataTypeSize)\n        {\n            // Handle non power-of-two depths.\n            // Ideally make a packed buffer, but that is a bit tedious,\n            // so use the normal I/O interfaces.\n\n            CPLFree(pabyData);\n\n            pabyData = static_cast<GByte *>(VSI_MALLOC3_VERBOSE(\n                m_nBlockXSize, m_nBlockYSize, nDataTypeSize));\n            if (pabyData == nullptr)\n                return CE_Failure;\n            if (m_bNoDataSetAsInt64)\n            {\n                GDALCopyWords64(&m_nNoDataValueInt64, GDT_Int64, 0, pabyData,\n                                eDataType, nDataTypeSize,\n                                static_cast<GPtrDiff_t>(m_nBlockXSize) *\n                                    m_nBlockYSize);\n            }\n            else if (m_bNoDataSetAsUInt64)\n            {\n                GDALCopyWords64(&m_nNoDataValueUInt64, GDT_UInt64, 0, pabyData,\n                                eDataType, nDataTypeSize,\n                                static_cast<GPtrDiff_t>(m_nBlockXSize) *\n                                    m_nBlockYSize);\n            }\n            else\n            {\n                GDALCopyWords64(&m_dfNoDataValue, GDT_Float64, 0, pabyData,\n                                eDataType, nDataTypeSize,\n                                static_cast<GPtrDiff_t>(m_nBlockXSize) *\n                                    m_nBlockYSize);\n            }\n            CPLErr eErr = CE_None;\n            for (int iBlock = 0; iBlock < nBlockCount; ++iBlock)\n            {\n                if (panByteCounts[iBlock] == 0)\n                {\n                    if (m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBands == 1)\n                    {\n                        if (GetRasterBand(1 + iBlock / m_nBlocksPerBand)\n                                ->WriteBlock((iBlock % m_nBlocksPerBand) %\n                                                 m_nBlocksPerRow,\n                                             (iBlock % m_nBlocksPerBand) /\n                                                 m_nBlocksPerRow,\n                                             pabyData) != CE_None)\n                        {\n                            eErr = CE_Failure;\n                        }\n                    }\n                    else\n                    {\n                        // In contig case, don't directly call WriteBlock(), as\n                        // it could cause useless decompression-recompression.\n                        const int nXOff =\n                            (iBlock % m_nBlocksPerRow) * m_nBlockXSize;\n                        const int nYOff =\n                            (iBlock / m_nBlocksPerRow) * m_nBlockYSize;\n                        const int nXSize =\n                            (nXOff + m_nBlockXSize <= nRasterXSize)\n                                ? m_nBlockXSize\n                                : nRasterXSize - nXOff;\n                        const int nYSize =\n                            (nYOff + m_nBlockYSize <= nRasterYSize)\n                                ? m_nBlockYSize\n                                : nRasterYSize - nYOff;\n                        for (int iBand = 1; iBand <= nBands; ++iBand)\n                        {\n                            if (GetRasterBand(iBand)->RasterIO(\n                                    GF_Write, nXOff, nYOff, nXSize, nYSize,\n                                    pabyData, nXSize, nYSize, eDataType, 0, 0,\n                                    nullptr) != CE_None)\n                            {\n                                eErr = CE_Failure;\n                            }\n                        }\n                    }\n                }\n            }\n            CPLFree(pabyData);\n            return eErr;\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      When we must fill with zeroes, try to create non-sparse file    */\n    /*      w.r.t TIFF spec ... as a sparse file w.r.t filesystem, ie by    */\n    /*      seeking to end of file instead of writing zero blocks.          */\n    /* -------------------------------------------------------------------- */\n    else if (m_nCompression == COMPRESSION_NONE && (m_nBitsPerSample % 8) == 0)\n    {\n        CPLErr eErr = CE_None;\n        // Only use libtiff to write the first sparse block to ensure that it\n        // will serialize offset and count arrays back to disk.\n        int nCountBlocksToZero = 0;\n        for (int iBlock = 0; iBlock < nBlockCount; ++iBlock)\n        {\n            if (panByteCounts[iBlock] == 0)\n            {\n                if (nCountBlocksToZero == 0)\n                {\n                    const bool bWriteEmptyTilesBak = m_bWriteEmptyTiles;\n                    m_bWriteEmptyTiles = true;\n                    const bool bOK = WriteEncodedTileOrStrip(iBlock, pabyData,\n                                                             FALSE) == CE_None;\n                    m_bWriteEmptyTiles = bWriteEmptyTilesBak;\n                    if (!bOK)\n                    {\n                        eErr = CE_Failure;\n                        break;\n                    }\n                }\n                nCountBlocksToZero++;\n            }\n        }\n        CPLFree(pabyData);\n\n        --nCountBlocksToZero;\n\n        // And then seek to end of file for other ones.\n        if (nCountBlocksToZero > 0)\n        {\n            toff_t *panByteOffsets = nullptr;\n\n            if (TIFFIsTiled(m_hTIFF))\n                TIFFGetField(m_hTIFF, TIFFTAG_TILEOFFSETS, &panByteOffsets);\n            else\n                TIFFGetField(m_hTIFF, TIFFTAG_STRIPOFFSETS, &panByteOffsets);\n\n            if (panByteOffsets == nullptr)\n            {\n                ReportError(\n                    CE_Failure, CPLE_AppDefined,\n                    \"FillEmptyTiles() failed because panByteOffsets == NULL\");\n                return CE_Failure;\n            }\n\n            VSILFILE *fpTIF = VSI_TIFFGetVSILFile(TIFFClientdata(m_hTIFF));\n            VSIFSeekL(fpTIF, 0, SEEK_END);\n            const vsi_l_offset nOffset = VSIFTellL(fpTIF);\n\n            vsi_l_offset iBlockToZero = 0;\n            for (int iBlock = 0; iBlock < nBlockCount; ++iBlock)\n            {\n                if (panByteCounts[iBlock] == 0)\n                {\n                    panByteOffsets[iBlock] = static_cast<toff_t>(\n                        nOffset + iBlockToZero * nBlockBytes);\n                    panByteCounts[iBlock] = nBlockBytes;\n                    iBlockToZero++;\n                }\n            }\n            CPLAssert(iBlockToZero ==\n                      static_cast<vsi_l_offset>(nCountBlocksToZero));\n\n            if (VSIFTruncateL(fpTIF, nOffset + iBlockToZero * nBlockBytes) != 0)\n            {\n                eErr = CE_Failure;\n                ReportError(CE_Failure, CPLE_FileIO,\n                            \"Cannot initialize empty blocks\");\n            }\n        }\n\n        return eErr;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Check all blocks, writing out data for uninitialized blocks.    */\n    /* -------------------------------------------------------------------- */\n\n    GByte *pabyRaw = nullptr;\n    vsi_l_offset nRawSize = 0;\n    CPLErr eErr = CE_None;\n    for (int iBlock = 0; iBlock < nBlockCount; ++iBlock)\n    {\n        if (panByteCounts[iBlock] == 0)\n        {\n            if (pabyRaw == nullptr)\n            {\n                if (WriteEncodedTileOrStrip(iBlock, pabyData, FALSE) != CE_None)\n                {\n                    eErr = CE_Failure;\n                    break;\n                }\n\n                vsi_l_offset nOffset = 0;\n                if (!IsBlockAvailable(iBlock, &nOffset, &nRawSize, nullptr))\n                    break;\n\n                // When using compression, get back the compressed block\n                // so we can use the raw API to write it faster.\n                if (m_nCompression != COMPRESSION_NONE)\n                {\n                    pabyRaw = static_cast<GByte *>(\n                        VSI_MALLOC_VERBOSE(static_cast<size_t>(nRawSize)));\n                    if (pabyRaw)\n                    {\n                        VSILFILE *fp =\n                            VSI_TIFFGetVSILFile(TIFFClientdata(m_hTIFF));\n                        const vsi_l_offset nCurOffset = VSIFTellL(fp);\n                        VSIFSeekL(fp, nOffset, SEEK_SET);\n                        VSIFReadL(pabyRaw, 1, static_cast<size_t>(nRawSize),\n                                  fp);\n                        VSIFSeekL(fp, nCurOffset, SEEK_SET);\n                    }\n                }\n            }\n            else\n            {\n                WriteRawStripOrTile(iBlock, pabyRaw,\n                                    static_cast<GPtrDiff_t>(nRawSize));\n            }\n        }\n    }\n\n    CPLFree(pabyData);\n    VSIFree(pabyRaw);\n    return eErr;\n}",
    "void GTiffDataset::ThreadCompressionFunc(void *pData)\n{\n    GTiffCompressionJob *psJob = static_cast<GTiffCompressionJob *>(pData);\n    GTiffDataset *poDS = psJob->poDS;\n\n    VSILFILE *fpTmp = VSIFOpenL(psJob->pszTmpFilename, \"wb+\");\n    TIFF *hTIFFTmp = VSI_TIFFOpen(\n        psJob->pszTmpFilename, psJob->bTIFFIsBigEndian ? \"wb+\" : \"wl+\", fpTmp);\n    CPLAssert(hTIFFTmp != nullptr);\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGEWIDTH, poDS->m_nBlockXSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGELENGTH, psJob->nHeight);\n    TIFFSetField(hTIFFTmp, TIFFTAG_BITSPERSAMPLE, poDS->m_nBitsPerSample);\n    TIFFSetField(hTIFFTmp, TIFFTAG_COMPRESSION, poDS->m_nCompression);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, poDS->m_nPhotometric);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLEFORMAT, poDS->m_nSampleFormat);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLESPERPIXEL, poDS->m_nSamplesPerPixel);\n    TIFFSetField(hTIFFTmp, TIFFTAG_ROWSPERSTRIP, poDS->m_nBlockYSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PLANARCONFIG, poDS->m_nPlanarConfig);\n    if (psJob->nPredictor != PREDICTOR_NONE)\n        TIFFSetField(hTIFFTmp, TIFFTAG_PREDICTOR, psJob->nPredictor);\n    if (poDS->m_nCompression == COMPRESSION_LERC)\n    {\n        TIFFSetField(hTIFFTmp, TIFFTAG_LERC_PARAMETERS, 2,\n                     poDS->m_anLercAddCompressionAndVersion);\n    }\n    if (psJob->nExtraSampleCount)\n    {\n        TIFFSetField(hTIFFTmp, TIFFTAG_EXTRASAMPLES, psJob->nExtraSampleCount,\n                     psJob->pExtraSamples);\n    }\n\n    poDS->RestoreVolatileParameters(hTIFFTmp);\n\n    bool bOK = TIFFWriteEncodedStrip(hTIFFTmp, 0, psJob->pabyBuffer,\n                                     psJob->nBufferSize) == psJob->nBufferSize;\n\n    toff_t nOffset = 0;\n    if (bOK)\n    {\n        toff_t *panOffsets = nullptr;\n        toff_t *panByteCounts = nullptr;\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPOFFSETS, &panOffsets);\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts);\n\n        nOffset = panOffsets[0];\n        psJob->nCompressedBufferSize =\n            static_cast<GPtrDiff_t>(panByteCounts[0]);\n    }\n    else\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"Error when compressing strip/tile %d\", psJob->nStripOrTile);\n    }\n\n    XTIFFClose(hTIFFTmp);\n    if (VSIFCloseL(fpTmp) != 0)\n    {\n        if (bOK)\n        {\n            bOK = false;\n            CPLError(CE_Failure, CPLE_AppDefined,\n                     \"Error when compressing strip/tile %d\",\n                     psJob->nStripOrTile);\n        }\n    }\n\n    if (bOK)\n    {\n        vsi_l_offset nFileSize = 0;\n        GByte *pabyCompressedBuffer =\n            VSIGetMemFileBuffer(psJob->pszTmpFilename, &nFileSize, FALSE);\n        CPLAssert(static_cast<vsi_l_offset>(\n                      nOffset + psJob->nCompressedBufferSize) <= nFileSize);\n        psJob->pabyCompressedBuffer = pabyCompressedBuffer + nOffset;\n    }\n    else\n    {\n        psJob->pabyCompressedBuffer = nullptr;\n        psJob->nCompressedBufferSize = 0;\n    }\n\n    auto poMainDS = poDS->m_poBaseDS ? poDS->m_poBaseDS : poDS;\n    if (poMainDS->m_poCompressQueue)\n    {\n        std::lock_guard oLock(poMainDS->m_oCompressThreadPoolMutex);\n        psJob->bReady = true;\n    }\n}",
    "void GTiffDataset::WriteRawStripOrTile(int nStripOrTile,\n                                       GByte *pabyCompressedBuffer,\n                                       GPtrDiff_t nCompressedBufferSize)\n{\n#ifdef DEBUG_VERBOSE\n    CPLDebug(\"GTIFF\", \"Writing raw strip/tile %d, size \" CPL_FRMT_GUIB,\n             nStripOrTile, static_cast<GUIntBig>(nCompressedBufferSize));\n#endif\n    toff_t *panOffsets = nullptr;\n    toff_t *panByteCounts = nullptr;\n    bool bWriteAtEnd = true;\n    bool bWriteLeader = m_bLeaderSizeAsUInt4;\n    bool bWriteTrailer = m_bTrailerRepeatedLast4BytesRepeated;\n    if (TIFFGetField(m_hTIFF,\n                     TIFFIsTiled(m_hTIFF) ? TIFFTAG_TILEOFFSETS\n                                          : TIFFTAG_STRIPOFFSETS,\n                     &panOffsets) &&\n        panOffsets != nullptr && panOffsets[nStripOrTile] != 0)\n    {\n        // Forces TIFFAppendStrip() to consider if the location of the\n        // tile/strip can be reused or if the strile should be written at end of\n        // file.\n        TIFFSetWriteOffset(m_hTIFF, 0);\n\n        if (m_bBlockOrderRowMajor)\n        {\n            if (TIFFGetField(m_hTIFF,\n                             TIFFIsTiled(m_hTIFF) ? TIFFTAG_TILEBYTECOUNTS\n                                                  : TIFFTAG_STRIPBYTECOUNTS,\n                             &panByteCounts) &&\n                panByteCounts != nullptr)\n            {\n                if (static_cast<GUIntBig>(nCompressedBufferSize) >\n                    panByteCounts[nStripOrTile])\n                {\n                    GTiffDataset *poRootDS = m_poBaseDS ? m_poBaseDS : this;\n                    if (!poRootDS->m_bKnownIncompatibleEdition &&\n                        !poRootDS->m_bWriteKnownIncompatibleEdition)\n                    {\n                        ReportError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"A strile cannot be rewritten in place, which \"\n                            \"invalidates the BLOCK_ORDER optimization.\");\n                        poRootDS->m_bKnownIncompatibleEdition = true;\n                        poRootDS->m_bWriteKnownIncompatibleEdition = true;\n                    }\n                }\n                // For mask interleaving, if the size is not exactly the same,\n                // completely give up (we could potentially move the mask in\n                // case the imagery is smaller)\n                else if (m_poMaskDS && m_bMaskInterleavedWithImagery &&\n                         static_cast<GUIntBig>(nCompressedBufferSize) !=\n                             panByteCounts[nStripOrTile])\n                {\n                    GTiffDataset *poRootDS = m_poBaseDS ? m_poBaseDS : this;\n                    if (!poRootDS->m_bKnownIncompatibleEdition &&\n                        !poRootDS->m_bWriteKnownIncompatibleEdition)\n                    {\n                        ReportError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"A strile cannot be rewritten in place, which \"\n                            \"invalidates the MASK_INTERLEAVED_WITH_IMAGERY \"\n                            \"optimization.\");\n                        poRootDS->m_bKnownIncompatibleEdition = true;\n                        poRootDS->m_bWriteKnownIncompatibleEdition = true;\n                    }\n                    bWriteLeader = false;\n                    bWriteTrailer = false;\n                    if (m_bLeaderSizeAsUInt4)\n                    {\n                        // If there was a valid leader, invalidat it\n                        VSI_TIFFSeek(m_hTIFF, panOffsets[nStripOrTile] - 4,\n                                     SEEK_SET);\n                        uint32_t nOldSize;\n                        VSIFReadL(&nOldSize, 1, 4,\n                                  VSI_TIFFGetVSILFile(TIFFClientdata(m_hTIFF)));\n                        CPL_LSBPTR32(&nOldSize);\n                        if (nOldSize == panByteCounts[nStripOrTile])\n                        {\n                            uint32_t nInvalidatedSize = 0;\n                            VSI_TIFFSeek(m_hTIFF, panOffsets[nStripOrTile] - 4,\n                                         SEEK_SET);\n                            VSI_TIFFWrite(m_hTIFF, &nInvalidatedSize,\n                                          sizeof(nInvalidatedSize));\n                        }\n                    }\n                }\n                else\n                {\n                    bWriteAtEnd = false;\n                }\n            }\n        }\n    }\n    if (bWriteLeader &&\n        static_cast<GUIntBig>(nCompressedBufferSize) <= 0xFFFFFFFFU)\n    {\n        // cppcheck-suppress knownConditionTrueFalse\n        if (bWriteAtEnd)\n        {\n            VSI_TIFFSeek(m_hTIFF, 0, SEEK_END);\n        }\n        else\n        {\n            // If we rewrite an existing strile in place with an existing\n            // leader, check that the leader is valid, before rewriting it. And\n            // if it is not valid, then do not write the trailer, as we could\n            // corrupt other data.\n            VSI_TIFFSeek(m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET);\n            uint32_t nOldSize;\n            VSIFReadL(&nOldSize, 1, 4,\n                      VSI_TIFFGetVSILFile(TIFFClientdata(m_hTIFF)));\n            CPL_LSBPTR32(&nOldSize);\n            bWriteLeader =\n                panByteCounts && nOldSize == panByteCounts[nStripOrTile];\n            bWriteTrailer = bWriteLeader;\n            VSI_TIFFSeek(m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET);\n        }\n        // cppcheck-suppress knownConditionTrueFalse\n        if (bWriteLeader)\n        {\n            uint32_t nSize = static_cast<uint32_t>(nCompressedBufferSize);\n            CPL_LSBPTR32(&nSize);\n            if (!VSI_TIFFWrite(m_hTIFF, &nSize, sizeof(nSize)))\n                m_bWriteError = true;\n        }\n    }\n    tmsize_t written;\n    if (TIFFIsTiled(m_hTIFF))\n        written = TIFFWriteRawTile(m_hTIFF, nStripOrTile, pabyCompressedBuffer,\n                                   nCompressedBufferSize);\n    else\n        written = TIFFWriteRawStrip(m_hTIFF, nStripOrTile, pabyCompressedBuffer,\n                                    nCompressedBufferSize);\n    if (written != nCompressedBufferSize)\n        m_bWriteError = true;\n    if (bWriteTrailer &&\n        static_cast<GUIntBig>(nCompressedBufferSize) <= 0xFFFFFFFFU)\n    {\n        GByte abyLastBytes[4] = {};\n        if (nCompressedBufferSize >= 4)\n            memcpy(abyLastBytes,\n                   pabyCompressedBuffer + nCompressedBufferSize - 4, 4);\n        else\n            memcpy(abyLastBytes, pabyCompressedBuffer, nCompressedBufferSize);\n        if (!VSI_TIFFWrite(m_hTIFF, abyLastBytes, 4))\n            m_bWriteError = true;\n    }\n}",
    "bool GTiffDataset::SubmitCompressionJob(int nStripOrTile, GByte *pabyData,\n                                        GPtrDiff_t cc, int nHeight)\n{\n    /* -------------------------------------------------------------------- */\n    /*      Should we do compression in a worker thread ?                   */\n    /* -------------------------------------------------------------------- */\n    auto poQueue = m_poBaseDS ? m_poBaseDS->m_poCompressQueue.get()\n                              : m_poCompressQueue.get();\n\n    if (poQueue && m_nCompression == COMPRESSION_NONE)\n    {\n        // We don't do multi-threaded compression for uncompressed...\n        // but we must wait for other related compression tasks (e.g mask)\n        // to be completed\n        poQueue->WaitCompletion();\n\n        // Flush remaining data\n        // cppcheck-suppress constVariableReference\n        auto &oQueue =\n            m_poBaseDS ? m_poBaseDS->m_asQueueJobIdx : m_asQueueJobIdx;\n        while (!oQueue.empty())\n        {\n            WaitCompletionForJobIdx(oQueue.front());\n        }\n    }\n\n    const auto SetupJob =\n        [this, pabyData, cc, nHeight, nStripOrTile](GTiffCompressionJob &sJob)\n    {\n        sJob.poDS = this;\n        sJob.bTIFFIsBigEndian = CPL_TO_BOOL(TIFFIsBigEndian(m_hTIFF));\n        sJob.pabyBuffer = static_cast<GByte *>(CPLRealloc(sJob.pabyBuffer, cc));\n        memcpy(sJob.pabyBuffer, pabyData, cc);\n        sJob.nBufferSize = cc;\n        sJob.nHeight = nHeight;\n        sJob.nStripOrTile = nStripOrTile;\n        sJob.nPredictor = PREDICTOR_NONE;\n        if (GTIFFSupportsPredictor(m_nCompression))\n        {\n            TIFFGetField(m_hTIFF, TIFFTAG_PREDICTOR, &sJob.nPredictor);\n        }\n\n        sJob.pExtraSamples = nullptr;\n        sJob.nExtraSampleCount = 0;\n        TIFFGetField(m_hTIFF, TIFFTAG_EXTRASAMPLES, &sJob.nExtraSampleCount,\n                     &sJob.pExtraSamples);\n    };\n\n    if (poQueue == nullptr || !(m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n                                m_nCompression == COMPRESSION_LZW ||\n                                m_nCompression == COMPRESSION_PACKBITS ||\n                                m_nCompression == COMPRESSION_LZMA ||\n                                m_nCompression == COMPRESSION_ZSTD ||\n                                m_nCompression == COMPRESSION_LERC ||\n                                m_nCompression == COMPRESSION_JXL ||\n                                m_nCompression == COMPRESSION_JXL_DNG_1_7 ||\n                                m_nCompression == COMPRESSION_WEBP ||\n                                m_nCompression == COMPRESSION_JPEG))\n    {\n        if (m_bBlockOrderRowMajor || m_bLeaderSizeAsUInt4 ||\n            m_bTrailerRepeatedLast4BytesRepeated)\n        {\n            GTiffCompressionJob sJob;\n            memset(&sJob, 0, sizeof(sJob));\n            SetupJob(sJob);\n            sJob.pszTmpFilename =\n                CPLStrdup(VSIMemGenerateHiddenFilename(\"temp.tif\"));\n\n            ThreadCompressionFunc(&sJob);\n\n            if (sJob.nCompressedBufferSize)\n            {\n                sJob.poDS->WriteRawStripOrTile(sJob.nStripOrTile,\n                                               sJob.pabyCompressedBuffer,\n                                               sJob.nCompressedBufferSize);\n            }\n\n            CPLFree(sJob.pabyBuffer);\n            VSIUnlink(sJob.pszTmpFilename);\n            CPLFree(sJob.pszTmpFilename);\n            return sJob.nCompressedBufferSize > 0 && !m_bWriteError;\n        }\n\n        return false;\n    }\n\n    auto poMainDS = m_poBaseDS ? m_poBaseDS : this;\n    auto &oQueue = poMainDS->m_asQueueJobIdx;\n    auto &asJobs = poMainDS->m_asCompressionJobs;\n\n    int nNextCompressionJobAvail = -1;\n\n    if (oQueue.size() == asJobs.size())\n    {\n        CPLAssert(!oQueue.empty());\n        nNextCompressionJobAvail = oQueue.front();\n        WaitCompletionForJobIdx(nNextCompressionJobAvail);\n    }\n    else\n    {\n        const int nJobs = static_cast<int>(asJobs.size());\n        for (int i = 0; i < nJobs; ++i)\n        {\n            if (asJobs[i].nBufferSize == 0)\n            {\n                nNextCompressionJobAvail = i;\n                break;\n            }\n        }\n    }\n    CPLAssert(nNextCompressionJobAvail >= 0);\n\n    GTiffCompressionJob *psJob = &asJobs[nNextCompressionJobAvail];\n    SetupJob(*psJob);\n    poQueue->SubmitJob(ThreadCompressionFunc, psJob);\n    oQueue.push(nNextCompressionJobAvail);\n\n    return true;\n}",
    "static void GTiffFillStreamableOffsetAndCount(TIFF *hTIFF, int nSize)\n{\n    uint32_t nXSize = 0;\n    uint32_t nYSize = 0;\n    TIFFGetField(hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize);\n    TIFFGetField(hTIFF, TIFFTAG_IMAGELENGTH, &nYSize);\n    const bool bIsTiled = CPL_TO_BOOL(TIFFIsTiled(hTIFF));\n    const int nBlockCount =\n        bIsTiled ? TIFFNumberOfTiles(hTIFF) : TIFFNumberOfStrips(hTIFF);\n\n    toff_t *panOffset = nullptr;\n    TIFFGetField(hTIFF, bIsTiled ? TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                 &panOffset);\n    toff_t *panSize = nullptr;\n    TIFFGetField(hTIFF,\n                 bIsTiled ? TIFFTAG_TILEBYTECOUNTS : TIFFTAG_STRIPBYTECOUNTS,\n                 &panSize);\n    toff_t nOffset = nSize;\n    // Trick to avoid clang static analyzer raising false positive about\n    // divide by zero later.\n    int nBlocksPerBand = 1;\n    uint32_t nRowsPerStrip = 0;\n    if (!bIsTiled)\n    {\n        TIFFGetField(hTIFF, TIFFTAG_ROWSPERSTRIP, &nRowsPerStrip);\n        if (nRowsPerStrip > static_cast<uint32_t>(nYSize))\n            nRowsPerStrip = nYSize;\n        nBlocksPerBand = DIV_ROUND_UP(nYSize, nRowsPerStrip);\n    }\n    for (int i = 0; i < nBlockCount; ++i)\n    {\n        GPtrDiff_t cc = bIsTiled\n                            ? static_cast<GPtrDiff_t>(TIFFTileSize(hTIFF))\n                            : static_cast<GPtrDiff_t>(TIFFStripSize(hTIFF));\n        if (!bIsTiled)\n        {\n            /* --------------------------------------------------------------------\n             */\n            /*      If this is the last strip in the image, and is partial, then\n             */\n            /*      we need to trim the number of scanlines written to the */\n            /*      amount of valid data we have. (#2748) */\n            /* --------------------------------------------------------------------\n             */\n            int nStripWithinBand = i % nBlocksPerBand;\n            if (nStripWithinBand * nRowsPerStrip > nYSize - nRowsPerStrip)\n            {\n                cc = (cc / nRowsPerStrip) *\n                     (nYSize - nStripWithinBand * nRowsPerStrip);\n            }\n        }\n        panOffset[i] = nOffset;\n        panSize[i] = cc;\n        nOffset += cc;\n    }\n}",
    "CPLErr GTiffDataset::FlushDirectory()\n\n{\n    CPLErr eErr = CE_None;\n\n    const auto ReloadAllOtherDirectories = [this]()\n    {\n        const auto poBaseDS = m_poBaseDS ? m_poBaseDS : this;\n        if (poBaseDS->m_papoOverviewDS)\n        {\n            for (int i = 0; i < poBaseDS->m_nOverviewCount; ++i)\n            {\n                if (poBaseDS->m_papoOverviewDS[i]->m_bCrystalized &&\n                    poBaseDS->m_papoOverviewDS[i] != this)\n                {\n                    poBaseDS->m_papoOverviewDS[i]->ReloadDirectory(true);\n                }\n\n                if (poBaseDS->m_papoOverviewDS[i]->m_poMaskDS &&\n                    poBaseDS->m_papoOverviewDS[i]->m_poMaskDS != this &&\n                    poBaseDS->m_papoOverviewDS[i]->m_poMaskDS->m_bCrystalized)\n                {\n                    poBaseDS->m_papoOverviewDS[i]->m_poMaskDS->ReloadDirectory(\n                        true);\n                }\n            }\n        }\n        if (poBaseDS->m_poMaskDS && poBaseDS->m_poMaskDS != this &&\n            poBaseDS->m_poMaskDS->m_bCrystalized)\n        {\n            poBaseDS->m_poMaskDS->ReloadDirectory(true);\n        }\n        if (poBaseDS->m_bCrystalized && poBaseDS != this)\n        {\n            poBaseDS->ReloadDirectory(true);\n        }\n    };\n\n    if (eAccess == GA_Update)\n    {\n        if (m_bMetadataChanged)\n        {\n            m_bNeedsRewrite =\n                WriteMetadata(this, m_hTIFF, true, m_eProfile, m_pszFilename,\n                              m_papszCreationOptions);\n            m_bMetadataChanged = false;\n\n            if (m_bForceUnsetRPC)\n            {\n                double *padfRPCTag = nullptr;\n                uint16_t nCount;\n                if (TIFFGetField(m_hTIFF, TIFFTAG_RPCCOEFFICIENT, &nCount,\n                                 &padfRPCTag))\n                {\n                    std::vector<double> zeroes(92);\n                    TIFFSetField(m_hTIFF, TIFFTAG_RPCCOEFFICIENT, 92,\n                                 zeroes.data());\n                    TIFFUnsetField(m_hTIFF, TIFFTAG_RPCCOEFFICIENT);\n                    m_bNeedsRewrite = true;\n                }\n\n                GDALWriteRPCTXTFile(m_pszFilename, nullptr);\n                GDALWriteRPBFile(m_pszFilename, nullptr);\n            }\n        }\n\n        if (m_bGeoTIFFInfoChanged)\n        {\n            WriteGeoTIFFInfo();\n            m_bGeoTIFFInfoChanged = false;\n        }\n\n        if (m_bNoDataChanged)\n        {\n            if (m_bNoDataSet)\n            {\n                WriteNoDataValue(m_hTIFF, m_dfNoDataValue);\n            }\n            else if (m_bNoDataSetAsInt64)\n            {\n                WriteNoDataValue(m_hTIFF, m_nNoDataValueInt64);\n            }\n            else if (m_bNoDataSetAsUInt64)\n            {\n                WriteNoDataValue(m_hTIFF, m_nNoDataValueUInt64);\n            }\n            else\n            {\n                UnsetNoDataValue(m_hTIFF);\n            }\n            m_bNeedsRewrite = true;\n            m_bNoDataChanged = false;\n        }\n\n        if (m_bNeedsRewrite)\n        {\n            if (!m_bCrystalized)\n            {\n                Crystalize();\n            }\n            else\n            {\n                const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc(m_hTIFF);\n\n                m_nDirOffset = pfnSizeProc(TIFFClientdata(m_hTIFF));\n                if ((m_nDirOffset % 2) == 1)\n                    ++m_nDirOffset;\n\n                if (TIFFRewriteDirectory(m_hTIFF) == 0)\n                    eErr = CE_Failure;\n\n                TIFFSetSubDirectory(m_hTIFF, m_nDirOffset);\n\n                ReloadAllOtherDirectories();\n\n                if (m_bLayoutIFDSBeforeData && m_bBlockOrderRowMajor &&\n                    m_bLeaderSizeAsUInt4 &&\n                    m_bTrailerRepeatedLast4BytesRepeated &&\n                    !m_bKnownIncompatibleEdition &&\n                    !m_bWriteKnownIncompatibleEdition)\n                {\n                    ReportError(CE_Warning, CPLE_AppDefined,\n                                \"The IFD has been rewritten at the end of \"\n                                \"the file, which breaks COG layout.\");\n                    m_bKnownIncompatibleEdition = true;\n                    m_bWriteKnownIncompatibleEdition = true;\n                }\n            }\n\n            m_bNeedsRewrite = false;\n        }\n    }\n\n    // There are some circumstances in which we can reach this point\n    // without having made this our directory (SetDirectory()) in which\n    // case we should not risk a flush.\n    if (GetAccess() == GA_Update &&\n        TIFFCurrentDirOffset(m_hTIFF) == m_nDirOffset)\n    {\n        const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc(m_hTIFF);\n\n        toff_t nNewDirOffset = pfnSizeProc(TIFFClientdata(m_hTIFF));\n        if ((nNewDirOffset % 2) == 1)\n            ++nNewDirOffset;\n\n        if (TIFFFlush(m_hTIFF) == 0)\n            eErr = CE_Failure;\n\n        if (m_nDirOffset != TIFFCurrentDirOffset(m_hTIFF))\n        {\n            m_nDirOffset = nNewDirOffset;\n            ReloadAllOtherDirectories();\n            CPLDebug(\"GTiff\",\n                     \"directory moved during flush in FlushDirectory()\");\n        }\n    }\n\n    SetDirectory();\n    return eErr;\n}",
    "bool GTiffDataset::GetOverviewParameters(\n    int &nCompression, uint16_t &nPlanarConfig, uint16_t &nPredictor,\n    uint16_t &nPhotometric, int &nOvrJpegQuality, std::string &osNoData,\n    uint16_t *&panExtraSampleValues, uint16_t &nExtraSamples,\n    CSLConstList papszOptions) const\n{\n    const auto GetOptionValue =\n        [papszOptions](const char *pszOptionKey, const char *pszConfigOptionKey,\n                       const char **ppszKeyUsed = nullptr)\n    {\n        const char *pszVal = CSLFetchNameValue(papszOptions, pszOptionKey);\n        if (pszVal)\n        {\n            if (ppszKeyUsed)\n                *ppszKeyUsed = pszOptionKey;\n            return pszVal;\n        }\n        pszVal = CSLFetchNameValue(papszOptions, pszConfigOptionKey);\n        if (pszVal)\n        {\n            if (ppszKeyUsed)\n                *ppszKeyUsed = pszConfigOptionKey;\n            return pszVal;\n        }\n        pszVal = CPLGetConfigOption(pszConfigOptionKey, nullptr);\n        if (pszVal && ppszKeyUsed)\n            *ppszKeyUsed = pszConfigOptionKey;\n        return pszVal;\n    };\n\n    /* -------------------------------------------------------------------- */\n    /*      Determine compression method.                                   */\n    /* -------------------------------------------------------------------- */\n    nCompression = m_nCompression;\n    const char *pszOptionKey = \"\";\n    const char *pszCompressValue =\n        GetOptionValue(\"COMPRESS\", \"COMPRESS_OVERVIEW\", &pszOptionKey);\n    if (pszCompressValue != nullptr)\n    {\n        nCompression =\n            GTIFFGetCompressionMethod(pszCompressValue, pszOptionKey);\n        if (nCompression < 0)\n        {\n            nCompression = m_nCompression;\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Determine planar configuration.                                 */\n    /* -------------------------------------------------------------------- */\n    nPlanarConfig = m_nPlanarConfig;\n    if (nCompression == COMPRESSION_WEBP)\n    {\n        nPlanarConfig = PLANARCONFIG_CONTIG;\n    }\n    const char *pszInterleave =\n        GetOptionValue(\"INTERLEAVE\", \"INTERLEAVE_OVERVIEW\", &pszOptionKey);\n    if (pszInterleave != nullptr && pszInterleave[0] != '\\0')\n    {\n        if (EQUAL(pszInterleave, \"PIXEL\"))\n            nPlanarConfig = PLANARCONFIG_CONTIG;\n        else if (EQUAL(pszInterleave, \"BAND\"))\n            nPlanarConfig = PLANARCONFIG_SEPARATE;\n        else\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"%s=%s unsupported, \"\n                     \"value must be PIXEL or BAND. ignoring\",\n                     pszOptionKey, pszInterleave);\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Determine predictor tag                                         */\n    /* -------------------------------------------------------------------- */\n    nPredictor = PREDICTOR_NONE;\n    if (GTIFFSupportsPredictor(nCompression))\n    {\n        const char *pszPredictor =\n            GetOptionValue(\"PREDICTOR\", \"PREDICTOR_OVERVIEW\");\n        if (pszPredictor != nullptr)\n        {\n            nPredictor = static_cast<uint16_t>(atoi(pszPredictor));\n        }\n        else if (GTIFFSupportsPredictor(m_nCompression))\n            TIFFGetField(m_hTIFF, TIFFTAG_PREDICTOR, &nPredictor);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Determine photometric tag                                       */\n    /* -------------------------------------------------------------------- */\n    if (m_nPhotometric == PHOTOMETRIC_YCBCR && nCompression != COMPRESSION_JPEG)\n        nPhotometric = PHOTOMETRIC_RGB;\n    else\n        nPhotometric = m_nPhotometric;\n    const char *pszPhotometric =\n        GetOptionValue(\"PHOTOMETRIC\", \"PHOTOMETRIC_OVERVIEW\", &pszOptionKey);\n    if (!GTIFFUpdatePhotometric(pszPhotometric, pszOptionKey, nCompression,\n                                pszInterleave, nBands, nPhotometric,\n                                nPlanarConfig))\n    {\n        return false;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Determine JPEG quality                                          */\n    /* -------------------------------------------------------------------- */\n    nOvrJpegQuality = m_nJpegQuality;\n    if (nCompression == COMPRESSION_JPEG)\n    {\n        const char *pszJPEGQuality =\n            GetOptionValue(\"JPEG_QUALITY\", \"JPEG_QUALITY_OVERVIEW\");\n        if (pszJPEGQuality != nullptr)\n        {\n            nOvrJpegQuality = atoi(pszJPEGQuality);\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Set nodata.                                                     */\n    /* -------------------------------------------------------------------- */\n    if (m_bNoDataSet)\n    {\n        osNoData = GTiffFormatGDALNoDataTagValue(m_dfNoDataValue);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Fetch extra sample tag                                          */\n    /* -------------------------------------------------------------------- */\n    panExtraSampleValues = nullptr;\n    nExtraSamples = 0;\n    if (TIFFGetField(m_hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples,\n                     &panExtraSampleValues))\n    {\n        uint16_t *panExtraSampleValuesNew = static_cast<uint16_t *>(\n            CPLMalloc(nExtraSamples * sizeof(uint16_t)));\n        memcpy(panExtraSampleValuesNew, panExtraSampleValues,\n               nExtraSamples * sizeof(uint16_t));\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = nullptr;\n        nExtraSamples = 0;\n    }\n\n    return true;\n}",
    "static void GTiffWriteDummyGeokeyDirectory(TIFF *hTIFF)\n{\n    // If we have existing geokeys, try to wipe them\n    // by writing a dummy geokey directory. (#2546)\n    uint16_t *panVI = nullptr;\n    uint16_t nKeyCount = 0;\n\n    if (TIFFGetField(hTIFF, TIFFTAG_GEOKEYDIRECTORY, &nKeyCount, &panVI))\n    {\n        GUInt16 anGKVersionInfo[4] = {1, 1, 0, 0};\n        double adfDummyDoubleParams[1] = {0.0};\n        TIFFSetField(hTIFF, TIFFTAG_GEOKEYDIRECTORY, 4, anGKVersionInfo);\n        TIFFSetField(hTIFF, TIFFTAG_GEODOUBLEPARAMS, 1, adfDummyDoubleParams);\n        TIFFSetField(hTIFF, TIFFTAG_GEOASCIIPARAMS, \"\");\n    }\n}",
    "static void WriteMDMetadata(GDALMultiDomainMetadata *poMDMD, TIFF *hTIFF,\n                            CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail,\n                            int nBand, GTiffProfile eProfile)\n\n{\n\n    /* ==================================================================== */\n    /*      Process each domain.                                            */\n    /* ==================================================================== */\n    CSLConstList papszDomainList = poMDMD->GetDomainList();\n    for (int iDomain = 0; papszDomainList && papszDomainList[iDomain];\n         ++iDomain)\n    {\n        CSLConstList papszMD = poMDMD->GetMetadata(papszDomainList[iDomain]);\n        bool bIsXML = false;\n\n        if (EQUAL(papszDomainList[iDomain], \"IMAGE_STRUCTURE\") ||\n            EQUAL(papszDomainList[iDomain], \"DERIVED_SUBDATASETS\"))\n            continue;  // Ignored.\n        if (EQUAL(papszDomainList[iDomain], \"COLOR_PROFILE\"))\n            continue;  // Handled elsewhere.\n        if (EQUAL(papszDomainList[iDomain], MD_DOMAIN_RPC))\n            continue;  // Handled elsewhere.\n        if (EQUAL(papszDomainList[iDomain], \"xml:ESRI\") &&\n            CPLTestBool(CPLGetConfigOption(\"ESRI_XML_PAM\", \"NO\")))\n            continue;  // Handled elsewhere.\n        if (EQUAL(papszDomainList[iDomain], \"xml:XMP\"))\n            continue;  // Handled in SetMetadata.\n\n        if (STARTS_WITH_CI(papszDomainList[iDomain], \"xml:\"))\n            bIsXML = true;\n\n        /* --------------------------------------------------------------------\n         */\n        /*      Process each item in this domain. */\n        /* --------------------------------------------------------------------\n         */\n        for (int iItem = 0; papszMD && papszMD[iItem]; ++iItem)\n        {\n            const char *pszItemValue = nullptr;\n            char *pszItemName = nullptr;\n\n            if (bIsXML)\n            {\n                pszItemName = CPLStrdup(\"doc\");\n                pszItemValue = papszMD[iItem];\n            }\n            else\n            {\n                pszItemValue = CPLParseNameValue(papszMD[iItem], &pszItemName);\n                if (pszItemName == nullptr)\n                {\n                    CPLDebug(\"GTiff\", \"Invalid metadata item : %s\",\n                             papszMD[iItem]);\n                    continue;\n                }\n            }\n\n            /* --------------------------------------------------------------------\n             */\n            /*      Convert into XML item or handle as a special TIFF tag. */\n            /* --------------------------------------------------------------------\n             */\n            if (strlen(papszDomainList[iDomain]) == 0 && nBand == 0 &&\n                (STARTS_WITH_CI(pszItemName, \"TIFFTAG_\") ||\n                 (EQUAL(pszItemName, \"GEO_METADATA\") &&\n                  eProfile == GTiffProfile::GDALGEOTIFF) ||\n                 (EQUAL(pszItemName, \"TIFF_RSID\") &&\n                  eProfile == GTiffProfile::GDALGEOTIFF)))\n            {\n                if (EQUAL(pszItemName, \"TIFFTAG_RESOLUTIONUNIT\"))\n                {\n                    // ResolutionUnit can't be 0, which is the default if\n                    // atoi() fails.  Set to 1=Unknown.\n                    int v = atoi(pszItemValue);\n                    if (!v)\n                        v = RESUNIT_NONE;\n                    TIFFSetField(hTIFF, TIFFTAG_RESOLUTIONUNIT, v);\n                }\n                else\n                {\n                    bool bFoundTag = false;\n                    size_t iTag = 0;  // Used after for.\n                    const auto *pasTIFFTags = GTiffDataset::GetTIFFTags();\n                    for (; pasTIFFTags[iTag].pszTagName; ++iTag)\n                    {\n                        if (EQUAL(pszItemName, pasTIFFTags[iTag].pszTagName))\n                        {\n                            bFoundTag = true;\n                            break;\n                        }\n                    }\n\n                    if (bFoundTag &&\n                        pasTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING)\n                        TIFFSetField(hTIFF, pasTIFFTags[iTag].nTagVal,\n                                     pszItemValue);\n                    else if (bFoundTag &&\n                             pasTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT)\n                        TIFFSetField(hTIFF, pasTIFFTags[iTag].nTagVal,\n                                     CPLAtof(pszItemValue));\n                    else if (bFoundTag &&\n                             pasTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT)\n                        TIFFSetField(hTIFF, pasTIFFTags[iTag].nTagVal,\n                                     atoi(pszItemValue));\n                    else if (bFoundTag && pasTIFFTags[iTag].eType ==\n                                              GTIFFTAGTYPE_BYTE_STRING)\n                    {\n                        uint32_t nLen =\n                            static_cast<uint32_t>(strlen(pszItemValue));\n                        if (nLen)\n                        {\n                            TIFFSetField(hTIFF, pasTIFFTags[iTag].nTagVal, nLen,\n                                         pszItemValue);\n                        }\n                    }\n                    else\n                        CPLError(CE_Warning, CPLE_NotSupported,\n                                 \"%s metadata item is unhandled and \"\n                                 \"will not be written\",\n                                 pszItemName);\n                }\n            }\n            else if (nBand == 0 && EQUAL(pszItemName, GDALMD_AREA_OR_POINT))\n            {\n                /* Do nothing, handled elsewhere. */;\n            }\n            else\n            {\n                AppendMetadataItem(ppsRoot, ppsTail, pszItemName, pszItemValue,\n                                   nBand, nullptr, papszDomainList[iDomain]);\n            }\n\n            CPLFree(pszItemName);\n        }\n\n        /* --------------------------------------------------------------------\n         */\n        /*      Remove TIFFTAG_xxxxxx that are already set but no longer in */\n        /*      the metadata list (#5619) */\n        /* --------------------------------------------------------------------\n         */\n        if (strlen(papszDomainList[iDomain]) == 0 && nBand == 0)\n        {\n            const auto *pasTIFFTags = GTiffDataset::GetTIFFTags();\n            for (size_t iTag = 0; pasTIFFTags[iTag].pszTagName; ++iTag)\n            {\n                uint32_t nCount = 0;\n                char *pszText = nullptr;\n                int16_t nVal = 0;\n                float fVal = 0.0f;\n                const char *pszVal =\n                    CSLFetchNameValue(papszMD, pasTIFFTags[iTag].pszTagName);\n                if (pszVal == nullptr &&\n                    ((pasTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING &&\n                      TIFFGetField(hTIFF, pasTIFFTags[iTag].nTagVal,\n                                   &pszText)) ||\n                     (pasTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT &&\n                      TIFFGetField(hTIFF, pasTIFFTags[iTag].nTagVal, &nVal)) ||\n                     (pasTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT &&\n                      TIFFGetField(hTIFF, pasTIFFTags[iTag].nTagVal, &fVal)) ||\n                     (pasTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING &&\n                      TIFFGetField(hTIFF, pasTIFFTags[iTag].nTagVal, &nCount,\n                                   &pszText))))\n                {\n                    TIFFUnsetField(hTIFF, pasTIFFTags[iTag].nTagVal);\n                }\n            }\n        }\n    }\n}",
    "bool GTiffDataset::WriteMetadata(GDALDataset *poSrcDS, TIFF *l_hTIFF,\n                                 bool bSrcIsGeoTIFF, GTiffProfile eProfile,\n                                 const char *pszTIFFFilename,\n                                 CSLConstList papszCreationOptions,\n                                 bool bExcludeRPBandIMGFileWriting)\n\n{\n    /* -------------------------------------------------------------------- */\n    /*      Convert all the remaining metadata into a simple XML            */\n    /*      format.                                                         */\n    /* -------------------------------------------------------------------- */\n    CPLXMLNode *psRoot = nullptr;\n    CPLXMLNode *psTail = nullptr;\n\n    const char *pszCopySrcMDD =\n        CSLFetchNameValueDef(papszCreationOptions, \"COPY_SRC_MDD\", \"AUTO\");\n    char **papszSrcMDD =\n        CSLFetchNameValueMultiple(papszCreationOptions, \"SRC_MDD\");\n\n    if (bSrcIsGeoTIFF)\n    {\n        GTiffDataset *poSrcDSGTiff = cpl::down_cast<GTiffDataset *>(poSrcDS);\n        assert(poSrcDSGTiff);\n        WriteMDMetadata(&poSrcDSGTiff->m_oGTiffMDMD, l_hTIFF, &psRoot, &psTail,\n                        0, eProfile);\n    }\n    else\n    {\n        if (EQUAL(pszCopySrcMDD, \"AUTO\") || CPLTestBool(pszCopySrcMDD) ||\n            papszSrcMDD)\n        {\n            GDALMultiDomainMetadata l_oMDMD;\n            CSLConstList papszMD = poSrcDS->GetMetadata();\n            if (CSLCount(papszMD) > 0 &&\n                (!papszSrcMDD || CSLFindString(papszSrcMDD, \"\") >= 0 ||\n                 CSLFindString(papszSrcMDD, \"_DEFAULT_\") >= 0))\n            {\n                l_oMDMD.SetMetadata(papszMD);\n            }\n\n            if ((!EQUAL(pszCopySrcMDD, \"AUTO\") && CPLTestBool(pszCopySrcMDD)) ||\n                papszSrcMDD)\n            {\n                char **papszDomainList = poSrcDS->GetMetadataDomainList();\n                for (CSLConstList papszIter = papszDomainList;\n                     papszIter && *papszIter; ++papszIter)\n                {\n                    const char *pszDomain = *papszIter;\n                    if (pszDomain[0] != 0 &&\n                        (!papszSrcMDD ||\n                         CSLFindString(papszSrcMDD, pszDomain) >= 0))\n                    {\n                        l_oMDMD.SetMetadata(poSrcDS->GetMetadata(pszDomain),\n                                            pszDomain);\n                    }\n                }\n                CSLDestroy(papszDomainList);\n            }\n\n            WriteMDMetadata(&l_oMDMD, l_hTIFF, &psRoot, &psTail, 0, eProfile);\n        }\n    }\n\n    if (!bExcludeRPBandIMGFileWriting)\n    {\n        WriteRPC(poSrcDS, l_hTIFF, bSrcIsGeoTIFF, eProfile, pszTIFFFilename,\n                 papszCreationOptions);\n\n        /* --------------------------------------------------------------------\n         */\n        /*      Handle metadata data written to an IMD file. */\n        /* --------------------------------------------------------------------\n         */\n        char **papszIMDMD = poSrcDS->GetMetadata(MD_DOMAIN_IMD);\n        if (papszIMDMD != nullptr)\n        {\n            GDALWriteIMDFile(pszTIFFFilename, papszIMDMD);\n        }\n    }\n\n    uint16_t nPhotometric = 0;\n    if (!TIFFGetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric)))\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    const bool bStandardColorInterp = GTIFFIsStandardColorInterpretation(\n        GDALDataset::ToHandle(poSrcDS), nPhotometric, papszCreationOptions);\n\n    /* -------------------------------------------------------------------- */\n    /*      We also need to address band specific metadata, and special     */\n    /*      \"role\" metadata.                                                */\n    /* -------------------------------------------------------------------- */\n    for (int nBand = 1; nBand <= poSrcDS->GetRasterCount(); ++nBand)\n    {\n        GDALRasterBand *poBand = poSrcDS->GetRasterBand(nBand);\n\n        if (bSrcIsGeoTIFF)\n        {\n            GTiffRasterBand *poSrcBandGTiff =\n                cpl::down_cast<GTiffRasterBand *>(poBand);\n            assert(poSrcBandGTiff);\n            WriteMDMetadata(&poSrcBandGTiff->m_oGTiffMDMD, l_hTIFF, &psRoot,\n                            &psTail, nBand, eProfile);\n        }\n        else\n        {\n            GDALMultiDomainMetadata l_oMDMD;\n            bool bOMDMDSet = false;\n\n            if (EQUAL(pszCopySrcMDD, \"AUTO\") && !papszSrcMDD)\n            {\n                for (const char *pszDomain : {\"\", \"IMAGERY\"})\n                {\n                    if (CSLConstList papszMD = poBand->GetMetadata(pszDomain))\n                    {\n                        if (papszMD[0])\n                        {\n                            bOMDMDSet = true;\n                            l_oMDMD.SetMetadata(papszMD, pszDomain);\n                        }\n                    }\n                }\n            }\n            else if (CPLTestBool(pszCopySrcMDD) || papszSrcMDD)\n            {\n                char **papszDomainList = poBand->GetMetadataDomainList();\n                for (const char *pszDomain :\n                     cpl::Iterate(CSLConstList(papszDomainList)))\n                {\n                    if (pszDomain[0] != 0 &&\n                        !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") &&\n                        (!papszSrcMDD ||\n                         CSLFindString(papszSrcMDD, pszDomain) >= 0))\n                    {\n                        bOMDMDSet = true;\n                        l_oMDMD.SetMetadata(poBand->GetMetadata(pszDomain),\n                                            pszDomain);\n                    }\n                }\n                CSLDestroy(papszDomainList);\n            }\n\n            if (bOMDMDSet)\n            {\n                WriteMDMetadata(&l_oMDMD, l_hTIFF, &psRoot, &psTail, nBand,\n                                eProfile);\n            }\n        }\n\n        const double dfOffset = poBand->GetOffset();\n        const double dfScale = poBand->GetScale();\n        bool bGeoTIFFScaleOffsetInZ = false;\n        double adfGeoTransform[6];\n        // Check if we have already encoded scale/offset in the GeoTIFF tags\n        if (poSrcDS->GetGeoTransform(adfGeoTransform) == CE_None &&\n            adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0 &&\n            adfGeoTransform[5] < 0.0 && poSrcDS->GetSpatialRef() &&\n            poSrcDS->GetSpatialRef()->IsVertical() &&\n            poSrcDS->GetRasterCount() == 1)\n        {\n            bGeoTIFFScaleOffsetInZ = true;\n        }\n\n        if ((dfOffset != 0.0 || dfScale != 1.0) && !bGeoTIFFScaleOffsetInZ)\n        {\n            char szValue[128] = {};\n\n            CPLsnprintf(szValue, sizeof(szValue), \"%.17g\", dfOffset);\n            AppendMetadataItem(&psRoot, &psTail, \"OFFSET\", szValue, nBand,\n                               \"offset\", \"\");\n            CPLsnprintf(szValue, sizeof(szValue), \"%.17g\", dfScale);\n            AppendMetadataItem(&psRoot, &psTail, \"SCALE\", szValue, nBand,\n                               \"scale\", \"\");\n        }\n\n        const char *pszUnitType = poBand->GetUnitType();\n        if (pszUnitType != nullptr && pszUnitType[0] != '\\0')\n        {\n            bool bWriteUnit = true;\n            auto poSRS = poSrcDS->GetSpatialRef();\n            if (poSRS && poSRS->IsCompound())\n            {\n                const char *pszVertUnit = nullptr;\n                poSRS->GetTargetLinearUnits(\"COMPD_CS|VERT_CS\", &pszVertUnit);\n                if (pszVertUnit && EQUAL(pszVertUnit, pszUnitType))\n                {\n                    bWriteUnit = false;\n                }\n            }\n            if (bWriteUnit)\n            {\n                AppendMetadataItem(&psRoot, &psTail, \"UNITTYPE\", pszUnitType,\n                                   nBand, \"unittype\", \"\");\n            }\n        }\n\n        if (strlen(poBand->GetDescription()) > 0)\n        {\n            AppendMetadataItem(&psRoot, &psTail, \"DESCRIPTION\",\n                               poBand->GetDescription(), nBand, \"description\",\n                               \"\");\n        }\n\n        if (!bStandardColorInterp &&\n            !(nBand <= 3 && EQUAL(CSLFetchNameValueDef(papszCreationOptions,\n                                                       \"PHOTOMETRIC\", \"\"),\n                                  \"RGB\")))\n        {\n            AppendMetadataItem(&psRoot, &psTail, \"COLORINTERP\",\n                               GDALGetColorInterpretationName(\n                                   poBand->GetColorInterpretation()),\n                               nBand, \"colorinterp\", \"\");\n        }\n    }\n\n    CSLDestroy(papszSrcMDD);\n\n    const char *pszTilingSchemeName =\n        CSLFetchNameValue(papszCreationOptions, \"@TILING_SCHEME_NAME\");\n    if (pszTilingSchemeName)\n    {\n        AppendMetadataItem(&psRoot, &psTail, \"NAME\", pszTilingSchemeName, 0,\n                           nullptr, \"TILING_SCHEME\");\n\n        const char *pszZoomLevel = CSLFetchNameValue(\n            papszCreationOptions, \"@TILING_SCHEME_ZOOM_LEVEL\");\n        if (pszZoomLevel)\n        {\n            AppendMetadataItem(&psRoot, &psTail, \"ZOOM_LEVEL\", pszZoomLevel, 0,\n                               nullptr, \"TILING_SCHEME\");\n        }\n\n        const char *pszAlignedLevels = CSLFetchNameValue(\n            papszCreationOptions, \"@TILING_SCHEME_ALIGNED_LEVELS\");\n        if (pszAlignedLevels)\n        {\n            AppendMetadataItem(&psRoot, &psTail, \"ALIGNED_LEVELS\",\n                               pszAlignedLevels, 0, nullptr, \"TILING_SCHEME\");\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write information about some codecs.                            */\n    /* -------------------------------------------------------------------- */\n    if (CPLTestBool(\n            CPLGetConfigOption(\"GTIFF_WRITE_IMAGE_STRUCTURE_METADATA\", \"YES\")))\n    {\n        const char *pszTileInterleave =\n            CSLFetchNameValue(papszCreationOptions, \"@TILE_INTERLEAVE\");\n        if (pszTileInterleave && CPLTestBool(pszTileInterleave))\n        {\n            AppendMetadataItem(&psRoot, &psTail, \"INTERLEAVE\", \"TILE\", 0,\n                               nullptr, \"IMAGE_STRUCTURE\");\n        }\n\n        const char *pszCompress =\n            CSLFetchNameValue(papszCreationOptions, \"COMPRESS\");\n        if (pszCompress && EQUAL(pszCompress, \"WEBP\"))\n        {\n            if (GTiffGetWebPLossless(papszCreationOptions))\n            {\n                AppendMetadataItem(&psRoot, &psTail,\n                                   \"COMPRESSION_REVERSIBILITY\", \"LOSSLESS\", 0,\n                                   nullptr, \"IMAGE_STRUCTURE\");\n            }\n            else\n            {\n                AppendMetadataItem(\n                    &psRoot, &psTail, \"WEBP_LEVEL\",\n                    CPLSPrintf(\"%d\", GTiffGetWebPLevel(papszCreationOptions)),\n                    0, nullptr, \"IMAGE_STRUCTURE\");\n            }\n        }\n        else if (pszCompress && STARTS_WITH_CI(pszCompress, \"LERC\"))\n        {\n            const double dfMaxZError =\n                GTiffGetLERCMaxZError(papszCreationOptions);\n            const double dfMaxZErrorOverview =\n                GTiffGetLERCMaxZErrorOverview(papszCreationOptions);\n            if (dfMaxZError == 0.0 && dfMaxZErrorOverview == 0.0)\n            {\n                AppendMetadataItem(&psRoot, &psTail,\n                                   \"COMPRESSION_REVERSIBILITY\", \"LOSSLESS\", 0,\n                                   nullptr, \"IMAGE_STRUCTURE\");\n            }\n            else\n            {\n                AppendMetadataItem(&psRoot, &psTail, \"MAX_Z_ERROR\",\n                                   CSLFetchNameValueDef(papszCreationOptions,\n                                                        \"MAX_Z_ERROR\", \"\"),\n                                   0, nullptr, \"IMAGE_STRUCTURE\");\n                if (dfMaxZError != dfMaxZErrorOverview)\n                {\n                    AppendMetadataItem(\n                        &psRoot, &psTail, \"MAX_Z_ERROR_OVERVIEW\",\n                        CSLFetchNameValueDef(papszCreationOptions,\n                                             \"MAX_Z_ERROR_OVERVIEW\", \"\"),\n                        0, nullptr, \"IMAGE_STRUCTURE\");\n                }\n            }\n        }\n#if HAVE_JXL\n        else if (pszCompress && EQUAL(pszCompress, \"JXL\"))\n        {\n            float fDistance = 0.0f;\n            if (GTiffGetJXLLossless(papszCreationOptions))\n            {\n                AppendMetadataItem(&psRoot, &psTail,\n                                   \"COMPRESSION_REVERSIBILITY\", \"LOSSLESS\", 0,\n                                   nullptr, \"IMAGE_STRUCTURE\");\n            }\n            else\n            {\n                fDistance = GTiffGetJXLDistance(papszCreationOptions);\n                AppendMetadataItem(&psRoot, &psTail, \"JXL_DISTANCE\",\n                                   CPLSPrintf(\"%f\", fDistance), 0, nullptr,\n                                   \"IMAGE_STRUCTURE\");\n            }\n            const float fAlphaDistance =\n                GTiffGetJXLAlphaDistance(papszCreationOptions);\n            if (fAlphaDistance >= 0.0f && fAlphaDistance != fDistance)\n            {\n                AppendMetadataItem(&psRoot, &psTail, \"JXL_ALPHA_DISTANCE\",\n                                   CPLSPrintf(\"%f\", fAlphaDistance), 0, nullptr,\n                                   \"IMAGE_STRUCTURE\");\n            }\n            AppendMetadataItem(\n                &psRoot, &psTail, \"JXL_EFFORT\",\n                CPLSPrintf(\"%d\", GTiffGetJXLEffort(papszCreationOptions)), 0,\n                nullptr, \"IMAGE_STRUCTURE\");\n        }\n#endif\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write out the generic XML metadata if there is any.             */\n    /* -------------------------------------------------------------------- */\n    if (psRoot != nullptr)\n    {\n        bool bRet = true;\n\n        if (eProfile == GTiffProfile::GDALGEOTIFF)\n        {\n            char *pszXML_MD = CPLSerializeXMLTree(psRoot);\n            TIFFSetField(l_hTIFF, TIFFTAG_GDAL_METADATA, pszXML_MD);\n            CPLFree(pszXML_MD);\n        }\n        else\n        {\n            if (bSrcIsGeoTIFF)\n                cpl::down_cast<GTiffDataset *>(poSrcDS)->PushMetadataToPam();\n            else\n                bRet = false;\n        }\n\n        CPLDestroyXMLNode(psRoot);\n\n        return bRet;\n    }\n\n    // If we have no more metadata but it existed before,\n    // remove the GDAL_METADATA tag.\n    if (eProfile == GTiffProfile::GDALGEOTIFF)\n    {\n        char *pszText = nullptr;\n        if (TIFFGetField(l_hTIFF, TIFFTAG_GDAL_METADATA, &pszText))\n        {\n            TIFFUnsetField(l_hTIFF, TIFFTAG_GDAL_METADATA);\n        }\n    }\n\n    return true;\n}",
    "static GTiffDataset::MaskOffset *GetDiscardLsbOption(TIFF *hTIFF,\n                                                     char **papszOptions)\n{\n    const char *pszBits = CSLFetchNameValue(papszOptions, \"DISCARD_LSB\");\n    if (pszBits == nullptr)\n        return nullptr;\n\n    uint16_t nPhotometric = 0;\n    TIFFGetFieldDefaulted(hTIFF, TIFFTAG_PHOTOMETRIC, &nPhotometric);\n\n    uint16_t nBitsPerSample = 0;\n    if (!TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &nBitsPerSample))\n        nBitsPerSample = 1;\n\n    uint16_t nSamplesPerPixel = 0;\n    if (!TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSamplesPerPixel))\n        nSamplesPerPixel = 1;\n\n    uint16_t nSampleFormat = 0;\n    if (!TIFFGetField(hTIFF, TIFFTAG_SAMPLEFORMAT, &nSampleFormat))\n        nSampleFormat = SAMPLEFORMAT_UINT;\n\n    if (nPhotometric == PHOTOMETRIC_PALETTE)\n    {\n        CPLError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored on a paletted image\");\n        return nullptr;\n    }\n    if (!(nBitsPerSample == 8 || nBitsPerSample == 16 || nBitsPerSample == 32 ||\n          nBitsPerSample == 64))\n    {\n        CPLError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored on non 8, 16, 32 or 64 bits images\");\n        return nullptr;\n    }\n\n    const CPLStringList aosTokens(CSLTokenizeString2(pszBits, \",\", 0));\n    const int nTokens = aosTokens.size();\n    GTiffDataset::MaskOffset *panMaskOffsetLsb = nullptr;\n    if (nTokens == 1 || nTokens == nSamplesPerPixel)\n    {\n        panMaskOffsetLsb = static_cast<GTiffDataset::MaskOffset *>(\n            CPLCalloc(nSamplesPerPixel, sizeof(GTiffDataset::MaskOffset)));\n        for (int i = 0; i < nSamplesPerPixel; ++i)\n        {\n            const int nBits = atoi(aosTokens[nTokens == 1 ? 0 : i]);\n            const int nMaxBits = (nSampleFormat == SAMPLEFORMAT_IEEEFP)\n                                     ? ((nBitsPerSample == 32)   ? 23 - 1\n                                        : (nBitsPerSample == 64) ? 53 - 1\n                                                                 : 0)\n                                 : nSampleFormat == SAMPLEFORMAT_INT\n                                     ? nBitsPerSample - 2\n                                     : nBitsPerSample - 1;\n\n            if (nBits < 0 || nBits > nMaxBits)\n            {\n                CPLError(\n                    CE_Warning, CPLE_AppDefined,\n                    \"DISCARD_LSB ignored: values should be in [0,%d] range\",\n                    nMaxBits);\n                VSIFree(panMaskOffsetLsb);\n                return nullptr;\n            }\n            panMaskOffsetLsb[i].nMask =\n                ~((static_cast<uint64_t>(1) << nBits) - 1);\n            if (nBits > 1)\n            {\n                panMaskOffsetLsb[i].nRoundUpBitTest = static_cast<uint64_t>(1)\n                                                      << (nBits - 1);\n            }\n        }\n    }\n    else\n    {\n        CPLError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored: wrong number of components\");\n    }\n    return panMaskOffsetLsb;\n}",
    "int GTiffDataset::GuessJPEGQuality(bool &bOutHasQuantizationTable,\n                                   bool &bOutHasHuffmanTable)\n{\n    CPLAssert(m_nCompression == COMPRESSION_JPEG);\n    uint32_t nJPEGTableSize = 0;\n    void *pJPEGTable = nullptr;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize,\n                      &pJPEGTable))\n    {\n        bOutHasQuantizationTable = false;\n        bOutHasHuffmanTable = false;\n        return -1;\n    }\n\n    bOutHasQuantizationTable =\n        GTIFFFindNextTable(static_cast<const GByte *>(pJPEGTable),\n                           MARKER_QUANT_TABLE, nJPEGTableSize,\n                           nullptr) != nullptr;\n    bOutHasHuffmanTable =\n        GTIFFFindNextTable(static_cast<const GByte *>(pJPEGTable),\n                           MARKER_HUFFMAN_TABLE, nJPEGTableSize,\n                           nullptr) != nullptr;\n    if (!bOutHasQuantizationTable)\n        return -1;\n\n    if ((nBands == 1 && m_nBitsPerSample == 8) ||\n        (nBands == 3 && m_nBitsPerSample == 8 &&\n         m_nPhotometric == PHOTOMETRIC_RGB) ||\n        (nBands == 4 && m_nBitsPerSample == 8 &&\n         m_nPhotometric == PHOTOMETRIC_SEPARATED))\n    {\n        return GuessJPEGQualityFromMD5(md5JPEGQuantTable_generic_8bit,\n                                       static_cast<const GByte *>(pJPEGTable),\n                                       static_cast<int>(nJPEGTableSize));\n    }\n\n    if (nBands == 3 && m_nBitsPerSample == 8 &&\n        m_nPhotometric == PHOTOMETRIC_YCBCR)\n    {\n        int nRet =\n            GuessJPEGQualityFromMD5(md5JPEGQuantTable_3_YCBCR_8bit,\n                                    static_cast<const GByte *>(pJPEGTable),\n                                    static_cast<int>(nJPEGTableSize));\n        if (nRet < 0)\n        {\n            // libjpeg 9e has modified the YCbCr quantization tables.\n            nRet =\n                GuessJPEGQualityFromMD5(md5JPEGQuantTable_3_YCBCR_8bit_jpeg9e,\n                                        static_cast<const GByte *>(pJPEGTable),\n                                        static_cast<int>(nJPEGTableSize));\n        }\n        return nRet;\n    }\n\n    char **papszLocalParameters = nullptr;\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"COMPRESS\", \"JPEG\");\n    if (m_nPhotometric == PHOTOMETRIC_YCBCR)\n        papszLocalParameters =\n            CSLSetNameValue(papszLocalParameters, \"PHOTOMETRIC\", \"YCBCR\");\n    else if (m_nPhotometric == PHOTOMETRIC_SEPARATED)\n        papszLocalParameters =\n            CSLSetNameValue(papszLocalParameters, \"PHOTOMETRIC\", \"CMYK\");\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"BLOCKYSIZE\", \"16\");\n    if (m_nBitsPerSample == 12)\n        papszLocalParameters =\n            CSLSetNameValue(papszLocalParameters, \"NBITS\", \"12\");\n\n    const CPLString osTmpFilenameIn(\n        VSIMemGenerateHiddenFilename(\"gtiffdataset_guess_jpeg_quality_tmp\"));\n\n    int nRet = -1;\n    for (int nQuality = 0; nQuality <= 100 && nRet < 0; ++nQuality)\n    {\n        VSILFILE *fpTmp = nullptr;\n        if (nQuality == 0)\n            papszLocalParameters =\n                CSLSetNameValue(papszLocalParameters, \"JPEG_QUALITY\", \"75\");\n        else\n            papszLocalParameters =\n                CSLSetNameValue(papszLocalParameters, \"JPEG_QUALITY\",\n                                CPLSPrintf(\"%d\", nQuality));\n\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        CPLString osTmp;\n        bool bTileInterleaving;\n        TIFF *hTIFFTmp = CreateLL(\n            osTmpFilenameIn, 16, 16, (nBands <= 4) ? nBands : 1,\n            GetRasterBand(1)->GetRasterDataType(), 0.0, 0, papszLocalParameters,\n            &fpTmp, osTmp, /* bCreateCopy=*/false, bTileInterleaving);\n        CPLPopErrorHandler();\n        if (!hTIFFTmp)\n        {\n            break;\n        }\n\n        TIFFWriteCheck(hTIFFTmp, FALSE, \"CreateLL\");\n        TIFFWriteDirectory(hTIFFTmp);\n        TIFFSetDirectory(hTIFFTmp, 0);\n        // Now reset jpegcolormode.\n        if (m_nPhotometric == PHOTOMETRIC_YCBCR &&\n            CPLTestBool(CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\")))\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n\n        GByte abyZeroData[(16 * 16 * 4 * 3) / 2] = {};\n        const int nBlockSize =\n            (16 * 16 * ((nBands <= 4) ? nBands : 1) * m_nBitsPerSample) / 8;\n        TIFFWriteEncodedStrip(hTIFFTmp, 0, abyZeroData, nBlockSize);\n\n        uint32_t nJPEGTableSizeTry = 0;\n        void *pJPEGTableTry = nullptr;\n        if (TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSizeTry,\n                         &pJPEGTableTry))\n        {\n            if (GTIFFQuantizationTablesEqual(\n                    static_cast<GByte *>(pJPEGTable), nJPEGTableSize,\n                    static_cast<GByte *>(pJPEGTableTry), nJPEGTableSizeTry))\n            {\n                nRet = (nQuality == 0) ? 75 : nQuality;\n            }\n        }\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n\n    CSLDestroy(papszLocalParameters);\n    VSIUnlink(osTmpFilenameIn);\n\n    return nRet;\n}",
    "void GTiffDataset::SetJPEGQualityAndTablesModeFromFile(\n    int nQuality, bool bHasQuantizationTable, bool bHasHuffmanTable)\n{\n    if (nQuality > 0)\n    {\n        CPLDebug(\"GTiff\", \"Guessed JPEG quality to be %d\", nQuality);\n        m_nJpegQuality = static_cast<signed char>(nQuality);\n        TIFFSetField(m_hTIFF, TIFFTAG_JPEGQUALITY, nQuality);\n\n        // This means we will use the quantization tables from the\n        // JpegTables tag.\n        m_nJpegTablesMode = JPEGTABLESMODE_QUANT;\n    }\n    else\n    {\n        uint32_t nJPEGTableSize = 0;\n        void *pJPEGTable = nullptr;\n        if (!TIFFGetField(m_hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize,\n                          &pJPEGTable))\n        {\n            toff_t *panByteCounts = nullptr;\n            const int nBlockCount = m_nPlanarConfig == PLANARCONFIG_SEPARATE\n                                        ? m_nBlocksPerBand * nBands\n                                        : m_nBlocksPerBand;\n            if (TIFFIsTiled(m_hTIFF))\n                TIFFGetField(m_hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts);\n            else\n                TIFFGetField(m_hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts);\n\n            bool bFoundNonEmptyBlock = false;\n            if (panByteCounts != nullptr)\n            {\n                for (int iBlock = 0; iBlock < nBlockCount; ++iBlock)\n                {\n                    if (panByteCounts[iBlock] != 0)\n                    {\n                        bFoundNonEmptyBlock = true;\n                        break;\n                    }\n                }\n            }\n            if (bFoundNonEmptyBlock)\n            {\n                CPLDebug(\"GTiff\", \"Could not guess JPEG quality. \"\n                                  \"JPEG tables are missing, so going in \"\n                                  \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n                // Write quantization tables in each strile.\n                m_nJpegTablesMode = 0;\n            }\n        }\n        else\n        {\n            if (bHasQuantizationTable)\n            {\n                // FIXME in libtiff: this is likely going to cause issues\n                // since libtiff will reuse in each strile the number of\n                // the global quantization table, which is invalid.\n                CPLDebug(\"GTiff\",\n                         \"Could not guess JPEG quality although JPEG \"\n                         \"quantization tables are present, so going in \"\n                         \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n            }\n            else\n            {\n                CPLDebug(\"GTiff\",\n                         \"Could not guess JPEG quality since JPEG \"\n                         \"quantization tables are not present, so going in \"\n                         \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n            }\n\n            // Write quantization tables in each strile.\n            m_nJpegTablesMode = 0;\n        }\n    }\n    if (bHasHuffmanTable)\n    {\n        // If there are Huffman tables in header use them, otherwise\n        // if we use optimized tables, libtiff will currently reuse\n        // the number of the Huffman tables of the header for the\n        // optimized version of each strile, which is illegal.\n        m_nJpegTablesMode |= JPEGTABLESMODE_HUFF;\n    }\n    if (m_nJpegTablesMode >= 0)\n        TIFFSetField(m_hTIFF, TIFFTAG_JPEGTABLESMODE, m_nJpegTablesMode);\n}",
    "GDALDataset *GTiffDataset::Create(const char *pszFilename, int nXSize,\n                                  int nYSize, int l_nBands, GDALDataType eType,\n                                  char **papszParamList)\n\n{\n    VSILFILE *l_fpL = nullptr;\n    CPLString l_osTmpFilename;\n\n    const int nColorTableMultiplier = std::max(\n        1,\n        std::min(257,\n                 atoi(CSLFetchNameValueDef(\n                     papszParamList, \"COLOR_TABLE_MULTIPLIER\",\n                     CPLSPrintf(\"%d\", DEFAULT_COLOR_TABLE_MULTIPLIER_257)))));\n\n    /* -------------------------------------------------------------------- */\n    /*      Create the underlying TIFF file.                                */\n    /* -------------------------------------------------------------------- */\n    bool bTileInterleaving;\n    TIFF *l_hTIFF =\n        CreateLL(pszFilename, nXSize, nYSize, l_nBands, eType, 0,\n                 nColorTableMultiplier, papszParamList, &l_fpL, l_osTmpFilename,\n                 /* bCreateCopy=*/false, bTileInterleaving);\n    const bool bStreaming = !l_osTmpFilename.empty();\n\n    if (l_hTIFF == nullptr)\n        return nullptr;\n\n    /* -------------------------------------------------------------------- */\n    /*      Create the new GTiffDataset object.                             */\n    /* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->m_hTIFF = l_hTIFF;\n    poDS->m_fpL = l_fpL;\n    if (bStreaming)\n    {\n        poDS->m_bStreamingOut = true;\n        poDS->m_pszTmpFilename = CPLStrdup(l_osTmpFilename);\n        poDS->m_fpToWrite = VSIFOpenL(pszFilename, \"wb\");\n        if (poDS->m_fpToWrite == nullptr)\n        {\n            VSIUnlink(l_osTmpFilename);\n            delete poDS;\n            return nullptr;\n        }\n    }\n    poDS->nRasterXSize = nXSize;\n    poDS->nRasterYSize = nYSize;\n    poDS->eAccess = GA_Update;\n\n    poDS->m_nColorTableMultiplier = nColorTableMultiplier;\n\n    poDS->m_bCrystalized = false;\n    poDS->m_nSamplesPerPixel = static_cast<uint16_t>(l_nBands);\n    poDS->m_pszFilename = CPLStrdup(pszFilename);\n\n    // Don't try to load external metadata files (#6597).\n    poDS->m_bIMDRPCMetadataLoaded = true;\n\n    // Avoid premature crystalization that will cause directory re-writing if\n    // GetProjectionRef() or GetGeoTransform() are called on the newly created\n    // GeoTIFF.\n    poDS->m_bLookedForProjection = true;\n\n    TIFFGetField(l_hTIFF, TIFFTAG_SAMPLEFORMAT, &(poDS->m_nSampleFormat));\n    TIFFGetField(l_hTIFF, TIFFTAG_PLANARCONFIG, &(poDS->m_nPlanarConfig));\n    // Weird that we need this, but otherwise we get a Valgrind warning on\n    // tiff_write_124.\n    if (!TIFFGetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, &(poDS->m_nPhotometric)))\n        poDS->m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n    TIFFGetField(l_hTIFF, TIFFTAG_BITSPERSAMPLE, &(poDS->m_nBitsPerSample));\n    TIFFGetField(l_hTIFF, TIFFTAG_COMPRESSION, &(poDS->m_nCompression));\n\n    if (TIFFIsTiled(l_hTIFF))\n    {\n        TIFFGetField(l_hTIFF, TIFFTAG_TILEWIDTH, &(poDS->m_nBlockXSize));\n        TIFFGetField(l_hTIFF, TIFFTAG_TILELENGTH, &(poDS->m_nBlockYSize));\n    }\n    else\n    {\n        if (!TIFFGetField(l_hTIFF, TIFFTAG_ROWSPERSTRIP,\n                          &(poDS->m_nRowsPerStrip)))\n            poDS->m_nRowsPerStrip = 1;  // Dummy value.\n\n        poDS->m_nBlockXSize = nXSize;\n        poDS->m_nBlockYSize =\n            std::min(static_cast<int>(poDS->m_nRowsPerStrip), nYSize);\n    }\n\n    if (!poDS->ComputeBlocksPerColRowAndBand(l_nBands))\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    poDS->m_eProfile = GetProfile(CSLFetchNameValue(papszParamList, \"PROFILE\"));\n\n    /* -------------------------------------------------------------------- */\n    /*      YCbCr JPEG compressed images should be translated on the fly    */\n    /*      to RGB by libtiff/libjpeg unless specifically requested         */\n    /*      otherwise.                                                      */\n    /* -------------------------------------------------------------------- */\n    if (poDS->m_nCompression == COMPRESSION_JPEG &&\n        poDS->m_nPhotometric == PHOTOMETRIC_YCBCR &&\n        CPLTestBool(CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\")))\n    {\n        int nColorMode = 0;\n\n        poDS->SetMetadataItem(\"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\");\n        if (!TIFFGetField(l_hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode) ||\n            nColorMode != JPEGCOLORMODE_RGB)\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n    if (poDS->m_nCompression == COMPRESSION_LERC)\n    {\n        uint32_t nLercParamCount = 0;\n        uint32_t *panLercParams = nullptr;\n        if (TIFFGetField(l_hTIFF, TIFFTAG_LERC_PARAMETERS, &nLercParamCount,\n                         &panLercParams) &&\n            nLercParamCount == 2)\n        {\n            memcpy(poDS->m_anLercAddCompressionAndVersion, panLercParams,\n                   sizeof(poDS->m_anLercAddCompressionAndVersion));\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Read palette back as a color table if it has one.               */\n    /* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if (poDS->m_nPhotometric == PHOTOMETRIC_PALETTE &&\n        TIFFGetField(l_hTIFF, TIFFTAG_COLORMAP, &panRed, &panGreen, &panBlue))\n    {\n\n        poDS->m_poColorTable = std::make_unique<GDALColorTable>();\n\n        const int nColorCount = 1 << poDS->m_nBitsPerSample;\n\n        for (int iColor = nColorCount - 1; iColor >= 0; iColor--)\n        {\n            const GDALColorEntry oEntry = {\n                static_cast<short>(panRed[iColor] / nColorTableMultiplier),\n                static_cast<short>(panGreen[iColor] / nColorTableMultiplier),\n                static_cast<short>(panBlue[iColor] / nColorTableMultiplier),\n                static_cast<short>(255)};\n\n            poDS->m_poColorTable->SetColorEntry(iColor, &oEntry);\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Do we want to ensure all blocks get written out on close to     */\n    /*      avoid sparse files?                                             */\n    /* -------------------------------------------------------------------- */\n    if (!CPLFetchBool(papszParamList, \"SPARSE_OK\", false))\n        poDS->m_bFillEmptyTilesAtClosing = true;\n\n    poDS->m_bWriteEmptyTiles =\n        bStreaming || (poDS->m_nCompression != COMPRESSION_NONE &&\n                       poDS->m_bFillEmptyTilesAtClosing);\n    // Only required for people writing non-compressed striped files in the\n    // right order and wanting all tstrips to be written in the same order\n    // so that the end result can be memory mapped without knowledge of each\n    // strip offset.\n    if (CPLTestBool(CSLFetchNameValueDef(\n            papszParamList, \"WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\")) ||\n        CPLTestBool(CSLFetchNameValueDef(\n            papszParamList, \"@WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\")))\n    {\n        poDS->m_bWriteEmptyTiles = true;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Preserve creation options for consulting later (for instance    */\n    /*      to decide if a TFW file should be written).                     */\n    /* -------------------------------------------------------------------- */\n    poDS->m_papszCreationOptions = CSLDuplicate(papszParamList);\n\n    poDS->m_nZLevel = GTiffGetZLevel(papszParamList);\n    poDS->m_nLZMAPreset = GTiffGetLZMAPreset(papszParamList);\n    poDS->m_nZSTDLevel = GTiffGetZSTDPreset(papszParamList);\n    poDS->m_nWebPLevel = GTiffGetWebPLevel(papszParamList);\n    poDS->m_bWebPLossless = GTiffGetWebPLossless(papszParamList);\n    if (poDS->m_nWebPLevel != 100 && poDS->m_bWebPLossless &&\n        CSLFetchNameValue(papszParamList, \"WEBP_LEVEL\"))\n    {\n        CPLError(CE_Warning, CPLE_AppDefined,\n                 \"WEBP_LEVEL is specified, but WEBP_LOSSLESS=YES. \"\n                 \"WEBP_LEVEL will be ignored.\");\n    }\n    poDS->m_nJpegQuality = GTiffGetJpegQuality(papszParamList);\n    poDS->m_nJpegTablesMode = GTiffGetJpegTablesMode(papszParamList);\n    poDS->m_dfMaxZError = GTiffGetLERCMaxZError(papszParamList);\n    poDS->m_dfMaxZErrorOverview = GTiffGetLERCMaxZErrorOverview(papszParamList);\n#if HAVE_JXL\n    poDS->m_bJXLLossless = GTiffGetJXLLossless(papszParamList);\n    poDS->m_nJXLEffort = GTiffGetJXLEffort(papszParamList);\n    poDS->m_fJXLDistance = GTiffGetJXLDistance(papszParamList);\n    poDS->m_fJXLAlphaDistance = GTiffGetJXLAlphaDistance(papszParamList);\n#endif\n    poDS->InitCreationOrOpenOptions(true, papszParamList);\n\n    /* -------------------------------------------------------------------- */\n    /*      Create band information objects.                                */\n    /* -------------------------------------------------------------------- */\n    for (int iBand = 0; iBand < l_nBands; ++iBand)\n    {\n        if (poDS->m_nBitsPerSample == 8 ||\n            (poDS->m_nBitsPerSample == 16 && eType != GDT_Float32) ||\n            poDS->m_nBitsPerSample == 32 || poDS->m_nBitsPerSample == 64 ||\n            poDS->m_nBitsPerSample == 128)\n        {\n            poDS->SetBand(iBand + 1, new GTiffRasterBand(poDS, iBand + 1));\n        }\n        else\n        {\n            poDS->SetBand(iBand + 1, new GTiffOddBitsBand(poDS, iBand + 1));\n            poDS->GetRasterBand(iBand + 1)->SetMetadataItem(\n                \"NBITS\", CPLString().Printf(\"%d\", poDS->m_nBitsPerSample),\n                \"IMAGE_STRUCTURE\");\n        }\n    }\n\n    poDS->GetDiscardLsbOption(papszParamList);\n\n    if (poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG && l_nBands != 1)\n        poDS->SetMetadataItem(\"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\");\n    else\n        poDS->SetMetadataItem(\"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\");\n\n    poDS->oOvManager.Initialize(poDS, pszFilename);\n\n    return poDS;\n}",
    "CPLErr GTiffDataset::CreateMaskBand(int nFlagsIn)\n{\n    ScanDirectories();\n\n    if (m_poMaskDS != nullptr)\n    {\n        ReportError(CE_Failure, CPLE_AppDefined,\n                    \"This TIFF dataset has already an internal mask band\");\n        return CE_Failure;\n    }\n    else if (MustCreateInternalMask())\n    {\n        if (nFlagsIn != GMF_PER_DATASET)\n        {\n            ReportError(CE_Failure, CPLE_AppDefined,\n                        \"The only flag value supported for internal mask is \"\n                        \"GMF_PER_DATASET\");\n            return CE_Failure;\n        }\n\n        int l_nCompression = COMPRESSION_PACKBITS;\n        if (strstr(GDALGetMetadataItem(GDALGetDriverByName(\"GTiff\"),\n                                       GDAL_DMD_CREATIONOPTIONLIST, nullptr),\n                   \"<Value>DEFLATE</Value>\") != nullptr)\n            l_nCompression = COMPRESSION_ADOBE_DEFLATE;\n\n        /* --------------------------------------------------------------------\n         */\n        /*      If we don't have read access, then create the mask externally.\n         */\n        /* --------------------------------------------------------------------\n         */\n        if (GetAccess() != GA_Update)\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                        \"File open for read-only accessing, \"\n                        \"creating mask externally.\");\n\n            return GDALPamDataset::CreateMaskBand(nFlagsIn);\n        }\n\n        if (m_bLayoutIFDSBeforeData && !m_bKnownIncompatibleEdition &&\n            !m_bWriteKnownIncompatibleEdition)\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                        \"Adding a mask invalidates the \"\n                        \"LAYOUT=IFDS_BEFORE_DATA property\");\n            m_bKnownIncompatibleEdition = true;\n            m_bWriteKnownIncompatibleEdition = true;\n        }\n\n        bool bIsOverview = false;\n        uint32_t nSubType = 0;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_SUBFILETYPE, &nSubType))\n        {\n            bIsOverview = (nSubType & FILETYPE_REDUCEDIMAGE) != 0;\n\n            if ((nSubType & FILETYPE_MASK) != 0)\n            {\n                ReportError(CE_Failure, CPLE_AppDefined,\n                            \"Cannot create a mask on a TIFF mask IFD !\");\n                return CE_Failure;\n            }\n        }\n\n        const int bIsTiled = TIFFIsTiled(m_hTIFF);\n\n        FlushDirectory();\n\n        const toff_t nOffset = GTIFFWriteDirectory(\n            m_hTIFF,\n            bIsOverview ? FILETYPE_REDUCEDIMAGE | FILETYPE_MASK : FILETYPE_MASK,\n            nRasterXSize, nRasterYSize, 1, PLANARCONFIG_CONTIG, 1,\n            m_nBlockXSize, m_nBlockYSize, bIsTiled, l_nCompression,\n            PHOTOMETRIC_MASK, PREDICTOR_NONE, SAMPLEFORMAT_UINT, nullptr,\n            nullptr, nullptr, 0, nullptr, \"\", nullptr, nullptr, nullptr,\n            nullptr, m_bWriteCOGLayout);\n\n        ReloadDirectory();\n\n        if (nOffset == 0)\n            return CE_Failure;\n\n        m_poMaskDS = new GTiffDataset();\n        m_poMaskDS->m_poBaseDS = this;\n        m_poMaskDS->m_poImageryDS = this;\n        m_poMaskDS->ShareLockWithParentDataset(this);\n        m_poMaskDS->m_bPromoteTo8Bits = CPLTestBool(\n            CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n        if (m_poMaskDS->OpenOffset(VSI_TIFFOpenChild(m_hTIFF), nOffset,\n                                   GA_Update) != CE_None)\n        {\n            delete m_poMaskDS;\n            m_poMaskDS = nullptr;\n            return CE_Failure;\n        }\n\n        return CE_None;\n    }\n\n    return GDALPamDataset::CreateMaskBand(nFlagsIn);\n}",
    "void StackedBitmap::ReadSpecificTags(CTIFFReader * tiffReader)\n{\n\tuint32_t\t\t\t\tnrbitmaps = 1,\n\t\t\t\t\t\tsettingsapplied = 0;\n\n\tif (tiffReader)\n\t{\n\t\t// Read specific fields (if present)\n\t\tm_lISOSpeed = tiffReader->GetISOSpeed();\n\t\tm_lGain = tiffReader->GetGain();\n\t\tm_lTotalTime = tiffReader->GetExposureTime();\n\n\t\tif (TIFFGetField(tiffReader->m_tiff, TIFFTAG_DSS_NRFRAMES, &nrbitmaps))\n\t\t\tm_lNrBitmaps = nrbitmaps;\n\t\telse\n\t\t\tm_lNrBitmaps = 1;\n\n\t\tif (!TIFFGetField(tiffReader->m_tiff, TIFFTAG_DSS_SETTINGSAPPLIED, &settingsapplied))\n\t\t\tsettingsapplied = 1;\n\n\t\tif (settingsapplied)\n\t\t{\n\t\t\tm_BezierAdjust.reset(true);\n\t\t\tm_HistoAdjust.reset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar* szBezierParameters = nullptr;\n\t\t\tchar* szAdjustParameters = nullptr;\n\n\t\t\tm_BezierAdjust.reset();\n\t\t\tif (TIFFGetField(tiffReader->m_tiff, TIFFTAG_DSS_BEZIERSETTINGS, &szBezierParameters))\n\t\t\t{\n\t\t\t\tQString strBezierParameters(szBezierParameters);\n\t\t\t\tif (strBezierParameters.length())\n\t\t\t\t\tm_BezierAdjust.fromString(strBezierParameters);\n\t\t\t};\n\n\t\t\tm_HistoAdjust.reset();\n\t\t\tif (TIFFGetField(tiffReader->m_tiff, TIFFTAG_DSS_ADJUSTSETTINGS, &szAdjustParameters))\n\t\t\t{\n\t\t\t\tQString strAdjustParameters(szAdjustParameters);\n\t\t\t\tif (strAdjustParameters.length())\n\t\t\t\t\tm_HistoAdjust.FromText(strAdjustParameters);\n\t\t\t}\n\t\t}\n\t}\n}",
    "int GTiffRasterBand::DirectIO(GDALRWFlag eRWFlag, int nXOff, int nYOff,\n                              int nXSize, int nYSize, void *pData,\n                              int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType, GSpacing nPixelSpace,\n                              GSpacing nLineSpace,\n                              GDALRasterIOExtraArg *psExtraArg)\n{\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if (!(eRWFlag == GF_Read && m_poGDS->m_nCompression == COMPRESSION_NONE &&\n          (m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB ||\n           m_poGDS->m_nPhotometric == PHOTOMETRIC_PALETTE) &&\n          IsBaseGTiffClass()))\n    {\n        return -1;\n    }\n    m_poGDS->Crystalize();\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if ((nXSize != nBufXSize || nYSize != nBufYSize) && psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour)\n    {\n        return -1;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug(\"GTiff\", \"DirectIO(%d,%d,%d,%d -> %dx%d)\", nXOff, nYOff, nXSize,\n             nYSize, nBufXSize, nBufYSize);\n#endif\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if (m_poGDS->GetAccess() == GA_Update)\n    {\n        m_poGDS->FlushCache(false);\n        VSI_TIFFFlushBufferedWrite(TIFFClientdata(m_poGDS->m_hTIFF));\n    }\n\n    if (TIFFIsTiled(m_poGDS->m_hTIFF))\n    {\n        const int nDTSize = nDTSizeBits / 8;\n        const size_t nTempBufferForCommonDirectIOSize = static_cast<size_t>(\n            static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize * nDTSize *\n            (m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG ? m_poGDS->nBands\n                                                             : 1));\n        if (m_poGDS->m_pTempBufferForCommonDirectIO == nullptr)\n        {\n            m_poGDS->m_pTempBufferForCommonDirectIO = static_cast<GByte *>(\n                VSI_MALLOC_VERBOSE(nTempBufferForCommonDirectIOSize));\n            if (m_poGDS->m_pTempBufferForCommonDirectIO == nullptr)\n                return CE_Failure;\n        }\n\n        VSILFILE *fp = VSI_TIFFGetVSILFile(TIFFClientdata(m_poGDS->m_hTIFF));\n        FetchBufferDirectIO oFetcher(fp,\n                                     m_poGDS->m_pTempBufferForCommonDirectIO,\n                                     nTempBufferForCommonDirectIOSize);\n\n        return m_poGDS->CommonDirectIOClassic(\n            oFetcher, nXOff, nYOff, nXSize, nYSize, pData, nBufXSize, nBufYSize,\n            eBufType, 1, &nBand, nPixelSpace, nLineSpace, 0);\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if (!TIFFGetField(m_poGDS->m_hTIFF, TIFFTAG_STRIPOFFSETS,\n                      &panTIFFOffsets) ||\n        panTIFFOffsets == nullptr)\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    // TODO(schwehr): Make ppData be GByte**.\n    void **ppData =\n        static_cast<void **>(VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void *)));\n    vsi_l_offset *panOffsets = static_cast<vsi_l_offset *>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)));\n    size_t *panSizes =\n        static_cast<size_t *>(VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)));\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void *pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands =\n        m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG ? m_poGDS->nBands : 1;\n    int nSrcPixelSize = nDTSize * nContigBands;\n\n    if (ppData == nullptr || panOffsets == nullptr || panSizes == nullptr)\n        eErr = CE_Failure;\n    else if (nXSize != nBufXSize || nYSize != nBufYSize ||\n             eBufType != eDataType ||\n             nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n             nContigBands > 1)\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC3_VERBOSE(nReqXSize, nReqYSize, nSrcPixelSize);\n        if (pTmpBuffer == nullptr)\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast<double>(nBufYSize);\n\n    for (int iLine = 0; eErr == CE_None && iLine < nReqYSize; ++iLine)\n    {\n        if (pTmpBuffer == nullptr)\n            ppData[iLine] = static_cast<GByte *>(pData) + iLine * nLineSpace;\n        else\n            ppData[iLine] =\n                static_cast<GByte *>(pTmpBuffer) +\n                static_cast<size_t>(iLine) * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if (nBufYSize < nYSize)  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast<int>((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n        const int nBlockId = ComputeBlockId(nBlockXOff, nBlockYOff);\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if (panOffsets[iLine] == 0)  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff + static_cast<vsi_l_offset>(nYOffsetInBlock) * nBlockXSize) *\n            nSrcPixelSize;\n        panSizes[iLine] = static_cast<size_t>(nReqXSize) * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if (eErr == CE_None)\n    {\n        VSILFILE *fp = VSI_TIFFGetVSILFile(TIFFClientdata(m_poGDS->m_hTIFF));\n        const int nRet =\n            VSIFReadMultiRangeL(nReqYSize, ppData, panOffsets, panSizes, fp);\n        if (nRet != 0)\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if (eErr == CE_None && TIFFIsByteSwapped(m_poGDS->m_hTIFF))\n    {\n        for (int iLine = 0; iLine < nReqYSize; ++iLine)\n        {\n            if (GDALDataTypeIsComplex(eDataType))\n                GDALSwapWords(ppData[iLine], nDTSize / 2,\n                              2 * nReqXSize * nContigBands, nDTSize / 2);\n            else\n                GDALSwapWords(ppData[iLine], nDTSize, nReqXSize * nContigBands,\n                              nDTSize);\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast<double>(nBufXSize);\n    if (eErr == CE_None && pTmpBuffer != nullptr)\n    {\n        const bool bOneByteCopy =\n            (eDataType == eBufType &&\n             (eDataType == GDT_Byte || eDataType == GDT_Int8));\n        for (int iY = 0; iY < nBufYSize; ++iY)\n        {\n            const int iSrcY = nBufYSize <= nYSize\n                                  ? iY\n                                  : static_cast<int>((iY + 0.5) * dfSrcYInc);\n\n            GByte *pabySrcData = static_cast<GByte *>(ppData[iSrcY]) +\n                                 (nContigBands > 1 ? (nBand - 1) : 0) * nDTSize;\n            GByte *pabyDstData = static_cast<GByte *>(pData) + iY * nLineSpace;\n            if (nBufXSize == nXSize)\n            {\n                GDALCopyWords(pabySrcData, eDataType, nSrcPixelSize,\n                              pabyDstData, eBufType,\n                              static_cast<int>(nPixelSpace), nBufXSize);\n            }\n            else\n            {\n                if (bOneByteCopy)\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for (int iX = 0; iX < nBufXSize; ++iX, dfSrcX += dfSrcXInc)\n                    {\n                        const int iSrcX = static_cast<int>(dfSrcX);\n                        pabyDstData[iX * nPixelSpace] =\n                            pabySrcData[iSrcX * nSrcPixelSize];\n                    }\n                }\n                else\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for (int iX = 0; iX < nBufXSize; ++iX, dfSrcX += dfSrcXInc)\n                    {\n                        const int iSrcX = static_cast<int>(dfSrcX);\n                        GDALCopyWords(\n                            pabySrcData + iSrcX * nSrcPixelSize, eDataType, 0,\n                            pabyDstData + iX * nPixelSpace, eBufType, 0, 1);\n                    }\n                }\n            }\n        }\n    }\n\n    // Cleanup.\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}",
    "CPLVirtualMem *GTiffRasterBand::GetVirtualMemAutoInternal(GDALRWFlag eRWFlag,\n                                                          int *pnPixelSpace,\n                                                          GIntBig *pnLineSpace,\n                                                          char **papszOptions)\n{\n    int nLineSize = nBlockXSize * GDALGetDataTypeSizeBytes(eDataType);\n    if (m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG)\n        nLineSize *= m_poGDS->nBands;\n\n    if (m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG)\n    {\n        // In case of a pixel interleaved file, we save virtual memory space\n        // by reusing a base mapping that embraces the whole imagery.\n        if (m_poGDS->m_pBaseMapping != nullptr)\n        {\n            // Offset between the base mapping and the requested mapping.\n            vsi_l_offset nOffset = static_cast<vsi_l_offset>(nBand - 1) *\n                                   GDALGetDataTypeSizeBytes(eDataType);\n\n            GTiffRasterBand **ppoSelf = static_cast<GTiffRasterBand **>(\n                CPLCalloc(1, sizeof(GTiffRasterBand *)));\n            *ppoSelf = this;\n\n            CPLVirtualMem *pVMem = CPLVirtualMemDerivedNew(\n                m_poGDS->m_pBaseMapping, nOffset,\n                CPLVirtualMemGetSize(m_poGDS->m_pBaseMapping) - nOffset,\n                GTiffRasterBand::DropReferenceVirtualMem, ppoSelf);\n            if (pVMem == nullptr)\n            {\n                CPLFree(ppoSelf);\n                return nullptr;\n            }\n\n            // Mechanism used so that the memory mapping object can be\n            // destroyed after the raster band.\n            m_aSetPSelf.insert(ppoSelf);\n            ++m_poGDS->m_nRefBaseMapping;\n            *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n            if (m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG)\n                *pnPixelSpace *= m_poGDS->nBands;\n            *pnLineSpace = nLineSize;\n            return pVMem;\n        }\n    }\n\n    VSILFILE *fp = VSI_TIFFGetVSILFile(TIFFClientdata(m_poGDS->m_hTIFF));\n\n    vsi_l_offset nLength = static_cast<vsi_l_offset>(nRasterYSize) * nLineSize;\n\n    if (!(CPLIsVirtualMemFileMapAvailable() &&\n          VSIFGetNativeFileDescriptorL(fp) != nullptr &&\n#if SIZEOF_VOIDP == 4\n          nLength == static_cast<size_t>(nLength) &&\n#endif\n          m_poGDS->m_nCompression == COMPRESSION_NONE &&\n          (m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB ||\n           m_poGDS->m_nPhotometric == PHOTOMETRIC_PALETTE) &&\n          m_poGDS->m_nBitsPerSample == GDALGetDataTypeSizeBits(eDataType) &&\n          !TIFFIsTiled(m_poGDS->m_hTIFF) &&\n          !TIFFIsByteSwapped(m_poGDS->m_hTIFF)))\n    {\n        return nullptr;\n    }\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if (m_poGDS->GetAccess() == GA_Update)\n    {\n        m_poGDS->FlushCache(false);\n        VSI_TIFFFlushBufferedWrite(TIFFClientdata(m_poGDS->m_hTIFF));\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if (!TIFFGetField(m_poGDS->m_hTIFF, TIFFTAG_STRIPOFFSETS,\n                      &panTIFFOffsets) ||\n        panTIFFOffsets == nullptr)\n    {\n        return nullptr;\n    }\n\n    GPtrDiff_t nBlockSize = static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize *\n                            GDALGetDataTypeSizeBytes(eDataType);\n    if (m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG)\n        nBlockSize *= m_poGDS->nBands;\n\n    int nBlocks = m_poGDS->m_nBlocksPerBand;\n    if (m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE)\n        nBlocks *= m_poGDS->nBands;\n    int i = 0;  // Used after for.\n    for (; i < nBlocks; ++i)\n    {\n        if (panTIFFOffsets[i] != 0)\n            break;\n    }\n    if (i == nBlocks)\n    {\n        // All zeroes.\n        if (m_poGDS->eAccess == GA_Update)\n        {\n            // Initialize the file with empty blocks so that the file has\n            // the appropriate size.\n\n            toff_t *panByteCounts = nullptr;\n            if (!TIFFGetField(m_poGDS->m_hTIFF, TIFFTAG_STRIPBYTECOUNTS,\n                              &panByteCounts) ||\n                panByteCounts == nullptr)\n            {\n                return nullptr;\n            }\n            if (VSIFSeekL(fp, 0, SEEK_END) != 0)\n                return nullptr;\n            vsi_l_offset nBaseOffset = VSIFTellL(fp);\n\n            // Just write one tile with libtiff to put it in appropriate state.\n            GByte *pabyData =\n                static_cast<GByte *>(VSI_CALLOC_VERBOSE(1, nBlockSize));\n            if (pabyData == nullptr)\n            {\n                return nullptr;\n            }\n            const auto ret = TIFFWriteEncodedStrip(m_poGDS->m_hTIFF, 0,\n                                                   pabyData, nBlockSize);\n            VSI_TIFFFlushBufferedWrite(TIFFClientdata(m_poGDS->m_hTIFF));\n            VSIFree(pabyData);\n            if (ret != nBlockSize)\n            {\n                return nullptr;\n            }\n            CPLAssert(panTIFFOffsets[0] == nBaseOffset);\n            CPLAssert(panByteCounts[0] == static_cast<toff_t>(nBlockSize));\n\n            // Now simulate the writing of other blocks.\n            assert(nBlocks > 0);\n            assert(static_cast<vsi_l_offset>(nBlockSize) <\n                   std::numeric_limits<vsi_l_offset>::max() / nBlocks);\n            const vsi_l_offset nDataSize =\n                static_cast<vsi_l_offset>(nBlockSize) * nBlocks;\n            if (VSIFTruncateL(fp, nBaseOffset + nDataSize) != 0)\n                return nullptr;\n\n            for (i = 1; i < nBlocks; ++i)\n            {\n                panTIFFOffsets[i] =\n                    nBaseOffset + i * static_cast<toff_t>(nBlockSize);\n                panByteCounts[i] = nBlockSize;\n            }\n        }\n        else\n        {\n            CPLDebug(\"GTiff\", \"Sparse files not supported in file mapping\");\n            return nullptr;\n        }\n    }\n\n    GIntBig nBlockSpacing = 0;\n    bool bCompatibleSpacing = true;\n    toff_t nPrevOffset = 0;\n    for (i = 0; i < m_poGDS->m_nBlocksPerBand; ++i)\n    {\n        toff_t nCurOffset = 0;\n        if (m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE)\n            nCurOffset =\n                panTIFFOffsets[m_poGDS->m_nBlocksPerBand * (nBand - 1) + i];\n        else\n            nCurOffset = panTIFFOffsets[i];\n        if (nCurOffset == 0)\n        {\n            bCompatibleSpacing = false;\n            break;\n        }\n        if (i > 0)\n        {\n            const GIntBig nCurSpacing = nCurOffset - nPrevOffset;\n            if (i == 1)\n            {\n                if (nCurSpacing !=\n                    static_cast<GIntBig>(nBlockYSize) * nLineSize)\n                {\n                    bCompatibleSpacing = false;\n                    break;\n                }\n                nBlockSpacing = nCurSpacing;\n            }\n            else if (nBlockSpacing != nCurSpacing)\n            {\n                bCompatibleSpacing = false;\n                break;\n            }\n        }\n        nPrevOffset = nCurOffset;\n    }\n\n    if (!bCompatibleSpacing)\n    {\n        return nullptr;\n    }\n\n    vsi_l_offset nOffset = 0;\n    if (m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG)\n    {\n        CPLAssert(m_poGDS->m_pBaseMapping == nullptr);\n        nOffset = panTIFFOffsets[0];\n    }\n    else\n    {\n        nOffset = panTIFFOffsets[m_poGDS->m_nBlocksPerBand * (nBand - 1)];\n    }\n    CPLVirtualMem *pVMem = CPLVirtualMemFileMapNew(\n        fp, nOffset, nLength,\n        eRWFlag == GF_Write ? VIRTUALMEM_READWRITE : VIRTUALMEM_READONLY,\n        nullptr, nullptr);\n    if (pVMem == nullptr)\n    {\n        return nullptr;\n    }\n\n    if (m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG)\n    {\n        // TODO(schwehr): Revisit this block.\n        m_poGDS->m_pBaseMapping = pVMem;\n        pVMem = GetVirtualMemAutoInternal(eRWFlag, pnPixelSpace, pnLineSpace,\n                                          papszOptions);\n        // Drop ref on base mapping.\n        CPLVirtualMemFree(m_poGDS->m_pBaseMapping);\n        if (pVMem == nullptr)\n            m_poGDS->m_pBaseMapping = nullptr;\n    }\n    else\n    {\n        *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n        if (m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG)\n            *pnPixelSpace *= m_poGDS->nBands;\n        *pnLineSpace = nLineSize;\n    }\n    return pVMem;\n}",
    "const char *GTiffRasterBand::GetMetadataItem(const char *pszName,\n                                             const char *pszDomain)\n\n{\n    if (pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\"))\n    {\n        m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if (pszName != nullptr && pszDomain != nullptr && EQUAL(pszDomain, \"TIFF\"))\n    {\n        int nBlockXOff = 0;\n        int nBlockYOff = 0;\n\n        if (EQUAL(pszName, \"JPEGTABLES\"))\n        {\n            uint32_t nJPEGTableSize = 0;\n            void *pJPEGTable = nullptr;\n            if (TIFFGetField(m_poGDS->m_hTIFF, TIFFTAG_JPEGTABLES,\n                             &nJPEGTableSize, &pJPEGTable) != 1 ||\n                pJPEGTable == nullptr || nJPEGTableSize > INT_MAX)\n            {\n                return nullptr;\n            }\n            char *const pszHex = CPLBinaryToHex(\n                nJPEGTableSize, static_cast<const GByte *>(pJPEGTable));\n            const char *pszReturn = CPLSPrintf(\"%s\", pszHex);\n            CPLFree(pszHex);\n\n            return pszReturn;\n        }\n\n        if (EQUAL(pszName, \"IFD_OFFSET\"))\n        {\n            return CPLSPrintf(CPL_FRMT_GUIB,\n                              static_cast<GUIntBig>(m_poGDS->m_nDirOffset));\n        }\n\n        if (sscanf(pszName, \"BLOCK_OFFSET_%d_%d\", &nBlockXOff, &nBlockYOff) ==\n            2)\n        {\n            if (nBlockXOff < 0 || nBlockXOff >= nBlocksPerRow ||\n                nBlockYOff < 0 || nBlockYOff >= nBlocksPerColumn)\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if (m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE)\n            {\n                nBlockId += (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n            }\n\n            vsi_l_offset nOffset = 0;\n            if (!m_poGDS->IsBlockAvailable(nBlockId, &nOffset, nullptr,\n                                           nullptr))\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf(CPL_FRMT_GUIB, static_cast<GUIntBig>(nOffset));\n        }\n\n        if (sscanf(pszName, \"BLOCK_SIZE_%d_%d\", &nBlockXOff, &nBlockYOff) == 2)\n        {\n            if (nBlockXOff < 0 || nBlockXOff >= nBlocksPerRow ||\n                nBlockYOff < 0 || nBlockYOff >= nBlocksPerColumn)\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if (m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE)\n            {\n                nBlockId += (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n            }\n\n            vsi_l_offset nByteCount = 0;\n            if (!m_poGDS->IsBlockAvailable(nBlockId, nullptr, &nByteCount,\n                                           nullptr))\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf(CPL_FRMT_GUIB, static_cast<GUIntBig>(nByteCount));\n        }\n    }\n    else if (pszName && pszDomain && EQUAL(pszDomain, \"_DEBUG_\"))\n    {\n        if (EQUAL(pszName, \"HAS_BLOCK_CACHE\"))\n            return HasBlockCache() ? \"1\" : \"0\";\n    }\n\n    const char *pszRet = m_oGTiffMDMD.GetMetadataItem(pszName, pszDomain);\n\n    if (pszRet == nullptr && eDataType == GDT_Byte && pszName && pszDomain &&\n        EQUAL(pszDomain, \"IMAGE_STRUCTURE\") && EQUAL(pszName, \"PIXELTYPE\"))\n    {\n        // to get a chance of emitting the warning about this legacy usage\n        pszRet = GDALRasterBand::GetMetadataItem(pszName, pszDomain);\n    }\n    return pszRet;\n}",
    "CPLErr GTiffRasterBand::SetColorInterpretation(GDALColorInterp eInterp)\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if (eInterp == m_eBandInterp)\n        return CE_None;\n\n    m_eBandInterp = eInterp;\n\n    if (eAccess != GA_Update)\n    {\n        CPLDebug(\"GTIFF\",\n                 \"ColorInterpretation %s for band %d goes to PAM \"\n                 \"instead of TIFF tag\",\n                 GDALGetColorInterpretationName(eInterp), nBand);\n        return GDALPamRasterBand::SetColorInterpretation(eInterp);\n    }\n\n    m_poGDS->m_bNeedsRewrite = true;\n    m_poGDS->m_bMetadataChanged = true;\n\n    // Try to autoset TIFFTAG_PHOTOMETRIC = PHOTOMETRIC_RGB if possible.\n    if (m_poGDS->nBands >= 3 && m_poGDS->m_nCompression != COMPRESSION_JPEG &&\n        m_poGDS->m_nPhotometric != PHOTOMETRIC_RGB &&\n        CSLFetchNameValue(m_poGDS->m_papszCreationOptions, \"PHOTOMETRIC\") ==\n            nullptr &&\n        ((nBand == 1 && eInterp == GCI_RedBand) ||\n         (nBand == 2 && eInterp == GCI_GreenBand) ||\n         (nBand == 3 && eInterp == GCI_BlueBand)))\n    {\n        if (m_poGDS->GetRasterBand(1)->GetColorInterpretation() ==\n                GCI_RedBand &&\n            m_poGDS->GetRasterBand(2)->GetColorInterpretation() ==\n                GCI_GreenBand &&\n            m_poGDS->GetRasterBand(3)->GetColorInterpretation() == GCI_BlueBand)\n        {\n            m_poGDS->m_nPhotometric = PHOTOMETRIC_RGB;\n            TIFFSetField(m_poGDS->m_hTIFF, TIFFTAG_PHOTOMETRIC,\n                         m_poGDS->m_nPhotometric);\n\n            // We need to update the number of extra samples.\n            uint16_t *v = nullptr;\n            uint16_t count = 0;\n            const uint16_t nNewExtraSamplesCount =\n                static_cast<uint16_t>(m_poGDS->nBands - 3);\n            if (m_poGDS->nBands >= 4 &&\n                TIFFGetField(m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES, &count,\n                             &v) &&\n                count > nNewExtraSamplesCount)\n            {\n                uint16_t *const pasNewExtraSamples = static_cast<uint16_t *>(\n                    CPLMalloc(nNewExtraSamplesCount * sizeof(uint16_t)));\n                memcpy(pasNewExtraSamples, v + count - nNewExtraSamplesCount,\n                       nNewExtraSamplesCount * sizeof(uint16_t));\n\n                TIFFSetField(m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES,\n                             nNewExtraSamplesCount, pasNewExtraSamples);\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n        return CE_None;\n    }\n\n    // On the contrary, cancel the above if needed\n    if (m_poGDS->m_nCompression != COMPRESSION_JPEG &&\n        m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB &&\n        CSLFetchNameValue(m_poGDS->m_papszCreationOptions, \"PHOTOMETRIC\") ==\n            nullptr &&\n        ((nBand == 1 && eInterp != GCI_RedBand) ||\n         (nBand == 2 && eInterp != GCI_GreenBand) ||\n         (nBand == 3 && eInterp != GCI_BlueBand)))\n    {\n        m_poGDS->m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(m_poGDS->m_hTIFF, TIFFTAG_PHOTOMETRIC,\n                     m_poGDS->m_nPhotometric);\n\n        // We need to update the number of extra samples.\n        uint16_t *v = nullptr;\n        uint16_t count = 0;\n        const uint16_t nNewExtraSamplesCount =\n            static_cast<uint16_t>(m_poGDS->nBands - 1);\n        if (m_poGDS->nBands >= 2)\n        {\n            TIFFGetField(m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v);\n            if (nNewExtraSamplesCount > count)\n            {\n                uint16_t *const pasNewExtraSamples = static_cast<uint16_t *>(\n                    CPLMalloc(nNewExtraSamplesCount * sizeof(uint16_t)));\n                for (int i = 0;\n                     i < static_cast<int>(nNewExtraSamplesCount - count); ++i)\n                    pasNewExtraSamples[i] = EXTRASAMPLE_UNSPECIFIED;\n                if (count > 0)\n                {\n                    memcpy(pasNewExtraSamples + nNewExtraSamplesCount - count,\n                           v, count * sizeof(uint16_t));\n                }\n\n                TIFFSetField(m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES,\n                             nNewExtraSamplesCount, pasNewExtraSamples);\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n    }\n\n    // Mark alpha band / undefined in extrasamples.\n    if (eInterp == GCI_AlphaBand || eInterp == GCI_Undefined)\n    {\n        uint16_t *v = nullptr;\n        uint16_t count = 0;\n        if (TIFFGetField(m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v))\n        {\n            const int nBaseSamples = m_poGDS->m_nSamplesPerPixel - count;\n\n            if (eInterp == GCI_AlphaBand)\n            {\n                for (int i = 1; i <= m_poGDS->nBands; ++i)\n                {\n                    if (i != nBand &&\n                        m_poGDS->GetRasterBand(i)->GetColorInterpretation() ==\n                            GCI_AlphaBand)\n                    {\n                        if (i == nBaseSamples + 1 &&\n                            CSLFetchNameValue(m_poGDS->m_papszCreationOptions,\n                                              \"ALPHA\") != nullptr)\n                        {\n                            ReportError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too. \"\n                                \"Presumably ALPHA creation option is not \"\n                                \"needed\",\n                                i, nBand);\n                        }\n                        else\n                        {\n                            ReportError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too\",\n                                i, nBand);\n                        }\n                    }\n                }\n            }\n\n            if (nBand > nBaseSamples && nBand - nBaseSamples - 1 < count)\n            {\n                // We need to allocate a new array as (current) libtiff\n                // versions will not like that we reuse the array we got from\n                // TIFFGetField().\n\n                uint16_t *pasNewExtraSamples = static_cast<uint16_t *>(\n                    CPLMalloc(count * sizeof(uint16_t)));\n                memcpy(pasNewExtraSamples, v, count * sizeof(uint16_t));\n                if (eInterp == GCI_AlphaBand)\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        GTiffGetAlphaValue(\n                            CPLGetConfigOption(\"GTIFF_ALPHA\", nullptr),\n                            DEFAULT_ALPHA_TYPE);\n                }\n                else\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        EXTRASAMPLE_UNSPECIFIED;\n                }\n\n                TIFFSetField(m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES, count,\n                             pasNewExtraSamples);\n\n                CPLFree(pasNewExtraSamples);\n\n                return CE_None;\n            }\n        }\n    }\n\n    if (m_poGDS->m_nPhotometric != PHOTOMETRIC_MINISBLACK &&\n        CSLFetchNameValue(m_poGDS->m_papszCreationOptions, \"PHOTOMETRIC\") ==\n            nullptr)\n    {\n        m_poGDS->m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(m_poGDS->m_hTIFF, TIFFTAG_PHOTOMETRIC,\n                     m_poGDS->m_nPhotometric);\n    }\n\n    return CE_None;\n}",
    "T GetOrThrow(TIFF* tif, uint32_t tag)\n{\n    T r;\n    if (TIFFGetField(tif, tag, &r) != 1) {\n        throw std::runtime_error(\"Expected tag missing when reading tiff (\" + std::to_string(tag) + \")\");\n    }\n    return r;\n}",
    "T GetOrDefault(TIFF* tif, uint32_t tag, T default_val)\n{\n    T r = default_val;\n    TIFFGetField(tif, tag, &r);\n    return r;\n}",
    "absl::Status GetTIFFImageInfo(TIFF* tiff, TiffImageInfo& info) {\n  uint32_t width, height, depth;\n  if (!TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width) ||\n      !TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height)) {\n    return absl::InvalidArgumentError(\"TIFF read failed: invalid image\");\n  }\n\n  if (TIFFGetField(tiff, TIFFTAG_IMAGEDEPTH, &depth) && depth > 1) {\n    return absl::InvalidArgumentError(\"TIFF read failed: depth not supported\");\n  }\n\n  // These call TIFFSetField to update the in-memory structure so that\n  // subsequent calls get appropriate defaults.\n  if (!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &info.bits_per_sample_)) {\n    info.bits_per_sample_ = 1;\n    TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, info.bits_per_sample_);\n  }\n  uint32_t samples_per_pixel = 0;\n  if (!TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel)) {\n    samples_per_pixel = 1;\n    TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, samples_per_pixel);\n  }\n  uint16_t* sample_info;\n  if (TIFFGetField(tiff, TIFFTAG_EXTRASAMPLES, &info.extra_samples_,\n                   &sample_info) != 1) {\n    info.extra_samples_ = 0;\n  } else {\n    if (info.extra_samples_ == 1) {\n      info.extra_types_ = *sample_info;\n      if (info.extra_types_ == EXTRASAMPLE_UNSPECIFIED) {\n        if (samples_per_pixel > 3) {\n          info.extra_types_ = EXTRASAMPLE_ASSOCALPHA;\n        }\n      }\n    }\n  }\n\n  uint16_t sample_format = 0;\n  TIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLEFORMAT, &sample_format);\n\n  info.width = width;\n  info.height = height;\n  info.num_components = samples_per_pixel + info.extra_samples_;\n  TENSORSTORE_ASSIGN_OR_RETURN(info.dtype,\n                               SetDType(sample_format, info.bits_per_sample_));\n  return absl::OkStatus();\n}",
    "absl::Status ReadTiledImpl(TIFF* tiff, TiffImageInfo& info,\n                           tensorstore::span<unsigned char> data) {\n  ImageView dest_view(info, data);\n\n  // Translate 1,2,4 bits per sample to 8-bpp images.\n  const unsigned char* mapping = nullptr;\n  ptrdiff_t trstride = 1;\n  if (info.bits_per_sample_ == 1) {\n    mapping = TranslateBits<1>(trstride);\n  } else if (info.bits_per_sample_ == 2) {\n    mapping = TranslateBits<2>(trstride);\n  } else if (info.bits_per_sample_ == 4) {\n    mapping = TranslateBits<4>(trstride);\n  }\n\n  uint32_t tile_width, tile_height;\n  TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);\n  TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_height);\n\n  const int tile_bytes = TIFFTileSize(tiff);\n  std::unique_ptr<unsigned char[]> tile_buffer(new unsigned char[tile_bytes]);\n  ImageView tile_view(ImageInfo{/*.height=*/static_cast<int32_t>(tile_height),\n                                /*.width=*/static_cast<int32_t>(tile_width),\n                                /*.num_components=*/info.num_components},\n                      {tile_buffer.get(), tile_bytes});\n\n  for (size_t y = 0; y < info.height; y += tile_height) {\n    for (size_t x = 0; x < info.width; x += tile_width) {\n      if (TIFFReadTile(tiff, tile_buffer.get(), x, y, 0, 0) == -1) {\n        return absl::DataLossError(\"TIFF read tile failed\");\n      }\n      for (size_t y1 = 0; y1 < tile_height; y1++) {\n        if ((y + y1) >= info.height) break;\n        auto target_row = dest_view.data_row(y + y1, x);\n        auto tile_row = tile_view.data_row(y1);\n        if (info.bits_per_sample_ >= 8) {\n          memcpy(target_row.data(), tile_row.data(),\n                 std::min(target_row.size(), tile_row.size()));\n        } else {\n          unsigned char* packed = tile_row.data();\n          while (!target_row.empty()) {\n            size_t n = std::min(trstride, target_row.size());\n            memcpy(target_row.data(), mapping + (*packed * trstride), n);\n            target_row = target_row.subspan(n);\n            packed++;\n          }\n          assert(packed <= tile_row.data() + tile_row.size());\n        }\n      }\n    }\n  }\n  return absl::OkStatus();\n}",
    "absl::Status TiffReader::Context::Open() {\n  tiff_ = TIFFClientOpen(\"tensorstore_tiff_reader\", \"rmh\",\n                         static_cast<thandle_t>(this), &ReadProc, &NoWriteProc,\n                         &SeekProc, &CloseProc, &SizeProc,\n                         /*mmap*/ nullptr, /*munmap*/ nullptr);\n  if (!tiff_) {\n    return absl::InvalidArgumentError(\"Not a TIFF file\");\n  }\n\n  // NOTE: If https://gitlab.com/libtiff/libtiff/-/merge_requests/390 is\n  // submitted, then we can setup per-file error handling and skip the initial\n  // header read.\n  if (!TIFFReadDirectory(tiff_)) {\n    error_.Update(absl::InvalidArgumentError(\"Failed to read TIFF directory\"));\n  }\n\n#if 0\n  // TODO: If this tiff has a thumbnail, then we probably want to skip it\n  // by default.\n  uint32_t file_type;\n  if (TIFFGetField(tiff_, TIFFTAG_SUBFILETYPE, &file_type) &&\n      file_type == FILETYPE_REDUCEDIMAGE) {\n    // It's a thumbnail\n  }\n#endif\n\n  return ExtractErrors(absl::OkStatus());\n}",
    "void generate(int nBands, uint16_t nPhotometric, uint16_t nBitsPerSample)\n{\n    char **papszOpts = nullptr;\n    papszOpts = CSLSetNameValue(papszOpts, \"COMPRESS\", \"JPEG\");\n    if (nPhotometric == PHOTOMETRIC_YCBCR)\n        papszOpts = CSLSetNameValue(papszOpts, \"PHOTOMETRIC\", \"YCBCR\");\n    else if (nPhotometric == PHOTOMETRIC_SEPARATED)\n        papszOpts = CSLSetNameValue(papszOpts, \"PHOTOMETRIC\", \"CMYK\");\n    papszOpts = CSLSetNameValue(papszOpts, \"BLOCKYSIZE\", \"16\");\n    if (nBitsPerSample == 12)\n        papszOpts = CSLSetNameValue(papszOpts, \"NBITS\", \"12\");\n\n    CPLString osTmpFilename;\n    osTmpFilename.Printf(\"gtiffdataset_guess_jpeg_quality_tmp\");\n\n    for (int nQuality = 1; nQuality <= 100; ++nQuality)\n    {\n        papszOpts = CSLSetNameValue(papszOpts, \"JPEG_QUALITY\",\n                                    CPLSPrintf(\"%d\", nQuality));\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        CPLString osTmp;\n        std::unique_ptr<GDALDataset> poDS(\n            GDALDriver::FromHandle(GDALGetDriverByName(\"GTiff\"))\n                ->Create(\n                    osTmpFilename.c_str(), 16, 16, (nBands <= 4) ? nBands : 1,\n                    nBitsPerSample == 8 ? GDT_Byte : GDT_UInt16, papszOpts));\n        assert(poDS);\n        poDS.reset();\n        CPLPopErrorHandler();\n\n        TIFF *hTIFFTmp = TIFFOpen(osTmpFilename.c_str(), \"rb\");\n        uint32_t nJPEGTableSizeTry = 0;\n        void *pJPEGTableTry = nullptr;\n        if (TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSizeTry,\n                         &pJPEGTableTry))\n        {\n            const GByte *const pabyTable =\n                static_cast<const GByte *>(pJPEGTableTry);\n            int nLen = static_cast<int>(nJPEGTableSizeTry);\n            const GByte *paby = pabyTable;\n\n            struct CPLMD5Context context;\n            CPLMD5Init(&context);\n\n            while (true)\n            {\n                int nLenTable = 0;\n                const GByte *pabyNew =\n                    GTIFFFindNextTable(paby, 0xDB, nLen, &nLenTable);\n                if (pabyNew == nullptr)\n                    break;\n                CPLMD5Update(&context, pabyNew, nLenTable);\n                pabyNew += nLenTable;\n                nLen -= static_cast<int>(pabyNew - paby);\n                paby = pabyNew;\n            }\n\n            GByte digest[16];\n            CPLMD5Final(digest, &context);\n            printf(\"{\"); /*ok*/\n            for (int i = 0; i < 16; i++)\n                printf(\"0x%02X,\", digest[i]);       /*ok*/\n            printf(\"}, // quality %d\\n\", nQuality); /*ok*/\n        }\n\n        TIFFClose(hTIFFTmp);\n    }\n\n    VSIUnlink(osTmpFilename);\n\n    CSLDestroy(papszOpts);\n}",
    "HRESULT CImageTIFF::ReadHeader()\n{\n\tTIFF* tif = static_cast<TIFF*>(m_state);\n\tif (!tif) {\n\t\ttif = TIFFStreamOpen(\"ReadTIFF\", (ISTREAM*)m_pStream);\n\t\tif (!tif) {\n\t\t\tLOG(LT_IMAGE, \"error: unsupported TIFF image\");\n\t\t\treturn _INVALIDFILE;\n\t\t}\n\t}\n\tm_state = tif;\n\n\tuint16 photometric = 0;\n\tif (TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &m_width) &&\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &m_height) &&\n\t\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric))\n\t{\n\t\tuint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn);\n\n\t\tm_dataWidth = m_width;\n\t\tm_dataHeight= m_height;\n\t\tm_numLevels = 0;\n\t\tm_level     = 0;\n\n\t\tif ((bpp == 32 && ncn == 3) || photometric == PHOTOMETRIC_LOGLUV) {\n\t\t\t// this is HDR format with 3 floats per pixel\n\t\t\t//TODO: implement\n\t\t\tASSERT(\"error: not implemented\" == NULL);\n\t\t\tClose();\n\t\t\treturn _FAIL;\n\t\t}\n\t\tif (bpp > 8 &&\n\t\t\t((photometric != 2 && photometric != 1) ||\n\t\t\t\t(ncn != 1 && ncn != 3 && ncn != 4)))\n\t\t\tbpp = 8;\n\t\tswitch (bpp) {\n\t\tcase 8:\n\t\t\tm_stride = 4;\n\t\t\tm_format = PF_B8G8R8A8;\n\t\t\tbreak;\n\t\t//case 16:\n\t\t//\tm_type = CV_MAKETYPE(CV_16U, photometric > 1 ? 3 : 1);\n\t\t//\tbreak;\n\t\t//case 32:\n\t\t//\tm_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n\t\t//\tbreak;\n\t\t//case 64:\n\t\t//\tm_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n\t\t//\tbreak;\n\t\tdefault:\n\t\t\t//TODO: implement\n\t\t\tASSERT(\"error: not implemented\" == NULL);\n\t\t\tLOG(LT_IMAGE, \"error: unsupported TIFF image\");\n\t\t\tClose();\n\t\t\treturn _INVALIDFILE;\n\t\t}\n\t\tm_lineWidth = m_width * m_stride;\n\n\t\treturn _OK;\n\t}\n\n\tClose();\n\treturn _FAIL;\n}",
    "HRESULT CImageTIFF::ReadData(void* pData, PIXELFORMAT dataFormat, Size nStride, Size lineWidth)\n{\n\tif (m_state && m_width && m_height) {\n\t\tTIFF* tif = (TIFF*)m_state;\n\t\tuint32_t tile_width0 = m_width, tile_height0 = 0;\n\t\tint is_tiled = TIFFIsTiled(tif);\n\t\tuint16 photometric;\n\t\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric);\n\t\tuint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn);\n\t\tconst int bitsPerByte = 8;\n\t\tint dst_bpp = (int)(1 * bitsPerByte);\n\t\tif (dst_bpp == 8) {\n\t\t\tchar errmsg[1024];\n\t\t\tif (!TIFFRGBAImageOK(tif, errmsg)) {\n\t\t\t\tClose();\n\t\t\t\treturn _INVALIDFILE;\n\t\t\t}\n\t\t}\n\n\t\tif ((!is_tiled) ||\n\t\t\t(is_tiled &&\n\t\t\t TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0) &&\n\t\t\t TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0)))\n\t\t{\n\t\t\tif (!is_tiled)\n\t\t\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0);\n\n\t\t\tif (tile_width0 <= 0)\n\t\t\t\ttile_width0 = m_width;\n\n\t\t\tif (tile_height0 <= 0 ||\n\t\t\t\t(!is_tiled && tile_height0 == std::numeric_limits<uint32_t>::max()))\n\t\t\t\ttile_height0 = m_height;\n\n\t\t\tuint8_t* data = (uint8_t*)pData;\n\t\t\tif (!is_tiled && tile_height0 == 1 && dataFormat == m_format && nStride == m_stride) {\n\t\t\t\t// read image directly to the data buffer\n\t\t\t\tfor (Size j=0; j<m_height; ++j, data+=lineWidth)\n\t\t\t\t\tif (!TIFFReadRGBAStrip(tif, j, (uint32_t*)data)) {\n\t\t\t\t\t\tClose();\n\t\t\t\t\t\treturn _INVALIDFILE;\n\t\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// read image to a buffer and convert it\n\t\t\t\tconst size_t buffer_size = 4 * tile_height0 * tile_width0;\n\t\t\t\tCLISTDEF0(uint8_t) _buffer(buffer_size);\n\t\t\t\tuint8_t* buffer = _buffer.Begin();\n\n\t\t\t\tfor (uint32_t y = 0; y < m_height; y += tile_height0, data += lineWidth*tile_height0) {\n\t\t\t\t\tuint32_t tile_height = tile_height0;\n\t\t\t\t\tif (y + tile_height > m_height)\n\t\t\t\t\t\ttile_height = m_height - y;\n\n\t\t\t\t\tfor (uint32_t x = 0; x < m_width; x += tile_width0) {\n\t\t\t\t\t\tuint32_t tile_width = tile_width0;\n\t\t\t\t\t\tif (x + tile_width > m_width)\n\t\t\t\t\t\t\ttile_width = m_width - x;\n\n\t\t\t\t\t\tint ok;\n\t\t\t\t\t\tswitch (dst_bpp) {\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint8_t* bstart = buffer;\n\t\t\t\t\t\t\tif (!is_tiled)\n\t\t\t\t\t\t\t\tok = TIFFReadRGBAStrip(tif, y, (uint32_t*)buffer);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = TIFFReadRGBATile(tif, x, y, (uint32_t*)buffer);\n\t\t\t\t\t\t\t\t//Tiles fill the buffer from the bottom up\n\t\t\t\t\t\t\t\tbstart += (tile_height0 - tile_height) * tile_width0 * 4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!ok) {\n\t\t\t\t\t\t\t\tClose();\n\t\t\t\t\t\t\t\treturn _INVALIDFILE;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (uint32_t i = 0; i < tile_height; ++i) {\n\t\t\t\t\t\t\t\tuint8_t* dst = data + x*3 + lineWidth*(tile_height - i - 1);\n\t\t\t\t\t\t\t\tuint8_t* src = bstart + i*tile_width0*4;\n\t\t\t\t\t\t\t\tif (!FilterFormat(dst, dataFormat, nStride, src, m_format, m_stride, tile_width)) {\n\t\t\t\t\t\t\t\t\tClose();\n\t\t\t\t\t\t\t\t\treturn _FAIL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tClose();\n\t\t\t\t\t\t\treturn _INVALIDFILE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn _OK;\n\t\t}\n\t}\n\n\tClose();\n\treturn _FAIL;\n}",
    "std::unique_ptr<GTiffGrid> GTiffDataset::nextGrid() {\n    if (!m_hasNextGrid)\n        return nullptr;\n    if (m_nextDirOffset) {\n        TIFFSetSubDirectory(m_hTIFF, m_nextDirOffset);\n    }\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGELENGTH, &height);\n    if (width == 0 || height == 0 || width > INT_MAX || height > INT_MAX) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Invalid image size\"));\n        return nullptr;\n    }\n\n    uint16_t samplesPerPixel = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Missing SamplesPerPixel tag\"));\n        return nullptr;\n    }\n    if (samplesPerPixel == 0) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Invalid SamplesPerPixel value\"));\n        return nullptr;\n    }\n\n    uint16_t bitsPerSample = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_BITSPERSAMPLE, &bitsPerSample)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Missing BitsPerSample tag\"));\n        return nullptr;\n    }\n\n    uint16_t planarConfig = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PLANARCONFIG, &planarConfig)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Missing PlanarConfig tag\"));\n        return nullptr;\n    }\n\n    uint16_t sampleFormat = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLEFORMAT, &sampleFormat)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Missing SampleFormat tag\"));\n        return nullptr;\n    }\n\n    TIFFDataType dt;\n    if (sampleFormat == SAMPLEFORMAT_INT && bitsPerSample == 16)\n        dt = TIFFDataType::Int16;\n    else if (sampleFormat == SAMPLEFORMAT_UINT && bitsPerSample == 16)\n        dt = TIFFDataType::UInt16;\n    else if (sampleFormat == SAMPLEFORMAT_INT && bitsPerSample == 32)\n        dt = TIFFDataType::Int32;\n    else if (sampleFormat == SAMPLEFORMAT_UINT && bitsPerSample == 32)\n        dt = TIFFDataType::UInt32;\n    else if (sampleFormat == SAMPLEFORMAT_IEEEFP && bitsPerSample == 32)\n        dt = TIFFDataType::Float32;\n    else if (sampleFormat == SAMPLEFORMAT_IEEEFP && bitsPerSample == 64)\n        dt = TIFFDataType::Float64;\n    else {\n        pj_log(m_ctx, PJ_LOG_ERROR,\n               _(\"Unsupported combination of SampleFormat \"\n                 \"and BitsPerSample values\"));\n        return nullptr;\n    }\n\n    uint16_t photometric = PHOTOMETRIC_MINISBLACK;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PHOTOMETRIC, &photometric))\n        photometric = PHOTOMETRIC_MINISBLACK;\n    if (photometric != PHOTOMETRIC_MINISBLACK) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Unsupported Photometric value\"));\n        return nullptr;\n    }\n\n    uint16_t compression = COMPRESSION_NONE;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_COMPRESSION, &compression))\n        compression = COMPRESSION_NONE;\n\n    if (compression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(compression)) {\n        pj_log(m_ctx, PJ_LOG_ERROR,\n               _(\"Cannot open TIFF file due to missing codec.\"));\n        return nullptr;\n    }\n    // We really don't want to try dealing with old-JPEG images\n    if (compression == COMPRESSION_OJPEG) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Unsupported compression method.\"));\n        return nullptr;\n    }\n\n    const auto blockSize = TIFFIsTiled(m_hTIFF) ? TIFFTileSize64(m_hTIFF)\n                                                : TIFFStripSize64(m_hTIFF);\n    if (blockSize == 0 || blockSize > 64 * 1024 * 2014) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Unsupported block size.\"));\n        return nullptr;\n    }\n\n    unsigned short count = 0;\n    unsigned short *geokeys = nullptr;\n    bool pixelIsArea = false;\n\n    ExtentAndRes extent;\n    extent.isGeographic = true;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_GEOKEYDIRECTORY, &count, &geokeys)) {\n        pj_log(m_ctx, PJ_LOG_TRACE, \"No GeoKeys tag\");\n    } else {\n        if (count < 4 || (count % 4) != 0) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   _(\"Wrong number of values in GeoKeys tag\"));\n            return nullptr;\n        }\n\n        if (geokeys[0] != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, _(\"Unsupported GeoTIFF major version\"));\n            return nullptr;\n        }\n        // We only know that we support GeoTIFF 1.0 and 1.1 at that time\n        if (geokeys[1] != 1 || geokeys[2] > 1) {\n            pj_log(m_ctx, PJ_LOG_TRACE, \"GeoTIFF %d.%d possibly not handled\",\n                   geokeys[1], geokeys[2]);\n        }\n\n        for (unsigned int i = 4; i + 3 < count; i += 4) {\n            constexpr unsigned short GTModelTypeGeoKey = 1024;\n            constexpr unsigned short ModelTypeProjected = 1;\n            constexpr unsigned short ModelTypeGeographic = 2;\n\n            constexpr unsigned short GTRasterTypeGeoKey = 1025;\n            constexpr unsigned short RasterPixelIsArea = 1;\n            // constexpr unsigned short RasterPixelIsPoint = 2;\n\n            if (geokeys[i] == GTModelTypeGeoKey) {\n                if (geokeys[i + 3] == ModelTypeProjected) {\n                    extent.isGeographic = false;\n                } else if (geokeys[i + 3] != ModelTypeGeographic) {\n                    pj_log(m_ctx, PJ_LOG_ERROR,\n                           _(\"Only GTModelTypeGeoKey = \"\n                             \"ModelTypeGeographic or ModelTypeProjected are \"\n                             \"supported\"));\n                    return nullptr;\n                }\n            } else if (geokeys[i] == GTRasterTypeGeoKey) {\n                if (geokeys[i + 3] == RasterPixelIsArea) {\n                    pixelIsArea = true;\n                }\n            }\n        }\n    }\n\n    double hRes = 0;\n    double vRes = 0;\n    double west = 0;\n    double north = 0;\n\n    double *matrix = nullptr;\n    if (TIFFGetField(m_hTIFF, TIFFTAG_GEOTRANSMATRIX, &count, &matrix) &&\n        count == 16) {\n        // If using GDAL to produce a bottom-up georeferencing, it will produce\n        // a GeoTransformationMatrix, since negative values in GeoPixelScale\n        // have historically been implementation bugs.\n        if (matrix[1] != 0 || matrix[4] != 0) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   _(\"Rotational terms not supported in \"\n                     \"GeoTransformationMatrix tag\"));\n            return nullptr;\n        }\n\n        west = matrix[3];\n        hRes = matrix[0];\n        north = matrix[7];\n        vRes = -matrix[5]; // negation to simulate GeoPixelScale convention\n    } else {\n        double *geopixelscale = nullptr;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_GEOPIXELSCALE, &count,\n                         &geopixelscale) != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, _(\"No GeoPixelScale tag\"));\n            return nullptr;\n        }\n        if (count != 3) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   _(\"Wrong number of values in GeoPixelScale tag\"));\n            return nullptr;\n        }\n        hRes = geopixelscale[0];\n        vRes = geopixelscale[1];\n\n        double *geotiepoints = nullptr;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_GEOTIEPOINTS, &count,\n                         &geotiepoints) != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, _(\"No GeoTiePoints tag\"));\n            return nullptr;\n        }\n        if (count != 6) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   _(\"Wrong number of values in GeoTiePoints tag\"));\n            return nullptr;\n        }\n\n        west = geotiepoints[3] - geotiepoints[0] * hRes;\n        north = geotiepoints[4] + geotiepoints[1] * vRes;\n    }\n\n    if (pixelIsArea) {\n        west += 0.5 * hRes;\n        north -= 0.5 * vRes;\n    }\n\n    const double mulFactor = extent.isGeographic ? DEG_TO_RAD : 1;\n    extent.west = west * mulFactor;\n    extent.north = north * mulFactor;\n    extent.resX = hRes * mulFactor;\n    extent.resY = fabs(vRes) * mulFactor;\n    extent.east = (west + hRes * (width - 1)) * mulFactor;\n    extent.south = (north - vRes * (height - 1)) * mulFactor;\n\n    if (vRes < 0) {\n        std::swap(extent.north, extent.south);\n    }\n\n    if (!((!extent.isGeographic ||\n           (fabs(extent.west) <= 4 * M_PI && fabs(extent.east) <= 4 * M_PI &&\n            fabs(extent.north) <= M_PI + 1e-5 &&\n            fabs(extent.south) <= M_PI + 1e-5)) &&\n          extent.west < extent.east && extent.south < extent.north &&\n          extent.resX > 1e-10 && extent.resY > 1e-10)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Inconsistent georeferencing for %s\"),\n               m_filename.c_str());\n        return nullptr;\n    }\n\n    auto ret = std::unique_ptr<GTiffGrid>(new GTiffGrid(\n        m_ctx, m_hTIFF, m_cache, m_fp.get(), m_ifdIdx, m_filename, width,\n        height, extent, dt, samplesPerPixel, planarConfig, vRes < 0));\n    m_ifdIdx++;\n    m_hasNextGrid = TIFFReadDirectory(m_hTIFF) != 0;\n    m_nextDirOffset = TIFFCurrentDirOffset(m_hTIFF);\n    return ret;\n}",
    "void ScImgDataLoader_TIFF::loadEmbeddedProfile(const QString& fn, int /*page*/)\n{\n\tm_embeddedProfile.resize(0);\n\tm_profileComponents = 0;\n\tif (!QFile::exists(fn))\n\t\treturn;\n\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn;\n\n\tuint32_t EmbedLen = 0;\n\tvoid*  EmbedBuffer;\n\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer))\n\t{\n\t\tbool profileIsValid = false;\n\t\tQByteArray profArray((const char*) EmbedBuffer, EmbedLen);\n\t\tScColorMgmtEngine engine(ScCore->defaultEngine);\n\t\tScColorProfile tiffProf = engine.openProfileFromMem(profArray);\n\t\tif (tiffProf)\n\t\t{\n\t\t\tuint16_t photometric = 0;\n\t\t\tuint16_t samplesPerPixel = 0;\n\t\t\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric);\n\t\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);\n\t\t\teColorSpaceType colorSpace = tiffProf.colorSpace();\n\t\t\tif (colorSpace == ColorSpace_Rgb)\n\t\t\t\tprofileIsValid = (photometric == PHOTOMETRIC_RGB);\n\t\t\tif (colorSpace == ColorSpace_Cmyk)\n\t\t\t\tprofileIsValid = (photometric == PHOTOMETRIC_SEPARATED && samplesPerPixel >= 4);\n\t\t\tif (colorSpace == ColorSpace_Gray)\n\t\t\t\tprofileIsValid = (photometric == PHOTOMETRIC_MINISBLACK || photometric == PHOTOMETRIC_MINISWHITE);\n\t\t}\n\t\tif (profileIsValid)\n\t\t{\n\t\t\tif (tiffProf.colorSpace() == ColorSpace_Rgb)\n\t\t\t\tm_profileComponents = 3;\n\t\t\tif (tiffProf.colorSpace() == ColorSpace_Cmyk)\n\t\t\t\tm_profileComponents = 4;\n\t\t\tif (tiffProf.colorSpace() == ColorSpace_Gray)\n\t\t\t\tm_profileComponents = 1;\n\t\t\tm_embeddedProfile = profArray;\n\t\t}\n\t}\n\tTIFFClose(tif);\n}",
    "int ScImgDataLoader_TIFF::getLayers(const QString& fn, int /*page*/)\n{\n\tint layerNum = 1;\n\tint test;\n\tstruct PSDLayer lay;\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn layerNum;\n\n\tdo\n\t{\n\t\tchar *layerName = nullptr;\n\t\tTIFFGetField(tif, TIFFTAG_PAGENAME, &layerName);\n\t\tQString name(layerName);\n\t\tif (name.isEmpty())\n\t\t\tlay.layerName = QString(\"Layer #%1\").arg(layerNum);\n\t\telse\n\t\t\tlay.layerName = name;\n\t\tlay.blend = \"norm\";\n\t\tlay.opacity = 255;\n\t\tlay.flags = 0;\n\t\tm_imageInfoRecord.layerInfo.append(lay);\n\t\tm_imageInfoRecord.valid = true;\n\t\tlayerNum++;\n\t\ttest = TIFFReadDirectory(tif);\n\t}\n\twhile (test == 1);\n\tTIFFClose(tif);\n\n\treturn layerNum;\n}",
    "bool ScImgDataLoader_TIFF::getImageData(TIFF* tif, RawImage *image, uint widtht, uint heightt, uint size, const SampleFormatInfo& sampleInfo, bool &bilevel, bool &isCMYK)\n{\n\tif (sampleInfo.photometric != PHOTOMETRIC_SEPARATED)\n\t{\n\t\tif (!getImageData_RGBA(tif, image, widtht, heightt, size, sampleInfo))\n\t\t\treturn false;\n\t\tif (sampleInfo.bitsPerSample == 1)\n\t\t\tbilevel = true;\n\t\tm_pixelFormat = Format_RGBA_8;\n\t\treturn true;\n\t}\n\n\t// Now we are in the PHOTOMETRIC_SEPARATED case\n\tif (sampleInfo.samplesPerPixel > 5)\n\t{\n\t\tif (!getImageData_RGBA(tif, image, widtht, heightt, size, sampleInfo))\n\t\t\treturn false;\n\t\tif (sampleInfo.bitsPerSample == 1)\n\t\t\tbilevel = true;\n\t\tisCMYK = false;\n\t\tm_pixelFormat = Format_RGBA_8;\n\t\treturn true;\n\t}\n\n\tif (sampleInfo.samplesFormat != SAMPLEFORMAT_UINT && sampleInfo.samplesFormat != SAMPLEFORMAT_INT)\n\t{\n\t\tm_message = QObject::tr(\"This image uses an unsupported non integer sample format\");\n\t\tm_msgType = errorMsg;\n\t\treturn false;\n\t}\n\n\tif (sampleInfo.bitsPerSample > 16)\n\t{\n\t\tm_message = QObject::tr(\"This image uses an unsupported bit depth: %1 bits per sample.\").arg(sampleInfo.bitsPerSample);\n\t\tm_msgType = errorMsg;\n\t\treturn false;\n\t}\n\n\tif (TIFFIsTiled(tif))\n\t{\n\t\tuint32_t columns, rows;\n\t\tuint32_t *tile_buf;\n\t\tuint32_t xt, yt;\n\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH,  &columns);\n\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &rows);\n\t\ttile_buf = (uint32_t*) _TIFFmalloc(columns * rows * sizeof(uint32_t));\n\t\tif (tile_buf == nullptr)\n\t\t{\n\t\t\tTIFFClose(tif);\n\t\t\treturn false;\n\t\t}\n\t\tuint32_t tileW = columns, tileH = rows;\n\t\tfor (yt = 0; yt < (uint32_t) image->height(); yt += rows)\n\t\t{\n\t\t\tif (yt > (uint) image->height())\n\t\t\t\tbreak;\n\t\t\tif (image->height() - yt < rows)\n\t\t\t\ttileH = image->height() - yt;\n\t\t\ttileW = columns;\n\t\t\tuint32_t yi;\n\t\t\tint chans = image->channels();\n\t\t\tfor (xt = 0; xt < (uint) image->width(); xt += columns)\n\t\t\t{\n\t\t\t\tTIFFReadTile(tif, tile_buf, xt, yt, 0, 0);\n\t\t\t\tfor (yi = 0; yi < tileH; yi++)\n\t\t\t\t{\n\t\t\t\t\t_TIFFmemcpy(image->scanLine(yt + (tileH - 1 - yi)) + xt, tile_buf + tileW * yi, tileW * chans);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(tile_buf);\n\t}\n\telse\n\t{\n\t\tint chans = image->channels();\n\t\ttsize_t bytesperrow = TIFFScanlineSize(tif);\n\t\tuint32_t *bits = (uint32_t *) _TIFFmalloc(bytesperrow);\n\t\tif (bits)\n\t\t{\n\t\t\tfor (unsigned int y = 0; y < heightt; y++)\n\t\t\t{\n\t\t\t\tif (!TIFFReadScanline(tif, bits, y, 0))\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (sampleInfo.bitsPerSample == 16 && sampleInfo.samplesFormat == SAMPLEFORMAT_UINT)\n\t\t\t\t\tconvertImageData((uint16_t*) bits, (uint8_t*) image->scanLine(y), chans * widtht);\n\t\t\t\telse if (sampleInfo.bitsPerSample == 16 && sampleInfo.samplesFormat == SAMPLEFORMAT_INT)\n\t\t\t\t\tconvertImageData((int16_t*) bits, (uint8_t*) image->scanLine(y), chans * widtht);\n\t\t\t\telse\n\t\t\t\t\tmemcpy(image->scanLine(y), bits, chans * widtht);\n\t\t\t}\n\t\t\t_TIFFfree(bits);\n\t\t}\n\t}\n\tisCMYK = true;\n\tm_pixelFormat = (image->channels() == 5) ? Format_CMYKA_8 : Format_CMYK_8;\n\n\treturn true;\n}",
    "bool ScImgDataLoader_TIFF::getImageData_RGBA(TIFF* tif, RawImage *image, uint widtht, uint heightt, uint size, const SampleFormatInfo& sampleInfo)\n{\n\tuint32_t* bits = (uint32_t *) _TIFFmalloc(size * sizeof(uint32_t));\n\tif (!bits)\n\t\treturn false;\n\n\tuint16_t  extraSamples(0), *extraTypes(nullptr);\n\tif (!TIFFGetField (tif, TIFFTAG_EXTRASAMPLES, &extraSamples, &extraTypes))\n\t\textraSamples = 0;\n\t\n\tbool gotData = false;\n\tif (TIFFReadRGBAImage(tif, widtht, heightt, bits, 0))\n\t{\n\t\tfor (unsigned int y = 0; y < heightt; y++)\n\t\t{\n\t\t\tmemcpy(image->scanLine(heightt - 1 - y), bits + y * widtht, widtht * image->channels());\n\t\t\tif (QSysInfo::ByteOrder == QSysInfo::BigEndian)\n\t\t\t{\n\t\t\t\tunsigned char *s = image->scanLine(heightt - 1 - y);\n\t\t\t\tunsigned char r, g, b, a;\n\t\t\t\tfor (uint xi = 0; xi < widtht; ++xi)\n\t\t\t\t{\n\t\t\t\t\tr = s[0];\n\t\t\t\t\tg = s[1];\n\t\t\t\t\tb = s[2];\n\t\t\t\t\ta = s[3];\n\t\t\t\t\ts[0] = a;\n\t\t\t\t\ts[1] = b;\n\t\t\t\t\ts[2] = g;\n\t\t\t\t\ts[3] = r;\n\t\t\t\t\ts += image->channels();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (extraSamples > 0 && extraTypes[0] == EXTRASAMPLE_ASSOCALPHA)\n\t\t\tunmultiplyRGBA(image);\n\t\tgotData = true;\n\t}\n\t_TIFFfree(bits);\n\n\treturn gotData;\n}",
    "bool ScImgDataLoader_TIFF::loadPicture(const QString& fn, int page, int res, bool thumbnail)\n{\n\tScColorMgmtEngine engine(ScCore->defaultEngine);\n\tbool bilevel = false;\n\tbool failedPS = false;\n\tbool foundPS = false;\n\tshort resolutionUnit = RESUNIT_INCH; // Default unit is inch\n\tfloat xres = 72.0, yres = 72.0;\n\tif (!QFile::exists(fn))\n\t\treturn false;\n\tQByteArray byteOrder(2, ' ');\n\tQFile fo(fn);\n\tif (fo.open(QIODevice::ReadOnly))\n\t{\n\t\tfo.read(byteOrder.data(), 1);\n\t\tfo.close();\n\t}\n\tsrand(314159265);\n\tfor (int i = 0; i < 4096; i++)\n\t\tm_random_table[i] = rand();\n\tfor (int i = 0; i < 4096; i++)\n\t{\n\t\tint tmp;\n\t\tint swap = i + rand() % (4096 - i);\n\t\ttmp = m_random_table[i];\n\t\tm_random_table[i] = m_random_table[swap];\n\t\tm_random_table[swap] = tmp;\n\t}\n\n\tinitialize();\n\n\tint test;\n\tbool valid = m_imageInfoRecord.isRequest;\n\tQMap<int, ImageLoadRequest> req = m_imageInfoRecord.RequestProps;\n\tm_imageInfoRecord.RequestProps = req;\n\tm_imageInfoRecord.isRequest = valid;\n\tm_imageInfoRecord.type = ImageTypeTIF;\n\tgetLayers(fn, page);\n\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn false;\n\n\tbool isCMYK = false;\n\tunsigned int widtht, heightt, size;\n\tchar* description = nullptr;\n\tchar* copyright = nullptr;\n\tchar* datetime = nullptr;\n\tchar* artist = nullptr;\n\tchar* scannerMake = nullptr;\n\tchar* scannerModel = nullptr;\n\tuint16_t bitsPerSample = 1;\n\tuint16_t sampleFormat = SAMPLEFORMAT_UINT;\n\tuint16_t fillorder = FILLORDER_MSB2LSB;\n\tuint16_t planar = PLANARCONFIG_CONTIG;\n\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &widtht);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &heightt);\n\tTIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres);\n\tTIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres);\n\tTIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT , &resolutionUnit);\n\tsize = widtht * heightt;\n\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &m_photometric);\n\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planar);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &m_samplesPerPixel);\n\tTIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\tTIFFGetField(tif, TIFFTAG_FILLORDER, &fillorder);\n\n\tTIFFGetField(tif, TIFFTAG_MAKE, &scannerMake);\n\tTIFFGetField(tif, TIFFTAG_MODEL, &scannerModel);\n\tTIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &description);\n\tTIFFGetField(tif, TIFFTAG_COPYRIGHT, &copyright);\n\tTIFFGetField(tif, TIFFTAG_DATETIME, &datetime);\n\tTIFFGetField(tif, TIFFTAG_ARTIST, &artist);\n\n\tSampleFormatInfo sampleInfo;\n\tsampleInfo.photometric = m_photometric;\n\tsampleInfo.bitsPerSample = bitsPerSample;\n\tsampleInfo.samplesPerPixel = m_samplesPerPixel;\n\tsampleInfo.samplesFormat = sampleFormat;\n\tsampleInfo.fillOrder = fillorder;\n\n\tm_imageInfoRecord.exifInfo.cameraName = QString(scannerModel);\n\tm_imageInfoRecord.exifInfo.cameraVendor = QString(scannerMake);\n\tm_imageInfoRecord.exifInfo.comment = QString(description);\n\tm_imageInfoRecord.exifInfo.userComment = QString(copyright);\n\tm_imageInfoRecord.exifInfo.width = widtht;\n\tm_imageInfoRecord.exifInfo.height = heightt;\n\tm_imageInfoRecord.exifInfo.dateTime = QString(datetime);\n\tm_imageInfoRecord.exifInfo.artist = QString(artist);\n\tm_imageInfoRecord.exifInfo.thumbnail = QImage();\n\tm_imageInfoRecord.exifDataValid = true;\n\n\tm_imageInfoRecord.isEmbedded = false;\n\tm_imageInfoRecord.profileName.clear();\n\tm_imageInfoRecord.embeddedProfileName.clear();\n\n\tuint32_t EmbedLen = 0;\n\tvoid*  EmbedBuffer;\n\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer))\n\t{\n\t\tbool profileIsValid = false;\n\t\tQByteArray profArray((const char*) EmbedBuffer, EmbedLen);\n\t\tScColorProfile tiffProf = engine.openProfileFromMem(profArray);\n\t\tif (tiffProf)\n\t\t{\n\t\t\teColorSpaceType colorSpace = tiffProf.colorSpace();\n\t\t\tif (colorSpace == ColorSpace_Rgb)\n\t\t\t\tprofileIsValid = (m_photometric == PHOTOMETRIC_RGB);\n\t\t\tif (colorSpace == ColorSpace_Cmyk)\n\t\t\t\tprofileIsValid = (m_photometric == PHOTOMETRIC_SEPARATED && m_samplesPerPixel >= 4);\n\t\t\tif (colorSpace == ColorSpace_Gray)\n\t\t\t\tprofileIsValid = (m_photometric == PHOTOMETRIC_MINISBLACK || m_photometric == PHOTOMETRIC_MINISWHITE);\n\t\t}\n\t\tif (profileIsValid)\n\t\t{\n\t\t\tm_embeddedProfile = profArray;\n\t\t\tm_imageInfoRecord.profileName = tiffProf.productDescription();\n\t\t\tm_imageInfoRecord.embeddedProfileName = m_imageInfoRecord.profileName;\n\t\t\tm_imageInfoRecord.isEmbedded = true;\n\t\t}\n\t}\n\n\tunsigned int PhotoshopLen = 0;\n\tunsigned char* PhotoshopBuffer;\n\tif (TIFFGetField(tif, TIFFTAG_PHOTOSHOP, &PhotoshopLen, &PhotoshopBuffer) )\n\t{\n\t\tif (PhotoshopLen != 0)\n\t\t{\n\t\t\tQByteArray arrayPhot = QByteArray((const char*)PhotoshopBuffer,PhotoshopLen);\n\t\t\tQDataStream strPhot(&arrayPhot,QIODevice::ReadOnly);\n\t\t\tstrPhot.setByteOrder( QDataStream::BigEndian );\n\t\t\tPSDHeader fakeHeader;\n\t\t\tfakeHeader.width = widtht;\n\t\t\tfakeHeader.height = heightt;\n\t\t\tparseResourceData(strPhot, fakeHeader, PhotoshopLen);\n\t\t\tm_imageInfoRecord.exifInfo.width = widtht;\n\t\t\tm_imageInfoRecord.exifInfo.height = heightt;\n\t\t\tif (!m_imageInfoRecord.valid)\n\t\t\t\tm_imageInfoRecord.valid = (m_imageInfoRecord.PDSpathData.size())>0;\n\t\t\tif (thumbnail)\n\t\t\t{\n\t\t\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t\t{\n\t\t\t\t\tisCMYK = true;\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\t\t\t}\n\t\t\t\telse if (m_samplesPerPixel == 1)\n\t\t\t\t{\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t\t\t\t\tisCMYK = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\t\t\tif (bitsPerSample == 1)\n\t\t\t\t\tbilevel = true;\n\t\t\t\tif (!m_imageInfoRecord.exifInfo.thumbnail.isNull())\n\t\t\t\t{\n\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t{\n\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 5);\n\t\t\t\t\t\tm_pixelFormat = Format_CMYKA_8;;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 4);\n\t\t\t\t\t\tm_pixelFormat = (m_imageInfoRecord.colorspace == ColorSpaceCMYK) ? Format_CMYK_8 : Format_RGBA_8;\n\t\t\t\t\t}\n\t\t\t\t\tr_image.fill(0);\n\t\t\t\t\tQRgb *s;\n\t\t\t\t\tuchar *d;\n\t\t\t\t\tunsigned char cc, cm, cy, ck;\n\t\t\t\t\tfor (int yit = 0; yit < m_imageInfoRecord.exifInfo.thumbnail.height(); ++yit)\n\t\t\t\t\t{\n\t\t\t\t\t\ts = (QRgb*)(m_imageInfoRecord.exifInfo.thumbnail.scanLine(yit));\n\t\t\t\t\t\td = r_image.scanLine(yit);\n\t\t\t\t\t\tfor (int xit = 0; xit < m_imageInfoRecord.exifInfo.thumbnail.width(); ++xit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcc = 255 - qRed(*s);\n\t\t\t\t\t\t\t\tcm = 255 - qGreen(*s);\n\t\t\t\t\t\t\t\tcy = 255 - qBlue(*s);\n\t\t\t\t\t\t\t\tck = qMin(qMin(cc, cm), cy);\n\t\t\t\t\t\t\t\td[0] = cc-ck;\n\t\t\t\t\t\t\t\td[1] = cm-ck;\n\t\t\t\t\t\t\t\td[2] = cy-ck;\n\t\t\t\t\t\t\t\td[3] = ck;\n\t\t\t\t\t\t\t\td[4] = 255;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\td[0] = qRed(*s);\n\t\t\t\t\t\t\t\td[1] = qGreen(*s);\n\t\t\t\t\t\t\t\td[2] = qBlue(*s);\n\t\t\t\t\t\t\t\td[3] = 255;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\td += r_image.channels();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tunsigned int PhotoshopLen2 = 0;\n\tunsigned char* PhotoshopBuffer2;\n\tint gotField = TIFFGetField(tif, 37724, &PhotoshopLen2, &PhotoshopBuffer2);\n\tif (gotField && (PhotoshopLen2 > 40))\n\t{\n\t\tm_imageInfoRecord.layerInfo.clear();\n\t\tQByteArray arrayPhot = QByteArray::fromRawData((const char*)PhotoshopBuffer2, PhotoshopLen2);\n\t\tQDataStream s(&arrayPhot,QIODevice::ReadOnly);\n\t\tif (byteOrder[0] == 'M')\n\t\t\ts.setByteOrder( QDataStream::BigEndian );\n\t\telse\n\t\t\ts.setByteOrder( QDataStream::LittleEndian );\n\n\t\tfailedPS = !loadLayerInfo(s, m_imageInfoRecord.layerInfo); \n\t\tif (!failedPS)\n\t\t{\n\t\t\tint chans = 4;\n\t\t\tint numChannels = m_imageInfoRecord.layerInfo.last().channelType.count();\n\t\t\tint numLayers = m_imageInfoRecord.layerInfo.count();\n\t\t\tPSDHeader fakeHeader;\n\t\t\tfakeHeader.width = widtht;\n\t\t\tfakeHeader.height = heightt;\n\t\t\tfakeHeader.channel_count = numChannels;\n\t\t\tfakeHeader.depth = 8;\n\t\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t{\n\t\t\t\tisCMYK = true;\n\t\t\t\tfakeHeader.color_mode = CM_CMYK;\n\t\t\t\tchans = 5;\n\t\t\t}\n\t\t\telse if (m_samplesPerPixel == 1)\n\t\t\t{\n\t\t\t\tfakeHeader.color_mode = CM_GRAYSCALE;\n\t\t\t\tisCMYK = false;\n\t\t\t\tchans = 4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfakeHeader.color_mode = CM_RGB;\n\t\t\t\tisCMYK = false;\n\t\t\t\tchans = 4;\n\t\t\t}\n\t\t\tif (!r_image.create(widtht, heightt, chans))\n\t\t\t\treturn false;\n\t\t\tr_image.fill(0);\n\t\t\tbool firstLayer = true;\n\t\t\tfor (int layer = 0; layer < numLayers; layer++)\n\t\t\t{\n\t\t\t\tloadLayerChannels( s, fakeHeader, m_imageInfoRecord.layerInfo, layer, &firstLayer );\n\t\t\t}\n\t\t\tarrayPhot.clear();\n\t\t\tTIFFClose(tif);\n\t\t\tfoundPS = true;\n\t\t\tif (m_imageInfoRecord.layerInfo.count() == 1)\n\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarrayPhot.clear();\n\t\t\tgetLayers(fn, page);\n\t\t}\n\t}\n\n\tif (xres <= 1.0 || yres <= 1.0)\n\t{\n\t\txres = yres = 72.0;\n\t\tQFileInfo qfi(fn);\n\t\tm_message = QObject::tr(\"%1 may be corrupted : missing resolution tags\").arg(qfi.fileName());\n\t\tm_msgType = warningMsg;\n\t}\n\tif ((!foundPS) || (failedPS))\n\t{\n\t\tint chans = 4;\n\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t{\n\t\t\tif (m_samplesPerPixel > 5) \n\t\t\t\tchans = 4;\n\t\t\telse\n\t\t\t\tchans = m_samplesPerPixel;\n\t\t}\n\t\telse\n\t\t\tchans = 4;\n\t\tif (!r_image.create(widtht, heightt, chans))\n\t\t{\n\t\t\tTIFFClose(tif);\n\t\t\treturn false;\n\t\t}\n\t\tr_image.fill(0);\n\t\tint layerNum = 0;\n\t\tdo\n\t\t{\n\t\t\tRawImage tmpImg;\n\t\t\tif (!tmpImg.create(widtht, heightt, chans))\n\t\t\t{\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttmpImg.fill(0);\n\t\t\tif (!getImageData(tif, &tmpImg, widtht, heightt, size, sampleInfo, bilevel, isCMYK))\n\t\t\t{\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbool visible = true;\n\t\t\tbool useMask = true;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tvisible = m_imageInfoRecord.RequestProps[layerNum].visible;\n\t\t\tQString layBlend(\"norm\");\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tlayBlend = m_imageInfoRecord.RequestProps[layerNum].blend;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tuseMask = m_imageInfoRecord.RequestProps[layerNum].useMask;\n\t\t\tint layOpa = 255;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tlayOpa = m_imageInfoRecord.RequestProps[layerNum].opacity;\n\t\t\tif (visible)\n\t\t\t{\n\t\t\t\tif ((layerNum == 0) && (layBlend != \"diss\"))\n\t\t\t\t\tr_image = tmpImg;\n\t\t\t\telse\n\t\t\t\t\tblendOntoTarget(&tmpImg, layOpa, layBlend, isCMYK, useMask);\n\t\t\t}\n\t\t\t//JG Copy should not be necessary as QImage is implicitly shared in Qt4\n\t\t\tQImage imt; //QImage imt = tmpImg.copy();\n\t\t\tdouble sx = tmpImg.width() / 40.0;\n\t\t\tdouble sy = tmpImg.height() / 40.0;\n\t\t\timt = tmpImg.convertToQImage(chans > 4);\n\t\t\timt = sy < sx ?\timt.scaled(qRound(imt.width() / sx), qRound(imt.height() / sx), Qt::IgnoreAspectRatio, Qt::SmoothTransformation) :\n\t\t\t\t\t\t\t\t\t\timt.scaled(qRound(imt.width() / sy), qRound(imt.height() / sy), Qt::IgnoreAspectRatio, Qt::SmoothTransformation);\n\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb = imt.copy();\n\t\t\tif (chans > 4)\n\t\t\t{\n\t\t\t\tQImage imt2 = imt.createAlphaMask();\n\t\t\t\timt2.invertPixels();\n\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = imt2.copy();\n\t\t\t}\n\t\t\telse\n\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = QImage();\n\t\t\tlayerNum++;\n\n\t\t\tif ((m_imageInfoRecord.layerInfo.count() == 1) && (chans < 5))\n\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t\ttest = TIFFReadDirectory(tif);\n\n\t\t\t// #10415 : check that image size for the current directory is the same as the main one\n\t\t\t// Some progs use tiff directory to store previews, we do not handle such case\n\t\t\t// and may perform reads in non allocated blocks if we continue\n\t\t\twhile (test == 1)\n\t\t\t{\n\t\t\t\tunsigned int dirWidth(0), dirHeight(0);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &dirWidth);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &dirHeight);\n\t\t\t\tif (dirWidth == widtht && dirHeight == heightt)\n\t\t\t\t\tbreak;\n\t\t\t\ttest = TIFFReadDirectory(tif);\n\t\t\t\tlayerNum++;\n\t\t\t}\n\t\t}\n\t\twhile (test == 1);\n\t\tTIFFClose(tif);\n\t}\n\tif (resolutionUnit == RESUNIT_INCH)\n\t{\n\t\tm_image.setDotsPerMeterX ((int) (xres / 0.0254));\n\t\tm_image.setDotsPerMeterY ((int) (yres / 0.0254));\n\t\tm_imageInfoRecord.xres = qRound(xres);\n\t\tm_imageInfoRecord.yres = qRound(yres);\n\t}\n\telse if (resolutionUnit == RESUNIT_CENTIMETER)\n\t{\n\t\tm_image.setDotsPerMeterX ((int) (xres * 100.0));\n\t\tm_image.setDotsPerMeterY ((int) (yres * 100.0));\n\t\tm_imageInfoRecord.xres = qRound(xres*2.54);\n\t\tm_imageInfoRecord.yres = qRound(yres*2.54);\n\t}\n\tif (isCMYK)\n\t{\n\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\tm_pixelFormat = (r_image.channels() == 5) ? Format_CMYKA_8 : Format_CMYK_8;\n\t}\n\telse if (m_samplesPerPixel == 1)\n\t{\n\t\t// Do not set m_pixelFormat here as the real pixel format is most probably different than gray\n\t\tif (bitsPerSample == 1)\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceMonochrome;\n\t\telse\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t}\n\telse\n\t{\n\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\tm_pixelFormat = Format_RGBA_8;\n\t}\n\tm_imageInfoRecord.BBoxX = 0;\n\tm_imageInfoRecord.BBoxH = r_image.height();\n\tm_imageInfoRecord.valid = !(m_imageInfoRecord.layerInfo.isEmpty() && m_imageInfoRecord.PDSpathData.isEmpty());\n\treturn true;\n}",
    "IFD::IFD(TIFF* tiff, uint16_t index, ifd_offset_t offset) : tiff_(tiff), ifd_index_(index), ifd_offset_(offset)\n{\n    PROF_SCOPED_RANGE(PROF_EVENT(ifd_ifd));\n    auto tif = tiff->client();\n\n    char* software_char_ptr = nullptr;\n    char* model_char_ptr = nullptr;\n\n    // TODO: error handling\n    TIFFGetField(tif, TIFFTAG_SOFTWARE, &software_char_ptr);\n    software_ = std::string(software_char_ptr ? software_char_ptr : \"\");\n    TIFFGetField(tif, TIFFTAG_MODEL, &model_char_ptr);\n    model_ = std::string(model_char_ptr ? model_char_ptr : \"\");\n    TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &model_char_ptr);\n    image_description_ = std::string(model_char_ptr ? model_char_ptr : \"\");\n    TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, &resolution_unit_);\n    TIFFGetField(tif, TIFFTAG_XRESOLUTION, &x_resolution_);\n    TIFFGetField(tif, TIFFTAG_YRESOLUTION, &y_resolution_);\n\n    TIFFDirectory& tif_dir = tif->tif_dir;\n    flags_ = tif->tif_flags;\n\n    width_ = tif_dir.td_imagewidth;\n    height_ = tif_dir.td_imagelength;\n    if ((flags_ & TIFF_ISTILED) != 0)\n    {\n        tile_width_ = tif_dir.td_tilewidth;\n        tile_height_ = tif_dir.td_tilelength;\n    }\n    else\n    {\n        rows_per_strip_ = tif_dir.td_rowsperstrip;\n    }\n    bits_per_sample_ = tif_dir.td_bitspersample;\n    samples_per_pixel_ = tif_dir.td_samplesperpixel;\n    subfile_type_ = tif_dir.td_subfiletype;\n    planar_config_ = tif_dir.td_planarconfig;\n    photometric_ = tif_dir.td_photometric;\n    compression_ = tif_dir.td_compression;\n    TIFFGetField(tif, TIFFTAG_PREDICTOR, &predictor_);\n    subifd_count_ = tif_dir.td_nsubifd;\n    uint64_t* subifd_offsets = tif_dir.td_subifd;\n    if (subifd_count_)\n    {\n        subifd_offsets_.resize(subifd_count_);\n        subifd_offsets_.insert(subifd_offsets_.end(), &subifd_offsets[0], &subifd_offsets[subifd_count_]);\n    }\n\n    if (compression_ == COMPRESSION_JPEG)\n    {\n        uint8_t* jpegtable_data = nullptr;\n        uint32_t jpegtable_count = 0;\n\n        TIFFGetField(tif, TIFFTAG_JPEGTABLES, &jpegtable_count, &jpegtable_data);\n        jpegtable_.reserve(jpegtable_count);\n        jpegtable_.insert(jpegtable_.end(), jpegtable_data, jpegtable_data + jpegtable_count);\n\n        if (photometric_ == PHOTOMETRIC_RGB)\n        {\n            jpeg_color_space_ = 2; // JCS_RGB\n        }\n        else if (photometric_ == PHOTOMETRIC_YCBCR)\n        {\n            jpeg_color_space_ = 3; // JCS_YCbCr\n        }\n    }\n\n    image_piece_count_ = tif_dir.td_stripoffset_entry.tdir_count;\n\n    image_piece_offsets_.reserve(image_piece_count_);\n    uint64* td_stripoffset_p = tif_dir.td_stripoffset_p;\n    uint64* td_stripbytecount_p = tif_dir.td_stripbytecount_p;\n\n    // Copy data to vector\n    image_piece_offsets_.insert(image_piece_offsets_.end(), &td_stripoffset_p[0], &td_stripoffset_p[image_piece_count_]);\n    image_piece_bytecounts_.insert(\n        image_piece_bytecounts_.end(), &td_stripbytecount_p[0], &td_stripbytecount_p[image_piece_count_]);\n\n    // Calculate hash value with IFD index\n    hash_value_ = tiff->file_handle_->hash_value ^ cucim::codec::splitmix64(index);\n\n    //    TIFFPrintDirectory(tif, stdout, TIFFPRINT_STRIPS);\n}",
    "TiffImage_Libtiff::TiffImage_Libtiff(const uint8_t *encoded_buffer,\n                                     size_t length,\n                                     DALIImageType image_type)\n    : GenericImage(encoded_buffer, length, image_type),\n      buf_({encoded_buffer, static_cast<ptrdiff_t>(length)}),\n      buf_pos_(0) {\n  tif_.reset(\n    TIFFClientOpen(\"\", \"r\",\n                   reinterpret_cast<thandle_t>(\n                     new detail::BufDecoderHelper(buf_, buf_pos_)),\n                   &detail::BufDecoderHelper::read,\n                   &detail::BufDecoderHelper::write,\n                   &detail::BufDecoderHelper::seek,\n                   &detail::BufDecoderHelper::close,\n                   &detail::BufDecoderHelper::size,\n                   &detail::BufDecoderHelper::map,\n                   /*unmap=*/0));\n  DALI_ENFORCE(tif_, \"Cannot open TIFF file.\");\n\n  LIBTIFF_CALL(\n    TIFFGetField(tif_.get(), TIFFTAG_IMAGELENGTH, &shape_[0]));\n  LIBTIFF_CALL(\n    TIFFGetField(tif_.get(), TIFFTAG_IMAGEWIDTH, &shape_[1]));\n  LIBTIFF_CALL(\n    TIFFGetFieldDefaulted(tif_.get(), TIFFTAG_SAMPLESPERPIXEL, &shape_[2]));\n  is_tiled_ = static_cast<bool>(\n    TIFFIsTiled(tif_.get()));\n  LIBTIFF_CALL(\n    TIFFGetFieldDefaulted(tif_.get(), TIFFTAG_BITSPERSAMPLE, &bit_depth_));\n  DALI_ENFORCE(bit_depth_ <= 64,\n    \"Unexpected bit depth: \" + std::to_string(bit_depth_));\n  LIBTIFF_CALL(\n    TIFFGetFieldDefaulted(tif_.get(), TIFFTAG_ORIENTATION, &orientation_));\n  LIBTIFF_CALL(\n    TIFFGetFieldDefaulted(tif_.get(), TIFFTAG_ROWSPERSTRIP, &rows_per_strip_));\n  LIBTIFF_CALL(\n    TIFFGetFieldDefaulted(tif_.get(), TIFFTAG_COMPRESSION, &compression_));\n\n  uint16_t photometric_interpretation;\n  if (TIFFGetField(tif_.get(), TIFFTAG_PHOTOMETRIC, &photometric_interpretation) &&\n      photometric_interpretation == PHOTOMETRIC_PALETTE) {\n    shape_[2] = 3;\n    palette_ = true;\n  }\n}",
    "void vw::DiskImageResourceTIFF::open( std::string const& filename ) {\n  m_info->filename = filename;\n\n  TIFFSetWarningHandler( &tiff_warning_handler );\n  TIFFSetErrorHandler( &tiff_error_handler );\n\n  TIFF* tif = TIFFOpen( filename.c_str(), \"r\" );\n  if( !tif ) vw_throw( vw::ArgumentErr() << \"DiskImageResourceTIFF: Failed to open \\\"\" << filename << \"\\\" for reading!\" );\n\n  // Read into temp variables first to ensure we are using the right integer type.\n  // Otherwise we can run into endianness problems.\n  uint32 cols_tmp, rows_tmp;\n  uint16 planes_tmp;\n  check_retval(TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &cols_tmp ), 0);\n  check_retval(TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &rows_tmp ), 0);\n  check_retval(\n    TIFFGetFieldDefaulted( tif, TIFFTAG_SAMPLESPERPIXEL, &planes_tmp ), 0);\n  m_format.cols = cols_tmp;\n  m_format.rows = rows_tmp;\n  m_format.planes = planes_tmp;\n\n  uint16 sample_format = 0, bits_per_sample = 0, photometric = 0;\n  check_retval(\n    TIFFGetFieldDefaulted( tif, TIFFTAG_BITSPERSAMPLE, &bits_per_sample ), 0);\n  check_retval(\n    TIFFGetFieldDefaulted( tif, TIFFTAG_SAMPLEFORMAT, &sample_format ), 0);\n  check_retval(TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ), 0);\n\n  m_format.channel_type = VW_CHANNEL_UNKNOWN;\n  switch( sample_format ) {\n  case SAMPLEFORMAT_UINT:\n    if (bits_per_sample == 8)\n      m_format.channel_type = VW_CHANNEL_UINT8;\n    else if (bits_per_sample == 16)\n      m_format.channel_type = VW_CHANNEL_UINT16;\n    else if (bits_per_sample == 32)\n      m_format.channel_type = VW_CHANNEL_UINT32;\n    else if (bits_per_sample == 64)\n      m_format.channel_type = VW_CHANNEL_UINT64;\n    break;\n  case SAMPLEFORMAT_INT:\n    if (bits_per_sample == 8)\n      m_format.channel_type = VW_CHANNEL_INT8;\n    else if (bits_per_sample == 16)\n      m_format.channel_type = VW_CHANNEL_INT16;\n    else if (bits_per_sample == 32)\n      m_format.channel_type = VW_CHANNEL_INT32;\n    else if (bits_per_sample == 64)\n      m_format.channel_type = VW_CHANNEL_INT64;\n    break;\n  case SAMPLEFORMAT_IEEEFP:\n    if (bits_per_sample == 16)\n      m_format.channel_type = VW_CHANNEL_FLOAT16;\n    else if (bits_per_sample == 32)\n      m_format.channel_type = VW_CHANNEL_FLOAT32;\n    else if (bits_per_sample == 64)\n      m_format.channel_type = VW_CHANNEL_FLOAT64;\n    break;\n  }\n  if( ! m_format.channel_type ) {\n    vw_throw( IOErr() << \"DiskImageResourceTIFF: \" << m_filename << \" has an unsupported channel type (\"\n              << sample_format << \",\" << bits_per_sample << \")!\" );\n  }\n\n  uint16 plane_configuration = 0;\n  check_retval(TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &plane_configuration), 0);\n\n  // FIXME: Tiff might actually provide us with some info on\n  // colorimetric interpretation of the channels, so maybe we should\n  // try to use that here as well?\n  if( photometric == PHOTOMETRIC_PALETTE ) {\n    m_format.channel_type = VW_CHANNEL_UINT16;\n    m_format.pixel_format = VW_PIXEL_RGB;\n  }\n  else if( m_format.planes == 1 ) {\n    m_format.pixel_format = VW_PIXEL_GRAY;\n  }\n  else {\n    switch( m_format.planes ) {\n    case 2:  m_format.pixel_format = VW_PIXEL_GRAYA;  m_format.planes=1; break;\n    case 3:  m_format.pixel_format = VW_PIXEL_RGB;    m_format.planes=1; break;\n    case 4:  m_format.pixel_format = VW_PIXEL_RGBA;   m_format.planes=1; break;\n    default: m_format.pixel_format = VW_PIXEL_SCALAR; break;\n    }\n  }\n\n  if( TIFFIsTiled(tif) ) {\n    uint32 tile_width, tile_length;\n    check_retval(TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width ), 0);\n    check_retval(TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_length ), 0);\n    m_info->block_size = Vector2i(tile_width,tile_length);\n  }\n  else {\n    uint32 rows_per_strip;\n    check_retval(TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &rows_per_strip ), 0);\n    m_info->block_size = Vector2i(cols(),rows_per_strip);\n  }\n\n  TIFFClose(tif);\n}",
    "void vw::DiskImageResourceTIFF::read( ImageBuffer const& dest, BBox2i const& bbox ) const\n{\n  VW_ASSERT( int(dest.format.cols)==bbox.width() && int(dest.format.rows)==bbox.height(),\n             ArgumentErr() << \"DiskImageResourceTIFF (read) Error: Destination buffer has wrong dimensions!\" );\n\n  // Only support sequential reading on striped TIFFs right now.\n  if( !m_info || !(m_info->tif) || !(m_info->striped) || (m_info->striped && m_info->current_line > bbox.min().y()) )\n    m_info->reopen_read();\n\n  uint16 config = 0, bpsample = 0, nsamples = 0, photometric = 0;\n  check_retval(TIFFGetField(m_info->tif, TIFFTAG_PLANARCONFIG, &config), 0);\n  check_retval(TIFFGetField(m_info->tif, TIFFTAG_BITSPERSAMPLE, &bpsample), 0);\n  check_retval(TIFFGetField(m_info->tif, TIFFTAG_SAMPLESPERPIXEL, &nsamples), 0);\n  check_retval(TIFFGetField(m_info->tif, TIFFTAG_PHOTOMETRIC, &photometric), 0);\n\n  bool is_planar = (config == PLANARCONFIG_SEPARATE) && (m_format.pixel_format != VW_PIXEL_SCALAR);\n  bool is_tiled = TIFFIsTiled(m_info->tif);\n  m_info->striped = !is_tiled;\n\n  // Compute the tile or strip geometry\n  uint32 block_cols, block_rows, block_size, blocks_per_row, blocks_per_plane;\n  if( is_tiled ) {\n    check_retval(TIFFGetField(m_info->tif, TIFFTAG_TILEWIDTH, &block_cols), 0);\n    check_retval(TIFFGetField(m_info->tif, TIFFTAG_TILELENGTH, &block_rows), 0);\n    block_size = TIFFTileSize(m_info->tif);\n    blocks_per_row = (cols()-1) / block_cols + 1;\n    blocks_per_plane = blocks_per_row * ( (rows()-1) / block_rows + 1 );\n  }\n  else {\n    block_cols = cols();\n    check_retval(TIFFGetField( m_info->tif, TIFFTAG_ROWSPERSTRIP, &block_rows ), 0);\n    block_size = TIFFStripSize(m_info->tif);\n    blocks_per_row = 1;\n    blocks_per_plane = (rows()-1) / block_rows + 1;\n  }\n\n  tdata_t buf = _TIFFmalloc( block_size );\n  if( !buf ) vw_throw( vw::IOErr() << \"DiskImageResourceTIFF: Failed to malloc!\" );\n\n  // Allocate a buffer interleave planar data\n  tdata_t plane_buf = 0;\n  if( is_planar ) {\n    plane_buf = buf;\n    buf = _TIFFmalloc( block_size * nsamples );\n    if( !buf ) vw_throw( vw::IOErr() << \"DiskImageResourceTIFF: Failed to malloc!\" );\n  }\n\n  // Palettized TIFFs are always uint16 RGB\n  tdata_t palette_buf = 0;\n  uint16 *red_table, *green_table, *blue_table;\n  if( photometric == PHOTOMETRIC_PALETTE ) {\n    palette_buf = buf;\n    buf = _TIFFmalloc( block_cols*block_rows*6 );\n    if( !buf ) vw_throw( vw::IOErr() << \"DiskImageResourceTIFF: Failed to malloc!\" );\n\n    check_retval(TIFFGetField( m_info->tif, TIFFTAG_COLORMAP, &red_table, &green_table, &blue_table ), 0);\n  }\n\n  // Set up the source and destination image buffers\n  ImageBuffer src_buf, dest_buf=dest;\n  src_buf.format = m_format;\n  if( photometric == PHOTOMETRIC_PALETTE ) src_buf.cstride = 6;\n  else src_buf.cstride = bpsample * nsamples / 8;\n  src_buf.rstride = block_cols*src_buf.cstride;\n  src_buf.pstride = block_rows*src_buf.rstride;\n\n  for( int block_y = bbox.min().y()/block_rows; block_y <= int((bbox.max().y()-1)/block_rows); ++block_y ) {\n    for( int block_x = bbox.min().x()/block_cols; block_x <= int((bbox.max().x()-1)/block_cols); ++block_x ) {\n      int block_id = block_y * blocks_per_row + block_x;\n      int data_left = (std::max)(block_x*block_cols,uint32(bbox.min().x()))-block_x*block_cols;\n      int data_top  = (std::max)(block_y*block_rows,uint32(bbox.min().y()))-block_y*block_rows;\n      int data_right = (std::min)((block_x+1)*block_cols,uint32(bbox.max().x()))-block_x*block_cols;\n      int data_bottom = (std::min)((block_y+1)*block_rows,uint32(bbox.max().y()))-block_y*block_rows;\n\n      // Read the block into the buffer, converting planar or palettized data as needed.\n      if( is_planar ) {\n        // At the moment we make an extra copy here to spoof plane contiguity\n        for( int i=0; i<nsamples; ++i ) {\n          if( is_tiled ) check_retval(TIFFReadEncodedTile( m_info->tif, block_id+i*blocks_per_plane, plane_buf, (tsize_t) -1 ), -1);\n          else check_retval(TIFFReadEncodedStrip( m_info->tif, block_id+i*blocks_per_plane, plane_buf, (tsize_t) -1 ), 0);\n          // Oh man, this is horrible!\n          switch(bpsample/8) {\n          case 1:\n            for( int y=data_top; y<data_bottom; ++y ) {\n              for( int x=data_left; x<data_right; ++x ) {\n                ((uint8*)buf)[(y*block_cols+x)*nsamples+i] = ((uint8*)plane_buf)[y*block_cols+x];\n              }\n            }\n            break;\n          case 2:\n            for( int y=data_top; y<data_bottom; ++y ) {\n              for( int x=data_left; x<data_right; ++x ) {\n                ((uint16*)buf)[(y*block_cols+x)*nsamples+i] = ((uint16*)plane_buf)[y*block_cols+x];\n              }\n            }\n            break;\n          case 4:\n            for( int y=data_top; y<data_bottom; ++y ) {\n              for( int x=data_left; x<data_right; ++x ) {\n                ((uint32*)buf)[(y*block_cols+x)*nsamples+i] = ((uint32*)plane_buf)[y*block_cols+x];\n              }\n            }\n            break;\n          default:\n            vw_throw( NoImplErr() << \"Unsupported bit depth in separate-plane TIFF!\" );\n          }\n        }\n      }\n      else if( photometric == PHOTOMETRIC_PALETTE ) {\n        if( is_tiled ) check_retval(TIFFReadEncodedTile( m_info->tif, block_id, palette_buf, (tsize_t) -1 ), -1);\n        else check_retval(TIFFReadEncodedStrip( m_info->tif, block_id, palette_buf, (tsize_t) -1 ), 0);\n        if( photometric == PHOTOMETRIC_PALETTE ) {\n          for( int y=data_top; y<data_bottom; ++y ) {\n            for( int x=data_left; x<data_right; ++x ) {\n              int i = y*block_cols + x;\n              int p = ((uint8*)palette_buf)[i];\n              ((uint16*)buf)[3*i+0] = red_table[p];\n              ((uint16*)buf)[3*i+1] = green_table[p];\n              ((uint16*)buf)[3*i+2] = blue_table[p];\n            }\n          }\n        }\n      }\n      else {\n        if( is_tiled )  {\n          check_retval(TIFFReadEncodedTile( m_info->tif, block_id, buf, (tsize_t) -1 ), -1);\n        } else {\n          check_retval(TIFFReadEncodedStrip( m_info->tif, block_id, buf, (tsize_t) -1 ), -1);\n          m_info->current_line++;\n        }\n      }\n\n      src_buf.data = (uint8*)buf + data_left*src_buf.cstride + data_top*src_buf.rstride;\n      dest_buf.data = (uint8*)dest.data + (data_left+block_x*block_cols-bbox.min().x())*dest.cstride + (data_top+block_y*block_rows-bbox.min().y())*dest.rstride;\n      src_buf.format.cols = dest_buf.format.cols = data_right-data_left;\n      src_buf.format.rows = dest_buf.format.rows = data_bottom-data_top;\n\n      convert( dest_buf, src_buf, m_rescale );\n    }\n\n  }\n\n  _TIFFfree(buf);\n  if( plane_buf ) _TIFFfree(plane_buf);\n  if( palette_buf ) _TIFFfree(palette_buf);\n  // Sorry .. this keeps us from incrementally reading\n  m_info->close();\n}",
    "IImageObject* LoadImageFromTIFF(const AZStd::string& filename)\n        {\n#ifdef AZ_ENABLE_TRACING\n            // Reroute the TIFF loader Error Handler so that any load errors are recorded.\n            // There is also a warning handler that can get rerouted via TIFFSetWarningHandler, but the warnings include noisy notices\n            // like 'tiff tag X unsupported', so it isn't currently hooked up here.\n            TIFFSetErrorHandler(ImageProcessingTiffErrorHandler);\n#endif\n\n            TiffFileRead tiffRead(filename);\n            TIFF* tif = tiffRead.GetTiff();\n\n            IImageObject* pRet = nullptr;\n\n            if (!tif)\n            {\n                AZ_Warning(\"Image Processing\", false, \"%s: Open tiff failed (%s)\", __FUNCTION__, filename.c_str());\n                return pRet;\n            }\n\n            uint32_t dwBitsPerChannel = 0;\n            uint32_t dwChannels = 0;\n            uint32_t dwFormat = 0;\n            TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &dwChannels);\n            TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &dwBitsPerChannel);\n            TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &dwFormat);\n\n            if (dwChannels != 1 && dwChannels != 2 && dwChannels != 3 && dwChannels != 4)\n            {\n                AZ_Warning(\"Image Processing\", false, \"Unsupported TIFF pixel format (channel count: %d)\", dwChannels);\n                return pRet;\n            }\n\n            uint32_t dwWidth = 0;\n            uint32_t dwHeight = 0;\n            TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &dwWidth);\n            TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &dwHeight);\n            if (dwWidth <= 0 || dwHeight <= 0)\n            {\n                AZ_Error(\"Image Processing\", false, \"%s failed (empty image)\", __FUNCTION__);\n                return pRet;\n            }\n\n            bool validFormat = false;\n\n            // Currently, we only support uint/int TIFFs with 8 or 16 bits per channel and float TIFFs with 16 or 32 bits per channel.\n            switch (dwFormat)\n            {\n                case SAMPLEFORMAT_UINT:\n                case SAMPLEFORMAT_INT:\n                    if ((dwBitsPerChannel == 8) || (dwBitsPerChannel == 16))\n                    {\n                        pRet = LoadImageFromTIFFInternal(tif);\n                        validFormat = true;\n                    }\n                    break;\n                case SAMPLEFORMAT_IEEEFP:\n                    if ((dwBitsPerChannel == 16) || (dwBitsPerChannel == 32))\n                    {\n                        pRet = LoadImageFromTIFFInternal(tif);\n                        validFormat = true;\n                    }\n                    break;\n                default:\n                    // Unsupported format, invalid.\n                    break;\n            }\n\n            if (!validFormat)\n            {\n                AZ_Error(\n                    \"Image Processing\", false, \"File %s has unsupported TIFF pixel format. sample channels: %d,\\\n                            bits per channel: %d, sample format: %d\",\n                    filename.c_str(), dwChannels, dwBitsPerChannel, dwFormat);\n                return pRet;\n            }\n\n            if (pRet == nullptr)\n            {\n                AZ_Error(\"Image Processing\", false, \"Failed to read TIFF pixels\");\n                return pRet;\n            }\n\n            return pRet;\n        }",
    "static IImageObject* LoadImageFromTIFFInternal(TIFF* tif)\n        {\n            uint32_t bitsPerChannel = 0;\n            uint32_t numChannels = 0;\n            uint32_t photometricFormat = 0;\n            uint32_t sampleFormat = 0;\n            TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerChannel);\n            TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &numChannels);\n            TIFFGetFieldDefaulted(tif, TIFFTAG_PHOTOMETRIC, &photometricFormat);\n            TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n            uint32_t inputImageWidth = 0;\n            uint32_t inputImageHeight = 0;\n            TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &inputImageWidth);\n            TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &inputImageHeight);\n\n            uint32_t tileWidth = 0;\n            uint32_t tileHeight = 0;\n            TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tileWidth);\n            TIFFGetField(tif, TIFFTAG_TILELENGTH, &tileHeight);\n\n            bool isTiled = (tileWidth > 0) && (tileHeight > 0);\n            bool isIntFormat = (sampleFormat == SAMPLEFORMAT_INT) || (sampleFormat == SAMPLEFORMAT_UINT);\n\n            EPixelFormat outputPixelFormat = GetOutputPixelFormat(numChannels, bitsPerChannel, sampleFormat);\n            if (outputPixelFormat == ePixelFormat_Unknown)\n            {\n                return nullptr;\n            }\n\n            if ((photometricFormat == PHOTOMETRIC_SEPARATED) && (sampleFormat == SAMPLEFORMAT_IEEEFP))\n            {\n                AZ_Error(\"Image Processing\", false, \"Separated Photometric format isn't supported with floating-point images.\");\n                return nullptr;\n            }\n\n            uint32_t dstChannels = CPixelFormats::GetInstance().GetPixelFormatInfo(outputPixelFormat)->nChannels;\n            IImageObject* pRet = IImageObject::CreateImage(inputImageWidth, inputImageHeight, 1, outputPixelFormat);\n\n            uint8_t* dst;\n            uint32_t dwPitch;\n            pRet->GetImagePointer(0, dst, dwPitch);\n\n            // Determine if this is a scanline-based or tile-based TIFF, and size our temporary buffer appropriately.\n            size_t bufSize = 0;\n            if (isTiled)\n            {\n                // Tiled TIFF, so our buffer needs to be tile-sized\n                bufSize = TIFFTileSize(tif);\n            }\n            else\n            {\n                // Scanline TIFF, so our buffer needs to be scanline-sized.\n                bufSize = TIFFScanlineSize(tif);\n\n                // For our processing loops, we'll treat scanlines like a tile of 1 x width size.\n                tileHeight = 1;\n                tileWidth = inputImageWidth;\n            }\n\n            AZStd::vector<uint8_t> buf(bufSize);\n\n            // There are two types of 32-bit floating point TIF semantics.  Paint programs tend to use values in the 0.0 - 1.0 range.\n            // GeoTIFF files use values where 1.0 = 1 meter by default, but also have an optional ZScale parameter to provide additional\n            // scaling control.\n            // By default, we'll assume this is a regular TIFF that we want to leave in the 0.0 - 1.0 range.\n            float pixelValueScale = 1.0f;\n\n            // Check to see if it's a GeoTIFF, and if so, whether or not it has the ZScale parameter.\n            // Defined in GeoTIFF format -\n            // http://web.archive.org/web/20160403164508/http://www.remotesensing.org/geotiff/spec/geotiffhome.html\n            // Used to get the X, Y, Z scales from a GeoTIFF file\n            bool isGeoTIFF = false;\n            {\n                uint32 tagCount = 0;\n                double* pixelScales = NULL;\n                static constexpr int GEOTIFF_MODELPIXELSCALE_TAG = 33550;\n                if (TIFFGetField(tif, GEOTIFF_MODELPIXELSCALE_TAG, &tagCount, &pixelScales) == 1)\n                {\n                    isGeoTIFF = true;\n\n                    // if there's an xyz scale, and the Z scale isn't 0, let's use it.\n                    if ((tagCount == 3) && (pixelScales != NULL) && (pixelScales[2] != 0.0f))\n                    {\n                        pixelValueScale = static_cast<float>(pixelScales[2]);\n                    }\n                }\n            }\n\n            // Track min/max values for GeoTIFFs so that we can scale the values into the 0-1 range.\n            float minChannelValue = AZStd::numeric_limits<float>::max();\n            float maxChannelValue = AZStd::numeric_limits<float>::lowest();\n\n            // Copy one channel of one pixel from source to destination, and optionally invert the value.\n            auto CopyPixelChannel = [bitsPerChannel, pixelValueScale, &buf, &dst, &minChannelValue, &maxChannelValue]\n                (uint32_t destPixelChannelIndex, uint32_t srcPixelChannelIndex, bool invert = false)\n            {\n                if (bitsPerChannel == 8)\n                {\n                    dst[destPixelChannelIndex] = invert ? (0xFF - buf[srcPixelChannelIndex]) : buf[srcPixelChannelIndex];\n                }\n                else if (bitsPerChannel == 16)\n                {\n                    // Alias the base pointers to a 16-bit channel type, then use the channel index to get to the correct pixel & channel\n                    uint16_t* buf16 = reinterpret_cast<uint16_t*>(buf.data());\n                    uint16_t* dst16 = reinterpret_cast<uint16_t*>(dst);\n                    dst16[destPixelChannelIndex] = invert ? (0xFFFF - buf16[srcPixelChannelIndex]) : buf16[srcPixelChannelIndex];\n                }\n                else\n                {\n                    // Alias the base pointers to a 32-bit channel type, then use the channel index to get to the correct pixel & channel\n                    float* buf32 = reinterpret_cast<float*>(buf.data());\n                    float* dst32 = reinterpret_cast<float*>(dst);\n\n                    // GeoTIFFs might have a pixel scale, so apply it.\n                    const float scaledValue = buf32[srcPixelChannelIndex] * pixelValueScale;\n\n                    // Track min/max values, but exclude the lowest float value, as that might be a \"no data\" value for GeoTIFFs.\n                    if (scaledValue > AZStd::numeric_limits<float>::lowest())\n                    {\n                        minChannelValue = AZStd::min(minChannelValue, scaledValue);\n                        maxChannelValue = AZStd::max(maxChannelValue, scaledValue);\n                    }\n\n                    // We ignore the inversion flag for floats, it will always be false.\n                    dst32[destPixelChannelIndex] = scaledValue;\n                }\n            };\n\n            // Set one channel of one pixel in the destination to a specific value.\n            auto SetPixelChannel = [bitsPerChannel, &dst](uint32_t dstIdx, uint32_t value)\n            {\n                if (bitsPerChannel == 8)\n                {\n                    dst[dstIdx] = static_cast<uint8_t>(value);\n                }\n                else if (bitsPerChannel == 16)\n                {\n                    // Alias the base pointers to a 16-bit channel type, then use the channel index to get to the correct pixel & channel\n                    uint16_t* dst16 = reinterpret_cast<uint16_t*>(dst);\n                    dst16[dstIdx] = static_cast<uint16_t>(value);\n                }\n                else\n                {\n                    // Alias the base pointers to a 32-bit channel type, then use the channel index to get to the correct pixel & channel\n                    float* dst32 = reinterpret_cast<float*>(dst);\n                    dst32[dstIdx] = static_cast<float>(value);\n                }\n            };\n\n            // Loop across the image height, one tile at a time\n            for (uint32_t imageY = 0; imageY < inputImageHeight; imageY += tileHeight)\n            {\n                // Loop across the image width, one tile at a time\n                for (uint32 imageX = 0; imageX < inputImageWidth; imageX += tileWidth)\n                {\n                    // Either read in a tile or a scanline\n                    [[maybe_unused]] auto result = isTiled?\n                        TIFFReadTile(tif, buf.data(), imageX, imageY, 0, 0):\n                        TIFFReadScanline(tif, buf.data(), imageY);\n\n                    // non-fatal error, only print the warning\n                    // For details: https://github.com/o3de/o3de/pull/8929\n                    AZ_Warning(\"TIFFLoader\", !(result == -1), \"Read tiff image data from %s error at row %d\", TIFFFileName(tif), imageY);\n\n                    // Convert each pixel in the scanline / tile buffer.\n                    // The image might not be evenly divisible by tile height/width, so don't process any pixels outside those bounds.\n                    for (uint32 tileY = 0; (tileY < tileHeight) && ((imageY + tileY) < inputImageHeight); tileY++)\n                    {\n                        for (uint32 tileX = 0; (tileX < tileWidth) && ((imageX + tileX) < inputImageWidth); tileX++)\n                        {\n                            // Calculate the buffer start index for the source and destination pixels.\n                            // These indices are by channel, not by byte, so for example a 2x2 R16G16B16A16 image will have\n                            // pixel channel indices of 0, 4, 8, 12. If they were by byte, they'd be 0, 8, 16, 24.\n                            // Also, note that the destination image provides a \"pitch\" value that's the number of bytes per row,\n                            // which could include padding. Since that value is in bytes, we divide by bytes per channel so that\n                            // our index is back in channel range, not byte range.\n                            uint32 srcPixelChannelIndex = ((tileY * tileWidth) + tileX) * numChannels;\n                            uint32 destPixelChannelIndex =\n                                ((imageY + tileY) * (dwPitch / (bitsPerChannel / 8))) +\n                                ((imageX + tileX) * dstChannels);\n\n                            if (numChannels == 1)\n                            {\n                                // One channel, perform a straight copy.\n                                CopyPixelChannel(destPixelChannelIndex, srcPixelChannelIndex);\n                            }\n                            else if (numChannels == 2)\n                            {\n                                if (photometricFormat == PHOTOMETRIC_SEPARATED)\n                                {\n                                    // convert CMY to RGB (PHOTOMETRIC_SEPARATED refers to inks in TIFF, the value is inverted)\n                                    constexpr bool invert = true;\n                                    CopyPixelChannel(destPixelChannelIndex + 0, srcPixelChannelIndex + 0, invert);\n                                    CopyPixelChannel(destPixelChannelIndex + 1, srcPixelChannelIndex + 1, invert);\n                                    SetPixelChannel(destPixelChannelIndex + 2, 0x00000000);\n                                    SetPixelChannel(destPixelChannelIndex + 3, isIntFormat ? 0xFFFFFFFF : 1);\n                                }\n                                else\n                                {\n                                    // Not separated, so just copy the two channels, and fill in the other two channels with defaults.\n                                    CopyPixelChannel(destPixelChannelIndex + 0, srcPixelChannelIndex + 0);\n                                    CopyPixelChannel(destPixelChannelIndex + 1, srcPixelChannelIndex + 1);\n                                    SetPixelChannel(destPixelChannelIndex + 2, 0x00000000);\n                                    SetPixelChannel(destPixelChannelIndex + 3, isIntFormat ? 0xFFFFFFFF : 1);\n                                }\n                            }\n                            else if (numChannels == 3)\n                            {\n                                // 3 channels, copy over RGB and fill in Alpha with a default.\n                                CopyPixelChannel(destPixelChannelIndex + 0, srcPixelChannelIndex + 0);\n                                CopyPixelChannel(destPixelChannelIndex + 1, srcPixelChannelIndex + 1);\n                                CopyPixelChannel(destPixelChannelIndex + 2, srcPixelChannelIndex + 2);\n                                SetPixelChannel(destPixelChannelIndex + 3, isIntFormat ? 0xFFFFFFFF : 1);\n                            }\n                            else\n                            {\n                                // 4 channels, just perform a straight copy.\n                                CopyPixelChannel(destPixelChannelIndex + 0, srcPixelChannelIndex + 0);\n                                CopyPixelChannel(destPixelChannelIndex + 1, srcPixelChannelIndex + 1);\n                                CopyPixelChannel(destPixelChannelIndex + 2, srcPixelChannelIndex + 2);\n                                CopyPixelChannel(destPixelChannelIndex + 3, srcPixelChannelIndex + 3);\n                            }\n                        }\n                    }\n                }\n            }\n\n            // A GeoTIFF image contains real-world height values, so the values could potentially range from roughly +/- 10000 meters.\n            // To make this data usable in-engine, it will get scaled to 0.0 - 1.0, based on the min/max values found in the file.\n            if (isGeoTIFF && (sampleFormat == SAMPLEFORMAT_IEEEFP))\n            {\n                float* dst32 = reinterpret_cast<float*>(dst);\n\n                for (uint32 imageY = 0; imageY < inputImageHeight; imageY++)\n                {\n                    for (uint32 imageX = 0; imageX < inputImageWidth; imageX++)\n                    {\n                        uint32 pixelChannelIndex = (imageY * (dwPitch / (bitsPerChannel / 8))) + (imageX * dstChannels);\n                        dst32[pixelChannelIndex] =\n                            AZStd::clamp((dst32[pixelChannelIndex] - minChannelValue) / (maxChannelValue - minChannelValue), 0.0f, 1.0f);\n                    }\n                }\n            }\n\n            return pRet;\n        }",
    "void\nImageToTexture::changeFileName()\n{\n    changeFileNameFailed_ = true;\n    // assume physical-soze image dimension is available in file\n    mode_ = TextureMapping::NONE;\n    // open file\n    bild_ = TIFFOpen(FileName_.c_str(), \"r\");\n\n    if (bild_ == NULL)\n    {\n        sendWarning(\"Could not open file.\");\n        return;\n    }\n\n    // read width in pixels\n    if (TIFFGetField(bild_, TIFFTAG_IMAGEWIDTH, &w_) != 1)\n    {\n        sendWarning(\"Could not allocate memory for raster_.\");\n        TIFFClose(bild_);\n        bild_ = NULL;\n        return;\n    }\n    // read height in pixels\n    if (TIFFGetField(bild_, TIFFTAG_IMAGELENGTH, &h_) != 1)\n    {\n        sendWarning(\"Could not read image.\");\n        TIFFClose(bild_);\n        bild_ = NULL;\n        return;\n    }\n\n    // @@@ problems with segmented memory (Windows...)\n    delete[] raster_;\n    raster_ = new uint32[w_ * h_];\n\n    if (raster_ == NULL)\n    {\n        sendWarning(\"Could not allocate memory for raster_.\");\n        TIFFClose(bild_);\n        bild_ = NULL;\n        return;\n    }\n    // read image content\n    if (TIFFReadRGBAImage(bild_, w_, h_, raster_, 0) != 1)\n    {\n        sendWarning(\"Could not read TIFF file.\");\n        TIFFClose(bild_);\n        delete[] raster_; // @@@\n        bild_ = NULL;\n        raster_ = NULL;\n        return;\n    }\n    // Calculate image dimensions from the file (if possible)\n    // first of all get resolution unit\n    XResolution_ = 0.0, YResolution_ = 0.0;\n    if (TIFFGetField(bild_, TIFFTAG_RESOLUTIONUNIT, &resUnit_) != 1\n        || resUnit_ == RESUNIT_NONE)\n    {\n        sendInfo(\"The image has no resolution unit. Please, set physical image dimensions manually\");\n        mode_ = TextureMapping::MANUAL;\n    }\n    else // we have resolution unit\n    {\n        if (TIFFGetField(bild_, TIFFTAG_XRESOLUTION, &XResolution_) != 1)\n        {\n            sendInfo(\"Could not read X Resolution. Please, set physical image dimension manually\");\n            mode_ = TextureMapping::MANUAL;\n        }\n        else if (TIFFGetField(bild_, TIFFTAG_YRESOLUTION, &YResolution_) != 1)\n        {\n            sendInfo(\"Could not read Y Resolution. Assuming the same value as for the X dimension. You may always control the behaviour manually\");\n            YResolution_ = XResolution_;\n            mode_ = TextureMapping::AUTOMATIC;\n        }\n        else\n        {\n            sendInfo(\"A valid image size has been read from file\");\n            mode_ = TextureMapping::AUTOMATIC;\n        }\n        if (mode_ == TextureMapping::AUTOMATIC) // give the user a hint\n        {\n            float Width, Height;\n            Width = w_ / XResolution_;\n            Height = h_ / YResolution_;\n            if (resUnit_ == RESUNIT_INCH)\n            {\n                Width *= 2.54f;\n                Height *= 2.54f;\n            }\n            sendInfo(\"Image size according to file information: width, %f; height, %f (cm)\", Width, Height);\n        }\n    }\n    TIFFClose(bild_);\n    bild_ = NULL;\n    changeFileNameFailed_ = false;\n    // transform RGBA format from raster_ to image_\n    return;\n}",
    "static void adaptSizeToResolution(TIFF *tiff, ttag_t whichres, double dpi, uint32_t *size)\n{\n    float resvalue = 1.0;\n    uint16_t resunit = 0;\n    if (!TIFFGetField(tiff, whichres, &resvalue) || !TIFFGetFieldDefaulted(tiff, TIFFTAG_RESOLUTIONUNIT, &resunit)) {\n        return;\n    }\n\n    float newsize = *size / resvalue;\n    switch (resunit) {\n    case RESUNIT_INCH:\n        *size = (uint32_t)(newsize * dpi);\n        break;\n    case RESUNIT_CENTIMETER:\n        *size = (uint32_t)(newsize * 10.0 / 25.4 * dpi);\n        break;\n    case RESUNIT_NONE:\n        break;\n    }\n}",
    "static Okular::Rotation readTiffRotation(TIFF *tiff)\n{\n    uint32_t tiffOrientation = 0;\n\n    if (!TIFFGetField(tiff, TIFFTAG_ORIENTATION, &tiffOrientation)) {\n        return Okular::Rotation0;\n    }\n\n    Okular::Rotation ret = Okular::Rotation0;\n    switch (tiffOrientation) {\n    case ORIENTATION_TOPLEFT:\n    case ORIENTATION_TOPRIGHT:\n        ret = Okular::Rotation0;\n        break;\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_BOTLEFT:\n        ret = Okular::Rotation180;\n        break;\n    case ORIENTATION_LEFTTOP:\n    case ORIENTATION_LEFTBOT:\n        ret = Okular::Rotation270;\n        break;\n    case ORIENTATION_RIGHTTOP:\n    case ORIENTATION_RIGHTBOT:\n        ret = Okular::Rotation90;\n        break;\n    }\n\n    return ret;\n}",
    "QImage TIFFGenerator::image(Okular::PixmapRequest *request)\n{\n    bool generated = false;\n    QImage img;\n\n    if (TIFFSetDirectory(d->tiff, mapPage(request->page()->number()))) {\n        int rotation = request->page()->rotation();\n        uint32_t width = 1;\n        uint32_t height = 1;\n        uint32_t orientation = 0;\n        TIFFGetField(d->tiff, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(d->tiff, TIFFTAG_IMAGELENGTH, &height);\n\n        if (!TIFFGetField(d->tiff, TIFFTAG_ORIENTATION, &orientation)) {\n            orientation = ORIENTATION_TOPLEFT;\n        }\n\n        QImage image(width, height, QImage::Format_RGB32);\n        uint32_t *data = reinterpret_cast<uint32_t *>(image.bits());\n\n        // read data\n        if (TIFFReadRGBAImageOriented(d->tiff, width, height, data, orientation) != 0) {\n            // an image read by ReadRGBAImage is ABGR, we need ARGB, so swap red and blue\n            uint32_t size = width * height;\n            for (uint32_t i = 0; i < size; ++i) {\n                uint32_t red = (data[i] & 0x00FF0000) >> 16;\n                uint32_t blue = (data[i] & 0x000000FF) << 16;\n                data[i] = (data[i] & 0xFF00FF00) + red + blue;\n            }\n\n            int reqwidth = request->width();\n            int reqheight = request->height();\n            if (rotation % 2 == 1) {\n                std::swap(reqwidth, reqheight);\n            }\n            img = image.scaled(reqwidth, reqheight, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);\n\n            generated = true;\n        }\n    }\n\n    if (!generated) {\n        img = QImage(request->width(), request->height(), QImage::Format_RGB32);\n        img.fill(qRgb(255, 255, 255));\n    }\n\n    return img;\n}",
    "Okular::DocumentInfo TIFFGenerator::generateDocumentInfo(const QSet<Okular::DocumentInfo::Key> &keys) const\n{\n    Okular::DocumentInfo docInfo;\n    if (d->tiff) {\n        if (keys.contains(Okular::DocumentInfo::MimeType)) {\n            docInfo.set(Okular::DocumentInfo::MimeType, QStringLiteral(\"image/tiff\"));\n        }\n\n        if (keys.contains(Okular::DocumentInfo::Description)) {\n            char *buffer = nullptr;\n            TIFFGetField(d->tiff, TIFFTAG_IMAGEDESCRIPTION, &buffer);\n            docInfo.set(Okular::DocumentInfo::Description, buffer ? QString::fromLatin1(buffer) : QString());\n        }\n\n        if (keys.contains(Okular::DocumentInfo::Producer)) {\n            char *buffer = nullptr;\n            TIFFGetField(d->tiff, TIFFTAG_SOFTWARE, &buffer);\n            docInfo.set(Okular::DocumentInfo::Producer, buffer ? QString::fromLatin1(buffer) : QString());\n        }\n\n        if (keys.contains(Okular::DocumentInfo::Copyright)) {\n            char *buffer = nullptr;\n            TIFFGetField(d->tiff, TIFFTAG_COPYRIGHT, &buffer);\n            docInfo.set(Okular::DocumentInfo::Copyright, buffer ? QString::fromLatin1(buffer) : QString());\n        }\n\n        if (keys.contains(Okular::DocumentInfo::Author)) {\n            char *buffer = nullptr;\n            TIFFGetField(d->tiff, TIFFTAG_ARTIST, &buffer);\n            docInfo.set(Okular::DocumentInfo::Author, buffer ? QString::fromLatin1(buffer) : QString());\n        }\n\n        if (keys.contains(Okular::DocumentInfo::CreationDate)) {\n            char *buffer = nullptr;\n            TIFFGetField(d->tiff, TIFFTAG_DATETIME, &buffer);\n            QDateTime date = convertTIFFDateTime(buffer);\n            docInfo.set(Okular::DocumentInfo::CreationDate, date.isValid() ? QLocale().toString(date, QLocale::LongFormat) : QString());\n        }\n    }\n\n    return docInfo;\n}",
    "void TIFFGenerator::loadPages(QVector<Okular::Page *> &pagesVector)\n{\n    if (!d->tiff) {\n        return;\n    }\n\n    tdir_t dirs = TIFFNumberOfDirectories(d->tiff);\n    pagesVector.resize(dirs);\n    tdir_t realdirs = 0;\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n\n    const QSizeF dpi = Okular::Utils::realDpi(nullptr);\n    for (tdir_t i = 0; i < dirs; ++i) {\n        if (!TIFFSetDirectory(d->tiff, i)) {\n            continue;\n        }\n\n        if (TIFFGetField(d->tiff, TIFFTAG_IMAGEWIDTH, &width) != 1 || TIFFGetField(d->tiff, TIFFTAG_IMAGELENGTH, &height) != 1) {\n            continue;\n        }\n\n        adaptSizeToResolution(d->tiff, TIFFTAG_XRESOLUTION, dpi.width(), &width);\n        adaptSizeToResolution(d->tiff, TIFFTAG_YRESOLUTION, dpi.height(), &height);\n\n        Okular::Page *page = new Okular::Page(realdirs, width, height, readTiffRotation(d->tiff));\n        pagesVector[realdirs] = page;\n\n        m_pageMapping[realdirs] = i;\n\n        ++realdirs;\n    }\n\n    pagesVector.resize(realdirs);\n}",
    "Okular::Document::PrintError TIFFGenerator::print(QPrinter &printer)\n{\n    uint32_t width = 0;\n    uint32_t height = 0;\n\n    QPainter p(&printer);\n\n    QList<int> pageList = Okular::FilePrinter::pageList(printer, document()->pages(), document()->currentPage() + 1, document()->bookmarkedPageList());\n\n    for (int i = 0; i < pageList.count(); ++i) {\n        if (!TIFFSetDirectory(d->tiff, mapPage(pageList[i] - 1))) {\n            continue;\n        }\n\n        if (TIFFGetField(d->tiff, TIFFTAG_IMAGEWIDTH, &width) != 1 || TIFFGetField(d->tiff, TIFFTAG_IMAGELENGTH, &height) != 1) {\n            continue;\n        }\n\n        QImage image(width, height, QImage::Format_RGB32);\n        uint32_t *data = reinterpret_cast<uint32_t *>(image.bits());\n\n        // read data\n        if (TIFFReadRGBAImageOriented(d->tiff, width, height, data, ORIENTATION_TOPLEFT) != 0) {\n            // an image read by ReadRGBAImage is ABGR, we need ARGB, so swap red and blue\n            uint32_t size = width * height;\n            for (uint32_t j = 0; j < size; ++j) {\n                uint32_t red = (data[j] & 0x00FF0000) >> 16;\n                uint32_t blue = (data[j] & 0x000000FF) << 16;\n                data[j] = (data[j] & 0xFF00FF00) + red + blue;\n            }\n        }\n\n        if (i != 0) {\n            printer.newPage();\n        }\n\n        QSize targetSize = printer.pageRect(QPrinter::Unit::DevicePixel).size().toSize();\n\n        if ((image.width() < targetSize.width()) && (image.height() < targetSize.height())) {\n            // draw small images at 100% (don't scale up)\n            p.drawImage(0, 0, image);\n        } else {\n            // fit to page\n            p.drawImage(0, 0, image.scaled(targetSize, Qt::IgnoreAspectRatio, Qt::SmoothTransformation));\n        }\n    }\n\n    return Okular::Document::NoPrintError;\n}",
    "void\nXdmfTIFFController::read(XdmfArray * const array)\n{\n  TIFF* tif = TIFFOpen(mFilePath.c_str(), \"r\");\n\n  unsigned int compression = 0;\n\n  TIFFGetField(tif, TIFFTAG_COMPRESSION, &compression);\n\n  unsigned int currentDirectory = 0;\n\n  if (tif && mStart.size() >= 3) {\n    // setting the start for the first directory\n    TIFFSetDirectory(tif, mStart[2]);\n    currentDirectory = mStart[2];\n  }\n\n  unsigned int amountWritten = 0;\n  // Only used for 1d controllers\n  unsigned int sizeLeft = this->getSize();\n  if (!array->isInitialized()) {\n    array->initialize(this->getType());\n  }\n  if (array->getSize() != this->getSize()) {\n    array->resize(mDimensions, 0);\n  }\n\n  // For single dimension version only\n  unsigned int currentRowStart = mStart[0];\n  unsigned int scanlineIndex = 0;\n\n  if (mDimensions.size() > 1)\n  {\n    scanlineIndex = mStart[1];\n  }\n\n  if (tif) {\n    bool validDir = true;\n    while (validDir) {\n      // Directories are handled by the third dimension\n      // If no directories are specified, progress as far\n      // as needed to fill the dimensions provided.\n      unsigned int imagelength, bitsPerSample;\n      tdata_t buf;\n      unsigned int row;\n      unsigned int scanlinesize = TIFFScanlineSize(tif);\n\n      shared_ptr<const XdmfArrayType> tiffDataType = array->getArrayType();\n\n      TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n\n      TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imagelength);\n\n      if (compression == 1) {\n        // Specific to non-compressed read\n\n        if (bitsPerSample / 8 == 1) {\n          tiffDataType = XdmfArrayType::UInt8();\n        }\n        else if (bitsPerSample / 8 == 2) {\n          tiffDataType = XdmfArrayType::UInt16();\n        }\n        else if (bitsPerSample / 8 == 4) {\n          tiffDataType = XdmfArrayType::UInt32();\n        }\n        else if (bitsPerSample / 8 == 8) {\n          tiffDataType = XdmfArrayType::UInt64();\n        }\n\n        // the buffer is a number of bytes equal to the scan line size\n        buf = _TIFFmalloc(scanlinesize );\n\n        scanlinesize /= array->getArrayType()->getElementSize();\n\n        if (mDimensions.size() == 1)\n        {\n          if (sizeLeft == 0) {\n            break;\n          }\n          // If there is one dimensions then we treat the entire entry as a single dataset.\n          // We need to adjust the starting point accordingly.\n          for (row = 0; row < imagelength; ++row)\n          {\n            TIFFReadScanline(tif, buf, row);\n            unsigned int amountRead = sizeLeft;\n            if ((scanlinesize - currentRowStart) / mStride[0] <= sizeLeft) {\n              amountRead = (scanlinesize - currentRowStart) / mStride[0];\n              if (scanlinesize % mStride[0] != 0 &&\n                  currentRowStart % mStride[0] <= scanlinesize - (amountRead * mStride[0] + currentRowStart))\n              {\n                 amountRead++;\n              }\n            }\n            readToArray(array,\n                        buf,\n                        amountWritten,\n                        currentRowStart,\n                        mStride[0],\n                        amountRead,\n                        tiffDataType);\n            // check to see how the start matches up with the scanline size\n            amountWritten += amountRead;\n            if (sizeLeft == 0) {\n              break;\n            }\n\n            if (amountRead < sizeLeft) {\n              sizeLeft = sizeLeft - amountRead;\n            }\n            else {\n              sizeLeft = 0;\n            }\n            if (((int)((amountRead * mStride[0]) + currentRowStart)) - scanlinesize >= 0)\n            {\n              currentRowStart = ((amountRead * mStride[0]) + currentRowStart) - scanlinesize;\n            }\n            else\n            {\n              currentRowStart = ((amountRead * (mStride[0] + 1)) + currentRowStart) - scanlinesize;\n            }\n          }\n        }\n        else {\n        // Dimensions correspond to scanline size and number of scanlines\n          unsigned int rowstride = mStride[1];\n          unsigned int currentRowStart = mStart[0];\n          for (row = mStart[1]; row < imagelength && row < mDataspaceDimensions[1]; row+=rowstride)\n          {\n            TIFFReadScanline(tif, buf, row);\n            readToArray(array,\n                        buf,\n                        amountWritten,\n                        currentRowStart,\n                        mStride[0],\n                        mDimensions[0],\n                        tiffDataType);\n            amountWritten += mDimensions[0];\n          }\n        }\n        _TIFFfree(buf);\n\n      }\n      else if (compression == 5)\n      {\n        // In this case we need to use strips instead of scanlines\n        // scanline size is in bytes when dealing with compression\n        if (bitsPerSample == 1) {\n          tiffDataType = XdmfArrayType::UInt8();\n        }\n        else if (bitsPerSample == 2) {\n          tiffDataType = XdmfArrayType::UInt16();\n        }\n        else if (bitsPerSample == 4) {\n          tiffDataType = XdmfArrayType::UInt32();\n        }\n        else if (bitsPerSample == 8) {\n          tiffDataType = XdmfArrayType::UInt64();\n        }\n\n        // the buffer is a number of bytes equal to the scan line size\n        buf = _TIFFmalloc(TIFFStripSize(tif));\n\n        scanlinesize /= array->getArrayType()->getElementSize();\n\n        // For each strip in the directory\n        for (unsigned int strip = 0; strip < TIFFNumberOfStrips(tif); strip++)\n        {\n          if (sizeLeft == 0) {\n            break;\n          }\n\n          unsigned int currentStripSize = TIFFReadEncodedStrip(tif, strip, buf, -1);\n          currentStripSize = currentStripSize / array->getArrayType()->getElementSize();\n          // Size is in bits, and is not necessarily the same per strip\n          unsigned int numberScanlines = currentStripSize / scanlinesize;\n          // For the case of a partial scanline\n          if (currentStripSize % scanlinesize != 0) {\n            ++numberScanlines;\n          }\n          // If singledimensional\n          // then write out the strip as if it was a scanline\n\n          if (mDimensions.size() == 1)\n          {\n            unsigned int amountRead = sizeLeft;\n            if ((currentStripSize - currentRowStart) / mStride[0] <= sizeLeft) {\n              amountRead = (currentStripSize - currentRowStart) / mStride[0];\n              if (currentStripSize % mStride[0] != 0 &&\n                  currentRowStart % mStride[0] <= currentStripSize - (amountRead * mStride[0] + currentRowStart))\n              {\n                 amountRead++;\n              }\n            }\n            readToArray(array,\n                        buf,\n                        amountWritten,\n                        currentRowStart,\n                        mStride[0],\n                        amountRead,\n                        tiffDataType);\n            amountWritten += amountRead;\n            if (sizeLeft == 0) {\n              break;\n            }\n\n            if (amountRead < sizeLeft) {\n              sizeLeft = sizeLeft - amountRead;\n            }\n            else {\n              sizeLeft = 0;\n            }\n            if (((int)((amountRead * mStride[0]) + currentRowStart)) - currentStripSize >= 0)\n            {\n              currentRowStart = ((amountRead * mStride[0]) + currentRowStart) - currentStripSize;\n            }\n            else\n            {\n              currentRowStart = ((amountRead * (mStride[0] + 1)) + currentRowStart) - currentStripSize;\n            }\n          }\n          else\n          {\n            currentRowStart = scanlineIndex;\n            // If multidimensional\n            // Loop through the scanlines in the strip\n            for (; scanlineIndex < numberScanlines; scanlineIndex += mStride[1])\n            {\n              readToArray(array,\n                          buf,\n                          amountWritten,\n                          currentRowStart,\n                          mStride[0],\n                          mDimensions[0],\n                          tiffDataType);\n              amountWritten += mDimensions[0];\n              currentRowStart = currentRowStart + scanlinesize * mStride[1];\n            }\n            scanlineIndex = scanlineIndex % mStride[1];\n          }\n        }\n      }\n\n      if (mStride.size() >= 3)\n      {\n        currentDirectory += mStride[2];\n      }\n      else\n      {\n        ++currentDirectory;\n      }\n\n      validDir = TIFFSetDirectory(tif, currentDirectory);\n    }\n  }\n  else {\n    XdmfError::message(XdmfError::FATAL, \"Error: Invalid TIFF file\");\n  }\n\n  TIFFClose(tif);\n}",
    "TexImage32 *load_tiff32(IGenLoad &crd, IMemAlloc *mem, bool *out_used_alpha)\n{\n  uint32_t width, height;\n  uint16_t bps, spp;\n  TIFF *tif = TIFFClientOpen(crd.getTargetName(), \"r\", reinterpret_cast<thandle_t>(&crd), &tiff_ReadProc, &tiff_WriteProc,\n    &tiff_SeekProc, &tiff_CloseProc, &tiff_SizeProc, &tiff_nullMapProc, &tiff_nullUnmapProc);\n\n  if (!tif)\n  {\n    logerr(\"%s: could not open image\", crd.getTargetName());\n    return nullptr;\n  }\n\n  // Do whatever it is we do with the buffer -- we dump it in hex\n  if (TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width) == 0)\n  {\n    logerr(\"%s: no image width\", crd.getTargetName());\n    TIFFClose(tif);\n    return nullptr;\n  }\n  if (TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height) == 0)\n  {\n    logerr(\"%s: no image height\", crd.getTargetName());\n    TIFFClose(tif);\n    return nullptr;\n  }\n\n  // Check that it is of a type that we support\n  if (TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps) == 0)\n  {\n    logerr(\"%s: undefined bits-per-sample\", crd.getTargetName());\n    TIFFClose(tif);\n    return nullptr;\n  }\n  if (bps != 1 && bps != 2 && bps != 4 && bps != 8 && bps != 16 && bps != 32)\n  {\n    logerr(\"%s: unsupported bits-per-sample: %d\", crd.getTargetName(), bps);\n    TIFFClose(tif);\n    return nullptr;\n  }\n\n  if (TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp) == 0)\n  {\n    logerr(\"%s: undefined samples-per-pixel\", crd.getTargetName());\n    TIFFClose(tif);\n    return nullptr;\n  }\n\n  if (spp != 1 && spp != 2 && spp != 3 && spp != 4)\n  {\n    logerr(\"%s: unsupported samples-per-pixel: %d\", crd.getTargetName(), spp);\n    TIFFClose(tif);\n    return nullptr;\n  }\n\n  if (spp <= 4 && bps <= 8) //-V560\n  {\n    TexImage32 *im32 = TexImage32::create(width, height, mem);\n\n    // set extra channels to EXTRASAMPLE_UNSPECIFIED to treat alpha as ordinary (non-premultiplied) channel\n    uint16_t *sampleinfo, extrasamples = 0, new_sampleinfo[16];\n    TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &extrasamples, &sampleinfo);\n    for (int i = 0; i < spp - 3; i++) //-V1008\n      new_sampleinfo[i] = EXTRASAMPLE_UNSPECIFIED;\n    TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, extrasamples, new_sampleinfo);\n\n    if (!TIFFReadRGBAImageOriented(tif, width, height, (unsigned *)im32->getPixels(), ORIENTATION_TOPLEFT, 0))\n    {\n      mem->free(im32);\n      TIFFClose(tif);\n      return nullptr;\n    }\n    TIFFClose(tif);\n\n    for (TexPixel32 *p = im32->getPixels(), *pe = p + width * height; p < pe; p++)\n      eastl::swap(p->b, p->r); // TexPixel32 is BGRA while TIFFRGBAImage is RGBA\n\n    if (out_used_alpha)\n    {\n      *out_used_alpha = false;\n      if (spp >= 4)\n        for (TexPixel32 *p = im32->getPixels(), *pe = p + width * height; p < pe; p++)\n          if (p->a != 255)\n          {\n            *out_used_alpha = true;\n            break;\n          }\n    }\n    return im32;\n  }\n  logerr(\"%s: unsupported samples-per-pixel=%d and bits-per-sample=%d\", crd.getTargetName(), spp, bps);\n  return nullptr;\n}",
    "virtual BaseTexture *createTex(const char *fn, int /*flg*/, int /*levels*/, const char *fn_ext, const TextureMetaData &tmd)\n  {\n    if (!fn_ext || (dd_strnicmp(fn_ext, \".tif\", 3) != 0 && dd_strnicmp(fn_ext, \".tiff\", 4) != 0))\n      return NULL;\n\n    TIFF *image = TIFFOpen(fn, \"rb\");\n    if (!image)\n    {\n      logerr(\"Cannot open TIFF file '%s'\", fn);\n      return NULL;\n    }\n\n    uint16_t spp = 1, bpp = 8, fileFormat = SAMPLEFORMAT_UINT;\n    uint32_t width = 1, height = 1;\n    TIFFGetField(image, TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &bpp);\n    TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    TIFFGetField(image, TIFFTAG_SAMPLEFORMAT, &fileFormat);\n\n    struct FormatMap\n    {\n      int tiffFormat, tiffIsFloat, tiffBitsPerChannel, tiffChannels;\n      int dagorFormat, dagorIsFloat, dagorBitsPerChannel, dagorChannels;\n      bool swapRB;\n    };\n\n    const static struct FormatMap formatMap[] = {\n      {SAMPLEFORMAT_UINT, false, 1, 1, TEXFMT_L8, false, 8, 1, false},\n      {SAMPLEFORMAT_UINT, false, 8, 1, TEXFMT_L8, false, 8, 1, false},\n      {SAMPLEFORMAT_UINT, false, 8, 2, TEXFMT_R8G8, false, 8, 2, false},\n      {SAMPLEFORMAT_UINT, false, 8, 3, TEXFMT_A8R8G8B8, false, 8, 4, true},\n      {SAMPLEFORMAT_UINT, false, 8, 4, TEXFMT_A8R8G8B8, false, 8, 4, true},\n      {SAMPLEFORMAT_UINT, false, 16, 1, TEXFMT_L16, false, 16, 1, false},\n      {SAMPLEFORMAT_UINT, false, 16, 2, TEXFMT_G16R16, false, 16, 2, false},\n      {SAMPLEFORMAT_UINT, false, 16, 3, TEXFMT_A32B32G32R32F, true, 32, 4, false}, // TODO: figure out why A16B16G16R16 is not\n                                                                                   // supported?\n      {SAMPLEFORMAT_UINT, false, 16, 4, TEXFMT_A32B32G32R32F, true, 32, 4, false}, // *\n      {SAMPLEFORMAT_UINT, false, 32, 1, TEXFMT_R32UI, false, 32, 1, false},\n      {SAMPLEFORMAT_UINT, false, 32, 3, TEXFMT_A32B32G32R32UI, false, 32, 4, false},\n      {SAMPLEFORMAT_UINT, false, 32, 4, TEXFMT_A32B32G32R32UI, false, 32, 4, false},\n      {SAMPLEFORMAT_INT, false, 1, 1, TEXFMT_L8, false, 8, 1, false},\n      {SAMPLEFORMAT_INT, false, 8, 1, TEXFMT_L8, false, 8, 1, false},\n      {SAMPLEFORMAT_INT, false, 8, 2, TEXFMT_R8G8, false, 8, 2, false},\n      {SAMPLEFORMAT_INT, false, 8, 3, TEXFMT_A8R8G8B8, false, 8, 4, true},\n      {SAMPLEFORMAT_INT, false, 8, 4, TEXFMT_A8R8G8B8, false, 8, 4, true},\n      {SAMPLEFORMAT_INT, false, 16, 1, TEXFMT_L16, false, 16, 1, false},\n      {SAMPLEFORMAT_INT, false, 16, 2, TEXFMT_G16R16, false, 16, 2, false},\n      {SAMPLEFORMAT_INT, false, 16, 3, TEXFMT_A32B32G32R32F, false, 16, 4, false}, // *\n      {SAMPLEFORMAT_INT, false, 16, 4, TEXFMT_A32B32G32R32F, false, 16, 4, false}, // *\n      {SAMPLEFORMAT_INT, false, 32, 1, TEXFMT_R32UI, false, 32, 1, false},\n      {SAMPLEFORMAT_INT, false, 32, 2, TEXFMT_R32G32UI, false, 32, 2, false},\n      {SAMPLEFORMAT_INT, false, 32, 3, TEXFMT_A32B32G32R32UI, false, 32, 4, false},\n      {SAMPLEFORMAT_INT, false, 32, 4, TEXFMT_A32B32G32R32UI, false, 32, 4, false},\n      {SAMPLEFORMAT_IEEEFP, true, 16, 1, TEXFMT_R16F, true, 16, 1, false},\n      {SAMPLEFORMAT_IEEEFP, true, 16, 2, TEXFMT_G16R16F, true, 16, 2, false},\n      {SAMPLEFORMAT_IEEEFP, true, 16, 3, TEXFMT_A16B16G16R16F, true, 16, 4, false},\n      {SAMPLEFORMAT_IEEEFP, true, 16, 4, TEXFMT_A16B16G16R16F, true, 16, 4, false},\n      {SAMPLEFORMAT_IEEEFP, true, 32, 1, TEXFMT_R32F, true, 32, 1, false},\n      {SAMPLEFORMAT_IEEEFP, true, 32, 2, TEXFMT_G32R32F, true, 32, 2, false},\n      {SAMPLEFORMAT_IEEEFP, true, 32, 3, TEXFMT_A32B32G32R32F, true, 32, 4, false},\n      {SAMPLEFORMAT_IEEEFP, true, 32, 4, TEXFMT_A32B32G32R32F, true, 32, 4, false},\n    };\n\n    int formatIndex = -1;\n    for (int i = 0; i < countof(formatMap); i++)\n      if (formatMap[i].tiffFormat == fileFormat && formatMap[i].tiffBitsPerChannel == bpp && formatMap[i].tiffChannels == spp)\n      {\n        formatIndex = i;\n        break;\n      }\n\n    if (formatIndex < 0)\n    {\n      logerr(\"Unsupported TIFF format: '%s' format=%d, bpp=%d, channels=%d\", fn, fileFormat, bpp, spp);\n      TIFFClose(image);\n      return NULL;\n    }\n\n    const FormatMap &fm = formatMap[formatIndex];\n\n    BaseTexture *t = NULL;\n    BaseTexture *ref = NULL;\n    if (!tmd.baseTexName.empty())\n    {\n      TEXTUREID id = get_managed_texture_id(tmd.baseTexName);\n      if (id == BAD_TEXTUREID)\n        id = add_managed_texture(tmd.baseTexName);\n      ref = acquire_managed_tex(id);\n      if (!ref)\n      {\n        release_managed_tex(id);\n        TIFFClose(image);\n        return t;\n      }\n    }\n\n    int tiffStride = TIFFScanlineSize(image);\n    Tab<uint8_t> tiffLine(tiffStride, 0);\n    t = d3d::create_tex(NULL, width, height, fm.dagorFormat, 1, fn);\n\n    if (t)\n    {\n      apply_gen_tex_props(t, tmd);\n\n      uint8_t *data = NULL;\n      int stride = 0;\n\n      if (((Texture *)t)->lockimg((void **)&data, stride, 0, TEXLOCK_WRITE))\n      {\n        memset(data, 0x22, height * stride);\n\n        for (int y = 0; y < height; y++)\n        {\n          int idx = stride * y;\n          TIFFReadScanline(image, tiffLine.data(), y, 0);\n          if (!convert_image_line(tiffLine.data(), width, fm.tiffChannels, fm.tiffBitsPerChannel, fm.tiffIsFloat, data + idx,\n                fm.dagorChannels, fm.dagorBitsPerChannel, fm.dagorIsFloat, fm.swapRB))\n          {\n            break;\n          }\n        }\n\n        ((Texture *)t)->unlockimg();\n      }\n      else\n      {\n        G_ASSERTF(0, \"cannot lock texture\");\n        del_d3dres(t);\n        TIFFClose(image);\n        return NULL;\n      }\n    }\n\n    TIFFClose(image);\n    return t;\n  }",
    "static TexImage32 *load_tiff32(const char *fn, IMemAlloc *mem, bool *out_used_alpha = NULL)\n{\n  TIFF *image = TIFFOpen(fn, \"rb\");\n\n  if (!image)\n    return NULL;\n\n  uint16 spp = 0, bpp = 0, format = 0;\n  uint32 width = 1, height = 1;\n  TIFFGetField(image, TIFFTAG_IMAGELENGTH, &height);\n  TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &bpp);\n  TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetField(image, TIFFTAG_SAMPLEFORMAT, &format);\n\n  if (format && (format != SAMPLEFORMAT_UINT && format != SAMPLEFORMAT_INT))\n  {\n    logerr(\"Invalid TIFF format, only 'integer' type is supported\");\n    TIFFClose(image);\n    return NULL;\n  }\n\n  if (bpp != 1 && bpp != 8 && bpp != 16)\n  {\n    logerr(\"Invalid TIFF format, only 1, 8 and 16-bit is supported\");\n    TIFFClose(image);\n    return NULL;\n  }\n\n  if (spp != 1 && spp != 3 && spp != 4)\n  {\n    logerr(\"Invalid TIFF format, only 1, 3 and 4 channels supported\");\n    TIFFClose(image);\n    return NULL;\n  }\n\n\n  TexImage32 *im = (TexImage32 *)mem->tryAlloc(sizeof(TexImage32) + width * height * 4);\n  if (!im)\n  {\n    TIFFClose(image);\n    return NULL;\n  }\n\n  TexPixel32 *ptr = (TexPixel32 *)(im + 1);\n  int res = TIFFReadRGBAImageOriented(image, width, height, (uint32_t *)ptr, ORIENTATION_TOPLEFT, 1);\n\n  if (!res)\n  {\n    mem->free(im);\n    TIFFClose(image);\n    return NULL;\n  }\n\n  int pixelCount = width * height;\n  uint8_t *bytePtr = (uint8_t *)ptr;\n  for (int i = 0; i < pixelCount; i++)\n  {\n    uint8_t tmp = bytePtr[0];\n    bytePtr[0] = bytePtr[2];\n    bytePtr[2] = tmp;\n    bytePtr += 4;\n  }\n\n  if (out_used_alpha)\n    *out_used_alpha = (spp == 4);\n\n  TIFFClose(image);\n\n  im->w = width;\n  im->h = height;\n\n  return im;\n}",
    "virtual bool loadImage(BitmapMask &_img, const char *folder, const char *image_name)\n  {\n    String fname;\n    makeFullPath(fname, folder, image_name, \".tif\");\n\n    PublicBitmapMask &img = static_cast<PublicBitmapMask &>(_img);\n    img.init();\n\n    TIFF *image;\n    uint16_t photo, bps, spp, fillorder;\n    uint32_t width, height;\n    tsize_t stripSize;\n    unsigned long result;\n    int stripMax;\n    char *buffer, *buffer_end, tempbyte;\n\n    // debug(\"reading image <%s>\", (char*)fname);\n    //  Open the TIFF image\n    if ((image = TIFFOpen(fname, \"r\")) == NULL)\n    {\n      debug(\"Could not open image <%s>\", (char *)fname);\n\n      // try load .tga, if exist\n      makeFullPath(fname, folder, image_name, \".tga\");\n      TexImage32 *im = ::load_tga32(fname, tmpmem);\n      if (!im)\n      {\n        debug(\"  Could not open image <%s>\", (char *)fname);\n        return false;\n      }\n      img.alloc(im->w, im->h, 32, true);\n      if (img.singleTile())\n        memcpy(img.singleTile(), (im + 1), im->w * im->h * 4);\n      else\n      {\n        logerr(\"Could not initialize image <%s>\", (char *)fname);\n        memfree(im, tmpmem);\n        return false;\n      }\n      debug(\"loaded %dx%dx%dbit from %s\", img.getWidth(), img.getHeight(), img.getBitsPerPixel(), (char *)fname);\n      memfree(im, tmpmem);\n      return true;\n    }\n\n    // Do whatever it is we do with the buffer -- we dump it in hex\n    if (TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &width) == 0)\n    {\n      debug(\"Image does not define its width\");\n      TIFFClose(image);\n      return false;\n    }\n    if (TIFFGetField(image, TIFFTAG_IMAGELENGTH, &height) == 0)\n    {\n      debug(\"Image does not define its height\");\n      TIFFClose(image);\n      return false;\n    }\n\n    // Check that it is of a type that we support\n    if (TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &bps) == 0)\n    {\n      debug(\"undefined number of bits per sample\");\n      TIFFClose(image);\n      return false;\n    }\n    if (bps != 1 && bps != 4 && bps != 8 && bps != 16 && bps != 32)\n    {\n      debug(\"unsupported number of bits per sample: %d\", bps);\n      TIFFClose(image);\n      return false;\n    }\n\n    if (TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &spp) == 0)\n    {\n      debug(\"undefined number of samples per pixel\");\n      TIFFClose(image);\n      return false;\n    }\n\n    if (spp != 1 && spp != 3 && spp != 4)\n    {\n      debug(\"unsupported number of samples per pixel: %d\", spp);\n      TIFFClose(image);\n      return false;\n    }\n\n    // Deal with photometric interpretations\n    if (TIFFGetField(image, TIFFTAG_PHOTOMETRIC, &photo) == 0)\n    {\n      debug(\"Image has an undefined photometric interpretation\");\n      TIFFClose(image);\n      return false;\n    }\n\n    // Deal with fillorder\n    if (TIFFGetField(image, TIFFTAG_FILLORDER, &fillorder) == 0)\n      fillorder = FILLORDER_MSB2LSB;\n\n    if (spp == 3 && bps <= 8)\n    {\n      img.alloc(width, height, 32, true);\n      TIFFReadRGBAImage(image, width, height, (unsigned *)img.singleTile(), 0);\n      TIFFClose(image);\n      return true;\n    }\n\n    img.alloc(width, height, bps * spp);\n\n    // Read in the possibly multiple strips\n    stripSize = TIFFStripSize(image);\n    stripMax = TIFFNumberOfStrips(image);\n\n    if (spp == 1 && photo != PHOTOMETRIC_MINISBLACK)\n      debug(\"Fixing the photometric interpretation\");\n    if (fillorder != FILLORDER_MSB2LSB)\n      debug(\"Fixing the fillorder\");\n\n    // debug(\"width=%d bps=%d spp=%d stripSize=%d\", width, bps, spp, stripSize);\n    buffer = new char[stripSize];\n    for (int stripCount = 0, img_y = 0; stripCount < stripMax; stripCount++)\n    {\n      if ((result = TIFFReadEncodedStrip(image, stripCount, buffer, stripSize)) == -1)\n      {\n        debug(\"Read error on input strip number %d\", stripCount);\n        img.destroy();\n        TIFFClose(image);\n        delete[] buffer;\n        return false;\n      }\n      if (spp == 1 && photo != PHOTOMETRIC_MINISBLACK) // Flip bits\n        for (char *b = buffer, *be = b + result; b < be; b++)\n          *b = ~*b;\n      if (fillorder != FILLORDER_MSB2LSB) // We need to swap bits -- ABCDEFGH becomes HGFEDCBA\n        for (char *b = buffer, *be = b + result; b < be; b++)\n        {\n          tempbyte = 0;\n          if (*buffer & 128)\n            tempbyte += 1;\n          if (*buffer & 64)\n            tempbyte += 2;\n          if (*buffer & 32)\n            tempbyte += 4;\n          if (*buffer & 16)\n            tempbyte += 8;\n          if (*buffer & 8)\n            tempbyte += 16;\n          if (*buffer & 4)\n            tempbyte += 32;\n          if (*buffer & 2)\n            tempbyte += 64;\n          if (*buffer & 1)\n            tempbyte += 128;\n          *buffer = tempbyte;\n        }\n\n      int rows = result / (width * bps * spp / 8);\n      G_ASSERT(result = rows * (width * bps * spp / 8));\n\n      G_ASSERT(img_y + rows <= img.getHeight());\n      img.copyFrom(buffer, img_y, rows);\n      img_y += rows;\n    }\n    delete[] buffer;\n\n    TIFFClose(image);\n\n    debug(\"loaded %dx%dx%dbit from %s\", img.getWidth(), img.getHeight(), img.getBitsPerPixel(), (char *)fname);\n    return true;\n  }",
    "virtual bool getBitMaskProps(const char *folder, const char *image_name, int &out_w, int &out_h, int &out_bpp)\n  {\n    String fname;\n    makeFullPath(fname, folder, image_name, \".tif\");\n\n    TIFF *image;\n    uint16_t photo, bps, spp, fillorder;\n    tsize_t stripSize;\n    unsigned long result;\n    int stripMax;\n    char *buffer, *buffer_end, tempbyte;\n\n    if ((image = TIFFOpen(fname, \"r\")) == NULL)\n      return false;\n\n    if (TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &out_w) == 0 || TIFFGetField(image, TIFFTAG_IMAGELENGTH, &out_h) == 0 ||\n        TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &bps) == 0 || TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &spp) == 0)\n    {\n      TIFFClose(image);\n      return false;\n    }\n    out_bpp = spp * bps;\n    return true;\n  }",
    "virtual bool checkBitMask(const char *folder, const char *image_name, int w, int h, int bpp)\n  {\n    String fname;\n    makeFullPath(fname, folder, image_name, \".tif\");\n\n    TIFF *image;\n    uint16_t photo, bps, spp, fillorder;\n    uint32_t width, height;\n    tsize_t stripSize;\n    unsigned long result;\n    int stripMax;\n    char *buffer, *buffer_end, tempbyte;\n\n    if ((image = TIFFOpen(fname, \"r\")) == NULL)\n      return false;\n\n    if (TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &width) == 0 || TIFFGetField(image, TIFFTAG_IMAGELENGTH, &height) == 0 ||\n        TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &bps) == 0 || TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &spp) == 0)\n    {\n      TIFFClose(image);\n      return false;\n    }\n\n    if ((bps != 1 && bps != 4 && bps != 8 && bps != 16 && bps != 32) || (spp != 1 && spp != 3 && spp != 4) || width != w ||\n        height != h || bpp != spp * bps)\n    {\n      TIFFClose(image);\n      return false;\n    }\n    TIFFClose(image);\n    debug(\"%s confirmed: %dx%d, %d bpp\", fname.str(), w, h, bpp);\n    return true;\n  }",
    "bool Tiff_Exif_GetInfo(TIFF* tif_ctx, ttag_t tag, CFX_DIBAttribute* pAttr) {\n  T val = 0;\n  TIFFGetField(tif_ctx, tag, &val);\n  if (!val)\n    return false;\n  T* ptr = FX_Alloc(T, 1);\n  *ptr = val;\n  pAttr->m_Exif[tag] = ptr;\n  return true;\n}",
    "void Tiff_Exif_GetStringInfo(TIFF* tif_ctx,\n                             ttag_t tag,\n                             CFX_DIBAttribute* pAttr) {\n  char* buf = nullptr;\n  TIFFGetField(tif_ctx, tag, &buf);\n  if (!buf)\n    return;\n  size_t size = strlen(buf);\n  uint8_t* ptr = FX_Alloc(uint8_t, size + 1);\n  memcpy(ptr, buf, size);\n  ptr[size] = 0;\n  pAttr->m_Exif[tag] = ptr;\n}",
    "bool CTiffContext::LoadFrameInfo(int32_t frame,\n                                 int32_t* width,\n                                 int32_t* height,\n                                 int32_t* comps,\n                                 int32_t* bpc,\n                                 CFX_DIBAttribute* pAttribute) {\n  if (!TIFFSetDirectory(m_tif_ctx.get(), (uint16)frame))\n    return false;\n\n  uint32_t tif_width = 0;\n  uint32_t tif_height = 0;\n  uint16_t tif_comps = 0;\n  uint16_t tif_bpc = 0;\n  uint32_t tif_rps = 0;\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_IMAGEWIDTH, &tif_width);\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_IMAGELENGTH, &tif_height);\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_SAMPLESPERPIXEL, &tif_comps);\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_BITSPERSAMPLE, &tif_bpc);\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_ROWSPERSTRIP, &tif_rps);\n\n  if (pAttribute) {\n    pAttribute->m_wDPIUnit = FXCODEC_RESUNIT_INCH;\n    if (TIFFGetField(m_tif_ctx.get(), TIFFTAG_RESOLUTIONUNIT,\n                     &pAttribute->m_wDPIUnit)) {\n      pAttribute->m_wDPIUnit--;\n    }\n    Tiff_Exif_GetInfo<uint16_t>(m_tif_ctx.get(), TIFFTAG_ORIENTATION,\n                                pAttribute);\n    if (Tiff_Exif_GetInfo<float>(m_tif_ctx.get(), TIFFTAG_XRESOLUTION,\n                                 pAttribute)) {\n      void* val = pAttribute->m_Exif[TIFFTAG_XRESOLUTION];\n      float fDpi = val ? *reinterpret_cast<float*>(val) : 0;\n      pAttribute->m_nXDPI = (int32_t)(fDpi + 0.5f);\n    }\n    if (Tiff_Exif_GetInfo<float>(m_tif_ctx.get(), TIFFTAG_YRESOLUTION,\n                                 pAttribute)) {\n      void* val = pAttribute->m_Exif[TIFFTAG_YRESOLUTION];\n      float fDpi = val ? *reinterpret_cast<float*>(val) : 0;\n      pAttribute->m_nYDPI = (int32_t)(fDpi + 0.5f);\n    }\n    Tiff_Exif_GetStringInfo(m_tif_ctx.get(), TIFFTAG_IMAGEDESCRIPTION,\n                            pAttribute);\n    Tiff_Exif_GetStringInfo(m_tif_ctx.get(), TIFFTAG_MAKE, pAttribute);\n    Tiff_Exif_GetStringInfo(m_tif_ctx.get(), TIFFTAG_MODEL, pAttribute);\n  }\n  pdfium::base::CheckedNumeric<int32_t> checked_width = tif_width;\n  pdfium::base::CheckedNumeric<int32_t> checked_height = tif_height;\n  if (!checked_width.IsValid() || !checked_height.IsValid())\n    return false;\n\n  *width = checked_width.ValueOrDie();\n  *height = checked_height.ValueOrDie();\n  *comps = tif_comps;\n  *bpc = tif_bpc;\n  if (tif_rps > tif_height) {\n    tif_rps = tif_height;\n    TIFFSetField(m_tif_ctx.get(), TIFFTAG_ROWSPERSTRIP, tif_rps);\n  }\n  return true;\n}",
    "bool CTiffContext::IsSupport(const RetainPtr<CFX_DIBitmap>& pDIBitmap) const {\n  if (TIFFIsTiled(m_tif_ctx.get()))\n    return false;\n\n  uint16_t photometric = 0;\n  if (!TIFFGetField(m_tif_ctx.get(), TIFFTAG_PHOTOMETRIC, &photometric))\n    return false;\n\n  switch (pDIBitmap->GetBPP()) {\n    case 1:\n    case 8:\n      if (photometric != PHOTOMETRIC_PALETTE) {\n        return false;\n      }\n      break;\n    case 24:\n      if (photometric != PHOTOMETRIC_RGB) {\n        return false;\n      }\n      break;\n    default:\n      return false;\n  }\n  uint16_t planarconfig = 0;\n  if (!TIFFGetFieldDefaulted(m_tif_ctx.get(), TIFFTAG_PLANARCONFIG,\n                             &planarconfig))\n    return false;\n\n  return planarconfig != PLANARCONFIG_SEPARATE;\n}",
    "void CTiffContext::SetPalette(const RetainPtr<CFX_DIBitmap>& pDIBitmap,\n                              uint16_t bps) {\n  uint16_t* red_orig = nullptr;\n  uint16_t* green_orig = nullptr;\n  uint16_t* blue_orig = nullptr;\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_COLORMAP, &red_orig, &green_orig,\n               &blue_orig);\n  for (int32_t i = (1L << bps) - 1; i >= 0; i--) {\n#define CVT(x) ((uint16_t)((x) >> 8))\n    red_orig[i] = CVT(red_orig[i]);\n    green_orig[i] = CVT(green_orig[i]);\n    blue_orig[i] = CVT(blue_orig[i]);\n#undef CVT\n  }\n  int32_t len = 1 << bps;\n  for (int32_t index = 0; index < len; index++) {\n    uint32_t r = red_orig[index] & 0xFF;\n    uint32_t g = green_orig[index] & 0xFF;\n    uint32_t b = blue_orig[index] & 0xFF;\n    uint32_t color = (uint32_t)b | ((uint32_t)g << 8) | ((uint32_t)r << 16) |\n                     (((uint32)0xffL) << 24);\n    pDIBitmap->SetPaletteArgb(index, color);\n  }\n}",
    "bool CTiffContext::Decode(const RetainPtr<CFX_DIBitmap>& pDIBitmap) {\n  uint32_t img_width = pDIBitmap->GetWidth();\n  uint32_t img_height = pDIBitmap->GetHeight();\n  uint32_t width = 0;\n  uint32_t height = 0;\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_IMAGELENGTH, &height);\n  if (img_width != width || img_height != height)\n    return false;\n\n  if (pDIBitmap->GetBPP() == 32) {\n    uint16_t rotation = ORIENTATION_TOPLEFT;\n    TIFFGetField(m_tif_ctx.get(), TIFFTAG_ORIENTATION, &rotation);\n    if (TIFFReadRGBAImageOriented(m_tif_ctx.get(), img_width, img_height,\n                                  (uint32*)pDIBitmap->GetBuffer(), rotation,\n                                  1)) {\n      for (uint32_t row = 0; row < img_height; row++) {\n        uint8_t* row_buf = pDIBitmap->GetWritableScanline(row);\n        TiffBGRA2RGBA(row_buf, img_width, 4);\n      }\n      return true;\n    }\n  }\n  uint16_t spp = 0;\n  uint16_t bps = 0;\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_BITSPERSAMPLE, &bps);\n  FX_SAFE_UINT32 safe_bpp = bps;\n  safe_bpp *= spp;\n  if (!safe_bpp.IsValid())\n    return false;\n  uint32_t bpp = safe_bpp.ValueOrDie();\n  if (bpp == 1)\n    return Decode1bppRGB(pDIBitmap, height, width, bps, spp);\n  if (bpp <= 8)\n    return Decode8bppRGB(pDIBitmap, height, width, bps, spp);\n  if (bpp <= 24)\n    return Decode24bppRGB(pDIBitmap, height, width, bps, spp);\n  return false;\n}",
    "bool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif.get());\n    if (!tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n            if (!tif)\n                delete buf_helper;\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n        if (tif)\n            m_tif.reset(tif, cv_tiffCloseHandle);\n        else\n            m_tif.release();\n    }\n\n    if (tif)\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &wdth));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hght));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n        {\n            bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n            uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n            if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n            {\n                // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n                bpp = 1;\n            }\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n\n            m_width = wdth;\n            m_height = hght;\n            if (ncn == 3 && photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 1:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 8:\n                    //Palette color, the value of the component is used as an index into the red,\n                    //green and blue curves in the ColorMap field to retrieve an RGB triplet that defines the color.\n                    if(photometric == PHOTOMETRIC_PALETTE)\n                        m_type = CV_MAKETYPE(CV_8U, 3);\n                    else\n                        m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, wanted_channels);\n                    result = true;\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, wanted_channels);\n                    result = true;\n                    break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}",
    "const void* NImage::CTIFImageReader::ReadImage\n(\n\tconst char * cpImageName, \n\tuint32& rImageWidth, \n\tuint32& rImageHeight, \n\tEImageFileFormat& rFormat, \n\tconst uint32\n) const\n{\n\tconst uint32 cBPP = 3;\n\tstatic CSHAllocator<float> sAllocator;\n\tTIFF* pTiff = TIFFOpen(cpImageName,\"r\");\n\n\tfloat *pOutput = NULL;\n\tif(pTiff) \n\t{\n\t\tuint32 width, height;\n\t\tsize_t pixelNum;\n\t\tuint32 *pRGBA;\n\n\t\tTIFFGetField(pTiff, TIFFTAG_IMAGEWIDTH, &width);\n\t\tTIFFGetField(pTiff, TIFFTAG_IMAGELENGTH, &height);\n\t\trImageWidth\t\t= width;\n\t\trImageHeight\t= height;\n\t\trFormat\t= (cBPP == 4)?A32B32G32R32F : B32G32R32F;\n\n\t\tpixelNum = width * height;\n\t\tpRGBA = (uint32*) new char[pixelNum * sizeof (uint32)];\n\n\t\tif(pRGBA) \n\t\t{\n\t\t\tif(TIFFReadRGBAImage(pTiff, width, height, pRGBA, 0)) \n\t\t\t{\n\t\t\t\t//convert data into floats\n\t\t\t\t// scan and copy surface, everything is float RGB\n\t\t\t\tpOutput = (float*)(sAllocator.new_mem_array(sizeof(float) * rImageWidth * rImageHeight * cBPP));\n\t\t\t\tassert(pOutput);\t\n\n\t\t\t\tfloat *pCurrentOutput = pOutput;\n\t\t\t\tuint32 *pCurrentInput = pRGBA;\n\n\t\t\t\tfor(unsigned int y=0; y < height; ++y)\n\t\t\t\t{\n\t\t\t\t\tfor(unsigned int x=0; x < width; ++x)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int i=0; i<cBPP; ++i)\n\t\t\t\t\t\t\tpCurrentOutput[i] = (float)pCurrentInput[i];\n\t\t\t\t\t\tpCurrentOutput\t+= cBPP;\n\t\t\t\t\t\tpCurrentInput\t\t+= cBPP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSAFE_DELETE_ARRAY(pRGBA);\n\t\t}\n//\t\telse RCLogError(\"ReadImage out of memory\");\n\t}\n\telse\n\t{\n\t\tchar message[200];\n\t\tsprintf(message, \"Could not load Texture: %s\\n\", cpImageName);\n\t\tGetSHLog().LogError(message);\n\t\treturn NULL;\n\t}\n\n\tif(pTiff)\n\t\tTIFFClose(pTiff);\n\n\treturn (void*)pOutput;\n}",
    "DataType FindTIFFDataType( TiffFile& tiff ) {\n   uint16 bitsPerSample{};\n   if( !TIFFGetField( tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample )) {\n      bitsPerSample = 1; // Binary images don't carry this tag\n   }\n   uint16 sampleFormat{};\n   if( !TIFFGetField( tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat )) {\n      sampleFormat = SAMPLEFORMAT_UINT;\n   }\n   switch( sampleFormat ) {\n      case SAMPLEFORMAT_UINT:\n         switch( bitsPerSample ) {\n            case 1:\n               return DT_BIN;\n            case 8:\n               return DT_UINT8;\n            case 16:\n               return DT_UINT16;\n            case 32:\n               return DT_UINT32;\n            case 64:\n               return DT_UINT64;\n            default:\n               DIP_THROW_RUNTIME( TIFF_UNKNOWN_BIT_DEPTH );\n         }\n      case SAMPLEFORMAT_INT:\n         switch( bitsPerSample ) {\n            case 8:\n               return DT_SINT8;\n            case 16:\n               return DT_SINT16;\n            case 32:\n               return DT_SINT32;\n            case 64:\n               return DT_SINT64;\n            default:\n               DIP_THROW_RUNTIME( TIFF_UNKNOWN_BIT_DEPTH );\n         }\n      case SAMPLEFORMAT_IEEEFP:\n         switch( bitsPerSample ) {\n            case 8: // I have a TIFF file that says to be 8-bit IEEEFP, but is not.\n               return DT_UINT8;\n            case 32:\n               return DT_SFLOAT;\n            case 64:\n               return DT_DFLOAT;\n            default:\n               DIP_THROW_RUNTIME( TIFF_UNKNOWN_BIT_DEPTH );\n         }\n      default:\n         DIP_THROW_RUNTIME( \"Unsupported TIFF: Unknown pixel format\" );\n   }\n}",
    "bool IsTrulyPalette( TiffFile& tiff ) {\n   // So you say your TIFFTAG_PHOTOMETRIC == PHOTOMETRIC_PALETTE, but this is not always true!\n   // 1. Ensure there's actually a palette in the file.\n   uint16* CMRed{};\n   uint16* CMGreen{};\n   uint16* CMBlue{};\n   if( !TIFFGetField( tiff, TIFFTAG_COLORMAP, &CMRed, &CMGreen, &CMBlue )) {\n      return false;\n   }\n   // 2. Make sure bits per sample is valid\n   uint16 bitsPerSample{};\n   if( !TIFFGetField( tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample )) {\n      return false;\n   }\n   if(( bitsPerSample != 4 ) && ( bitsPerSample != 8 )) {\n      return false;\n   }\n   return true;\n}",
    "GetTIFFInfoData GetTIFFInfo( TiffFile& tiff, bool useColorMap ) {\n   GetTIFFInfoData data{};\n\n   data.fileInformation.name = tiff.FileName();\n   data.fileInformation.fileType = \"TIFF\";\n\n   // Image sizes\n   uint32 imageWidth{}, imageLength{};\n   READ_REQUIRED_TIFF_TAG( tiff, TIFFTAG_IMAGEWIDTH, &imageWidth );\n   READ_REQUIRED_TIFF_TAG( tiff, TIFFTAG_IMAGELENGTH, &imageLength );\n   data.fileInformation.sizes = { imageWidth, imageLength };\n   uint16 samplesPerPixel{};\n   if( !TIFFGetField( tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel )) {\n      samplesPerPixel = 1;\n   }\n   data.fileInformation.tensorElements = samplesPerPixel;\n\n   // Photometric interpretation\n   if( !TIFFGetField( tiff, TIFFTAG_PHOTOMETRIC, &data.photometricInterpretation )) {\n      data.photometricInterpretation = PHOTOMETRIC_MINISBLACK;\n   }\n   switch( data.photometricInterpretation ) {\n      case PHOTOMETRIC_YCBCR:\n         DIP_THROW_RUNTIME( \"Unsupported TIFF: Class Y image (YCbCr)\" );\n         // Mostly because these often have sub-sampled Cb and Cr, and sometimes they don't even bother setting the tags for it.\n      case PHOTOMETRIC_LOGLUV:\n      case PHOTOMETRIC_LOGL:\n         DIP_THROW_RUNTIME( \"Unsupported TIFF: Log-compressed image (LogLuv or LogL)\" );\n      case PHOTOMETRIC_PALETTE: {\n         if( !useColorMap || !IsTrulyPalette( tiff )) {\n            data.photometricInterpretation = PHOTOMETRIC_MINISBLACK;\n            break;\n         }\n         // Color-mapped images have 3 channels and 16 bits per channel.\n         data.fileInformation.colorSpace = \"sRGB\";\n         data.fileInformation.tensorElements = 3;\n         data.fileInformation.dataType = DT_UINT16;\n         break;\n      }\n      case PHOTOMETRIC_RGB:\n         if( samplesPerPixel == 3 ) {\n            data.fileInformation.colorSpace = \"sRGB\";\n         }\n         break;\n      case PHOTOMETRIC_SEPARATED:\n         // Assume CMYK, but we should really be reading the ink values...\n         switch( samplesPerPixel ) {\n            case 3:\n               data.fileInformation.colorSpace = \"CMY\";\n               break;\n            case 4:\n               data.fileInformation.colorSpace = \"CMYK\";\n               break;\n            default:\n               break;\n         }\n         break;\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_ICCLAB:\n      case PHOTOMETRIC_ITULAB:\n         data.fileInformation.colorSpace = \"Lab\";\n         break;\n      case PHOTOMETRIC_MINISWHITE:\n      case PHOTOMETRIC_MINISBLACK:\n      case PHOTOMETRIC_MASK:\n      default:\n         // If we don't recognize the photometric interpretation, just read the data as-is and don't set a color space\n         break;\n   }\n\n   // Data type\n   if( data.photometricInterpretation != PHOTOMETRIC_PALETTE ) {\n      data.fileInformation.dataType = FindTIFFDataType( tiff );\n   }\n   if( data.fileInformation.dataType == DT_BIN ) {\n      data.fileInformation.significantBits = 1;\n   } else {\n      // TODO: 12-bit TIFF files will have 16 significant bits. Is there a tag\n      //       we need to look at for this?\n      data.fileInformation.significantBits = data.fileInformation.dataType.SizeOf() * 8;\n   }\n\n   // Physical dimensions\n   uint16 resolutionUnit{};\n   if( !TIFFGetField( tiff, TIFFTAG_RESOLUTIONUNIT, &resolutionUnit )) {\n      resolutionUnit = 0;\n   }\n   PhysicalQuantity pixelSizeMultiplier = 1;\n   switch( resolutionUnit ) {\n      case RESUNIT_NONE:\n         break;\n      case RESUNIT_INCH:\n      default:\n         pixelSizeMultiplier = 0.0254 * Units::Meter();\n         break;\n      case RESUNIT_CENTIMETER:\n         pixelSizeMultiplier = 0.01 * Units::Meter();\n         break;\n   }\n   float resolution{};\n   PhysicalQuantity ps = 1;\n   if( TIFFGetField( tiff, TIFFTAG_XRESOLUTION, &resolution )) {\n      ps = ( 1.0 / static_cast< double >( resolution )) * pixelSizeMultiplier;\n      ps.Normalize();\n   }\n   data.fileInformation.pixelSize.Set( 0, ps );\n   ps = 1;\n   if( TIFFGetField( tiff, TIFFTAG_YRESOLUTION, &resolution )) {\n      ps = ( 1.0 / static_cast< double >( resolution )) * pixelSizeMultiplier;\n      ps.Normalize();\n   }\n   data.fileInformation.pixelSize.Set( 1, ps );\n\n   // Origin offset\n   float position{};\n   PhysicalQuantity xPos = 0 * pixelSizeMultiplier, yPos = 0 * pixelSizeMultiplier;\n   if( TIFFGetField( tiff, TIFFTAG_XPOSITION, &position )) {\n      xPos = static_cast< double >( position ) * pixelSizeMultiplier;\n      xPos.Normalize();\n   }\n   if( TIFFGetField( tiff, TIFFTAG_YPOSITION, &position )) {\n      yPos = static_cast< double >( position ) * pixelSizeMultiplier;\n      yPos.Normalize();\n   }\n   data.fileInformation.origin = { xPos, yPos };\n\n   // Number of images in file\n   data.fileInformation.numberOfImages = TIFFNumberOfDirectories( tiff );\n\n   // Metadata: the ImageDescription tag is often used to store metadata as XML or JSON.\n   char const* string{};\n   if( TIFFGetField( tiff, TIFFTAG_IMAGEDESCRIPTION, &string )) {\n      data.fileInformation.history.emplace_back( string );\n   }\n\n   return data;\n}",
    "void ReadTIFFColorMap(\n      Image& image,\n      TiffFile& tiff,\n      GetTIFFInfoData& data\n) {\n   // Test for tiled TIFF files. These we can't handle (yet).\n   uint32 tileWidth{};\n   if( TIFFGetField( tiff, TIFFTAG_TILEWIDTH, &tileWidth )) {\n      DIP_THROW_RUNTIME( \"Tiled TIFF format not supported for colormapped images\" );\n   }\n\n   // Read the tags\n   uint16 bitsPerSample{};\n   READ_REQUIRED_TIFF_TAG( tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample );\n   if(( bitsPerSample != 4 ) && ( bitsPerSample != 8 )) {\n      DIP_THROW_RUNTIME( TIFF_UNKNOWN_BIT_DEPTH );\n   }\n   uint16* CMRed{};\n   uint16* CMGreen{};\n   uint16* CMBlue{};\n   READ_REQUIRED_TIFF_TAG( tiff, TIFFTAG_COLORMAP, &CMRed, &CMGreen, &CMBlue );\n\n   // Forge the image\n   image.ReForge( data.fileInformation.sizes, 3, DT_UINT16 );\n   uint16* imagedata = static_cast< uint16* >( image.Origin() );\n\n   // Read the image data stripwise\n   uint32 imageWidth = static_cast< uint32 >( image.Size( 0 ));\n   uint32 imageLength = static_cast< uint32 >( image.Size( 1 ));\n   dip::uint scanline = static_cast< dip::uint >( TIFFScanlineSize( tiff ));\n   if( bitsPerSample == 4 ) {\n      DIP_ASSERT( scanline == div_ceil< dip::uint >( image.Size( 0 ), 2 ));\n   } else {\n      DIP_ASSERT( scanline == image.Size( 0 ));\n   }\n   std::vector< uint8 > buf( static_cast< dip::uint >( TIFFStripSize( tiff )));\n   uint32 rowsPerStrip{};\n   TIFFGetFieldDefaulted( tiff, TIFFTAG_ROWSPERSTRIP, &rowsPerStrip );\n   uint32 nStrips = TIFFNumberOfStrips( tiff );\n   uint32 row = 0;\n   for( uint32 strip = 0; strip < nStrips; ++strip ) {\n      dip::uint nrow = row + rowsPerStrip > imageLength ? imageLength - row : rowsPerStrip;\n      if( TIFFReadEncodedStrip( tiff, strip, buf.data(), static_cast< tmsize_t >( nrow * scanline )) < 0 ) {\n         DIP_THROW_RUNTIME( TIFF_ERROR_READING_DATA );\n      }\n      if( bitsPerSample == 4 ) {\n         ExpandColourMap4( imagedata, buf.data(), imageWidth, nrow, image.TensorStride(), image.Strides(), CMRed, CMGreen, CMBlue );\n      } else {\n         ExpandColourMap8( imagedata, buf.data(), imageWidth, nrow, image.TensorStride(), image.Strides(), CMRed, CMGreen, CMBlue );\n      }\n      imagedata += static_cast< dip::sint >( nrow ) * image.Stride( 1 );\n      row += rowsPerStrip;\n   }\n}",
    "void ReadTIFFBinary(\n      Image& image,\n      TiffFile& tiff,\n      GetTIFFInfoData& data\n) {\n   // Test for tiled TIFF files. These we can't handle (yet).\n   uint32 tileWidth{};\n   if( TIFFGetField( tiff, TIFFTAG_TILEWIDTH, &tileWidth )) {\n      DIP_THROW_RUNTIME( \"Tiled TIFF format not supported for binary images\" );\n   }\n\n   // Forge the image\n   image.ReForge( data.fileInformation.sizes, data.fileInformation.tensorElements, DT_BIN );\n   uint8* imagedata = static_cast< uint8* >( image.Origin() );\n\n   // Read the image data stripwise\n   uint32 imageWidth = static_cast< uint32 >( image.Size( 0 ));\n   uint32 imageLength = static_cast< uint32 >( image.Size( 1 ));\n   dip::uint scanline = static_cast< dip::uint >( TIFFScanlineSize( tiff ));\n   DIP_ASSERT( scanline == div_ceil< dip::uint >( image.Size( 0 ), 8 ));\n   std::vector< uint8 > buf( static_cast< dip::uint >( TIFFStripSize( tiff )));\n   uint32 rowsPerStrip{};\n   TIFFGetFieldDefaulted( tiff, TIFFTAG_ROWSPERSTRIP, &rowsPerStrip );\n   uint32 nStrips = TIFFNumberOfStrips( tiff );\n   uint32 row = 0;\n   for( uint32 strip = 0; strip < nStrips; ++strip ) {\n      uint32 nrow = ( row + rowsPerStrip > imageLength ? imageLength - row : rowsPerStrip );\n      if( TIFFReadEncodedStrip( tiff, strip, buf.data(), static_cast< tmsize_t >( nrow * scanline )) < 0 ) {\n         DIP_THROW_RUNTIME( TIFF_ERROR_READING_DATA );\n      }\n      if( data.photometricInterpretation == PHOTOMETRIC_MINISWHITE ) {\n         CopyBufferInv1( imagedata, buf.data(), imageWidth, nrow, image.Strides() );\n      } else {\n         CopyBuffer1( imagedata, buf.data(), imageWidth, nrow, image.Strides() );\n      }\n      imagedata += static_cast< dip::sint >( nrow ) * image.Stride( 1 );\n      row += rowsPerStrip;\n   }\n}",
    "void ReadTIFFData(\n      uint8* imagedata,\n      IntegerArray const& strides,\n      dip::sint tensorStride,\n      DataType dataType,\n      TiffFile& tiff,\n      FileInformation& data, // Shows how the data is stored in the file\n      RoiSpec const& roiSpec // Shows how the data is stored in memory -- sizes might be smaller if reading ROI!\n) {\n   dip::uint sizeOf = dataType.SizeOf();\n\n   // Planar configuration?\n   uint16 planarConfiguration = PLANARCONFIG_SEPARATE;\n   if( data.tensorElements > 1 ) {\n      if( !TIFFGetField( tiff, TIFFTAG_PLANARCONFIG, &planarConfiguration )) {\n         planarConfiguration = PLANARCONFIG_CONTIG; // Default\n      }\n   }\n\n   // Strips or tiles?\n   uint32 tileWidth{};\n   if( TIFFGetField( tiff, TIFFTAG_TILEWIDTH, &tileWidth )) {\n      // --- Tiled TIFF file ---\n      uint32 tileLength{};\n      READ_REQUIRED_TIFF_TAG( tiff, TIFFTAG_TILELENGTH, &tileLength );\n      auto tileSize = TIFFTileSize( tiff );\n      std::vector< uint8 > buf( static_cast< dip::uint >( tileSize ));\n      //uint32 nTiles = TIFFNumberOfTiles( tiff );\n      dip::uint firstTileX = ( roiSpec.roi[ 0 ].Offset() / tileWidth ) * tileWidth;\n      dip::uint firstTileY = ( roiSpec.roi[ 1 ].Offset() / tileLength ) * tileLength;\n      if( planarConfiguration == PLANARCONFIG_CONTIG ) {\n         // 1234123412341234....\n         // We know that data.tensorElements > 1, otherwise we force to PLANARCONFIG_SEPARATE\n         //std::cout << \"[ReadTIFFData] Tiles, Contiguous\\n\";\n         DIP_ASSERT( static_cast< dip::uint >( tileSize ) == static_cast< dip::uint >( tileWidth ) * tileLength * data.tensorElements * sizeOf );\n         dip::uint tileStrideY = data.tensorElements * tileWidth;\n         dip::uint yPos = roiSpec.roi[ 1 ].Offset();\n         for( dip::uint y = firstTileY; y <= roiSpec.roi[ 1 ].Last(); y += tileLength ) {\n            dip::uint tileEndY = std::min( y + tileLength, data.sizes[ 1 ] );\n            tileEndY = std::min( tileEndY, roiSpec.roi[ 1 ].Last() + 1 );\n            if( yPos >= tileEndY ) {\n               continue;\n            }\n            dip::uint copyHeight = div_ceil( tileEndY - yPos, roiSpec.roi[ 1 ].step );\n            uint8* imagedataPtr = imagedata;\n            dip::uint offsetY = ( yPos - y ) * tileStrideY;\n            dip::uint xPos = roiSpec.roi[ 0 ].Offset();\n            for( dip::uint x = firstTileX; x <= roiSpec.roi[ 0 ].Last(); x += tileWidth ) {\n               dip::uint tileEndX = std::min( x + tileWidth, data.sizes[ 0 ] );\n               tileEndX = std::min( tileEndX, roiSpec.roi[ 0 ].Last() + 1 );\n               if( xPos >= tileEndX ) {\n                  continue;\n               }\n               dip::uint copyWidth = div_ceil( tileEndX - xPos, roiSpec.roi[ 0 ].step );\n               dip::uint offset = ( offsetY + ( xPos - x ) * data.tensorElements + roiSpec.channels.Offset() );\n               uint32 tile = TIFFComputeTile( tiff, static_cast< uint32 >( x ), static_cast< uint32 >( y ), 0, 0 );\n               TIFFReadEncodedTile( tiff, tile, buf.data(), tileSize );\n               if( sizeOf == 1 ) {\n                  CopyBuffer3D_8bit( imagedataPtr, buf.data() + offset, roiSpec.tensorElements, copyWidth, copyHeight,\n                                     tensorStride, strides[ 0 ], strides[ 1 ],\n                                     roiSpec.channels.step, data.tensorElements * roiSpec.roi[ 0 ].step, tileStrideY * roiSpec.roi[ 1 ].step );\n                  imagedataPtr += static_cast< dip::sint >( copyWidth ) * strides[ 0 ];\n               } else {\n                  CopyBuffer3D( imagedataPtr, buf.data() + offset * sizeOf, roiSpec.tensorElements, copyWidth, copyHeight,\n                                tensorStride, strides[ 0 ], strides[ 1 ],\n                                roiSpec.channels.step, data.tensorElements * roiSpec.roi[ 0 ].step, tileStrideY * roiSpec.roi[ 1 ].step, sizeOf );\n                  imagedataPtr += static_cast< dip::sint >( copyWidth * sizeOf ) * strides[ 0 ];\n               }\n               xPos += roiSpec.roi[ 0 ].step * copyWidth;\n            }\n            imagedata += static_cast< dip::sint >( copyHeight * sizeOf ) * strides[ 1 ];\n            yPos += roiSpec.roi[ 1 ].step * copyHeight;\n         }\n      } else if( planarConfiguration == PLANARCONFIG_SEPARATE ) {\n         // 1111...2222...3333...4444...\n         //std::cout << \"[ReadTIFFData] Tiles, Separate\\n\";\n         DIP_ASSERT( static_cast< dip::uint >( tileSize ) == static_cast< dip::uint >( tileWidth ) * tileLength * sizeOf );\n         dip::uint tileStrideY = tileWidth;\n         for( auto plane : roiSpec.channels ) {\n            uint8* imagedataRow = imagedata;\n            dip::uint yPos = roiSpec.roi[ 1 ].Offset();\n            for( dip::uint y = firstTileY; y <= roiSpec.roi[ 1 ].Last(); y += tileLength ) {\n               dip::uint tileEndY = std::min( y + tileLength, data.sizes[ 1 ] );\n               tileEndY = std::min( tileEndY, roiSpec.roi[ 1 ].Last() + 1 );\n               if( yPos >= tileEndY ) {\n                  continue;\n               }\n               dip::uint copyHeight = div_ceil( tileEndY - yPos, roiSpec.roi[ 1 ].step );\n               uint8* imagedataPtr = imagedataRow;\n               dip::uint offsetY = ( yPos - y ) * tileStrideY;\n               dip::uint xPos = roiSpec.roi[ 0 ].Offset();\n               for( dip::uint x = firstTileX; x <= roiSpec.roi[ 0 ].Last(); x += tileWidth ) {\n                  dip::uint tileEndX = std::min( x + tileWidth, data.sizes[ 0 ] );\n                  tileEndX = std::min( tileEndX, roiSpec.roi[ 0 ].Last() + 1 );\n                  if( xPos >= tileEndX ) {\n                     continue;\n                  }\n                  dip::uint copyWidth = div_ceil( tileEndX - xPos, roiSpec.roi[ 0 ].step );\n                  dip::uint offset = ( offsetY + ( xPos - x ));\n                  uint32 tile = TIFFComputeTile( tiff, static_cast< uint32 >( x ), static_cast< uint32 >( y ), 0, static_cast< uint16 >( plane ));\n                  TIFFReadEncodedTile( tiff, tile, buf.data(), tileSize );\n                  if( sizeOf == 1 ) {\n                     //std::cout << \"Copying \" << copyWidth << \"x\" << copyHeight << \" pixels from tile, pos = \" << xPos << \", \" << yPos << std::endl;\n                     CopyBuffer2D_8bit( imagedataPtr, buf.data() + offset, copyWidth, copyHeight,\n                                        strides[ 0 ], strides[ 1 ],\n                                        roiSpec.roi[ 0 ].step, tileStrideY * roiSpec.roi[ 1 ].step );\n                     imagedataPtr += static_cast< dip::sint >( copyWidth ) * strides[ 0 ];\n                  } else {\n                     CopyBuffer2D( imagedataPtr, buf.data() + offset * sizeOf, copyWidth, copyHeight,\n                                   strides[ 0 ], strides[ 1 ],\n                                   roiSpec.roi[ 0 ].step, tileStrideY * roiSpec.roi[ 1 ].step, sizeOf );\n                     imagedataPtr += static_cast< dip::sint >( copyWidth * sizeOf ) * strides[ 0 ];\n                  }\n                  xPos += roiSpec.roi[ 0 ].step * copyWidth;\n               }\n               imagedataRow += static_cast< dip::sint >( copyHeight * sizeOf ) * strides[ 1 ];\n               yPos += roiSpec.roi[ 1 ].step * copyHeight;\n            }\n            imagedata += static_cast< dip::sint >( sizeOf ) * tensorStride;\n         }\n      } else {\n         DIP_THROW_RUNTIME( TIFF_UNKNOWN_PLANAR_CONFIG );\n      }\n   } else {\n      // --- Striped TIFF file ---\n      uint32 stripHeight{};\n      TIFFGetFieldDefaulted( tiff, TIFFTAG_ROWSPERSTRIP, &stripHeight );\n      tsize_t stripSize = TIFFStripSize( tiff );\n      uint32 nStrips = TIFFNumberOfStrips( tiff );\n      dip::uint firstStrip = ( roiSpec.roi[ 1 ].Offset() / stripHeight ) * stripHeight;\n      if( planarConfiguration == PLANARCONFIG_CONTIG ) {\n         // 1234123412341234....\n         // We know that tensorElements > 1, otherwise we force to PLANARCONFIG_SEPARATE\n         DIP_ASSERT( static_cast< dip::uint >( TIFFScanlineSize( tiff )) == data.sizes[ 0 ] * data.tensorElements * sizeOf );\n         if( roiSpec.isFullImage && roiSpec.isAllChannels && StridesAreNormal( data.tensorElements, tensorStride, data.sizes, strides )) {\n            //std::cout << \"[ReadTIFFData] Stripes, Contiguous, isFullImage\\n\";\n            uint32 yPos = 0;\n            for( uint32 strip = 0; strip < nStrips; ++strip ) {\n               dip::uint copyHeight = ( yPos + stripHeight > data.sizes[ 1 ] ? data.sizes[ 1 ] - yPos : stripHeight );\n               if( TIFFReadEncodedStrip( tiff, strip, imagedata, stripSize ) < 0 ) {\n                  DIP_THROW_RUNTIME( TIFF_ERROR_READING_DATA );\n               }\n               imagedata += static_cast< dip::sint >( copyHeight * sizeOf ) * strides[ 1 ];\n               yPos += stripHeight;\n            }\n         } else {\n            //std::cout << \"[ReadTIFFData] Stripes, Contiguous\\n\";\n            std::vector< uint8 > buf( static_cast< dip::uint >( stripSize ));\n            dip::uint yPos = roiSpec.roi[ 1 ].Offset();\n            dip::uint yStride = data.tensorElements * data.sizes[ 0 ];\n            for( dip::uint y = firstStrip; y <= roiSpec.roi[ 1 ].Last(); y += stripHeight ) {\n               dip::uint stripEnd = std::min( y + stripHeight, data.sizes[ 1 ] );\n               stripEnd = std::min( stripEnd, roiSpec.roi[ 1 ].Last() + 1 );\n               if( yPos >= stripEnd ) {\n                  continue;\n               }\n               dip::uint copyHeight = div_ceil( stripEnd - yPos, roiSpec.roi[ 1 ].step );\n               dip::uint offsetY = ( yPos - y ) * yStride;\n               dip::uint offset = ( offsetY + roiSpec.roi[ 0 ].Offset() * data.tensorElements + roiSpec.channels.Offset() );\n               uint32 strip = TIFFComputeStrip( tiff, static_cast< uint32 >( y ), 0 );\n               if( TIFFReadEncodedStrip( tiff, strip, buf.data(), stripSize ) < 0 ) {\n                  DIP_THROW_RUNTIME( TIFF_ERROR_READING_DATA );\n               }\n               if( sizeOf == 1 ) {\n                  //std::cout << \"Copying \" << roiSpec.sizes[ 0 ] << \"x\" << copyHeight << \" pixels from stripe, pos = \" << roiSpec.roi[ 0 ].Offset() << \", \" << yPos << std::endl;\n                  CopyBuffer3D_8bit(\n                        imagedata, buf.data() + offset, roiSpec.tensorElements, roiSpec.sizes[ 0 ], copyHeight,\n                        tensorStride, strides[ 0 ], strides[ 1 ],\n                        roiSpec.channels.step, data.tensorElements * roiSpec.roi[ 0 ].step, yStride * roiSpec.roi[ 1 ].step );\n                  imagedata += static_cast< dip::sint >( copyHeight ) * strides[ 1 ];\n               } else {\n                  CopyBuffer3D(\n                        imagedata, buf.data() + offset * sizeOf, roiSpec.tensorElements, roiSpec.sizes[ 0 ], copyHeight,\n                        tensorStride, strides[ 0 ], strides[ 1 ],\n                        roiSpec.channels.step, data.tensorElements * roiSpec.roi[ 0 ].step, yStride * roiSpec.roi[ 1 ].step, sizeOf );\n                  imagedata += static_cast< dip::sint >( copyHeight * sizeOf ) * strides[ 1 ];\n               }\n               yPos += roiSpec.roi[ 1 ].step * copyHeight;\n            }\n         }\n      } else if( planarConfiguration == PLANARCONFIG_SEPARATE ) {\n         // 1111...2222...3333...4444...\n         DIP_ASSERT( static_cast< dip::uint >( TIFFScanlineSize( tiff )) == data.sizes[ 0 ] * sizeOf );\n         DIP_ASSERT( nStrips % data.tensorElements == 0 );\n         nStrips /= static_cast< uint32 >( data.tensorElements );\n         if( roiSpec.isFullImage && StridesAreNormal( 1, 1, data.sizes, strides )) {\n            //std::cout << \"[ReadTIFFData] Stripes, Separate, isFullImage\\n\";\n            for( auto plane : roiSpec.channels ) {\n               uint8* imagedataRow = imagedata;\n               uint32 stripOffset = TIFFComputeStrip( tiff, 0, static_cast< uint16 >( plane ));\n               uint32 yPos = 0;\n               for( uint32 strip = 0; strip < nStrips; ++strip ) {\n                  dip::uint copyHeight = ( yPos + stripHeight > data.sizes[ 1 ] ? data.sizes[ 1 ] - yPos : stripHeight );\n                  if( TIFFReadEncodedStrip( tiff, stripOffset + strip, imagedataRow, stripSize ) < 0 ) {\n                     DIP_THROW_RUNTIME( TIFF_ERROR_READING_DATA );\n                  }\n                  imagedataRow += static_cast< dip::sint >( copyHeight * sizeOf ) * strides[ 1 ];\n                  yPos += stripHeight;\n               }\n               imagedata += static_cast< dip::sint >( sizeOf ) * tensorStride;\n            }\n         } else {\n            //std::cout << \"[ReadTIFFData] Stripes, Separate\\n\";\n            std::vector< uint8 > buf( static_cast< dip::uint >( stripSize ));\n            dip::uint yStride = data.sizes[ 0 ];\n            for( auto plane : roiSpec.channels ) {\n               uint8* imagedataRow = imagedata;\n               dip::uint yPos = roiSpec.roi[ 1 ].Offset();\n               for( dip::uint y = firstStrip; y <= roiSpec.roi[ 1 ].Last(); y += stripHeight ) {\n                  dip::uint stripEnd = std::min( y + stripHeight, data.sizes[ 1 ] );\n                  stripEnd = std::min( stripEnd, roiSpec.roi[ 1 ].Last() + 1 );\n                  if( yPos >= stripEnd ) {\n                     continue;\n                  }\n                  dip::uint copyHeight = div_ceil( stripEnd - yPos, roiSpec.roi[ 1 ].step );\n                  dip::uint offsetY = ( yPos - y ) * yStride;\n                  dip::uint offset = ( offsetY + roiSpec.roi[ 0 ].Offset() );\n                  uint32 strip = TIFFComputeStrip( tiff, static_cast< uint32 >( y ), static_cast< uint16 >( plane ));\n                  if( TIFFReadEncodedStrip( tiff, strip, buf.data(), stripSize ) < 0 ) {\n                     DIP_THROW_RUNTIME( TIFF_ERROR_READING_DATA );\n                  }\n                  if( sizeOf == 1 ) {\n                     CopyBuffer2D_8bit( imagedataRow, buf.data() + offset, roiSpec.sizes[ 0 ], copyHeight,\n                                        strides[ 0 ], strides[ 1 ],\n                                        roiSpec.roi[ 0 ].step, yStride * roiSpec.roi[ 1 ].step );\n                     imagedataRow += static_cast< dip::sint >( copyHeight ) * strides[ 1 ];\n                  } else {\n                     CopyBuffer2D( imagedataRow, buf.data() + offset * sizeOf, roiSpec.sizes[ 0 ], copyHeight,\n                                   strides[ 0 ], strides[ 1 ],\n                                   roiSpec.roi[ 0 ].step, yStride * roiSpec.roi[ 1 ].step, sizeOf );\n                     imagedataRow += static_cast< dip::sint >( copyHeight * sizeOf ) * strides[ 1 ];\n                  }\n                  yPos += roiSpec.roi[ 1 ].step * copyHeight;\n               }\n               imagedata += static_cast< dip::sint >( sizeOf ) * tensorStride;\n            }\n         }\n      } else {\n         DIP_THROW_RUNTIME( TIFF_UNKNOWN_PLANAR_CONFIG );\n      }\n   }\n}",
    "void ReadTIFFGreyValue(\n      Image& image,\n      TiffFile& tiff,\n      GetTIFFInfoData& data,\n      RoiSpec const& roiSpec\n) {\n   if( image.IsForged() && roiSpec.isFullImage && (( image.Sizes() != roiSpec.sizes ) || ( image.TensorElements() != roiSpec.tensorElements ))) {\n      // We need to reforge anyway, let's strip now.\n      image.Strip();\n   }\n   if( !image.IsForged() && ( roiSpec.tensorElements > 1 )) {\n      uint16 planarConfiguration = PLANARCONFIG_CONTIG;\n      TIFFGetField( tiff, TIFFTAG_PLANARCONFIG, &planarConfiguration );\n      if( planarConfiguration == PLANARCONFIG_SEPARATE ) {\n         // Set the tensor dimension as the last one, it will speed up reading\n         image.SetSizes( roiSpec.sizes );\n         image.SetTensorSizes( 1 );\n         image.SetNormalStrides();\n         image.SetTensorSizes( roiSpec.tensorElements );\n         image.SetTensorStride( static_cast< dip::sint >( roiSpec.sizes.product() ));\n      }\n   }\n\n   // Forge the image\n   image.ReForge( roiSpec.sizes, roiSpec.tensorElements, data.fileInformation.dataType );\n   uint8* imagedata = static_cast< uint8* >( image.Origin() );\n\n   // Read the image data\n   DIP_STACK_TRACE_THIS( ReadTIFFData( imagedata, image.Strides(), image.TensorStride(), image.DataType(), tiff, data.fileInformation, roiSpec ));\n\n   if( data.photometricInterpretation == PHOTOMETRIC_MINISWHITE ) {\n      Invert( image, image );\n   }\n}",
    "void ImageReadTIFFStack(\n      Image& image,\n      TiffFile& tiff,\n      GetTIFFInfoData& data,\n      Range const& imageNumbers,\n      RoiSpec& roiSpec,\n      bool useColorMap\n) {\n   // Forge the image\n   data.fileInformation.pixelSize.Set( data.fileInformation.sizes.size(), Units::Pixel() );\n   data.fileInformation.sizes.push_back( imageNumbers.Size() );\n   roiSpec.sizes.push_back( imageNumbers.Size() );\n   roiSpec.mirror.push_back( false );\n   //std::cout << \"[ImageReadTIFFStack] roiSpec.sizes = \" << roiSpec.sizes << \", roiSpec.tensorElements = \" << roiSpec.tensorElements << '\\n';\n   image.ReForge( roiSpec.sizes, roiSpec.tensorElements, data.fileInformation.dataType );\n   uint8* imagedata = static_cast< uint8* >( image.Origin() );\n   dip::sint z_stride = image.Stride( 2 ) * static_cast< dip::sint >( data.fileInformation.dataType.SizeOf() );\n\n   // Read the image data for first plane\n   if( data.photometricInterpretation == PHOTOMETRIC_PALETTE ) {\n      // TODO: To implement this, we need to separate out the core of ReadTIFFColorMap() to a separate function we can call here\n      DIP_THROW( \"Reading stacks of color-mapped images from a TIFF file is not yet implemented\" );\n   }\n   if( data.fileInformation.dataType.IsBinary() ) {\n      DIP_THROW( \"Reading stacks of binary images from a TIFF file is not yet implemented\" );\n   }\n   DIP_STACK_TRACE_THIS( ReadTIFFData( imagedata, image.Strides(), image.TensorStride(), image.DataType(), tiff, data.fileInformation, roiSpec ));\n\n   // Read the image data for other planes\n   dip::uint directory = imageNumbers.Offset();\n   for( dip::uint ii = 1; ii < image.Size( 2 ); ++ii ) {\n      imagedata += z_stride;\n      if( imageNumbers.start > imageNumbers.stop ) {\n         directory -= imageNumbers.step;\n      } else {\n         directory += imageNumbers.step;\n      }\n      if( TIFFSetDirectory( tiff, static_cast< uint16 >( directory )) == 0 ) {\n         DIP_THROW_RUNTIME( TIFF_DIRECTORY_NOT_FOUND );\n      }\n\n      // Test image plane to make sure it matches expectations\n      uint32 temp32{};\n      READ_REQUIRED_TIFF_TAG( tiff, TIFFTAG_IMAGEWIDTH, &temp32 );\n      if( temp32 != data.fileInformation.sizes[ 0 ] ) {\n         DIP_THROW_RUNTIME( \"Reading multi-slice TIFF: width of images not consistent\" );\n      }\n      READ_REQUIRED_TIFF_TAG( tiff, TIFFTAG_IMAGELENGTH, &temp32 );\n      if( temp32 != data.fileInformation.sizes[ 1 ] ) {\n         DIP_THROW_RUNTIME( \"Reading multi-slice TIFF: length of images not consistent\" );\n      }\n      uint16 photometricInterpretation{};\n      if( !TIFFGetField( tiff, TIFFTAG_PHOTOMETRIC, &photometricInterpretation )) {\n         photometricInterpretation = PHOTOMETRIC_MINISBLACK;\n      }\n      if(( photometricInterpretation == PHOTOMETRIC_PALETTE ) &&\n         ( !useColorMap || !IsTrulyPalette( tiff ))) {\n         photometricInterpretation = PHOTOMETRIC_MINISBLACK;\n      }\n      DataType dataType;\n      uint16 samplesPerPixel{};\n      if( photometricInterpretation == PHOTOMETRIC_PALETTE ) {\n         dataType = DT_UINT16;\n         samplesPerPixel = 3;\n      } else {\n         DIP_STACK_TRACE_THIS( dataType = FindTIFFDataType( tiff ));\n         if( !TIFFGetField( tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel )) {\n            samplesPerPixel = 1;\n         }\n      }\n      if( dataType != image.DataType() ) {\n         DIP_THROW_RUNTIME( \"Reading multi-slice TIFF: data type not consistent\" );\n      }\n      if( samplesPerPixel != data.fileInformation.tensorElements ) {\n         DIP_THROW_RUNTIME( \"Reading multi-slice TIFF: samples per pixel not consistent\" );\n      }\n\n      // Read the image data for this plane\n      if (data.photometricInterpretation == PHOTOMETRIC_PALETTE ) {\n         // TODO: Implement!\n         DIP_THROW( \"Reading stacks of color-mapped images from a TIFF file is not yet implemented\" );\n      }\n      DIP_STACK_TRACE_THIS( ReadTIFFData( imagedata, image.Strides(), image.TensorStride(), image.DataType(), tiff, data.fileInformation, roiSpec ));\n   }\n}",
    "bool CCodec_TiffContext::LoadFrameInfo(int32_t frame,\n                                       int32_t* width,\n                                       int32_t* height,\n                                       int32_t* comps,\n                                       int32_t* bpc,\n                                       CFX_DIBAttribute* pAttribute) {\n  if (!TIFFSetDirectory(m_tif_ctx, (uint16)frame))\n    return false;\n\n  uint32_t tif_width = 0;\n  uint32_t tif_height = 0;\n  uint16_t tif_comps = 0;\n  uint16_t tif_bpc = 0;\n  uint32_t tif_rps = 0;\n  TIFFGetField(m_tif_ctx, TIFFTAG_IMAGEWIDTH, &tif_width);\n  TIFFGetField(m_tif_ctx, TIFFTAG_IMAGELENGTH, &tif_height);\n  TIFFGetField(m_tif_ctx, TIFFTAG_SAMPLESPERPIXEL, &tif_comps);\n  TIFFGetField(m_tif_ctx, TIFFTAG_BITSPERSAMPLE, &tif_bpc);\n  TIFFGetField(m_tif_ctx, TIFFTAG_ROWSPERSTRIP, &tif_rps);\n\n  if (pAttribute) {\n    pAttribute->m_wDPIUnit = FXCODEC_RESUNIT_INCH;\n    if (TIFFGetField(m_tif_ctx, TIFFTAG_RESOLUTIONUNIT,\n                     &pAttribute->m_wDPIUnit)) {\n      pAttribute->m_wDPIUnit--;\n    }\n    Tiff_Exif_GetInfo<uint16_t>(m_tif_ctx, TIFFTAG_ORIENTATION, pAttribute);\n    if (Tiff_Exif_GetInfo<FX_FLOAT>(m_tif_ctx, TIFFTAG_XRESOLUTION,\n                                    pAttribute)) {\n      void* val = pAttribute->m_Exif[TIFFTAG_XRESOLUTION];\n      FX_FLOAT fDpi = val ? *reinterpret_cast<FX_FLOAT*>(val) : 0;\n      pAttribute->m_nXDPI = (int32_t)(fDpi + 0.5f);\n    }\n    if (Tiff_Exif_GetInfo<FX_FLOAT>(m_tif_ctx, TIFFTAG_YRESOLUTION,\n                                    pAttribute)) {\n      void* val = pAttribute->m_Exif[TIFFTAG_YRESOLUTION];\n      FX_FLOAT fDpi = val ? *reinterpret_cast<FX_FLOAT*>(val) : 0;\n      pAttribute->m_nYDPI = (int32_t)(fDpi + 0.5f);\n    }\n    Tiff_Exif_GetStringInfo(m_tif_ctx, TIFFTAG_IMAGEDESCRIPTION, pAttribute);\n    Tiff_Exif_GetStringInfo(m_tif_ctx, TIFFTAG_MAKE, pAttribute);\n    Tiff_Exif_GetStringInfo(m_tif_ctx, TIFFTAG_MODEL, pAttribute);\n  }\n  pdfium::base::CheckedNumeric<int32_t> checked_width = tif_width;\n  pdfium::base::CheckedNumeric<int32_t> checked_height = tif_height;\n  if (!checked_width.IsValid() || !checked_height.IsValid())\n    return false;\n\n  *width = checked_width.ValueOrDie();\n  *height = checked_height.ValueOrDie();\n  *comps = tif_comps;\n  *bpc = tif_bpc;\n  if (tif_rps > tif_height) {\n    tif_rps = tif_height;\n    TIFFSetField(m_tif_ctx, TIFFTAG_ROWSPERSTRIP, tif_rps);\n  }\n  return true;\n}",
    "bool CCodec_TiffContext::Decode(CFX_DIBitmap* pDIBitmap) {\n  uint32_t img_wid = pDIBitmap->GetWidth();\n  uint32_t img_hei = pDIBitmap->GetHeight();\n  uint32_t width = 0;\n  uint32_t height = 0;\n  TIFFGetField(m_tif_ctx, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(m_tif_ctx, TIFFTAG_IMAGELENGTH, &height);\n  if (img_wid != width || img_hei != height)\n    return false;\n\n  if (pDIBitmap->GetBPP() == 32) {\n    uint16_t rotation = ORIENTATION_TOPLEFT;\n    TIFFGetField(m_tif_ctx, TIFFTAG_ORIENTATION, &rotation);\n    if (TIFFReadRGBAImageOriented(m_tif_ctx, img_wid, img_hei,\n                                  (uint32*)pDIBitmap->GetBuffer(), rotation,\n                                  1)) {\n      for (uint32_t row = 0; row < img_hei; row++) {\n        uint8_t* row_buf = (uint8_t*)pDIBitmap->GetScanline(row);\n        TiffBGRA2RGBA(row_buf, img_wid, 4);\n      }\n      return true;\n    }\n  }\n  uint16_t spp = 0;\n  uint16_t bps = 0;\n  TIFFGetField(m_tif_ctx, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetField(m_tif_ctx, TIFFTAG_BITSPERSAMPLE, &bps);\n  FX_SAFE_UINT32 safe_bpp = bps;\n  safe_bpp *= spp;\n  if (!safe_bpp.IsValid())\n    return false;\n  uint32_t bpp = safe_bpp.ValueOrDie();\n  if (bpp == 1)\n    return Decode1bppRGB(pDIBitmap, height, width, bps, spp);\n  if (bpp <= 8)\n    return Decode8bppRGB(pDIBitmap, height, width, bps, spp);\n  if (bpp <= 24)\n    return Decode24bppRGB(pDIBitmap, height, width, bps, spp);\n  return false;\n}",
    "BitmapStorage* BitmapIO_TIF::TifReadLogLUV(BitmapInfo* fbi, BitmapManager* manager)\n\t{\n\t//-- Create a storage for this bitmap ------------------------------------\n\n     BitmapStorage *s = BMMCreateStorage(manager, BMM_LOGLUV_32);\n\t \n     if(!s)\n        return NULL;\n\n     if (s->Allocate(fbi,manager,BMM_OPEN_R)==0) {\n        bail_out:\n        if(s) {\n           delete s;\n           s = NULL;\n        }\n        return NULL;\n     }\n\n\t //'factor' is the physically - based units scale to scale these luminance values to\n\t //physically based units - candelas per metre squared\n\t //We still have to do something with this number...\n\t double factor = 0;\n\t if (!TIFFGetField(tif, TIFFTAG_STONITS, &factor) == 1)\n\t\t {\n\t\t factor = 1.0;\n\t\t }\n\n    // add the read stonits to the UserData\n    // bug 312453 - David Cunningham Nov. 7, 2001\n    UserData.lumStonits = factor;\n\n\tint y,type=0;\n\n\tfor (y = 0; y<height; y++)  \n\t\t{\n\t\tif (TIFFReadScanline(tif, loadbuf, y, 0)<0)\n\t\t\tgoto bail_out;\n\n\t\t\n\t\tif (td->td_photometric == PHOTOMETRIC_LOGL)\n\t\t\t{\n\t\t\tif (s && s->GetStoragePtr(&type) && type == BMM_LOGLUV_32)//this should always \n\t\t\t\t//be true, after all, we allocated it!\n\n\t\t\t\t//luv = (float*)line.Ptr();\n\t\t\t\t//we could play with exposure here - because of the high dynamic range, images\n\t\t\t\t//often look washed out because of clamping at white.  We can adjust this to display \n\t\t\t\t//images in different ranges.\n\t\t\t\tif(s->Put16Gray(0,y,width,(float*)loadbuf)!=1)\n\t\t\t\t\tgoto bail_out;\n\t\t\t}\n\t\telse if (td->td_photometric == PHOTOMETRIC_LOGLUV)\n\t\t\t{\n\t\t\tif (s && s->GetStoragePtr(&type) && type == BMM_LOGLUV_32)\n\t\t\t\t{\n\t\t\t\tLogLUV32Pixel* pixel = (LogLUV32Pixel*)s->GetStoragePtr(&type);\n\t\t\t\tpixel += y*width;\n\t\t\t\tLogLUV32Pixel* iter = (LogLUV32Pixel*)loadbuf;\n\t\t\t\tmemcpy(pixel, iter, width*sizeof(LogLUV32Pixel));//32 bits per pixel here.  4 bytes.\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tgoto bail_out;\n\t\t\t}\n\t\telse\n\t\t\tTIFFError(GetString(IDS_TIF_READ_ERR), GetString(IDS_TIFF_FORMAT_NO_SUPPORT));\n\t\t}\n\treturn s;\n\t}",
    "bool wxTIFFHandler::LoadFile( wxImage *image, wxInputStream& stream, bool verbose, int index )\n{\n    if (index == -1)\n        index = 0;\n\n    image->Destroy();\n\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"r\" );\n\n    if (!tif)\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Error loading image.\") );\n\n        return false;\n    }\n\n    if (!TIFFSetDirectory( tif, (tdir_t)index ))\n    {\n        if (verbose)\n            wxLogError( _(\"Invalid TIFF image index.\") );\n\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    uint32 w, h;\n    uint32 npixels;\n    uint32 *raster;\n\n    TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &w );\n    TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &h );\n\n    npixels = w * h;\n\n    raster = (uint32*) _TIFFmalloc( npixels * sizeof(uint32) );\n\n    if (!raster)\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    image->Create( (int)w, (int)h );\n    if (!image->Ok())\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n\n        _TIFFfree( raster );\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    if (!TIFFReadRGBAImage( tif, w, h, raster, 0 ))\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Error reading image.\") );\n\n        _TIFFfree( raster );\n        image->Destroy();\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    bool hasmask = false;\n\n    unsigned char *ptr = image->GetData();\n    ptr += w*3*(h-1);\n    uint32 pos = 0;\n\n    for (uint32 i = 0; i < h; i++)\n    {\n        for (uint32 j = 0; j < w; j++)\n        {\n            unsigned char alpha = (unsigned char)TIFFGetA(raster[pos]);\n            if (alpha < 127)\n            {\n                hasmask = true;\n                ptr[0] = image->GetMaskRed();\n                ptr++;\n                ptr[0] = image->GetMaskGreen();\n                ptr++;\n                ptr[0] = image->GetMaskBlue();\n                ptr++;\n            }\n            else\n            {\n                ptr[0] = (unsigned char)TIFFGetR(raster[pos]);\n                ptr++;\n                ptr[0] = (unsigned char)TIFFGetG(raster[pos]);\n                ptr++;\n                ptr[0] = (unsigned char)TIFFGetB(raster[pos]);\n                ptr++;\n            }\n            pos++;\n        }\n        ptr -= 2*w*3; // subtract line we just added plus one line\n    }\n\n    _TIFFfree( raster );\n\n    TIFFClose( tif );\n\n    image->SetMask( hasmask );\n\n    return true;\n}",
    "bool DkBasicLoader::loadTIFF(const QString &, QImage &, QSharedPointer<QByteArray>) const\n{\n    qWarning() << \"built-in TIFF loader is not included in this build and may be able to load this file\";\n#else\nbool DkBasicLoader::loadTIFF(const QString &filePath, QImage &img, QSharedPointer<QByteArray> ba) const\n{\n    bool success = false;\n\n    // first turn off nasty warning/error dialogs - (we do the GUI : )\n    TIFFErrorHandler oldErrorHandler, oldWarningHandler;\n    oldWarningHandler = TIFFSetWarningHandler(NULL);\n    oldErrorHandler = TIFFSetErrorHandler(NULL);\n\n    DkTimer dt;\n    TIFF *tiff = 0;\n\n// TODO: currently TIFFStreamOpen can only be linked on Windows?!\n#if defined(Q_OS_WIN)\n\n    std::istringstream is(ba ? ba->toStdString() : \"\");\n\n    if (ba)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &is);\n\n    // fallback to direct loading\n    if (!tiff)\n        tiff = TIFFOpen(filePath.toLatin1(), \"r\");\n\n    // FIXME: we could load without buffer if toLatin1()=>toUtf8() and on\n    // windows use wchar_t* version of TIFFOpen();\n\n    // loading from buffer allows us to load files with non-latin names\n    QSharedPointer<QByteArray> bal;\n    if (!tiff)\n        bal = loadFileToBuffer(filePath);\n\n    std::istringstream isl(bal ? bal->toStdString() : \"\");\n\n    if (bal)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &isl);\n#else\n    tiff = TIFFOpen(filePath.toLatin1(), \"r\");\n#endif\n\n    if (!tiff)\n        return success;\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n\n    // init the qImage\n    img = QImage(width, height, QImage::Format_ARGB32);\n\n    const int stopOnError = 1;\n    success = TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32_t *>(img.bits()), ORIENTATION_TOPLEFT, stopOnError) != 0;\n\n    if (success) {\n        for (uint32_t y = 0; y < height; ++y)\n            convert32BitOrder(img.scanLine(y), width);\n    }\n\n    TIFFClose(tiff);\n\n    TIFFSetWarningHandler(oldWarningHandler);\n    TIFFSetWarningHandler(oldErrorHandler);\n\n    return success;\n\n#endif // !WITH_LIBTIFF\n    return false;\n}\n\n#define DRIF_IMAGE_IMPL\n#include \"drif_image.h\"\n\nbool isQtFmtCompatible(uint32_t f)\n{\n    switch (f) {\n    case DRIF_FMT_RGB888:\n    case DRIF_FMT_RGBA8888:\n    case DRIF_FMT_GRAY:\n        return true;\n    }\n\n    return false;\n}\n\nuint32_t drif2qtfmt(uint32_t f)\n{\n    switch (f) {\n    case DRIF_FMT_RGB888:\n        return QImage::Format_RGB888;\n    case DRIF_FMT_RGBA8888:\n        return QImage::Format_RGBA8888;\n    case DRIF_FMT_GRAY:\n        return QImage::Format_Grayscale8;\n    }\n\n    return QImage::Format_Invalid;\n}\n\nbool DkBasicLoader::loadDRIF(const QString &filePath, QImage &img, QSharedPointer<QByteArray> ba) const\n{\n    bool success = false;\n\n    uint32_t w;\n    uint32_t h;\n    uint32_t f;\n\n    uint8_t *imgBytes = drifLoadImg(filePath.toLatin1(), &w, &h, &f);\n\n    if (!imgBytes)\n        return success;\n\n    if (isQtFmtCompatible(f)) {\n        img = QImage((int)w, (int)h, (QImage::Format)drif2qtfmt(f));\n        memcpy(reinterpret_cast<void *>(img.bits()), imgBytes, drifGetSize(w, h, f));\n\n        success = true;\n    }\n#ifdef WITH_OPENCV\n    else {\n        img = QImage((int)w, (int)h, QImage::Format_RGB888);\n\n        switch (f) {\n        case DRIF_FMT_BGR888: {\n            cv::Mat imgMat = cv::Mat((int)h, (int)w, CV_8UC3, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_BGR2RGB);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_RGB888P:\n        case DRIF_FMT_RGBA8888P: {\n            cv::Mat imgMatR = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes);\n            cv::Mat imgMatG = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes + w * h);\n            cv::Mat imgMatB = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes + 2 * w * h);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n\n            std::vector<cv::Mat> imgMat{imgMatR, imgMatG, imgMatB};\n            cv::merge(imgMat, rgbMat);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_BGR888P:\n        case DRIF_FMT_BGRA8888P: {\n            cv::Mat imgMatB = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes);\n            cv::Mat imgMatG = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes + w * h);\n            cv::Mat imgMatR = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes + 2 * w * h);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n\n            std::vector<cv::Mat> imgMat{imgMatR, imgMatG, imgMatB};\n            cv::merge(imgMat, rgbMat);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_BGRA8888: {\n            cv::Mat imgMat = cv::Mat((int)h, (int)w, CV_8UC4, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_BGR2RGB, 3);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_RGBA8888: {\n            cv::Mat imgMat = cv::Mat((int)h, (int)w, CV_8UC4, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_RGBA2RGB, 3);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_GRAY: {\n            cv::Mat imgMat = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_GRAY2RGB);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_YUV420P: {\n            cv::Mat imgMat = cv::Mat((int)h + h / 2, (int)w, CV_8UC1, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_YUV2RGB_I420);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_YVU420P: {\n            cv::Mat imgMat = cv::Mat((int)h + h / 2, (int)w, CV_8UC1, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_YUV2RGB_YV12);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_NV12: {\n            cv::Mat imgMat = cv::Mat((int)h + h / 2, (int)w, CV_8UC1, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_YUV2RGB_NV12);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_NV21: {\n            cv::Mat imgMat = cv::Mat((int)h + h / 2, (int)w, CV_8UC1, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_YUV2RGB_NV21);\n\n            success = true;\n        } break;\n\n        default:\n            success = false;\n            break;\n        }\n    }\n#endif\n\n    drifFreeImg(imgBytes);\n\n    return success;\n}\n\nvoid DkBasicLoader::setImage(const QImage &img, const QString &editName, const QString &file)\n{\n    mFile = file;\n    setEditImage(img, editName);\n}\n\nvoid DkBasicLoader::pruneEditHistory()\n{\n    // delete all hidden edit states\n    for (int idx = mImages.size() - 1; idx > mImageIndex; idx--) {\n        mImages.pop_back();\n    }\n}\n\nvoid DkBasicLoader::setEditImage(const QImage &img, const QString &editName)\n{\n    if (img.isNull())\n        return;\n\n    // delete all hidden edit states\n    pruneEditHistory();\n\n    // compute new history size\n    int historySize = 0;\n    for (const DkEditImage &e : mImages) {\n        historySize += e.size();\n    }\n\n    // reset exif orientation after image edit\n    if (!mImages.isEmpty())\n        mMetaData->clearOrientation();\n    // new history item with new pixmap (and old or original metadata)\n    DkEditImage newImg(img, mMetaData->copy(), editName); // new image, old/unchanged metadata\n\n    if (historySize + newImg.size() > DkSettingsManager::param().resources().historyMemory && mImages.size() > mMinHistorySize) {\n        mImages.removeAt(1);\n        qWarning() << \"removing history image because it's too large:\" << historySize + newImg.size() << \"MB\";\n    }\n\n    mImages.append(newImg);\n    mImageIndex = mImages.size() - 1; // set the index again to the last\n}\n\nvoid DkBasicLoader::setEditMetaData(const QSharedPointer<DkMetaDataT> &metaData, const QImage &img, const QString &editName)\n{\n    // delete all hidden edit states\n    pruneEditHistory();\n\n    // not removing second history item if oversized (see setEditImage())\n\n    // new history item with new metadata (and image, but hasNewImage() will be false)\n    DkEditImage newImg(metaData->copy(), img, editName); // new metadata, old/unchanged image\n\n    mImages.append(newImg);\n    mImageIndex = mImages.size() - 1; // set the index again to the last\n}\n\nvoid DkBasicLoader::setEditMetaData(const QSharedPointer<DkMetaDataT> &metaData, const QString &editName)\n{\n    // Add history edit with new metadata (hasMetaData()), copying last or original image\n    QImage lastImg = image(); // copy last edit of pixmap (if any) to new history item\n    setEditMetaData(metaData, lastImg, editName);\n}\n\nvoid DkBasicLoader::setEditMetaData(const QString &editName)\n{\n    // Add history edit with edited metadata (hasMetaData()), copying last or original image\n    setEditMetaData(mMetaData, image(), editName);\n}\n\nQImage DkBasicLoader::lastImage() const\n{\n    // Find and return the last/current version of the image (ready to be saved to disk)\n    // This is initially the first item (the original image) or the last one,\n    // excluding history items with images that only have modified metadata,\n    // for example, after rotating there'd be a history item with the rotated image\n    // but this rotated pixmap is for the gui only, it should not be saved.\n    for (int idx = mImageIndex; idx >= 0; idx--) {\n        if (mImages[idx].hasNewImage()) {\n            return mImages[idx].image();\n        }\n    }\n\n    return QImage();\n}\n\nQImage DkBasicLoader::pixmap() const\n{\n    // This is sometimes called with an invalid index, for example, after navigating back and forth\n    // if the history has been edited (i.e., > 1 entry). Sometimes, the index is -1 and the history is empty,\n    // which means we have nothing to return (image requested but nothing loaded). (via ViewPort?)\n    if (mImageIndex < 0 || mImageIndex >= mImages.size()) {\n        if (mImages.isEmpty())\n            return QImage();\n        else\n            return mImages.last().image();\n    }\n    // Return current pixmap, which may contain modification from metadata changes like rotation\n    // This should not be used to write the image to disk, use image() instead.\n    return mImages.at(mImageIndex).image();\n}\n\n/**\n * @brief Returns the pointer to the current metadata object which belongs to the loaded image.\n *\n * Note that this is a pointer, not a copy. After changing the metadata, it's necessary\n * to call setEditMetaData(), passing an appropriate edit name, to add a history item (will be copied).\n *\n * @return QSharedPointer<DkMetaDataT>\n */\nQSharedPointer<DkMetaDataT> DkBasicLoader::getMetaData() const\n{\n    QSharedPointer<DkMetaDataT> metaData(mMetaData);\n    return metaData;\n};\n\nQSharedPointer<DkMetaDataT> DkBasicLoader::lastMetaDataEdit(bool return_nullptr, bool return_orig) const\n{\n    QSharedPointer<DkMetaDataT> lastEdit; // null edit\n    if (return_orig) {\n        // Return original metadata only if requested (otherwise only return modified metadata)\n        lastEdit = mImages.first().metaData();\n    } else if (!return_nullptr) {\n        // Empty null object will be returned if no history item (with edited metadata) could be found\n        lastEdit = QSharedPointer<DkMetaDataT>(new DkMetaDataT());\n    }\n\n    // Get latest modified metadata item from history (or null)\n    for (int idx = mImageIndex; idx > 0; idx--) {\n        if (mImages[idx].hasNewMetaData()) {\n            lastEdit = mImages[idx].metaData();\n            break;\n        }\n    }\n\n    return lastEdit;\n}\n\nbool DkBasicLoader::isImageEdited()\n{\n    for (int i = 1, ii = mImageIndex; i <= ii; i++) {\n        if (mImages[i].hasNewImage()) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool DkBasicLoader::isMetaDataEdited()\n{\n    for (int i = 1, ii = mImageIndex; i <= ii; i++) {\n        if (mImages[i].hasNewMetaData()) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid DkBasicLoader::undo()\n{\n    // Change history index (for image()...)\n    if (mImageIndex > 0)\n        mImageIndex--;\n\n    // Get last history item with modified metadata (up until new history index)\n    QSharedPointer<DkMetaDataT> metaData(mMetaData);\n    metaData = lastMetaDataEdit(false, true);\n    // Update our current metadata object, which is also used elsewhere (pointer)\n    // for example, see DkMetaDataWidgets/DkMetaDataHUD - or DkCommentWidget\n    mMetaData->update(metaData);\n\n    // Notify listeners about changed metadata\n    emit undoSignal();\n    emit resetMetaDataSignal();\n}\n\nvoid DkBasicLoader::redo()\n{\n    // Change history index (for image()...)\n    if (mImageIndex < mImages.size() - 1)\n        mImageIndex++;\n\n    // Get last history item with modified metadata (up until new history index)\n    QSharedPointer<DkMetaDataT> metaData(mMetaData);\n    metaData = lastMetaDataEdit(false, true);\n    // Update our current metadata object, which is also used elsewhere (pointer)\n    // for example, see DkMetaDataWidgets/DkMetaDataHUD - or DkCommentWidget\n    mMetaData->update(metaData);\n\n    // Notify listeners about changed metadata\n    emit redoSignal();\n    emit resetMetaDataSignal();\n}\n\nQVector<DkEditImage> *DkBasicLoader::history()\n{\n    return &mImages;\n}\n\nDkEditImage DkBasicLoader::lastEdit() const\n{\n    assert(mImageIndex >= 0 && mImageIndex < mImages.size());\n    return mImages[mImageIndex];\n}\n\nint DkBasicLoader::historyIndex() const\n{\n    return mImageIndex;\n}\n\nvoid DkBasicLoader::setMinHistorySize(int size)\n{\n    mMinHistorySize = size;\n}\n\nvoid DkBasicLoader::setHistoryIndex(int idx)\n{\n    mImageIndex = idx;\n    // TODO update mMetaData, see undo()\n}\n\n// QByteArray DkBasicLoader::loadFileToBuffer(const QString &filePath) const\n// {\n//     QFileInfo fi(filePath);\n\n//     if (!fi.exists())\n//         return;\n\n// #ifdef WITH_QUAZIP\n//     if (fi.dir().path().contains(DkZipContainer::zipMarker()))\n//         DkZipContainer::extractImage(DkZipContainer::decodeZipFile(filePath), DkZipContainer::decodeImageFile(filePath), ba);\n// #endif\n\n//     QFile file(filePath);\n//     file.open(QIODevice::ReadOnly);\n\n//     ba = file.readAll();\n// }\n\nQSharedPointer<QByteArray> DkBasicLoader::loadFileToBuffer(const QString &filePath) const\n{\n    QFileInfo fi(filePath);\n\n#ifdef WITH_QUAZIP\n    if (fi.dir().path().contains(DkZipContainer::zipMarker()))\n        return DkZipContainer::extractImage(DkZipContainer::decodeZipFile(filePath), DkZipContainer::decodeImageFile(filePath));\n#endif\n\n    QFile file(filePath);\n    file.open(QIODevice::ReadOnly);\n\n    QSharedPointer<QByteArray> ba(new QByteArray(file.readAll()));\n    file.close();\n\n    return ba;\n}\n\n/**\n * @brief writeBufferToFile() writes the passed in file buffer to the specified file.\n *\n * It's called by the save() routine, which saves the image to that file buffer\n * and updates that file buffer to also contain exif data.\n *\n * @param fileInfo path to file to be written\n * @param ba raw content to be written to file\n */\nbool DkBasicLoader::writeBufferToFile(const QString &fileInfo, const QSharedPointer<QByteArray> ba) const\n{\n    if (!ba || ba->isEmpty())\n        return false;\n\n    QFile file(fileInfo);\n    file.open(QIODevice::WriteOnly);\n    qint64 bytesWritten = file.write(*ba.data(), ba->size());\n    file.close();\n    qDebug() << \"[DkBasicLoader] buffer saved, bytes written: \" << bytesWritten;\n\n    if (!bytesWritten || bytesWritten == -1)\n        return false;\n\n    return true;\n}\n\nvoid DkBasicLoader::indexPages(const QString &filePath, const QSharedPointer<QByteArray> ba)\n{\n    // reset counters\n    mNumPages = 1;\n    mPageIdx = 1;\n\n#ifdef WITH_LIBTIFF\n\n    QFileInfo fInfo(filePath);\n\n    // for now we just support tiff's\n    if (!fInfo.suffix().contains(QRegularExpression(\"(tif|tiff)\", QRegularExpression::CaseInsensitiveOption)))\n        return;\n\n    // first turn off nasty warning/error dialogs - (we do the GUI : )\n    TIFFErrorHandler oldErrorHandler, oldWarningHandler;\n    oldWarningHandler = TIFFSetWarningHandler(NULL);\n    oldErrorHandler = TIFFSetErrorHandler(NULL);\n\n    DkTimer dt;\n    TIFF *tiff = 0;\n\n#if defined(Q_OS_WIN)\n    std::istringstream is(ba ? ba->toStdString() : \"\");\n\n    if (ba)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &is);\n\n    // read from file\n    if (!tiff)\n        tiff = TIFFOpen(filePath.toLatin1(), \"r\"); // this->mFile was here before - not sure why\n\n    // loading from buffer allows us to load files with non-latin names\n    QSharedPointer<QByteArray> bal;\n    if (!tiff)\n        bal = loadFileToBuffer(filePath);\n    ;\n    std::istringstream isl(bal ? bal->toStdString() : \"\");\n\n    if (bal)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &isl);\n#else\n    // read from file\n    tiff = TIFFOpen(filePath.toLatin1(), \"r\"); // this->mFile was here before - not sure why\n#endif\n\n    if (!tiff)\n        return;\n\n    // libtiff example\n    int dircount = 0;\n\n    do {\n        dircount++;\n\n    } while (TIFFReadDirectory(tiff));\n\n    mNumPages = dircount;\n\n    if (mNumPages > 1)\n        mPageIdx = 1;\n\n    qDebug() << dircount << \" TIFF directories... \" << dt;\n    TIFFClose(tiff);\n\n    TIFFSetWarningHandler(oldWarningHandler);\n    TIFFSetWarningHandler(oldErrorHandler);\n#else\n    Q_UNUSED(filePath);\n#endif\n}\n\nbool DkBasicLoader::loadPage(int skipIdx)\n{\n    bool imgLoaded = false;\n\n    mPageIdx += skipIdx;\n\n    // <= 1 since first page is loaded using qt\n    if (mPageIdx > mNumPages || mPageIdx <= 1)\n        return imgLoaded;\n\n    return loadPageAt(mPageIdx);\n}\n\nbool DkBasicLoader::loadPageAt(int pageIdx)\n{\n    bool imgLoaded = false;\n\n#ifdef WITH_LIBTIFF\n\n    // <= 1 since first page is loaded using qt\n    if (pageIdx > mNumPages || pageIdx < 1)\n        return imgLoaded;\n\n    // first turn off nasty warning/error dialogs - (we do the GUI : )\n    TIFFErrorHandler oldErrorHandler, oldWarningHandler;\n    oldWarningHandler = TIFFSetWarningHandler(NULL);\n    oldErrorHandler = TIFFSetErrorHandler(NULL);\n\n    DkTimer dt;\n    TIFF *tiff = TIFFOpen(mFile.toLatin1(), \"r\");\n\n#if defined(Q_OS_WIN)\n\n    // loading from buffer allows us to load files with non-latin names\n    QSharedPointer<QByteArray> ba;\n    if (!tiff)\n        ba = loadFileToBuffer(mFile);\n\n    std::istringstream is(ba ? ba->toStdString() : \"\");\n    if (ba)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &is);\n#endif\n\n    if (!tiff)\n        return imgLoaded;\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n\n    // go to current directory\n    for (int idx = 1; idx < pageIdx; idx++) {\n        if (!TIFFReadDirectory(tiff))\n            return false;\n    }\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n\n    // init the qImage\n    QImage img = QImage(width, height, QImage::Format_ARGB32);\n\n    const int stopOnError = 1;\n    imgLoaded = TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32_t *>(img.bits()), ORIENTATION_TOPLEFT, stopOnError) != 0;\n\n    if (imgLoaded) {\n        for (uint32_t y = 0; y < height; ++y)\n            convert32BitOrder(img.scanLine(y), width);\n    }\n\n    TIFFClose(tiff);\n\n    TIFFSetWarningHandler(oldWarningHandler);\n    TIFFSetWarningHandler(oldErrorHandler);\n\n    setEditImage(img, tr(\"Original Image\"));\n#else\n    Q_UNUSED(pageIdx);\n#endif\n\n    return imgLoaded;\n}\n\nbool DkBasicLoader::setPageIdx(int skipIdx)\n{\n    // do nothing if we don't have tiff pages\n    if (mNumPages <= 1)\n        return false;\n\n    mPageIdxDirty = false;\n\n    int newPageIdx = mPageIdx + skipIdx;\n\n    if (newPageIdx > 0 && newPageIdx <= mNumPages) {\n        mPageIdxDirty = true;\n        mPageIdx = newPageIdx;\n    }\n\n    return mPageIdxDirty;\n}\n\nvoid DkBasicLoader::resetPageIdx()\n{\n    mPageIdxDirty = false;\n    mPageIdx = 1;\n}\n\nvoid DkBasicLoader::convert32BitOrder(void *buffer, int width) const\n{\n#ifdef WITH_LIBTIFF\n    // code from Qt QTiffHandler\n    uint32_t *target = reinterpret_cast<uint32_t *>(buffer);\n    for (uint32_t x = 0; x < width; ++x) {\n        uint32_t p = target[x];\n        // convert between ARGB and ABGR\n        target[x] = (p & 0xff000000) | ((p & 0x00ff0000) >> 16) | (p & 0x0000ff00) | ((p & 0x000000ff) << 16);\n    }\n#else\n    Q_UNUSED(buffer);\n    Q_UNUSED(width);\n#endif\n}\n\n/**\n * @brief saves the image and its metadata to the specified file.\n *\n * It writes the image to a file buffer and then writes that buffer back to the original file.\n * Modified metadata is saved afterwards.\n *\n * @param filePath target path to image file\n * @param img source image to be written to file (may be converted along the way)\n * @param compression compression flag for QImageWriter\n */\nQString DkBasicLoader::save(const QString &filePath, const QImage &img, int compression)\n{\n    QSharedPointer<QByteArray> ba;\n\n    DkTimer dt;\n    if (saveToBuffer(filePath, img, ba, compression) && ba) {\n        if (writeBufferToFile(filePath, ba)) {\n            qInfo() << \"saved to\" << filePath << \"in\" << dt;\n            return filePath;\n        }\n    }\n\n    return QString();\n}\n\n/**\n * @brief saveToBuffer() writes the image matrix img to the file buffer.\n *\n * The file path is used to convert the image based on the file suffix.\n *\n * @param filePath path to file to which this image will later be written, the suffix is relevant\n * @param img image to be written to file buffer\n * @param ba in-memory file buffer containing resulting file\n * @param compression compression flag for QImageWriter\n */\nbool DkBasicLoader::saveToBuffer(const QString &filePath, const QImage &img, QSharedPointer<QByteArray> &ba, int compression) const\n{\n    bool bufferCreated = false;\n\n    if (!ba) {\n        ba = QSharedPointer<QByteArray>(new QByteArray());\n        bufferCreated = true;\n    }\n    // copy current metadata object: mMetaData pointer may be reset in the background in the process\n    // and then it won't be saved because !isLoaded()... [2022-08, pse]\n    QSharedPointer<DkMetaDataT> metaData = mMetaData;\n\n    bool saved = false;\n\n    QFileInfo fInfo(filePath);\n\n#ifdef Q_OS_WIN\n    if (0 == fInfo.suffix().compare(\"ico\", Qt::CaseInsensitive)) {\n        saved = saveWindowsIcon(img, ba);\n    } else\n#endif\n    {\n        bool hasAlpha = DkImage::alphaChannelUsed(img);\n\n        QImage sImg = img;\n\n        // JPEG 2000 can only handle 32 or 8bit images\n        if (!hasAlpha && img.colorTable().empty() && !fInfo.suffix().contains(QRegularExpression(\"(avif|j2k|jp2|jpf|jpx|jxl|png)\"))) {\n            sImg = sImg.convertToFormat(QImage::Format_RGB888);\n        } else if (fInfo.suffix().contains(QRegularExpression(\"(j2k|jp2|jpf|jpx)\")) && sImg.depth() != 32 && sImg.depth() != 8) {\n            if (sImg.hasAlphaChannel()) {\n                sImg = sImg.convertToFormat(QImage::Format_ARGB32);\n            } else {\n                sImg = sImg.convertToFormat(QImage::Format_RGB32);\n            }\n        }\n\n        if (fInfo.suffix().contains(QRegularExpression(\"(png)\")))\n            compression = -1;\n\n        QBuffer fileBuffer(ba.data());\n        // size_t s = fileBuffer.size();\n        fileBuffer.open(QIODevice::WriteOnly);\n        QImageWriter *imgWriter = new QImageWriter(&fileBuffer, fInfo.suffix().toStdString().c_str());\n\n        if (compression >= 0) { // -1 -> use Qt's default\n            imgWriter->setCompression(compression);\n            imgWriter->setQuality(compression);\n        }\n        if (compression == -1 && imgWriter->format() == \"jpg\") {\n            imgWriter->setQuality(DkSettingsManager::instance().settings().app().defaultJpgQuality);\n        }\n\n        imgWriter->setOptimizedWrite(true); // this saves space TODO: user option here?\n        imgWriter->setProgressiveScanWrite(true);\n\n        saved = imgWriter->write(sImg); // hint: release() might run now, resetting mMetaData which is used below [2022-08, pse]\n        delete imgWriter;\n    }\n\n    if (saved && metaData) {\n        if (!metaData->isLoaded() || !metaData->hasMetaData()) {\n            if (!bufferCreated)\n                metaData->readMetaData(filePath, ba);\n            else\n                // if we created the buffere here - force loading metadata from the file\n                metaData->readMetaData(filePath);\n        }\n\n        // If we have metadata for the image, save it\n        // If your images are saved without metadata, check if the metadata object is discarded or reset\n        // causing isLoaded() to return false (glitch on reload) - pse\n        if (metaData->isLoaded()) {\n            try {\n                // be careful: here we actually lie about the constness\n                metaData->updateImageMetaData(img, false); // set dimensions in exif (do not reset exif orientation)\n                if (!metaData->saveMetaData(ba, true))\n                    metaData->clearExifState();\n            } catch (...) {\n                // is it still throwing anything?\n                qInfo() << \"Sorry, I could not save the meta data...\";\n                // clear exif state here -> the 'dirty' flag would otherwise edit the original image (see #514)\n                metaData->clearExifState();\n            }\n        }\n    }\n\n    if (!saved)\n        emit errorDialogSignal(tr(\"Sorry, I could not save: %1\").arg(fInfo.fileName()));\n\n    return saved;\n}\n\nvoid DkBasicLoader::saveThumbToMetaData(const QString &filePath)\n{\n    QSharedPointer<QByteArray> ba; // dummy\n    saveThumbToMetaData(filePath, ba);\n}\n\nvoid DkBasicLoader::saveThumbToMetaData(const QString &filePath, QSharedPointer<QByteArray> &ba)\n{\n    if (!hasImage())\n        return;\n\n    mMetaData->setThumbnail(DkImage::createThumb(image()));\n    saveMetaData(filePath, ba);\n}\n\n/**\n * @brief this will write the current exif/metadata to the loaded file.\n *\n * It calls the other overload passing an empty buffer,\n * so it'll load the buffer, save the exif data to the buffer\n * and write the buffer back to the file.\n *\n * @param filePath path to current file to be updated\n */\nvoid DkBasicLoader::saveMetaData(const QString &filePath)\n{\n    QSharedPointer<QByteArray> ba; // dummy\n    saveMetaData(filePath, ba);\n}\n\n/**\n * @brief writes metadata to the file on disk, if it's marked as dirty\n *\n * This routine will write new metadata to the file on disk if metadata is marked dirty.\n * It does this by first loading the file into a buffer (unless a non-empty buffer is passed),\n * then it calls the MetaData module to save the exif data to that buffer\n * and finally, it writes the modified buffer to the file on disk.\n * The MetaData module has an overload which does basically the same thing.\n *\n * See ImageLoader (regular workflow starts there) and ImageContainer.\n *\n * @param filePath path to image file\n * @param ba file buffer to be saved (leave empty to work on the specified file as it is on disk)\n */\nvoid DkBasicLoader::saveMetaData(const QString &filePath, QSharedPointer<QByteArray> &ba)\n{\n    if (!ba)\n        ba = QSharedPointer<QByteArray>(new QByteArray());\n\n    if (ba->isEmpty() && mMetaData->isDirty()) {\n        ba = loadFileToBuffer(filePath);\n    }\n\n    // Update in-memory copy of file (ba) with new meta data\n    bool saved = false;\n    try {\n        saved = mMetaData->saveMetaData(ba);\n    } catch (...) {\n        qInfo() << \"could not save metadata...\";\n    }\n\n    // Write in-memory copy to specified file - use this overload only if you really need it\n    if (saved)\n        writeBufferToFile(filePath, ba);\n}\n\nbool DkBasicLoader::isContainer(const QString &filePath)\n{\n    QFileInfo fInfo(filePath);\n    if (!fInfo.isFile() || !fInfo.exists())\n        return false;\n\n    QString suffix = fInfo.suffix();\n\n    if (suffix.isEmpty())\n        return false;\n\n    for (int idx = 0; idx < DkSettingsManager::param().app().containerFilters.size(); idx++) {\n        if (DkSettingsManager::param().app().containerFilters[idx].contains(suffix))\n            return true;\n    }\n\n    return false;\n}\n\n/**\n * @brief releases the currently loaded images.\n *\n * Clears the history.\n * Called by loadGeneral() and ImageContainer::clear().\n *\n * @note This will *not* silently auto-save your beautiful images.\n * It was apparently intended to be used that way (it called saveMetaData(), like ~DkImageContainerT()).\n * All changes should be explicitly committed, including exif notes.\n * If you think this is wrong, a comment would be appreciated. See issue #799. PSE, 2022.\n *\n **/\nvoid DkBasicLoader::release()\n{\n    // TODO: auto save routines here?\n    // answer: no.\n\n    mImages.clear(); // clear history\n    mImageIndex = -1;\n\n    // Unload metadata\n    mMetaData = QSharedPointer<DkMetaDataT>(new DkMetaDataT());\n}\n\n#ifdef Q_OS_WIN\n// bool DkBasicLoader::saveWindowsIcon(const QString &filePath, const QImage &img) const\n// {\n//     QSharedPointer<QByteArray> ba;\n\n//     if (saveWindowsIcon(img, ba) && ba && !ba->isEmpty()) {\n//         writeBufferToFile(filePath, ba);\n//         return true;\n//     }\n\n//     return false;\n// }\n\nstruct ICONDIRENTRY {\n    UCHAR nWidth;\n    UCHAR nHeight;\n    UCHAR nNumColorsInPalette; // 0 if no palette\n    UCHAR nReserved; // should be 0\n    WORD nNumColorPlanes; // 0 or 1\n    WORD nBitsPerPixel;\n    ULONG nDataLength; // length in bytes\n    ULONG nOffset; // offset of BMP or PNG data from beginning of file\n};\n\nbool DkBasicLoader::saveWindowsIcon(const QImage &img, QSharedPointer<QByteArray> &ba) const\n{\n    // this code is an adopted version of:\n    // http://stackoverflow.com/questions/2289894/how-can-i-save-hicon-to-an-ico-file\n\n    if (!ba)\n        ba = QSharedPointer<QByteArray>(new QByteArray());\n\n#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)\n    HICON hIcon = QtWin::toHICON(QPixmap::fromImage(img));\n#else\n    HICON hIcon = img.toHICON();\n#endif\n    int nColorBits = 32;\n\n    QBuffer buffer(ba.data());\n    buffer.open(QIODevice::WriteOnly);\n\n    if (!hIcon)\n        return false;\n\n    HDC screenDevice = GetDC(0);\n\n    // Write header:\n    UCHAR icoHeader[6] = {0, 0, 1, 0, 1, 0}; // ICO file with 1 image\n    buffer.write((const char *)(&icoHeader), sizeof(icoHeader));\n\n    // Get information about icon:\n    ICONINFO iconInfo;\n    GetIconInfo(hIcon, &iconInfo);\n    HGDIOBJ handle1(iconInfo.hbmColor); // free bitmaps when function ends\n    BITMAPINFO bmInfo = {0};\n    bmInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);\n    bmInfo.bmiHeader.biBitCount = 0; // don't get the color table\n    if (!GetDIBits(screenDevice, iconInfo.hbmColor, 0, 0, NULL, &bmInfo, DIB_RGB_COLORS)) {\n        return false;\n    }\n\n    // Allocate size of bitmap info header plus space for color table:\n    int nBmInfoSize = sizeof(BITMAPINFOHEADER);\n    if (nColorBits < 24) {\n        nBmInfoSize += sizeof(RGBQUAD) * (int)(1 << nColorBits);\n    }\n\n    QSharedPointer<UCHAR> bitmapInfo(new UCHAR[nBmInfoSize]);\n    BITMAPINFO *pBmInfo = (BITMAPINFO *)bitmapInfo.data();\n    memcpy(pBmInfo, &bmInfo, sizeof(BITMAPINFOHEADER));\n\n    // Get bitmap data:\n    QSharedPointer<UCHAR> bits(new UCHAR[bmInfo.bmiHeader.biSizeImage]);\n    pBmInfo->bmiHeader.biBitCount = (WORD)nColorBits;\n    pBmInfo->bmiHeader.biCompression = BI_RGB;\n    if (!GetDIBits(screenDevice, iconInfo.hbmColor, 0, bmInfo.bmiHeader.biHeight, bits.data(), pBmInfo, DIB_RGB_COLORS)) {\n        return false;\n    }\n\n    // Get mask data:\n    BITMAPINFO maskInfo = {0};\n    maskInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);\n    maskInfo.bmiHeader.biBitCount = 0; // don't get the color table\n    if (!GetDIBits(screenDevice, iconInfo.hbmMask, 0, 0, NULL, &maskInfo, DIB_RGB_COLORS)) {\n        return false;\n    }\n\n    QSharedPointer<UCHAR> maskBits(new UCHAR[maskInfo.bmiHeader.biSizeImage]);\n    QSharedPointer<UCHAR> maskInfoBytes(new UCHAR[sizeof(BITMAPINFO) + 2 * sizeof(RGBQUAD)]);\n    BITMAPINFO *pMaskInfo = (BITMAPINFO *)maskInfoBytes.data();\n    memcpy(pMaskInfo, &maskInfo, sizeof(maskInfo));\n    if (!GetDIBits(screenDevice, iconInfo.hbmMask, 0, maskInfo.bmiHeader.biHeight, maskBits.data(), pMaskInfo, DIB_RGB_COLORS)) {\n        return false;\n    }\n\n    // Write directory entry:\n    ICONDIRENTRY dir;\n    dir.nWidth = (UCHAR)pBmInfo->bmiHeader.biWidth;\n    dir.nHeight = (UCHAR)pBmInfo->bmiHeader.biHeight;\n    dir.nNumColorsInPalette = (nColorBits == 4 ? 16 : 0);\n    dir.nReserved = 0;\n    dir.nNumColorPlanes = 0;\n    dir.nBitsPerPixel = pBmInfo->bmiHeader.biBitCount;\n    dir.nDataLength = pBmInfo->bmiHeader.biSizeImage + pMaskInfo->bmiHeader.biSizeImage + nBmInfoSize;\n    dir.nOffset = sizeof(dir) + sizeof(icoHeader);\n    buffer.write((const char *)&dir, sizeof(dir));\n\n    // Write DIB header (including color table):\n    int nBitsSize = pBmInfo->bmiHeader.biSizeImage;\n    pBmInfo->bmiHeader.biHeight *= 2; // because the header is for both image and mask\n    pBmInfo->bmiHeader.biCompression = 0;\n    pBmInfo->bmiHeader.biSizeImage += pMaskInfo->bmiHeader.biSizeImage; // because the header is for both image and mask\n    buffer.write((const char *)&pBmInfo->bmiHeader, nBmInfoSize);\n\n    // Write image data:\n    buffer.write((const char *)bits.data(), nBitsSize);\n\n    // Write mask data:\n    buffer.write((const char *)maskBits.data(), pMaskInfo->bmiHeader.biSizeImage);\n\n    buffer.close();\n\n    DeleteObject(handle1);\n\n    return true;\n}\n\n#endif // #ifdef Q_OS_WIN\n\n#ifdef WITH_OPENCV\n\n// cv::Mat DkBasicLoader::getImageCv()\n// {\n//     return cv::Mat();\n// }\n\nbool DkBasicLoader::loadOpenCVVecFile(const QString &filePath, QImage &img, QSharedPointer<QByteArray> ba, QSize s) const\n{\n    if (!ba)\n        ba = QSharedPointer<QByteArray>(new QByteArray());\n\n    // load from file?\n    if (ba->isEmpty())\n        ba = loadFileToBuffer(filePath);\n\n    if (ba->isEmpty())\n        return false;\n\n    // read header & get a pointer to the first image\n    int fileCount, vecSize;\n    const unsigned char *imgPtr = (const unsigned char *)ba->constData();\n    if (!readHeader(&imgPtr, fileCount, vecSize))\n        return false;\n\n    int guessedW = 0;\n    int guessedH = 0;\n\n    getPatchSizeFromFileName(QFileInfo(filePath).fileName(), guessedW, guessedH);\n\n    qDebug() << \"patch size from filename: \" << guessedW << \" x \" << guessedH;\n\n    if (vecSize > 0 && !guessedH && !guessedW) {\n        guessedW = qFloor(sqrt((float)vecSize));\n        if (guessedW > 0)\n            guessedH = vecSize / guessedW;\n    }\n\n    if (guessedW <= 0 || guessedH <= 0 || guessedW * guessedH != vecSize) {\n        // TODO: ask user\n        qDebug() << \"dimensions do not match, patch size: \" << guessedW << \" x \" << guessedH << \" vecSize: \" << vecSize;\n        return false;\n    }\n\n    int fSize = ba->size();\n    int numElements = 0;\n\n    // guess size\n    if (s.isEmpty()) {\n        double nEl = (fSize - 64) / (vecSize * 2);\n        nEl = (fSize - 64 - qCeil(nEl)) / (vecSize * 2) + 1; // opencv adds one byte per image - so we take care for this here\n\n        if (qFloor(nEl) != qCeil(nEl))\n            return false;\n        numElements = qRound(nEl);\n    }\n\n    double nRowsCols = sqrt(numElements);\n    int numCols = qCeil(nRowsCols);\n    int minusOneRow = (qFloor(nRowsCols) != qCeil(nRowsCols) && nRowsCols - qFloor(nRowsCols) < 0.5) ? 1 : 0;\n\n    cv::Mat allPatches((numCols - minusOneRow) * guessedH, numCols * guessedW, CV_8UC1, cv::Scalar(125));\n\n    for (int idx = 0; idx < numElements; idx++) {\n        if (*imgPtr != 0) {\n            qDebug() << \"skipping non-empty byte - there is something seriously wrong here!\";\n            // return false;\t// stop if the byte is non-empty -> otherwise we might read wrong memory\n        }\n\n        imgPtr++; // there is an empty byte between images\n        cv::Mat cPatch = getPatch(&imgPtr, QSize(guessedW, guessedH));\n        cv::Mat cPatchAll = allPatches(cv::Rect(idx % numCols * guessedW, qFloor(idx / numCols) * guessedH, guessedW, guessedH));\n\n        if (!cPatchAll.empty())\n            cPatch.copyTo(cPatchAll);\n    }\n\n    img = DkImage::mat2QImage(allPatches);\n    img = img.convertToFormat(QImage::Format_ARGB32);\n\n    // setEditImage(img, tr(\"Original Image\"));\n\n    return true;\n}\n\nvoid DkBasicLoader::getPatchSizeFromFileName(const QString &fileName, int &width, int &height) const\n{\n    // parse patch size from file\n    QStringList sections = fileName.split(QRegularExpression(\"[-\\\\.]\"));\n\n    for (int idx = 0; idx < sections.size(); idx++) {\n        QString tmpSec = sections[idx];\n        qDebug() << \"section: \" << tmpSec;\n\n        if (tmpSec.contains(\"w\"))\n            width = tmpSec.remove(\"w\").toInt();\n        else if (tmpSec.contains(\"h\"))\n            height = tmpSec.remove(\"h\").toInt();\n    }\n}\n\nbool DkBasicLoader::readHeader(const unsigned char **dataPtr, int &fileCount, int &vecSize) const\n{\n    const int *pData = (const int *)*dataPtr;\n    fileCount = *pData;\n    pData++; // read file count\n    vecSize = *pData; // read vec size\n\n    qDebug() << \"vec size: \" << vecSize << \" fileCount \" << fileCount;\n\n    *dataPtr += 12; // skip the first 12 (header) bytes\n\n    return true;\n}\n\n// the double pointer is here needed to additionally increase the pointer value\ncv::Mat DkBasicLoader::getPatch(const unsigned char **dataPtr, QSize patchSize) const\n{\n    cv::Mat img8U(patchSize.height(), patchSize.width(), CV_8UC1, cv::Scalar(0));\n\n    // ok, take just the second byte\n    for (int rIdx = 0; rIdx < img8U.rows; rIdx++) {\n        unsigned char *ptr8U = img8U.ptr<unsigned char>(rIdx);\n\n        for (int cIdx = 0; cIdx < img8U.cols; cIdx++) {\n            ptr8U[cIdx] = **dataPtr;\n            *dataPtr += 2; // it is strange: opencv stores vec files as 16 bit but just use the 2nd byte\n        }\n    }\n\n    return img8U;\n}\n\nint DkBasicLoader::mergeVecFiles(const QStringList &vecFilePaths, QString &saveFilePath) const\n{\n    int lastVecSize = 0;\n    int totalFileCount = 0;\n    int vecCount = 0;\n    int pWidth = 0, pHeight = 0;\n    QByteArray vecBuffer;\n\n    for (const QString &filePath : vecFilePaths) {\n        QFileInfo fInfo(filePath);\n        QSharedPointer<QByteArray> ba = loadFileToBuffer(filePath);\n        if (ba->isEmpty()) {\n            qDebug() << \"could not load: \" << fInfo.fileName();\n            continue;\n        }\n\n        int fileCount, vecSize;\n        const unsigned char *dataPtr = (const unsigned char *)ba->constData();\n        if (!readHeader(&dataPtr, fileCount, vecSize)) {\n            qDebug() << \"could not read header, skipping: \" << fInfo.fileName();\n            continue;\n        }\n\n        if (lastVecSize && vecSize != lastVecSize) {\n            qDebug() << \"wrong vec size, skipping: \" << fInfo.fileName();\n            continue;\n        }\n\n        vecBuffer.append((const char *)dataPtr, vecSize * fileCount * 2 + fileCount); // +fileCount accounts for the '\\0' bytes between the patches\n\n        getPatchSizeFromFileName(fInfo.fileName(), pWidth, pHeight);\n\n        totalFileCount += fileCount;\n        lastVecSize = vecSize;\n\n        vecCount++;\n    }\n\n    // don't save if we could not merge the files\n    if (!vecCount)\n        return vecCount;\n\n    unsigned int *header = new unsigned int[3];\n    header[0] = totalFileCount;\n    header[1] = lastVecSize;\n    header[2] = 0;\n\n    vecBuffer.prepend((const char *)header, 3 * sizeof(int));\n\n    QFileInfo saveFileInfo(saveFilePath);\n\n    // append width, height if we don't know\n    if (pWidth && pHeight) {\n        QString whString = \"-w\" + QString::number(pWidth) + \"-h\" + QString::number(pHeight);\n        saveFileInfo = QFileInfo(saveFileInfo.absolutePath(), saveFileInfo.baseName() + whString + \".\" + saveFileInfo.suffix());\n    }\n\n    QFile file(saveFileInfo.absoluteFilePath());\n    file.open(QIODevice::WriteOnly);\n    file.write(vecBuffer);\n    file.close();\n\n    return vecCount;\n}\n\n#endif // #ifdef WITH_OPENCV\n\n// FileDownloader --------------------------------------------------------------------\nFileDownloader::FileDownloader(const QUrl &imageUrl, const QString &filePath, QObject *parent)\n    : QObject(parent)\n{\n    mFilePath = filePath;\n\n    QNetworkProxyQuery npq(QUrl(\"https://google.com\"));\n    QList<QNetworkProxy> listOfProxies = QNetworkProxyFactory::systemProxyForQuery(npq);\n    if (!listOfProxies.empty() && listOfProxies[0].hostName() != \"\") {\n        mWebCtrl.setProxy(listOfProxies[0]);\n    }\n\n    connect(&mWebCtrl, &QNetworkAccessManager::finished, this, &FileDownloader::fileDownloaded);\n\n    downloadFile(imageUrl);\n}\n\nFileDownloader::~FileDownloader()\n{\n}\n\nvoid FileDownloader::downloadFile(const QUrl &url)\n{\n    QNetworkRequest request(url);\n    mWebCtrl.get(request);\n    mUrl = url;\n}\n\nvoid FileDownloader::saved()\n{\n    if (mSaveWatcher.result()) {\n        qInfo() << \"downloaded image saved to\" << mFilePath;\n        emit downloaded(mFilePath);\n    } else {\n        qWarning() << \"could not download file to \" << mFilePath;\n    }\n}\n\nbool FileDownloader::save(const QString &filePath, const QSharedPointer<QByteArray> data)\n{\n    if (!data) {\n        qWarning() << \"cannot save file if data is NULL\";\n        return false;\n    }\n\n    QFileInfo fi(filePath);\n\n    if (!fi.absoluteDir().exists())\n        QDir().mkpath(fi.absolutePath());\n\n    QFile f(filePath);\n    f.open(QIODevice::WriteOnly);\n\n    return f.write(*data);\n}\n\nvoid FileDownloader::fileDownloaded(QNetworkReply *pReply)\n{\n    if (pReply->error() != QNetworkReply::NoError) {\n        qWarning() << \"I could not download: \" << mUrl;\n        qWarning() << pReply->errorString();\n    }\n\n    mDownloadedData = QSharedPointer<QByteArray>(new QByteArray(pReply->readAll()));\n    // emit a signal\n    pReply->deleteLater();\n\n    // data only requested\n    if (mFilePath.isEmpty()) {\n        emit downloaded();\n    }\n    // ok save it\n    else {\n        connect(&mSaveWatcher, &QFutureWatcherBase::finished, this, &FileDownloader::saved, Qt::UniqueConnection);\n        mSaveWatcher.setFuture(QtConcurrent::run([&] {\n            return save(mFilePath, mDownloadedData);\n        }));\n    }\n}\n\nQSharedPointer<QByteArray> FileDownloader::downloadedData() const\n{\n    return mDownloadedData;\n}\n\nQUrl FileDownloader::getUrl() const\n{\n    return mUrl;\n}\n\n#ifdef WITH_QUAZIP\n\n// DkZipContainer --------------------------------------------------------------------\nDkZipContainer::DkZipContainer(const QString &encodedFilePath)\n{\n    if (!encodedFilePath.isEmpty() && encodedFilePath.contains(mZipMarker)) {\n        mImageInZip = true;\n        mEncodedFilePath = encodedFilePath;\n        mZipFilePath = decodeZipFile(encodedFilePath);\n        mImageFileName = decodeImageFile(encodedFilePath);\n    } else\n        mImageInZip = false;\n}\n\nQString DkZipContainer::encodeZipFile(const QString &zipFile, const QString &imageFile)\n{\n    // if you think this code is unreadable, take a look at the old line:\n    // return QFileInfo(QDir(zipFile.absoluteFilePath() + mZipMarker + imageFile.left(imageFile.lastIndexOf(\"/\") + 1).replace(\"/\",\n    // mZipMarker)),(imageFile.lastIndexOf(\"/\") < 0) ? imageFile : imageFile.right(imageFile.size() - imageFile.lastIndexOf(\"/\") - 1));\n\n    QDir dir = QDir(zipFile + mZipMarker + imageFile.left(imageFile.lastIndexOf(\"/\") + 1).replace(\"/\", mZipMarker));\n    QString fileName = (imageFile.lastIndexOf(\"/\") < 0) ? imageFile : imageFile.right(imageFile.size() - imageFile.lastIndexOf(\"/\") - 1);\n\n    return QFileInfo(dir, fileName).absoluteFilePath();\n}\n\nQString DkZipContainer::decodeZipFile(const QString &encodedFileInfo)\n{\n    QString encodedDir = QFileInfo(encodedFileInfo).absolutePath();\n\n    return encodedDir.left(encodedDir.indexOf(mZipMarker));\n}\n\nQString DkZipContainer::decodeImageFile(const QString &encodedFileInfo)\n{\n    // get relative zip path\n    QString tmp = encodedFileInfo.right(encodedFileInfo.size() - encodedFileInfo.indexOf(mZipMarker) - QString(mZipMarker).size());\n    tmp = tmp.replace(mZipMarker, \"/\");\n    tmp = tmp.replace(\"//\", \"/\");\n\n    // diem: this fixes an issue with images that are in a zip's root folder\n    if (tmp.startsWith(\"/\"))\n        tmp = tmp.right(tmp.length() - 1);\n\n    return tmp;\n}\n\nQSharedPointer<QByteArray> DkZipContainer::extractImage(const QString &zipFile, const QString &imageFile)\n{\n    QuaZip zip(zipFile);\n    if (!zip.open(QuaZip::mdUnzip))\n        return QSharedPointer<QByteArray>(new QByteArray());\n\n    qDebug() << \"DkZip::extractImage filePath: \" << zipFile;\n    qDebug() << \"3.0 image file\" << imageFile;\n\n    zip.setCurrentFile(imageFile);\n    QuaZipFile extractedFile(&zip);\n    if (!extractedFile.open(QIODevice::ReadOnly) || extractedFile.getZipError() != UNZ_OK)\n        return QSharedPointer<QByteArray>(new QByteArray());\n\n    QSharedPointer<QByteArray> ba(new QByteArray(extractedFile.readAll()));\n    extractedFile.close();\n\n    zip.close();\n\n    return ba;\n}\n\nvoid DkZipContainer::extractImage(const QString &zipFile, const QString &imageFile, QByteArray &ba)\n{\n    QuaZip zip(zipFile);\n    if (!zip.open(QuaZip::mdUnzip))\n        return;\n\n    zip.setCurrentFile(imageFile);\n    QuaZipFile extractedFile(&zip);\n    if (!extractedFile.open(QIODevice::ReadOnly) || extractedFile.getZipError() != UNZ_OK)\n        return;\n\n    ba = QByteArray(extractedFile.readAll());\n    extractedFile.close();\n\n    zip.close();\n}\n\nbool DkZipContainer::isZip() const\n{\n    return mImageInZip;\n}\n\nQString DkZipContainer::getZipFilePath() const\n{\n    return mZipFilePath;\n}\n\nQString DkZipContainer::getImageFileName() const\n{\n    return mImageFileName;\n}\n\nQString DkZipContainer::getEncodedFilePath() const\n{\n    return mEncodedFilePath;\n}\n\nQString DkZipContainer::zipMarker()\n{\n    return mZipMarker;\n}\n\n#endif\n\n// DkRawLoader --------------------------------------------------------------------\nDkRawLoader::DkRawLoader(const QString &filePath, const QSharedPointer<DkMetaDataT> &metaData)\n{\n    mFilePath = filePath;\n    mMetaData = metaData;\n}\n\nbool DkRawLoader::isEmpty() const\n{\n    return mFilePath.isEmpty();\n}\n\nvoid DkRawLoader::setLoadFast(bool fast)\n{\n    mLoadFast = fast;\n}\n\nbool DkRawLoader::load(const QSharedPointer<QByteArray> ba)\n{\n    DkTimer dt;\n\n    // try fetching the preview\n    if (loadPreview(ba))\n        return true;\n\n#ifdef WITH_LIBRAW\n\n    try {\n        // open the buffer\n        LibRaw iProcessor;\n\n        iProcessor.imgdata.params.use_camera_wb = 1;\n        iProcessor.imgdata.params.output_color = 1;\n        iProcessor.imgdata.params.output_bps = 8;\n        iProcessor.imgdata.params.four_color_rgb = 1;\n        iProcessor.imgdata.params.user_flip = 0;\n\n        if (DkSettingsManager::param().resources().filterRawImages) {\n            iProcessor.imgdata.params.user_qual = 3;\n            iProcessor.imgdata.params.dcb_enhance_fl = 1;\n            iProcessor.imgdata.params.fbdd_noiserd = 2;\n        } else {\n            iProcessor.imgdata.params.user_qual = 0;\n            iProcessor.imgdata.params.dcb_enhance_fl = 0;\n            iProcessor.imgdata.params.fbdd_noiserd = 0;\n        }\n\n        if (!openBuffer(ba, iProcessor)) {\n            qDebug() << \"could not open buffer for\" << mFilePath;\n            return false;\n        }\n\n        // check camera models for specific hacks\n        detectSpecialCamera(iProcessor);\n\n        // try loading RAW preview\n        if (mLoadFast) {\n            mImg = loadPreviewRaw(iProcessor);\n            mImg.setText(\"RAW.IsPreview\", mImg.isNull() ? \"no\" : \"yes\");\n\n            // are we done already?\n            if (!mImg.isNull())\n                return true;\n        }\n\n        // unpack the data\n        int error = iProcessor.unpack();\n        if (std::strcmp(iProcessor.version(), \"0.13.5\") != 0) // fixes a bug specific to libraw 13 - version call is UNTESTED\n            iProcessor.raw2image();\n\n        if (error != LIBRAW_SUCCESS)\n            return false;\n\n        // develop using libraw\n        error = iProcessor.dcraw_process();\n\n        auto rimg = iProcessor.dcraw_make_mem_image();\n\n        if (rimg) {\n            mImg = QImage(rimg->data, rimg->width, rimg->height, rimg->width * 3, QImage::Format_RGB888);\n            mImg = mImg.copy(); // make a deep copy...\n            mImg.setColorSpace(QColorSpace(QColorSpace::SRgb));\n            LibRaw::dcraw_clear_mem(rimg);\n            mImg.setText(\"RAW.Loader\", \"Default\");\n            mImg.setText(\"RAW.IsPreview\", \"no\");\n            return true;\n        }\n\n        // demosaic image\n        cv::Mat rawMat;\n\n        QHash<QString, QString> info; // info for mImg.setText()\n        info.insert(\"RAW.Loader\", \"Nomacs\");\n        info.insert(\"RAW.IsPreview\", \"no\");\n\n        if (iProcessor.imgdata.idata.filters) {\n            rawMat = demosaic(iProcessor);\n            info.insert(\"RAW.Processing\", \"Demosaic\");\n        } else {\n            rawMat = prepareImg(iProcessor);\n            info.insert(\"RAW.Processing\", \"Copy\");\n        }\n\n        // color correction + white balance\n        if (mIsChromatic)\n            whiteBalance(iProcessor, rawMat);\n\n        info.insert(\"RAW.ColorCorrection\", mIsChromatic ? \"yes\" : \"no\");\n\n        // gamma correction\n        gammaCorrection(iProcessor, rawMat);\n\n        // reduce color noise\n        bool noiseReduced = false;\n        if (DkSettingsManager::param().resources().filterRawImages && mIsChromatic) {\n            reduceColorNoise(iProcessor, rawMat);\n            noiseReduced = true;\n        }\n        info.insert(\"RAW.NoiseReduction\", noiseReduced ? \"yes\" : \"no\");\n\n        mImg = raw2Img(iProcessor, rawMat);\n\n        for (auto &key : qAsConst(info).keys())\n            mImg.setText(key, info.value(key));\n\n        // qDebug() << \"img size\" << mImg.size();\n        // qDebug() << \"raw mat size\" << rawMat.rows << \"x\" << rawMat.cols;\n        iProcessor.recycle();\n        rawMat.release();\n    } catch (...) {\n        qDebug() << \"[RAW] error during processing...\";\n        return false;\n    }\n\n    qInfo() << \"[RAW] loaded in \" << dt;\n\n#endif\n\n    return !mImg.isNull();\n}\n\nQImage DkRawLoader::image() const\n{\n    return mImg;\n}\n\nbool DkRawLoader::loadPreview(const QSharedPointer<QByteArray> &ba)\n{\n    try {\n        // try to get preview image from exiv2\n        if (mMetaData) {\n            if (mLoadFast || DkSettingsManager::param().resources().loadRawThumb == DkSettings::raw_thumb_always\n                || DkSettingsManager::param().resources().loadRawThumb == DkSettings::raw_thumb_if_large) {\n                mMetaData->readMetaData(mFilePath, ba);\n\n                int minWidth = 0;\n\n#ifdef WITH_LIBRAW // if nomacs has libraw - we can still hope for a fallback -> otherwise try whatever we have here\n                if (DkSettingsManager::param().resources().loadRawThumb == DkSettings::raw_thumb_if_large)\n                    minWidth = 1920;\n#endif\n                mImg = mMetaData->getPreviewImage(minWidth);\n\n                if (!mImg.isNull()) {\n                    qDebug() << \"[RAW] loaded with exiv2\";\n                    return true;\n                }\n            }\n        }\n    } catch (...) {\n        qWarning() << \"Exception caught during fetching RAW from thumbnail...\";\n    }\n\n    return false;\n}\n\n#ifdef WITH_LIBRAW\n\n// here are some hints from earlier days...\n//// (-w) Use camera white balance, if possible (otherwise, fallback to auto_wb)\n// iProcessor.imgdata.params.use_camera_wb = 1;\n//// (-a) Use automatic white balance obtained after averaging over the entire image\n// iProcessor.imgdata.params.use_auto_wb = 1;\n//// (-q 3) Adaptive homogeneity-directed de-mosaicing algorithm (AHD)\n// iProcessor.imgdata.params.user_qual = 3;\n// iProcessor.imgdata.params.output_tiff = 1;\n////iProcessor.imgdata.params.four_color_rgb = 1;\n////iProcessor.imgdata.params.output_color = 1; //sRGB  (0...raw)\n//// RAW data filtration mode during data unpacking and post-processing\n// iProcessor.imgdata.params.filtering_mode = LIBRAW_FILTERING_AUTOMATIC;\n\nQImage DkRawLoader::loadPreviewRaw(LibRaw &iProcessor) const\n{\n    int tW = iProcessor.imgdata.thumbnail.twidth;\n\n    if (DkSettingsManager::param().resources().loadRawThumb == DkSettings::raw_thumb_always\n        || (DkSettingsManager::param().resources().loadRawThumb == DkSettings::raw_thumb_if_large && tW >= 1920)) {\n        // crashes here if image is broken\n        int err = iProcessor.unpack_thumb();\n        char *tPtr = iProcessor.imgdata.thumbnail.thumb;\n\n        if (!err && tPtr) {\n            QImage img;\n            img.loadFromData((const uchar *)tPtr, iProcessor.imgdata.thumbnail.tlength);\n\n            // we're good to go\n            if (!img.isNull()) {\n                qDebug() << \"[RAW] I loaded the RAW's thumbnail\";\n                return img;\n            } else\n                qDebug() << \"RAW could not load the thumb\";\n        } else\n            qDebug() << \"error unpacking the thumb...\";\n    }\n\n    // default: return nothing\n    return QImage();\n}\n\nbool DkRawLoader::openBuffer(const QSharedPointer<QByteArray> &ba, LibRaw &iProcessor) const\n{\n    int error = LIBRAW_DATA_ERROR;\n\n    QFileInfo fi(mFilePath);\n\n    // use iprocessor from libraw to read the data\n    // OK - so LibRaw 0.17 cannot identify iiq files in the buffer - so we load them from the file\n    if (fi.suffix().contains(\"iiq\", Qt::CaseInsensitive) || !ba || ba->isEmpty()) {\n        error = iProcessor.open_file(mFilePath.toStdString().c_str());\n    } else {\n        // the buffer check is because:\n        // libraw has an error when loading buffers if the first 4 bytes encode as 'RIFF'\n        // and no data follows at all\n        if (ba->isEmpty() || ba->size() < 100)\n            return false;\n\n        error = iProcessor.open_buffer((void *)ba->constData(), ba->size());\n    }\n\n    return (error == LIBRAW_SUCCESS);\n}\n\nvoid DkRawLoader::detectSpecialCamera(const LibRaw &iProcessor)\n{\n    if (QString(iProcessor.imgdata.idata.model) == \"IQ260 Achromatic\")\n        mIsChromatic = false;\n\n    if (QString(iProcessor.imgdata.idata.model).contains(\"IQ260\"))\n        mCamType = camera_iiq;\n    else if (QString(iProcessor.imgdata.idata.make).compare(\"Canon\", Qt::CaseInsensitive))\n        mCamType = camera_canon;\n\n    // add your camera flag (for hacks) here\n}\n\ncv::Mat DkRawLoader::demosaic(LibRaw &iProcessor) const\n{\n    cv::Mat rawMat = cv::Mat(iProcessor.imgdata.sizes.height, iProcessor.imgdata.sizes.width, CV_16UC1);\n    double dynamicRange = (double)(iProcessor.imgdata.color.maximum - iProcessor.imgdata.color.black);\n\n    // normalize all image values\n    for (int rIdx = 0; rIdx < rawMat.rows; rIdx++) {\n        unsigned short *ptrRaw = rawMat.ptr<unsigned short>(rIdx);\n\n        for (int cIdx = 0; cIdx < rawMat.cols; cIdx++) {\n            int colIdx = iProcessor.COLOR(rIdx, cIdx);\n            double val = (double)(iProcessor.imgdata.image[(rawMat.cols * rIdx) + cIdx][colIdx]);\n\n            // normalize the value w.r.t the black point defined\n            val = (val - iProcessor.imgdata.color.black) / dynamicRange;\n            ptrRaw[cIdx] = clip<unsigned short>(val * USHRT_MAX); // for conversion to 16U\n        }\n    }\n\n    // no demosaicing\n    if (mIsChromatic) {\n        unsigned long type = (unsigned long)iProcessor.imgdata.idata.filters;\n        type = type & 255;\n\n        cv::Mat rgbImg;\n\n        // define bayer pattern\n        if (type == 180) {\n            cvtColor(rawMat, rgbImg, CV_BayerBG2RGB); // bitmask  10 11 01 00  -> 3(G) 2(B) 1(G) 0(R) ->\tRG RG RG\n                                                      //\t\t\t\t\t\t\t\t\t\t\t\t\tGB GB GB\n        } else if (type == 30) {\n            cvtColor(rawMat, rgbImg, CV_BayerRG2RGB); // bitmask  00 01 11 10\t-> 0 1 3 2\n        } else if (type == 225) {\n            cvtColor(rawMat, rgbImg, CV_BayerGB2RGB); // bitmask  11 10 00 01\n        } else if (type == 75) {\n            cvtColor(rawMat, rgbImg, CV_BayerGR2RGB); // bitmask  01 00 10 11\n        } else {\n            qWarning() << \"Wrong Bayer Pattern (not BG, RG, GB, GR)\\n\";\n            return cv::Mat();\n        }\n\n        rawMat = rgbImg;\n    }\n\n    // 16U (1 or 3 channeled) Mat\n    return rawMat;\n}\n\ncv::Mat DkRawLoader::prepareImg(const LibRaw &iProcessor) const\n{\n    cv::Mat rawMat = cv::Mat(iProcessor.imgdata.sizes.height, iProcessor.imgdata.sizes.width, CV_16UC3, cv::Scalar(0));\n    double dynamicRange = (double)(iProcessor.imgdata.color.maximum - iProcessor.imgdata.color.black);\n\n    // normalization function\n    auto normalize = [&](double val) {\n        val = (val - iProcessor.imgdata.color.black) / dynamicRange;\n        return clip<unsigned short>(val * USHRT_MAX);\n    };\n\n    for (int rIdx = 0; rIdx < rawMat.rows; rIdx++) {\n        unsigned short *ptrI = rawMat.ptr<unsigned short>(rIdx);\n\n        for (int cIdx = 0; cIdx < rawMat.cols; cIdx++) {\n            *ptrI = normalize(iProcessor.imgdata.image[rawMat.cols * rIdx + cIdx][0]);\n            ptrI++;\n            *ptrI = normalize(iProcessor.imgdata.image[rawMat.cols * rIdx + cIdx][1]);\n            ptrI++;\n            *ptrI = normalize(iProcessor.imgdata.image[rawMat.cols * rIdx + cIdx][2]);\n            ptrI++;\n        }\n    }\n\n    return rawMat;\n}\n\ncv::Mat DkRawLoader::whiteMultipliers(const LibRaw &iProcessor) const\n{\n    // get camera white balance multipliers\n    cv::Mat wm(1, 4, CV_32FC1);\n\n    float *wmp = wm.ptr<float>();\n\n    for (int idx = 0; idx < wm.cols; idx++)\n        wmp[idx] = iProcessor.imgdata.color.cam_mul[idx];\n\n    if (wmp[3] == 0)\n        wmp[3] = wmp[1]; // take green (usually its RGBG)\n\n    // normalize white balance multipliers\n    float w = (float)cv::sum(wm)[0] / 4.0f;\n    float maxW = 1.0f;\n\n    // clipping according the camera model\n    // if w > 2.0 maxW is 256, otherwise 512\n    // tested empirically\n    // check if it can be defined by some metadata settings?\n    if (w > 2.0f)\n        maxW = 255.0f;\n    if (w > 2.0f && mCamType == camera_canon)\n        maxW = 511.0f; // some cameras would even need ~800 - why?\n\n    // normalize white point\n    wm /= maxW;\n\n    // 1 x 4 32FC1 white balance vector\n    return wm;\n}\n\ncv::Mat DkRawLoader::gammaTable(const LibRaw &iProcessor) const\n{\n    // OK this is an instance of reverse engineering:\n    // we found out that the values of (at least) the PhaseOne's achromatic back have to be doubled\n    // our images are no close to what their software (Capture One does) - only the gamma correction\n    // seems to be slightly different... -> now we can load compressed IIQs that are not supported by PS : )\n    double cameraHackMlp = (QString(iProcessor.imgdata.idata.model) == \"IQ260 Achromatic\") ? 2.0 : 1.0;\n\n    // read gamma value and create gamma table\n    double gamma = (double)iProcessor.imgdata.params.gamm[0];\n\n    cv::Mat gmt(1, USHRT_MAX, CV_16UC1);\n    unsigned short *gmtp = gmt.ptr<unsigned short>();\n\n    for (int idx = 0; idx < gmt.cols; idx++) {\n        gmtp[idx] = clip<unsigned short>(qRound((1.099 * std::pow((double)idx / USHRT_MAX, gamma) - 0.099) * 255 * cameraHackMlp));\n    }\n\n    // a 1 x 65535 U16 gamma table\n    return gmt;\n}\n\nvoid DkRawLoader::whiteBalance(const LibRaw &iProcessor, cv::Mat &img) const\n{\n    // white balance must not be empty at this point\n    cv::Mat wb = whiteMultipliers(iProcessor);\n    const float *wbp = wb.ptr<float>();\n    assert(wb.cols == 4);\n\n    for (int rIdx = 0; rIdx < img.rows; rIdx++) {\n        unsigned short *ptr = img.ptr<unsigned short>(rIdx);\n\n        for (int cIdx = 0; cIdx < img.cols; cIdx++) {\n            // apply white balance correction\n            unsigned short r = clip<unsigned short>(*ptr * wbp[0]);\n            unsigned short g = clip<unsigned short>(*(ptr + 1) * wbp[1]);\n            unsigned short b = clip<unsigned short>(*(ptr + 2) * wbp[2]);\n\n            // apply color correction\n            int cr =\n                qRound(iProcessor.imgdata.color.rgb_cam[0][0] * r + iProcessor.imgdata.color.rgb_cam[0][1] * g + iProcessor.imgdata.color.rgb_cam[0][2] * b);\n            int cg =\n                qRound(iProcessor.imgdata.color.rgb_cam[1][0] * r + iProcessor.imgdata.color.rgb_cam[1][1] * g + iProcessor.imgdata.color.rgb_cam[1][2] * b);\n            int cb =\n                qRound(iProcessor.imgdata.color.rgb_cam[2][0] * r + iProcessor.imgdata.color.rgb_cam[2][1] * g + iProcessor.imgdata.color.rgb_cam[2][2] * b);\n\n            // clip & save color corrected values\n            *ptr = clip<unsigned short>(cr);\n            ptr++;\n            *ptr = clip<unsigned short>(cg);\n            ptr++;\n            *ptr = clip<unsigned short>(cb);\n            ptr++;\n        }\n    }\n}\n\nvoid DkRawLoader::gammaCorrection(const LibRaw &iProcessor, cv::Mat &img) const\n{\n    // white balance must not be empty at this point\n    cv::Mat gt = gammaTable(iProcessor);\n    const unsigned short *gammaLookup = gt.ptr<unsigned short>();\n    assert(gt.cols == USHRT_MAX);\n\n    for (int rIdx = 0; rIdx < img.rows; rIdx++) {\n        unsigned short *ptr = img.ptr<unsigned short>(rIdx);\n\n        for (int cIdx = 0; cIdx < img.cols * img.channels(); cIdx++) {\n            // values close to 0 are treated linear\n            if (ptr[cIdx] <= 5) // 0.018 * 255\n                ptr[cIdx] = (unsigned short)qRound(ptr[cIdx] * (double)iProcessor.imgdata.params.gamm[1] / 255.0);\n            else\n                ptr[cIdx] = gammaLookup[ptr[cIdx]];\n        }\n    }\n}\n\nvoid DkRawLoader::reduceColorNoise(const LibRaw &iProcessor, cv::Mat &img) const\n{\n    // filter color noise with a median filter\n    float isoSpeed = iProcessor.imgdata.other.iso_speed;\n\n    if (isoSpeed > 0) {\n        DkTimer dt;\n\n        int winSize;\n        if (isoSpeed > 6400)\n            winSize = 13;\n        else if (isoSpeed >= 3200)\n            winSize = 11;\n        else if (isoSpeed >= 2500)\n            winSize = 9;\n        else if (isoSpeed >= 400)\n            winSize = 7;\n        else\n            winSize = 5;\n\n        DkTimer dMed;\n\n        // revert back to 8-bit image\n        img.convertTo(img, CV_8U);\n\n        cv::cvtColor(img, img, CV_RGB2YCrCb);\n\n        std::vector<cv::Mat> imgCh;\n        cv::split(img, imgCh);\n        assert(imgCh.size() == 3);\n\n        cv::medianBlur(imgCh[1], imgCh[1], winSize);\n        cv::medianBlur(imgCh[2], imgCh[2], winSize);\n\n        cv::merge(imgCh, img);\n        cv::cvtColor(img, img, CV_YCrCb2RGB);\n        qDebug() << \"median blur takes:\" << dt;\n    }\n}\n\nQImage DkRawLoader::raw2Img(const LibRaw &iProcessor, cv::Mat &img) const\n{\n    // check the pixel aspect ratio of the raw image\n    if (iProcessor.imgdata.sizes.pixel_aspect != 1.0f)\n        cv::resize(img, img, cv::Size(), (double)iProcessor.imgdata.sizes.pixel_aspect, 1.0f);\n\n    // revert back to 8-bit image\n    img.convertTo(img, CV_8U);\n\n    // TODO: for now - fix this!\n    if (img.channels() == 1)\n        cv::cvtColor(img, img, CV_GRAY2RGB);\n\n    return DkImage::mat2QImage(img);\n}\n\n#endif\n\n// -------------------------------------------------------------------- DkTgaLoader\nnamespace tga\n{\nDkTgaLoader::DkTgaLoader(QSharedPointer<QByteArray> ba)\n{\n    mBa = ba;\n}\n\nQImage DkTgaLoader::image() const\n{\n    return mImg;\n}\n\nbool DkTgaLoader::load()\n{\n    if (!mBa || mBa->isEmpty())\n        return false;\n\n    return load(mBa);\n}\n\nbool DkTgaLoader::load(QSharedPointer<QByteArray> ba)\n{\n    // this code is from: http://www.paulbourke.net/dataformats/tga/\n    // thanks!\n    Header header;\n\n    const char *dataC = ba->data();\n\n    /* Display the header fields */\n    header.idlength = *dataC;\n    dataC++;\n    header.colourmaptype = *dataC;\n    dataC++;\n    header.datatypecode = *dataC;\n    dataC++;\n\n    const short *dataS = (const short *)dataC;\n\n    header.colourmaporigin = *dataS;\n    dataS++;\n    header.colourmaplength = *dataS;\n    dataS++;\n    dataC = (const char *)dataS;\n    header.colourmapdepth = *dataC;\n    dataC++;\n    dataS = (const short *)dataC;\n    header.x_origin = *dataS;\n    dataS++;\n    header.y_origin = *dataS;\n    dataS++;\n    header.width = *dataS;\n    dataS++;\n    header.height = *dataS;\n    dataS++;\n    dataC = (const char *)dataS;\n    header.bitsperpixel = *dataC;\n    dataC++;\n    header.imagedescriptor = *dataC;\n    dataC++;\n\n#ifdef _DEBUG\n    qDebug() << \"TGA Header ------------------------------\";\n    qDebug() << \"ID length:         \" << (int)header.idlength;\n    qDebug() << \"Colourmap type:    \" << (int)header.colourmaptype;\n    qDebug() << \"Image type:        \" << (int)header.datatypecode;\n    qDebug() << \"Colour map offset: \" << header.colourmaporigin;\n    qDebug() << \"Colour map length: \" << header.colourmaplength;\n    qDebug() << \"Colour map depth:  \" << (int)header.colourmapdepth;\n    qDebug() << \"X origin:          \" << header.x_origin;\n    qDebug() << \"Y origin:          \" << header.y_origin;\n    qDebug() << \"Width:             \" << header.width;\n    qDebug() << \"Height:            \" << header.height;\n    qDebug() << \"Bits per pixel:    \" << (int)header.bitsperpixel;\n    qDebug() << \"Descriptor:        \" << (int)header.imagedescriptor;\n#endif\n\n    /* What can we handle */\n    if (header.datatypecode != 2 && header.datatypecode != 10) {\n        qWarning() << \"[TGA] Can only handle image type 2 and 10\";\n        return false;\n    }\n\n    if (header.bitsperpixel != 16 && header.bitsperpixel != 24 && header.bitsperpixel != 32) {\n        qWarning() << \"[TGA] Can only handle pixel depths of 16, 24, and 32\";\n        return false;\n    }\n\n    if (header.colourmaptype != 0 && header.colourmaptype != 1) {\n        qWarning() << \"[TGA] Can only handle colour map types of 0 and 1\";\n        return false;\n    }\n\n    Pixel *pixels = new Pixel[header.width * header.height * sizeof(Pixel)];\n\n    if (!pixels) {\n        qWarning() << \"[TGA] could not allocate\" << header.width * header.height * sizeof(Pixel) / 1024 << \"KB\";\n        return false;\n    }\n\n    ///* Skip over unnecessary stuff */\n    int skipover = header.idlength;\n    skipover += header.colourmaptype * header.colourmaplength;\n    dataC += skipover;\n\n    /* Read the image */\n    int bytes2read = header.bitsperpixel / 8; // save?\n    unsigned char p[5];\n\n    for (int n = 0; n < header.width * header.height;) {\n        if (header.datatypecode == 2) { /* Uncompressed */\n\n            // TODO: out-of-bounds not checked here...\n            for (int bi = 0; bi < bytes2read; bi++, dataC++)\n                p[bi] = *dataC;\n\n            mergeBytes(&(pixels[n]), p, bytes2read);\n            n++;\n        } else if (header.datatypecode == 10) { /* Compressed */\n\n            for (int bi = 0; bi < bytes2read + 1; bi++, dataC++)\n                p[bi] = *dataC;\n\n            int j = p[0] & 0x7f;\n            mergeBytes(&(pixels[n]), &(p[1]), bytes2read);\n            n++;\n            if (p[0] & 0x80) { /* RLE chunk */\n                for (int i = 0; i < j; i++) {\n                    mergeBytes(&(pixels[n]), &(p[1]), bytes2read);\n                    n++;\n                }\n            } else { /* Normal chunk */\n                for (int i = 0; i < j; i++) {\n                    for (int bi = 0; bi < bytes2read; bi++, dataC++)\n                        p[bi] = *dataC;\n\n                    mergeBytes(&(pixels[n]), p, bytes2read);\n                    n++;\n                }\n            }\n        }\n    }\n\n    mImg = QImage((uchar *)pixels, header.width, header.height, QImage::Format_ARGB32);\n    mImg = mImg.copy();\n\n    // I somehow expected the 5th bit to be 0x10 -> but Paul seems to have a 0th bit : )\n    if (!(header.imagedescriptor & 0x20))\n        mImg = mImg.mirrored();\n\n    delete[] pixels;\n\n    return true;\n}\n\nvoid DkTgaLoader::mergeBytes(Pixel *pixel, unsigned char *p, int bytes) const\n{\n    if (bytes == 4) {\n        pixel->r = p[0];\n        pixel->g = p[1];\n        pixel->b = p[2];\n        pixel->a = p[3];\n    } else if (bytes == 3) {\n        pixel->r = p[0];\n        pixel->g = p[1];\n        pixel->b = p[2];\n        pixel->a = 255;\n    } else if (bytes == 2) {\n        pixel->r = (p[0] & 0x1f) << 3;\n        pixel->g = ((p[1] & 0x03) << 6) | ((p[0] & 0xe0) >> 2);\n        pixel->b = (p[1] & 0x7c) << 1;\n        pixel->a = 255; // (p[1] & 0x80);\n    }\n}\n}\n\n}",
    "bool DkBasicLoader::loadTIFF(const QString &filePath, QImage &img, QSharedPointer<QByteArray> ba) const\n{\n    bool success = false;\n\n    // first turn off nasty warning/error dialogs - (we do the GUI : )\n    TIFFErrorHandler oldErrorHandler, oldWarningHandler;\n    oldWarningHandler = TIFFSetWarningHandler(NULL);\n    oldErrorHandler = TIFFSetErrorHandler(NULL);\n\n    DkTimer dt;\n    TIFF *tiff = 0;\n\n// TODO: currently TIFFStreamOpen can only be linked on Windows?!\n#if defined(Q_OS_WIN)\n\n    std::istringstream is(ba ? ba->toStdString() : \"\");\n\n    if (ba)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &is);\n\n    // fallback to direct loading\n    if (!tiff)\n        tiff = TIFFOpen(filePath.toLatin1(), \"r\");\n\n    // FIXME: we could load without buffer if toLatin1()=>toUtf8() and on\n    // windows use wchar_t* version of TIFFOpen();\n\n    // loading from buffer allows us to load files with non-latin names\n    QSharedPointer<QByteArray> bal;\n    if (!tiff)\n        bal = loadFileToBuffer(filePath);\n\n    std::istringstream isl(bal ? bal->toStdString() : \"\");\n\n    if (bal)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &isl);\n#else\n    tiff = TIFFOpen(filePath.toLatin1(), \"r\");\n#endif\n\n    if (!tiff)\n        return success;\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n\n    // init the qImage\n    img = QImage(width, height, QImage::Format_ARGB32);\n\n    const int stopOnError = 1;\n    success = TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32_t *>(img.bits()), ORIENTATION_TOPLEFT, stopOnError) != 0;\n\n    if (success) {\n        for (uint32_t y = 0; y < height; ++y)\n            convert32BitOrder(img.scanLine(y), width);\n    }\n\n    TIFFClose(tiff);\n\n    TIFFSetWarningHandler(oldWarningHandler);\n    TIFFSetWarningHandler(oldErrorHandler);\n\n    return success;\n\n#endif // !WITH_LIBTIFF\n    return false;\n}",
    "bool DkBasicLoader::loadPageAt(int pageIdx)\n{\n    bool imgLoaded = false;\n\n#ifdef WITH_LIBTIFF\n\n    // <= 1 since first page is loaded using qt\n    if (pageIdx > mNumPages || pageIdx < 1)\n        return imgLoaded;\n\n    // first turn off nasty warning/error dialogs - (we do the GUI : )\n    TIFFErrorHandler oldErrorHandler, oldWarningHandler;\n    oldWarningHandler = TIFFSetWarningHandler(NULL);\n    oldErrorHandler = TIFFSetErrorHandler(NULL);\n\n    DkTimer dt;\n    TIFF *tiff = TIFFOpen(mFile.toLatin1(), \"r\");\n\n#if defined(Q_OS_WIN)\n\n    // loading from buffer allows us to load files with non-latin names\n    QSharedPointer<QByteArray> ba;\n    if (!tiff)\n        ba = loadFileToBuffer(mFile);\n\n    std::istringstream is(ba ? ba->toStdString() : \"\");\n    if (ba)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &is);\n#endif\n\n    if (!tiff)\n        return imgLoaded;\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n\n    // go to current directory\n    for (int idx = 1; idx < pageIdx; idx++) {\n        if (!TIFFReadDirectory(tiff))\n            return false;\n    }\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n\n    // init the qImage\n    QImage img = QImage(width, height, QImage::Format_ARGB32);\n\n    const int stopOnError = 1;\n    imgLoaded = TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32_t *>(img.bits()), ORIENTATION_TOPLEFT, stopOnError) != 0;\n\n    if (imgLoaded) {\n        for (uint32_t y = 0; y < height; ++y)\n            convert32BitOrder(img.scanLine(y), width);\n    }\n\n    TIFFClose(tiff);\n\n    TIFFSetWarningHandler(oldWarningHandler);\n    TIFFSetWarningHandler(oldErrorHandler);\n\n    setEditImage(img, tr(\"Original Image\"));\n#else\n    Q_UNUSED(pageIdx);\n#endif\n\n    return imgLoaded;\n}",
    "inline\nT tiff_get(const tif_holder& t, const int tag) {\n    T val;\n    if (!TIFFGetField(t.tif, tag, &val)) {\n        std::stringstream out;\n        out << \"imread.imread._tiff: Cannot find necessary tag (\" << tag << \")\";\n        throw CannotReadError(out.str());\n    }\n    return val;\n}",
    "inline\nstd::string tiff_get<std::string>(const tif_holder& t, const int tag) {\n    char* val;\n    if (!TIFFGetField(t.tif, tag, &val)) {\n        std::stringstream out;\n        out << \"imread.imread._tiff: Cannot find necessary tag (\" << tag << \")\";\n        throw CannotReadError(out.str());\n    }\n    return val;\n}",
    "inline\nT tiff_get(const tif_holder& t, const int tag, const T def) {\n    T val;\n    if (!TIFFGetField(t.tif, tag, &val)) return def;\n    return val;\n}",
    "inline\nstd::string tiff_get<std::string>(const tif_holder& t, const int tag, const std::string def) {\n    char* val;\n    if (!TIFFGetField(t.tif, tag, &val)) return def;\n    return val;\n}",
    "std::unique_ptr<image_list> STKFormat::read_multi(byte_source* src, ImageFactory* factory, const options_map&) {\n    shift_source moved(src);\n    stk_extend ext;\n    tiff_warn_error twe;\n\n    tif_holder t = read_client(&moved);\n    std::unique_ptr<image_list> images(new image_list);\n    const uint32_t h = tiff_get<uint32_t>(t, TIFFTAG_IMAGELENGTH);\n    const uint32_t w = tiff_get<uint32_t>(t, TIFFTAG_IMAGEWIDTH);\n\n    const uint16_t nr_samples = tiff_get<uint16_t>(t, TIFFTAG_SAMPLESPERPIXEL, 1);\n    const uint16_t bits_per_sample = tiff_get<uint16_t>(t, TIFFTAG_BITSPERSAMPLE, 8);\n    const int depth = nr_samples > 1 ? nr_samples : -1;\n\n    const int strip_size = TIFFStripSize(t.tif);\n    const int n_strips = TIFFNumberOfStrips(t.tif);\n    int32_t n_planes;\n    void* data;\n    TIFFGetField(t.tif, UIC3Tag, &n_planes, &data);\n    int raw_strip_size = 0;\n    for (int st = 0; st != n_strips; ++st) {\n        raw_strip_size += TIFFRawStripSize(t.tif, st);\n    }\n    for (int z = 0; z < n_planes; ++z) {\n        // Monkey patch strip offsets. This is very hacky, but it seems to work!\n        moved.shift(z * raw_strip_size);\n\n        std::unique_ptr<Image> output(factory->create(bits_per_sample, h, w, depth));\n        uint8_t* start = output->rowp_as<uint8_t>(0);\n        for (int st = 0; st != n_strips; ++st) {\n            const int offset = TIFFReadEncodedStrip(t.tif, st, start, strip_size);\n            if (offset == -1) {\n                throw CannotReadError(\"imread.imread._tiff.stk: Error reading strip\");\n            }\n            start += offset;\n        }\n        images->push_back(std::move(output));\n    }\n    return images;\n}",
    "jobject NativeDecoder::getBitmap()\n{\n        //init signal handler for catch SIGSEGV error that could be raised in libtiff\n        struct sigaction act;\n        memset(&act, 0, sizeof(act));\n        sigemptyset(&act.sa_mask);\n        act.sa_sigaction = generalErrorHandler;\n        act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n        if(sigaction(SIGSEGV, &act, 0) < 0) {\n            LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n        }\n\n        //check for error\n        if (setjmp(NativeDecoder::general_buf)) {\n             const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n             LOGE(err);\n             if (throwException) {\n                 throwDecodeFileException(err);\n             }\n            return NULL;\n        }\n\n        //Get options from TiffBitmapFactory$Options\n        jfieldID gOptions_ThrowExceptionFieldID = env->GetFieldID(jBitmapOptionsClass,\n                                                                          \"inThrowException\",\n                                                                          \"Z\");\n        throwException = env->GetBooleanField(optionsObject, gOptions_ThrowExceptionFieldID);\n\n        jfieldID gOptions_UseOrientationTagFieldID = env->GetFieldID(jBitmapOptionsClass,\n                                                                                  \"inUseOrientationTag\",\n                                                                                  \"Z\");\n        useOrientationTag = env->GetBooleanField(optionsObject, gOptions_UseOrientationTagFieldID);\n\n        jfieldID gOptions_sampleSizeFieldID = env->GetFieldID(jBitmapOptionsClass, \"inSampleSize\", \"I\");\n        jint inSampleSize = env->GetIntField(optionsObject, gOptions_sampleSizeFieldID);\n        if (inSampleSize != 1 && inSampleSize % 2 != 0) {\n            const char *message = \"inSampleSize should be power of 2\\0\";\n            LOGE(message);\n            if (throwException) {\n                throwDecodeFileException(message);\n            }\n            return NULL;\n        }\n\n        jfieldID gOptions_justDecodeBoundsFieldID = env->GetFieldID(jBitmapOptionsClass,\n                                                                    \"inJustDecodeBounds\", \"Z\");\n        jboolean inJustDecodeBounds = env->GetBooleanField(optionsObject, gOptions_justDecodeBoundsFieldID);\n\n        jfieldID gOptions_invertRedAndBlueFieldID = env->GetFieldID(jBitmapOptionsClass,\n                                                                    \"inSwapRedBlueColors\", \"Z\");\n        invertRedAndBlue = env->GetBooleanField(optionsObject, gOptions_invertRedAndBlueFieldID);\n\n        jfieldID gOptions_DirectoryCountFieldID = env->GetFieldID(jBitmapOptionsClass,\n                                                                  \"inDirectoryNumber\",\n                                                                  \"I\");\n        jint inDirectoryNumber = env->GetIntField(optionsObject, gOptions_DirectoryCountFieldID);\n        LOGII(\"param directoryCount\", inDirectoryNumber);\n\n        jfieldID gOptions_AvailableMemoryFieldID = env->GetFieldID(jBitmapOptionsClass,\n                                                                  \"inAvailableMemory\",\n                                                                  \"J\");\n        unsigned long inAvailableMemory = env->GetLongField(optionsObject, gOptions_AvailableMemoryFieldID);\n\n        jfieldID gOptions_PreferedConfigFieldID = env->GetFieldID(jBitmapOptionsClass,\n                                                                  \"inPreferredConfig\",\n                                                                  \"Lorg/beyka/tiffbitmapfactory/TiffBitmapFactory$ImageConfig;\");\n        jobject config = env->GetObjectField(optionsObject, gOptions_PreferedConfigFieldID);\n\n        if (inAvailableMemory > 0) {\n            availableMemory = inAvailableMemory;\n        }\n\n        if (config == NULL) {\n            LOGI(\"config is NULL, creating default options\");\n            jclass bitmapConfig = env->FindClass(\n                    \"org/beyka/tiffbitmapfactory/TiffBitmapFactory$ImageConfig\");\n            jfieldID argb8888FieldID = env->GetStaticFieldID(bitmapConfig, \"ARGB_8888\",\n                                                             \"Lorg/beyka/tiffbitmapfactory/TiffBitmapFactory$ImageConfig;\");\n            config = env->GetStaticObjectField(bitmapConfig, argb8888FieldID);\n            env->DeleteLocalRef(bitmapConfig);\n        }\n        preferedConfig = env->NewGlobalRef(config);\n        env->DeleteLocalRef(config);\n\n        jfieldID gOptions_DecodeAreaFieldId = env->GetFieldID(jBitmapOptionsClass, \"inDecodeArea\",\n                                                                \"Lorg/beyka/tiffbitmapfactory/DecodeArea;\");\n        jobject decodeArea = env->GetObjectField(optionsObject, gOptions_DecodeAreaFieldId);\n\n        //if directory number < 0 set it to 0\n        if (inDirectoryNumber < 0) inDirectoryNumber = 0;\n\n        //Open tiff file\n        LOGIS(\"nativeTiffOpen\", strPath);\n        const char *strPath = NULL;\n        if (decodingMode == DECODE_MODE_FILE_DESCRIPTOR) {\n            image = TIFFFdOpen(jFd, \"\", \"r\");\n        } else if (decodingMode == DECODE_MODE_FILE_PATH) {\n            strPath = env->GetStringUTFChars(jPath, 0);\n            image = TIFFOpen(strPath, \"r\");\n        }\n\n        if (image == NULL) {\n            if (throwException) {\n                throwCantOpenFileException();\n            }\n\n            if (decodingMode == DECODE_MODE_FILE_PATH) {\n                LOGES(\"Can\\'t open bitmap\", strPath);\n                env->ReleaseStringUTFChars(jPath, strPath);\n            } else {\n                LOGEI(\"Can\\'t open file descriptor\", jFd);\n            }\n            return NULL;\n        } else {\n            if (decodingMode == DECODE_MODE_FILE_PATH) {\n                env->ReleaseStringUTFChars(jPath, strPath);\n            }\n        }\n        LOGI(\"Tiff is open\");\n\n        TIFFSetDirectory(image, inDirectoryNumber);\n        TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &origwidth);\n        TIFFGetField(image, TIFFTAG_IMAGELENGTH, &origheight);\n\n        //Read decode bounds if exists\n        if (decodeArea) {\n            LOGI(\"Decode bounds present\");\n            jclass decodeAreaClass = env->FindClass(\"org/beyka/tiffbitmapfactory/DecodeArea\");\n            jfieldID xFieldID = env->GetFieldID(decodeAreaClass, \"x\", \"I\");\n            jfieldID yFieldID = env->GetFieldID(decodeAreaClass, \"y\", \"I\");\n            jfieldID widthFieldID = env->GetFieldID(decodeAreaClass, \"width\", \"I\");\n            jfieldID heightFieldID = env->GetFieldID(decodeAreaClass, \"height\", \"I\");\n\n            boundX = env->GetIntField(decodeArea, xFieldID);\n            boundY = env->GetIntField(decodeArea, yFieldID);\n            boundWidth = env->GetIntField(decodeArea, widthFieldID);\n            boundHeight = env->GetIntField(decodeArea, heightFieldID);\n            if (boundX >= origwidth-1) {\n                const char *message = \"X of left top corner of decode area should be less than image width\";\n                LOGE(*message);\n                if (throwException) {\n                    throwDecodeFileException(message);\n                }\n                env->DeleteLocalRef(decodeAreaClass);\n                return NULL;\n            }\n            if (boundY >= origheight-1) {\n                const char *message = \"Y of left top corner of decode area should be less than image height\";\n                LOGE(*message);\n                if (throwException) {\n                    throwDecodeFileException(message);\n                }\n                env->DeleteLocalRef(decodeAreaClass);\n                return NULL;\n            }\n\n            if (boundX < 0) boundX = 0;\n            if (boundY < 0) boundY = 0;\n            if (boundX + boundWidth >= origwidth) boundWidth = origwidth - boundX -1;\n            if (boundY + boundHeight >= origheight) boundHeight = origheight - boundY -1;\n\n            if (boundWidth < 1) {\n                const char *message = \"Width of decode area can\\'t be less than 1\";\n                LOGE(*message);\n                if (throwException) {\n                    throwDecodeFileException(message);\n                }\n                env->DeleteLocalRef(decodeAreaClass);\n                return NULL;\n            }\n            if (boundHeight < 1) {\n                const char *message = \"Height of decode area can\\'t be less than 1\";\n                LOGE(*message);\n                if (throwException) {\n                    throwDecodeFileException(message);\n                }\n                env->DeleteLocalRef(decodeAreaClass);\n                return NULL;\n            }\n\n            LOGII(\"Decode X\", boundX);\n            LOGII(\"Decode Y\", boundY);\n            LOGII(\"Decode width\", boundWidth);\n            LOGII(\"Decode height\", boundHeight);\n\n            hasBounds = 1;\n            env->DeleteLocalRef(decodeAreaClass);\n            env->DeleteLocalRef(decodeArea);\n        }\n\n        jobject java_bitmap = NULL;\n\n        writeDataToOptions(inDirectoryNumber);\n\n        if (!inJustDecodeBounds) {\n            progressTotal = origwidth * origheight;\n            sendProgress(0, progressTotal);\n            java_bitmap = createBitmap(inSampleSize, inDirectoryNumber);\n        }\n\n        return java_bitmap;\n}",
    "jobject NativeDecoder::createBitmap(int inSampleSize, int directoryNumber)\n{\n//Read Config from options. Use ordinal field from ImageConfig class\n    jint configInt = ARGB_8888;\n    if(preferedConfig) {\n        jclass configClass = env->FindClass(\n            \"org/beyka/tiffbitmapfactory/TiffBitmapFactory$ImageConfig\");\n        jfieldID ordinalFieldID = env->GetFieldID(configClass, \"ordinal\", \"I\");\n        configInt = env->GetIntField(preferedConfig, ordinalFieldID);\n        env->DeleteLocalRef(configClass);\n    }\n\n    int bitdepth = 1;\n    TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &bitdepth);\n    if (bitdepth != 1 && bitdepth != 4 && bitdepth != 8 && bitdepth != 16) {\n        const char * err = \"Only 1, 4, 8 and 16 bits per sample are supported\";\n        LOGE(err);\n        if (throwException) {\n            throwDecodeFileException(err);\n        }\n        return NULL;\n    }\n\n    int newBitmapWidth = 0;\n    int newBitmapHeight = 0;\n\n    jint *raster = NULL;\n\n    if (!hasBounds) {\n        switch(getDecodeMethod()) {\n            case DECODE_METHOD_IMAGE:\n                raster = getSampledRasterFromImage(inSampleSize, &newBitmapWidth, &newBitmapHeight);\n                break;\n            case DECODE_METHOD_TILE:\n                raster = getSampledRasterFromTile(inSampleSize, &newBitmapWidth, &newBitmapHeight);\n                break;\n            case DECODE_METHOD_STRIP:\n                raster = getSampledRasterFromStrip(inSampleSize,  &newBitmapWidth, &newBitmapHeight);\n                break;\n        }\n    } else {\n        switch(getDecodeMethod()) {\n            case DECODE_METHOD_IMAGE:\n                raster = getSampledRasterFromImageWithBounds(inSampleSize, &newBitmapWidth, &newBitmapHeight);\n                break;\n            case DECODE_METHOD_TILE:\n                raster = getSampledRasterFromTileWithBounds(inSampleSize, &newBitmapWidth, &newBitmapHeight);\n                break;\n            case DECODE_METHOD_STRIP:\n                raster = getSampledRasterFromStripWithBounds(inSampleSize,  &newBitmapWidth, &newBitmapHeight);\n                break;\n        }\n\n    }\n\n    if (raster == NULL) {\n        return NULL;\n    }\n\n    // Convert ABGR to ARGB\n    if (invertRedAndBlue) {\n        int i = 0;\n        int j = 0;\n        int tmp = 0;\n        for (i = 0; i < newBitmapHeight; i++) {\n            for (j = 0; j < newBitmapWidth; j++) {\n                tmp = raster[j + newBitmapWidth * i];\n                raster[j + newBitmapWidth * i] =\n                        (tmp & 0xff000000) | ((tmp & 0x00ff0000) >> 16) | (tmp & 0x0000ff00) |\n                        ((tmp & 0xff) << 16);\n            }\n        }\n    }\n\n    sendProgress(progressTotal, progressTotal);\n\n    if(checkStop()) {\n        if (raster) {\n            free(raster);\n        }\n        LOGI(\"Thread stopped\");\n        return NULL;\n    }\n\n    //Class and field for Bitmap.Config\n    jclass bitmapConfigClass = env->FindClass(\"android/graphics/Bitmap$Config\");\n    jfieldID bitmapConfigField = NULL;\n    void *processedBuffer = NULL;\n    if (configInt == ARGB_8888) {\n        processedBuffer = raster;\n        bitmapConfigField = env->GetStaticFieldID(bitmapConfigClass, \"ARGB_8888\",\n                                                  \"Landroid/graphics/Bitmap$Config;\");\n    } else if (configInt == ALPHA_8) {\n        processedBuffer = createBitmapAlpha8(raster, newBitmapWidth,\n                                             newBitmapHeight);\n        bitmapConfigField = env->GetStaticFieldID(bitmapConfigClass, \"ALPHA_8\",\n                                                  \"Landroid/graphics/Bitmap$Config;\");\n    } else if (configInt == RGB_565) {\n        processedBuffer = createBitmapRGB565(raster, newBitmapWidth,\n                                             newBitmapHeight);\n        bitmapConfigField = env->GetStaticFieldID(bitmapConfigClass, \"RGB_565\",\n                                                  \"Landroid/graphics/Bitmap$Config;\");\n    }\n\n    if (processedBuffer == NULL) {\n        LOGE(\"Error while decoding image\");\n        return NULL;\n    }\n\n    //Create mutable bitmap\n    jclass bitmapClass = env->FindClass(\"android/graphics/Bitmap\");\n    jmethodID methodid = env->GetStaticMethodID(bitmapClass, \"createBitmap\",\n                                                \"(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;\");\n\n    //BitmapConfig\n    jobject config = env->GetStaticObjectField(bitmapConfigClass, bitmapConfigField);\n\n    env->DeleteLocalRef(bitmapConfigClass);\n\n    jobject java_bitmap = NULL;\n\n    if(checkStop()) {\n        env->DeleteLocalRef(config);\n        env->DeleteLocalRef(bitmapClass);\n        if (processedBuffer) {\n            free(processedBuffer);\n        }\n        LOGI(\"Thread stopped\");\n        return NULL;\n    }\n\n    if (!useOrientationTag) {\n        java_bitmap = env->CallStaticObjectMethod(bitmapClass, methodid, newBitmapWidth,\n                                                      newBitmapHeight, config);\n    } else if (origorientation > 4) {\n        java_bitmap = env->CallStaticObjectMethod(bitmapClass, methodid, newBitmapHeight,\n                                                  newBitmapWidth, config);\n    } else {\n        java_bitmap = env->CallStaticObjectMethod(bitmapClass, methodid, newBitmapWidth,\n                                                  newBitmapHeight, config);\n    }\n\n    //remove not used references\n    env->DeleteLocalRef(config);\n    env->DeleteLocalRef(bitmapClass);\n\n    //Copy data to bitmap\n    int ret;\n    void *bitmapPixels;\n    if ((ret = AndroidBitmap_lockPixels(env, java_bitmap, &bitmapPixels)) < 0) {\n        //error\n        LOGE(\"Lock pixels failed\");\n        return NULL;\n    }\n    int pixelsCount = newBitmapWidth * newBitmapHeight;\n\n    if (configInt == ARGB_8888) {\n        memcpy(bitmapPixels, (jint *) processedBuffer, sizeof(jint) * pixelsCount);\n    } else if (configInt == ALPHA_8) {\n        memcpy(bitmapPixels, (jbyte *) processedBuffer, sizeof(jbyte) * pixelsCount);\n    } else if (configInt == RGB_565) {\n        memcpy(bitmapPixels, (unsigned short *) processedBuffer,\n               sizeof(unsigned short) * pixelsCount);\n    }\n\n    AndroidBitmap_unlockPixels(env, java_bitmap);\n\n    //remove array\n    free(processedBuffer);\n\n    return java_bitmap;\n}",
    "jint * NativeDecoder::getSampledRasterFromStrip(int inSampleSize, int *bitmapwidth, int *bitmapheight) {\n\n    //init signal handler for catch SIGSEGV error that could be raised in libtiff\n    struct sigaction act;\n    memset(&act, 0, sizeof(act));\n    sigemptyset(&act.sa_mask);\n    act.sa_sigaction = stripErrorHandler;\n    act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n    if(sigaction(SIGSEGV, &act, 0) < 0) {\n        LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n    }\n\n    LOGII(\"width\", origwidth);\n    LOGII(\"height\", origheight);\n\n    jint *pixels = NULL;\n    *bitmapwidth = origwidth / inSampleSize;\n    *bitmapheight = origheight / inSampleSize;\n    uint32 pixelsBufferSize = *bitmapwidth * *bitmapheight;\n    int origImageBufferSize = origwidth * origheight;\n\n    LOGII(\"new width\", *bitmapwidth);\n    LOGII(\"new height\", *bitmapheight);\n\n    uint32 stripSize = TIFFStripSize (image);\n    uint32 stripMax = TIFFNumberOfStrips (image);\n    LOGII(\"strip size \", stripSize);\n    LOGII(\"stripMax  \", stripMax);\n    int rowPerStrip = -1;\n    TIFFGetField(image, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    LOGII(\"rowsperstrip\", rowPerStrip);\n\n    unsigned long estimateMem = 0;\n    estimateMem += (sizeof(jint) * pixelsBufferSize); //buffer for decoded pixels\n    estimateMem += (origwidth * sizeof(uint32)); //work line for rotate strip\n    estimateMem += (origwidth * rowPerStrip * sizeof (uint32) * 2); //current and next strips\n    estimateMem += (sizeof(jint) * origwidth * 2); //bottom and top lines for reading pixel(matrixBottomLine, matrixTopLine)\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory) {\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return NULL;\n    }\n\n    pixels = (jint *) malloc(sizeof(jint) * pixelsBufferSize);\n    if (pixels == NULL) {\n        LOGE(\"Can\\'t allocate memory for temp buffer\");\n        return NULL;\n    }\n\n    uint32* work_line_buf = (uint32 *)_TIFFmalloc(origwidth * sizeof(uint32));\n\n    uint32* raster;\n    uint32* rasterForBottomLine; // in this raster copy next strip for getting bottom line in matrix color selection\n    if (rowPerStrip == -1 && stripMax == 1) {\n            raster = (uint32 *)_TIFFmalloc(origImageBufferSize * sizeof (uint32));\n            rasterForBottomLine = (uint32 *)_TIFFmalloc(origImageBufferSize * sizeof (uint32));\n    } else {\n            raster = (uint32 *)_TIFFmalloc(origwidth * rowPerStrip * sizeof (uint32));\n            rasterForBottomLine = (uint32 *)_TIFFmalloc(origwidth * rowPerStrip * sizeof (uint32));\n    }\n    if (rowPerStrip == -1) {\n            rowPerStrip = origheight;\n    }\n\n    int writedLines = 0;\n    int nextStripOffset = 0;\n    int globalLineCounter = 0;\n\n    unsigned int *matrixTopLine = (uint32 *) malloc(sizeof(jint) * origwidth);\n    unsigned int *matrixBottomLine = (uint32 *) malloc(sizeof(jint) * origwidth);\n\n    int isSecondRasterExist = 0;\n    int ok = 1;\n    uint32 rows_to_write = 0;\n\n    //check for error\n    if (setjmp(NativeDecoder::strip_buf)) {\n        if (raster) {\n            _TIFFfree(raster);\n            raster = NULL;\n        }\n        if (rasterForBottomLine) {\n            _TIFFfree(rasterForBottomLine);\n            rasterForBottomLine = NULL;\n        }\n        if (matrixTopLine) {\n            _TIFFfree(matrixTopLine);\n            matrixTopLine = NULL;\n        }\n        if (matrixBottomLine) {\n            _TIFFfree(matrixBottomLine);\n            matrixBottomLine = NULL;\n        }\n\n        const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n        LOGE(err);\n        if (throwException) {\n            throwDecodeFileException(err);\n        }\n\n        return NULL;\n    }\n\n    for (int i = 0; i < stripMax*rowPerStrip; i += rowPerStrip) {\n\n            sendProgress(i * origwidth, progressTotal);\n\n            //if second raster is exist - copy it to work raster end decode next strip\n            if (isSecondRasterExist) {\n                _TIFFmemcpy(raster, rasterForBottomLine, origwidth * rowPerStrip * sizeof (uint32));\n\n                //If next strip is exist - decode it, invert lines\n                if (i + rowPerStrip < stripMax*rowPerStrip) {\n                    TIFFReadRGBAStrip(image, i+rowPerStrip, rasterForBottomLine);\n                    isSecondRasterExist = 1;\n\n                    rows_to_write = 0;\n                    if ( i + rowPerStrip * 2 > origheight )\n                        rows_to_write = origheight - i - rowPerStrip;\n                    else\n                        rows_to_write = rowPerStrip;\n\n                    if (origorientation <= 4) {\n                        for (int line = 0; line < rows_to_write / 2; line++) {\n                            unsigned int  *top_line, *bottom_line;\n\n                            top_line = rasterForBottomLine + origwidth * line;\n                            bottom_line = rasterForBottomLine + origwidth * (rows_to_write - line - 1);\n\n                            _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                        }\n                    }\n                } else {\n                    isSecondRasterExist = 0;\n                }\n            } else {\n                //if second raster is not exist - first processing - read first and second raster\n                 TIFFReadRGBAStrip(image, i, raster);\n                 //invert lines, because libtiff origin is bottom left instead of top left\n                 rows_to_write = 0;\n                 if( i + rowPerStrip > origheight )\n                    rows_to_write = origheight - i;\n                 else\n                    rows_to_write = rowPerStrip;\n\n                 if (origorientation <= 4) {\n                     for (int line = 0; line < rows_to_write / 2; line++) {\n                         unsigned int  *top_line, *bottom_line;\n\n                         top_line = raster + origwidth * line;\n                         bottom_line = raster + origwidth * (rows_to_write - line - 1);\n\n                         _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                         _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                         _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                     }\n                 }\n\n                 //if next strip is exist - read it and invert lines\n                 if (i + rowPerStrip < origheight) {\n                    TIFFReadRGBAStrip(image, i+rowPerStrip, rasterForBottomLine);\n                    isSecondRasterExist = 1;\n\n                    //invert lines, because libtiff origin is bottom left instead of top left\n                    rows_to_write = 0;\n                    if ( i + rowPerStrip * 2 > origheight )\n                        rows_to_write = origheight - i - rowPerStrip;\n                    else\n                        rows_to_write = rowPerStrip;\n                    if (origorientation <= 4) {\n                        for (int line = 0; line < rows_to_write / 2; line++) {\n                            unsigned int  *top_line, *bottom_line;\n\n                            top_line = rasterForBottomLine + origwidth * line;\n                            bottom_line = rasterForBottomLine + origwidth * (rows_to_write - line - 1);\n\n                            _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                        }\n                    }\n                 }\n\n            }\n\n            if (inSampleSize == 1) {\n                int byteToCopy = 0;\n                if (i + rowPerStrip < origheight) {\n                    byteToCopy = sizeof(unsigned int) * rowPerStrip * origwidth;\n                } else {\n                    byteToCopy = sizeof(unsigned int) * rows_to_write * origwidth;\n                }\n                int position = i * origwidth;\n                memcpy(&pixels[position], raster, byteToCopy);\n                //sendProgress(position, progressTotal);\n            } else {\n                if (isSecondRasterExist) {\n                    _TIFFmemcpy(matrixBottomLine, rasterForBottomLine /*+ lineAddrToCopyBottomLine * origwidth*/, sizeof(unsigned int) * origwidth);\n                }\n                 int workWritedLines = writedLines;\n                 for (int resBmpY = workWritedLines, workY = 0; resBmpY < *bitmapheight && workY < rowPerStrip; /*wj++,*/ workY ++/*= inSampleSize*/) {\n\n                 if (checkStop()) {\n                     if (raster) {\n                         _TIFFfree(raster);\n                         raster = NULL;\n                     }\n                     if (rasterForBottomLine) {\n                         _TIFFfree(rasterForBottomLine);\n                         rasterForBottomLine = NULL;\n                     }\n                     if (matrixTopLine) {\n                         _TIFFfree(matrixTopLine);\n                         matrixTopLine = NULL;\n                     }\n                     if (matrixBottomLine) {\n                         _TIFFfree(matrixBottomLine);\n                         matrixBottomLine = NULL;\n                     }\n                     LOGI(\"Thread stopped\");\n                     return NULL;\n                 }\n\n                    // if total line of source image is equal to inSampleSize*N then process this line\n                    if (globalLineCounter % inSampleSize == 0) {\n                        for (int resBmpX = 0, workX = 0; resBmpX < *bitmapwidth; resBmpX++, workX += inSampleSize) {\n\n                            //Apply filter to pixel\n                            jint crPix = raster[workY * origwidth + workX];\n                            int sum = 1;\n\n\n                            int alpha = colorMask & crPix >> 24;\n                            int red = colorMask & crPix >> 16;\n                            int green = colorMask & crPix >> 8;\n                            int blue = colorMask & crPix;\n\n\n                            //topleft\n                            if (workX - 1 >= 0 && workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX - 1 >= 0 && workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n                            //top\n                            if (workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            // topright\n                            if (workX + 1 < origwidth && workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX + 1 < origwidth && workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //right\n                            if (workX + 1 < origwidth) {\n                                crPix = raster[workY * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottomright\n                            if (workX + 1 < origwidth && workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX + 1 < origwidth && workY + 1 == rowPerStrip && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottom\n                            if (workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workY + 1 == rowPerStrip && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottomleft\n                            if (workX - 1 >= 0 && workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX - 1 >= 0 && workY + 1 == rowPerStrip  && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n\n                            //left\n                            if (workX - 1 >= 0) {\n                                crPix = raster[workY * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            red /= sum;\n                            if (red > 255) red = 255;\n                            if (red < 0) red = 0;\n\n                            green /= sum;\n                            if (green > 255) green = 255;\n                            if (green < 0) green = 0;\n\n                            blue /= sum;\n                            if (blue > 255) blue = 255;\n                            if (blue < 0) blue = 0;\n\n                            alpha /= sum;///= sum;\n                            if (alpha > 255) alpha = 255;\n                            if (alpha < 0) alpha = 0;\n\n                            crPix = (alpha << 24) | (red << 16) | (green << 8) | (blue);\n\n                            pixels[resBmpY * *bitmapwidth + resBmpX] = crPix;\n                        }\n                        //if line was processed - increment counter of lines that was writed to result image\n                        writedLines++;\n                        //and incremetncounter of current Y for writing\n                        resBmpY++;\n                    }\n                    if (workY == rowPerStrip - 1 && i + rowPerStrip < origheight) {\n                        _TIFFmemcpy(matrixTopLine, raster + workY * origwidth, sizeof(unsigned int) * origwidth);\n                    }\n                    //incremetn global source image line counter\n                    globalLineCounter++;\n\n                }\n            }\n        }\n        LOGI(\"Decoding finished. Free memmory\");\n\n        //Close Buffers\n        if (raster) {\n            _TIFFfree(raster);\n            raster = NULL;\n        }\n\n        if (rasterForBottomLine) {\n            _TIFFfree(rasterForBottomLine);\n            rasterForBottomLine = NULL;\n        }\n\n        if (matrixTopLine) {\n            _TIFFfree(matrixTopLine);\n            matrixTopLine = NULL;\n        }\n\n        if (matrixBottomLine) {\n            _TIFFfree(matrixBottomLine);\n            matrixBottomLine = NULL;\n        }\n\n        if (useOrientationTag) {\n            uint32 buf;\n            //fixOrientation(pixels, pixelsBufferSize, *bitmapwidth, *bitmapheight);\n            switch(origorientation) {\n                 case ORIENTATION_TOPLEFT:\n                 case ORIENTATION_TOPRIGHT:\n                    break;\n                 case ORIENTATION_BOTRIGHT:\n                 case ORIENTATION_BOTLEFT:\n                    flipPixelsVertical(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                 case ORIENTATION_LEFTTOP:\n                    rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_RIGHTTOP:\n                    rotateRaster(pixels, 270, bitmapwidth, bitmapheight);\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_RIGHTBOT:\n                    rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                    buf= *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_LEFTBOT:\n                    rotateRaster(pixels, 270, bitmapwidth, bitmapheight);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n            }\n\n        } else if (origorientation == 2 || origorientation == 3 || origorientation == 6 || origorientation == 7) {\n            flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n        }\n\n        return pixels;\n}",
    "jint * NativeDecoder::getSampledRasterFromStripWithBounds(int inSampleSize, int *bitmapwidth, int *bitmapheight) {\n\n    //init signal handler for catch SIGSEGV error that could be raised in libtiff\n    struct sigaction act;\n    memset(&act, 0, sizeof(act));\n    sigemptyset(&act.sa_mask);\n    act.sa_sigaction = stripErrorHandler;\n    act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n    if(sigaction(SIGSEGV, &act, 0) < 0) {\n        LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n    }\n\n    LOGII(\"width\", origwidth);\n    LOGII(\"height\", origheight);\n\n    jint *pixels = NULL;\n    *bitmapwidth = origwidth / inSampleSize;\n    *bitmapheight = boundHeight / inSampleSize;//origheight / inSampleSize;\n    uint32 pixelsBufferSize = *bitmapwidth * *bitmapheight;\n    int origImageBufferSize = origwidth * origheight;\n\n    LOGII(\"new width\", *bitmapwidth);\n    LOGII(\"new height\", *bitmapheight);\n\n    uint32 stripSize = TIFFStripSize (image);\n    uint32 stripMax = TIFFNumberOfStrips (image);\n    LOGII(\"strip size \", stripSize);\n    LOGII(\"stripMax  \", stripMax);\n    int rowPerStrip = -1;\n    TIFFGetField(image, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    LOGII(\"rowsperstrip\", rowPerStrip);\n\n    unsigned long estimateMem = 0;\n    estimateMem += (sizeof(jint) * pixelsBufferSize); //temp buffer for decoded pixels\n    estimateMem += (sizeof(jint) * (boundWidth / inSampleSize) * (boundHeight/inSampleSize)); //final buffer that will store original image\n    estimateMem += (origwidth * sizeof(uint32)); //work line for rotate strip\n    estimateMem += (origwidth * rowPerStrip * sizeof (uint32) * 2); //current and next strips\n    estimateMem += (sizeof(jint) * origwidth * 2); //bottom and top lines for reading pixel(matrixBottomLine, matrixTopLine)\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory) {\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return NULL;\n    }\n\n    progressTotal = pixelsBufferSize + (boundWidth/inSampleSize) * (boundHeight / inSampleSize);\n    sendProgress(0, progressTotal);\n    jlong processedProgress = 0;\n\n    pixels = (jint *) malloc(sizeof(jint) * pixelsBufferSize);\n    if (pixels == NULL) {\n        LOGE(\"Can\\'t allocate memory for temp buffer\");\n        return NULL;\n    }\n\n    uint32* work_line_buf = (uint32 *)_TIFFmalloc(origwidth * sizeof(uint32));\n\n    uint32* raster;\n    uint32* rasterForBottomLine; // in this raster copy next strip for getting bottom line in matrix color selection\n    if (rowPerStrip == -1 && stripMax == 1) {\n            raster = (uint32 *)_TIFFmalloc(origImageBufferSize * sizeof (uint32));\n            rasterForBottomLine = (uint32 *)_TIFFmalloc(origImageBufferSize * sizeof (uint32));\n    } else {\n            raster = (uint32 *)_TIFFmalloc(origwidth * rowPerStrip * sizeof (uint32));\n            rasterForBottomLine = (uint32 *)_TIFFmalloc(origwidth * rowPerStrip * sizeof (uint32));\n    }\n    if (rowPerStrip == -1) {\n            rowPerStrip = origheight;\n    }\n\n    int writedLines = 0;\n    int nextStripOffset = 0;\n    int globalLineCounter = 0;\n\n    unsigned int *matrixTopLine = (uint32 *) malloc(sizeof(jint) * origwidth);\n    unsigned int *matrixBottomLine = (uint32 *) malloc(sizeof(jint) * origwidth);\n\n    int isSecondRasterExist = 0;\n    int ok = 1;\n    uint32 rows_to_write = 0;\n\n    //check for error\n    if (setjmp(NativeDecoder::strip_buf)) {\n        if (raster) {\n            _TIFFfree(raster);\n            raster = NULL;\n        }\n        if (rasterForBottomLine) {\n            _TIFFfree(rasterForBottomLine);\n            rasterForBottomLine = NULL;\n        }\n        if (matrixTopLine) {\n            _TIFFfree(matrixTopLine);\n            matrixTopLine = NULL;\n        }\n        if (matrixBottomLine) {\n            _TIFFfree(matrixBottomLine);\n            matrixBottomLine = NULL;\n        }\n\n        const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n        LOGE(err);\n        if (throwException) {\n            throwDecodeFileException(err);\n        }\n\n        return NULL;\n    }\n\n    for (int i = 0; (i < stripMax*rowPerStrip || i > boundY + boundHeight) ; i += rowPerStrip) {\n\n            if (i + rowPerStrip <= boundY) {\n                continue;\n            }\n            if (i > boundY + boundHeight) {\n                break;\n            }\n\n            sendProgress(processedProgress * *bitmapwidth, progressTotal);\n            processedProgress += rowPerStrip/inSampleSize;\n\n            //if second raster is exist - copy it to work raster end decode next strip\n            if (isSecondRasterExist) {\n                _TIFFmemcpy(raster, rasterForBottomLine, origwidth * rowPerStrip * sizeof (uint32));\n\n                //If next strip is exist - decode it, invert lines\n                if (i + rowPerStrip < stripMax*rowPerStrip) {\n                    TIFFReadRGBAStrip(image, i+rowPerStrip, rasterForBottomLine);\n                    isSecondRasterExist = 1;\n\n                    rows_to_write = 0;\n                    if ( i + rowPerStrip * 2 > origheight )\n                        rows_to_write = origheight - i - rowPerStrip;\n                    else\n                        rows_to_write = rowPerStrip;\n\n                    if (origorientation <= 4) {\n                        for (int line = 0; line < rows_to_write / 2; line++) {\n                            unsigned int  *top_line, *bottom_line;\n\n                            top_line = rasterForBottomLine + origwidth * line;\n                            bottom_line = rasterForBottomLine + origwidth * (rows_to_write - line - 1);\n\n                            _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                        }\n                    }\n                } else {\n                    isSecondRasterExist = 0;\n                }\n            } else {\n                //if second raster is not exist - first processing - read first and second raster\n                 TIFFReadRGBAStrip(image, i, raster);\n                 //invert lines, because libtiff origin is bottom left instead of top left\n                 rows_to_write = 0;\n                 if( i + rowPerStrip > origheight )\n                    rows_to_write = origheight - i;\n                 else\n                    rows_to_write = rowPerStrip;\n\n                 if (origorientation <= 4) {\n                     for (int line = 0; line < rows_to_write / 2; line++) {\n                         unsigned int  *top_line, *bottom_line;\n\n                         top_line = raster + origwidth * line;\n                         bottom_line = raster + origwidth * (rows_to_write - line - 1);\n\n                         _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                         _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                         _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                     }\n                 }\n\n                 //if next strip is exist - read it and invert lines\n                 if (i + rowPerStrip < origheight) {\n                    TIFFReadRGBAStrip(image, i+rowPerStrip, rasterForBottomLine);\n                    isSecondRasterExist = 1;\n\n                    //invert lines, because libtiff origin is bottom left instead of top left\n                    rows_to_write = 0;\n                    if ( i + rowPerStrip * 2 > origheight )\n                        rows_to_write = origheight - i - rowPerStrip;\n                    else\n                        rows_to_write = rowPerStrip;\n                    if (origorientation <= 4) {\n                        for (int line = 0; line < rows_to_write / 2; line++) {\n                            unsigned int  *top_line, *bottom_line;\n\n                            top_line = rasterForBottomLine + origwidth * line;\n                            bottom_line = rasterForBottomLine + origwidth * (rows_to_write - line - 1);\n\n                            _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                        }\n                    }\n                 }\n\n            }\n\n            /*if (inSampleSize == 1) {\n                int byteToCopy = 0;\n                if (i + rowPerStrip < origheight) {\n                    byteToCopy = sizeof(unsigned int) * rowPerStrip * origwidth;\n                } else {\n                    byteToCopy = sizeof(unsigned int) * rows_to_write * origwidth;\n                }\n                int position = i * origwidth;\n                memcpy(&pixels[position], raster, byteToCopy);\n                //sendProgress(position, progressTotal);\n            } else {*/\n                if (isSecondRasterExist) {\n                    _TIFFmemcpy(matrixBottomLine, rasterForBottomLine /*+ lineAddrToCopyBottomLine * origwidth*/, sizeof(unsigned int) * origwidth);\n                }\n                 int workWritedLines = writedLines;\n                 for (int resBmpY = workWritedLines, workY = 0; resBmpY < *bitmapheight && workY < rowPerStrip; /*wj++,*/ workY ++/*= inSampleSize*/) {\n\n                 if (checkStop()) {\n                     if (raster) {\n                         _TIFFfree(raster);\n                         raster = NULL;\n                     }\n                     if (rasterForBottomLine) {\n                         _TIFFfree(rasterForBottomLine);\n                         rasterForBottomLine = NULL;\n                     }\n                     if (matrixTopLine) {\n                         _TIFFfree(matrixTopLine);\n                         matrixTopLine = NULL;\n                     }\n                     if (matrixBottomLine) {\n                         _TIFFfree(matrixBottomLine);\n                         matrixBottomLine = NULL;\n                     }\n                     LOGI(\"Thread stopped\");\n                     return NULL;\n                 }\n\n                    // if total line of source image is equal to inSampleSize*N then process this line\n                    if (globalLineCounter % inSampleSize == 0) {\n                        for (int resBmpX = 0, workX = 0; resBmpX < *bitmapwidth; workX += inSampleSize) {\n\n                            /*if (workX <= boundX) {\n                                continue;\n                            }\n                            if (workX > boundX + boundWidth) {\n                                break;\n                            }\n                            LOGII(\"J\", workX);*/\n\n                            //Apply filter to pixel\n                            jint crPix = raster[workY * origwidth + workX];\n                            int sum = 1;\n\n\n                            int alpha = colorMask & crPix >> 24;\n                            int red = colorMask & crPix >> 16;\n                            int green = colorMask & crPix >> 8;\n                            int blue = colorMask & crPix;\n\n\n                            //topleft\n                            if (workX - 1 >= 0 && workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX - 1 >= 0 && workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n                            //top\n                            if (workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            // topright\n                            if (workX + 1 < origwidth && workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX + 1 < origwidth && workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //right\n                            if (workX + 1 < origwidth) {\n                                crPix = raster[workY * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottomright\n                            if (workX + 1 < origwidth && workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX + 1 < origwidth && workY + 1 == rowPerStrip && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottom\n                            if (workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workY + 1 == rowPerStrip && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottomleft\n                            if (workX - 1 >= 0 && workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX - 1 >= 0 && workY + 1 == rowPerStrip  && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n\n                            //left\n                            if (workX - 1 >= 0) {\n                                crPix = raster[workY * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            red /= sum;\n                            if (red > 255) red = 255;\n                            if (red < 0) red = 0;\n\n                            green /= sum;\n                            if (green > 255) green = 255;\n                            if (green < 0) green = 0;\n\n                            blue /= sum;\n                            if (blue > 255) blue = 255;\n                            if (blue < 0) blue = 0;\n\n                            alpha /= sum;///= sum;\n                            if (alpha > 255) alpha = 255;\n                            if (alpha < 0) alpha = 0;\n\n                            crPix = (alpha << 24) | (red << 16) | (green << 8) | (blue);\n\n                            pixels[resBmpY * *bitmapwidth + resBmpX] = crPix;\n\n                            resBmpX++;\n                        }\n                        //if line was processed - increment counter of lines that was writed to result image\n                        writedLines++;\n                        //and incremetncounter of current Y for writing\n                        resBmpY++;\n                    }\n                    if (workY == rowPerStrip - 1 && i + rowPerStrip < origheight) {\n                        _TIFFmemcpy(matrixTopLine, raster + workY * origwidth, sizeof(unsigned int) * origwidth);\n                    }\n                    //incremetn global source image line counter\n                    globalLineCounter++;\n\n                }\n            /*}*/\n        }\n        LOGI(\"Decoding finished. Free memmory\");\n\n        //Close Buffers\n        if (raster) {\n            _TIFFfree(raster);\n            raster = NULL;\n        }\n\n        if (rasterForBottomLine) {\n            _TIFFfree(rasterForBottomLine);\n            rasterForBottomLine = NULL;\n        }\n\n        if (matrixTopLine) {\n            _TIFFfree(matrixTopLine);\n            matrixTopLine = NULL;\n        }\n\n        if (matrixBottomLine) {\n            _TIFFfree(matrixBottomLine);\n            matrixBottomLine = NULL;\n        }\n\n        processedProgress *= *bitmapwidth;\n\n        if (useOrientationTag) {\n            uint32 buf;\n            switch(origorientation) {\n                 case ORIENTATION_TOPLEFT:\n                 case ORIENTATION_TOPRIGHT:\n                    break;\n                 case ORIENTATION_BOTRIGHT:\n                 case ORIENTATION_BOTLEFT:\n                    flipPixelsVertical(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                 case ORIENTATION_LEFTTOP:\n                    rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_RIGHTTOP:\n                    rotateRaster(pixels, 270, bitmapwidth, bitmapheight);\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_RIGHTBOT:\n                    rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                    buf= *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_LEFTBOT:\n                    rotateRaster(pixels, 270, bitmapwidth, bitmapheight);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n            }\n\n        } else if (origorientation == 2 || origorientation == 3 || origorientation == 6 || origorientation == 7) {\n            flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n        }\n\n        uint32 tmpPixelBufferSize = (boundWidth / inSampleSize) * (boundHeight / inSampleSize);\n\n        estimateMem = (sizeof(jint) * pixelsBufferSize); //temp buffer for decoded pixels\n        estimateMem += (sizeof(jint) * tmpPixelBufferSize); //final buffer that will store original image\n        LOGII(\"estimateMem\", estimateMem);\n        if (estimateMem > availableMemory) {\n            if (throwException) {\n                throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n            }\n            return NULL;\n        }\n\n        jint* tmpPixels = (jint *) malloc(sizeof(jint) * tmpPixelBufferSize);\n        uint32 startPosX = 0;\n\n        if (useOrientationTag && (origorientation == ORIENTATION_TOPRIGHT || origorientation == ORIENTATION_BOTRIGHT\n                                    || origorientation == ORIENTATION_LEFTBOT || origorientation == ORIENTATION_RIGHTBOT)) {\n            startPosX = *bitmapwidth - boundX/inSampleSize;\n            for (int ox = startPosX, nx = 0; nx < boundWidth/inSampleSize; ox--, nx++) {\n                sendProgress(processedProgress + nx * boundWidth/inSampleSize, progressTotal);\n                for (int oy = 0, ny = 0; ny < boundHeight/inSampleSize; oy++, ny++) {\n                    if (useOrientationTag && (origorientation > 4)) {\n                        tmpPixels[nx * (boundHeight/inSampleSize) + ny] = pixels[ox * *bitmapheight + oy];\n                    } else {\n                        tmpPixels[ny * (boundWidth/inSampleSize) + nx] = pixels[oy * *bitmapwidth + ox];\n                    }\n                }\n            }\n        } else {\n            startPosX = boundX/inSampleSize;\n            for (int ox = startPosX, nx = 0; nx < boundWidth/inSampleSize; ox++, nx++) {\n                sendProgress(processedProgress + nx * boundWidth/inSampleSize, progressTotal);\n                for (int oy = 0, ny = 0; ny < boundHeight/inSampleSize; oy++, ny++) {\n                    if (useOrientationTag && (origorientation > 4)) {\n                        tmpPixels[nx * (boundHeight/inSampleSize) + ny] = pixels[ox * *bitmapheight + oy];\n                    } else {\n                        tmpPixels[ny * (boundWidth/inSampleSize) + nx] = pixels[oy * *bitmapwidth + ox];\n                    }\n                }\n            }\n        }\n\n        free(pixels);\n        pixels = tmpPixels;\n        *bitmapwidth = boundWidth/inSampleSize;\n        *bitmapheight = boundHeight/inSampleSize;\n\n        return pixels;\n}",
    "jint * NativeDecoder::getSampledRasterFromTile(int inSampleSize, int *bitmapwidth, int *bitmapheight) {\n\n        //init signal handler for catch SIGSEGV error that could be raised in libtiff\n        struct sigaction act;\n        memset(&act, 0, sizeof(act));\n        sigemptyset(&act.sa_mask);\n        act.sa_sigaction = tileErrorHandler;\n        act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n        if(sigaction(SIGSEGV, &act, 0) < 0) {\n            LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n        }\n\n        jint *pixels = NULL;\n        *bitmapwidth = origwidth / inSampleSize;\n        *bitmapheight = origheight / inSampleSize;\n        uint32 pixelsBufferSize = *bitmapwidth * *bitmapheight;\n\n        uint32 tileWidth = 0, tileHeight = 0;\n        TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileWidth);\n        TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileHeight);\n\n        unsigned long estimateMem = 0;\n        estimateMem += (sizeof(jint) * pixelsBufferSize); //buffer for decoded pixels\n        estimateMem += (tileWidth * tileHeight * sizeof(uint32)) * 3; //current, left and right tiles buffers\n        estimateMem += (tileWidth * sizeof(uint32)); //work line for rotate tile\n        LOGII(\"estimateMem\", estimateMem);\n        if (estimateMem > availableMemory) {\n            if (throwException) {\n                throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n            }\n            return NULL;\n        }\n\n        pixels = (jint *) malloc(sizeof(jint) * pixelsBufferSize);\n        if (pixels == NULL) {\n            LOGE(\"Can\\'t allocate memory for temp buffer\");\n            return NULL;\n        }\n\n        uint32 row, column;\n\n        //main worker tile\n        uint32 *rasterTile = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n        //left tile\n        uint32 *rasterTileLeft = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n        //right tile\n        uint32 *rasterTileRight = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n\n        uint32 *work_line_buf = (uint32*)_TIFFmalloc(tileWidth * sizeof (uint32));\n\n        //this variable calculate processed pixels for x and y direction to make right offsets at the begining of next tile\n        //offset calculated from condition globalProcessed % inSampleSize should be 0\n        uint32 globalProcessedX = 0;\n        uint32 globalProcessedY = 0;\n\n        //check for error\n        if (setjmp(NativeDecoder::tile_buf)) {\n            if (rasterTile) {\n                _TIFFfree(rasterTile);\n                rasterTile = NULL;\n            }\n            if (rasterTileLeft) {\n                _TIFFfree(rasterTileLeft);\n                rasterTileLeft = NULL;\n            }\n            if (rasterTileRight) {\n                _TIFFfree(rasterTileRight);\n                rasterTileRight = NULL;\n            }\n            if (work_line_buf) {\n                _TIFFfree(work_line_buf);\n                work_line_buf = NULL;\n            }\n\n            const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n            LOGE(err);\n            if (throwException) {\n                throwDecodeFileException(err);\n            }\n\n            return NULL;\n        }\n\n        for (row = 0; row < origheight; row += tileHeight) {\n            short leftTileExists = 0;\n            short rightTileExists = 0;\n            for (column = 0; column < origwidth; column += tileWidth) {\n                sendProgress(row * origwidth + column, progressTotal);\n\n                //If not first column - we should have previous tile - copy it to left tile buffer\n                if (column != 0) {\n                    _TIFFmemcpy(rasterTileLeft, rasterTile, tileWidth * tileHeight * sizeof(uint32));\n                    leftTileExists = 1;\n                } else {\n                    leftTileExists = 0;\n                }\n\n                //if current column + tile width is less than origin width - we have right tile - copy it to current tile and read next tile to rasterTileRight buffer\n                if (column + tileWidth < origwidth && rightTileExists) {\n                    _TIFFmemcpy(rasterTile, rasterTileRight, tileWidth * tileHeight * sizeof(uint32));\n                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);\n                    rightTileExists = 1;\n                } else if (column + tileWidth < origwidth) {\n                    //have right tile but this is first tile in row, so need to read raster and right raster\n                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);\n                    TIFFReadRGBATile(image, column, row, rasterTile);\n                    rightTileExists = 1;\n\n                    //in that case we also need to invert lines in rasterTile\n                    switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                    }\n                } else {\n                    //otherwise we haven't right tile buffer, so we should read tile to current buffer\n                    TIFFReadRGBATile(image, column, row, rasterTile);\n                    rightTileExists = 0;\n                }\n\n                //if we have right tile - current tile already rotated and we need to rotate only right tile\n                if (rightTileExists) {\n                    switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                    }\n                } else {\n                    //otherwise - current tile not rotated so rotate it\n                    //tile orig is on bottom left - should change lines\n                     switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                    }\n                }\n\n                if (inSampleSize > 1 )\n                {\n                    //Tile could begin from not filled pixel(pixel[x,y] == 0). This variables allow to calculate begining of filled pixels\n                    int tileStartDataX = -1;\n                    int tileStartDataY = -1;\n\n                    for (int origTileY = 0, pixY = row/inSampleSize; origTileY < tileHeight && pixY < *bitmapheight; origTileY++) {\n\n                        if (checkStop()) {\n                            if (rasterTile) {\n                                _TIFFfree(rasterTile);\n                                rasterTile = NULL;\n                            }\n                            if (rasterTileLeft) {\n                                _TIFFfree(rasterTileLeft);\n                                rasterTileLeft = NULL;\n                            }\n                            if (rasterTileRight) {\n                                _TIFFfree(rasterTileRight);\n                                rasterTileRight = NULL;\n                            }\n                            if (work_line_buf) {\n                                _TIFFfree(work_line_buf);\n                                work_line_buf = NULL;\n                            }\n                            LOGI(\"Thread stopped\");\n                            return NULL;\n                        }\n\n                        if (tileStartDataY != -1 && globalProcessedY % inSampleSize != 0) {\n                            if (tileStartDataY != -1) {\n                                globalProcessedY++;\n                            }\n                        }\n                        else\n                        {\n                            for (int origTileX = 0, pixX = column/inSampleSize; origTileX < tileWidth && pixX < *bitmapwidth; origTileX++) {\n                                if (tileStartDataX != -1 && globalProcessedX % inSampleSize != 0)\n                                {\n                                    if (tileStartDataX != -1) {\n                                        globalProcessedX++;\n                                    }\n                                }\n                                else\n                                {\n                                    uint32 srcPosition = origTileY * tileWidth + origTileX;\n                                    if (rasterTile[srcPosition] != 0) {\n                                        if (tileStartDataX == -1) {\n                                            tileStartDataX = origTileX;\n                                        }\n                                        if (tileStartDataY == -1) {\n                                            tileStartDataY = origTileY;\n                                        }\n\n                                        //Apply filter to pixel\n                                        jint crPix = rasterTile[srcPosition];//origBuffer[j1 * origwidth + i1];\n                                        int sum = 1;\n\n                                        int alpha = colorMask & crPix >> 24;\n                                        int red = colorMask & crPix >> 16;\n                                        int green = colorMask & crPix >> 8;\n                                        int blue = colorMask & crPix;\n\n                                        //using kernel 3x3\n\n                                        //topleft\n                                        if (origTileX - 1 >= 0 && origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY - 1 >= 0 && leftTileExists) {\n                                            crPix = rasterTileLeft[(origTileY - 1) * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //top\n                                        if (origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        // topright\n                                        if (origTileX + 1 < tileWidth && origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY - 1 >= 0 && rightTileExists) {\n                                            crPix = rasterTileRight[(origTileY - 1) * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //right\n                                        if (origTileX + 1 < tileWidth) {\n                                            crPix = rasterTile[origTileY * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (rightTileExists) {\n                                            crPix = rasterTileRight[origTileY * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottomright\n                                        if (origTileX + 1 < tileWidth && origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY + 1 < tileHeight && rightTileExists) {\n                                            crPix = rasterTileRight[(origTileY + 1) * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottom\n                                        if (origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottomleft\n                                        if (origTileX - 1 >= 0 && origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY + 1 < tileHeight && leftTileExists) {\n                                            crPix = rasterTileLeft[(origTileY + 1) * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //left\n                                        if (origTileX - 1 >= 0) {\n                                            crPix = rasterTile[origTileY * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (leftTileExists) {\n                                            crPix = rasterTileLeft[origTileY * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        red /= sum;\n                                        if (red > 255) red = 255;\n                                        if (red < 0) red = 0;\n\n                                        green /= sum;\n                                        if (green > 255) green = 255;\n                                        if (green < 0) green = 0;\n\n                                        blue /= sum;\n                                        if (blue > 255) blue = 255;\n                                        if (blue < 0) blue = 0;\n\n                                        alpha /= sum;///= sum;\n                                        if (alpha > 255) alpha = 255;\n                                        if (alpha < 0) alpha = 0;\n\n                                        crPix = (alpha << 24) | (red << 16) | (green << 8) | (blue);\n\n                                        int position;\n                                        if (origorientation <= 4) {\n                                            position = pixY * *bitmapwidth + pixX;\n                                        } else {\n                                            position = pixX * *bitmapheight + pixY;\n                                        }\n                                        pixels[position] = crPix;\n                                    } else {\n                                        if (tileStartDataX != -1) tileStartDataX = -1;\n                                        if (tileStartDataY != -1) tileStartDataY = -1;\n                                    }\n\n                                    if (tileStartDataX != -1) {\n                                        pixX++;\n                                        globalProcessedX++;\n                                    }\n\n                                }\n                            }\n                            if (tileStartDataY != -1) {\n                                pixY++;\n                                globalProcessedY++;\n                            }\n                        }\n                    }\n                } else {\n                    int rowHasPixels = 0;\n                        for (int th = 0, bh = 0; th < tileHeight; th++) {\n                            for (int tw = 0, bw = 0; tw < tileWidth; tw++) {\n                                uint32 srcPosition = th * tileWidth + tw;\n                                if (rasterTile[srcPosition] != 0) {\n                                    int position = 0;\n                                    if (origorientation <= 4) {\n                                        position = (row + bh) * *bitmapwidth + column + bw;\n                                    } else {\n                                        position = (column + bw) * *bitmapheight + row + bh;\n                                    }\n                                    pixels[position] = rasterTile[srcPosition];\n                                    rowHasPixels = 1;\n                                    bw++;\n                                }\n                            }\n                            if (rowHasPixels) {\n                                bh++;\n                                rowHasPixels = 0;\n                            }\n                        }\n                }\n            }\n        }\n\n        if (rasterTile) {\n            _TIFFfree(rasterTile);\n            rasterTile = NULL;\n        }\n        if (rasterTileLeft) {\n            _TIFFfree(rasterTileLeft);\n            rasterTileLeft = NULL;\n        }\n        if (rasterTileRight) {\n            _TIFFfree(rasterTileRight);\n            rasterTileRight = NULL;\n        }\n        if (work_line_buf) {\n            _TIFFfree(work_line_buf);\n            work_line_buf = NULL;\n        }\n\n        if (useOrientationTag) {\n            switch (origorientation) {\n                case ORIENTATION_TOPLEFT:\n                case ORIENTATION_LEFTTOP:\n                    break;\n                case ORIENTATION_TOPRIGHT:\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                case ORIENTATION_RIGHTTOP:\n                    flipPixelsHorizontal(*bitmapheight, *bitmapwidth, pixels);\n                    break;\n                case ORIENTATION_BOTRIGHT:\n                case ORIENTATION_RIGHTBOT:\n                    rotateRaster(pixels, 180, bitmapwidth, bitmapheight);\n                    break;\n                case ORIENTATION_BOTLEFT:\n                    flipPixelsVertical(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                case ORIENTATION_LEFTBOT:\n                    flipPixelsVertical(*bitmapheight, *bitmapwidth, pixels);\n                    break;\n            }\n        } else {\n            if (origorientation > 4) {\n                uint32 buf = *bitmapwidth;\n                *bitmapwidth = *bitmapheight;\n                *bitmapheight = buf;\n                rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n            }\n        }\n\n        return pixels;\n}",
    "jint * NativeDecoder::getSampledRasterFromTileWithBounds(int inSampleSize, int *bitmapwidth, int *bitmapheight) {\n\n        //init signal handler for catch SIGSEGV error that could be raised in libtiff\n        struct sigaction act;\n        memset(&act, 0, sizeof(act));\n        sigemptyset(&act.sa_mask);\n        act.sa_sigaction = tileErrorHandler;\n        act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n        if(sigaction(SIGSEGV, &act, 0) < 0) {\n            LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n        }\n\n\n        //First read all tiles that are on necessary area\n\n        uint32 tileWidth = 0, tileHeight = 0;\n        TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileWidth);\n        TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileHeight);\n\n        //find first and last tile to process\n        uint32 firstTileX = (uint32)(boundX / tileWidth);\n        uint32 firstTileY = (uint32)(boundY / tileHeight);\n\n        uint32 lastTileX = (uint32)((boundX + boundWidth) / tileWidth) + 1;\n        uint32 lastTileY = (uint32)((boundY + boundHeight) / tileHeight) + 1;\n\n        jint *pixels = NULL;\n        *bitmapwidth = /*boundWidth*/ (lastTileX - firstTileX) * tileWidth / inSampleSize;//origwidth / inSampleSize;\n        *bitmapheight = /*boundHeight*/ (lastTileY - firstTileY) * tileHeight / inSampleSize;//origheight / inSampleSize;\n        uint32 pixelsBufferSize = *bitmapwidth * *bitmapheight;\n\n         unsigned long estimateMem = 0;\n         estimateMem += (sizeof(jint) * pixelsBufferSize); //buffer for decoded pixels\n         estimateMem += (tileWidth * tileHeight * sizeof(uint32)) * 3; //current, left and right tiles buffers\n         estimateMem += (tileWidth * sizeof(uint32)); //work line for rotate tile\n         LOGII(\"estimateMem\", estimateMem);\n         if (estimateMem > availableMemory) {\n            if (throwException) {\n                throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n            }\n            return NULL;\n         }\n\n        pixels = (jint *) malloc(sizeof(jint) * pixelsBufferSize);\n        if (pixels == NULL) {\n            LOGE(\"Can\\'t allocate memory for temp buffer\");\n            return NULL;\n        }\n\n        progressTotal = pixelsBufferSize + (boundWidth/inSampleSize) * (boundHeight/inSampleSize);\n        sendProgress(0, progressTotal);\n        jlong processedProgress = 0;\n\n        uint32 row, column, rowDest, columnDest;\n\n        //main worker tile\n        uint32 *rasterTile = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n        //left tile\n        uint32 *rasterTileLeft = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n        //right tile\n        uint32 *rasterTileRight = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n\n        uint32 *work_line_buf = (uint32*)_TIFFmalloc(tileWidth * sizeof (uint32));\n\n        //check for error\n        if (setjmp(NativeDecoder::tile_buf)) {\n            if (rasterTile) {\n                _TIFFfree(rasterTile);\n                rasterTile = NULL;\n            }\n            if (rasterTileLeft) {\n                _TIFFfree(rasterTileLeft);\n                rasterTileLeft = NULL;\n            }\n            if (rasterTileRight) {\n                _TIFFfree(rasterTileRight);\n                rasterTileRight = NULL;\n            }\n            if (work_line_buf) {\n                _TIFFfree(work_line_buf);\n                work_line_buf = NULL;\n            }\n\n        const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n        LOGE(err);\n        if (throwException) {\n            throwDecodeFileException(err);\n        }\n\n            return NULL;\n        }\n\n        //this variable calculate processed pixels for x and y direction to make right offsets at the begining of next tile\n        //offset calculated from condition globalProcessed % inSampleSize should be 0\n        uint32 globalProcessedX = 0;\n        uint32 globalProcessedY = 0;\n\n        uint32 progressRow = 0;\n        uint32 progressColumn = 0;\n\n        rowDest = columnDest = 0;\n        for (row = firstTileY * tileHeight; row < lastTileY * tileHeight; row += tileHeight, progressRow += tileHeight) {\n            columnDest = 0;\n            short leftTileExists = 0;\n            short rightTileExists = 0;\n            for (column = firstTileX * tileWidth; column < lastTileX * tileWidth; column += tileWidth, progressColumn += tileWidth) {\n                processedProgress = progressRow * *bitmapwidth + progressColumn;\n                sendProgress(processedProgress, progressTotal);\n\n                //If not first column - we should have previous tile - copy it to left tile buffer\n                if (column != firstTileY) {\n                    _TIFFmemcpy(rasterTileLeft, rasterTile, tileWidth * tileHeight * sizeof(uint32));\n                    leftTileExists = 1;\n                } else {\n                    leftTileExists = 0;\n                }\n                //if current column + tile width is less than origin width - we have right tile - copy it to current tile and read next tile to rasterTileRight buffer\n                if (column + tileWidth < origwidth && rightTileExists) {\n                    _TIFFmemcpy(rasterTile, rasterTileRight, tileWidth * tileHeight * sizeof(uint32));\n                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);\n                    rightTileExists = 1;\n                } else if (column + tileWidth < origwidth) {\n                    //have right tile but this is first tile in row, so need to read raster and right raster\n                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);\n                    TIFFReadRGBATile(image, column, row, rasterTile);\n                    rightTileExists = 1;\n\n                    //in that case we also need to invert lines in rasterTile\n                    switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                    }\n                } else {\n                    //otherwise we haven't right tile buffer, so we should read tile to current buffer\n                    TIFFReadRGBATile(image, column, row, rasterTile);\n                    rightTileExists = 0;\n                }\n\n                //if we have right tile - current tile already rotated and we need to rotate only right tile\n                if (rightTileExists) {\n                    switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                    }\n                } else {\n                    //otherwise - current tile not rotated so rotate it\n                    //tile orig is on bottom left - should change lines\n                     switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                    }\n                }\n\n                    //Tile could begin from not filled pixel(pixel[x,y] == 0). This variables allow to calculate begining of filled pixels\n                    int tileStartDataX = -1;\n                    int tileStartDataY = -1;\n\n                    for (int origTileY = 0, pixY = rowDest/inSampleSize; origTileY < tileHeight && pixY < *bitmapheight; origTileY++) {\n                        if (checkStop()) {\n                            if (rasterTile) {\n                                _TIFFfree(rasterTile);\n                                rasterTile = NULL;\n                            }\n                            if (rasterTileLeft) {\n                                _TIFFfree(rasterTileLeft);\n                                rasterTileLeft = NULL;\n                            }\n                            if (rasterTileRight) {\n                                _TIFFfree(rasterTileRight);\n                                rasterTileRight = NULL;\n                            }\n                            if (work_line_buf) {\n                                _TIFFfree(work_line_buf);\n                                work_line_buf = NULL;\n                            }\n                            LOGI(\"Thread stopped\");\n                            return NULL;\n                        }\n\n                        if (tileStartDataY != -1 && globalProcessedY % inSampleSize != 0) {\n                            if (tileStartDataY != -1) {\n                                globalProcessedY++;\n                            }\n                        }\n                        else\n                        {\n\n                            for (int origTileX = 0, pixX = columnDest/inSampleSize; origTileX < tileWidth && pixX < *bitmapwidth; origTileX++) {\n\n\n                                if (tileStartDataX != -1 && globalProcessedX % inSampleSize != 0)\n                                {\n                                    if (tileStartDataX != -1) {\n                                        globalProcessedX++;\n                                    }\n                                }\n                                else\n                                {\n                                    uint32 srcPosition = origTileY * tileWidth + origTileX;\n                                    if (rasterTile[srcPosition] != 0) {\n\n                                        if (tileStartDataX == -1) {\n                                            tileStartDataX = origTileX;\n                                        }\n                                        if (tileStartDataY == -1) {\n                                            tileStartDataY = origTileY;\n                                        }\n\n                                        //Apply filter to pixel\n                                        jint crPix = rasterTile[srcPosition];//origBuffer[j1 * origwidth + i1];\n                                        int sum = 1;\n\n                                        int alpha = colorMask & crPix >> 24;\n                                        int red = colorMask & crPix >> 16;\n                                        int green = colorMask & crPix >> 8;\n                                        int blue = colorMask & crPix;\n\n                                        //using kernel 3x3\n\n                                        //topleft\n                                        if (origTileX - 1 >= 0 && origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY - 1 >= 0 && leftTileExists) {\n                                            crPix = rasterTileLeft[(origTileY - 1) * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //top\n                                        if (origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        // topright\n                                        if (origTileX + 1 < tileWidth && origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY - 1 >= 0 && rightTileExists) {\n                                            crPix = rasterTileRight[(origTileY - 1) * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //right\n                                        if (origTileX + 1 < tileWidth) {\n                                            crPix = rasterTile[origTileY * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (rightTileExists) {\n                                            crPix = rasterTileRight[origTileY * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottomright\n                                        if (origTileX + 1 < tileWidth && origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY + 1 < tileHeight && rightTileExists) {\n                                            crPix = rasterTileRight[(origTileY + 1) * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottom\n                                        if (origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottomleft\n                                        if (origTileX - 1 >= 0 && origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY + 1 < tileHeight && leftTileExists) {\n                                            crPix = rasterTileLeft[(origTileY + 1) * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //left\n                                        if (origTileX - 1 >= 0) {\n                                            crPix = rasterTile[origTileY * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (leftTileExists) {\n                                            crPix = rasterTileLeft[origTileY * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        red /= sum;\n                                        if (red > 255) red = 255;\n                                        if (red < 0) red = 0;\n\n                                        green /= sum;\n                                        if (green > 255) green = 255;\n                                        if (green < 0) green = 0;\n\n                                        blue /= sum;\n                                        if (blue > 255) blue = 255;\n                                        if (blue < 0) blue = 0;\n\n                                        alpha /= sum;///= sum;\n                                        if (alpha > 255) alpha = 255;\n                                        if (alpha < 0) alpha = 0;\n\n                                        crPix = (alpha << 24) | (red << 16) | (green << 8) | (blue);\n\n                                        int position;\n                                        if (origorientation <= 4) {\n                                            position = pixY * *bitmapwidth + pixX;\n                                        } else {\n                                            position = pixX * *bitmapheight + pixY;\n                                        }\n                                        pixels[position] = crPix;\n                                    } else {\n                                        if (tileStartDataX != -1) tileStartDataX = -1;\n                                        if (tileStartDataY != -1) tileStartDataY = -1;\n                                    }\n\n                                    if (tileStartDataX != -1) {\n                                        pixX++;\n                                        globalProcessedX++;\n                                    }\n\n                                }\n                            }\n                            if (tileStartDataY != -1) {\n                                pixY++;\n                                globalProcessedY++;\n                            }\n                        }\n                    }\n                columnDest += tileWidth;\n            }\n            rowDest += tileHeight;\n        }\n\n        if (rasterTile) {\n            _TIFFfree(rasterTile);\n            rasterTile = NULL;\n        }\n        if (rasterTileLeft) {\n            _TIFFfree(rasterTileLeft);\n            rasterTileLeft = NULL;\n        }\n        if (rasterTileRight) {\n            _TIFFfree(rasterTileRight);\n            rasterTileRight = NULL;\n        }\n        if (work_line_buf) {\n            _TIFFfree(work_line_buf);\n            work_line_buf = NULL;\n        }\n\n        //Copy necessary pixels to new array if orientation <=4\n        uint32 tmpPixelBufferSize = (boundWidth / inSampleSize) * (boundHeight / inSampleSize);\n\n        estimateMem = (sizeof(jint) * pixelsBufferSize); //buffer for decoded pixels\n        estimateMem += (sizeof(jint) * tmpPixelBufferSize); //finall buffer\n        LOGII(\"estimateMem\", estimateMem);\n        if (estimateMem > availableMemory) {\n            if (throwException) {\n                throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n            }\n            return NULL;\n        }\n\n        if (origorientation <= 4) {\n\n            jint* tmpPixels = (jint *) malloc(sizeof(jint) * tmpPixelBufferSize);\n            uint32 startPosX = boundX%tileWidth /inSampleSize;//(firstTileX * tileWidth - tileWidth + boundX) / inSampleSize;\n            uint32 startPosY = boundY%tileHeight /inSampleSize;//(firstTileY * tileHeight - tileHeight + boundY) /inSampleSize;\n            for (int ox = startPosX, nx = 0; nx < boundWidth/inSampleSize; ox++, nx++) {\n                sendProgress(processedProgress + nx * (boundHeight/inSampleSize), progressTotal);\n                for (int oy = startPosY, ny = 0; ny < boundHeight/inSampleSize; oy++, ny++) {\n                    tmpPixels[ny * (boundWidth/inSampleSize) + nx] = pixels[oy * *bitmapwidth + ox];\n                }\n            }\n\n            free(pixels);\n            pixels = tmpPixels;\n            *bitmapwidth = boundWidth/inSampleSize;\n            *bitmapheight = boundHeight/inSampleSize;\n        }\n\n        if (useOrientationTag) {\n            switch (origorientation) {\n                case ORIENTATION_TOPLEFT:\n                case ORIENTATION_LEFTTOP:\n                    break;\n                case ORIENTATION_TOPRIGHT:\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                case ORIENTATION_RIGHTTOP:\n                    flipPixelsHorizontal(*bitmapheight, *bitmapwidth, pixels);\n                    break;\n                case ORIENTATION_BOTRIGHT:\n                case ORIENTATION_RIGHTBOT:\n                    rotateRaster(pixels, 180, bitmapwidth, bitmapheight);\n                    break;\n                case ORIENTATION_BOTLEFT:\n                    flipPixelsVertical(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                case ORIENTATION_LEFTBOT:\n                    flipPixelsVertical(*bitmapheight, *bitmapwidth, pixels);\n                    break;\n            }\n        } else {\n            if (origorientation > 4) {\n                uint32 buf = *bitmapwidth;\n                *bitmapwidth = *bitmapheight;\n                *bitmapheight = buf;\n                rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n            }\n        }\n\n        //Copy necessary pixels to new array if orientation >4\n        if (origorientation > 4) {\n            jint* tmpPixels = (jint *) malloc(sizeof(jint) * tmpPixelBufferSize);\n            uint32 startPosX = boundX%tileWidth /inSampleSize;\n            uint32 startPosY = boundY%tileHeight /inSampleSize;\n            for (int ox = startPosX, nx = 0; nx < boundWidth/inSampleSize; ox++, nx++) {\n                sendProgress(processedProgress + nx * (boundHeight/inSampleSize), progressTotal);\n                for (int oy = startPosY, ny = 0; ny < boundHeight/inSampleSize; oy++, ny++) {\n                    if (useOrientationTag) {\n                        tmpPixels[nx * (boundHeight/inSampleSize) + ny] = pixels[ox * *bitmapheight + oy];\n                    } else {\n                        tmpPixels[ny * (boundWidth/inSampleSize) + nx] = pixels[oy * *bitmapwidth + ox];\n                    }\n                }\n            }\n\n            free(pixels);\n            pixels = tmpPixels;\n            *bitmapwidth = boundWidth/inSampleSize;\n            *bitmapheight = boundHeight/inSampleSize;\n        }\n\n        return pixels;\n}",
    "int NativeDecoder::getDecodeMethod()\n{\n\tint method = -1;\n\tuint32 tileWidth, tileHeight;\n\tint readTW = 0, readTH = 0;\n    readTW = TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileWidth);\n    readTH = TIFFGetField(image, TIFFTAG_TILELENGTH, &tileHeight);\n    if (tileWidth > 0 && tileHeight > 0 && readTH > 0 && readTW > 0) {\n        method = DECODE_METHOD_TILE;\n    } else {\n        int rowPerStrip = -1;\n    \tTIFFGetField(image, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    \tuint32 stripSize = TIFFStripSize (image);\n    \tuint32 stripMax = TIFFNumberOfStrips (image);\n    \tint estimate = origwidth * 3;\n    \tLOGII(\"RPS\", rowPerStrip);\n    \tLOGII(\"stripSize\", stripSize);\n    \tLOGII(\"stripMax\", stripMax);\n    \tif (rowPerStrip != -1 && stripSize > 0 && stripMax > 1 && rowPerStrip < origheight) {\n    \t    method = DECODE_METHOD_STRIP;\n    \t} else {\n    \tmethod = DECODE_METHOD_IMAGE;\n    \t}\n    }\n\n\tLOGII(\"Decode method\", method);\n\treturn method;\n}",
    "void NativeDecoder::writeDataToOptions(int directoryNumber)\n{\n    TIFFSetDirectory(image, directoryNumber);\n        jfieldID gOptions_outDirectoryCountFieldId = env->GetFieldID(jBitmapOptionsClass,\n            \"outDirectoryCount\", \"I\");\n        int dircount = getDyrectoryCount();\n        env->SetIntField(optionsObject, gOptions_outDirectoryCountFieldId, dircount);\n\n        TIFFSetDirectory(image, directoryNumber);\n        TIFFGetField(image, TIFFTAG_IMAGEWIDTH, & origwidth);\n        TIFFGetField(image, TIFFTAG_IMAGELENGTH, & origheight);\n\n        //Getting image orientation and createing ImageOrientation enum\n        TIFFGetField(image, TIFFTAG_ORIENTATION, & origorientation);\n        //If orientation field is empty - use ORIENTATION_TOPLEFT\n        if (origorientation == 0) {\n            origorientation = ORIENTATION_TOPLEFT;\n        }\n        jclass gOptions_ImageOrientationClass = env->FindClass(\n            \"org/beyka/tiffbitmapfactory/Orientation\");\n        jfieldID gOptions_ImageOrientationFieldId = NULL;\n        bool flipHW = false;\n        LOGII(\"Orientation\", origorientation);\n        switch (origorientation) {\n            case ORIENTATION_TOPLEFT:\n                gOptions_ImageOrientationFieldId = env->GetStaticFieldID(gOptions_ImageOrientationClass,\n                    \"TOP_LEFT\",\n                    \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n                break;\n            case ORIENTATION_TOPRIGHT:\n                gOptions_ImageOrientationFieldId = env->GetStaticFieldID(gOptions_ImageOrientationClass,\n                    \"TOP_RIGHT\",\n                    \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n                break;\n            case ORIENTATION_BOTRIGHT:\n                gOptions_ImageOrientationFieldId = env->GetStaticFieldID(gOptions_ImageOrientationClass,\n                    \"BOT_RIGHT\",\n                    \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n                break;\n            case ORIENTATION_BOTLEFT:\n                gOptions_ImageOrientationFieldId = env->GetStaticFieldID(gOptions_ImageOrientationClass,\n                    \"BOT_LEFT\",\n                    \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n                break;\n            case ORIENTATION_LEFTTOP:\n                flipHW = true;\n                gOptions_ImageOrientationFieldId = env->GetStaticFieldID(gOptions_ImageOrientationClass,\n                    \"LEFT_TOP\",\n                    \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n                break;\n            case ORIENTATION_RIGHTTOP:\n                flipHW = true;\n                gOptions_ImageOrientationFieldId = env->GetStaticFieldID(gOptions_ImageOrientationClass,\n                    \"RIGHT_TOP\",\n                    \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n                break;\n            case ORIENTATION_RIGHTBOT:\n                flipHW = true;\n                gOptions_ImageOrientationFieldId = env->GetStaticFieldID(gOptions_ImageOrientationClass,\n                    \"RIGHT_BOT\",\n                    \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n                break;\n            case ORIENTATION_LEFTBOT:\n                flipHW = true;\n                gOptions_ImageOrientationFieldId = env->GetStaticFieldID(gOptions_ImageOrientationClass,\n                    \"LEFT_BOT\",\n                    \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n                break;\n        }\n        if (gOptions_ImageOrientationFieldId != NULL) {\n            jobject gOptions_ImageOrientationObj = env->GetStaticObjectField(\n                gOptions_ImageOrientationClass,\n                gOptions_ImageOrientationFieldId);\n\n            //Set outImageOrientation field to options object\n            jfieldID gOptions_outImageOrientationField = env->GetFieldID(jBitmapOptionsClass,\n                \"outImageOrientation\",\n                \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n            env->SetObjectField(optionsObject, gOptions_outImageOrientationField,\n                gOptions_ImageOrientationObj);\n        }\n\n        //Get resolution variables\n        /*\n        jfieldID gOptions_outDirectoryCountFieldId = env->GetFieldID(jOptionsClass,\n                    \"outDirectoryCount\", \"I\");\n                int dircount = getDyrectoryCount();\n                env->SetIntField(optionsObject, gOptions_outDirectoryCountFieldId, dircount);\n        */\n        float xresolution, yresolution;\n        uint16 resunit;\n        TIFFGetField(image, TIFFTAG_XRESOLUTION, &xresolution);\n        LOGIF(\"xres\", xresolution);\n        jfieldID gOptions_outXResolutionFieldID = env->GetFieldID(jBitmapOptionsClass, \"outXResolution\", \"F\");\n        env->SetFloatField(optionsObject, gOptions_outXResolutionFieldID, xresolution);\n        TIFFGetField(image, TIFFTAG_YRESOLUTION, &yresolution);\n        LOGIF(\"yres\", yresolution);\n        jfieldID gOptions_outYResolutionFieldID = env->GetFieldID(jBitmapOptionsClass, \"outYResolution\", \"F\");\n        env->SetFloatField(optionsObject, gOptions_outYResolutionFieldID, yresolution);\n        TIFFGetField(image, TIFFTAG_RESOLUTIONUNIT, &resunit);\n        LOGII(\"resunit\", resunit);\n        jclass gOptions_ResolutionUnitClass = env->FindClass(\"org/beyka/tiffbitmapfactory/ResolutionUnit\");\n        jfieldID gOptions_ResolutionUnitFieldId = NULL;\n        switch(resunit) {\n            case RESUNIT_INCH:\n                gOptions_ResolutionUnitFieldId = env->GetStaticFieldID(gOptions_ResolutionUnitClass,\n                            \"INCH\",\n                            \"Lorg/beyka/tiffbitmapfactory/ResolutionUnit;\");\n                break;\n            case RESUNIT_CENTIMETER:\n                gOptions_ResolutionUnitFieldId = env->GetStaticFieldID(gOptions_ResolutionUnitClass,\n                            \"CENTIMETER\",\n                            \"Lorg/beyka/tiffbitmapfactory/ResolutionUnit;\");\n                break;\n            case RESUNIT_NONE:\n            default:\n                gOptions_ResolutionUnitFieldId = env->GetStaticFieldID(gOptions_ResolutionUnitClass,\n                            \"NONE\",\n                            \"Lorg/beyka/tiffbitmapfactory/ResolutionUnit;\");\n                break;\n        }\n        if (gOptions_ResolutionUnitFieldId != NULL) {\n            jobject gOptions_ResolutionUnitObj = env->GetStaticObjectField(\n                        gOptions_ResolutionUnitClass,\n                        gOptions_ResolutionUnitFieldId);\n\n            //Set resolution unit field to options object\n            jfieldID gOptions_outResUnitField = env->GetFieldID(jBitmapOptionsClass,\n                        \"outResolutionUnit\",\n                        \"Lorg/beyka/tiffbitmapfactory/ResolutionUnit;\");\n            env->SetObjectField(optionsObject, gOptions_outResUnitField,\n                        gOptions_ResolutionUnitObj);\n        }\n\n        //Get image planar config\n        int planarConfig = 0;\n        TIFFGetField(image, TIFFTAG_PLANARCONFIG, &planarConfig);\n        LOGII(\"planar config\", planarConfig);\n        jclass gOptions_PlanarConfigClass = env->FindClass(\"org/beyka/tiffbitmapfactory/PlanarConfig\");\n        jfieldID gOptions_PlanarConfigFieldId = NULL;\n        switch(planarConfig) {\n            case PLANARCONFIG_CONTIG:\n                gOptions_PlanarConfigFieldId = env->GetStaticFieldID(gOptions_PlanarConfigClass,\n                \"CONTIG\",\n                \"Lorg/beyka/tiffbitmapfactory/PlanarConfig;\");\n                break;\n            case PLANARCONFIG_SEPARATE:\n                gOptions_PlanarConfigFieldId = env->GetStaticFieldID(gOptions_PlanarConfigClass,\n                \"SEPARATE\",\n                \"Lorg/beyka/tiffbitmapfactory/PlanarConfig;\");\n                break;\n        }\n        if (gOptions_PlanarConfigFieldId != NULL) {\n            jobject gOptions_PlanarConfigObj = env->GetStaticObjectField(\n                    gOptions_PlanarConfigClass,\n                    gOptions_PlanarConfigFieldId);\n\n            jfieldID gOptions_outPlanarConfigField = env->GetFieldID(jBitmapOptionsClass,\n                    \"outPlanarConfig\",\n                    \"Lorg/beyka/tiffbitmapfactory/PlanarConfig;\");\n            env->SetObjectField(optionsObject, gOptions_outPlanarConfigField,\n                    gOptions_PlanarConfigObj);\n        }\n\n        //Getting image compression scheme and createing CompressionScheme enum\n        TIFFGetField(image, TIFFTAG_COMPRESSION, & origcompressionscheme);\n        LOGII(\"compression\", origcompressionscheme);\n\n        jclass gOptions_ImageCompressionClass = env->FindClass(\n            \"org/beyka/tiffbitmapfactory/CompressionScheme\");\n        jfieldID gOptions_ImageCompressionFieldId = NULL;\n        switch (origcompressionscheme) {\n        case COMPRESSION_NONE:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"NONE\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            break;\n        case COMPRESSION_CCITTRLE:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"CCITTRLE\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            break;\n        case COMPRESSION_CCITTFAX3:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"CCITTFAX3\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n                break;\n        case COMPRESSION_CCITTFAX4:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n            \"CCITTFAX4\",\n            \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            break;\n        case COMPRESSION_LZW:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"LZW\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            break;\n        case COMPRESSION_JPEG:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"JPEG\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            break;\n        case COMPRESSION_PACKBITS:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"PACKBITS\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            break;\n        case COMPRESSION_DEFLATE:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"DEFLATE\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            break;\n        case COMPRESSION_ADOBE_DEFLATE:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"ADOBE_DEFLATE\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            break;\n        default:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"OTHER\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n\n        }\n        if (gOptions_ImageCompressionFieldId != NULL) {\n            jobject gOptions_ImageCompressionObj = env->GetStaticObjectField(\n                gOptions_ImageCompressionClass,\n                gOptions_ImageCompressionFieldId);\n\n            //Set outImageOrientation field to options object\n            jfieldID gOptions_outCompressionSchemeField = env->GetFieldID(jBitmapOptionsClass,\n                \"outCompressionScheme\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            env->SetObjectField(optionsObject, gOptions_outCompressionSchemeField,\n                gOptions_ImageCompressionObj);\n        }\n\n        jfieldID gOptions_OutCurDirNumberFieldID = env->GetFieldID(jBitmapOptionsClass,\n            \"outCurDirectoryNumber\",\n            \"I\");\n        env->SetIntField(optionsObject, gOptions_OutCurDirNumberFieldID, directoryNumber);\n        if (!flipHW) {\n            jfieldID gOptions_outWidthFieldId = env->GetFieldID(jBitmapOptionsClass, \"outWidth\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outWidthFieldId, origwidth);\n\n            jfieldID gOptions_outHeightFieldId = env->GetFieldID(jBitmapOptionsClass, \"outHeight\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outHeightFieldId, origheight);\n        } else {\n            jfieldID gOptions_outWidthFieldId = env->GetFieldID(jBitmapOptionsClass, \"outWidth\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outWidthFieldId, origheight);\n\n            jfieldID gOptions_outHeightFieldId = env->GetFieldID(jBitmapOptionsClass, \"outHeight\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outHeightFieldId, origwidth);\n        }\n\n        int tagRead = 0;\n\n        int bitPerSample = 0;\n        tagRead = TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &bitPerSample);\n        if (tagRead == 1) {\n            LOGII(\"bit per sample\", bitPerSample);\n            jfieldID gOptions_outBitPerSampleFieldID = env->GetFieldID(jBitmapOptionsClass, \"outBitsPerSample\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outBitPerSampleFieldID, bitPerSample);\n        }\n\n        int samplePerPixel = 0;\n        tagRead = TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &samplePerPixel);\n        if (tagRead == 1) {\n            LOGII(\"sample per pixel\", samplePerPixel);\n            jfieldID gOptions_outSamplePerPixelFieldID = env->GetFieldID(jBitmapOptionsClass, \"outSamplePerPixel\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outSamplePerPixelFieldID, samplePerPixel);\n        }\n\n        //Tile size\n        int tileWidth = 0;\n        tagRead = TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileWidth);\n            if (tagRead == 1) {\n            LOGII(\"tile width\", tileWidth);\n            jfieldID gOptions_outTileWidthFieldID = env->GetFieldID(jBitmapOptionsClass, \"outTileWidth\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outTileWidthFieldID, tileWidth);\n        }\n        int tileHeight = 0;\n        tagRead = TIFFGetField(image, TIFFTAG_TILELENGTH, &tileHeight);\n        if (tagRead == 1) {\n            LOGII(\"tile height\", tileHeight);\n            jfieldID gOptions_outTileHeightFieldID = env->GetFieldID(jBitmapOptionsClass, \"outTileHeight\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outTileHeightFieldID, tileHeight);\n        }\n\n        //row per strip\n        int rowPerStrip = 0;\n        tagRead = TIFFGetField(image, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n        if (tagRead == 1) {\n            LOGII(\"row per strip\", rowPerStrip);\n            jfieldID gOptions_outRowPerStripFieldID = env->GetFieldID(jBitmapOptionsClass, \"outRowPerStrip\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outRowPerStripFieldID, rowPerStrip);\n        }\n\n        //strip size\n        uint32 stripSize = TIFFStripSize (image);\n        LOGII(\"strip size\", stripSize);\n        jfieldID gOptions_outStripSizeFieldID = env->GetFieldID(jBitmapOptionsClass, \"outStripSize\", \"I\");\n        env->SetIntField(optionsObject, gOptions_outStripSizeFieldID, stripSize);\n\n        //strip max\n        uint32 stripMax = TIFFNumberOfStrips (image);\n        LOGII(\"number of strips\", stripMax);\n        jfieldID gOptions_outStripMaxFieldID = env->GetFieldID(jBitmapOptionsClass, \"outNumberOfStrips\", \"I\");\n        env->SetIntField(optionsObject, gOptions_outStripMaxFieldID, stripMax);\n\n        //photometric\n        int photometric = 0;\n        TIFFGetField(image, TIFFTAG_PHOTOMETRIC, &photometric);\n        LOGII(\"photometric\", photometric);\n        jclass gOptions_PhotometricClass = env->FindClass(\"org/beyka/tiffbitmapfactory/Photometric\");\n        jfieldID gOptions_PhotometricFieldId = NULL;\n                switch(photometric) {\n                    case PHOTOMETRIC_MINISWHITE:\n                        gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                        \"MINISWHITE\",\n                        \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                        break;\n                    case PHOTOMETRIC_MINISBLACK:\n                        gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                        \"MINISBLACK\",\n                        \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_RGB:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"RGB\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_PALETTE:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"PALETTE\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_MASK:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"MASK\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_SEPARATED:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"SEPARATED\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_YCBCR:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"YCBCR\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_CIELAB:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"CIELAB\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_ICCLAB:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"ICCLAB\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_ITULAB:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"ITULAB\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_LOGL:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"LOGL\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_LOGLUV:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"LOGLUV\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    default:\n                        gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                        \"OTHER\",\n                        \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                }\n        if (gOptions_PhotometricFieldId != NULL) {\n                    jobject gOptions_PhotometricObj = env->GetStaticObjectField(\n                            gOptions_PhotometricClass,\n                            gOptions_PhotometricFieldId);\n\n                    jfieldID gOptions_outPhotometricField = env->GetFieldID(jBitmapOptionsClass,\n                            \"outPhotometric\",\n                            \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    env->SetObjectField(optionsObject, gOptions_outPhotometricField,\n                            gOptions_PhotometricObj);\n        }\n\n        //FillOrder\n        int fillOrder = 0;\n        TIFFGetField(image, TIFFTAG_FILLORDER, &fillOrder);\n        LOGII(\"fill Order\", fillOrder);\n        jclass gOptions_FillOrderClass = env->FindClass(\"org/beyka/tiffbitmapfactory/FillOrder\");\n        jfieldID gOptions_FillOrderFieldId = NULL;\n        switch(fillOrder) {\n        case FILLORDER_MSB2LSB:\n            gOptions_FillOrderFieldId = env->GetStaticFieldID(gOptions_FillOrderClass,\n            \"MSB2LSB\",\n            \"Lorg/beyka/tiffbitmapfactory/FillOrder;\");\n            break;\n        case PLANARCONFIG_SEPARATE:\n            gOptions_FillOrderFieldId = env->GetStaticFieldID(gOptions_FillOrderClass,\n            \"LSB2MSB\",\n            \"Lorg/beyka/tiffbitmapfactory/FillOrder;\");\n            break;\n        }\n        if (gOptions_FillOrderFieldId != NULL) {\n            jobject gOptions_FillOrderObj = env->GetStaticObjectField(\n            gOptions_FillOrderClass,\n            gOptions_FillOrderFieldId);\n\n            jfieldID gOptions_outFillOrderField = env->GetFieldID(jBitmapOptionsClass,\n            \"outFillOrder\",\n            \"Lorg/beyka/tiffbitmapfactory/FillOrder;\");\n            env->SetObjectField(optionsObject, gOptions_outFillOrderField,\n            gOptions_FillOrderObj);\n        }\n\n        //Author\n        const char * artist;\n        tagRead = TIFFGetField(image, TIFFTAG_ARTIST, & artist);\n        if (tagRead == 1) {\n            LOGI(artist);\n            jstring jauthor = charsToJString(artist);//env->NewStringUTF(artist);\n            jfieldID gOptions_outAuthorFieldId = env->GetFieldID(jBitmapOptionsClass, \"outAuthor\", \"Ljava/lang/String;\");\n            env->SetObjectField(optionsObject, gOptions_outAuthorFieldId, jauthor);\n            env->DeleteLocalRef(jauthor);\n            //free(artist);\n        }\n\n        //Copyright\n        const char * copyright;\n        tagRead = TIFFGetField(image, TIFFTAG_COPYRIGHT, & copyright);\n        if (tagRead == 1) {\n            LOGI(copyright);\n            jstring jcopyright = charsToJString(copyright);//env->NewStringUTF(copyright);\n            jfieldID gOptions_outCopyrightFieldId = env->GetFieldID(jBitmapOptionsClass, \"outCopyright\", \"Ljava/lang/String;\");\n            env->SetObjectField(optionsObject, gOptions_outCopyrightFieldId, jcopyright);\n            env->DeleteLocalRef(jcopyright);\n            //free(copyright);\n        }\n\n        //ImageDescription\n        const char * imgDescr;\n        tagRead = TIFFGetField(image, TIFFTAG_IMAGEDESCRIPTION, & imgDescr);\n        if (tagRead == 1) {\n            LOGI(imgDescr);\n            jstring jimgDescr = charsToJString(imgDescr);//env->NewStringUTF(imgDescr);\n            jfieldID gOptions_outimgDescrFieldId = env->GetFieldID(jBitmapOptionsClass, \"outImageDescription\", \"Ljava/lang/String;\");\n            env->SetObjectField(optionsObject, gOptions_outimgDescrFieldId, jimgDescr);\n            env->DeleteLocalRef(jimgDescr);\n            //free(imgDescr);\n        }\n\n        //Software\n        const char * software;\n        tagRead = TIFFGetField(image, TIFFTAG_SOFTWARE, & software);\n        if (tagRead == 1) {\n            LOGI(software);\n            jstring jsoftware = charsToJString(software);//env->NewStringUTF(software);\n            jfieldID gOptions_outsoftwareFieldId = env->GetFieldID(jBitmapOptionsClass, \"outSoftware\", \"Ljava/lang/String;\");\n            env->SetObjectField(optionsObject, gOptions_outsoftwareFieldId, jsoftware);\n            env->DeleteLocalRef(jsoftware);\n            //free(software);\n        }\n\n        //DateTime\n        const char * datetime;\n        tagRead = TIFFGetField(image, TIFFTAG_DATETIME, & datetime);\n        if (tagRead == 1) {\n            LOGI(datetime);\n            jstring jdatetime = charsToJString(datetime);//env->NewStringUTF(datetime);\n            jfieldID gOptions_outdatetimeFieldId = env->GetFieldID(jBitmapOptionsClass, \"outDatetime\", \"Ljava/lang/String;\");\n            env->SetObjectField(optionsObject, gOptions_outdatetimeFieldId, jdatetime);\n            env->DeleteLocalRef(jdatetime);\n            //free(datetime);\n        }\n\n        //Host Computer\n        const char * host;\n        tagRead = TIFFGetField(image, TIFFTAG_HOSTCOMPUTER, & host);\n        if (tagRead == 1) {\n            LOGI(host);\n            jstring jhost = charsToJString(host);//env->NewStringUTF(host);\n            jfieldID gOptions_outhostFieldId = env->GetFieldID(jBitmapOptionsClass, \"outHostComputer\", \"Ljava/lang/String;\");\n            env->SetObjectField(optionsObject, gOptions_outhostFieldId, jhost);\n            env->DeleteLocalRef(jhost);\n            //free(host);\n        }\n}",
    "jboolean TiffToPngConverter::convert()\n{\n    readOptions();\n    LOGI(\"Optioons read done\");\n\n    LOGII(\"inFd=\", inFd);\n    if (inFd == -1) {\n        const char *inCPath = NULL;\n        inCPath = env->GetStringUTFChars(inPath, 0);\n        LOGIS(\"IN path\", inCPath);\n        inFd = open(inCPath, O_RDWR, 0666);\n        if (inFd < 0) {\n            if (throwException) {\n                throw_cant_open_file_exception(env, inPath);\n            }\n            LOGES(\"Can\\'t open in file\", inCPath);\n            env->ReleaseStringUTFChars(inPath, inCPath);\n            return JNI_FALSE;\n        }\n        env->ReleaseStringUTFChars(inPath, inCPath);\n    }\n\n    //open tiff image for reading\n    tiffImage = TIFFFdOpen(inFd, \"\", \"r\");\n    if (tiffImage == NULL) {\n        if (throwException) {\n            if (inFd < 0) {\n                throw_cant_open_file_exception(env, inPath);\n            } else {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n        }\n        return JNI_FALSE;\n    }\n    LOGI(\"Tiff file opened for reading\");\n\n    //open png file fow writing\n    LOGII(\"outFd=\", outFd);\n    if(outFd == -1) {\n    LOGI(\"Opening png as File\");\n        //open tiff file for writing or appending\n        const char *outCPath = NULL;\n        outCPath = env->GetStringUTFChars(outPath, 0);\n        LOGIS(\"OUT path\", outCPath);\n        LOGIS(\"nativeTiffOpenForSave\", outCPath);\n\n        pngFile = fopen(outCPath, \"w\");\n        if (!pngFile) {\n            throw_cant_open_file_exception(env, outPath);\n            env->ReleaseStringUTFChars(outPath, outCPath);\n            return JNI_FALSE;\n        }\n    } else {\n    LOGI(\"Opening png as FD\");\n        pngFile = fdopen(outFd, \"w\");\n        if (!pngFile) {\n            LOGI(\"PNG file is null\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n            LOGES(\"Can\\'t open out file descriptor\", inFd);\n            return JNI_FALSE;\n        }\n    }\n    LOGI(\"PNG file opened\");\n\n    //create png structure pointer\n    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n    if (!png_ptr) {\n        const char *message = \"Can\\'t create PNG structure\";\n        LOGE(*message);\n        if (throwException) {\n            jstring er = env->NewStringUTF(message);\n            if (outFd == -1) {\n                throw_decode_file_exception(env, outPath, er);\n            } else {\n                throw_decode_file_exception_fd(env, outFd, er);\n            }\n            env->DeleteLocalRef(er);\n        }\n        return JNI_FALSE;\n    }\n    png_ptr_init = 1;\n\n    //create png info pointer\n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        const char *message = \"Can\\'t create PNG info structure\";\n        LOGE(*message);\n        if (throwException) {\n            jstring er = env->NewStringUTF(message);\n            if  (outFd == -1) {\n                throw_decode_file_exception(env, outPath, er);\n            } else {\n                throw_decode_file_exception_fd(env, outFd, er);\n            }\n            env->DeleteLocalRef(er);\n        }\n        return JNI_FALSE;\n    }\n    png_info_init = 1;\n\n    //png error handler\n    if (setjmp(png_jmpbuf(png_ptr))) {\n        const char *message = \"Error creating PNG\";\n        LOGE(message);\n        if (throwException) {\n            jstring er = env->NewStringUTF(message);\n            if (outFd == -1) {\n                throw_decode_file_exception(env, outPath, er);\n            } else {\n                throw_decode_file_exception_fd(env, outFd, er);\n            }\n            env->DeleteLocalRef(er);\n        }\n        return JNI_FALSE;\n    }\n\n    //Init PNG IO\n    png_init_io(png_ptr, pngFile);\n\n    //set tiff directory and read image dimensions\n    TIFFSetDirectory(tiffImage, tiffDirectory);\n    TIFFGetField(tiffImage, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tiffImage, TIFFTAG_IMAGELENGTH, &height);\n    //Getting image orientation and createing ImageOrientation enum\n    TIFFGetField(tiffImage, TIFFTAG_ORIENTATION, &origorientation);\n    //If orientation field is empty - use ORIENTATION_TOPLEFT\n    if (origorientation == 0) {\n        origorientation = ORIENTATION_TOPLEFT;\n    }\n    LOGII(\"image width\", width);\n    LOGII(\"image height\", height);\n\n    if (!normalizeDecodeArea()) {\n        return JNI_FALSE;\n    }\n\n    //set png data\n    png_set_IHDR(png_ptr, info_ptr, outWidth, outHeight, 8, PNG_COLOR_TYPE_RGB_ALPHA,\n                PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT,\n                PNG_FILTER_TYPE_DEFAULT);\n\n                LOGI(\"png_set_IHDR done\");\n\n    //write file header\n    png_write_info(png_ptr, info_ptr);\n    LOGI(\"png_write_info done\");\n\n    png_set_flush(png_ptr, 32);\n\n    jboolean result = JNI_FALSE;\n\n    switch(getDecodeMethod()) {\n        case DECODE_METHOD_IMAGE:\n            result = convertFromImage();\n            break;\n        case DECODE_METHOD_TILE:\n            result = convertFromTile();\n            break;\n        case DECODE_METHOD_STRIP:\n            result = convertFromStrip();\n            break;\n    }\n\n    if (result) {\n        png_write_end(png_ptr, info_ptr);\n    }\n    conversion_result = result;\n    return conversion_result;\n}",
    "jboolean TiffToPngConverter::convertFromTile() {\n    uint32 tileWidth = 0, tileHeight = 0;\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileWidth);\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileHeight);\n    LOGII(\"Tile width\", tileWidth);\n    LOGII(\"Tile height\", tileHeight);\n\n    //uint32 *raster = (uint32 *)_TIFFmalloc(width * tileHeight * sizeof(uint32));\n    uint32 workingWidth = (width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth;\n    LOGII(\"workingWidth \", workingWidth );\n    uint32 rasterSize =  workingWidth  * tileHeight ;\n    LOGII(\"rasterSize \", rasterSize );\n    //uint32 *raster = (uint32 *)_TIFFmalloc(rasterSize * sizeof(uint32));\n\n\n    unsigned long estimateMem = rasterSize * sizeof(uint32); //raster\n    estimateMem += tileWidth * tileHeight * sizeof(uint32); //tile raster\n    estimateMem += tileWidth * sizeof (uint32); //working buf\n    estimateMem += 4 * outWidth * sizeof(png_bytep); //bufer for writing to png\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    uint32 *rasterTile = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n    uint32 *work_line_buf = (uint32*)_TIFFmalloc(tileWidth * sizeof (uint32));\n\n    jlong total = ((width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth)\n                * ((height/tileHeight + (height%tileHeight == 0 ? 0 : 1)) * tileHeight);\n        sendProgress(0, total);\n\n    uint32 row, column;\n\n    int startx = -1, starty = -1, endx = -1, endy = -1;\n    uint32 imageWritedLines = 0;\n\n    for (row = 0; row < height; row += tileHeight) {\n        sendProgress(row * width, total);\n        endy = -1;\n        starty = -1;\n        uint32 *raster = (uint32 *)_TIFFmalloc(rasterSize * sizeof(uint32));\n\n        for (column = 0; column < width; column += tileWidth) {\n            if (checkStop()) {\n                free(raster);\n                raster = NULL;\n                if (rasterTile) {\n                    _TIFFfree(rasterTile);\n                    rasterTile = NULL;\n                }\n                if (work_line_buf) {\n                    _TIFFfree(rasterTile);\n                    work_line_buf = NULL;\n                }\n                return JNI_FALSE;\n            }\n            endx = -1;\n            startx = -1;\n            TIFFReadRGBATile(tiffImage, column , row, rasterTile);\n            switch(origorientation) {\n                case 1:\n                case 5:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 2:\n                case 6:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 3:\n                case 7:\n                {\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n\n                    break;\n                    }\n            }\n\n            normalizeTile(tileHeight, tileWidth, rasterTile);\n\n\n            //find start and end position\n            for (int ty = 0; ty < tileHeight; ty++) {\n\n                for (int tx = 0; tx < tileWidth; tx++) {\n                    if (rasterTile[ty * tileWidth + tx] != 0) {\n                        if (startx == -1) {\n                            startx = tx;\n                        }\n                        if (starty == -1) {\n                            starty = ty;\n                        }\n\n                        if (tx > endx)\n                            endx = tx;\n                        if (ty > endy)\n                            endy = ty;\n\n                        uint32 rasterPos = (ty ) * workingWidth + (tx + column);\n                        //LOGII(\"rp\", rasterPos);\n                        raster[rasterPos] = rasterTile[ty * tileWidth + tx];\n                    }\n\n                }\n            }\n        }\n\n        int outY, outX;\n        for (int y = starty; y < tileHeight; y++) {\n            if (imageWritedLines == height) break;\n            if (y + row < outStartY || y + row >= outStartY + outHeight) continue;\n            outY = y + row - outStartY;\n            //create temp raster and write there pixels than not null\n            png_bytep pngrow = (png_bytep)malloc(4 * outWidth * sizeof(png_bytep));\n            memcpy(pngrow, raster + y * workingWidth + outStartX, outWidth * 4);\n            //memcpy(pngrow, rasterLine, width * 4);\n            png_write_row(png_ptr, pngrow);\n            free(pngrow);\n            //delete(rasterLine);\n            imageWritedLines++;\n        }\n        //LOGII(\"imageWritedLines\", imageWritedLines);\n\n        free(raster);\n\n    }\n\n    /*if (raster) {\n        _TIFFfree(raster);\n        raster = NULL;\n    }*/\n\n    if (rasterTile) {\n        _TIFFfree(rasterTile);\n        rasterTile = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(rasterTile);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n\n    return JNI_TRUE;\n\n}",
    "jboolean TiffToPngConverter::convertFromStrip() {\n    uint32 stripSize = TIFFStripSize (tiffImage);\n    uint32 stripMax = TIFFNumberOfStrips (tiffImage);\n    int rowPerStrip = -1;\n    TIFFGetField(tiffImage, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    LOGII(\"RPS\", rowPerStrip);\n\n    unsigned long estimateMem = width * sizeof(uint32);//working buf\n    estimateMem += width * rowPerStrip * sizeof (uint32);//raster\n    estimateMem += 4 * outWidth * sizeof(png_bytep); //buf for writing to png\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    jlong total = stripMax * rowPerStrip * width;\n    sendProgress(0, total);\n\n    uint32* work_line_buf = (uint32 *)_TIFFmalloc(width * sizeof(uint32));\n    uint32* raster = (uint32 *)_TIFFmalloc(width * rowPerStrip * sizeof (uint32));\n\n    uint32 rows_to_write = 0;\n\n    for (int i = 0; i < stripMax*rowPerStrip; i += rowPerStrip) {\n        if (checkStop()) {\n            if (raster) {\n                _TIFFfree(raster);\n                raster = NULL;\n            }\n            if (work_line_buf) {\n                _TIFFfree(work_line_buf);\n                work_line_buf = NULL;\n            }\n            return JNI_FALSE;\n        }\n        sendProgress(i * width, total);\n        TIFFReadRGBAStrip(tiffImage, i, raster);\n\n        rows_to_write = 0;\n        if( i + rowPerStrip > height )\n            rows_to_write = height - i;\n        else\n            rows_to_write = rowPerStrip;\n\n        if (origorientation <= 4) {\n            for (int line = 0; line < rows_to_write / 2; line++) {\n                unsigned int  *top_line, *bottom_line;\n                top_line = raster + width * line;\n                bottom_line = raster + width * (rows_to_write - line - 1);\n\n                _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * width);\n            }\n        }\n\n        if (origorientation == ORIENTATION_TOPRIGHT || origorientation == ORIENTATION_BOTRIGHT\n                || origorientation == ORIENTATION_RIGHTTOP || origorientation == ORIENTATION_RIGHTBOT) {\n\n                for (int y = 0; y < rows_to_write; y++) {\n                    for (int x = 0; x < width/2; x++) {\n                        uint32 buf = raster[y * width + x];\n                        raster[y * width + x] = raster[y * width + width - 1 - x];\n                        raster[y * width + width - 1 - x] = buf;\n                    }\n                }\n\n        }\n\n        int outY, outX;\n        for (int y = 0; y < rows_to_write; y++) {\n            if (i + y < outStartY || i + y >= outStartY + outHeight) continue;\n            outY = i + y - outStartY;\n            LOGII(\"out Y\", outY);\n            png_bytep pngrow = (png_bytep)malloc(4 * outWidth * sizeof(png_bytep));\n            memcpy(pngrow, raster + y * width + outStartX, outWidth * 4);\n            png_write_row(png_ptr, pngrow);\n            free(pngrow);\n        }\n\n    }\n\n    if (raster) {\n        _TIFFfree(raster);\n        raster = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(work_line_buf);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n\n    return JNI_TRUE;\n}",
    "int TiffToPngConverter::getDecodeMethod() {\n    int method = -1;\n\tuint32 tileWidth, tileHeight;\n\tint readTW = 0, readTH = 0;\n    readTW = TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileWidth);\n    readTH = TIFFGetField(tiffImage, TIFFTAG_TILELENGTH, &tileHeight);\n    if (tileWidth > 0 && tileHeight > 0 && readTH > 0 && readTW > 0) {\n        method = DECODE_METHOD_TILE;\n    } else {\n        int rowPerStrip = -1;\n    \tTIFFGetField(tiffImage, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    \tuint32 stripSize = TIFFStripSize (tiffImage);\n    \tuint32 stripMax = TIFFNumberOfStrips (tiffImage);\n    \tint estimate = width * 3;\n    \tLOGII(\"RPS\", rowPerStrip);\n    \tLOGII(\"stripSize\", stripSize);\n    \tLOGII(\"stripMax\", stripMax);\n    \tif (rowPerStrip != -1 && stripSize > 0 && stripMax > 1 && rowPerStrip < height) {\n    \t    method = DECODE_METHOD_STRIP;\n    \t} else {\n    \tmethod = DECODE_METHOD_IMAGE;\n    \t}\n    }\n\n\tLOGII(\"Decode method\", method);\n\treturn method;\n}",
    "jboolean TiffToBmpConverter::convert()\n{\n    readOptions();\n    LOGI(\"Optioons read done\");\n\n    LOGII(\"inFd=\", inFd);\n    if (inFd == -1) {\n        const char *inCPath = NULL;\n        inCPath = env->GetStringUTFChars(inPath, 0);\n        LOGIS(\"IN path\", inCPath);\n        inFd = open(inCPath, O_RDWR, 0666);\n        if (inFd == -1) {\n            if (throwException) {\n                throw_cant_open_file_exception(env, inPath);\n            }\n            LOGES(\"Can\\'t open in file\", inCPath);\n            env->ReleaseStringUTFChars(inPath, inCPath);\n            return JNI_FALSE;\n        }\n        env->ReleaseStringUTFChars(inPath, inCPath);\n    }\n\n    //open tiff image for reading\n    tiffImage = TIFFFdOpen(inFd, \"\", \"r\");\n    if (tiffImage == NULL) {\n        if (throwException) {\n            if (inFd < 0) {\n                throw_cant_open_file_exception(env, inPath);\n            } else {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n        }\n        return JNI_FALSE;\n    }\n    LOGI(\"Tiff file opened for reading\");\n\n    //open bmp file for writing\n    LOGII(\"outFd=\", outFd);\n    if(outFd == -1) {\n    LOGI(\"Opening bmp as File\");\n        //open tiff file for writing or appending\n        const char *outCPath = NULL;\n        outCPath = env->GetStringUTFChars(outPath, 0);\n        LOGIS(\"OUT path\", outCPath);\n        outFIle = fopen(outCPath, \"w\");\n        if (!outFIle) {\n            throw_cant_open_file_exception(env, outPath);\n            env->ReleaseStringUTFChars(outPath, outCPath);\n            return JNI_FALSE;\n        }\n    } else {\n    LOGI(\"Opening bmp as FD\");\n        outFIle = fdopen(outFd, \"w\");\n        if (!outFIle) {\n            LOGI(\"BMP file is null\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n            LOGES(\"Can\\'t open out file descriptor\", inFd);\n            return JNI_FALSE;\n        }\n    }\n    LOGI(\"BMP file opened\");\n\n    //set tiff directory and read image dimensions\n    TIFFSetDirectory(tiffImage, tiffDirectory);\n    TIFFGetField(tiffImage, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tiffImage, TIFFTAG_IMAGELENGTH, &height);\n    //Getting image orientation and createing ImageOrientation enum\n    TIFFGetField(tiffImage, TIFFTAG_ORIENTATION, &origorientation);\n    //If orientation field is empty - use ORIENTATION_TOPLEFT\n    if (origorientation == 0) {\n        origorientation = ORIENTATION_TOPLEFT;\n    }\n\n    if (!normalizeDecodeArea()) {\n        fclose(outFIle);\n        return JNI_FALSE;\n    }\n\n    LOGII(\"image width\", width);\n    LOGII(\"image height\", height);\n    LOGII(\"image bound width\", boundWidth);\n    LOGII(\"image bound height\", boundHeight);\n\n    unsigned long long imageDataSize = (outWidth * 3 + outWidth % 4) * outHeight;\n\n    LOGII(\"image out width\", outWidth);\n    LOGII(\"image out height\", outHeight);\n\n\n    LOGII(\"image data size\", imageDataSize);\n\n    LOGII(\"size\", sizeof(BITMAPINFOHEADER));\n\n    //char *bm = \"BM\";\n     //memcpy(&bmpHeader->bfType, bm, sizeof(short));\n    bmpHeader->bfType[0] = 0x42;\n    bmpHeader->bfType[1] = 0x4d;\n    bmpHeader->bfSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + imageDataSize;//sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + 3 * width * height;\n    bmpHeader->bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);//sizeof(BITMAPFILEHEADER) + 108;\n\n    bmpInfo->biSize = 108;\n    bmpInfo->biWidth = outWidth;\n    bmpInfo->biHeight = outHeight;\n    bmpInfo->biBitCount = 24;\n    bmpInfo->biPlanes = 1;\n    bmpInfo->biCompression = 0;\n\n    bmpInfo->biSizeImage = 0;//imageDataSize;\n\n    bmpInfo->biClrUsed = 0;\n    bmpInfo->biClrImportant = 0;\n\n    bmpInfo->biPalete[0] = 0;\n    bmpInfo->biPalete[1] = 0;\n    bmpInfo->biPalete[2] = 0;\n\n    for (int i = 0; i < 55; i++) {\n        bmpInfo->reserved[i] = 0;\n    }\n\n    fwrite(bmpHeader,sizeof(BITMAPFILEHEADER),1,outFIle);\n    fseek(outFIle, sizeof(BITMAPFILEHEADER) , SEEK_SET);\n    fwrite(bmpInfo,sizeof(BITMAPINFOHEADER),1,outFIle);\n    fseek(outFIle, sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) , SEEK_SET);\n\n    jboolean result = JNI_FALSE;\n\n    switch(getDecodeMethod()) {\n        case DECODE_METHOD_IMAGE:\n            result = convertFromImage();\n            break;\n        case DECODE_METHOD_TILE:\n           result = convertFromTile();\n           break;\n       case DECODE_METHOD_STRIP:\n           result = convertFromStrip();\n           break;\n    }\n\n    fclose(outFIle);\n    if (!result) {\n        //maybe shold delete file?\n    }\n\n    LOGI(\"fille closed\");\n    conversion_result = result;\n    return conversion_result;\n    //return JNI_FALSE;\n}",
    "jboolean TiffToBmpConverter::convertFromTile() {\n    uint32 tileWidth = 0, tileHeight = 0;\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileWidth);\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileHeight);\n    LOGII(\"Tile width\", tileWidth);\n    LOGII(\"Tile height\", tileHeight);\n\n    uint32 workingWidth = (width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth;\n    LOGII(\"workingWidth \", workingWidth );\n    uint32 rasterSize =  workingWidth  * tileHeight ;\n    LOGII(\"rasterSize \", rasterSize );\n\n\n    unsigned long estimateMem = rasterSize * sizeof(uint32); //raster\n    estimateMem += tileWidth * tileHeight * sizeof(uint32); //tile raster\n    estimateMem += tileWidth * sizeof (uint32); //working buf\n    estimateMem += width * 3 + width % 4; //bufer for writing scanline to bmp\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    uint32 *rasterTile = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n    uint32 *work_line_buf = (uint32*)_TIFFmalloc(tileWidth * sizeof (uint32));\n\n     jlong total = ((width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth)\n                * ((height/tileHeight + (height%tileHeight == 0 ? 0 : 1)) * tileHeight);\n        sendProgress(0, total);\n\n    uint32 row, column;\n\n    int startx = -1, starty = -1, endx = -1, endy = -1;\n    uint32 imageWritedLines = 0;\n\n    //24 bpp bmp should has with multiple 4\n    int scanlineSize = outWidth * 3 + outWidth % 4;\n    unsigned char *scanline = new unsigned char[scanlineSize];\n\n    for (row = 0; row < height; row += tileHeight) {\n        sendProgress(row * width, total);\n        endy = -1;\n        starty = -1;\n        uint32 *raster = (uint32 *)_TIFFmalloc(rasterSize * sizeof(uint32));\n\n        for (column = 0; column < width; column += tileWidth) {\n            if (checkStop()) {\n                free(raster);\n                raster = NULL;\n                if (rasterTile) {\n                    _TIFFfree(rasterTile);\n                    rasterTile = NULL;\n                }\n                if (work_line_buf) {\n                    _TIFFfree(rasterTile);\n                    work_line_buf = NULL;\n                }\n                return JNI_FALSE;\n            }\n            endx = -1;\n            startx = -1;\n            TIFFReadRGBATile(tiffImage, column , row, rasterTile);\n            switch(origorientation) {\n                case 1:\n                case 5:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 2:\n                case 6:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 3:\n                case 7:\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n            }\n\n            normalizeTile(tileHeight, tileWidth, rasterTile);\n\n            //find start and end position\n            for (int ty = 0; ty < tileHeight; ty++) {\n\n                for (int tx = 0; tx < tileWidth; tx++) {\n                    if (rasterTile[ty * tileWidth + tx] != 0) {\n                        if (startx == -1) {\n                            startx = tx;\n                        }\n                        if (starty == -1) {\n                            starty = ty;\n                        }\n\n                        if (tx > endx)\n                            endx = tx;\n                        if (ty > endy)\n                            endy = ty;\n\n                        uint32 rasterPos = (ty ) * workingWidth + (tx + column);\n                        //LOGII(\"rp\", rasterPos);\n                        raster[rasterPos] = rasterTile[ty * tileWidth + tx];\n                    }\n\n                }\n            }\n        }\n\n        int outY, outX;\n        int tileShift = 0;\n        for (int y = starty; y < tileHeight; y++) {\n            if (imageWritedLines == height) break;\n            if (y + row < outStartY || y + row >= outStartY + outHeight) continue;\n            outY = y + row - outStartY;\n            for (int x = 0; x < width * 3; x += 3) {\n                if (x < outStartX * 3 || x >= (outStartX + outWidth) * 3) continue;\n                outX = x - (outStartX*3);\n                uint32 pix = raster[y * workingWidth + x/3];\n                unsigned char *vp = (unsigned char *)&pix;\n                scanline[outX] = vp[2];\n                scanline[outX+1] = vp[1];\n                scanline[outX+2] = vp[0];\n            }\n\n            //in bmp lines stored fliped verticaly. Write lines from bottom to top\n            fseek(outFIle, 122 + (/*height - tileShift - row*/outHeight - outY - 1) * scanlineSize , SEEK_SET);\n            fwrite(scanline,scanlineSize,1,outFIle);\n            tileShift++;\n            imageWritedLines++;\n        }\n        //LOGII(\"imageWritedLines\", imageWritedLines);\n        free(raster);\n    }\n    free(scanline);\n\n    if (rasterTile) {\n        _TIFFfree(rasterTile);\n        rasterTile = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(rasterTile);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n    return JNI_TRUE;\n\n}",
    "jboolean TiffToBmpConverter::convertFromStrip() {\n    uint32 stripSize = TIFFStripSize (tiffImage);\n    uint32 stripMax = TIFFNumberOfStrips (tiffImage);\n    int rowPerStrip = -1;\n    TIFFGetField(tiffImage, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n\n    unsigned long estimateMem = width * sizeof(uint32);//working buf\n    estimateMem += width * rowPerStrip * sizeof (uint32);//raster\n    estimateMem += outWidth * 3 + outWidth % 4;\n    //estimateMem += 4 * width * sizeof(png_bytep); //buf for writing to png\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    LOGII(\"rps\", rowPerStrip);\n    LOGII(\"sm\", stripMax);\n\n    jlong total = stripMax * rowPerStrip * width;\n    sendProgress(0, total);\n\n    uint32* work_line_buf = (uint32 *)_TIFFmalloc(width * sizeof(uint32));\n    uint32* raster = (uint32 *)_TIFFmalloc(width * rowPerStrip * sizeof (uint32));\n\n    uint32 rows_to_write = 0;\n\n    //24 bpp bmp should has with multiple 4\n    int rowSize = outWidth * 3 + outWidth % 4;\n    unsigned char *row = new unsigned char[rowSize];\n    for (int i = 0; i < stripMax*rowPerStrip; i += rowPerStrip) {\n        if (checkStop()) {\n            if (raster) {\n                _TIFFfree(raster);\n                raster = NULL;\n            }\n            if (work_line_buf) {\n                _TIFFfree(work_line_buf);\n                work_line_buf = NULL;\n            }\n            return JNI_FALSE;\n        }\n\n        if ((i < outStartY && i + rowPerStrip < outStartY) || (i >= outStartY + outHeight && i + rowPerStrip >= outStartY + outHeight)) continue;\n        LOGII(\"i\", i);\n\n        sendProgress(i * width, total);\n        TIFFReadRGBAStrip(tiffImage, i, raster);\n\n        rows_to_write = 0;\n        if( i + rowPerStrip > height )\n            rows_to_write = height - i;\n        else\n            rows_to_write = rowPerStrip;\n\n        if (origorientation <= 4) {\n            for (int line = 0; line < rows_to_write / 2; line++) {\n                unsigned int  *top_line, *bottom_line;\n                top_line = raster + width * line;\n                bottom_line = raster + width * (rows_to_write - line - 1);\n\n                _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * width);\n            }\n        }\n\n        if (origorientation == ORIENTATION_TOPRIGHT || origorientation == ORIENTATION_BOTRIGHT\n                || origorientation == ORIENTATION_RIGHTTOP || origorientation == ORIENTATION_RIGHTBOT) {\n\n                for (int y = 0; y < rows_to_write; y++) {\n                    for (int x = 0; x < width/2; x++) {\n                        uint32 buf = raster[y * width + x];\n                        raster[y * width + x] = raster[y * width + width - 1 - x];\n                        raster[y * width + width - 1 - x] = buf;\n                    }\n                }\n        }\n\n        int outY, outX;\n        for (int y = 0; y < rows_to_write; y++) {\n            if (i + y < outStartY || i + y >= outStartY + outHeight) continue;\n            outY = i + y - outStartY;\n            for (int x = 0; x < width * 3; x += 3) {\n                if (x < outStartX * 3 || x >= (outStartX + outWidth) * 3) continue;\n                outX = x - (outStartX*3);\n                uint32 pix = raster[y * width + x/3];\n                unsigned char *vp = (unsigned char *)&pix;\n                //in bmp colors stores as bgr\n                row[outX] = vp[2]; //red\n                row[outX+1] = vp[1]; //green\n                row[outX+2] = vp[0];   //blue\n            }\n\n            //in bmp lines stored fliped verticaly. Write lines from bottom to top\n            fseek(outFIle, 122 + (outHeight - outY - 1) * rowSize , SEEK_SET);\n            fwrite(row,rowSize,1,outFIle);\n        }\n    }\n    free(row);\n\n    if (raster) {\n        _TIFFfree(raster);\n        raster = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(work_line_buf);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n\n    return JNI_TRUE;\n}",
    "jboolean TiffToJpgConverter::convert()\n{\n    readOptions();\n    LOGI(\"Optioons read done\");\n\n    LOGII(\"inFd=\", inFd);\n    if (inFd == -1) {\n        const char *inCPath = NULL;\n        inCPath = env->GetStringUTFChars(inPath, 0);\n        LOGIS(\"IN path\", inCPath);\n        inFd = open(inCPath, O_RDWR, 0666);\n        if (inFd == -1) {\n            if (throwException) {\n                throw_cant_open_file_exception(env, inPath);\n            }\n            LOGES(\"Can\\'t open in file\", inCPath);\n            env->ReleaseStringUTFChars(inPath, inCPath);\n            return JNI_FALSE;\n        }\n        env->ReleaseStringUTFChars(inPath, inCPath);\n    }\n\n    //open tiff image for reading\n    tiffImage = TIFFFdOpen(inFd, \"\", \"r\");\n    if (tiffImage == NULL) {\n        if (throwException) {\n            if (inFd < 0) {\n                throw_cant_open_file_exception(env, inPath);\n            } else {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n        }\n        return JNI_FALSE;\n    }\n    LOGI(\"Tiff file opened for reading\");\n\n\n    //in c++ path\n    /*const char *strTiffPath = NULL;\n    strTiffPath = env->GetStringUTFChars(inPath, 0);\n    LOGIS(\"IN path\", strTiffPath);\n\n    //open tiff image for reading\n    tiffImage = TIFFOpen(strTiffPath, \"r\");\n    if (tiffImage == NULL) {\n        if (throwException) {\n            throw_cant_open_file_exception(env, inPath);\n        }\n        LOGES(\"Can\\'t open in file\", strTiffPath);\n        env->ReleaseStringUTFChars(inPath, strTiffPath);\n        return JNI_FALSE;\n    } else {\n        env->ReleaseStringUTFChars(inPath, strTiffPath);\n    }\n    LOGI(\"Tiff file opened for reading\");*/\n\n    //open jpg file for writing\n    LOGII(\"outFd=\", outFd);\n    if(outFd == -1) {\n    LOGI(\"Opening jpg as File\");\n        //open tiff file for writing or appending\n        const char *outCPath = NULL;\n        outCPath = env->GetStringUTFChars(outPath, 0);\n        LOGIS(\"OUT path\", outCPath);\n        jpegFile = fopen(outCPath, \"w\");\n        if (!jpegFile) {\n            throw_cant_open_file_exception(env, outPath);\n            env->ReleaseStringUTFChars(outPath, outCPath);\n            return JNI_FALSE;\n        }\n    } else {\n    LOGI(\"Opening jpg as FD\");\n        jpegFile = fdopen(outFd, \"w\");\n        if (!jpegFile) {\n            LOGI(\"JPG file is null\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n            LOGES(\"Can\\'t open out file descriptor\", inFd);\n            return JNI_FALSE;\n        }\n    }\n    LOGI(\"JPG file opened\");\n    /*const char *strPngPath = NULL;\n    strPngPath = env->GetStringUTFChars(outPath, 0);\n    LOGIS(\"OUT path\", strPngPath);\n    jpegFile = fopen(strPngPath, \"wb\");\n    if (!jpegFile) {\n        if (throwException) {\n            throw_cant_open_file_exception(env, outPath);\n        }\n        LOGES(\"Can\\'t open out file\", strPngPath);\n        env->ReleaseStringUTFChars(outPath, strPngPath);\n        return JNI_FALSE;\n    } else {\n        env->ReleaseStringUTFChars(outPath, strPngPath);\n    }*/\n\n\n    LOGI(\"initialize jpeg structure\");\n    //set error handling\n    cinfo.err = jpeg_std_error(&jerr);\n    LOGI(\"initialize error handling done\");\n    //initialize jpeg compression object\n    jpeg_create_compress(&cinfo);\n    jpeg_struct_init = 1;\n    LOGI(\"initialize compress done\");\n    //set phisical file for jpeg\n    jpeg_stdio_dest(&cinfo, jpegFile);\n    LOGI(\"initialize dest file done\");\n\n    //set tiff directory and read image dimensions\n    TIFFSetDirectory(tiffImage, tiffDirectory);\n    TIFFGetField(tiffImage, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tiffImage, TIFFTAG_IMAGELENGTH, &height);\n    //Getting image orientation and createing ImageOrientation enum\n    TIFFGetField(tiffImage, TIFFTAG_ORIENTATION, &origorientation);\n    //If orientation field is empty - use ORIENTATION_TOPLEFT\n    if (origorientation == 0) {\n        origorientation = ORIENTATION_TOPLEFT;\n    }\n\n    if (!normalizeDecodeArea()) {\n        return JNI_FALSE;\n    }\n\n    LOGII(\"image width\", width);\n    LOGII(\"image height\", height);\n    LOGII(\"image bound width\", boundWidth);\n    LOGII(\"image bound height\", boundHeight);\n    LOGII(\"image out width\", outWidth);\n    LOGII(\"image out height\", outHeight);\n\n    cinfo.image_width = outWidth;\n    cinfo.image_height = outHeight;\n    cinfo.input_components = 3;\n    cinfo.in_color_space = JCS_RGB;\n\n    LOGI(\"writing img parameters done\");\n\n    jpeg_set_defaults(&cinfo);\n    LOGI(\"set defaults done\");\n    jpeg_set_quality(&cinfo, JPEG_QUALITY, TRUE /* limit to baseline-JPEG values */);\n    LOGI(\"set quality done\");\n\n    //write file header\n    jpeg_start_compress(&cinfo, TRUE);\n    LOGI(\"start compressing\");\n\n    jboolean result = JNI_FALSE;\n\n    switch(getDecodeMethod()) {\n        case DECODE_METHOD_IMAGE:\n            result = convertFromImage();\n            break;\n        case DECODE_METHOD_TILE:\n            result = convertFromTile();\n            break;\n        case DECODE_METHOD_STRIP:\n            result = convertFromStrip();\n            break;\n    }\n\n    if (result) {\n        jpeg_finish_compress(&cinfo);\n    }\n    conversion_result = result;\n    return conversion_result;\n}",
    "jboolean TiffToJpgConverter::convertFromTile() {\n    uint32 tileWidth = 0, tileHeight = 0;\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileWidth);\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileHeight);\n    LOGII(\"Tile width\", tileWidth);\n    LOGII(\"Tile height\", tileHeight);\n\n    //uint32 *raster = (uint32 *)_TIFFmalloc(width * tileHeight * sizeof(uint32));\n    uint32 workingWidth = (width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth;\n    LOGII(\"workingWidth \", workingWidth );\n    uint32 rasterSize =  workingWidth  * tileHeight ;\n    LOGII(\"rasterSize \", rasterSize );\n    //uint32 *raster = (uint32 *)_TIFFmalloc(rasterSize * sizeof(uint32));\n\n\n    unsigned long estimateMem = rasterSize * sizeof(uint32); //raster\n    estimateMem += tileWidth * tileHeight * sizeof(uint32); //tile raster\n    estimateMem += tileWidth * sizeof (uint32); //working buf\n    estimateMem += outWidth * sizeof(unsigned char) * 3; //bufer for writing to jpg\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    uint32 *rasterTile = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n    uint32 *work_line_buf = (uint32*)_TIFFmalloc(tileWidth * sizeof (uint32));\n\n     jlong total = ((width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth)\n                * ((height/tileHeight + (height%tileHeight == 0 ? 0 : 1)) * tileHeight);\n        sendProgress(0, total);\n\n    uint32 row, column;\n\n    int startx = -1, starty = -1, endx = -1, endy = -1;\n    uint32 imageWritedLines = 0;\n\n    for (row = 0; row < height; row += tileHeight) {\n        sendProgress(row * width, total);\n        endy = -1;\n        starty = -1;\n        uint32 *raster = (uint32 *)_TIFFmalloc(rasterSize * sizeof(uint32));\n\n        for (column = 0; column < width; column += tileWidth) {\n            if (checkStop()) {\n                free(raster);\n                raster = NULL;\n                if (rasterTile) {\n                    _TIFFfree(rasterTile);\n                    rasterTile = NULL;\n                }\n                if (work_line_buf) {\n                    _TIFFfree(rasterTile);\n                    work_line_buf = NULL;\n                }\n                return JNI_FALSE;\n            }\n            endx = -1;\n            startx = -1;\n            TIFFReadRGBATile(tiffImage, column , row, rasterTile);\n            switch(origorientation) {\n                case 1:\n                case 5:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 2:\n                case 6:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 3:\n                case 7:\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n            }\n\n            normalizeTile(tileHeight, tileWidth, rasterTile);\n\n            //find start and end position\n            for (int ty = 0; ty < tileHeight; ty++) {\n\n                for (int tx = 0; tx < tileWidth; tx++) {\n                    if (rasterTile[ty * tileWidth + tx] != 0) {\n                        if (startx == -1) {\n                            startx = tx;\n                        }\n                        if (starty == -1) {\n                            starty = ty;\n                        }\n\n                        if (tx > endx)\n                            endx = tx;\n                        if (ty > endy)\n                            endy = ty;\n\n                        uint32 rasterPos = (ty ) * workingWidth + (tx + column);\n                        //LOGII(\"rp\", rasterPos);\n                        raster[rasterPos] = rasterTile[ty * tileWidth + tx];\n                    }\n\n                }\n            }\n        }\n\n        int outY, outX;\n        JSAMPROW row_pointer[1];\n        for (int y = starty; y < tileHeight; y++) {\n            if (imageWritedLines == height) break;\n            if (y + row < outStartY || y + row >= outStartY + outHeight) continue;\n            outY = y + row - outStartY;\n            unsigned char *jpgrow = (unsigned char*)malloc(outWidth * sizeof(unsigned char) * 3);\n\n           // uint32 *rasterLine = (uint32 *)malloc(width * sizeof(uint32));\n\n            //for (int x = startx, x2 = 0; x2 < width; x++, x2++) {\n            //   rasterLine[x2] = raster[y * workingWidth + x];\n            //}\n\n            for (int x = 0; x < width * 3; x += 3) {\n                if (x < outStartX * 3 || x >= (outStartX + outWidth) * 3) continue;\n                outX = x - (outStartX*3);\n                uint32 pix = raster[y * workingWidth + x/3];\n                unsigned char *vp = (unsigned char *)&pix;\n                jpgrow[outX] = vp[0];\n                jpgrow[outX+1] = vp[1];\n                jpgrow[outX+2] = vp[2];\n            }\n            row_pointer[0] = jpgrow;\n            jpeg_write_scanlines(&cinfo, row_pointer, 1);\n            delete(jpgrow);\n            //delete(rasterLine);\n\n            imageWritedLines++;\n        }\n        //LOGII(\"imageWritedLines\", imageWritedLines);\n        free(raster);\n    }\n\n    /*if (raster) {\n        _TIFFfree(raster);\n        raster = NULL;\n    }*/\n\n    if (rasterTile) {\n        _TIFFfree(rasterTile);\n        rasterTile = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(rasterTile);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n    return JNI_TRUE;\n\n}",
    "jboolean TiffToJpgConverter::convertFromStrip() {\n    uint32 stripSize = TIFFStripSize (tiffImage);\n    uint32 stripMax = TIFFNumberOfStrips (tiffImage);\n    int rowPerStrip = -1;\n    TIFFGetField(tiffImage, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n\n    unsigned long estimateMem = width * sizeof(uint32);//working buf\n    estimateMem += width * rowPerStrip * sizeof (uint32);//raster\n    estimateMem += outWidth * sizeof(unsigned char) * 3; //buf for writing to jpg\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    jlong total = stripMax * rowPerStrip * width;\n    sendProgress(0, total);\n\n    uint32* work_line_buf = (uint32 *)_TIFFmalloc(width * sizeof(uint32));\n    uint32* raster = (uint32 *)_TIFFmalloc(width * rowPerStrip * sizeof (uint32));\n\n    uint32 rows_to_write = 0;\n\n    for (int i = 0; i < stripMax*rowPerStrip; i += rowPerStrip) {\n        if (checkStop()) {\n            if (raster) {\n                _TIFFfree(raster);\n                raster = NULL;\n            }\n            if (work_line_buf) {\n                _TIFFfree(work_line_buf);\n                work_line_buf = NULL;\n            }\n            return JNI_FALSE;\n        }\n        sendProgress(i * width, total);\n        TIFFReadRGBAStrip(tiffImage, i, raster);\n\n        rows_to_write = 0;\n        if( i + rowPerStrip > height )\n            rows_to_write = height - i;\n        else\n            rows_to_write = rowPerStrip;\n\n        if (origorientation <= 4) {\n            for (int line = 0; line < rows_to_write / 2; line++) {\n                unsigned int  *top_line, *bottom_line;\n                top_line = raster + width * line;\n                bottom_line = raster + width * (rows_to_write - line - 1);\n\n                _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * width);\n            }\n        }\n\n        if (origorientation == ORIENTATION_TOPRIGHT || origorientation == ORIENTATION_BOTRIGHT\n                || origorientation == ORIENTATION_RIGHTTOP || origorientation == ORIENTATION_RIGHTBOT) {\n\n                for (int y = 0; y < rows_to_write; y++) {\n                    for (int x = 0; x < width/2; x++) {\n                        uint32 buf = raster[y * width + x];\n                        raster[y * width + x] = raster[y * width + width - 1 - x];\n                        raster[y * width + width - 1 - x] = buf;\n                    }\n                }\n\n        }\n        int outY, outX;\n        JSAMPROW row_pointer[1];\n        for (int y = 0; y < rows_to_write; y++) {\n            if (i + y < outStartY || i + y >= outStartY + outHeight) continue;\n            outY = i + y - outStartY;\n\n            unsigned char *jpgrow = (unsigned char*)malloc(outWidth * sizeof(unsigned char) * 3);\n\n            for (int x = 0; x < width * 3; x += 3) {\n                if (x < outStartX * 3 || x >= (outStartX + outWidth) * 3) continue;\n                outX = x - (outStartX*3);\n                uint32 pix = raster[y * width + x/3];\n                unsigned char *vp = (unsigned char *)&pix;\n                jpgrow[outX] = vp[0];\n                jpgrow[outX+1] = vp[1];\n                jpgrow[outX+2] = vp[2];\n            }\n            row_pointer[0] = jpgrow;\n            jpeg_write_scanlines(&cinfo, row_pointer, 1);\n            delete(jpgrow);\n\n            /*png_bytep row = (png_bytep)malloc(4 * width * sizeof(png_bytep));\n            memcpy(row, raster + (y * width), width * 4);\n            png_write_row(png_ptr, row);\n            delete(row);*/\n        }\n\n    }\n\n    if (raster) {\n        _TIFFfree(raster);\n        raster = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(work_line_buf);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n\n    return JNI_TRUE;\n}",
    "int TiffToJpgConverter::getDecodeMethod() {\n    int method = -1;\n\tuint32 tileWidth, tileHeight;\n\tint readTW = 0, readTH = 0;\n    readTW = TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileWidth);\n    readTH = TIFFGetField(tiffImage, TIFFTAG_TILELENGTH, &tileHeight);\n    if (tileWidth > 0 && tileHeight > 0 && readTH > 0 && readTW > 0) {\n        method = DECODE_METHOD_TILE;\n    } else {\n        int rowPerStrip = -1;\n    \tTIFFGetField(tiffImage, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    \tuint32 stripSize = TIFFStripSize (tiffImage);\n    \tuint32 stripMax = TIFFNumberOfStrips (tiffImage);\n    \tint estimate = width * 3;\n    \tLOGII(\"RPS\", rowPerStrip);\n    \tLOGII(\"stripSize\", stripSize);\n    \tLOGII(\"stripMax\", stripMax);\n    \tif (rowPerStrip != -1 && stripSize > 0 && stripMax > 1 && rowPerStrip < height) {\n    \t    method = DECODE_METHOD_STRIP;\n    \t} else {\n    \tmethod = DECODE_METHOD_IMAGE;\n    \t}\n    }\n\n\tLOGII(\"Decode method\", method);\n\treturn method;\n    /*int method = -1;\n\tuint32 tileWidth, tileHeight;\n\tint readTW = 0, readTH = 0;\n    readTW = TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileWidth);\n    readTH = TIFFGetField(tiffImage, TIFFTAG_TILELENGTH, &tileHeight);\n    int rowPerStrip = -1;\n    TIFFGetField(tiffImage, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    uint32 stripSize = TIFFStripSize (tiffImage);\n    uint32 stripMax = TIFFNumberOfStrips (tiffImage);\n    int estimate = width * 3;\n    LOGII(\"RPS\", rowPerStrip);\n    LOGII(\"stripSize\", stripSize);\n    LOGII(\"stripMax\", stripMax);\n\n    if (rowPerStrip != -1 && stripSize > 0 && stripMax > 1 && rowPerStrip < height) {\n        method = DECODE_METHOD_STRIP;\n    } else if (tileWidth > 0 && tileHeight > 0 && readTH > 0 && readTW > 0) {\n        method = DECODE_METHOD_TILE;\n    } else {\n        method = DECODE_METHOD_IMAGE;\n    }\n\tLOGII(\"Decode method\", method);\n\treturn method;*/\n}",
    "void image_info::readtif(const char *filename){\n#ifdef USE_LIBTIFF\n#ifdef _USE_DL_\n  if(!have_tiff){\n    if(init_tiff(LIBTIFF_SOLIBRARY)){ \n      have_tiff = 1;\n    }\n  }\n  if(!have_tiff){\n    printf(\"tiff library not found\\n\");\n    printf(\"Please try reading from a supported format\\n\");\n    return;\n  }\n#endif  \n  TIFF* tif = TIFFOpen(filename, \"r\");\n  uint16 spp;\n  TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n  if(spp!=1&&spp!=3&&spp!=4){\n    uint32 tileWidth, tileLength;\n    uint32 *bc, *bc2;\n    bool istiled = true, isstripped = true;\n    int success = TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tileWidth);\n    if(!success)  istiled = false;\n    success = TIFFGetField(tif, TIFFTAG_TILELENGTH, &tileLength);\n    if(!success)  istiled = false;\n    success = TIFFGetField(tif, TIFFTAG_STRIPBYTECOUNTS, &bc);\n    if(!success)  isstripped = false;\n    uint32 stripsize = bc[0];\n    success = TIFFGetField(tif,  TIFFTAG_TILEBYTECOUNTS, &bc2);\n    if(!success)  isstripped = false;\n    uint32 tilesize = bc2[0];\n    if(istiled&&isstripped) {\n      printf(\"Seems to be tiled and stripped in readtiff.\\n\");\n      printf(\"Unlikley!!, quitting ...\\n\");\n      return;\n    }\n    if(istiled) {\n      pixels = new unsigned char[width*height*spp];\n      colourspace = spp;\n      if(spp==2){\n        colourspace_type = IMAGEINFO_MONOA;\n      }else{\n        printf(\"Unsupported samples per pixel in readtiff: %d\\n\",spp);\n        delete [] pixels;\n        return;\n      }\n      /*\n      printf(\"Samples per pixel size of %d tiled tiff files is currently not supported by CCP4MG\\n\",spp);\n      printf(\"Please convert to another tiff format, eg rgb or rgb+alpha\\n\");\n      printf(\"The following is developer info to help rectify the problem\\n\");\n      printf(\"Scanline size:%d\\n\",TIFFScanlineSize(tif));\n      printf(\"Number of tiles:%d\\n\",TIFFNumberOfTiles(tif));\n      printf(\"Number of strips:%d\\n\",TIFFNumberOfStrips(tif));\n      printf(\"Strip size:%d\\n\",TIFFStripSize(tif));\n      printf(\"Strip size from TIFFGetField:%d\\n\",stripsize);\n      printf(\"Tile size from TIFFGetField:%d\\n\",tilesize);\n      printf(\"Tile width:%d\\n\",tileWidth);\n      printf(\"Tile length:%d\\n\",tileLength);\n      printf(\"Seems to be tiled\\n\");\n      */\n      uint32 imageWidth, imageLength;\n      uint32 tileWidth, tileLength;\n      uint32 x, y;\n      tdata_t buf;\n      uint16 config;\n\n      TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n      TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imageLength);\n      TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tileWidth);\n      TIFFGetField(tif, TIFFTAG_TILELENGTH, &tileLength);\n      TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n      buf = _TIFFmalloc(TIFFTileSize(tif));\n      if (config == PLANARCONFIG_CONTIG) {\n        for (y = 0; y < imageLength; y += tileLength){\n          for (x = 0; x < imageWidth; x += tileWidth){\n            TIFFReadTile(tif, buf, x, y, 0, 0);\n            for(unsigned jj=0;jj<tileLength;jj++){\n              for(unsigned ii=0;ii<tileWidth*spp;ii++){\n                pixels[(y+jj)*width*spp+x+ii] = ((unsigned char *)buf)[jj*tileWidth*spp+ii];\n              }\n            }\n          }\n        }\n      } else if (config == PLANARCONFIG_SEPARATE) {\n        uint16 s;\n        for (s = 0; s < spp; s++){\n          for (y = 0; y < imageLength; y += tileLength){\n            for (x = 0; x < imageWidth; x += tileWidth){\n              TIFFReadTile(tif, buf, x, y, 0, s);\n              for(unsigned jj=0;jj<tileLength;jj++){\n                for(unsigned ii=0;ii<tileWidth;ii++){\n                  pixels[(y+jj)*width*spp+x+ii+s] = ((unsigned char *)buf)[jj*tileWidth+ii];\n                }\n              }\n            }\n          }\n        }\n      }\n      _TIFFfree(buf);\n    }\n    if(isstripped) {\n      pixels = new unsigned char[width*height*spp];\n      colourspace = spp;\n      if(spp==2){\n        colourspace_type = IMAGEINFO_MONOA;\n      }else{\n        printf(\"Unsupported samples per pixel in readtiff: %d\\n\",spp);\n        delete [] pixels;\n        return;\n      }\n      uint32 imagelength;\n      tdata_t buf;\n      uint32 row;\n      uint16 config;\n\n      TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imagelength);\n      TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n      buf = _TIFFmalloc(TIFFScanlineSize(tif));\n      if (config == PLANARCONFIG_CONTIG) {\n        for (row = 0; row < imagelength; row++){\n          TIFFReadScanline(tif, buf, row,0);\n          /* Just possible this may ignore a colourmap, not sure */\n          memcpy(pixels+row*TIFFScanlineSize(tif),(unsigned char *)buf,sizeof(unsigned char)*TIFFScanlineSize(tif));\n        }\n      } else if (config == PLANARCONFIG_SEPARATE) {\n        uint16 s;\n        for (s = 0; s < spp; s++){\n          for (row = 0; row < imagelength; row++){\n            TIFFReadScanline(tif, buf, row, s);\n            for(int ii=0;ii<width;ii++){\n              pixels[spp*ii+s+width*row*spp] = ((unsigned char *)buf)[ii];\n            }\n          }\n        }\n      }\n      _TIFFfree(buf);\n    }\n  } else {\n    uint32 *raster;\n    raster = (uint32*) _TIFFmalloc(width*height*sizeof(uint32));\n    if(!raster){\n      printf(\"Error reading tif image\\n\");\n      return;\n    }\n    TIFFReadRGBAImage(tif, width, height, raster, 0);\n    pixels = new unsigned char[width*height*4];\n    colourspace = 4;\n    colourspace_type = IMAGEINFO_RGBA;\n    int ii=0;\n    for(int i=height-1;i>=0;i--){\n      for(int j=0;j<width;j++){\n         uint32 pix = raster[i*width+j];\n         unsigned char a = (pix>>24)&255;\n         unsigned char b = (pix>>16)&255;\n         unsigned char g = (pix>>8)&255;\n         unsigned char r = pix&255;\n         pixels[ii++] = r;\n         pixels[ii++] = g;\n         pixels[ii++] = b;\n         pixels[ii++] = a;\n      }\n    }\n    _TIFFfree(raster);\n  }\n  TIFFClose(tif);\n#else\n    printf(\"No tiff support compiled into this program\\n\");\n    printf(\"Please install libtiff (if not already done) and\\n\");\n    printf(\"rebuild adding -DUSE_LIBTIFF to C_DEFINES\\n\");\n    printf(\"and CXX_DEFINES. Or convert input file to a\\n\");\n    printf(\"supported format.\\n\");\n#endif  \n}",
    "bool QTiffHandler::read(QImage *image)\n{\n   if (!canRead()) {\n      return false;\n   }\n\n   TIFF *const tiff = TIFFClientOpen(\"foo\",\n         \"r\",\n         this,\n         qtiffReadProc,\n         qtiffWriteProc,\n         qtiffSeekProc,\n         qtiffCloseProc,\n         qtiffSizeProc,\n         qtiffMapProc,\n         qtiffUnmapProc);\n\n   if (!tiff) {\n      return false;\n   }\n\n   uint32_t width;\n   uint32_t height;\n   uint16_t photometric;\n\n   if (!TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width)\n      || !TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height)\n      || !TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &photometric)) {\n      TIFFClose(tiff);\n      return false;\n   }\n\n   // BitsPerSample defaults to 1 according to the TIFF spec.\n   uint16_t bitPerSample;\n   if (!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitPerSample)) {\n      bitPerSample = 1;\n   }\n\n   uint16_t samplesPerPixel; // they may be e.g. grayscale with 2 samples per pixel\n   if (!TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel)) {\n      samplesPerPixel = 1;\n   }\n\n   bool grayscale = photometric == PHOTOMETRIC_MINISBLACK || photometric == PHOTOMETRIC_MINISWHITE;\n   if (grayscale && bitPerSample == 1 && samplesPerPixel == 1) {\n      if (image->size() != QSize(width, height) || image->format() != QImage::Format_Mono) {\n         *image = QImage(width, height, QImage::Format_Mono);\n      }\n      QVector<QRgb> colortable(2);\n      if (photometric == PHOTOMETRIC_MINISBLACK) {\n         colortable[0] = 0xff000000;\n         colortable[1] = 0xffffffff;\n      } else {\n         colortable[0] = 0xffffffff;\n         colortable[1] = 0xff000000;\n      }\n      image->setColorTable(colortable);\n\n      if (!image->isNull()) {\n         for (uint32_t y = 0; y < height; ++y) {\n            if (TIFFReadScanline(tiff, image->scanLine(y), y, 0) < 0) {\n               TIFFClose(tiff);\n               return false;\n            }\n         }\n      }\n   } else {\n      if ((grayscale || photometric == PHOTOMETRIC_PALETTE) && bitPerSample == 8 && samplesPerPixel == 1) {\n         if (image->size() != QSize(width, height) || image->format() != QImage::Format_Indexed8) {\n            *image = QImage(width, height, QImage::Format_Indexed8);\n         }\n         if (!image->isNull()) {\n            const uint16_t tableSize = 256;\n            QVector<QRgb> qtColorTable(tableSize);\n\n            if (grayscale) {\n               for (int i = 0; i < tableSize; ++i) {\n                  const int c = (photometric == PHOTOMETRIC_MINISBLACK) ? i : (255 - i);\n                  qtColorTable[i] = qRgb(c, c, c);\n               }\n\n            } else {\n               // create the color table\n               uint16_t *redTable   = nullptr;\n               uint16_t *greenTable = nullptr;\n               uint16_t *blueTable  = nullptr;\n\n               if (!TIFFGetField(tiff, TIFFTAG_COLORMAP, &redTable, &greenTable, &blueTable)) {\n                  TIFFClose(tiff);\n                  return false;\n               }\n               if (!redTable || !greenTable || !blueTable) {\n                  TIFFClose(tiff);\n                  return false;\n               }\n\n               for (int i = 0; i < tableSize ; ++i) {\n                  const int red = redTable[i] / 257;\n                  const int green = greenTable[i] / 257;\n                  const int blue = blueTable[i] / 257;\n                  qtColorTable[i] = qRgb(red, green, blue);\n               }\n            }\n\n            image->setColorTable(qtColorTable);\n            for (uint32_t y = 0; y < height; ++y) {\n               if (TIFFReadScanline(tiff, image->scanLine(y), y, 0) < 0) {\n                  TIFFClose(tiff);\n                  return false;\n               }\n            }\n\n            // free redTable, greenTable and greenTable done by libtiff\n         }\n      } else {\n         if (image->size() != QSize(width, height) || image->format() != QImage::Format_ARGB32) {\n            *image = QImage(width, height, QImage::Format_ARGB32);\n         }\n         if (!image->isNull()) {\n            const int stopOnError = 1;\n            if (TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32_t *>(image->bits()), ORIENTATION_TOPLEFT,\n                  stopOnError)) {\n               for (uint32_t y = 0; y < height; ++y) {\n                  convert32BitOrder(image->scanLine(y), width);\n               }\n            } else {\n               TIFFClose(tiff);\n               return false;\n            }\n         }\n      }\n   }\n\n   if (image->isNull()) {\n      TIFFClose(tiff);\n      return false;\n   }\n\n   float resX = 0;\n   float resY = 0;\n   uint16_t resUnit;\n\n   if (!TIFFGetField(tiff, TIFFTAG_RESOLUTIONUNIT, &resUnit)) {\n      resUnit = RESUNIT_INCH;\n   }\n\n   if (TIFFGetField(tiff, TIFFTAG_XRESOLUTION, &resX)\n      && TIFFGetField(tiff, TIFFTAG_YRESOLUTION, &resY)) {\n      switch (resUnit) {\n         case RESUNIT_CENTIMETER:\n            image->setDotsPerMeterX(qRound(resX * 100));\n            image->setDotsPerMeterY(qRound(resY * 100));\n            break;\n         case RESUNIT_INCH:\n            image->setDotsPerMeterX(qRound(resX * (100 / 2.54)));\n            image->setDotsPerMeterY(qRound(resY * (100 / 2.54)));\n            break;\n         default:\n            // do nothing as defaults have already\n            // been set within the QImage class\n            break;\n      }\n   }\n\n   // rotate the image if the orientation is defined in the file\n   uint16_t orientationTag;\n   if (TIFFGetField(tiff, TIFFTAG_ORIENTATION, &orientationTag)) {\n      if (image->format() == QImage::Format_ARGB32) {\n         // TIFFReadRGBAImageOriented() flip the image but does not rotate them\n         switch (orientationTag) {\n            case 5:\n               rotate_right_mirror_horizontal(image);\n               break;\n            case 6:\n               rotate_right_mirror_vertical(image);\n               break;\n            case 7:\n               rotate_right_mirror_horizontal(image);\n               break;\n            case 8:\n               rotate_right_mirror_vertical(image);\n               break;\n         }\n      } else {\n         switch (orientationTag) {\n            case 1: // default orientation\n               break;\n            case 2: // mirror horizontal\n               *image = image->mirrored(true, false);\n               break;\n            case 3: // mirror both\n               *image = image->mirrored(true, true);\n               break;\n            case 4: // mirror vertical\n               *image = image->mirrored(false, true);\n               break;\n            case 5: { // rotate right mirror horizontal\n               QMatrix transformation;\n               transformation.rotate(90);\n               *image = image->transformed(transformation);\n               *image = image->mirrored(true, false);\n               break;\n            }\n            case 6: { // rotate right\n               QMatrix transformation;\n               transformation.rotate(90);\n               *image = image->transformed(transformation);\n               break;\n            }\n            case 7: { // rotate right, mirror vertical\n               QMatrix transformation;\n               transformation.rotate(90);\n               *image = image->transformed(transformation);\n               *image = image->mirrored(false, true);\n               break;\n            }\n            case 8: { // rotate left\n               QMatrix transformation;\n               transformation.rotate(270);\n               *image = image->transformed(transformation);\n               break;\n            }\n         }\n      }\n   }\n\n\n   TIFFClose(tiff);\n   return true;\n}",
    "QVariant QTiffHandler::option(ImageOption option)\n{\n   if (option == Size && canRead()) {\n      QSize imageSize;\n      qint64 pos = device()->pos();\n      TIFF *tiff = TIFFClientOpen(\"foo\",\n            \"r\",\n            const_cast<QTiffHandler *>(this),\n            qtiffReadProc,\n            qtiffWriteProc,\n            qtiffSeekProc,\n            qtiffCloseProc,\n            qtiffSizeProc,\n            qtiffMapProc,\n            qtiffUnmapProc);\n\n      if (tiff) {\n         uint32_t width = 0;\n         uint32_t height = 0;\n         TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n         TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n         imageSize = QSize(width, height);\n         TIFFClose(tiff);\n      }\n\n      device()->seek(pos);\n      if (imageSize.isValid()) {\n         return imageSize;\n      }\n\n   } else if (option == CompressionRatio) {\n      return compression;\n   } else if (option == ImageFormat) {\n      return QImage::Format_ARGB32;\n   }\n\n   return QVariant();\n}",
    "std::shared_ptr<PrimitiveObject> readTiffFile(std::string const &path, int type = 0) {\n    TIFF* tif = TIFFOpen(path.c_str(), \"r\");\n    if (!tif) {\n        throw std::runtime_error(\"tiff read fail\");\n    }\n    auto img = std::make_shared<PrimitiveObject>();\n\n    uint32 width, height;\n    uint16_t samplesPerPixel, bitsPerSample;\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n    img->userData().set2(\"isImage\", 1);\n    img->userData().set2(\"w\", (int)width);\n    img->userData().set2(\"h\", (int)height);\n    img->userData().set2(\"samplesPerPixel\", (int)samplesPerPixel);\n    img->userData().set2(\"bitsPerSample\", (int)bitsPerSample);\n    if (bitsPerSample != 32) {\n        throw std::runtime_error(\"tiff read fail\");\n    }\n\n    std::vector<uint8_t> data_;\n    uint32_t rowSize = TIFFScanlineSize(tif);\n    img->userData().set2(\"rowSize\", (int)rowSize);\n    data_.resize(rowSize * height);\n\n    for (int32_t row = 0; row < height; ++row) {\n        TIFFReadScanline(tif, &data_[row * rowSize], row);\n    }\n    TIFFClose(tif);\n\n    img->resize(width * height);\n    if (samplesPerPixel == 4) {\n        vec4f *ptr = (vec4f*)data_.data();\n        auto &alpha = img->verts.add_attr<float>(\"alpha\");\n        auto &uv = img->verts.add_attr<zeno::vec2f>(\"uv\");\n        for (auto i = 0; i < height; i++) {\n            for (auto j = 0; j < width; j++) {\n                vec4f rgba = ptr[i * width + j];\n                img->verts[i * width + j] =  { rgba[0], rgba[1], rgba[2] };\n                alpha[i * width + j] =  rgba[3];\n                uv[i * width + j] = vec2f(j,i);\n            }\n        }\n    }\n    else if (samplesPerPixel == 3) {\n        vec3f *ptr = (vec3f*)data_.data();\n        auto &uv = img->verts.add_attr<zeno::vec2f>(\"uv\");\n        for (auto i = 0; i < height; i++) {\n            for (auto j = 0; j < width; j++) {\n                vec3f rgb = ptr[i * width + j];\n                img->verts[i * width + j] = rgb;\n                uv[i * width + j] = vec2f(j,i);\n            }\n        }\n    }\n    else if (samplesPerPixel == 1) {\n        auto &uv = img->verts.add_attr<zeno::vec2f>(\"uv\");\n        for (auto i = 0; i < height; i++) {\n            for (auto j = 0; j < width; j++) {\n                float r;\n                if(type == 0)\n                  r = ((int *)data_.data())[i*width + j];\n                else\n                  r = ((float *)data_.data())[i*width + j];\n                img->verts[i * width + j] = {r, r, r};\n                uv[i * width + j] = vec2f(j,i);\n            }\n        }\n    }\n\n    // Process image data here...\n    return img;\n}",
    "bool EerFile::ReadLogicalDimensionsFromDisk(bool check_only_the_first_image) {\n    MyDebugAssertTrue(tif != NULL, \"File must be open\");\n    MyDebugAssertTrue(fh != NULL, \"File must be open: %s\", filename.GetFullPath( ));\n    MyDebugAssertFalse(number_of_eer_frames_per_image == 0, \"Number of EER frames per image has not yet been set. Cannot work out logical dimensions.\");\n    /*\n\t * Since the file was already open, EerOpen has already read in the first dictionary\n\t * and it must be valid, else we would have returned an error at open-time already\n\t */\n    int  set_dir_ret  = TIFFSetDirectory(tif, 0);\n    bool return_value = (set_dir_ret == 1);\n    int  dircount     = 1;\n\n    uint32 original_x = 0;\n    uint16 compression;\n\n    // Work out logical dimensions of the frames (x,y)\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &logical_dimension_x);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &logical_dimension_y);\n    frame_size_bits = logical_dimension_x * logical_dimension_y;\n\n    // Work out RLE compression scheme\n    TIFFGetField(tif, TIFFTAG_COMPRESSION, &compression);\n    if ( compression == 65000 )\n        bits_per_rle = 8;\n    else if ( compression == 65001 )\n        bits_per_rle = 7;\n    else {\n        MyPrintWithDetails(\"Warning:: Unknown Compression in EER tif file, assuming 7-bit (65001)\");\n        bits_per_rle = 7;\n    }\n\n    if ( ! check_only_the_first_image ) {\n        // Work out the number of frames\n        while ( TIFFSetDirectory(tif, number_of_eer_frames) != 0 )\n            number_of_eer_frames++;\n\n        // Work out the number of images\n        number_of_images = number_of_eer_frames / number_of_eer_frames_per_image;\n\n        // Work out the total file size\n        fseek(fh, 0, SEEK_END);\n        file_size_bytes = ftell(fh);\n        fseek(fh, 0, SEEK_SET); //go back to the beginning of the file\n    }\n\n    return return_value;\n}",
    "bool TiffFile::ReadLogicalDimensionsFromDisk(bool check_only_the_first_image) {\n    MyDebugAssertTrue(tif != NULL, \"File must be open\");\n\n    /*\n\t * Since the file was already open, TiffOpen has already read in the first dictionary\n\t * and it must be valid, else we would have returned an error at open-time already\n\t */\n    int  set_dir_ret  = TIFFSetDirectory(tif, 0);\n    bool return_value = (set_dir_ret == 1);\n    int  dircount     = 1;\n\n    uint32 original_x = 0;\n    uint32 current_x  = 0;\n    uint32 current_y  = 0;\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &current_x);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &current_y);\n\n    // Serial EM has the option to write out 4-bit compressed tif.  They way that this is done is to do it as an 8-bit with\n    // half the x dimension. If the file has specific dimensions, it is assumed to be 4-bit.  I've copied the check directly\n    // from David Mastronarde. - see function comments for sizeCanBe4BitK2SuperRes\n\n    if ( sizeCanBe4BitK2SuperRes(current_x, current_y) == 1 ) {\n        logical_dimension_x                     = current_x * 2;\n        logical_dimension_y                     = current_y;\n        this_is_in_mastronarde_4bit_hack_format = true;\n    }\n    else {\n        logical_dimension_x                     = current_x;\n        logical_dimension_y                     = current_y;\n        this_is_in_mastronarde_4bit_hack_format = false;\n    }\n\n    original_x = current_x;\n\n    if ( ! check_only_the_first_image ) {\n        const bool check_dimensions_of_every_image = true;\n        if ( check_dimensions_of_every_image ) {\n            // Loop through all the TIFF directories and check they all have the same x,y dimensions\n            // This takes ages when importing TIFFs\n            while ( ! TIFFLastDirectory(tif) ) {\n                // The current directory is not the last one, so let's go to the next\n                dircount++;\n                set_dir_ret = TIFFSetDirectory(tif, dircount - 1);\n\n                if ( set_dir_ret != 1 ) {\n                    MyPrintfRed(\"Warning: Image %i of file %s seems to be corrupted\\n\", dircount, filename.GetFullName( ));\n                    return_value = false;\n                    dircount--;\n                    break;\n                }\n                else {\n                    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &current_x);\n                    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &current_y);\n\n                    if ( current_x != original_x || logical_dimension_y != current_y ) {\n                        MyPrintfRed(\"Warning: Image %i of file %s has dimensions %i,%i, whereas previous images had dimensions %i,%i\\n\", dircount, filename.GetFullName( ), current_x, current_y, original_x, logical_dimension_y);\n                        return_value = false;\n                        dircount--;\n                        break;\n                    }\n                }\n            }\n            // we return the number of valid images\n            number_of_images = dircount;\n        }\n        else {\n            // This doesnt' seem to be significantly faster than the other way to do it.\n            number_of_images = TIFFNumberOfDirectories(tif);\n        }\n    }\n    else {\n        // We only checked the first image, so we don't know how many images are in the file\n        number_of_images = -1;\n    }\n\n    return return_value;\n}",
    "void TiffFile::ReadSlicesFromDisk(int start_slice, int end_slice, float* output_array) {\n    MyDebugAssertTrue(tif != NULL, \"File must be open\");\n    MyDebugAssertTrue(start_slice > 0 && end_slice >= start_slice && end_slice <= number_of_images, \"Bad start or end slice number\");\n\n    unsigned int bits_per_sample   = 0;\n    unsigned int samples_per_pixel = 0;\n    unsigned int sample_format     = 0;\n    unsigned int rows_per_strip    = 0;\n\n    long output_counter;\n\n    tstrip_t strip_counter;\n    tmsize_t number_of_bytes_placed_in_buffer;\n\n    for ( unsigned int directory_counter = start_slice - 1; directory_counter < end_slice; directory_counter++ ) {\n\n        TIFFSetDirectory(tif, directory_counter);\n\n        // We don't support tiles, only strips\n        if ( TIFFIsTiled(tif) ) {\n            MyPrintfRed(\"Error. Cannot read tiled TIF files. Filename = %s, Directory # %i. Number of tiles per image = %i\\n\", filename.GetFullPath( ), directory_counter, TIFFNumberOfTiles(tif));\n        }\n\n        // Get bit depth etc\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits_per_sample);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel);\n        if ( samples_per_pixel != 1 ) {\n            MyPrintfRed(\"Error. Unsupported number of samples per pixel: %i. Filename = %s, Directory # %i\\n\", samples_per_pixel, filename.GetFullPath( ), directory_counter);\n        }\n        TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sample_format);\n\n        // How many rows per strip?\n        TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);\n\n        // Copy & cast data from these rows into the output array\n        switch ( sample_format ) {\n            case SAMPLEFORMAT_UINT:\n                switch ( bits_per_sample ) {\n                    case 8: {\n                        uint8* buf = new uint8[TIFFStripSize(tif)];\n\n                        // Serial EM has the option to write out 4-bit compressed tif.  They way that this is done is to do it as an 8-bit with\n                        // half the x dimension. If the file has specific dimensions, it is assumed to be 4-bit.  I've copied the check directly\n                        // from David Mastronarde. - see function comments for sizeCanBe4BitK2SuperRes\n\n                        if ( this_is_in_mastronarde_4bit_hack_format == true ) // this is 4-bit\n                        {\n\n                            uint8 hi_4bits;\n                            uint8 low_4bits;\n\n                            strip_counter = 0;\n\n                            number_of_bytes_placed_in_buffer = TIFFReadEncodedStrip(tif, strip_counter, (char*)buf, (tsize_t)-1);\n                            //wxPrintf(\"%i %i %i\\n\",int(number_of_bytes_placed_in_buffer),int(rows_per_strip), int(rows_per_strip * ReturnXSize()));\n                            if ( strip_counter < TIFFNumberOfStrips(tif) - 1 )\n                                MyDebugAssertTrue(number_of_bytes_placed_in_buffer == rows_per_strip * ReturnXSize( ), \"Unexpected number of bytes in uint8 buffer\");\n\n                            for ( strip_counter = 0; strip_counter < TIFFNumberOfStrips(tif); strip_counter++ ) {\n\n                                number_of_bytes_placed_in_buffer = TIFFReadEncodedStrip(tif, strip_counter, (char*)buf, (tsize_t)-1);\n                                if ( strip_counter < TIFFNumberOfStrips(tif) - 1 )\n                                    MyDebugAssertTrue(number_of_bytes_placed_in_buffer == rows_per_strip * ReturnXSize( ) / 2, \"Unexpected number of bytes in uint8 buffer\");\n\n                                output_counter = strip_counter * rows_per_strip * ReturnXSize( ) + ((directory_counter - start_slice + 1) * ReturnXSize( ) * ReturnYSize( ));\n\n                                for ( long counter = 0; counter < number_of_bytes_placed_in_buffer; counter++ ) {\n                                    low_4bits = buf[counter] & 0x0F;\n                                    hi_4bits  = (buf[counter] >> 4) & 0x0F;\n\n                                    output_array[output_counter] = float(low_4bits);\n                                    output_counter++;\n                                    output_array[output_counter] = float(hi_4bits);\n                                    output_counter++;\n                                }\n                            }\n                        }\n                        else // not 4-bit\n                        {\n                            for ( strip_counter = 0; strip_counter < TIFFNumberOfStrips(tif); strip_counter++ ) {\n\n                                number_of_bytes_placed_in_buffer = TIFFReadEncodedStrip(tif, strip_counter, (char*)buf, (tsize_t)-1);\n                                if ( strip_counter < TIFFNumberOfStrips(tif) - 1 )\n                                    MyDebugAssertTrue(number_of_bytes_placed_in_buffer == rows_per_strip * ReturnXSize( ), \"Unexpected number of bytes in uint8 buffer\");\n\n                                output_counter = strip_counter * rows_per_strip * ReturnXSize( ) + ((directory_counter - start_slice + 1) * ReturnXSize( ) * ReturnYSize( ));\n                                for ( long counter = 0; counter < number_of_bytes_placed_in_buffer; counter++ ) {\n                                    output_array[output_counter] = buf[counter];\n                                    output_counter++;\n                                }\n                            }\n                        }\n\n                        delete[] buf;\n                    } break;\n                    case 16: {\n                        uint16* buf = new uint16[TIFFStripSize(tif) / 2];\n\n                        for ( strip_counter = 0; strip_counter < TIFFNumberOfStrips(tif); strip_counter++ ) {\n                            number_of_bytes_placed_in_buffer = TIFFReadEncodedStrip(tif, strip_counter, (char*)buf, (tsize_t)-1);\n                            MyDebugAssertTrue(number_of_bytes_placed_in_buffer == rows_per_strip * ReturnXSize( ) * 2, \"Unexpected number of bytes in uint16 buffer\");\n\n                            output_counter = strip_counter * rows_per_strip * ReturnXSize( ) + ((directory_counter - start_slice + 1) * ReturnXSize( ) * ReturnYSize( ));\n                            for ( long counter = 0; counter < number_of_bytes_placed_in_buffer / 2; counter++ ) {\n                                output_array[output_counter] = buf[counter];\n                                output_counter++;\n                            }\n                        }\n                        delete[] buf;\n                    } break;\n                    default:\n                        MyPrintfRed(\"Error. Unsupported uint bit depth: %i. Filename = %s, Directory # %i\\n\", bits_per_sample, filename.GetFullPath( ), directory_counter);\n                        break;\n                }\n                break;\n            case SAMPLEFORMAT_INT:\n                switch ( bits_per_sample ) {\n                    case 16: {\n                        int16* buf = new int16[TIFFStripSize(tif) / 2];\n\n                        for ( strip_counter = 0; strip_counter < TIFFNumberOfStrips(tif); strip_counter++ ) {\n                            number_of_bytes_placed_in_buffer = TIFFReadEncodedStrip(tif, strip_counter, (char*)buf, (tsize_t)-1);\n                            MyDebugAssertTrue(number_of_bytes_placed_in_buffer == rows_per_strip * ReturnXSize( ) * 2, \"Unexpected number of bytes in uint16 buffer\");\n\n                            output_counter = strip_counter * rows_per_strip * ReturnXSize( ) + ((directory_counter - start_slice + 1) * ReturnXSize( ) * ReturnYSize( ));\n                            for ( long counter = 0; counter < number_of_bytes_placed_in_buffer / 2; counter++ ) {\n                                output_array[output_counter] = buf[counter];\n                                output_counter++;\n                            }\n                        }\n                        delete[] buf;\n                    } break;\n                    default:\n                        MyPrintfRed(\"Error. Unsupported int bit depth: %i. Filename = %s, Directory # %i\\n\", bits_per_sample, filename.GetFullPath( ), directory_counter);\n                        break;\n                }\n                break;\n            case SAMPLEFORMAT_IEEEFP: {\n                switch ( bits_per_sample ) {\n                    case 32: {\n                        float* buf = new float[TIFFStripSize(tif) / 4];\n\n                        for ( strip_counter = 0; strip_counter < TIFFNumberOfStrips(tif); strip_counter++ ) {\n                            number_of_bytes_placed_in_buffer = TIFFReadEncodedStrip(tif, strip_counter, (char*)buf, (tsize_t)-1);\n                            MyDebugAssertTrue(number_of_bytes_placed_in_buffer == rows_per_strip * ReturnXSize( ) * 4, \"Unexpected number of bytes in float buffer\");\n\n                            output_counter = strip_counter * rows_per_strip * ReturnXSize( ) + ((directory_counter - start_slice + 1) * ReturnXSize( ) * ReturnYSize( ));\n                            for ( long counter = 0; counter < number_of_bytes_placed_in_buffer / 4; counter++ ) {\n                                output_array[output_counter] = buf[counter];\n                                output_counter++;\n                            }\n                        }\n                        delete[] buf;\n                    } break;\n                    default:\n                        MyPrintfRed(\"Error. Unsupported float bit depth: %i. Filename = %s, Directory # %i\\n\", bits_per_sample, filename.GetFullPath( ), directory_counter);\n                        break;\n                }\n                break;\n            } break;\n            default:\n                MyPrintfRed(\"Error. Unsupported sample format: %i. Filename = %s, Directory # %i\\n\", sample_format, filename.GetFullPath( ), directory_counter);\n                break;\n        }\n\n        // Annoyingly, we need to swap the order of the lines to be \"compatible\" with MRC files etc\n        {\n            float* temp_line                      = new float[ReturnXSize( )];\n            long   address_of_start_of_slice      = (directory_counter - start_slice + 1) * ReturnXSize( ) * ReturnYSize( );\n            long   address_of_start_of_line       = address_of_start_of_slice;\n            long   address_of_start_of_other_line = address_of_start_of_slice + (ReturnYSize( ) - 1) * ReturnXSize( );\n            long   counter;\n\n            for ( long line_counter = 0; line_counter < ReturnYSize( ) / 2; line_counter++ ) {\n                // Copy current line to a buffer\n                for ( counter = 0; counter < ReturnXSize( ); counter++ ) {\n                    temp_line[counter] = output_array[counter + address_of_start_of_line];\n                }\n                // Copy other line to current line\n                for ( counter = 0; counter < ReturnXSize( ); counter++ ) {\n                    output_array[counter + address_of_start_of_line] = output_array[counter + address_of_start_of_other_line];\n                }\n                // Copy line from buffer to other line\n                for ( counter = 0; counter < ReturnXSize( ); counter++ ) {\n                    output_array[counter + address_of_start_of_other_line] = temp_line[counter];\n                }\n                // Get ready for next iteration\n                address_of_start_of_line += ReturnXSize( );\n                address_of_start_of_other_line -= ReturnXSize( );\n            }\n\n            delete[] temp_line;\n        }\n\n    } // end of loop over slices\n}",
    "bool TIFRaster::Data::Create()\r\n{\r\n\tTIFFSetErrorHandler(NULL);\r\n\tTIFFSetErrorHandlerExt(NULL);\r\n\tTIFFSetWarningHandler(NULL);\r\n\tTIFFSetWarningHandlerExt(NULL);\r\n\r\n\ttiff = TIFFStreamOpen(\"tiff@\" + Format64((intptr_t)this), \"r\", &stream);\r\n\tif(!tiff)\r\n\t\treturn false;\r\n\r\n\tint count = TIFFNumberOfDirectories(tiff);\r\n\tif(count <= 0)\r\n\t\treturn false;\r\n\tfor(int i = 0; i < count; i++) {\r\n\t\tPage& page = pages.Add();\r\n\t\tTIFFSetDirectory(tiff, i);\r\n\t\tTIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &page.width);\r\n\t\tTIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &page.height);\r\n\t\tfloat xres, yres;\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_XRESOLUTION, &xres);\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_YRESOLUTION, &yres);\r\n\t\tuint16 resunit;\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_RESOLUTIONUNIT, &resunit);\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_BITSPERSAMPLE, &page.bits_per_sample);\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLESPERPIXEL, &page.samples_per_pixel);\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_PHOTOMETRIC, &page.photometric);\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_ORIENTATION, &page.orientation);\r\n\t\tdouble dots_per_unit = (resunit == RESUNIT_INCH ? 600.0 : resunit == RESUNIT_CENTIMETER\r\n\t\t\t? 600.0 / 2.54 : 0);\r\n\t\tpage.dot_size.cx = (xres ? fround(page.width * dots_per_unit / xres) : 0);\r\n\t\tpage.dot_size.cy = (yres ? fround(page.height * dots_per_unit / yres) : 0);\r\n\t\tpage.alpha = false;\r\n\t\tuint16 extrasamples, *sampletypes;\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_EXTRASAMPLES, &extrasamples, &sampletypes);\r\n\t\tfor(int e = 0; e < extrasamples; e++)\r\n\t\t\tif(sampletypes[e] == EXTRASAMPLE_ASSOCALPHA) {\r\n\t\t\t\tpage.alpha = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\r\n\t\tif(i == 0) {\r\n\t\t\tconst word TIFFTAG_GEOPIXELSCALE = 33550,\r\n\t\t\t           TIFFTAG_GEOTIEPOINTS = 33922,\r\n\t\t\t           TIFFTAG_GEOTRANSMATRIX = 34264,\r\n\t\t\t           TIFFTAG_GEOKEYDIRECTORY = 34735,\r\n\t\t\t           TIFFTAG_GEODOUBLEPARAMS = 34736,\r\n\t\t\t           TIFFTAG_GEOASCIIPARAMS = 34737;\r\n\r\n\t\t\tword count = 0;\r\n\t\t\tword *geokeys = nullptr;\r\n\t\t\tbool pixel_is_area = true; // Default is true, usually only DTM/DEM use 'RasterPixelIsPoint' and generally include the GeoKey in such case\r\n\r\n\t\t\tint dpc = 0;\r\n\t\t\tdouble *doubleparams = 0;\r\n\r\n\t\t\tint apc = 0;\r\n\t\t\tchar *asciiparams = 0;\r\n\r\n\t\t\tTIFFGetField(tiff, TIFFTAG_GEODOUBLEPARAMS, &dpc, &doubleparams);\r\n\t\t\tTIFFGetField(tiff, TIFFTAG_GEOASCIIPARAMS, &apc, &asciiparams);\r\n\r\n\t\t\tif(TIFFGetField(tiff, TIFFTAG_GEOKEYDIRECTORY, &count, &geokeys) &&\r\n\t\t\t\tcount >= 4 && (count % 4) == 0 && geokeys[0] == 1)\r\n\t\t\t\tfor(int i = 4; i + 3 < count; i += 4) {\r\n\t\t\t\t\tconst word GTRasterTypeGeoKey = 1025,\r\n\t\t\t\t\t           RasterPixelIsArea = 1,\r\n\t\t\t\t\t           GeographicTypeGeoKey = 2048,\r\n\t\t\t\t\t           ProjectedCSTypeGeoKey = 3072;\r\n\r\n\t\t\t\t\tword value = geokeys[i + 3];\r\n\r\n\t\t\t\t\tswitch(geokeys[i]) {\r\n\t\t\t\t\tcase GTRasterTypeGeoKey:\r\n\t\t\t\t\t\tpixel_is_area = value == RasterPixelIsArea;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase GeographicTypeGeoKey:\r\n\t\t\t\t\tcase ProjectedCSTypeGeoKey:\r\n\t\t\t\t\t\tattr.GetAdd(\"epsg\") = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tswitch(geokeys[i+1]){ // by type\r\n\t\t\t\t\t\tcase TIFFTAG_GEOASCIIPARAMS:\r\n\t\t\t\t\t\t\tif(geokeys[i+3]<=apc) attr.GetAdd(Format(\"GK%d\",geokeys[i])) = Value(String(&asciiparams[geokeys[i+3]],geokeys[i+2]));\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase TIFFTAG_GEODOUBLEPARAMS:\r\n\t\t\t\t\t\t\tif(geokeys[i+3]<=dpc) attr.GetAdd(Format(\"GK%d\",geokeys[i])) = Value(doubleparams[geokeys[i+3]]);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tattr.GetAdd(Format(\"GK%d\",geokeys[i])) = Value(geokeys[i+3]);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\tdouble geomatrix[6];\r\n\t        geomatrix[0] = 0.0;\r\n\t        geomatrix[1] = 1.0;\r\n\t        geomatrix[2] = 0.0;\r\n\t        geomatrix[3] = 0.0;\r\n\t        geomatrix[4] = 0.0;\r\n\t        geomatrix[5] = 1.0;\r\n\t        \r\n\t        auto AdjustMatrixOrientation = [&](double dx, double dy) {\r\n\t\t\t\tgeomatrix[0] += (geomatrix[1] * dx + geomatrix[2] * dy);\r\n\t\t\t\tgeomatrix[3] += (geomatrix[4] * dx + geomatrix[5] * dy);\r\n\t\t\t\tif(dx!=0){\r\n\t\t\t\t\tgeomatrix[1] = -geomatrix[1];\r\n\t\t\t\t\tgeomatrix[4] = -geomatrix[4];\r\n\t\t\t\t}\r\n\t\t\t\tif(dy!=0){\r\n\t\t\t\t\tgeomatrix[2] = -geomatrix[2];\r\n\t\t\t\t\tgeomatrix[5] = -geomatrix[5];\r\n\t\t\t\t}\r\n\t        };\r\n\t        \r\n\t\t\tauto NormalizeOrientation = [&] {\r\n\t\t\t\tif(!pixel_is_area) {\r\n\t\t\t\t\tgeomatrix[0] -= (geomatrix[1] * 0.5 + geomatrix[2] * 0.5);\r\n\t\t\t\t\tgeomatrix[3] -= (geomatrix[4] * 0.5 + geomatrix[5] * 0.5);\r\n\t\t\t\t}\r\n\t\t\t\tif(page.orientation>=5){\r\n\t\t\t\t\tSwap(geomatrix[1],geomatrix[2]);\r\n\t\t\t\t\tSwap(geomatrix[4],geomatrix[5]);\r\n\t\t\t\t}\r\n\t\t\t\tswitch(page.orientation){\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(page.width, 0);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(page.width, page.height);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(0, page.height);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 6:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(page.height, 0);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 7:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(page.height, page.width);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 8:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(0, page.width);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t// TIFF orientations:\r\n\t\t\t\t// 1 = FLIP_MIRROR_VERT,\r\n\t\t\t\t// 2 = FLIP_ROTATE_180,\r\n\t\t\t\t// 3 = FLIP_MIRROR_HORZ,\r\n\t\t\t\t// 4 = FLIP_NONE,\r\n\t\t\t\t// 5 = FLIP_ROTATE_CLOCKWISE,\r\n\t\t\t\t// 6 = FLIP_TRANSPOSE,\r\n\t\t\t\t// 7 = FLIP_ROTATE_ANTICLOCKWISE,\r\n\t\t\t\t// 8 = FLIP_TRANSVERSE,\r\n\t\t\t};\r\n\t    \r\n\t        double  *data;\r\n\t        auto FinishMatrix = [&] {\r\n\t\t\t\tValueArray va;\r\n\t\t\t\tfor(int i = 0; i < 6; i++)\r\n\t\t\t\t\tva << geomatrix[i];\r\n\t\t\t\tattr.GetAdd(\"geo_matrix\") = va;\r\n\t        };\r\n\t        \r\n\t\t\tif(TIFFGetField(tiff, TIFFTAG_GEOTRANSMATRIX, &count, &data) && count == 16) {\r\n\t\t\t\tgeomatrix[0] = data[3];\r\n\t\t\t\tgeomatrix[1] = data[0];\r\n\t\t\t\tgeomatrix[2] = data[1];\r\n\t\t\t\tgeomatrix[3] = data[7];\r\n\t\t\t\tgeomatrix[4] = data[4];\r\n\t\t\t\tgeomatrix[5] = data[5];\r\n\r\n\t\t\t\tNormalizeOrientation();\r\n\t\t\t\tFinishMatrix();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\tif(TIFFGetField(tiff, TIFFTAG_GEOTIEPOINTS, &count, &data) && count >= 6) {\r\n\t\t\t\tif(count>=18){ // 3 tiepoints needed for Xform2D::Map()\r\n\t\t\t\t\tfor(int t=0; t<count; t+=6){\r\n\t\t\t\t\t\tif(page.orientation>=5) Swap(data[t + 0], data[t + 1]);\r\n\t\t\t\t\t\tswitch(page.orientation){\r\n\t\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\t\tdata[t + 0] = page.width - data[t + 0];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\t\tdata[t + 0] = page.width - data[t + 0];\r\n\t\t\t\t\t\t\t\tdata[t + 1] = page.height - data[t + 1];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\t\tdata[t + 1] = page.height - data[t + 1];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 5:\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 6:\r\n\t\t\t\t\t\t\t\tdata[t + 0] = page.height - data[t + 0];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 7:\r\n\t\t\t\t\t\t\t\tdata[t + 0] = page.height - data[t + 0];\r\n\t\t\t\t\t\t\t\tdata[t + 1] = page.width - data[t + 1];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 8:\r\n\t\t\t\t\t\t\t\tdata[t + 1] = page.width - data[t + 1];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tXform2D xf = Xform2D::Map(Pointf(data[0],data[1]),Pointf(data[6+0],data[6+1]),Pointf(data[12+0],data[12+1]),\r\n\t\t\t\t\t\t\t\t\t\t\t\tPointf(data[3],data[4]),Pointf(data[6+3],data[6+4]),Pointf(data[12+3],data[12+4]));\r\n\r\n\t\t\t\t\tgeomatrix[0] = xf.t.x;\r\n\t\t\t\t\tgeomatrix[1] = xf.x.x;\r\n\t\t\t\t\tgeomatrix[2] = xf.y.x;\r\n\t\t\t\t\tgeomatrix[3] = xf.t.y;\r\n\t\t\t\t\tgeomatrix[4] = xf.x.y;\r\n\t\t\t\t\tgeomatrix[5] = xf.y.y;\r\n\r\n\t\t\t\t\tif(!pixel_is_area) {\r\n\t\t\t\t\t\tgeomatrix[0] -= (geomatrix[1] * 0.5 + geomatrix[2] * 0.5);\r\n\t\t\t\t\t\tgeomatrix[3] -= (geomatrix[4] * 0.5 + geomatrix[5] * 0.5);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tFinishMatrix();\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tdouble x = data[0];\r\n\t\t\t\t\tdouble y = data[1];\r\n\t\t\t\t\tdouble e = data[3];\r\n\t\t\t\t\tdouble n = data[4];\r\n\r\n\t\t\t\t\tif(TIFFGetField(tiff, TIFFTAG_GEOPIXELSCALE, &count, &data) && count >= 2 && data[0] && data[1]) {\r\n\t\t\t\t\t\tdouble dx = data[0];\r\n\t\t\t\t\t\tdouble dy = -abs(data[1]);\r\n\r\n\t\t\t\t\t\tgeomatrix[0] = e - x * dx;\r\n\t\t\t\t\t\tgeomatrix[1] = dx;\r\n\t\t\t\t\t\tgeomatrix[2] = 0;\r\n\t\t\t\t\t\tgeomatrix[3] = n - y * dy;\r\n\t\t\t\t\t\tgeomatrix[4] = 0;\r\n\t\t\t\t\t\tgeomatrix[5] = dy;\r\n\r\n\t\t\t\t\t\tNormalizeOrientation();\r\n\t\t\t\t\t\tFinishMatrix();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(TIFFGetField(tiff, 42113, &count, &data) && // TIFFTAG_GDAL_NODATA = 42113\r\n\t\t\t\tcount >= 1){\r\n\t\t\t\t\tattr.GetAdd(\"nodata\") = String((const char*)data, count);\r\n\t\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\treturn SeekPage(0);\r\n}",
    "char * _loadTIFF(const char *filename, unsigned *width, unsigned *height, unsigned *numcolors, unsigned *numbits, std::map<std::string,std::string> &info, std::string params=\"\", char ** icc_m=NULL, unsigned  *icclength=0)\n{\n\tchar *img, *buf;\n\tFILE * infile;\n\tuint32_t w, h;\n\tuint16_t c, b;\n\n\tTIFFSetErrorHandler(0);\n\n\tTIFF* tif = TIFFOpen(filename, \"r\");\n\tif (tif) {\n\n\t\tsize_t npixels;\n\t\tuint32_t* raster;\n\n\t\tuint32_t imagelength, imagewidth;\n\t\tuint16_t config, nsamples, sampleformat, uval;\n\n\t\tunsigned len;\n\t\tchar * buffer;\n        \n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &c);\n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &b);\n\t\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n\t\t\n\t\tif (config != PLANARCONFIG_CONTIG) return NULL;\n\n\t\tchar *infobuf;\n\t\t//if (TIFFGetField(tif, TIFFTAG_ARTIST, &infobuf)) info[\"Artist\"]=infobuf; \n\t\t//if (TIFFGetField(tif, TIFFTAG_MAKE, &infobuf))  info[\"Make\"]=infobuf;\n\t\t//if (TIFFGetField(tif, TIFFTAG_MODEL, &infobuf))  info[\"Model\"]=infobuf;\n\t\t//if (TIFFGetField(tif, TIFFTAG_SOFTWARE, &infobuf))  info[\"Software\"]=infobuf; \n\t\t//if (TIFFGetField(tif, TIFFTAG_COPYRIGHT, &infobuf))  info[\"Copyright\"]=infobuf; \n\t\t//if (TIFFGetField(tif, TIFFTAG_LENSINFO, &infobuf))  info[\"LensInfo\"]=infobuf; \n\t\t//if (TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &infobuf))  info[\"ImageDescription\"]=infobuf; \n\t\t//if (TIFFGetField(tif, TIFFTAG_DATETIME, &infobuf)) info[\"DateTime\"]=infobuf;\n\t\t//if (TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleformat)) {\n\t\t//\tif (sampleformat == SAMPLEFORMAT_UINT) info[\"SampleFormat\"]=\"uint\";\n\t\t//\tif (sampleformat == SAMPLEFORMAT_INT) info[\"SampleFormat\"]=\"int\";\n\t\t//\tif (sampleformat == SAMPLEFORMAT_IEEEFP) info[\"SampleFormat\"]=\"float\";\n\t\t//\tif (sampleformat == SAMPLEFORMAT_VOID) info[\"SampleFormat\"]=\"void\";\n\t\t//}\n\t\t//if (TIFFGetField(tif, TIFFTAG_ORIENTATION, &uval)) info[\"Orientation\"]=tostr(uval);\n/*\n\t\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &len, &buffer)) {\n\t\t\t*icc_m = new char[len];\n\t\t\tmemcpy(*icc_m, buffer, len);\n\t\t\t*icclength = len;\n\t\t}\n*/\n//\t\telse {\n\t\t\t*icc_m = NULL;\n\t\t\t*icclength = 0;\n//\t\t}\n\t\t\n\t\timg = new char[w*h*c*(b/8)];\n\t\tbuf = (char *) _TIFFmalloc(TIFFScanlineSize(tif));\n\t\tint stride = TIFFScanlineSize(tif);\n\t\t\n\t\tchar * dst = (char *) img;\n\t\tfor (unsigned y = 0; y < h; y++){\n\t\t\tTIFFReadScanline(tif, buf, y, 0);\n\t\t\tmemcpy(dst,buf,stride);\n\t\t\tdst += stride;\n\t\t}\n\t\t\n/*\n\t\tuint32_t read_dir_offset; uint32_t count;\n\t\tfloat fval;\n\t\tuint16_t * sval;\n\t\tif (TIFFGetField(tif, TIFFTAG_EXIFIFD, &read_dir_offset )) {\n\t\t\tif (TIFFReadEXIFDirectory(tif, read_dir_offset)) {\n\t\t\t\tif (TIFFGetField( tif, EXIFTAG_FNUMBER, &fval)) info[\"FNumber\"] = tostr(fval);\n\t\t\t\tif (TIFFGetField( tif, EXIFTAG_EXPOSURETIME, &fval)) info[\"ExposureTime\"] = tostr(fval);\n\t\t\t\tif (TIFFGetField( tif, EXIFTAG_FOCALLENGTH, &fval)) info[\"FocalLength\"] = tostr(fval);\n\t\t\t\tif (TIFFGetField( tif, EXIFTAG_ISOSPEEDRATINGS, &count, &sval)) info[\"ISOSpeedRatings\"] = tostr(*sval);\n\t\t\t}\n\t\t\telse printf(\"TIFFReadEXIFDirectory failed\\n\");\n\t\t}\n*/\n\t\t\n\t\t*width = w;\n\t\t*height = h;\n\t\t*numcolors = c;\n\t\t*numbits = b;\n\t\tif (buf) _TIFFfree(buf);\n\t\tTIFFClose(tif);\n\t\treturn img;\n\t}\n\telse return NULL;\n}",
    "CImage* CImageIOTiff::ReadImage(CNcbiIstream& istr)\n{\n    TIFF*            tiff             = NULL;\n    uint32*          raster           = NULL;\n    TIFFErrorHandler old_err_handler  = NULL;\n    TIFFErrorHandler old_warn_handler = NULL;\n    CRef<CImage> image;\n    try {\n\n        old_err_handler  = TIFFSetErrorHandler(&s_TiffReadErrorHandler);\n        old_warn_handler = TIFFSetWarningHandler(&s_TiffWarningHandler);\n\n        // open our file\n        tiff = TIFFClientOpen(\"\", \"rm\",\n                              reinterpret_cast<thandle_t>(&istr),\n                              s_TIFFReadHandler,\n                              s_TIFFDummyIOHandler,\n                              s_TIFFSeekHandler,\n                              s_TIFFCloseHandler,\n                              s_TIFFSizeHandler,\n                              s_TIFFMapFileHandler,\n                              s_TIFFUnmapFileHandler);\n        if ( !tiff ) {\n            NCBI_THROW(CImageException, eReadError,\n                       \"CImageIOTiff::ReadImage(): error opening file \");\n        }\n\n        // extract the size parameters\n        size_t width  = 0;\n        size_t height = 0;\n        size_t depth  = 0;\n        TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH,  &width);\n        TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &depth);\n\n        if (depth != 1  &&  depth != 3  &&  depth != 4) {\n            string msg(\"CImageIOTiff::ReadImage(): unhandled image depth: \");\n            msg += NStr::NumericToString(depth);\n            NCBI_THROW(CImageException, eReadError, msg);\n        }\n\n        // NB: we treat single plane images as RGB\n        if (depth == 1) {\n            depth = 3;\n        }\n\n        // allocate a temporary buffer for the image\n        raster = (uint32*)_TIFFmalloc(tsize_t(width * height * sizeof(uint32)));\n        if ( !TIFFReadRGBAImage(tiff, (uint32)width, (uint32)height, raster, 1) ) {\n            _TIFFfree(raster);\n\n            NCBI_THROW(CImageException, eReadError,\n                       \"CImageIOTiff::ReadImage(): error reading file\");\n        }\n\n        // now we need to copy this data and pack it appropriately\n        // according to the TIFFRGBAImage man page, TIFFRGBAImage and\n        // TIFFReadRGBAImage create the image in *RASTER* format - i.e.,\n        // with (0, 0) being the lower-left corner, not the upper-left\n        // corner as everyone else in the world expects\n        image = new CImage(width, height, depth);\n        unsigned char* data = image->SetData();\n        for (size_t j = 0;  j < height;  ++j) {\n            // implicit inversion\n            size_t from_idx_base = j * width;\n            size_t to_idx_base   = (height - j - 1) * width;\n\n            size_t i;\n            switch (depth) {\n            case 3:\n                for (i = 0;  i < width;  ++i) {\n                    size_t from_idx = from_idx_base + i;\n                    size_t to_idx   = to_idx_base + i;\n\n                    // TIFFReadRGBAImage() returns data in ABGR image,\n                    // packed as a 32-bit value, so we need to pick this\n                    // apart here\n                    uint32 pixel = raster[from_idx];\n                    data[3 * to_idx + 0] = TIFFGetR(pixel);\n                    data[3 * to_idx + 1] = TIFFGetG(pixel);\n                    data[3 * to_idx + 2] = TIFFGetB(pixel);\n                }\n                break;\n\n            case 4:\n                for (i = 0;  i < width;  ++i) {\n                    size_t from_idx = from_idx_base + i;\n                    size_t to_idx   = to_idx_base + i;\n\n                    // TIFFReadRGBAImage() returns data in ABGR image,\n                    // packed as a 32-bit value, so we need to pick this\n                    // apart here\n                    uint32 pixel = raster[from_idx];\n                    data[4 * to_idx + 0] = TIFFGetR(pixel);\n                    data[4 * to_idx + 1] = TIFFGetG(pixel);\n                    data[4 * to_idx + 2] = TIFFGetB(pixel);\n                    data[4 * to_idx + 3] = (unsigned char)TIFFGetA(pixel);\n                }\n                break;\n            }\n        }\n\n        // clean-up\n        _TIFFfree(raster);\n        TIFFClose(tiff);\n    }\n    catch (...) {\n        if (raster) {\n            _TIFFfree(raster);\n            raster = NULL;\n        }\n\n        if (tiff) {\n            TIFFClose(tiff);\n            tiff = NULL;\n        }\n\n        TIFFSetErrorHandler(old_err_handler);\n        TIFFSetWarningHandler(old_warn_handler);\n\n        // throw to a higher level\n        throw;\n    }\n\n    TIFFSetErrorHandler(old_err_handler);\n    TIFFSetWarningHandler(old_warn_handler);\n    return image.Release();\n}",
    "bool CImageIOTiff::ReadImageInfo(CNcbiIstream& istr,\n                                size_t* width, size_t* height, size_t* depth)\n{\n    TIFF*            tiff             = NULL;\n    TIFFErrorHandler old_err_handler  = NULL;\n    TIFFErrorHandler old_warn_handler = NULL;\n\n    bool success = false;\n    try {\n\n        old_err_handler  = TIFFSetErrorHandler(&s_TiffReadErrorHandler);\n        old_warn_handler = TIFFSetWarningHandler(&s_TiffWarningHandler);\n\n        // open our file\n        tiff = TIFFClientOpen(\"\", \"rm\",\n                              reinterpret_cast<thandle_t>(&istr),\n                              s_TIFFReadHandler,\n                              s_TIFFDummyIOHandler,\n                              s_TIFFSeekHandler,\n                              s_TIFFCloseHandler,\n                              s_TIFFSizeHandler,\n                              s_TIFFMapFileHandler,\n                              s_TIFFUnmapFileHandler);\n        if ( !tiff ) {\n            NCBI_THROW(CImageException, eReadError,\n                       \"CImageIOTiff::ReadImageInfo(): error opening file \");\n        }\n\n        // extract the size parameters\n        if (width) {\n            TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n        }\n        if (height) {\n            TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, height);\n        }\n        if (depth) {\n            TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, depth);\n        }\n        TIFFClose(tiff);\n\n        success = true;\n    }\n    catch (...) {\n    }\n\n    TIFFSetErrorHandler(old_err_handler);\n    TIFFSetWarningHandler(old_warn_handler);\n\n    return success;\n}",
    "int ImageIO::loadTIFF(const Glib::ustring &fname)\n{\n\n    static MyMutex thumbMutex;\n    MyMutex::MyLock lock(thumbMutex);\n\n    if(!options.serializeTiffRead) {\n        lock.release();\n    }\n\n    IMFILE *src = fopen(fname.c_str());\n    TIFF *in = TIFFClientOpen(\n        fname.c_str(), \"r\", static_cast<thandle_t>(src),\n        tiff_Read, tiff_Write, tiff_Seek, tiff_Close, tiff_Size,\n        tiff_Map, tiff_Unmap);\n\n    if (in == nullptr) {\n        return IMIO_CANNOTREADFILE;\n    }\n\n    if (pl) {\n        pl->setProgressStr (\"PROGRESSBAR_LOADTIFF\");\n        pl->setProgress (0.0);\n    }\n\n    int width, height;\n    TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(in, TIFFTAG_IMAGELENGTH, &height);\n\n    uint16 bitspersample, samplesperpixel;\n    int hasTag = TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n    hasTag &= TIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\n    if (!hasTag) {\n        // These are needed\n        TIFFClose(in);\n        return IMIO_VARIANTNOTSUPPORTED;\n    }\n\n    uint16 config;\n    TIFFGetField(in, TIFFTAG_PLANARCONFIG, &config);\n\n    if (config != PLANARCONFIG_CONTIG) {\n        TIFFClose(in);\n        return IMIO_VARIANTNOTSUPPORTED;\n    }\n\n    if (sampleFormat & (IIOSF_LOGLUV24 | IIOSF_LOGLUV32)) {\n        TIFFSetField(in, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    }\n\n    /*\n     * We could use the min/max values set in TIFFTAG_SMINSAMPLEVALUE and\n     * TIFFTAG_SMAXSAMPLEVALUE, but for now, we normalize the image to the\n     * effective minimum and maximum values\n     */\n    if (options.rtSettings.verbose) {\n        printf(\"Information of \\\"%s\\\":\\n\", fname.c_str());\n        uint16 tiffDefaultScale, tiffBaselineExposure, tiffLinearResponseLimit;\n        if (TIFFGetField(in, TIFFTAG_DEFAULTSCALE, &tiffDefaultScale)) {\n            printf(\"   DefaultScale: %d\\n\", tiffDefaultScale);\n        }\n        else\n            printf(\"   No DefaultScale value!\\n\");\n        if (TIFFGetField(in, TIFFTAG_BASELINEEXPOSURE, &tiffBaselineExposure)) {\n            printf(\"   BaselineExposure: %d\\n\", tiffBaselineExposure);\n        }\n        else\n            printf(\"   No BaselineExposure value!\\n\");\n        if (TIFFGetField(in, TIFFTAG_LINEARRESPONSELIMIT, &tiffLinearResponseLimit)) {\n            printf(\"   LinearResponseLimit: %d\\n\", tiffLinearResponseLimit);\n        }\n        else\n            printf(\"   No LinearResponseLimit value!\\n\");\n\n        // agriggio 2020-11-06: this causes a segfault when compiled with -O3 and PROC_TARGET_NUMBER=2\n        // on gcc 7.5.0, Ubuntu 18.04. Need to understand why...\n        // \n        // uint16 tiffMinValue, tiffMaxValue;\n        // if (TIFFGetField(in, TIFFTAG_SMINSAMPLEVALUE, &tiffMinValue)) {\n        //     printf(\"   MinValue: %d\\n\", tiffMinValue);\n        // }\n        // else\n        //     printf(\"   No minimum value!\\n\");\n        // if (TIFFGetField(in, TIFFTAG_SMAXSAMPLEVALUE, &tiffMaxValue)) {\n        //     printf(\"   MaxValue: %d\\n\\n\", tiffMaxValue);\n        // }\n        // else\n        //     printf(\"   No maximum value!\\n\\n\");\n        // printf(\"   Those values are not taken into account, the image data are normalized to a [0;1] range\\n\\n\");\n    }\n\n    char* profdata;\n    deleteLoadedProfileData();\n    loadedProfileDataJpg = false;\n\n    if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &loadedProfileLength, &profdata)) {\n        embProfile = cmsOpenProfileFromMem (profdata, loadedProfileLength);\n        loadedProfileData = new char [loadedProfileLength];\n        memcpy (loadedProfileData, profdata, loadedProfileLength);\n    } else {\n        embProfile = nullptr;\n    }\n\n    allocate (width, height);\n\n    unsigned char* linebuffer = new unsigned char[TIFFScanlineSize(in) * (samplesperpixel == 1 ? 3 : 1)];\n\n    for (int row = 0; row < height; row++) {\n        if (TIFFReadScanline(in, linebuffer, row, 0) < 0) {\n            TIFFClose(in);\n            delete [] linebuffer;\n            return IMIO_READERROR;\n        }\n\n        if (samplesperpixel > 3) {\n            for (int i = 0; i < width; i++) {\n                memmove(linebuffer + i * 3 * bitspersample / 8, linebuffer + i * samplesperpixel * bitspersample / 8, 3 * bitspersample / 8);\n            }\n        }\n        else if (samplesperpixel == 1) {\n            const size_t bytes = bitspersample / 8;\n            for (int i = width - 1; i >= 0; --i) {\n                const unsigned char* const src = linebuffer + i * bytes;\n                unsigned char* const dest = linebuffer + i * 3 * bytes;\n                memcpy(dest + 2 * bytes, src, bytes);\n                memcpy(dest + 1 * bytes, src, bytes);\n                memcpy(dest + 0 * bytes, src, bytes);\n            }\n        }\n\n        setScanline (row, linebuffer, bitspersample);\n\n        if (pl && !(row % 100)) {\n            pl->setProgress ((double)(row + 1) / height);\n        }\n    }\n\n    TIFFClose(in);\n    delete [] linebuffer;\n\n    if (pl) {\n        pl->setProgressStr (\"PROGRESSBAR_READY\");\n        pl->setProgress (1.0);\n    }\n\n    return IMIO_SUCCESS;\n}",
    "int GeoImage::TiffOpen(string path)\n{\n    TIFFSetErrorHandler(myTiffErrHandler);\n\n    GeoImage::TiffClose();\n\n    // Check for a valid file name (this avoids Linux crash):\n    //\n    struct stat statbuf;\n    if (stat(path.c_str(), &statbuf) < 0) {\n        SetErrMsg(\"Invalid tiff file: %s\\n\", path.c_str());\n        return -1;\n    }\n\n    // Not using memory-mapped IO (m) is reputed to help plug\n    // leaks (but doesn't do any good on windows for me)\n    //\n    _tif = XTIFFOpen(path.c_str(), \"rm\");\n    if (!_tif) {\n        SetErrMsg(\"Unable to open tiff file: %s\\n\", path.c_str());\n        return -1;\n    }\n\n    char emsg[1000];\n    int  ok = TIFFRGBAImageOK(_tif, emsg);\n    if (!ok) {\n        MyBase::SetErrMsg(\"Unable to process tiff file:\\n %s\\nError message: %s\", path.c_str(), emsg);\n        return (-1);\n    }\n\n    // Check compression.  Some compressions, e.g. jpeg, cause crash on Linux\n    //\n#ifdef VAPOR3_0_0_ALPHA\n    short compr = 1;\n    ok = TIFFGetField(_tif, TIFFTAG_COMPRESSION, &compr);\n    if (ok) {\n        if (compr != COMPRESSION_NONE && compr != COMPRESSION_LZW && compr != COMPRESSION_JPEG && compr != COMPRESSION_CCITTRLE) {\n            MyBase::SetErrMsg(\"Unsupported Tiff compression\");\n            return (-1);\n        }\n    }\n#endif\n\n    return (0);\n}",
    "int GeoImage::TiffGetImageDimensions(int dirnum, size_t &width, size_t &height) const\n{\n    VAssert(_tif != NULL);\n    width = 0;\n    height = 0;\n\n    bool ok = (bool)TIFFSetDirectory(_tif, dirnum);\n    if (!ok) return (-1);\n\n    uint32_t w;\n    ok = (bool)TIFFGetField(_tif, TIFFTAG_IMAGEWIDTH, &w);\n    if (!ok) return (-1);\n\n    uint32_t h;\n    ok = (bool)TIFFGetField(_tif, TIFFTAG_IMAGELENGTH, &h);\n    if (!ok) return (-1);\n\n    width = (size_t)w;\n    height = (size_t)h;\n\n    return (0);\n}",
    "int GeoImage::TiffReadImage(int dirnum, unsigned char *texture) const\n{\n    VAssert(_tif != NULL);\n\n    uint32_t *texuint32_t = (uint32_t *)texture;\n\n    bool ok = (bool)TIFFSetDirectory(_tif, dirnum);\n    if (!ok) return (-1);\n\n    size_t w, h;\n    int    rc = GeoImage::TiffGetImageDimensions(dirnum, w, h);\n    if (rc < 0) return (-1);\n\n    // Check if this is a 2-component 8-bit image.  These are read\n    // by scanline since TIFFReadRGBAImage\n    // apparently does not know how to get the alpha channel\n    //\n    short nsamples, nbitspersample;\n    ok = TIFFGetField(_tif, TIFFTAG_SAMPLESPERPIXEL, &nsamples);\n    if (!ok) return (-1);\n\n    ok = TIFFGetField(_tif, TIFFTAG_BITSPERSAMPLE, &nbitspersample);\n    if (!ok) return (-1);\n\n    if (nsamples == 2 && nbitspersample == 8) {\n        tdata_t buf;\n        uint32_t  row;\n        short   config;\n        short   photometric;\n\n        TIFFGetField(_tif, TIFFTAG_PLANARCONFIG, &config);\n        if (!ok) return (-1);\n\n        TIFFGetField(_tif, TIFFTAG_PHOTOMETRIC, &photometric);\n        if (!ok) return (-1);\n\n        buf = _TIFFmalloc(TIFFScanlineSize(_tif));\n        VAssert(buf != NULL);\n\n        unsigned char *charArray = (unsigned char *)buf;\n        int            scanlength = TIFFScanlineSize(_tif) / 2;\n\n        if (config == PLANARCONFIG_CONTIG) {\n            for (row = 0; row < h; row++) {\n                int revrow = h - row - 1;    // reverse, go bottom up\n                int rc = TIFFReadScanline(_tif, buf, row);\n                if (rc < 0) {\n                    MyBase::SetErrMsg(\"Error reading tiff file:\\n %s\\n\", _path.c_str());\n                    _TIFFfree(buf);\n                    return (-1);\n                }\n                for (int k = 0; k < scanlength; k++) {\n                    unsigned char greyval = charArray[2 * k];\n                    // If white is zero, reverse it:\n                    if (!photometric) greyval = 255 - greyval;\n                    unsigned char alphaval = charArray[2 * k + 1];\n                    texuint32_t[revrow * w + k] = alphaval << 24 | greyval << 16 | greyval << 8 | greyval;\n                }\n            }\n        } else if (config == PLANARCONFIG_SEPARATE) {\n            uint16_t s;\n\n            // Note: following loop (adapted from tiff docs) has not\n            // been tested.  Are there tiff\n            // examples with separate alpha channel?\n            //\n            for (s = 0; s < nsamples; s++) {\n                for (row = 0; row < h; row++) {\n                    int rc = TIFFReadScanline(_tif, buf, row, s);\n                    if (rc < 0) {\n                        MyBase::SetErrMsg(\"Error reading tiff file:\\n %s\\n\", _path.c_str());\n                        _TIFFfree(buf);\n                        return (-1);\n                    }\n                    int revrow = h - row - 1;    // reverse, go bottom up\n                    if (!(s % 2)) {              // color\n                        for (int k = 0; k < h; k++) {\n                            unsigned char greyval = charArray[k];\n                            // If white is zero, reverse it:\n                            if (!photometric) greyval = 255 - greyval;\n                            texuint32_t[revrow * w + k] = greyval << 16 | greyval << 8 | greyval;\n                        }\n                    } else {    // alpha\n                        for (int k = 0; k < h; k++) {\n                            unsigned char alphaval = charArray[k];\n                            texuint32_t[revrow * w + k] = alphaval << 24 | (texuint32_t[revrow * w + k] & 0xffffff);\n                        }\n                    }\n                }\n            }\n        }\n        _TIFFfree(buf);\n        return (0);\n\n    } else {\n        // Read pixels, whether or not we are georeferenced:\n\n        ok = TIFFReadRGBAImage(_tif, w, h, texuint32_t, 0);\n        if (!ok) {\n            MyBase::SetErrMsg(\"Error reading tiff file:\\n %s\\n\", _path.c_str());\n            return -1;\n        }\n\n        return (0);\n    }\n}",
    "void GeoImageGeoTiff::_initTimeVector(TIFF *tif, const vector<double> &times)\n{\n    _times = times;\n    _tiffTimes.clear();\n\n    // Check if the first time step (tiff \"directory\" has a time stamp.\n    // If it does all directories must have a time stamp. If no time\n    // stamp is present then the time stamp is taken from the data itself.\n    //\n    TIFFSetDirectory(tif, 0);\n\n    char *timePtr = NULL;\n    bool  hasTime = TIFFGetField(tif, TIFFTAG_DATETIME, &timePtr);\n\n    // build a list of the times in the tiff\n    //\n    UDUnits udunits;\n    udunits.Initialize();\n\n    do {\n        int dircount = 0;\n\n        if (hasTime) {\n            double tifftime = 0.0;\n            bool   ok = _getTiffTime(tif, &udunits, tifftime);\n            if (!ok) {\n                SetDiagMsg(\"Failed to read time stamp from TIFF image\");\n                break;\n            }\n            _tiffTimes.push_back(tifftime);\n        } else {\n            if (dircount < _times.size()) _tiffTimes.push_back(_times[dircount]);\n        }\n\n        dircount++;\n    } while (TIFFReadDirectory(tif));\n\n    return;\n}",
    "bool GeoImageGeoTiff::_getTiffTime(TIFF *tif, UDUnits *udunits, double &tifftime) const\n{\n    tifftime = 0.0;\n\n    char *timePtr = NULL;\n    bool  hasTime = (bool)TIFFGetField(tif, TIFFTAG_DATETIME, &timePtr);\n\n    if (!hasTime) return (false);\n\n    // determine seconds from the time stamp in the tiff\n    // convert tifftags to use WRF style date/time strings\n    //\n    int         year, mon, mday, hour, min, sec;\n    const char *format = \"%4d:%2d:%2d %2d:%2d:%2d\";\n    int         rc = sscanf(timePtr, format, &year, &mon, &mday, &hour, &min, &sec);\n\n    // For backwords compatibility check WRF-style format\n    //\n    if (rc != 6) {\n        format = \"%4d-%2d-%2d_%2d:%2d:%2d\";\n        rc = sscanf(timePtr, format, &year, &mon, &mday, &hour, &min, &sec);\n\n        if (rc != 6) return (false);\n    }\n\n    tifftime = udunits->EncodeTime(year, mon, mday, hour, min, sec);\n    return (true);\n}",
    "static void CopyGeoTIFF(TIFF *in, TIFF *out)\n{\n    GTIF *  gtif = (GTIF *)0; /* GeoKey-level descriptor */\n    double *d_list = NULL;\n    int16_t   d_list_count;\n\n    /* read definition from source file. */\n    gtif = GTIFNew(in);\n    if (!gtif) return;\n\n    if (TIFFGetField(in, GTIFF_TIEPOINTS, &d_list_count, &d_list)) TIFFSetField(out, GTIFF_TIEPOINTS, d_list_count, d_list);\n    if (TIFFGetField(in, GTIFF_PIXELSCALE, &d_list_count, &d_list)) TIFFSetField(out, GTIFF_PIXELSCALE, d_list_count, d_list);\n    if (TIFFGetField(in, GTIFF_TRANSMATRIX, &d_list_count, &d_list)) TIFFSetField(out, GTIFF_TRANSMATRIX, d_list_count, d_list);\n\n    /* Here we violate the GTIF abstraction to retarget on another file.\n       We should just have a function for copying tags from one GTIF object\n       to another. */\n    gtif->gt_tif = out;\n    gtif->gt_flags |= FLAG_FILE_MODIFIED;\n\n    /* Install keys and tags */\n    GTIFWriteKeys(gtif);\n    GTIFFree(gtif);\n    return;\n}",
    "static void cpOtherTags(TIFF *in, TIFF *out)\n{\n    struct cpTag *p = tags;\n    for (int i = 0; i < NTAGS; i++, p++) {\n        switch (p->type) {\n        case TIFF_SHORT:\n            if (p->count == 1) {\n                uint16_t shortv;\n                CopyField(p->tag, shortv);\n            } else if (p->count == 2) {\n                uint16_t shortv1, shortv2;\n                CopyField2(p->tag, shortv1, shortv2);\n            } else if (p->count == (uint16_t)-1) {\n                uint16_t  shortv1;\n                uint16_t *shortav;\n                CopyField2(p->tag, shortv1, shortav);\n            }\n            break;\n        case TIFF_LONG: {\n            uint32_t longv;\n            CopyField(p->tag, longv);\n        } break;\n        case TIFF_RATIONAL:\n            if (p->count == 1) {\n                float floatv;\n                // CopyField(tag, v) replaced by following\n                // Workaround a tiff lib bug:  TIFFGetField gets a very small float\n                if (TIFFGetField(in, p->tag, &floatv) && floatv >= .00001) TIFFSetField(out, p->tag, floatv);\n            } else if (p->count == (uint16_t)-1) {\n                float *floatav;\n                CopyField(p->tag, floatav);\n            }\n            break;\n        case TIFF_ASCII: {\n            char *stringv;\n            CopyField(p->tag, stringv);\n        } break;\n        case TIFF_DOUBLE:\n            if (p->count == 1) {\n                double doublev;\n                CopyField(p->tag, doublev);\n            } else if (p->count == (uint16_t)-1) {\n                double *doubleav;\n                CopyField(p->tag, doubleav);\n            }\n            break;\n        default: break;\n        }\n    }\n}",
    "static int tiffcp(TIFF *in, TIFF *out)\n{\n    uint16_t   samplesperpixel, shortv;\n    uint16_t   bitspersample = 0;\n    copyFunc cf;\n    uint32_t   w, l;\n\n    CopyField(TIFFTAG_IMAGEWIDTH, w);\n    CopyField(TIFFTAG_IMAGELENGTH, l);\n\n    currentImageWidth = w;\n    currentImageHeight = l;\n    if (convert_8_to_4) {\n        TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 4);\n    } else {\n        CopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);\n    }\n    if (compression != (uint16_t)-1)\n        TIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n    else\n        CopyField(TIFFTAG_COMPRESSION, compression);\n    if (compression == COMPRESSION_JPEG && jpegcolormode == JPEGCOLORMODE_RGB)\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n    else\n        CopyField(TIFFTAG_PHOTOMETRIC, shortv);\n    if (fillorder != 0)\n        TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n    else\n        CopyField(TIFFTAG_FILLORDER, shortv);\n    CopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n    /*\n     * Choose tiles/strip for the output image according to\n     * the command line arguments (-tiles, -strips) and the\n     * structure of the input image.\n     */\n    if (outtiled == -1) outtiled = TIFFIsTiled(in);\n    if (outtiled) {\n        /*\n         * Setup output file's tile width&height.  If either\n         * is not specified, use either the value from the\n         * input image or, if nothing is defined, use the\n         * library default.\n         */\n        if (tilewidth == (uint32_t)-1) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);\n        if (tilelength == (uint32_t)-1) TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);\n        TIFFDefaultTileSize(out, &tilewidth, &tilelength);\n        TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);\n        TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);\n    } else {\n        /*\n         * RowsPerStrip is left unspecified: use either the\n         * value from the input image or, if nothing is defined,\n         * use the library default.\n         */\n        if (rowsperstrip == (uint32_t)-1) TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n        rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n        TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n    }\n    if (config != (uint16_t)-1)\n        TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n    else\n        CopyField(TIFFTAG_PLANARCONFIG, config);\n    if (g3opts != (uint32_t)-1)\n        TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);\n    else\n        CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\n    if (samplesperpixel <= 4) {\n        uint16_t *tr, *tg, *tb, *ta;\n        CopyField4(TIFFTAG_TRANSFERFUNCTION, tr, tg, tb, ta);\n    }\n    {\n        uint16_t *red, *green, *blue;\n        if (TIFFGetField(in, TIFFTAG_COLORMAP, &red, &green, &blue)) {\n            CheckAndCorrectColormap(in, 1 << bitspersample, red, green, blue);\n            TIFFSetField(out, TIFFTAG_COLORMAP, red, green, blue);\n        }\n    }\n    /* SMinSampleValue & SMaxSampleValue */\n    switch (compression) {\n    case COMPRESSION_JPEG:\n        TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n        TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n        break;\n    case COMPRESSION_LZW:\n    case COMPRESSION_DEFLATE:\n        if (predictor != (uint16_t)-1)\n            TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n        else\n            CopyField(TIFFTAG_PREDICTOR, predictor);\n        break;\n    }\n    cpOtherTags(in, out);\n\n    if (geofile || proj4_string || timeFile)\n        InstallGeoTIFF(out);\n    else\n        CopyGeoTIFF(in, out);\n\n    if (worldfile) ApplyWorldFile(worldfile, out);\n\n    cf = pickCopyFunc(in, out, bitspersample, samplesperpixel);\n    return (cf ? (*cf)(in, out, l, w, samplesperpixel) : FALSE);\n}",
    "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n    unsigned char *tilebuf = (unsigned char *)_TIFFmalloc(TIFFTileSize(in));\n    uint32_t         imagew = TIFFScanlineSize(in);\n    uint32_t         tilew = TIFFTileRowSize(in);\n    int            iskew = imagew - tilew;\n    unsigned char *bufp = buf;\n    uint32_t         tw, tl;\n    uint32_t         row;\n\n    (void)spp;\n    if (tilebuf == 0) return;\n    (void)TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n    (void)TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n    for (row = 0; row < imagelength; row += tl) {\n        uint32_t nrow = (row + tl > imagelength) ? imagelength - row : tl;\n        uint32_t colb = 0;\n        uint32_t col;\n\n        for (col = 0; col < imagewidth; col += tw) {\n            if (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0 && !ignore) goto done;\n            if (colb + tilew > imagew) {\n                uint32_t width = imagew - colb;\n                uint32_t oskew = tilew - width;\n                cpStripToTile(bufp + colb, tilebuf, nrow, width, oskew + iskew, oskew);\n            } else\n                cpStripToTile(bufp + colb, tilebuf, nrow, tilew, iskew, 0);\n            colb += tilew;\n        }\n        bufp += imagew * nrow;\n    }\ndone:\n    _TIFFfree(tilebuf);\n}",
    "DECLAREreadFunc(readSeparateTilesIntoBuffer)\n{\n    uint32_t         imagew = TIFFScanlineSize(in);\n    uint32_t         tilew = TIFFTileRowSize(in);\n    int            iskew = imagew - tilew;\n    unsigned char *tilebuf = (unsigned char *)_TIFFmalloc(TIFFTileSize(in));\n    unsigned char *bufp = buf;\n    uint32_t         tw, tl;\n    uint32_t         row;\n\n    if (tilebuf == 0) return;\n    (void)TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n    (void)TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n    for (row = 0; row < imagelength; row += tl) {\n        uint32_t nrow = (row + tl > imagelength) ? imagelength - row : tl;\n        uint32_t colb = 0;\n        uint32_t col;\n\n        for (col = 0; col < imagewidth; col += tw) {\n            tsample_t s;\n\n            for (s = 0; s < spp; s++) {\n                if (TIFFReadTile(in, tilebuf, col, row, 0, s) < 0 && !ignore) goto done;\n                /*\n                 * Tile is clipped horizontally.  Calculate\n                 * visible portion and skewing factors.\n                 */\n                if (colb + tilew > imagew) {\n                    uint32_t width = imagew - colb;\n                    int    oskew = tilew - width;\n                    cpSeparateBufToContigBuf(bufp + colb + s, tilebuf, nrow, width, oskew + iskew, oskew, spp);\n                } else\n                    cpSeparateBufToContigBuf(bufp + colb + s, tilebuf, nrow, tw, iskew, 0, spp);\n            }\n            colb += tilew;\n        }\n        bufp += imagew * nrow;\n    }\ndone:\n    _TIFFfree(tilebuf);\n}",
    "DECLAREwriteFunc(writeBufferToContigTiles)\n{\n    uint32_t         imagew = TIFFScanlineSize(out);\n    uint32_t         tilew = TIFFTileRowSize(out);\n    int            iskew = imagew - tilew;\n    unsigned char *obuf = (unsigned char *)_TIFFmalloc(TIFFTileSize(out));\n    unsigned char *bufp = buf;\n    uint32_t         tl, tw;\n    uint32_t         row;\n\n    (void)spp;\n    if (obuf == NULL) return (FALSE);\n    (void)TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n    (void)TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n    for (row = 0; row < imagelength; row += tilelength) {\n        uint32_t nrow = (row + tl > imagelength) ? imagelength - row : tl;\n        uint32_t colb = 0;\n        uint32_t col;\n\n        for (col = 0; col < imagewidth; col += tw) {\n            /*\n             * Tile is clipped horizontally.  Calculate\n             * visible portion and skewing factors.\n             */\n            if (colb + tilew > imagew) {\n                uint32_t width = imagew - colb;\n                int    oskew = tilew - width;\n                cpStripToTile(obuf, bufp + colb, nrow, width, oskew, oskew + iskew);\n            } else\n                cpStripToTile(obuf, bufp + colb, nrow, tilew, 0, iskew);\n            if (TIFFWriteTile(out, obuf, col, row, 0, 0) < 0) {\n                _TIFFfree(obuf);\n                return (FALSE);\n            }\n            colb += tilew;\n        }\n        bufp += nrow * imagew;\n    }\n    _TIFFfree(obuf);\n    return (TRUE);\n}",
    "DECLAREwriteFunc(writeBufferToSeparateTiles)\n{\n    uint32_t         imagew = TIFFScanlineSize(out);\n    tsize_t        tilew = TIFFTileRowSize(out);\n    int            iskew = imagew - tilew;\n    unsigned char *obuf = (unsigned char *)_TIFFmalloc(TIFFTileSize(out));\n    unsigned char *bufp = buf;\n    uint32_t         tl, tw;\n    uint32_t         row;\n\n    if (obuf == NULL) return (FALSE);\n    (void)TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n    (void)TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n    for (row = 0; row < imagelength; row += tl) {\n        uint32_t nrow = (row + tl > imagelength) ? imagelength - row : tl;\n        uint32_t colb = 0;\n        uint32_t col;\n\n        for (col = 0; col < imagewidth; col += tw) {\n            tsample_t s;\n            for (s = 0; s < spp; s++) {\n                /*\n                 * Tile is clipped horizontally.  Calculate\n                 * visible portion and skewing factors.\n                 */\n                if (colb + tilew > imagew) {\n                    uint32_t width = imagew - colb;\n                    int    oskew = tilew - width;\n\n                    cpContigBufToSeparateBuf(obuf, bufp + colb + s, nrow, width, oskew / spp, oskew + imagew, spp);\n                } else\n                    cpContigBufToSeparateBuf(obuf, bufp + colb + s, nrow, tilewidth, 0, iskew, spp);\n                if (TIFFWriteTile(out, obuf, col, row, 0, s) < 0) {\n                    _TIFFfree(obuf);\n                    return (FALSE);\n                }\n            }\n            colb += tilew;\n        }\n        bufp += nrow * imagew;\n    }\n    _TIFFfree(obuf);\n    return (TRUE);\n}",
    "static copyFunc pickCopyFunc(TIFF *in, TIFF *out, uint16_t bitspersample, uint16_t samplesperpixel)\n{\n    uint16_t shortv;\n    uint32_t w, l, tw, tl;\n    int    bychunk;\n\n    (void)TIFFGetField(in, TIFFTAG_PLANARCONFIG, &shortv);\n    if (shortv != config && bitspersample != 8 && samplesperpixel > 1) {\n        fprintf(stderr, \"%s: Can not handle different planar configuration w/ bits/sample != 8\\n\", TIFFFileName(in));\n        return (NULL);\n    }\n    TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w);\n    TIFFGetField(in, TIFFTAG_IMAGELENGTH, &l);\n    if (TIFFIsTiled(out)) {\n        if (!TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw)) tw = w;\n        if (!TIFFGetField(in, TIFFTAG_TILELENGTH, &tl)) tl = l;\n        bychunk = (tw == tilewidth && tl == tilelength);\n    } else if (TIFFIsTiled(in)) {\n        TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n        TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n        bychunk = (tw == w && tl == rowsperstrip);\n    } else {\n        uint32_t irps = (uint32_t)-1L;\n        TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &irps);\n        bychunk = (rowsperstrip == irps);\n    }\n#define T                   1\n#define F                   0\n#define pack(a, b, c, d, e) ((long)(((a) << 11) | ((b) << 3) | ((c) << 2) | ((d) << 1) | (e)))\n    switch (pack(shortv, config, TIFFIsTiled(in), TIFFIsTiled(out), bychunk)) {\n        /* Strips -> Tiles */\n    case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG, F, T, F):\n    case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG, F, T, T): return cpContigStrips2ContigTiles;\n    case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE, F, T, F):\n    case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE, F, T, T): return cpContigStrips2SeparateTiles;\n    case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG, F, T, F):\n    case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG, F, T, T): return cpSeparateStrips2ContigTiles;\n    case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F, T, F):\n    case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F, T, T):\n        return cpSeparateStrips2SeparateTiles;\n        /* Tiles -> Tiles */\n    case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG, T, T, F):\n    case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG, T, T, T): return cpContigTiles2ContigTiles;\n    case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE, T, T, F):\n    case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE, T, T, T): return cpContigTiles2SeparateTiles;\n    case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG, T, T, F):\n    case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG, T, T, T): return cpSeparateTiles2ContigTiles;\n    case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T, T, F):\n    case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T, T, T):\n        return cpSeparateTiles2SeparateTiles;\n        /* Tiles -> Strips */\n    case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG, T, F, F):\n    case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG, T, F, T): return cpContigTiles2ContigStrips;\n    case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE, T, F, F):\n    case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE, T, F, T): return cpContigTiles2SeparateStrips;\n    case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG, T, F, F):\n    case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG, T, F, T): return cpSeparateTiles2ContigStrips;\n    case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T, F, F):\n    case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T, F, T):\n        return cpSeparateTiles2SeparateStrips;\n        /* Strips -> Strips */\n    case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG, F, F, F):\n        if (convert_8_to_4)\n            return cpContig2ContigByRow_8_to_4;\n        else\n            return cpContig2ContigByRow;\n\n    case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG, F, F, T):\n        if (convert_8_to_4)\n            return cpContig2ContigByRow_8_to_4;\n        else\n            return cpDecodedStrips;\n    case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE, F, F, F):\n    case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE, F, F, T): return cpContig2SeparateByRow;\n    case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG, F, F, F):\n    case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG, F, F, T): return cpSeparate2ContigByRow;\n    case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F, F, F):\n    case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F, F, T): return cpSeparate2SeparateByRow;\n    }\n#undef pack\n#undef F\n#undef T\n    fprintf(stderr, \"tiffcp: %s: Don't know how to copy/convert image.\\n\", TIFFFileName(in));\n    return (NULL);\n}",
    "ImagePyramid::ImagePyramid(TIFF *fileHandle, std::vector<ImagePyramidLevel> levels, int channels, bool isOMETIFF) {\n    m_isOMETIFF = isOMETIFF;\n    if(channels <= 0 || channels > 4)\n        throw Exception(\"Nr of channels must be between 1 and 4 in ImagePyramid when importing from TIFF\");\n    m_tiffHandle = fileHandle;\n    m_levels = levels;\n    m_channels = channels;\n    for(int i = 0; i < m_levels.size(); ++i) {\n        m_levels[i].tilesX = std::ceil((float)m_levels[i].width / m_levels[i].tileWidth);\n        m_levels[i].tilesY = std::ceil((float)m_levels[i].height / m_levels[i].tileHeight);\n    }\n    TIFFSetDirectory(fileHandle, 0);\n    // Get data type\n    uint16_t bitsPerSample;\n    TIFFGetField(fileHandle, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n    uint16_t sampleFormat;\n    TIFFGetField(fileHandle, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n    if(sampleFormat == SAMPLEFORMAT_IEEEFP) {\n        if(bitsPerSample == 32) {\n            m_dataType = TYPE_FLOAT;\n        } else {\n            throw Exception(\"Unsupported TIFF data type, float with \" + std::to_string(bitsPerSample) + \" bits\");\n        }\n    } else if(sampleFormat == SAMPLEFORMAT_UINT) {\n        std::map<uint16_t, DataType> bitsPerSampleMap = {\n                {8, TYPE_UINT8},\n                {16, TYPE_UINT16},\n                };\n        if(bitsPerSampleMap.count(bitsPerSample) > 0) {\n            m_dataType = bitsPerSampleMap[bitsPerSample];\n        } else {\n            throw Exception(\"Unsupported TIFF data type, unsigned integer with \" + std::to_string(bitsPerSample) + \" bits\");\n        }\n    } else if(sampleFormat == SAMPLEFORMAT_INT) {\n        std::map<uint16_t, DataType> bitsPerSampleMap = {\n                {8, TYPE_INT8},\n                {16, TYPE_INT16},\n                };\n        if(bitsPerSampleMap.count(bitsPerSample) > 0) {\n            m_dataType = bitsPerSampleMap[bitsPerSample];\n        } else {\n            throw Exception(\"Unsupported TIFF data type, signed integer with \" + std::to_string(bitsPerSample) + \" bits\");\n        }\n    } else {\n        throw Exception(\"Unsupported TIFF data type: \" + std::to_string(sampleFormat) + \" \" + std::to_string(bitsPerSample) + \" bits\");\n        //m_dataType = TYPE_UINT8;\n    }\n    // Get compression\n    uint16_t compressionTag;\n    TIFFGetField(fileHandle, TIFFTAG_COMPRESSION, &compressionTag);\n    ImageCompression compression = ImageCompression::UNSPECIFIED;\n    switch(compressionTag) {\n        case COMPRESSION_NONE:\n            compression = ImageCompression::RAW;\n            break;\n        case COMPRESSION_JPEG:\n            compression = ImageCompression::JPEG;\n            {\n                int quality = -1;\n                int res = TIFFGetField(m_tiffHandle, TIFFTAG_JPEGQUALITY, &quality);\n                if(res != 1)\n                    throw Exception(\"Unable to get JPEG quality from TIFF\");\n                m_compressionQuality = quality;\n            }\n            break;\n        case COMPRESSION_JXL:\n            compression = ImageCompression::JPEGXL;\n            break;\n        case COMPRESSION_LZW:\n            compression = ImageCompression::LZW;\n            break;\n        case COMPRESSION_JP2000:\n            throw Exception(\"JPEG 2000 TIFF not supported yet\");\n            break;\n        case COMPRESSION_ADOBE_DEFLATE:\n        case COMPRESSION_DEFLATE:\n            compression = ImageCompression::DEFLATE;\n            break;\n        case 34666:\n            compression = ImageCompression::NEURAL_NETWORK;\n            break;\n        default:\n            reportWarning() << \"Unrecognized compression by FAST in TIFF: \" << compressionTag << reportEnd();\n    }\n    m_compressionFormat = compression;\n    // Get spacing from TIFF\n    float spacingX;\n    float spacingY;\n    int resX = TIFFGetField(fileHandle, TIFFTAG_XRESOLUTION, &spacingX);\n    int resY = TIFFGetField(fileHandle, TIFFTAG_YRESOLUTION, &spacingY);\n    if(resX == 1 && resY == 1) {\n        // Convert from cm\n        spacingX = 1.0f/(spacingX/10.0f);\n        spacingY = 1.0f/(spacingY/10.0f);\n        reportInfo() << \"Spacing from TIFF was \" << spacingX << \" \" << spacingY << reportEnd();\n        m_spacing = Vector3f(spacingX, spacingY, 1.0f);\n    }\n    mBoundingBox = DataBoundingBox(Vector3f(getFullWidth(), getFullHeight(), 0));\n    m_initialized = true;\n    m_pyramidFullyInitialized = true;\n    m_counter += 1;\n}",
    "void TIFFImagePyramidImporter::execute() {\n\n    reportInfo() << \"Reading WSI with TIFF\" << reportEnd();\n    TIFFSetErrorHandler([](const char* module, const char* fmt, va_list ap) {\n        auto str = make_uninitialized_unique<char[]>(512);\n        sprintf(str.get(), fmt, ap);\n        Reporter::warning() << \"TIFF: \" << module << \": \" << str.get() << Reporter::end();\n    });\n    TIFFSetWarningHandler([](const char* module, const char* fmt, va_list ap) {\n        auto str = make_uninitialized_unique<char[]>(512);\n        sprintf(str.get(), fmt, ap);\n        std::string strstr = str.get();\n        if(strstr.find(\"tag ignored\") == std::string::npos) // ignore warnings about incorrect tag\n            Reporter::warning() << \"TIFF: \" << module << \": \" << str.get() << Reporter::end();\n    });\n    TIFF* tiff = TIFFOpen(m_filename.c_str(), \"rm\");\n    if(tiff == nullptr) {\n        throw Exception(\"Failed to open file \" + m_filename);\n    }\n\n    std::vector<ImagePyramidLevel> levelList;\n    uint16_t channels;\n\n    bool isOMETiff = false;\n    TIFFSetDirectory(tiff, 0);\n    // Read description to check if image is OME-TIFF\n    char * description;\n    int result = TIFFGetField(tiff, TIFFTAG_IMAGEDESCRIPTION, &description);\n    if(result == 1) { // Must check if tag exists\n        std::string str = description;\n        if(str.find(\"xml\") != std::string::npos && str.find(\"OME\") != std::string::npos) {\n            reportInfo() << \"TIFF file seems to be an OME-TIFF, reading it as such..\" << reportEnd();\n            isOMETiff = true;\n        }\n    }\n\n    float magnification = 0.0f;\n    if(isOMETiff) {\n        TIFFSetDirectory(tiff, 0);\n\n        // read data for level 0\n        uint width, height;\n        TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n        uint tileWidth, tileHeight;\n        TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tileWidth);\n        TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tileHeight);\n        TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &channels);\n        reportInfo() << \"Level \" << 0 <<  \" has size \" << width << \" \" << height <<\n        \" and tile size: \" << tileWidth << \" \" << tileHeight << \" channels \" << channels << reportEnd();\n\n        ImagePyramidLevel levelData;\n        levelData.width = width;\n        levelData.height = height;\n        levelData.tileWidth = tileWidth;\n        levelData.tileHeight = tileHeight;\n        levelData.offset = 0;\n        levelList.push_back(levelData);\n\n        // Read SubIFD offsets\n        uint16_t count;\n        uint64_t* values; // If big tiff, this is 64. This is deleted by TIFF\n        TIFFGetField(tiff, TIFFTAG_SUBIFD, &count, &values);\n        std::vector<uint64_t> offsets; // Have to copy the offsets for some reason\n        for(int i = 0; i < count; ++i)\n            offsets.push_back(values[i]);\n\n        reportInfo() << \"Found \" << count << \" subdirectories (SubIFD) in OME-TIFF file\" << reportEnd();\n        for(int i = 0; i < count; ++i) {\n            TIFFSetSubDirectory(tiff, offsets[i]);\n            uint width, height;\n            TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n            TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n            uint tileWidth, tileHeight;\n            TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tileWidth);\n            TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tileHeight);\n            reportInfo() << \"Level \" << (i+1) <<  \" has size \" << width << \" \" << height <<\n                         \" and tile size: \" << tileWidth << \" \" << tileHeight << \" channels \" << channels << reportEnd();\n\n            ImagePyramidLevel levelData;\n            levelData.width = width;\n            levelData.height = height;\n            levelData.tileWidth = tileWidth;\n            levelData.tileHeight = tileHeight;\n            levelData.offset = offsets[i];\n            levelList.push_back(levelData);\n        }\n\n        // Try to get magnification from description using regex\n        std::regex pattern(R\"(NominalMagnification=\"([-+]?[0-9]*\\.?[0-9]+))\");\n        std::smatch match;\n        std::string str = description;\n        magnification = 0.0f;\n        while(std::regex_search(str, match, pattern)) {\n            if(std::stof(match[1]) > magnification) { // Get largest magnification\n                magnification = std::stof(match[1]);\n            }\n            str = match.suffix();\n        }\n        if(magnification == 0) {\n            reportInfo() << \"Unable to get magnification from OME-TIFF XML data\" << reportEnd();\n        } else {\n            reportInfo() << \"Got magnification \" << magnification << \" from OME-TIFF XML data\" << reportEnd();\n        }\n    } else {\n        for(int level = 0; level < TIFFNumberOfDirectories(tiff); ++level) {\n            TIFFSetDirectory(tiff, level);\n            uint width, height;\n            TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n            TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n            uint tileWidth, tileHeight;\n            TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tileWidth);\n            TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tileHeight);\n            TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &channels);\n            reportInfo() << \"Level \" << level <<  \" has size \" << width << \" \" << height <<\n            \" and tile size: \" << tileWidth << \" \" << tileHeight << \" channels \" << channels << reportEnd();\n\n            ImagePyramidLevel levelData;\n            levelData.width = width;\n            levelData.height = height;\n            levelData.tileWidth = tileWidth;\n            levelData.tileHeight = tileHeight;\n            levelList.push_back(levelData);\n        }\n    }\n    auto image = ImagePyramid::create(tiff, levelList, (int)channels, isOMETiff);\n    if(magnification > 0)\n        image->setMagnification(magnification);\n    addOutputData(0, image);\n}",
    "void GetMatrices(const char* fileName, Mat44f& camera, Mat44f& screen,\n                     bool doTranspose)\n    {\n        TIFF* tif = TIFFOpen(fileName, \"r\");\n        if (tif == NULL)\n        {\n            TWK_EXC_THROW_WHAT(Exception, \"Could not open file\");\n        }\n\n        float* ptr = NULL;\n        int rslt = TIFFGetField(tif, TIFFTAG_CAMERA_MATRIX, &ptr);\n        if (ptr == NULL)\n        {\n            TWK_EXC_THROW_WHAT(Exception, \"Could not get camera matrix\");\n        }\n        else\n        {\n            memcpy((void*)(&(camera[0][0])), (const void*)ptr,\n                   16 * sizeof(float));\n        }\n\n        rslt = TIFFGetField(tif, TIFFTAG_SCREEN_MATRIX, &ptr);\n        if (ptr == NULL)\n        {\n            TWK_EXC_THROW_WHAT(Exception, \"Could not get screen matrix\");\n        }\n        else\n        {\n            memcpy((void*)(&(screen[0][0])), (const void*)ptr,\n                   16 * sizeof(float));\n        }\n\n        TIFFClose(tif);\n\n        if (doTranspose)\n        {\n            camera.transpose();\n            screen.transpose();\n        }\n    }",
    "static void readAllTags(TIFF* tif, FrameBuffer& img)\n    {\n        //\n        //  ICC Profile\n        //\n        //  I have to look for this before EXIFTAG_COLORSPACE or else I get\n        //  crashing\n        //\n\n        uint32 Len;\n        void* Buffer;\n        bool set_profile = false;\n\n        if (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &Len, &Buffer))\n        {\n            img.setPrimaryColorSpace(ColorSpace::ICCProfile());\n            img.setTransferFunction(ColorSpace::ICCProfile());\n            img.setICCprofile(Buffer, Len);\n\n            set_profile = true;\n\n            //_TIFFfree(Buffer); // this is a bad idea apparently (causes a\n            // crash)\n        }\n\n        //\n        //  Read EXIF tags if present\n        //\n\n        uint32 exif_offset = 0;\n\n        if (TIFFGetField(tif, TIFFTAG_EXIFIFD, &exif_offset))\n        {\n            tdir_t directory = TIFFCurrentDirectory(tif);\n\n            if (TIFFReadEXIFDirectory(tif, exif_offset))\n            {\n                unsigned short v_short = 0;\n\n                //\n                // Special handling of color space tag\n                //\n\n                if (TIFFGetField(tif, EXIFTAG_COLORSPACE, &v_short))\n                {\n                    if (v_short == 1)\n                    {\n                        img.attribute<string>(\"EXIF/ColorSpace\") = \"1 (sRGB)\";\n\n                        if (!set_profile)\n                        {\n                            img.setPrimaryColorSpace(ColorSpace::Rec709());\n                            img.setTransferFunction(ColorSpace::sRGB());\n                        }\n                    }\n                    else if (v_short == 2)\n                    {\n                        //\n                        //  NOTE: this might be wrong.\n                        //  See: http://www.cpanforum.com/threads/2784\n                        //\n\n                        img.attribute<string>(\"EXIF/ColorSpace\") =\n                            \"2 (Adobe RGB)\";\n\n                        if (!set_profile)\n                        {\n                            img.setPrimaryColorSpace(ColorSpace::ICCProfile());\n                            img.attribute<string>(\n                                ColorSpace::ICCProfileDescription()) =\n                                string(\"Adobe RGB\");\n                        }\n                    }\n                    else\n                    {\n                        ostringstream str;\n                        str << v_short << \" (Uncalibrated)\";\n                        img.attribute<string>(\"EXIF/ColorSpace\") = str.str();\n                        img.setPrimaryColorSpace(ColorSpace::Generic());\n                    }\n                }\n            }\n        }\n\n        //\n        //  Now the rest of the tags\n        //\n\n        for (int fi = 0, nfi = tif->tif_nfields; fi < nfi; fi++)\n        {\n            const TIFFField* const fip = tif->tif_fields[fi];\n\n            if (fip->field_tag != TIFFTAG_ICCPROFILE\n                && // exclude tags we handle seperately\n                fip->field_tag != EXIFTAG_COLORSPACE &&\n\n                fip->field_tag != TIFFTAG_XRESOLUTION\n                && fip->field_tag != TIFFTAG_YRESOLUTION\n                && fip->field_tag != TIFFTAG_SOFTWARE\n                && fip->field_tag != EXIFTAG_PIXELXDIMENSION\n                && fip->field_tag != EXIFTAG_PIXELYDIMENSION\n                && fip->field_tag != TIFFTAG_RESOLUTIONUNIT\n                && fip->field_tag != TIFFTAG_PLANARCONFIG &&\n\n                fip->field_tag != TIFFTAG_SUBIFD &&\n\n                // There are some variable length tags that require more than\n                // one argument. This is an attempt to filter those out.\n                // However, this may be filtering EXIF tags ... its hard to tell\n                // For example TIFFTAG_COLORMAP,  TIFFTAG_HALFTONEHINTS,\n                // TIFFTAG_PAGENUMBER, and TIFFTAG_SUBIFD, ...\n                // see tif_dir.c _TIFFVGetField for multiple uses of va_arg()\n                // by a tag type.\n\n                (fip->field_readcount != TIFF_VARIABLE\n                 || fip->field_type == TIFF_ASCII)\n                &&\n\n                // fip->field_tag != TIFFTAG_COLORMAP &&\n                // fip->field_tag != TIFFTAG_HALFTONEHINTS &&\n                fip->field_tag != TIFFTAG_PAGENUMBER &&\n                // fip->field_tag != TIFFTAG_SUBIFD &&\n                fip->field_tag != TIFFTAG_YCBCRSUBSAMPLING &&\n                // fip->field_tag != TIFFTAG_TRANSFERFUNCTION &&\n\n                fip->field_tag != TIFFTAG_PHOTOMETRIC\n                && fip->field_tag != TIFFTAG_IMAGEWIDTH\n                && fip->field_tag != TIFFTAG_IMAGELENGTH\n                && fip->field_tag != TIFFTAG_BITSPERSAMPLE\n                && fip->field_tag != TIFFTAG_SAMPLESPERPIXEL)\n            {\n                unsigned char ch;\n                char* text;\n                float f;\n                float* fp;\n                unsigned int ui;\n                unsigned short us;\n\n                bool exif_tag = false;\n\n                if (exif_offset)\n                {\n                    //\n                    //  If we read EXIF, we have to check tags against known\n                    //  EXIF\n                    //\n\n                    for (unsigned int tag = exifTags[0].tag, i = 0;\n                         (tag = exifTags[i].tag) && !exif_tag; i++)\n                    {\n                        exif_tag = (tag == fip->field_tag);\n                    }\n                }\n\n                string aname = (exif_tag ? string(\"EXIF/\") : string(\"TIFF/\"))\n                               + fip->field_name;\n\n                switch (fip->field_type)\n                {\n                case TIFF_ASCII:\n                    if (fip->field_passcount)\n                    {\n                        if (TIFFGetField(tif, fip->field_tag, &Len, &text))\n                        {\n                            img.attribute<string>(aname) = text;\n                        }\n                    }\n                    else if (TIFFGetField(tif, fip->field_tag, &text))\n                    {\n                        img.attribute<string>(aname) = text;\n                    }\n                    break;\n\n                case TIFF_SHORT:\n                    if (TIFFGetField(tif, fip->field_tag, &us))\n                    {\n                        img.attribute<int>(aname) = us;\n                    }\n                    break;\n\n                case TIFF_LONG:\n                    // sometimes this is LONG (which is supposed to be wrong)\n                    if (aname == \"TIFF/RichTIFFIPTC\")\n                    {\n                        void* array = 0;\n\n                        if (TIFFGetField(tif, fip->field_tag, &ui, &array))\n                        {\n                            img.attribute<string>(aname) = \"\";\n                        }\n                    }\n                    else if (TIFFGetField(tif, fip->field_tag, &ui))\n                    {\n                        img.attribute<int>(aname) = ui;\n                    }\n                    break;\n\n                case TIFF_RATIONAL:\n                case TIFF_SRATIONAL:\n                case TIFF_FLOAT:\n                    if (TIFFGetField(tif, fip->field_tag, &f))\n                    {\n                        img.attribute<float>(aname) = f;\n                    }\n                    break;\n\n                case TIFF_BYTE:\n                    // could be BYTE\n                    if (aname == \"TIFF/RichTIFFIPTC\")\n                    {\n                        char* array = 0;\n\n                        if (TIFFGetField(tif, fip->field_tag, &ui, &array))\n                        {\n                            img.attribute<string>(aname) = array;\n                        }\n                    }\n                    break;\n\n                case TIFF_UNDEFINED: // means char, apparently\n                    // could be undefined\n                    if (aname == \"TIFF/RichTIFFIPTC\")\n                    {\n                        char* array = 0;\n\n                        if (TIFFGetField(tif, fip->field_tag, &ui, &array))\n                        {\n                            img.attribute<string>(aname) = array;\n                        }\n                    }\n                    // if(TIFFGetField(tif, fip->field_tag, &ch))\n                    //{\n                    // img.attribute<int>(aname) = ch;\n                    //}\n                    break;\n\n                default:\n                    break;\n                }\n            }\n        }\n    }",
    "static void readContiguousScanlineImage3Planar(TIFF* tif, int w, int h,\n                                                   FrameBuffer& img)\n    {\n        unsigned short orient = ORIENTATION_TOPLEFT;\n        bool flip = false;\n        bool flop = false;\n        TIFFGetField(tif, TIFFTAG_ORIENTATION, &orient);\n        flip = orient == ORIENTATION_TOPLEFT || orient == ORIENTATION_TOPRIGHT;\n        flop = orient == ORIENTATION_TOPRIGHT || orient == ORIENTATION_BOTRIGHT;\n\n        unsigned short sampleFormat = DEFAULT_TIFFTAG_SAMPLEFORMAT_VALUE;\n        unsigned short bitsPerSample = DEFAULT_TIFFTAG_BITSPERSAMPLE_VALUE;\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n        TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n        tsize_t rowsize = 0;\n        unsigned char* buf = 0;\n        if (sampleFormat == SAMPLEFORMAT_INT)\n        {\n            rowsize = TIFFScanlineSize(tif);\n            buf = (unsigned char*)_TIFFmalloc(rowsize);\n        }\n\n        for (int y = 0; y < h; ++y)\n        {\n            int flipY = flip ? h - y - 1 : y;\n\n            if (sampleFormat == SAMPLEFORMAT_INT)\n            {\n                if (TIFFReadScanline(tif, buf, y) == -1)\n                {\n                    // Incomplete image read, just stop and return what we did\n                    // get\n                    break;\n                }\n\n                float* fbBuf = img.scanline<float>(flipY);\n\n                storeIntAsNormalizedFloatSamples(bitsPerSample, rowsize, buf,\n                                                 fbBuf);\n\n                memcpy(fbBuf, buf, rowsize);\n            }\n            else\n            {\n                if (TIFFReadScanline(tif, img.scanline<unsigned char>(flipY), y)\n                    == -1)\n                {\n                    // Incomplete image read, just stop and return what we did\n                    // get\n                    break;\n                }\n            }\n        }\n\n        if (buf)\n            _TIFFfree(buf);\n\n        if (flop)\n        {\n            img.setOrientation(FrameBuffer::BOTTOMRIGHT);\n        }\n    }",
    "static void readContiguousScanlineImage(TIFF* tif, int w, int h,\n                                            FrameBuffer& img)\n    {\n        unsigned short orient = ORIENTATION_TOPLEFT;\n        bool flip = false;\n        bool flop = false;\n        TIFFGetField(tif, TIFFTAG_ORIENTATION, &orient);\n        flip = orient == ORIENTATION_TOPLEFT || orient == ORIENTATION_TOPRIGHT;\n        flop = orient == ORIENTATION_TOPRIGHT || orient == ORIENTATION_BOTRIGHT;\n\n        unsigned short sampleFormat = DEFAULT_TIFFTAG_SAMPLEFORMAT_VALUE;\n        unsigned short bitsPerSample = DEFAULT_TIFFTAG_BITSPERSAMPLE_VALUE;\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n        TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n        tsize_t rowsize = 0;\n        unsigned char* buf = 0;\n        if (sampleFormat == SAMPLEFORMAT_INT)\n        {\n            rowsize = TIFFScanlineSize(tif);\n            buf = (unsigned char*)_TIFFmalloc(rowsize);\n        }\n\n        //\n        //  Because we use TIFF a lot, and tiff files are stored by default\n        //  in TOPLEFT orientation, we'll \"correct\" it to make it bottom\n        //  right. For scanline images this is not a huge hit -- we just\n        //  read the image backwards. For orther orientations we'll set the\n        //  FB image orientation\n        //\n\n        for (int y = 0; y < h; ++y)\n        {\n            int flipY = flip ? h - y - 1 : y;\n\n            if (sampleFormat == SAMPLEFORMAT_INT)\n            {\n                if (TIFFReadScanline(tif, buf, y) == -1)\n                {\n                    // Incomplete image read, just stop and return what we did\n                    // get\n                    break;\n                }\n\n                float* fbBuf = img.scanline<float>(flipY);\n\n                storeIntAsNormalizedFloatSamples(bitsPerSample, rowsize, buf,\n                                                 fbBuf);\n\n                memcpy(fbBuf, buf, rowsize);\n            }\n            else\n            {\n                if (TIFFReadScanline(tif, img.scanline<unsigned char>(flipY), y)\n                    == -1)\n                {\n                    // Incomplete image read, just stop and return what we did\n                    // get\n                    break;\n                }\n            }\n        }\n\n        if (buf)\n            _TIFFfree(buf);\n\n        if (flop)\n        {\n            img.setOrientation(FrameBuffer::BOTTOMRIGHT);\n        }\n    }",
    "static void readContiguousScanlineImageOverflow(TIFF* tif, int w, int h,\n                                                    FrameBuffer& img)\n    {\n        //\n        //  This function is used when we have an interleaved TIFF with more\n        //  than 4 channels. The TwkFrameBuffer doesn't like more than 4\n        //  interleaved channels, so we'll decode the scanline and copy only the\n        //  first 4 samples from each pixel.\n        //\n\n        unsigned short samplesPerPixel = DEFAULT_TIFFTAG_SAMPLESPERPIXEL_VALUE;\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);\n\n        unsigned short orient = ORIENTATION_TOPLEFT;\n        bool flip = false;\n        bool flop = false;\n        TIFFGetField(tif, TIFFTAG_ORIENTATION, &orient);\n        flip = orient == ORIENTATION_TOPLEFT || orient == ORIENTATION_TOPRIGHT;\n        flop = orient == ORIENTATION_TOPRIGHT || orient == ORIENTATION_BOTRIGHT;\n\n        unsigned short sampleFormat = DEFAULT_TIFFTAG_SAMPLEFORMAT_VALUE;\n        unsigned short bitsPerSample = DEFAULT_TIFFTAG_BITSPERSAMPLE_VALUE;\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n        TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n        if (unsigned char* buf =\n                (unsigned char*)_TIFFmalloc(TIFFScanlineSize(tif)))\n        {\n            //\n            //  Because we use TIFF a lot, and tiff files are stored by default\n            //  in TOPLEFT orientation, we'll \"correct\" it to make it bottom\n            //  right. For scanline images this is not a huge hit -- we just\n            //  read the image backwards. For orther orientations we'll set the\n            //  FB image orientation\n            //\n\n            for (int y = 0; y < h; ++y)\n            {\n                int flipY = flip ? h - y - 1 : y;\n\n                if (TIFFReadScanline(tif, buf, y) == -1)\n                {\n                    // Incomplete image read, just stop and return what we did\n                    // get\n                    break;\n                }\n\n                if (sampleFormat == SAMPLEFORMAT_INT)\n                {\n                    switch (bitsPerSample)\n                    {\n                    case 8:\n                        copyAndNormalizeScanlineSamples(\n                            (unsigned char*)buf, img.scanline<float>(flipY), w,\n                            4, samplesPerPixel - 4,\n                            SAMPLEFORMAT_INT8_NORM_VALUE);\n                        break;\n                    case 16:\n                        copyAndNormalizeScanlineSamples(\n                            (unsigned short*)buf, img.scanline<float>(flipY), w,\n                            4, samplesPerPixel - 4,\n                            SAMPLEFORMAT_INT16_NORM_VALUE);\n                        break;\n                    case 32:\n                        copyAndNormalizeScanlineSamples(\n                            (float*)buf, img.scanline<float>(flipY), w, 4,\n                            samplesPerPixel - 4, SAMPLEFORMAT_INT32_NORM_VALUE);\n                        break;\n                    }\n                }\n                else\n                {\n                    switch (bitsPerSample)\n                    {\n                    case 1:\n                    case 8:\n                        copyScanlineSamples((unsigned char*)buf,\n                                            img.scanline<unsigned char>(flipY),\n                                            w, 4, samplesPerPixel - 4);\n                        break;\n                    case 16:\n                        copyScanlineSamples((unsigned short*)buf,\n                                            img.scanline<unsigned short>(flipY),\n                                            w, 4, samplesPerPixel - 4);\n                        break;\n                    case 32:\n                        copyScanlineSamples((float*)buf,\n                                            img.scanline<float>(flipY), w, 4,\n                                            samplesPerPixel - 4);\n                        break;\n                    }\n                }\n            }\n\n            _TIFFfree(buf);\n        }\n\n        if (flop)\n        {\n            img.setOrientation(FrameBuffer::BOTTOMRIGHT);\n        }\n    }",
    "static void readContiguousScanlineImageAsPlanar(TIFF* tif, int w, int h,\n                                                    FrameBuffer& img)\n    {\n        //\n        //  This function is used when we have an interleaved TIFF with more\n        //  than 4 channels. In this case the FrameBuffer should be planar and\n        //  we'll have to copy the interleaved scanline to the planes.\n        //\n\n        assert(img.isPlanar());\n\n        unsigned short samplesPerPixel = DEFAULT_TIFFTAG_SAMPLESPERPIXEL_VALUE;\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);\n\n        unsigned short orient = ORIENTATION_TOPLEFT;\n        bool flip = false;\n        bool flop = false;\n        TIFFGetField(tif, TIFFTAG_ORIENTATION, &orient);\n        flip = orient == ORIENTATION_TOPLEFT || orient == ORIENTATION_TOPRIGHT;\n        flop = orient == ORIENTATION_TOPRIGHT || orient == ORIENTATION_BOTRIGHT;\n\n        unsigned short sampleFormat = DEFAULT_TIFFTAG_SAMPLEFORMAT_VALUE;\n        unsigned short bitsPerSample = DEFAULT_TIFFTAG_BITSPERSAMPLE_VALUE;\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n        TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n        if (unsigned char* buf =\n                (unsigned char*)_TIFFmalloc(TIFFScanlineSize(tif)))\n        {\n            //\n            //  Because we use TIFF a lot, and tiff files are stored by default\n            //  in TOPLEFT orientation, we'll \"correct\" it to make it bottom\n            //  right. For scanline images this is not a huge hit -- we just\n            //  read the image backwards. For orther orientations we'll set the\n            //  FB image orientation\n            //\n\n            for (int y = 0; y < h; ++y)\n            {\n                int flipY = flip ? h - y - 1 : y;\n\n                if (TIFFReadScanline(tif, buf, y) == -1)\n                {\n                    // Incomplete image read, just stop and return what we did\n                    // get\n                    break;\n                }\n\n                FrameBuffer* fbuf = &img;\n\n                for (int c = 0;\n                     c < img.planeSize() && c < samplesPerPixel && fbuf; c++)\n                {\n\n                    if (sampleFormat == SAMPLEFORMAT_INT)\n                    {\n                        switch (bitsPerSample)\n                        {\n                        case 8:\n                            copyAndNormalizeScanlineSamples(\n                                (unsigned char*)buf + c,\n                                &fbuf->pixel<float>(0, flipY), w, 1,\n                                samplesPerPixel - 1,\n                                SAMPLEFORMAT_INT8_NORM_VALUE);\n                            break;\n                        case 16:\n                            copyAndNormalizeScanlineSamples(\n                                (unsigned short*)buf + c,\n                                &fbuf->pixel<float>(0, flipY), w, 1,\n                                samplesPerPixel - 1,\n                                SAMPLEFORMAT_INT16_NORM_VALUE);\n                            break;\n                        case 32:\n                            copyAndNormalizeScanlineSamples(\n                                (float*)buf + c, &fbuf->pixel<float>(0, flipY),\n                                w, 1, samplesPerPixel - 1,\n                                SAMPLEFORMAT_INT32_NORM_VALUE);\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        switch (bitsPerSample)\n                        {\n                        case 1:\n                        case 8:\n                            copyScanlineSamples(\n                                (unsigned char*)buf + c,\n                                &fbuf->pixel<unsigned char>(0, flipY), w, 1,\n                                samplesPerPixel - 1);\n                            break;\n                        case 16:\n                            copyScanlineSamples(\n                                (unsigned short*)buf + c,\n                                &fbuf->pixel<unsigned short>(0, flipY), w, 1,\n                                samplesPerPixel - 1);\n                            break;\n                        case 32:\n                            copyScanlineSamples((float*)buf + c,\n                                                &fbuf->pixel<float>(0, flipY),\n                                                w, 1, samplesPerPixel - 1);\n                            break;\n                        }\n                    }\n\n                    fbuf = fbuf->nextPlane();\n                }\n            }\n\n            _TIFFfree(buf);\n        }\n\n        if (flop)\n        {\n            img.setOrientation(FrameBuffer::BOTTOMRIGHT);\n        }\n    }",
    "static void readPlanarScanlineImage(TIFF* tif, int w, int h, int planes,\n                                        FrameBuffer& img)\n    {\n        unsigned short orient = ORIENTATION_TOPLEFT;\n        bool flip = false;\n        bool flop = false;\n        TIFFGetField(tif, TIFFTAG_ORIENTATION, &orient);\n        flip = orient == ORIENTATION_TOPLEFT || orient == ORIENTATION_TOPRIGHT;\n        flop = orient == ORIENTATION_TOPRIGHT || orient == ORIENTATION_BOTRIGHT;\n\n        unsigned short sampleFormat = DEFAULT_TIFFTAG_SAMPLEFORMAT_VALUE;\n        unsigned short bitsPerSample = DEFAULT_TIFFTAG_BITSPERSAMPLE_VALUE;\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n        TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n        //\n        //  Because we use TIFF a lot, and tiff files are stored by default\n        //  in TOPLEFT orientation, we'll \"correct\" it to make it bottom\n        //  right. For scanline images this is not a huge hit -- we just\n        //  read the image backwards. For orther orientations we'll set the\n        //  FB image orientation\n        //\n\n        FrameBuffer* fb = &img;\n\n        tsize_t rowsize = 0;\n        unsigned char* buf = 0;\n        if (sampleFormat == SAMPLEFORMAT_INT)\n        {\n            rowsize = TIFFScanlineSize(tif);\n            buf = (unsigned char*)_TIFFmalloc(rowsize);\n        }\n\n        for (int p = 0; p < planes && fb; ++p)\n        {\n            for (int y = 0; y < h; ++y)\n            {\n                int flipY = flip ? h - y - 1 : y;\n\n                if (sampleFormat == SAMPLEFORMAT_INT)\n                {\n                    if (TIFFReadScanline(tif, buf, y, p) == -1)\n                    {\n                        // Incomplete image read, just stop and return what we\n                        // did get\n                        break;\n                    }\n\n                    float* fbBuf = &fb->pixel<float>(0, flipY);\n\n                    storeIntAsNormalizedFloatSamples(bitsPerSample, rowsize,\n                                                     buf, fbBuf);\n\n                    memcpy(fbBuf, buf, rowsize);\n                }\n                else\n                {\n                    if (TIFFReadScanline(\n                            tif, &fb->pixel<unsigned char>(0, flipY), y, p)\n                        == -1)\n                    {\n                        // Incomplete image read, just stop and return what we\n                        // did get\n                        break;\n                    }\n                }\n            }\n\n            fb = fb->nextPlane();\n        }\n\n        if (buf)\n            _TIFFfree(buf);\n\n        if (flop)\n        {\n            img.setOrientation(FrameBuffer::BOTTOMRIGHT);\n        }\n    }",
    "static void readContiguousTiledImage(TIFF* tif, int w, int h,\n                                         FrameBuffer& img)\n    {\n        tsize_t rowsize = TIFFTileRowSize(tif);\n\n        unsigned short orient = ORIENTATION_TOPLEFT;\n        bool flip = false;\n        bool flop = false;\n        TIFFGetField(tif, TIFFTAG_ORIENTATION, &orient);\n        flip = orient == ORIENTATION_TOPLEFT || orient == ORIENTATION_TOPRIGHT;\n        flop = orient == ORIENTATION_TOPRIGHT || orient == ORIENTATION_BOTRIGHT;\n\n        if (flip)\n        {\n            img.setOrientation(flop ? FrameBuffer::TOPRIGHT\n                                    : FrameBuffer::TOPLEFT);\n        }\n        else\n        {\n            img.setOrientation(flop ? FrameBuffer::BOTTOMRIGHT\n                                    : FrameBuffer::NATURAL);\n        }\n\n        if (unsigned char* buf = (unsigned char*)_TIFFmalloc(TIFFTileSize(tif)))\n        {\n            uint32 tw, th, w, h;\n\n            TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n            TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n            TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n            TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n\n            unsigned short sampleFormat = DEFAULT_TIFFTAG_SAMPLEFORMAT_VALUE;\n            unsigned short bitsPerSample = DEFAULT_TIFFTAG_BITSPERSAMPLE_VALUE;\n            TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n            TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n            // These checks are to handle the case where the\n            // tile is larger than the image size.\n            //\n            uint32 copy_rowsize = ((w < tw) ? (w * rowsize / tw) : rowsize);\n\n            for (uint32 row = 0; row < h; row += th)\n            {\n                for (uint32 col = 0; col < w; col += tw)\n                {\n                    if (TIFFReadTile(tif, buf, col, row, 0, 0) < 0)\n                    {\n                        _TIFFfree(buf);\n                        return; // just return on partially read image\n                    }\n                    else\n                    {\n                        //\n                        //  Copy the tile row over to the fb\n                        //\n\n                        for (int y = 0; y < th && row + y < h; y++)\n                        {\n                            if (sampleFormat == SAMPLEFORMAT_INT)\n                            {\n                                storeIntAsNormalizedFloatSamples(\n                                    bitsPerSample, copy_rowsize,\n                                    buf + y * rowsize,\n                                    &img.pixel<float>(col, row + y));\n                            }\n                            else\n                            {\n                                unsigned char* s =\n                                    &img.pixel<unsigned char>(col, row + y);\n                                memcpy(s, buf + y * rowsize, copy_rowsize);\n                            }\n                        }\n                    }\n                }\n            }\n\n            _TIFFfree(buf);\n        }\n    }",
    "static void readPlanarTiledImage(TIFF* tif, int w, int h, FrameBuffer& img)\n    {\n        tsize_t rowsize = TIFFTileRowSize(tif);\n        unsigned short orient = ORIENTATION_TOPLEFT;\n        bool flip = false;\n        bool flop = false;\n        FrameBuffer::Orientation o;\n\n        TIFFGetField(tif, TIFFTAG_ORIENTATION, &orient);\n        flip = orient == ORIENTATION_TOPLEFT || orient == ORIENTATION_TOPRIGHT;\n        flop = orient == ORIENTATION_TOPRIGHT || orient == ORIENTATION_BOTRIGHT;\n\n        if (flip)\n        {\n            o = flop ? FrameBuffer::TOPRIGHT : FrameBuffer::TOPLEFT;\n        }\n        else\n        {\n            o = flop ? FrameBuffer::BOTTOMRIGHT : FrameBuffer::NATURAL;\n        }\n\n        if (unsigned char* buf = (unsigned char*)_TIFFmalloc(TIFFTileSize(tif)))\n        {\n            uint32 tw, th, w, h;\n            unsigned short d = DEFAULT_TIFFTAG_SAMPLESPERPIXEL_VALUE;\n            unsigned short sampleFormat = DEFAULT_TIFFTAG_SAMPLEFORMAT_VALUE;\n            unsigned short bitsPerSample = DEFAULT_TIFFTAG_BITSPERSAMPLE_VALUE;\n\n            TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n            TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n            TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n            TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n            TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &d);\n            TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n            TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n            FrameBuffer* fb = &img;\n\n            // These checks are to handle the case where the\n            // tile is larger than the image size.\n            //\n            uint32 copy_rowsize = ((w < tw) ? (w * rowsize / tw) : rowsize);\n\n            for (uint32 plane = 0; plane < d && fb; plane++)\n            {\n                fb->setOrientation(o);\n\n                for (uint32 row = 0; row < h; row += th)\n                {\n                    for (uint32 col = 0; col < w; col += tw)\n                    {\n                        if (TIFFReadTile(tif, buf, col, row, 0, plane) < 0)\n                        {\n                            _TIFFfree(buf);\n                            return; // just return on partially read image\n                        }\n                        else\n                        {\n                            //\n                            //  Copy the tile row over to the fb\n                            //\n\n                            for (int y = 0; y < th && row + y < h; y++)\n                            {\n                                if (sampleFormat == SAMPLEFORMAT_INT)\n                                {\n                                    storeIntAsNormalizedFloatSamples(\n                                        bitsPerSample, copy_rowsize,\n                                        buf + y * rowsize,\n                                        &fb->pixel<float>(col, row + y));\n                                }\n                                else\n                                {\n                                    unsigned char* s =\n                                        &fb->pixel<unsigned char>(col, row + y);\n                                    memcpy(s, buf + y * rowsize, copy_rowsize);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                fb = fb->nextPlane();\n            }\n\n            _TIFFfree(buf);\n        }\n    }",
    "void IOtiff::getImageInfo(const std::string& filename, FBInfo& fbi) const\n    {\n#ifdef _MSC_VER\n        TIFF* tif = TIFFOpenW(UNICODE_C_STR(filename.c_str()), \"r\");\n#else\n        TIFF* tif = TIFFOpen(UNICODE_C_STR(filename.c_str()), \"r\");\n#endif\n\n        if (!tif)\n        {\n            TWK_THROW_STREAM(Exception,\n                             \"TIFF cannot open \\\"\" << filename << \"\\\"\");\n        }\n\n        unsigned short colorspace;\n        unsigned short orient = ORIENTATION_TOPLEFT;\n\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &fbi.width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &fbi.height);\n        TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &colorspace);\n        TIFFGetField(tif, TIFFTAG_ORIENTATION, &orient);\n\n        unsigned short samplesPerPixel = DEFAULT_TIFFTAG_SAMPLESPERPIXEL_VALUE;\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);\n        fbi.numChannels = samplesPerPixel;\n\n        unsigned short bitsPerSample = DEFAULT_TIFFTAG_BITSPERSAMPLE_VALUE;\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n\n        unsigned short sampleFormat = DEFAULT_TIFFTAG_SAMPLEFORMAT_VALUE;\n        TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n        uint16 config;\n        TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n\n        float x_rez, y_rez;\n        if (TIFFGetField(tif, TIFFTAG_XRESOLUTION, &x_rez)\n            && TIFFGetField(tif, TIFFTAG_YRESOLUTION, &y_rez))\n        {\n            fbi.pixelAspect = x_rez != 0.0 ? y_rez / x_rez : 1.0;\n            unsigned short unit = 0;\n\n            if (TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, &unit))\n            {\n                ostringstream str;\n\n                switch (unit)\n                {\n                case 1:\n                    str << \"None\";\n                    break;\n                case 2:\n                    str << \"Inch\";\n                    break;\n                case 3:\n                    str << \"Centimeter\";\n                    break;\n                default:\n                    str << \"Unknown (\" << unit << \")\";\n                    break;\n                }\n\n                fbi.proxy.newAttribute(\"TIFF/ResolutionUnit\", str.str());\n            }\n\n            fbi.proxy.setPixelAspectRatio(x_rez != 0.0 ? y_rez / x_rez : 1.0);\n            fbi.proxy.newAttribute(\"TIFF/XResolution\", x_rez);\n            fbi.proxy.newAttribute(\"TIFF/YResolution\", y_rez);\n        }\n\n        readAllTags(tif, fbi.proxy);\n\n        switch (bitsPerSample)\n        {\n        case 1:\n            fbi.dataType = FrameBuffer::BIT;\n            break;\n        case 8:\n            if (sampleFormat == SAMPLEFORMAT_INT)\n            {\n                // We promote tif signed int types to\n                // a float type framebuffer, normalized\n                // by the unsigned 8 bit value.\n                fbi.dataType = FrameBuffer::FLOAT;\n            }\n            else\n            {\n                fbi.dataType = FrameBuffer::UCHAR;\n            }\n            break;\n        case 16:\n            if (sampleFormat == SAMPLEFORMAT_INT)\n            {\n                // We promote tif signed int types to\n                // a float type framebuffer, normalized\n                // by the unsigned 16 bit value.\n                fbi.dataType = FrameBuffer::FLOAT;\n            }\n            else\n            {\n                fbi.dataType = FrameBuffer::USHORT;\n            }\n            break;\n        case 32:\n            if (sampleFormat == SAMPLEFORMAT_INT)\n            {\n                // We promote tif signed int types to\n                // a float type framebuffer, normalized\n                // by the unsigned 16 bit value for this case.\n                fbi.dataType = FrameBuffer::FLOAT;\n            }\n            else if (sampleFormat == SAMPLEFORMAT_UINT)\n            {\n                fbi.dataType = FrameBuffer::UINT;\n            }\n            else\n            {\n                fbi.dataType = FrameBuffer::FLOAT;\n            }\n            break;\n        default:\n            TIFFClose(tif);\n            TWK_THROW_STREAM(Exception, \"Sorry, unsupported bit depth.\");\n        }\n\n        bool readAsRGBA = false;\n\n        if ((colorspace != PHOTOMETRIC_RGB\n             && colorspace != PHOTOMETRIC_MINISBLACK\n             && colorspace != PHOTOMETRIC_MINISWHITE)\n            || (m_addAlphaTo3Channel && samplesPerPixel == 3)\n            || (config == PLANARCONFIG_CONTIG && samplesPerPixel > 4))\n        {\n            readAsRGBA = true;\n        }\n\n        if (readAsRGBA)\n        {\n            // TIFFReadRGBAImage(tif, width, height, p, 0);\n            fbi.orientation = FrameBuffer::NATURAL;\n        }\n        else if (TIFFIsTiled(tif))\n        {\n            // readContiguousTiledImage(tif, width, height, fb);\n            //  or readPlanarTiledImage(tif, width, height, fb);\n            bool flip = false;\n            bool flop = false;\n            flip =\n                orient == ORIENTATION_TOPLEFT || orient == ORIENTATION_TOPRIGHT;\n            flop = orient == ORIENTATION_TOPRIGHT\n                   || orient == ORIENTATION_BOTRIGHT;\n\n            if (flip)\n                fbi.orientation =\n                    (flop ? FrameBuffer::TOPRIGHT : FrameBuffer::TOPLEFT);\n            else\n                fbi.orientation =\n                    (flop ? FrameBuffer::BOTTOMRIGHT : FrameBuffer::NATURAL);\n        }\n        else\n        {\n            bool flip = false;\n            bool flop = false;\n            flop = orient == ORIENTATION_TOPRIGHT\n                   || orient == ORIENTATION_BOTRIGHT;\n            fbi.orientation =\n                flop ? FrameBuffer::BOTTOMRIGHT : FrameBuffer::NATURAL;\n        }\n\n        TIFFClose(tif);\n    }",
    "void IOtiff::readImage(FrameBuffer& fb, const std::string& filename,\n                           const ReadRequest& request) const\n    {\n        TIFF* tif = NULL;\n        StreamData* stream = NULL;\n\n        try\n        {\n            if (m_iotype == StandardIO)\n            {\n#ifdef _MSC_VER\n                tif = TIFFOpenW(UNICODE_C_STR(filename.c_str()), \"r\");\n#else\n                tif = TIFFOpen(UNICODE_C_STR(filename.c_str()), \"r\");\n#endif\n            }\n            else\n            {\n                stream = new StreamData(\n                    filename, (FileStream::Type)((unsigned int)m_iotype - 1),\n                    m_iosize, m_iomaxAsync);\n\n                tif = TIFFClientOpen(filename.c_str(), \"r\", (thandle_t)stream,\n                                     readproc, writeproc, seekproc, closeproc,\n                                     sizeproc, NULL, NULL);\n            }\n\n            if (!tif)\n            {\n                TWK_THROW_STREAM(Exception,\n                                 \"TIFF: cannot open \\\"\" << filename << \"\\\"\");\n            }\n\n            int width;\n            int height;\n            unsigned short bitsPerSample = DEFAULT_TIFFTAG_BITSPERSAMPLE_VALUE;\n            FrameBuffer::DataType dataType = FrameBuffer::UCHAR;\n            unsigned short samplesPerPixel =\n                DEFAULT_TIFFTAG_SAMPLESPERPIXEL_VALUE;\n            uint16 config;\n            bool istexture = false;\n            bool isshadow = false;\n            char* texformat = 0;\n            char* datetime = 0;\n            unsigned short colorspace = 2;\n            float x_rez, y_rez;\n            uint16 numExtra = 0, *extraSamples = 0;\n            unsigned short sampleFormat = DEFAULT_TIFFTAG_SAMPLEFORMAT_VALUE;\n\n            TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &colorspace);\n            TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n            TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n            TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n            TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);\n            TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n            TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n            TIFFGetField(tif, TIFFTAG_EXTRASAMPLES, &numExtra, &extraSamples);\n\n#if 0\n        if (TIFFGetField(tif, TIFFTAG_PIXAR_TEXTUREFORMAT, &texformat) == 1)\n        {\n            istexture = true;\n            isshadow = !strcmp(texformat, \"Shadow\");\n        }\n#endif\n\n            FrameBuffer* img = NULL;\n            bool readAsRGBA = false;\n\n            if ((colorspace != PHOTOMETRIC_RGB\n                 && colorspace != PHOTOMETRIC_MINISBLACK\n                 && colorspace != PHOTOMETRIC_MINISWHITE)\n                || (m_addAlphaTo3Channel && samplesPerPixel == 3)\n                || (config == PLANARCONFIG_CONTIG && samplesPerPixel > 4))\n            {\n                readAsRGBA = true;\n                samplesPerPixel = 4;\n            }\n\n            switch (bitsPerSample)\n            {\n            case 1:\n                dataType = FrameBuffer::UCHAR;\n                break;\n\n            case 8:\n                if (sampleFormat == SAMPLEFORMAT_INT)\n                {\n                    // We promote tif signed int types to\n                    // a float type framebuffer, normalized\n                    // by the unsigned 8 bit value.\n                    dataType = FrameBuffer::FLOAT;\n                }\n                else\n                {\n                    dataType = FrameBuffer::UCHAR;\n                }\n                break;\n\n            case 16:\n                if (sampleFormat == SAMPLEFORMAT_INT)\n                {\n                    // We promote tif signed int types to\n                    // a float type framebuffer, normalized\n                    // by the unsigned 16 bit value.\n                    dataType = FrameBuffer::FLOAT;\n                }\n                else\n                {\n                    dataType = FrameBuffer::USHORT;\n                }\n                break;\n\n            case 32:\n                if (sampleFormat == SAMPLEFORMAT_INT)\n                {\n                    // We promote tif signed int types to\n                    // a float type framebuffer, normalized\n                    // by the unsigned 16 bit value for this case.\n                    dataType = FrameBuffer::FLOAT;\n                }\n                else if (sampleFormat == SAMPLEFORMAT_UINT)\n                {\n                    dataType = FrameBuffer::UINT;\n                }\n                else\n                {\n                    dataType = FrameBuffer::FLOAT;\n                }\n                break;\n\n            default:\n                TWK_THROW_STREAM(UnsupportedException,\n                                 \"TIFF: Unsupported bit depth (\"\n                                     << bitsPerSample << \") trying to read \"\n                                     << filename);\n            }\n\n            if (config == PLANARCONFIG_SEPARATE)\n            {\n                const char* chanNames[] = {\"R\", \"G\", \"B\", \"A\", \"Z\",\n                                           \"X\", \"Y\", \"P\", \"D\", \"Q\"};\n\n                StringVector planeNames;\n\n                for (int i = 0; i < samplesPerPixel && i < 10; i++)\n                {\n                    planeNames.push_back(string(chanNames[i]));\n                }\n\n                fb.restructurePlanar(width, height, planeNames, dataType,\n                                     FrameBuffer::NATURAL);\n            }\n            else\n            {\n                fb.restructure(\n                    width, height, 0, min((int)samplesPerPixel, 4),\n                    dataType); // interleaved, we can only do 4 channels\n            }\n\n            string message = \"Reading TIFF \" + stl_ext::basename(filename);\n\n            if (readAsRGBA)\n            {\n                uint32* p = fb.begin<uint32>();\n                const uint32* e = fb.end<uint32>();\n\n                TIFFReadRGBAImage(tif, width, height, p, 0);\n\n#ifdef __BIG_ENDIAN__\n                for (; p < e; p++)\n                {\n                    const uint32 i = *p;\n                    *p = (uint32(TIFFGetR(i)) << 24)\n                         | (uint32(TIFFGetG(i)) << 16)\n                         | (uint32(TIFFGetB(i)) << 8) | uint32(TIFFGetA(i));\n                }\n#endif\n            }\n            else if (TIFFIsTiled(tif))\n            {\n                if (config == PLANARCONFIG_CONTIG)\n                {\n                    readContiguousTiledImage(tif, width, height, fb);\n                    fb.newAttribute(\"TIFF/PlanarConfig\",\n                                    string(\"Tiled Contiguous\"));\n                }\n                else\n                {\n                    readPlanarTiledImage(tif, width, height, fb);\n                    fb.newAttribute(\"TIFF/PlanarConfig\",\n                                    string(\"Tiled Separate\"));\n                }\n            }\n            else\n            {\n                if (config == PLANARCONFIG_CONTIG)\n                {\n                    if (samplesPerPixel == 1\n                        || (dataType != FrameBuffer::USHORT\n                            && samplesPerPixel <= 4))\n                    {\n                        readContiguousScanlineImage(tif, width, height, fb);\n                    }\n                    else\n                    {\n                        const char* chanNames[] = {\"R\", \"G\", \"B\", \"A\", \"Z\",\n                                                   \"X\", \"Y\", \"P\", \"D\", \"Q\"};\n\n                        if (!fb.isPlanar())\n                        {\n                            StringVector planeNames;\n\n                            for (int i = 0; i < samplesPerPixel && i < 10; i++)\n                            {\n                                planeNames.push_back(string(chanNames[i]));\n                            }\n\n                            fb.restructurePlanar(width, height, planeNames,\n                                                 dataType,\n                                                 FrameBuffer::NATURAL);\n                        }\n                        readContiguousScanlineImageAsPlanar(tif, width, height,\n                                                            fb);\n                    }\n\n                    fb.newAttribute(\"TIFF/PlanarConfig\", string(\"Contiguous\"));\n                }\n                else\n                {\n                    readPlanarScanlineImage(tif, width, height, samplesPerPixel,\n                                            fb);\n                    fb.newAttribute(\"TIFF/PlanarConfig\", string(\"Separate\"));\n                }\n            }\n\n            //\n            //  Here we have a workaround for Maya writing the resolution tags\n            //  wrong. Someday this should be replaced with a rule in our fancy\n            //  rules system.\n            //\n\n            char* software = NULL;\n            bool isMaya = false;\n            unsigned int compression;\n\n            if (TIFFGetField(tif, TIFFTAG_COMPRESSION, &compression))\n            {\n                string compressionName = tagToName(compression, compTags);\n                fb.newAttribute(\"TIFF/Compression\", compressionName);\n            }\n\n            if (TIFFGetField(tif, TIFFTAG_SOFTWARE, &software))\n            {\n                fb.newAttribute(\"TIFF/Software\", string(software));\n\n                if (!strncmp(software, \"Maya\", 4))\n                {\n                    isMaya = true;\n                }\n            }\n\n            if (TIFFGetField(tif, TIFFTAG_XRESOLUTION, &x_rez)\n                && TIFFGetField(tif, TIFFTAG_YRESOLUTION, &y_rez))\n            {\n                unsigned short unit = 0;\n\n                if (TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, &unit))\n                {\n                    ostringstream str;\n\n                    switch (unit)\n                    {\n                    case 1:\n                        str << \"None\";\n                        break;\n                    case 2:\n                        str << \"Inch\";\n                        break;\n                    case 3:\n                        str << \"Centimeter\";\n                        break;\n                    default:\n                        str << \"Unknown (\" << unit << \")\";\n                        break;\n                    }\n\n                    fb.newAttribute(\"TIFF/ResolutionUnit\", str.str());\n                }\n\n                if (!isMaya)\n                {\n                    fb.setPixelAspectRatio(x_rez != 0.0 ? y_rez / x_rez : 1.0);\n                }\n\n                fb.newAttribute(\"TIFF/XResolution\", x_rez);\n                fb.newAttribute(\"TIFF/YResolution\", y_rez);\n            }\n\n            readAllTags(tif, fb);\n\n            TIFFClose(tif);\n\n#if 0\n        if (isshadow)\n        {\n            TwkFB::normalize(&fb, true, true);\n        }\n#endif\n\n            if (numExtra)\n            {\n                switch (extraSamples[0])\n                {\n                case EXTRASAMPLE_UNASSALPHA:\n                    fb.attribute<string>(\"AlphaType\") = \"Unpremultipled\";\n                    break;\n                case EXTRASAMPLE_ASSOCALPHA:\n                    fb.attribute<string>(\"AlphaType\") = \"Premultiplied\";\n                    break;\n                default:\n                    break;\n                }\n            }\n\n            //\n            //  Most cards can't handle RGB or RGBA 16bit int textures.\n            //\n            if (fb.dataType() == FrameBuffer::USHORT && fb.numChannels() != 1\n                && !fb.isPlanar())\n            {\n                //  cerr << \"converting tiff to planar\" << endl;\n                FrameBufferVector fbv = split(&fb);\n                fbv[0]->setIdentifier(fb.identifier());\n                fb.copyAttributesTo(fbv[0]);\n                for (int j = 1; j < fbv.size(); ++j)\n                    fbv[0]->appendPlane(fbv[j]);\n                fb.copyFrom(fbv[0]);\n                delete fbv[0];\n            }\n        }\n        catch (...)\n        {\n            delete stream;\n            stream = 0;\n            throw;\n        }\n\n        delete stream;\n    }",
    "static void readTIFF(ImageType::ImageStruct* im,\n                         const Mu::String& imgFileName, Thread& thread)\n    {\n        Process* process = thread.process();\n        MuLangContext* context = (MuLangContext*)process->context();\n\n        //\n        // Suppress annoying messages about unknown tags, etc...\n        //\n\n        TIFFSetErrorHandler(0);\n        TIFFSetWarningHandler(0);\n\n        TIFF* tif = TIFFOpen(imgFileName.c_str(), \"r\");\n\n        if (!tif)\n        {\n            const Mu::MuLangContext* context =\n                static_cast<const Mu::MuLangContext*>(thread.context());\n            ExceptionType::Exception* e =\n                new ExceptionType::Exception(context->exceptionType());\n            e->string() = \"failed to open image \\\"\";\n            e->string() += imgFileName;\n            e->string() += \"\\\"\";\n            thread.setException(e);\n            throw ProgramException(e);\n        }\n\n        uint16* sampleinfo;\n        uint16 extrasamples;\n        uint16 bps;\n\n        int width, height;\n\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n\n        im->width = width;\n        im->height = height;\n\n        TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &extrasamples,\n                              &sampleinfo);\n\n        unsigned short orient = ORIENTATION_TOPLEFT;\n        TIFFGetField(tif, TIFFTAG_ORIENTATION, &orient);\n        bool flip =\n            orient == ORIENTATION_BOTLEFT || orient == ORIENTATION_BOTRIGHT;\n        bool flop =\n            orient == ORIENTATION_BOTRIGHT || orient == ORIENTATION_TOPRIGHT;\n        flop = false;\n\n        bool hasAlpha = extrasamples == 1 ? true : false;\n\n        DynamicArrayType* dataType = static_cast<DynamicArrayType*>(\n            context->arrayType(context->vec4fType(), 1, 0));\n        im->data = new DynamicArray(dataType, 1);\n        im->data->resize(width * height);\n\n        vector<char> buf(TIFFScanlineSize(tif));\n\n        int y0 = 0;\n        int y1 = height;\n        int inc = 1;\n\n        switch (bps)\n        {\n        case 32:\n            for (int y = 0; y < height; y++)\n            {\n                int oy = flip ? (height - 1 - y) : y;\n\n                if (hasAlpha)\n                {\n                    TIFFReadScanline(tif, (float*)im->row(oy), y);\n                }\n                else\n                {\n                    TIFFReadScanline(tif, &buf[0], y);\n                    Vector4f* dstPixel = im->row(oy);\n                    Vector3f* srcPixel = reinterpret_cast<Vector3f*>(&buf[0]);\n\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel)[0] = (*srcPixel)[0];\n                        (*dstPixel)[1] = (*srcPixel)[1];\n                        (*dstPixel)[2] = (*srcPixel)[2];\n                        (*dstPixel)[3] = 1.0f;\n                    }\n                }\n\n                if (flop)\n                    reverse(im->row(oy), im->row(oy) + width);\n            }\n            break;\n\n        case 16:\n            for (int y = 0; y < height; y++)\n            {\n                int oy = flip ? (height - 1 - y) : y;\n                TIFFReadScanline(tif, &buf[0], y);\n                Vector4f* dstPixel = im->row(oy);\n\n                if (hasAlpha)\n                {\n                    Vector4s* srcPixel = reinterpret_cast<Vector4s*>(&buf[0]);\n\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel)[0] = (*srcPixel)[0] / 65535.0f;\n                        (*dstPixel)[1] = (*srcPixel)[1] / 65535.0f;\n                        (*dstPixel)[2] = (*srcPixel)[2] / 65535.0f;\n                        (*dstPixel)[3] = (*srcPixel)[3] / 65535.0f;\n                    }\n                }\n                else\n                {\n                    Vector3s* srcPixel = reinterpret_cast<Vector3s*>(&buf[0]);\n\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel)[0] = (*srcPixel)[0] / 65535.0f;\n                        (*dstPixel)[1] = (*srcPixel)[1] / 65535.0f;\n                        (*dstPixel)[2] = (*srcPixel)[2] / 65535.0f;\n                        (*dstPixel)[3] = 1.0f;\n                    }\n                }\n\n                if (flop)\n                    reverse(im->row(oy), im->row(oy) + width);\n            }\n            break;\n\n        case 8:\n\n            for (int y = 0; y < height; y++)\n            {\n                int oy = flip ? (height - 1 - y) : y;\n                TIFFReadScanline(tif, &buf[0], y);\n                Vector4f* dstPixel = im->row(oy);\n\n                if (hasAlpha)\n                {\n                    Vector4c* srcPixel = reinterpret_cast<Vector4c*>(&buf[0]);\n\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel)[0] = (*srcPixel)[0] / 255.0f;\n                        (*dstPixel)[1] = (*srcPixel)[1] / 255.0f;\n                        (*dstPixel)[2] = (*srcPixel)[2] / 255.0f;\n                        (*dstPixel)[3] = (*srcPixel)[3] / 255.0f;\n                    }\n                }\n                else\n                {\n                    Vector3c* srcPixel = reinterpret_cast<Vector3c*>(&buf[0]);\n\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel)[0] = (*srcPixel)[0] / 255.0f;\n                        (*dstPixel)[1] = (*srcPixel)[1] / 255.0f;\n                        (*dstPixel)[2] = (*srcPixel)[2] / 255.0f;\n                        (*dstPixel)[3] = 1.0f;\n                    }\n                }\n\n                if (flop)\n                    reverse(im->row(oy), im->row(oy) + width);\n            }\n            break;\n\n        default:\n\n            TIFFClose(tif);\n            {\n                width = 0;\n                const Mu::MuLangContext* context =\n                    static_cast<const Mu::MuLangContext*>(thread.context());\n                ExceptionType::Exception* e =\n                    new ExceptionType::Exception(context->exceptionType());\n                e->string() = \"Unsupported bit depth in image file \\\"\";\n                e->string() += imgFileName;\n                e->string() += \"\\\"\";\n                thread.setException(e);\n                throw ProgramException(e);\n            }\n        }\n\n        TIFFClose(tif);\n    }",
    "Img4f* TiffIff::read(const char* imgFileName, bool showWarnings)\n    {\n        if (!showWarnings)\n        {\n            // Suppress annoying messages about unknown tags, etc...\n            TIFFSetErrorHandler(0);\n            TIFFSetWarningHandler(0);\n        }\n\n        TIFF* tif = TIFFOpen(imgFileName, \"r\");\n        if (tif == NULL)\n        {\n            IffExc exc(\"Could not open specified image file for reading\");\n            throw(exc);\n        }\n\n        int width;\n        int height;\n        uint16 bitsPerSample;\n        uint16* sampleinfo;\n        uint16 extrasamples;\n\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n\n        TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &extrasamples,\n                              &sampleinfo);\n\n        bool hasAlpha = false;\n        if (extrasamples == 1)\n        {\n            hasAlpha = true;\n        }\n\n        Img4f* ret = new Img4f(width, height);\n        tdata_t buf = _TIFFmalloc(TIFFScanlineSize(tif));\n\n        switch (bitsPerSample)\n        {\n        case 32:\n            for (int y = 0; y < height; ++y)\n            {\n                if (hasAlpha)\n                {\n                    TIFFReadScanline(tif, &(ret->pixel(0, height - y - 1)), y);\n                }\n                else\n                {\n                    TIFFReadScanline(tif, buf, y);\n                    Col4f* dstPixel = (*ret)[height - y - 1];\n                    Col3f* srcPixel = (Col3f*)buf;\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel).x = srcPixel->x;\n                        (*dstPixel).y = srcPixel->y;\n                        (*dstPixel).z = srcPixel->z;\n                        (*dstPixel).w = 1.0f;\n                    }\n                }\n            }\n            break;\n        case 16:\n            for (int y = 0; y < height; ++y)\n            {\n                TIFFReadScanline(tif, buf, y);\n\n                Col4f* dstPixel = (*ret)[height - y - 1];\n                if (hasAlpha)\n                {\n                    Col4us* srcPixel = (Col4us*)buf;\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel).x = (float)srcPixel->x / 65535.0f;\n                        (*dstPixel).y = (float)srcPixel->y / 65535.0f;\n                        (*dstPixel).z = (float)srcPixel->z / 65535.0f;\n                        (*dstPixel).w = (float)srcPixel->w / 65535.0f;\n                    }\n                }\n                else\n                {\n                    Col3us* srcPixel = (Col3us*)buf;\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel).x = (float)srcPixel->x / 65535.0f;\n                        (*dstPixel).y = (float)srcPixel->y / 65535.0f;\n                        (*dstPixel).z = (float)srcPixel->z / 65535.0f;\n                        (*dstPixel).w = 1.0f;\n                    }\n                }\n            }\n            break;\n        case 8:\n            for (int y = 0; y < height; ++y)\n            {\n                TIFFReadScanline(tif, buf, y);\n\n                Col4f* dstPixel = (*ret)[height - y - 1];\n\n                if (hasAlpha)\n                {\n                    Col4uc* srcPixel = (Col4uc*)buf;\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel).x = (float)srcPixel->x / 255.0f;\n                        (*dstPixel).y = (float)srcPixel->y / 255.0f;\n                        (*dstPixel).z = (float)srcPixel->z / 255.0f;\n                        (*dstPixel).w = (float)srcPixel->w / 255.0f;\n                    }\n                }\n                else\n                {\n                    Col3uc* srcPixel = (Col3uc*)buf;\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel).x = (float)srcPixel->x / 255.0f;\n                        (*dstPixel).y = (float)srcPixel->y / 255.0f;\n                        (*dstPixel).z = (float)srcPixel->z / 255.0f;\n                        (*dstPixel).w = 1.0f;\n                    }\n                }\n            }\n            break;\n        default:\n            IffExc exc(\"Sorry, unsupported TIFF data type.\");\n            throw(exc);\n        } // End switch( bitsPerSample )\n\n        _TIFFfree(buf);\n\n        TIFFClose(tif);\n\n        return ret;\n    }",
    "Img4uc* TiffIff::read4uc(const char* imgFileName, bool showWarnings)\n    {\n        if (!showWarnings)\n        {\n            // Suppress annoying messages about unknown tags, etc...\n            TIFFSetErrorHandler(0);\n            TIFFSetWarningHandler(0);\n        }\n\n        TIFF* tif = TIFFOpen(imgFileName, \"r\");\n        if (tif == NULL)\n        {\n            IffExc exc(\"Could not open specified image file for reading\");\n            throw(exc);\n        }\n\n        int width;\n        int height;\n        uint16 bitsPerSample;\n        uint16* sampleinfo;\n        uint16 extrasamples;\n\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n\n        TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &extrasamples,\n                              &sampleinfo);\n\n        bool hasAlpha = false;\n        if (extrasamples == 1)\n        {\n            hasAlpha = true;\n        }\n\n        Img4uc* ret = new Img4uc(width, height);\n        tdata_t buf = _TIFFmalloc(TIFFScanlineSize(tif));\n\n        switch (bitsPerSample)\n        {\n        case 32:\n            for (int y = 0; y < height; ++y)\n            {\n                TIFFReadScanline(tif, buf, y);\n\n                Col4uc* dstPixel = (*ret)[height - y - 1];\n                if (hasAlpha)\n                {\n                    Col4f* srcPixel = (Col4f*)buf;\n                    (*dstPixel).x = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).x * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).y = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).y * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).z = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).z * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).w = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).w * 255.0f, 0.0f, 255.0f));\n                }\n                else\n                {\n                    Col3f* srcPixel = (Col3f*)buf;\n                    (*dstPixel).x = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).x * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).y = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).y * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).z = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).z * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).w = 255;\n                }\n            }\n            break;\n        case 16:\n            for (int y = 0; y < height; ++y)\n            {\n                TIFFReadScanline(tif, buf, y);\n\n                Col4uc* dstPixel = (*ret)[height - y - 1];\n                if (hasAlpha)\n                {\n                    Col4us* srcPixel = (Col4us*)buf;\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel).x = (unsigned char)(TwkMath::clamp(\n                            (*srcPixel).x / 255.0f, 0.0f, 255.0f));\n                        (*dstPixel).y = (unsigned char)(TwkMath::clamp(\n                            (*srcPixel).y / 255.0f, 0.0f, 255.0f));\n                        (*dstPixel).z = (unsigned char)(TwkMath::clamp(\n                            (*srcPixel).z / 255.0f, 0.0f, 255.0f));\n                        (*dstPixel).w = (unsigned char)(TwkMath::clamp(\n                            (*srcPixel).w / 255.0f, 0.0f, 255.0f));\n                    }\n                }\n                else\n                {\n                    Col3us* srcPixel = (Col3us*)buf;\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel).x = (unsigned char)(TwkMath::clamp(\n                            (*srcPixel).x / 255.0f, 0.0f, 255.0f));\n                        (*dstPixel).y = (unsigned char)(TwkMath::clamp(\n                            (*srcPixel).y / 255.0f, 0.0f, 255.0f));\n                        (*dstPixel).z = (unsigned char)(TwkMath::clamp(\n                            (*srcPixel).z / 255.0f, 0.0f, 255.0f));\n                        (*dstPixel).w = 255;\n                    }\n                }\n            }\n            break;\n        case 8:\n            for (int y = 0; y < height; ++y)\n            {\n                TIFFReadScanline(tif, buf, y);\n\n                Col4uc* dstPixel = (*ret)[height - y - 1];\n\n                if (hasAlpha)\n                {\n                    TIFFReadScanline(tif, &(ret->pixel(0, height - y - 1)), y);\n                }\n                else\n                {\n                    Col3uc* srcPixel = (Col3uc*)buf;\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel).x = srcPixel->x;\n                        (*dstPixel).y = srcPixel->y;\n                        (*dstPixel).z = srcPixel->z;\n                        (*dstPixel).w = 255;\n                    }\n                }\n            }\n            break;\n        default:\n            IffExc exc(\"Sorry, unsupported TIFF data type.\");\n            throw(exc);\n        } // End switch( bitsPerSample )\n\n        _TIFFfree(buf);\n\n        TIFFClose(tif);\n\n        return ret;\n    }",
    "cv::Mat load_tiff(std::string file,bool bgr2rgb)\n    {\n        TIFF *in = TIFFOpen(file.c_str(),\"r\");\n        if(!in)\n            throw std::runtime_error(\"Failed to open tiff file \" + file);\n        try {\n            uint32_t width,height;\n            uint16_t depth,spp,format = SAMPLEFORMAT_UINT;\n            TIFFGetField(in,TIFFTAG_IMAGEWIDTH,&width);\n            TIFFGetField(in,TIFFTAG_IMAGELENGTH,&height);\n            TIFFGetField(in,TIFFTAG_SAMPLESPERPIXEL,&spp);\n            TIFFGetField(in,TIFFTAG_BITSPERSAMPLE,&depth);\n            TIFFGetField(in,TIFFTAG_SAMPLEFORMAT,&format);\n            if(spp <= 0 || spp > 4)\n                throw std::runtime_error(\"Invalid format for \" + file);\n            int type = -1;\n            switch(depth) {\n            case 8:\n                switch(format) {\n                case SAMPLEFORMAT_INT: type = CV_MAKETYPE(CV_8S,spp);  break;\n                case SAMPLEFORMAT_UINT: type = CV_MAKETYPE(CV_8U,spp);  break;\n                }\n                break;\n            case 16:\n                switch(format) {\n                case SAMPLEFORMAT_INT: type = CV_MAKETYPE(CV_16S,spp);  break;\n                case SAMPLEFORMAT_UINT: type = CV_MAKETYPE(CV_16U,spp);  break;\n                }\n                break;\n            case 32:\n                switch(format) {\n                case SAMPLEFORMAT_INT: type = CV_MAKETYPE(CV_32S,spp);  break;\n                case SAMPLEFORMAT_IEEEFP: type = CV_MAKETYPE(CV_32F,spp);  break;\n                }\n                break;\n            case 64:\n                switch(format) {\n                case SAMPLEFORMAT_IEEEFP: type = CV_MAKETYPE(CV_64F,spp);  break;\n                }\n                break;\n            }\n            if(type == -1)\n                throw std::runtime_error(\"Unsupported tiff format \" + file + \": spp=\" + std::to_string(spp) + \" depth=\" + std::to_string(depth) + \" format=\" + std::to_string(format));\n            cv::Mat res(height,width,type);\n            if(TIFFScanlineSize(in)!=int(res.step[0])) {\n                throw std::runtime_error(\"Internal error in stride/scanline size in \" + file);\n            }\n            for(unsigned i=0;i<height;i++) {\n                if(TIFFReadScanline(in,(char*)res.data + res.step[0]*i,i,0)<0)\n                    throw std::runtime_error(\"Failed to read \" + file);\n            }\n            TIFFClose(in);\n            if(bgr2rgb) {\n                cv::Mat tmp;\n                if(res.channels() == 3) {\n                    cv::cvtColor(res,tmp,cv::COLOR_RGB2BGR);\n                    res = tmp;\n                }\n                else if(res.channels() == 4) {\n                    cv::cvtColor(res,tmp,cv::COLOR_RGBA2BGRA);\n                    res = tmp;\n                }\n            }\n            return res;\n        }\n        catch(...) {\n            TIFFClose(in);\n            throw;\n        }\n    }",
    "static osg::ImageSequence* tiffLoad(std::istream& fin, const osgDB::Options* options)\n{\n    TIFFSetErrorHandler(tiffError);\n    TIFFSetWarningHandler(tiffWarn);\n    TIFF* in = TIFFClientOpen(\"inputstream\", \"r\", (thandle_t)&fin,\n                              tiffStreamReadProc, tiffStreamWriteProc,\n                              tiffStreamSeekProc, tiffStreamCloseProc,\n                              tiffStreamSizeProc, tiffStreamMapProc, tiffStreamUnmapProc);\n    if (in == NULL) { OSG_WARN << \"[ReaderWriterTiff] Unable to open stream\" << std::endl; return NULL; }\n\n    uint16_t photometric = 0;\n    if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric) == 1)\n    {\n        if (photometric != PHOTOMETRIC_RGB && photometric != PHOTOMETRIC_PALETTE &&\n            photometric != PHOTOMETRIC_MINISWHITE && photometric != PHOTOMETRIC_MINISBLACK)\n        {\n            OSG_WARN << \"[ReaderWriterTiff] Photometric type \" << photometric << \" not handled\" << std::endl;\n            TIFFClose(in); return NULL;\n        }\n    }\n    else\n    {\n        OSG_WARN << \"[ReaderWriterTiff] Unable to get photometric type\" << std::endl;\n        TIFFClose(in); return NULL;\n    }\n\n    uint16_t samplesperpixel = 0;\n    if (TIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel) == 1)\n    {\n        if (samplesperpixel != 1 && samplesperpixel != 2 &&\n            samplesperpixel != 3 && samplesperpixel != 4)\n        {\n            OSG_WARN << \"[ReaderWriterTiff] Bad samples per pixel: \" << samplesperpixel << std::endl;\n            TIFFClose(in); return NULL;\n        }\n    }\n    else\n    {\n        OSG_WARN << \"[ReaderWriterTiff] Unable to get samples per pixel\" << std::endl;\n        TIFFClose(in); return NULL;\n    }\n\n    uint16_t bitspersample = 0;\n    if (TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample) == 1)\n    {\n        if (bitspersample != 8 && bitspersample != 16 && bitspersample != 32)\n        {\n            OSG_WARN << \"[ReaderWriterTiff] Can only handle 8, 16 and 32 bit samples\" << std::endl;\n            TIFFClose(in); return NULL;\n        }\n    }\n    else\n    {\n        OSG_WARN << \"[ReaderWriterTiff] Unable to get bits per sample\" << std::endl;\n        TIFFClose(in); return NULL;\n    }\n\n    uint32_t w = 0, h = 0, d = 1; uint16_t config = 0, dataType = 0;\n    if (TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w) != 1 || TIFFGetField(in, TIFFTAG_IMAGELENGTH, &h) != 1 ||\n        TIFFGetField(in, TIFFTAG_PLANARCONFIG, &config) != 1)\n    {\n        OSG_WARN << \"[ReaderWriterTiff] Unable to get width / height / depth parameters\" << std::endl;\n        TIFFClose(in); return NULL;\n    }\n\n    // if it has a palette, data returned is 3 byte rgb\n    int format = (photometric == PHOTOMETRIC_PALETTE) ? 3 : (samplesperpixel * bitspersample / 8);\n    int bytespersample = bitspersample / 8;\n    int bytesperpixel = bytespersample * samplesperpixel;\n    TIFFGetField(in, TIFFTAG_DATATYPE, &dataType);\n    TIFFGetField(in, TIFFTAG_IMAGEDEPTH, &d);\n\n    osg::ref_ptr<osg::ImageSequence> seq = new osg::ImageSequence;\n    if (d > 1)\n    {\n        // TODO...\n        OSG_WARN << \"[ReaderWriterTiff] Unsupported dimension\" << std::endl;\n    }\n    else\n    {\n        int dirCount = 0, imgSize = w * h * format;\n        do\n        {\n            unsigned char* inBuffer = NULL; bool hasError = false;\n            unsigned char* buffer = new unsigned char[imgSize];\n            memset(buffer, 0, imgSize); dirCount++;\n\n            unsigned char* currPtr = buffer + (h - 1) * w * format;\n            uint16_t *red = NULL, *green = NULL, *blue = NULL;\n            size_t rowSize = TIFFScanlineSize(in);\n            switch (PACK(photometric, config))\n            {\n            case PACK(PHOTOMETRIC_MINISWHITE, PLANARCONFIG_CONTIG):\n            case PACK(PHOTOMETRIC_MINISBLACK, PLANARCONFIG_CONTIG):\n            case PACK(PHOTOMETRIC_MINISWHITE, PLANARCONFIG_SEPARATE):\n            case PACK(PHOTOMETRIC_MINISBLACK, PLANARCONFIG_SEPARATE):\n                inBuffer = new unsigned char[rowSize];\n                for (uint32_t row = 0; row < h; row++)\n                {\n                    if (TIFFReadScanline(in, inBuffer, row, 0) < 0) { hasError = true; break; }\n                    invertRow(currPtr, inBuffer, samplesperpixel * w,\n                              photometric == PHOTOMETRIC_MINISWHITE, bitspersample);\n                    currPtr -= format * w;\n                }\n                break;\n\n            case PACK(PHOTOMETRIC_PALETTE, PLANARCONFIG_CONTIG):\n            case PACK(PHOTOMETRIC_PALETTE, PLANARCONFIG_SEPARATE):\n                if (TIFFGetField(in, TIFFTAG_COLORMAP, &red, &green, &blue) != 1)\n                { hasError = true; break; }\n                else if (!hasError && bitspersample != 32 && checkColormap(1<<bitspersample, red, green, blue) == 16)\n                {\n                    for (int i = (1 << bitspersample) - 1; i >= 0; --i)\n                    { red[i] = CVT(red[i]); green[i] = CVT(green[i]); blue[i] = CVT(blue[i]); }\n                }\n\n                inBuffer = new unsigned char[rowSize];\n                for (uint32_t row = 0; row < h; row++)\n                {\n                    if (TIFFReadScanline(in, inBuffer, row, 0) < 0) { hasError = true; break; }\n                    remapRow(currPtr, inBuffer, w, red, green, blue); currPtr -= format * w;\n                }\n                break;\n\n            case PACK(PHOTOMETRIC_RGB, PLANARCONFIG_CONTIG):\n                inBuffer = new unsigned char[rowSize];\n                for (uint32_t row = 0; row < h; row++)\n                {\n                    if (TIFFReadScanline(in, inBuffer, row, 0) < 0) { hasError = true; break; }\n                    memcpy(currPtr, inBuffer, format * w); currPtr -= format * w;\n                }\n                break;\n\n            case PACK(PHOTOMETRIC_RGB, PLANARCONFIG_SEPARATE):\n                inBuffer = new unsigned char[format * rowSize];\n                for (uint32_t row = 0; !hasError && row < h; row++)\n                {\n                    for (int s = 0; s < format; s++)\n                    {\n                        if (TIFFReadScanline(in, (tdata_t)(inBuffer + s * rowSize), (uint32_t)row, (tsample_t)s) < 0)\n                        { hasError = true; break; }\n                    }\n\n                    if (!hasError)\n                    {\n                        unsigned char *inBuffer2 = inBuffer + rowSize, *inBuffer3 = inBuffer + 2 * rowSize,\n                                      *inBuffer4 = inBuffer + 3 * rowSize;\n                        if (format == 4) interleaveRow(currPtr, inBuffer, inBuffer2, inBuffer3, inBuffer4, w, format, bitspersample);\n                        else if (format == 3) interleaveRow(currPtr, inBuffer, inBuffer2, inBuffer3, w, format, bitspersample);\n                        currPtr -= format * w;\n                    }\n                }\n                break;\n            default:\n                OSG_WARN << \"[ReaderWriterTiff] Unsupported Packing: \" << photometric << \", \" << config << std::endl;\n                hasError = true; break;\n            }\n\n            if (inBuffer) delete[] inBuffer;\n            if (hasError)\n            {\n                OSG_WARN << \"[ReaderWriterTiff] Failed to read with packing: \" << photometric << \", \" << config << std::endl;\n                if (buffer) delete[] buffer; continue;\n            }\n\n            int numComponents = (photometric == PHOTOMETRIC_PALETTE) ? format : samplesperpixel;\n            unsigned int pixelFormat =\n                (numComponents) == 1 ? GL_LUMINANCE :\n                (numComponents) == 2 ? GL_LUMINANCE_ALPHA :\n                (numComponents) == 3 ? GL_RGB :\n                (numComponents) == 4 ? GL_RGBA : (GLenum)-1;\n            unsigned int dataType =\n                (bitspersample == 8) ? GL_UNSIGNED_BYTE :\n                (bitspersample == 16) ? GL_UNSIGNED_SHORT :\n                (bitspersample == 32) ? GL_FLOAT : (GLenum)-1;\n            unsigned int internalFormat = computeInternalFormat(pixelFormat, dataType);\n            if (internalFormat <= 0)\n            {\n                OSG_WARN << \"[ReaderWriterTiff] Unsupported image format\" << std::endl;\n                continue;\n            }\n\n            osg::Image* image = new osg::Image;\n            image->setImage(w, h, d, internalFormat, pixelFormat, dataType,\n                            buffer, osg::Image::USE_NEW_DELETE);\n            seq->addImage(image);\n        } while (TIFFReadDirectory(in));\n    }\n    TIFFClose(in);\n    return seq.release();\n}",
    "void PdfImage::loadFromTiffHandle(void* handle, unsigned imageIndex)\n{\n    TIFF* hInTiffHandle = (TIFF*)handle;\n\n    int32_t row, width, height;\n    uint16_t samplesPerPixel, bitsPerSample;\n    uint16_t* sampleInfo;\n    uint16_t extraSamples;\n    uint16_t planarConfig, photoMetric, orientation;\n    int32_t resolutionUnit;\n\n    // Set the page/image index in the tiff context\n    TIFFSetDirectory(hInTiffHandle, (uint16_t)imageIndex);\n\n    TIFFGetField(hInTiffHandle, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(hInTiffHandle, TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_PLANARCONFIG, &planarConfig);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_PHOTOMETRIC, &photoMetric);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_EXTRASAMPLES, &extraSamples, &sampleInfo);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_ORIENTATION, &orientation);\n\n    resolutionUnit = 0;\n    float resX;\n    float resY;\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_XRESOLUTION, &resX);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_YRESOLUTION, &resY);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_RESOLUTIONUNIT, &resolutionUnit);\n\n    int colorChannels = samplesPerPixel - extraSamples;\n\n    int bitsPixel = bitsPerSample * samplesPerPixel;\n\n    // TODO: implement special cases\n    if (TIFFIsTiled(hInTiffHandle))\n        PODOFO_RAISE_ERROR(PdfErrorCode::UnsupportedImageFormat);\n\n    if (planarConfig != PLANARCONFIG_CONTIG && colorChannels != 1)\n        PODOFO_RAISE_ERROR(PdfErrorCode::UnsupportedImageFormat);\n\n    PdfImageInfo info;\n    info.Width = width;\n    info.Height = height;\n    info.BitsPerComponent = (unsigned char)bitsPerSample;\n    switch (photoMetric)\n    {\n        case PHOTOMETRIC_MINISBLACK:\n        {\n            if (bitsPixel == 1)\n            {\n                info.DecodeArray.push_back(0);\n                info.DecodeArray.push_back(1);\n                info.ColorSpace = PdfColorSpaceFilterFactory::GetDeviceGrayInstace();\n            }\n            else if (bitsPixel == 8 || bitsPixel == 16)\n            {\n                info.ColorSpace = PdfColorSpaceFilterFactory::GetDeviceGrayInstace();\n            }\n            else\n            {\n                PODOFO_RAISE_ERROR(PdfErrorCode::UnsupportedImageFormat);\n            }\n            break;\n        }\n        case PHOTOMETRIC_MINISWHITE:\n        {\n            if (bitsPixel == 1)\n            {\n                info.DecodeArray.push_back(1);\n                info.DecodeArray.push_back(0);\n                info.ColorSpace = PdfColorSpaceFilterFactory::GetDeviceGrayInstace();\n            }\n            else if (bitsPixel == 8 || bitsPixel == 16)\n            {\n                info.ColorSpace = PdfColorSpaceFilterFactory::GetDeviceGrayInstace();\n            }\n            else\n            {\n                PODOFO_RAISE_ERROR(PdfErrorCode::UnsupportedImageFormat);\n            }\n            break;\n        }\n        case PHOTOMETRIC_RGB:\n        {\n            if (bitsPixel != 24)\n                PODOFO_RAISE_ERROR(PdfErrorCode::UnsupportedImageFormat);\n\n            info.ColorSpace = PdfColorSpaceFilterFactory::GetDeviceRGBInstace();\n            break;\n        }\n        case PHOTOMETRIC_SEPARATED:\n        {\n            if (bitsPixel != 32)\n                PODOFO_RAISE_ERROR(PdfErrorCode::UnsupportedImageFormat);\n\n            info.ColorSpace = PdfColorSpaceFilterFactory::GetDeviceCMYKInstace();\n            break;\n        }\n        case PHOTOMETRIC_PALETTE:\n        {\n            unsigned numColors = (1 << bitsPixel);\n            info.DecodeArray.push_back(0);\n            info.DecodeArray.push_back(numColors - 1);\n\n            uint16_t* rgbRed;\n            uint16_t* rgbGreen;\n            uint16_t* rgbBlue;\n            TIFFGetField(hInTiffHandle, TIFFTAG_COLORMAP, &rgbRed, &rgbGreen, &rgbBlue);\n\n            charbuff data(numColors * 3);\n\n            for (unsigned clr = 0; clr < numColors; clr++)\n            {\n                data[3 * clr + 0] = (char)(rgbRed[clr] / 257);\n                data[3 * clr + 1] = (char)(rgbGreen[clr] / 257);\n                data[3 * clr + 2] = (char)(rgbBlue[clr] / 257);\n            }\n\n            // Create a colorspace object\n            auto& idxObj = this->GetDocument().GetObjects().CreateDictionaryObject();\n            idxObj.GetOrCreateStream().SetData(data);\n\n            // Add the colorspace to our image\n            info.ColorSpace = PdfColorSpaceInitializer(std::make_shared<PdfColorSpaceFilterIndexed>(\n                PdfColorSpaceInitializer(PdfColorSpaceFilterFactory::GetDeviceRGBInstace()), numColors, std::move(data)));\n            break;\n        }\n\n        default:\n        {\n            PODOFO_RAISE_ERROR(PdfErrorCode::UnsupportedImageFormat);\n            break;\n        }\n    }\n\n    size_t scanlineSize = TIFFScanlineSize(hInTiffHandle);\n    size_t bufferSize = scanlineSize * height;\n    charbuff buffer(bufferSize);\n    for (row = 0; row < height; row++)\n    {\n        if (TIFFReadScanline(hInTiffHandle,\n            &buffer[row * scanlineSize],\n            row) == (-1))\n        {\n            PODOFO_RAISE_ERROR(PdfErrorCode::UnsupportedImageFormat);\n        }\n    }\n\n    SpanStreamDevice input(buffer);\n    SetDataRaw(input, info);\n}",
    "void tiffDecode(PointerRange<const char> inBuffer, ImageImpl *impl)\n\t{\n\t\tTIFF *t = nullptr;\n\t\ttry\n\t\t{\n\t\t\tBufferIStream stream(inBuffer);\n\t\t\tt = TIFFStreamOpen(\"MemTIFF\", &stream);\n\t\t\tif (!t)\n\t\t\t\tCAGE_THROW_ERROR(Exception, \"failed to initialize tiff decoding\");\n\t\t\t{\n\t\t\t\tuint16 planarconfig = 0;\n\t\t\t\tTIFFGetField(t, TIFFTAG_PLANARCONFIG, &planarconfig);\n\t\t\t\tif (planarconfig != PLANARCONFIG_CONTIG)\n\t\t\t\t\tCAGE_THROW_ERROR(Exception, \"unsupported planar configuration in tiff decoding\");\n\t\t\t}\n\t\t\tTIFFGetField(t, TIFFTAG_IMAGEWIDTH, &impl->width);\n\t\t\tTIFFGetField(t, TIFFTAG_IMAGELENGTH, &impl->height);\n\t\t\t{\n\t\t\t\tuint16 ch = 0;\n\t\t\t\tTIFFGetField(t, TIFFTAG_SAMPLESPERPIXEL, &ch);\n\t\t\t\timpl->channels = ch;\n\t\t\t}\n\t\t\t{\n\t\t\t\tuint16 bpp = 0;\n\t\t\t\tTIFFGetField(t, TIFFTAG_BITSPERSAMPLE, &bpp);\n\t\t\t\tuint16 sampleformat = 0;\n\t\t\t\tTIFFGetField(t, TIFFTAG_SAMPLEFORMAT, &sampleformat);\n\t\t\t\tif (sampleformat == 0)\n\t\t\t\t\tsampleformat = SAMPLEFORMAT_UINT;\n\t\t\t\tif (bpp == 8 && sampleformat == SAMPLEFORMAT_UINT)\n\t\t\t\t\timpl->format = ImageFormatEnum::U8;\n\t\t\t\telse if (bpp == 16 && sampleformat == SAMPLEFORMAT_UINT)\n\t\t\t\t\timpl->format = ImageFormatEnum::U16;\n\t\t\t\telse if (bpp == 32 && sampleformat == SAMPLEFORMAT_IEEEFP)\n\t\t\t\t\timpl->format = ImageFormatEnum::Float;\n\t\t\t\telse\n\t\t\t\t\tCAGE_THROW_ERROR(Exception, \"unsupported format in tiff decoding\");\n\t\t\t}\n\t\t\tconst uint32 stride = numeric_cast<uint32>(TIFFScanlineSize(t));\n\t\t\tCAGE_ASSERT(stride == impl->width * impl->channels * formatBytes(impl->format));\n\t\t\timpl->mem.resize(impl->height * stride);\n\t\t\tfor (uint32 row = 0; row < impl->height; row++)\n\t\t\t{\n\t\t\t\tchar *dst = impl->mem.data() + row * stride;\n\t\t\t\tif (TIFFReadScanline(t, dst, row) < 0)\n\t\t\t\t\tCAGE_THROW_ERROR(Exception, \"failed scanline reading in tiff decoding\");\n\t\t\t}\n\t\t\tTIFFClose(t);\n\n\t\t\t// color config\n\t\t\t// todo deduce it from the file\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t\tif (t)\n\t\t\t\tTIFFClose(t);\n\t\t\tthrow;\n\t\t}\n\t}",
    "void texture_t::load_tiff(int index, bool allow_diff_width_height, bool allow_two_byte_grayscale) {\n\n#ifdef ENABLE_TIFF\n\tTIFF* tif = TIFFOpen(append_texture_dir(name).c_str(), \"r\"); // first try texture directory\n\tif (tif == NULL) {tif = TIFFOpen(name.c_str(), \"r\");} // not found, try current directory\n\n\tif (tif == NULL) {\n\t\tcerr << \"Error opening tiff file \" << name << \" for read.\" << endl;\n\t\texit(1);\n\t}\n\tuint32_t w(0), h(0);\n\tuint16_t bit_depth(0), config(0);\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH,    &w);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH,   &h);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bit_depth);\n\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG,  &config);\n\tset_image_size(w, h, allow_diff_width_height);\n\t\n\tif (allow_two_byte_grayscale && (ncolors == 0 || ncolors == 1) && bit_depth == 16) { // 16-bit grayscale\n\t\tset_16_bit_grayscale();\n\t\ttmsize_t const sl_size(TIFFScanlineSize(tif));\n\t\tassert(sl_size == 2*width);\n        tdata_t buf = _TIFFmalloc(sl_size);\n\t\tassert(buf);\n\t\talloc();\n\t\tassert(config == PLANARCONFIG_CONTIG); // no support for PLANARCONFIG_SEPARATE, but could be added later\n\n\t\tfor (int row = 0; row < height; row++) {\n\t\t\tTIFFReadScanline(tif, buf, row);\n\n\t\t\tfor (int i = 0; i < sl_size; ++i) { // x-values\n\t\t\t\tdata[sl_size*(height - row - 1) + i] = ((unsigned char const *)buf)[i]; // assumes little endian byte ordering, no swap required, may need to check this?\n\t\t\t}\n\t\t}\n        _TIFFfree(buf);\n\t}\n\telse {\n\t\tif (ncolors == 0) {ncolors = 4;} // 3?\n\t\tuint32_t *raster = (uint32_t *)_TIFFmalloc(num_pixels() * sizeof(uint32_t));\n\t\tassert(raster != NULL);\n\n\t\tif (!TIFFReadRGBAImage(tif, width, height, raster, 0)) {\n\t\t\tcerr << \"Error reading data from tiff file \" << name << \".\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\talloc();\n\n\t\tfor (int y = 0; y < height; ++y) {\n\t\t\tfor (int x = 0; x < width; ++x) {\n\t\t\t\tunsigned const ix(y*width + x);\n\t\t\t\tunsigned char const *d((unsigned char const *)(raster + ix));\n\t\t\t\tfor (int i = 0; i < ncolors; ++i) {data[ncolors*ix+i] = d[i];} // not correct for lum+alpha textures?\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(raster);\n\t}\n\tTIFFClose(tif);\n#else\n\tcerr << \"Error loading texture image file \" << name << \": tiff support has not been enabled.\" << endl;\n\texit(1);\n#endif\n}",
    "void Tiffload::Open() throw(invalid_argument, runtime_error)\n{\n\t// have we already opened the image?\n\tif (buffer != NULL) {\n\t\treturn;\n\t}\n\t\n  TIFF* image;\n  if ((image = TIFFOpen(filename.c_str(), \"r\")) == NULL) {\n    throw invalid_argument(\"Could not open image!\");\n  }\n  \n  TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &depth);\n  depth = (2 << (depth - 1)) - 1;\n  \n/*  uint16 spp;\n  if ((TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &spp) == 0) || (spp != 1)) {\n    throw invalid_argument(\"Either undefined or unsupported number of samples per pixel\");\n  }*/\n    \n  tsize_t stripSize = TIFFStripSize(image);\n  int stripMax = TIFFNumberOfStrips(image);\n  unsigned long imageOffset = 0;\n  \n  unsigned long bufferSize = stripMax * stripSize;\n  try {\n    buffer = new unsigned char[bufferSize];\n  } catch (bad_alloc&) {\n    throw runtime_error(\"Failure to allocate storage for tiff image\");\n  }\n  \n  for (int stripCount = 0; stripCount < stripMax; ++stripCount) {\n    long result = TIFFReadEncodedStrip(image, stripCount, buffer + imageOffset, stripSize);\n\tif (result == -1) {\n\t  throw invalid_argument(\"Read error for tiff image\");\n\t}\n    imageOffset += result;\n  }\n  \n  // find the number of rows and number of columns\n  if (TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &cols) == 0) {\n    throw invalid_argument(\"Tiff image does not define its width\");\n  }\n  if (TIFFGetField(image, TIFFTAG_IMAGELENGTH, &rows) == 0) {\n    throw invalid_argument(\"Tiff image does not define its length\");\n  }\n\n  TIFFClose(image);\n}",
    "std::unique_ptr<VistaTexture> TextureLoader::loadFromFile(std::string const& sFileName) {\n\n  std::string suffix = sFileName.substr(sFileName.rfind('.'));\n\n  if (suffix == \".tga\") {\n    // load with vista\n    logger().debug(\"Loading Texture '{}' with Vista.\", sFileName);\n    return std::unique_ptr<VistaTexture>(VistaOGLUtils::LoadTextureFromTga(sFileName));\n  }\n\n  std::unique_ptr<VistaTexture> result = std::make_unique<VistaTexture>(GL_TEXTURE_2D);\n\n  if (suffix == \".tiff\" || suffix == \".tif\") {\n    // load with tifflib\n    logger().debug(\"Loading Texture '{}' with libtiff.\", sFileName);\n\n    auto* data = TIFFOpen(sFileName.c_str(), \"r\");\n    if (!data) {\n      logger().error(\"Failed to load '{}' with libtiff!\", sFileName);\n      return nullptr;\n    }\n\n    uint32 width{};\n    uint32 height{};\n    TIFFGetField(data, TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetField(data, TIFFTAG_IMAGEWIDTH, &width);\n\n    uint16 bpp{};\n    TIFFGetField(data, TIFFTAG_BITSPERSAMPLE, &bpp);\n\n    int16 channels{};\n    TIFFGetField(data, TIFFTAG_SAMPLESPERPIXEL, &channels);\n\n    GLenum ePixelFormat = GL_RGBA;\n\n    if (channels == 1) {\n      ePixelFormat = GL_RED;\n    } else if (channels == 2) {\n      ePixelFormat = GL_RG;\n    } else if (channels == 3) {\n      ePixelFormat = GL_RGB;\n    }\n\n    if (bpp != 8 && bpp != 32) {\n      logger().error(\n          \"Failed to load '{}' with libtiff: Only 8 or 32 bit per sample are supported right now!\",\n          sFileName);\n      return nullptr;\n    }\n\n    if (bpp == 32) {\n\n      std::vector<float> pixels(width * height * channels);\n\n      for (unsigned y = 0; y < height; y++) {\n        TIFFReadScanline(data, &pixels[width * channels * y], y);\n      }\n\n      result->Bind();\n      glTexImage2D(\n          GL_TEXTURE_2D, 0, GL_RGB32F, width, height, 0, ePixelFormat, GL_FLOAT, pixels.data());\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\n    } else {\n\n      std::vector<char> pixels(width * height * channels);\n\n      for (unsigned y = 0; y < height; y++) {\n        TIFFReadScanline(data, &pixels[width * channels * y], y);\n      }\n\n      result->UploadTexture(width, height, pixels.data(), true, ePixelFormat);\n    }\n\n    TIFFClose(data);\n\n  } else if (suffix == \".hdr\") {\n\n    // load with stb image\n    logger().debug(\"Loading HDR Texture '{}' with stbi.\", sFileName);\n\n    int width{};\n    int height{};\n    int bpp{};\n    int channels = 4;\n\n    float* pixels = stbi_loadf(sFileName.c_str(), &width, &height, &bpp, channels);\n\n    if (!pixels) {\n      logger().error(\"Failed to load '{}' with stbi!\", sFileName);\n      return nullptr;\n    }\n\n    result->Bind();\n    gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA32F, width, height, GL_RGBA, GL_FLOAT, pixels);\n\n    stbi_image_free(pixels);\n\n  } else {\n    // load with stb image\n    logger().debug(\"Loading Texture '{}' with stbi.\", sFileName);\n\n    int width{};\n    int height{};\n    int bpp{};\n    int channels = 4;\n\n    unsigned char* pixels = stbi_load(sFileName.c_str(), &width, &height, &bpp, channels);\n\n    if (!pixels) {\n      logger().error(\"Failed to load '{}' with stbi!\", sFileName);\n      return nullptr;\n    }\n\n    result->UploadTexture(width, height, pixels);\n\n    stbi_image_free(pixels);\n  }\n\n  return result;\n}",
    "std::tuple<GLuint, glm::ivec2> read2DTexture(std::string const& path) {\n  auto* data = TIFFOpen(path.c_str(), \"r\");\n\n  if (!data) {\n    logger().error(\"Failed to open TIFF file '{}'\", path);\n    return {0u, {0, 0}};\n  }\n\n  uint32_t width{};\n  uint32_t height{};\n\n  TIFFGetField(data, TIFFTAG_IMAGELENGTH, &height);\n  TIFFGetField(data, TIFFTAG_IMAGEWIDTH, &width);\n\n  std::vector<float> pixels(width * height * 3);\n\n  for (unsigned y = 0; y < height; y++) {\n    TIFFReadScanline(data, &pixels[width * 3 * y], y);\n  }\n\n  TIFFClose(data);\n\n  GLuint texture;\n  glGenTextures(1, &texture);\n  glActiveTexture(GL_TEXTURE0);\n  glBindTexture(GL_TEXTURE_2D, texture);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n  glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);\n  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB32F, width, height, 0, GL_RGB, GL_FLOAT, pixels.data());\n\n  return {texture, {width, height}};\n}",
    "std::tuple<GLuint, glm::ivec3> read3DTexture(std::string const& path) {\n  auto* data = TIFFOpen(path.c_str(), \"r\");\n\n  if (!data) {\n    logger().error(\"Failed to open TIFF file '{}'\", path);\n    return {0u, {0, 0, 0}};\n  }\n\n  uint32_t width{};\n  uint32_t height{};\n  uint32_t depth{};\n\n  TIFFGetField(data, TIFFTAG_IMAGELENGTH, &height);\n  TIFFGetField(data, TIFFTAG_IMAGEWIDTH, &width);\n\n  do {\n    depth++;\n  } while (TIFFReadDirectory(data));\n\n  std::vector<float> pixels(width * height * depth * 3);\n\n  for (unsigned z = 0; z < depth; z++) {\n    TIFFSetDirectory(data, z);\n    for (unsigned y = 0; y < height; y++) {\n      TIFFReadScanline(data, &pixels[width * 3 * y + (3 * width * height * z)], y);\n    }\n  }\n\n  TIFFClose(data);\n\n  GLuint texture;\n  glGenTextures(1, &texture);\n  glActiveTexture(GL_TEXTURE0);\n  glBindTexture(GL_TEXTURE_3D, texture);\n  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\n  glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);\n  glTexImage3D(\n      GL_TEXTURE_3D, 0, GL_RGB32F, width, height, depth, 0, GL_RGB, GL_FLOAT, pixels.data());\n\n  return {texture, {width, height, depth}};\n}",
    "RGBATexture read2DTexture(std::string const& path, uint32_t layer) {\n  RGBATexture texture;\n\n  auto* data = TIFFOpen(path.c_str(), \"r\");\n\n  if (!data) {\n    std::cerr << \"Failed to open TIFF file '\" << path << \"'\" << std::endl;\n    return texture;\n  }\n\n  TIFFGetField(data, TIFFTAG_IMAGELENGTH, &texture.height);\n  TIFFGetField(data, TIFFTAG_IMAGEWIDTH, &texture.width);\n\n  std::vector<float> rgbData(texture.width * texture.height * 3);\n\n  TIFFSetDirectory(data, layer);\n  for (unsigned y = 0; y < texture.height; y++) {\n    TIFFReadScanline(data, &rgbData[texture.width * 3 * y], y);\n  }\n\n  TIFFClose(data);\n\n  texture.data = addAlphaChannel(rgbData);\n\n  return texture;\n}",
    "bool loadImpl(TileSourceWebMapService* source, BaseTileData* tile, TileId const& tileId, int x,\n    int y, CopyPixels which) {\n  std::optional<std::string> cacheFile;\n\n  // First we download the tile data to a local cache file. This will return quickly if the file is\n  // already downloaded but will take some time if it needs to be fetched from the server.\n  try {\n    cacheFile = source->loadData(tileId, x, y);\n  } catch (std::exception const& e) {\n    // This is not critical, the planet will just not refine any further.\n    logger().debug(\"Tile loading failed: {}\", e.what());\n    return false;\n  }\n\n  // Data is not available. That's most likely due to our server being offline.\n  if (!cacheFile) {\n    return false;\n  }\n\n  T* tileData = tile->getTypedPtr<T>();\n\n  // Now the cache file is available, try to load it with libtiff if it's elevation data.\n  if (tile->getDataType() == TileDataType::eElevation) {\n    TIFFSetWarningHandler(nullptr);\n    auto* data = TIFFOpen(cacheFile->c_str(), \"r\");\n    if (!data) {\n\n      // This is also not critical. Something went wrong - we will just remove the cache file and\n      // will try to download it later again if it's requested once more.\n      logger().debug(\"Tile loading failed: Removing invalid cache file '{}'.\", *cacheFile);\n      boost::filesystem::remove(*cacheFile);\n      return false;\n    }\n\n    uint32_t resolution = tile->getResolution();\n\n    // The elevation data can be read. For some patches (those at the international date boundary)\n    // two requests are made. For those, only half of the pixels contain valid data (above or below\n    // the diagonal).\n    int imagelength{};\n    if (TIFFGetField(data, TIFFTAG_IMAGELENGTH, &imagelength) == 0) {\n      logger().debug(\"TIFFGetField failed: Removing invalid cache file '{}'.\", *cacheFile);\n      boost::filesystem::remove(*cacheFile);\n      return false;\n    }\n    int tiffReturn{};\n    for (int y = 0; y < imagelength; y++) {\n      if (which == CopyPixels::eAll) {\n        tiffReturn = TIFFReadScanline(data, &tileData[resolution * y], y);\n      } else if (which == CopyPixels::eAboveDiagonal) {\n        std::vector<float> tmp(resolution);\n        tiffReturn = TIFFReadScanline(data, tmp.data(), y);\n        int offset = resolution * y;\n        int count  = resolution - y - 1;\n\n        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic)\n        std::memcpy(tileData + offset, tmp.data(), count * sizeof(float));\n      } else if (which == CopyPixels::eBelowDiagonal) {\n        std::vector<float> tmp(resolution);\n        tiffReturn = TIFFReadScanline(data, tmp.data(), y);\n        int offset = resolution * y + (resolution - y);\n        int count  = y;\n\n        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic)\n        std::memcpy(tileData + offset, tmp.data() + resolution - y, count * sizeof(float));\n      }\n    }\n    if (tiffReturn == -1) {\n      logger().debug(\"TIFFReadScanline failed: Removing invalid cache file '{}'.\", *cacheFile);\n      boost::filesystem::remove(*cacheFile);\n      return false;\n    }\n\n    TIFFClose(data);\n  } else {\n\n    // Image tiles are loaded with stbi.\n    int width{};\n    int height{};\n    int bpp{};\n    int channels = 4;\n\n    auto* data =\n        reinterpret_cast<T*>(stbi_load(cacheFile->c_str(), &width, &height, &bpp, channels));\n\n    if (!data) {\n\n      // This is also not critical. Something went wrong - we will just remove the cache file and\n      // will try to download it later again if it's requested once more.\n      logger().debug(\"Tile loading failed: Removing invalid cache file '{}'.\", *cacheFile);\n      boost::filesystem::remove(*cacheFile);\n      return false;\n    }\n\n    // The image data can be read. For some patches (those at the international date boundary)\n    // two requests are made. For those, only half of the pixels contain valid data (above or below\n    // the diagonal).\n    if (which == CopyPixels::eAll) {\n      std::memcpy(tileData, data, channels * width * height);\n    } else if (which == CopyPixels::eAboveDiagonal) {\n      for (int y = 0; y < height; ++y) {\n        int offset = width * y;\n        int count  = channels * (width - y - 1);\n\n        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic)\n        std::memcpy(tileData + offset, data + offset, count);\n      }\n    } else if (which == CopyPixels::eBelowDiagonal) {\n      for (int y = 0; y < height; ++y) {\n        int offset = width * y + (width - y);\n        int count  = channels * y;\n\n        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic)\n        std::memcpy(tileData + offset, data + offset, count);\n      }\n    }\n\n    stbi_image_free(data);\n  }\n\n  return true;\n}",
    "bool QTiffHandler::read(QImage *image)\n{\n    if (!canRead())\n        return false;\n\n    TIFF *const tiff = TIFFClientOpen(\"foo\",\n                                      \"r\",\n                                      this,\n                                      qtiffReadProc,\n                                      qtiffWriteProc,\n                                      qtiffSeekProc,\n                                      qtiffCloseProc,\n                                      qtiffSizeProc,\n                                      qtiffMapProc,\n                                      qtiffUnmapProc);\n\n    if (!tiff) {\n        return false;\n    }\n    uint32 width;\n    uint32 height;\n    uint16 photometric;\n    if (!TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width)\n        || !TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height)\n        || !TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &photometric)) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    uint16 bitPerSample;\n    if (!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitPerSample)) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    bool grayscale = photometric == PHOTOMETRIC_MINISBLACK || photometric == PHOTOMETRIC_MINISWHITE;\n    if (grayscale && bitPerSample == 1) {\n        if (image->size() != QSize(width, height) || image->format() != QImage::Format_Mono)\n            *image = QImage(width, height, QImage::Format_Mono);\n        QVector<QRgb> colortable(2);\n        if (photometric == PHOTOMETRIC_MINISBLACK) {\n            colortable[0] = 0xff000000;\n            colortable[1] = 0xffffffff;\n        } else {\n            colortable[0] = 0xffffffff;\n            colortable[1] = 0xff000000;\n        }\n        image->setColorTable(colortable);\n\n        if (!image->isNull()) {\n            for (uint32 y=0; y<height; ++y) {\n                if (TIFFReadScanline(tiff, image->scanLine(y), y, 0) < 0) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n            }\n        }\n    } else {\n        if ((grayscale || photometric == PHOTOMETRIC_PALETTE) && bitPerSample == 8) {\n            if (image->size() != QSize(width, height) || image->format() != QImage::Format_Indexed8)\n                *image = QImage(width, height, QImage::Format_Indexed8);\n            if (!image->isNull()) {\n                const uint16 tableSize = 256;\n                QVector<QRgb> qtColorTable(tableSize);\n                if (grayscale) {\n                    for (int i = 0; i<tableSize; ++i) {\n                        const int c = (photometric == PHOTOMETRIC_MINISBLACK) ? i : (255 - i);\n                        qtColorTable[i] = qRgb(c, c, c);\n                    }\n                } else {\n                    // create the color table\n                    uint16 *redTable = static_cast<uint16 *>(qMalloc(tableSize * sizeof(uint16)));\n                    uint16 *greenTable = static_cast<uint16 *>(qMalloc(tableSize * sizeof(uint16)));\n                    uint16 *blueTable = static_cast<uint16 *>(qMalloc(tableSize * sizeof(uint16)));\n                    if (!redTable || !greenTable || !blueTable) {\n                        TIFFClose(tiff);\n                        return false;\n                    }\n                    if (!TIFFGetField(tiff, TIFFTAG_COLORMAP, &redTable, &greenTable, &blueTable)) {\n                        TIFFClose(tiff);\n                        return false;\n                    }\n\n                    for (int i = 0; i<tableSize ;++i) {\n                        const int red = redTable[i] / 257;\n                        const int green = greenTable[i] / 257;\n                        const int blue = blueTable[i] / 257;\n                        qtColorTable[i] = qRgb(red, green, blue);\n                    }\n                }\n\n                image->setColorTable(qtColorTable);\n                for (uint32 y=0; y<height; ++y) {\n                    if (TIFFReadScanline(tiff, image->scanLine(y), y, 0) < 0) {\n                        TIFFClose(tiff);\n                        return false;\n                    }\n                }\n\n                // free redTable, greenTable and greenTable done by libtiff\n            }\n        } else {\n            if (image->size() != QSize(width, height) || image->format() != QImage::Format_ARGB32)\n                *image = QImage(width, height, QImage::Format_ARGB32);\n            if (!image->isNull()) {\n                const int stopOnError = 1;\n                if (TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32 *>(image->bits()), ORIENTATION_TOPLEFT, stopOnError)) {\n                    for (uint32 y=0; y<height; ++y)\n                        convert32BitOrder(image->scanLine(y), width);\n                } else {\n                    TIFFClose(tiff);\n                    return false;\n                }\n            }\n        }\n    }\n\n    if (image->isNull()) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    float resX = 0;\n    float resY = 0;\n    uint16 resUnit = RESUNIT_NONE;\n    if (TIFFGetField(tiff, TIFFTAG_RESOLUTIONUNIT, &resUnit)\n        && TIFFGetField(tiff, TIFFTAG_XRESOLUTION, &resX)\n        && TIFFGetField(tiff, TIFFTAG_YRESOLUTION, &resY)) {\n\n        switch(resUnit) {\n        case RESUNIT_CENTIMETER:\n            image->setDotsPerMeterX(qRound(resX * 100));\n            image->setDotsPerMeterY(qRound(resY * 100));\n            break;\n        case RESUNIT_INCH:\n            image->setDotsPerMeterX(qRound(resX * (100 / 2.54)));\n            image->setDotsPerMeterY(qRound(resY * (100 / 2.54)));\n            break;\n        default:\n            // do nothing as defaults have already\n            // been set within the QImage class\n            break;\n        }\n    }\n\n    // rotate the image if the orientation is defined in the file\n    uint16 orientationTag;\n    if (TIFFGetField(tiff, TIFFTAG_ORIENTATION, &orientationTag)) {\n        if (image->format() == QImage::Format_ARGB32) {\n            // TIFFReadRGBAImageOriented() flip the image but does not rotate them\n            switch (orientationTag) {\n            case 5:\n                rotate_right_mirror_horizontal(image);\n                break;\n            case 6:\n                rotate_right_mirror_vertical(image);\n                break;\n            case 7:\n                rotate_right_mirror_horizontal(image);\n                break;\n            case 8:\n                rotate_right_mirror_vertical(image);\n                break;\n            }\n        } else {\n            switch (orientationTag) {\n            case 1: // default orientation\n                break;\n            case 2: // mirror horizontal\n                *image = image->mirrored(true, false);\n                break;\n            case 3: // mirror both\n                *image = image->mirrored(true, true);\n                break;\n            case 4: // mirror vertical\n                *image = image->mirrored(false, true);\n                break;\n            case 5: // rotate right mirror horizontal\n                {\n                    QMatrix transformation;\n                    transformation.rotate(90);\n                    *image = image->transformed(transformation);\n                    *image = image->mirrored(true, false);\n                    break;\n                }\n            case 6: // rotate right\n                {\n                    QMatrix transformation;\n                    transformation.rotate(90);\n                    *image = image->transformed(transformation);\n                    break;\n                }\n            case 7: // rotate right, mirror vertical\n                {\n                    QMatrix transformation;\n                    transformation.rotate(90);\n                    *image = image->transformed(transformation);\n                    *image = image->mirrored(false, true);\n                    break;\n                }\n            case 8: // rotate left\n                {\n                    QMatrix transformation;\n                    transformation.rotate(270);\n                    *image = image->transformed(transformation);\n                    break;\n                }\n            }\n        }\n    }\n\n\n    TIFFClose(tiff);\n    return true;\n}",
    "ICCProfile *readICCProfile(TIFF *tiff)\n{\n    unsigned iccProfileSize = 0;\n    void *iccProfileData = Q_NULLPTR;\n    if(TIFFGetField(tiff, TIFFTAG_ICCPROFILE, &iccProfileSize, &iccProfileData))\n    {\n        LOG_DEBUG() << LOGGING_CTX << \"Found ICCP metadata (TIFFTAG_ICCPROFILE)\";\n        return new ICCProfile(QByteArray(reinterpret_cast<const char*>(iccProfileData), static_cast<int>(iccProfileSize)));\n    }\n\n    quint16 samplesPerPixel = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel))\n        return Q_NULLPTR;\n\n    quint16 bitsPerSample = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample))\n        return Q_NULLPTR;\n\n    float *whitePoint = Q_NULLPTR, *primaryChromaticities = Q_NULLPTR;\n    unsigned short *transferFunctionRed = Q_NULLPTR, *transferFunctionGreen = Q_NULLPTR, *transferFunctionBlue = Q_NULLPTR;\n    if(!TIFFGetField(tiff, TIFFTAG_WHITEPOINT, &whitePoint))\n        whitePoint = Q_NULLPTR;\n    if(!TIFFGetField(tiff, TIFFTAG_PRIMARYCHROMATICITIES, &primaryChromaticities))\n        primaryChromaticities = Q_NULLPTR;\n    if(samplesPerPixel == 1)\n    {\n        if(!TIFFGetField(tiff, TIFFTAG_TRANSFERFUNCTION, &transferFunctionRed, &transferFunctionGreen, &transferFunctionBlue))\n            transferFunctionRed = transferFunctionGreen = transferFunctionBlue = Q_NULLPTR;\n        else\n            transferFunctionGreen = transferFunctionBlue = transferFunctionRed;\n    }\n    else\n    {\n        if(!TIFFGetField(tiff, TIFFTAG_TRANSFERFUNCTION, &transferFunctionRed, &transferFunctionGreen, &transferFunctionBlue))\n            transferFunctionRed = transferFunctionGreen = transferFunctionBlue = Q_NULLPTR;\n    }\n\n    if(whitePoint || primaryChromaticities || transferFunctionRed || transferFunctionGreen || transferFunctionBlue)\n    {\n        LOG_DEBUG() << LOGGING_CTX << \"Found ICCP metadata (TIFFTAG_WHITEPOINT + TIFFTAG_PRIMARYCHROMATICITIES + TIFFTAG_TRANSFERFUNCTION)\";\n\n        /// @note TIFF defaults (CIE D50) does not match sRGB defaults (CIE D65)\n        if(!whitePoint && !TIFFGetFieldDefaulted(tiff, TIFFTAG_WHITEPOINT, &whitePoint))\n            whitePoint = Q_NULLPTR;\n\n        const size_t transferFunctionSize = (static_cast<std::size_t>(1) << bitsPerSample);\n        return new ICCProfile(whitePoint, primaryChromaticities, transferFunctionRed, transferFunctionGreen, transferFunctionBlue, transferFunctionSize);\n    }\n\n    return Q_NULLPTR;\n}",
    "void addMetaData(TIFF *tiff, const TIFFField *field, ImageMetaData *metaData, const QString &group, const QString &tag)\n{\n    const int readCount = TIFFFieldReadCount(field);\n    if(readCount == TIFF_VARIABLE2 || readCount == TIFF_VARIABLE || readCount > 1)\n    {\n        quint32 actualCount = 0;\n        T *data;\n        if(readCount == TIFF_VARIABLE)\n        {\n            quint16 gotCount = 0;\n            if(!TIFFGetField(tiff, TIFFFieldTag(field), &gotCount, &data))\n                return;\n            actualCount = gotCount;\n        }\n        else if(readCount == TIFF_VARIABLE2)\n        {\n            quint32 gotCount = 0;\n            if(!TIFFGetField(tiff, TIFFFieldTag(field), &gotCount, &data))\n                return;\n            actualCount = gotCount;\n        }\n        else\n        {\n            if(!TIFFGetField(tiff, TIFFFieldTag(field), &data))\n                return;\n            actualCount = readCount;\n        }\n        if(TIFFFieldDataType(field) == TIFF_UNDEFINED)\n        {\n            const char *charData = reinterpret_cast<const char*>(data);\n            const int charSize = static_cast<int>(actualCount * sizeof(T) / sizeof(char));\n            metaData->addExifEntry(group, TIFFFieldTag(field), tag, QString::fromLatin1(QByteArray(charData, charSize).toHex().prepend(\"0x\")));\n        }\n        else\n        {\n            QStringList values;\n            for(quint32 i = 0; i < actualCount; i++)\n                values.append(QString::fromLatin1(\"%1\").arg(data[i]));\n            metaData->addExifEntry(group, TIFFFieldTag(field), tag, QString::fromLatin1(\"{ %1 }\").arg(values.join(QString::fromLatin1(\", \"))));\n        }\n    }\n    else if(readCount == 1)\n    {\n        T data;\n        TIFFGetField(tiff, TIFFFieldTag(field), &data);\n        metaData->addExifEntry(group, TIFFFieldTag(field), tag, QString::fromLatin1(\"%1\").arg(data));\n    }\n}",
    "void addMetaData<QString>(TIFF *tiff, const TIFFField *field, ImageMetaData *metaData, const QString &group, const QString &tag)\n{\n    if(TIFFFieldReadCount(field) <= 1)\n        return;\n    char *data = Q_NULLPTR;\n    if(!TIFFGetField(tiff, TIFFFieldTag(field), &data) || !data)\n        return;\n    metaData->addExifEntry(group, TIFFFieldTag(field), tag, QString::fromUtf8(data));\n}",
    "void readTiffTagToMetaData(TIFF *tiff, ImageMetaData *&metaData, quint32 tag, const QString &tagDescription)\n{\n    const TIFFField *tagField = TIFFFindField(tiff, tag, TIFF_ANY);\n    if(!tagField)\n        return;\n    if(TIFFFieldDataType(tagField) != TIFF_IFD8)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"TIFFFieldDataType for tag (\" << tagDescription << \") is not TIFF_IFD8!\";\n        return;\n    }\n    quint64 exifOffset = 0;\n    if(!TIFFGetField(tiff, tag, &exifOffset))\n        return;\n    if(!TIFFReadEXIFDirectory(tiff, exifOffset))\n        return;\n    LOG_DEBUG() << LOGGING_CTX << \"Found EXIF metadata (\" << tagDescription << \")\";\n    if(!metaData)\n        metaData = new ImageMetaData;\n    for(int i = 0, tagListCount = TIFFGetTagListCount(tiff); i < tagListCount; i++)\n    {\n        ttag_t tag = TIFFGetTagListEntry(tiff, i);\n        const TIFFField *field = TIFFFieldWithTag(tiff, tag);\n        const QString exifName = QString::fromUtf8(TIFFFieldName(field));\n        /// @note See _TIFFVGetField in tif_dir.c\n        switch(TIFFFieldDataType(field))\n        {\n        case TIFF_BYTE:\n        case TIFF_UNDEFINED:\n            addMetaData<quint8>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_ASCII:\n            addMetaData<QString>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SHORT:\n            addMetaData<quint16>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_LONG:\n            addMetaData<quint32>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SBYTE:\n            addMetaData<qint8>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SSHORT:\n            addMetaData<qint16>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SLONG:\n            addMetaData<qint32>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SRATIONAL:\n        case TIFF_RATIONAL:\n        case TIFF_FLOAT:\n            addMetaData<float>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_DOUBLE:\n            addMetaData<double>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_LONG8:\n            addMetaData<quint64>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SLONG8:\n            addMetaData<qint64>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        default:\n            break;\n        }\n    }\n}",
    "PayloadWithMetaData<QImage> readTiffFile(const QString &filename)\n{\n    QFile inFile(filename);\n    if(!inFile.open(QIODevice::ReadOnly))\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't open\" << filename;\n        return QImage();\n    }\n\n#if defined (TIFFLIB_VERSION) && (TIFFLIB_VERSION >= 20221213) && (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))\n    TIFFOpenOptions *opts = TIFFOpenOptionsAlloc();\n    TIFFOpenOptionsSetErrorHandlerExtR(opts, errorHandlerProc, Q_NULLPTR);\n    TIFFOpenOptionsSetWarningHandlerExtR(opts, &warningHandlerProc, Q_NULLPTR);\n    TIFF *tiff = TIFFClientOpenExt(\"DecoderLibTiff\", \"r\", &inFile, readProc, writeProc, seekProc, closeProc, sizeProc, mapProc, unmapProc, opts);\n    TIFFOpenOptionsFree(opts);\n#else\n    TIFF *tiff = TIFFClientOpen(\"DecoderLibTiff\", \"r\", &inFile, readProc, writeProc, seekProc, closeProc, sizeProc, mapProc, unmapProc);\n#endif\n    if(!tiff)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't TIFFClientOpen for\" << filename;\n        return QImage();\n    }\n\n    if(!TIFFSetDirectory(tiff, 0))\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't TIFFSetDirectory for\" << filename;\n        TIFFClose(tiff);\n        return QImage();\n    }\n\n    quint32 width = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_IMAGEWIDTH, &width) || width <= 0)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't get TIFFTAG_IMAGEWIDTH for\" << filename;\n        TIFFClose(tiff);\n        return QImage();\n    }\n\n    quint32 height = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_IMAGELENGTH, &height) || height <= 0)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't get TIFFTAG_IMAGELENGTH for\" << filename;\n        TIFFClose(tiff);\n        return QImage();\n    }\n\n    quint16 compression = 0;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_COMPRESSION, &compression);\n\n    /// @todo LibTIFF-4.6.0: Looks like samples layout for subsampled YCbCr data\n    /// for JPEG compression is differ from samples layout for other compression\n    /// types. So we will enforce built-in YCbCr to RGB converter. Despite tag\n    /// name, non-YCbCr colorspaces like CMYK or RGB are not affected\n    if(compression == COMPRESSION_JPEG)\n        TIFFSetField(tiff, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\n    quint16 samplesPerPixel = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel) || samplesPerPixel <= 0)\n        samplesPerPixel = 1;\n\n    int alphaIndex = -1;\n    quint16 extrasamplesCount = 0;\n    const quint16 *extrasamples = Q_NULLPTR;\n    if(TIFFGetFieldDefaulted(tiff, TIFFTAG_EXTRASAMPLES, &extrasamplesCount, &extrasamples))\n    {\n        for(quint16 i = 0; i < extrasamplesCount && alphaIndex < 0; ++i)\n        {\n            if(extrasamples[i] == EXTRASAMPLE_ASSOCALPHA)\n                alphaIndex = static_cast<int>(i);\n        }\n        for(quint16 i = 0; i < extrasamplesCount && alphaIndex < 0; ++i)\n        {\n            if(extrasamples[i] == EXTRASAMPLE_UNASSALPHA)\n                alphaIndex = static_cast<int>(i);\n        }\n    }\n    const quint16 primarysamplesCount = samplesPerPixel > extrasamplesCount ? samplesPerPixel - extrasamplesCount : 0;\n\n    quint16 photometric = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_PHOTOMETRIC, &photometric))\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't get TIFFTAG_PHOTOMETRIC for\" << filename;\n        if(primarysamplesCount == 1)\n        {\n            photometric = PHOTOMETRIC_MINISWHITE;\n            LOG_WARNING() << LOGGING_CTX << \"Assuming PHOTOMETRIC_MINISWHITE\";\n        }\n        else if(primarysamplesCount == 3)\n        {\n            photometric = PHOTOMETRIC_RGB;\n            LOG_WARNING() << LOGGING_CTX << \"Assuming PHOTOMETRIC_RGB\";\n        }\n        else\n        {\n            TIFFClose(tiff);\n            return QImage();\n        }\n    }\n\n    /// @note Enable converting PHOTOMETRIC_LOGL and PHOTOMETRIC_LOGLUV to 8 bit\n    /// RGB and grayscale values respective\n    if(IsOneOf(photometric, PHOTOMETRIC_LOGL, PHOTOMETRIC_LOGLUV))\n        TIFFSetField(tiff, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n\n    quint16 orientation = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_ORIENTATION, &orientation) || orientation <= 0)\n        orientation = ORIENTATION_TOPLEFT;\n\n    quint16 bitsPerSample = 0;\n    if(!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample) || bitsPerSample <= 0)\n        bitsPerSample = 1;\n\n    quint16 sampleFormat = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat) || sampleFormat <= 0)\n        sampleFormat = SAMPLEFORMAT_VOID;\n\n    quint16 inkSet = 0;\n    if(photometric == PHOTOMETRIC_SEPARATED)\n    {\n        if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_INKSET, &inkSet) || inkSet <= 0)\n            inkSet = INKSET_CMYK;\n    }\n\n    quint16 planarConfig = 0;\n    TIFFGetField(tiff, TIFFTAG_PLANARCONFIG, &planarConfig);\n\n    const float *ycbcrcoeffs = Q_NULLPTR;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_YCBCRCOEFFICIENTS, &ycbcrcoeffs);\n\n    quint16 subsamplinghor = 0, subsamplingver = 0;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver);\n\n    quint16 ycbcrpositioning = 0;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_YCBCRPOSITIONING, &ycbcrpositioning);\n\n    const quint16 *redTable = Q_NULLPTR;\n    const quint16 *greenTable = Q_NULLPTR;\n    const quint16 *blueTable = Q_NULLPTR;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_COLORMAP, &redTable, &greenTable, &blueTable);\n\n    QScopedPointer<ICCProfile> iccProfile(readICCProfile(tiff));\n    if((!iccProfile || !iccProfile->isValid()) && photometric == PHOTOMETRIC_SEPARATED && inkSet == INKSET_CMYK)\n        iccProfile.reset(new ICCProfile(ICCProfile::defaultCmykProfileData()));\n\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_IMAGEWIDTH =\" << width;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_IMAGELENGTH =\" << height;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_PHOTOMETRIC =\" << photometricToString(photometric).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_INKSET =\" << inkSetToString(inkSet).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_ORIENTATION =\" << orientationToString(orientation).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_BITSPERSAMPLE =\" << bitsPerSample;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_SAMPLESPERPIXEL =\" << samplesPerPixel;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_SAMPLEFORMAT =\" << sampleFormatToString(sampleFormat).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_EXTRASAMPLES =\" << extrasamplesToString(extrasamplesCount, extrasamples).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_PLANARCONFIG =\" << planarConfigToString(planarConfig).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_COMPRESSION =\" << compressionToString(compression).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_YCBCRSUBSAMPLING =\" << subsamplinghor << subsamplingver;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_YCBCRPOSITIONING =\" << ycbcrpositioningToString(ycbcrpositioning).toLatin1().data();\n\n    const bool isSupportedInt = IsOneOf(sampleFormat, SAMPLEFORMAT_UINT, SAMPLEFORMAT_VOID, SAMPLEFORMAT_INT) && bitsPerSample <= 64;\n    const bool isSupportedFp = sampleFormat == SAMPLEFORMAT_IEEEFP && IsOneOf(bitsPerSample, 16, 24, 32, 64);\n    bool isReadingSupported = false;\n    switch(photometric)\n    {\n    case PHOTOMETRIC_MINISWHITE:\n    case PHOTOMETRIC_MINISBLACK:\n    case PHOTOMETRIC_LOGL:\n        isReadingSupported = (isSupportedInt || isSupportedFp) && primarysamplesCount >= 1;\n        break;\n    case PHOTOMETRIC_RGB:\n    case PHOTOMETRIC_YCBCR:\n    case PHOTOMETRIC_LOGLUV:\n        isReadingSupported = (isSupportedInt || isSupportedFp) && primarysamplesCount >= 3;\n        break;\n    case PHOTOMETRIC_SEPARATED:\n        isReadingSupported = (isSupportedInt || isSupportedFp) && primarysamplesCount >= 4;\n        break;\n    case PHOTOMETRIC_CIELAB:\n    case PHOTOMETRIC_ICCLAB:\n    case PHOTOMETRIC_ITULAB:\n        isReadingSupported = (isSupportedInt || isSupportedFp) && primarysamplesCount >= 1;\n        break;\n    case PHOTOMETRIC_PALETTE:\n        isReadingSupported = redTable && greenTable && blueTable && bitsPerSample <= 16 && primarysamplesCount >= 1;\n        break;\n    // case PHOTOMETRIC_MASK:\n    // case PHOTOMETRIC_CFA:\n    default:\n        break;\n    }\n\n    QImage result;\n    if(isReadingSupported)\n    {\n        Context ctx;\n        memset(&ctx, 0, sizeof(ctx));\n        ctx.tiff = tiff;\n        ctx.width = static_cast<qint64>(width);\n        ctx.height = static_cast<qint64>(height);\n        ctx.compression = compression;\n        ctx.photometric = compression == COMPRESSION_JPEG && photometric == PHOTOMETRIC_YCBCR ? PHOTOMETRIC_RGB : photometric;\n        ctx.samplesPerPixel = static_cast<qint64>(samplesPerPixel);\n        ctx.bitsPerSample = static_cast<qint64>(bitsPerSample);\n        ctx.sampleFormat = sampleFormat;\n        ctx.inkSet = inkSet;\n        ctx.iccProfile = iccProfile.data();\n        ctx.ycbcrcoeffs = ycbcrcoeffs;\n        ctx.subsamplinghor = static_cast<qint64>(subsamplinghor);\n        ctx.subsamplingver = static_cast<qint64>(subsamplingver);\n        ctx.ycbcrpositioning = ycbcrpositioning;\n        ctx.extrasamplesCount = static_cast<qint64>(extrasamplesCount);\n        ctx.primarysamplesCount = static_cast<qint64>(primarysamplesCount);\n        ctx.alphaIndex = alphaIndex;\n        ctx.alphaPremultiplied = alphaIndex >= 0 ? extrasamples[alphaIndex] == EXTRASAMPLE_ASSOCALPHA : false;\n        ctx.redTable = redTable;\n        ctx.greenTable = greenTable;\n        ctx.blueTable = blueTable;\n        ctx.colorTablesIs16Bit = false;\n\n        if(photometric == PHOTOMETRIC_PALETTE && redTable && greenTable && blueTable)\n        {\n            /// @note See buildMap and checkcmap in tif_getimage.c\n            for(quint64 i = 0, count = (1ull << bitsPerSample); i < count && !ctx.colorTablesIs16Bit; ++i)\n                if(redTable[i] >= 256 || greenTable[i] >= 256 || blueTable[i] >= 256)\n                    ctx.colorTablesIs16Bit = true;\n        }\n\n        if(TIFFIsTiled(tiff))\n            result = readTiffFileTiled(&ctx);\n        else\n            result = readTiffFileStriped(&ctx);\n    }\n\n    /// @todo LibTIFF-4.6.0: TIFFRGBA* has bad errors handling and reports OK\n    /// sometimes even if no data was decoded. So we will disable it for all\n    /// supported formats\n    if(result.isNull() && !isReadingSupported)\n    {\n        TIFFRGBAImage img;\n        char emsg[1024];\n        if(!TIFFRGBAImageBegin(&img, tiff, 0, emsg))\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Can't TIFFRGBAImageBegin for\" << filename;\n            LOG_WARNING() << LOGGING_CTX << \"Reason:\" << emsg;\n            TIFFClose(tiff);\n            return QImage();\n        }\n\n        result = QImage(static_cast<int>(img.width), static_cast<int>(img.height),\n#if (USE_RGBA_8888)\n                      QImage::Format_RGBA8888);\n#else\n                      QImage::Format_ARGB32);\n#endif\n        if(result.isNull())\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n            TIFFClose(tiff);\n            return QImage();\n        }\n\n        img.req_orientation = img.orientation;\n\n#if defined (TIFFLIB_VERSION) && (TIFFLIB_VERSION >= 20210416)\n        typedef uint32_t TiffImageBitsType;\n#else\n        typedef uint32 TiffImageBitsType;\n#endif\n\n        if(!TIFFRGBAImageGet(&img, reinterpret_cast<TiffImageBitsType*>(result.bits()), img.width, img.height))\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Can't TIFFRGBAImageGet for\" << filename;\n            TIFFClose(tiff);\n            return QImage();\n        }\n\n#if (!USE_RGBA_8888)\n        QImage_rgbSwap(result);\n#endif\n\n#undef USE_RGBA_8888\n\n        TIFFRGBAImageEnd(&img);\n\n        if(iccProfile)\n            iccProfile->applyToImage(&result);\n    }\n\n    // Some image formats can't be rendered successfully\n    if(!IsOneOf(result.format(), QImage::Format_RGB32, QImage::Format_ARGB32))\n        QImage_convertTo(result, result.hasAlphaChannel() ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n\n    ImageMetaData *metaData = ImageMetaData::createMetaData(filename);\n    if(!metaData)\n        metaData = readExifMetaData(tiff);\n    if(!metaData)\n        metaData = new ImageMetaData;\n\n    metaData->addCustomOrientation(orientation);\n    metaData->applyExifOrientation(&result);\n\n    quint16 resUnit = 0;\n    if(!TIFFGetField(tiff, TIFFTAG_RESOLUTIONUNIT, &resUnit))\n        resUnit = RESUNIT_INCH;\n    float resX = 0.0f, resY = 0.0f;\n    if(TIFFGetField(tiff, TIFFTAG_XRESOLUTION, &resX) && TIFFGetField(tiff, TIFFTAG_YRESOLUTION, &resY))\n    {\n        if(resUnit == RESUNIT_CENTIMETER)\n            metaData->addCustomDpi(static_cast<qreal>(resX * 2.54f), static_cast<qreal>(resY * 2.54f));\n        else if(resUnit == RESUNIT_INCH)\n            metaData->addCustomDpi(static_cast<qreal>(resX), static_cast<qreal>(resY));\n    }\n\n    TIFFClose(tiff);\n\n    return PayloadWithMetaData<QImage>(result, metaData);\n}",
    "uint8_t isImageJIm(const char* fileName){\n    TIFF* tif = TIFFOpen(fileName, \"r\");\n    if(!tif) return 0;\n    char* tiffDesc = NULL;\n    if(TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &tiffDesc)){\n        if(strstr(tiffDesc, \"ImageJ\")){\n            uint64_t* size = getImageSize(fileName);\n            if(size[2] > 1){\n                if(TIFFSetDirectory(tif,1)){\n                    free(size);\n                    return 0;\n                }\n            }\n            free(size);\n            uint16_t compressed = 1;\n            TIFFGetField(tif, TIFFTAG_COMPRESSION, &compressed);\n            TIFFClose(tif);\n            if(compressed != 1) return 0;\n            else return 1;\n        }\n    }\n    TIFFClose(tif);\n    return 0;\n}",
    "uint64_t imageJImGetZ(const char* fileName){\n    TIFF* tif = TIFFOpen(fileName, \"r\");\n    if(!tif) return 0;\n    char* tiffDesc = NULL;\n    if(TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &tiffDesc)){\n        if(strstr(tiffDesc, \"ImageJ\")){\n            char* nZ = strstr(tiffDesc,\"images=\");\n            if(nZ){\n                TIFFClose(tif);\n                nZ+=7;\n                char* temp;\n                return strtol(nZ,&temp,10);\n            }\n        }\n    }\n    TIFFClose(tif);\n    return 0;\n}",
    "uint64_t* getImageSize(const char* fileName){\n    TIFFSetWarningHandler(DummyHandler);\n    TIFF* tif = TIFFOpen(fileName, \"r\");\n    if(!tif) printf(\"File \\\"%s\\\" cannot be opened\",fileName);\n\n    uint64_t x = 1,y = 1,z = 1;\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &x);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &y);\n    z = getImageSizeZ(fileName);\n    TIFFClose(tif);\n\n    uint64_t* dims = (uint64_t*)malloc(3*sizeof(uint64_t));\n    dims[0] = y;\n    dims[1] = x;\n    dims[2] = z;\n    return dims;\n}",
    "uint64_t getDataType(const char* fileName){\n    TIFFSetWarningHandler(DummyHandler);\n    TIFF* tif = TIFFOpen(fileName, \"r\");\n    if(!tif) printf(\"File \\\"%s\\\" cannot be opened\",fileName);\n\n    uint64_t bits = 1;\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n    TIFFClose(tif);\n\n    return bits;\n}",
    "uint8_t readTiffParallel2D(uint64_t x, uint64_t y, uint64_t z, const char* fileName, void* tiff, uint64_t bits, uint64_t startSlice, uint64_t stripSize, uint8_t flipXY){\n    int32_t numWorkers = omp_get_max_threads();\n    uint64_t stripsPerDir = (uint64_t)ceil((double)y/(double)stripSize);\n    int32_t batchSize = (stripsPerDir-1)/numWorkers+1;\n    uint64_t bytes = bits/8;\n\n    int32_t w;\n    uint8_t err = 0;\n    uint8_t errBak = 0;\n    char errString[10000];\n    uint16_t compressed = 1;\n    TIFF* tif = TIFFOpen(fileName, \"r\");\n    TIFFGetField(tif, TIFFTAG_COMPRESSION, &compressed);\n\n    // The other method won't work on specific slices of 3D images for now\n    // so start slice must also be 0\n    if(numWorkers > 1 || compressed > 1){\n        #pragma omp parallel for\n        for(w = 0; w < numWorkers; w++){\n    \n            uint8_t outCounter = 0;\n            TIFF* tif = TIFFOpen(fileName, \"r\");\n            while(!tif){\n                tif = TIFFOpen(fileName, \"r\");\n                if(outCounter == 3){\n                    #pragma omp critical\n                    {\n                        err = 1;\n                        sprintf(errString,\"Thread %d: File \\\"%s\\\" cannot be opened\\n\",w,fileName);\n                    }\n                    continue;\n                }\n                outCounter++;\n            }\n    \n            void* buffer = malloc(x*stripSize*bytes);\n    \n    \n            uint8_t counter = 0;\n            while(!TIFFSetDirectory(tif, startSlice) && counter<3){\n                printf(\"Thread %d: File \\\"%s\\\" Directory \\\"%d\\\" failed to open. Try %d\\n\",w,fileName,0,counter+1);\n                counter++;\n                if(counter == 3){\n                    #pragma omp critical\n                    {\n                        err = 1;\n                        sprintf(errString,\"Thread %d: File \\\"%s\\\" cannot be opened\\n\",w,fileName);\n                    }\n                }\n            }\n            for (int64_t i = (w*batchSize); i < (w+1)*batchSize; i++)\n            {\n                if(i*stripSize >= y || err) break;\n                //loading the data into a buffer\n                int64_t cBytes = TIFFReadEncodedStrip(tif, i, buffer, stripSize*x*bytes);\n                if(cBytes < 0){\n                    #pragma omp critical\n                    {\n                        //errBak = 1;\n                        err = 1;\n                        sprintf(errString,\"Thread %d: Strip %ld cannot be read\\n\",w,i);\n                    }\n                    break;\n                }\n                if(!flipXY){\n                    memcpy(tiff+((i*stripSize*x)*bytes),buffer,cBytes);\n                    continue;\n                }\n                switch(bits){\n                    case 8:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t k = 0; k < stripSize; k++){\n                            if((k+(i*stripSize)) >= y) break;\n                            for(int64_t j = 0; j < x; j++){\n                                ((uint8_t*)tiff)[((j*y)+(k+(i*stripSize)))] = ((uint8_t*)buffer)[j+(k*x)];\n                            }\n                        }\n                                break;\n                    case 16:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t k = 0; k < stripSize; k++){\n                            if((k+(i*stripSize)) >= y) break;\n                            for(int64_t j = 0; j < x; j++){\n                                ((uint16_t*)tiff)[((j*y)+(k+(i*stripSize)))] = ((uint16_t*)buffer)[j+(k*x)];\n                            }\n                        }\n                                break;\n                    case 32:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t k = 0; k < stripSize; k++){\n                            if((k+(i*stripSize)) >= y) break;\n                            for(int64_t j = 0; j < x; j++){\n                                ((float*)tiff)[((j*y)+(k+(i*stripSize)))] = ((float*)buffer)[j+(k*x)];\n                            }\n                        }\n                                break;\n                    case 64:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t k = 0; k < stripSize; k++){\n                            if((k+(i*stripSize)) >= y) break;\n                            for(int64_t j = 0; j < x; j++){\n                                ((double*)tiff)[((j*y)+(k+(i*stripSize)))] = ((double*)buffer)[j+(k*x)];\n                            }\n                        }\n                                break;\n                }\n            }\n            free(buffer);\n            TIFFClose(tif);\n        }\n    }\n    else{\n        void* tiffC = NULL;\n        FILE *fp = fopen(fileName, \"rb\");\n        if(!fp){ \n\t\t\tprintf(\"File \\\"%s\\\" cannot be opened from Disk\\n\",fileName);\n\t\t\terr = 1;\n\t\t\treturn err;\n\t\t}\n\n        if(!tif){ \n\t\t\tprintf(\"File \\\"%s\\\" cannot be opened\\n\",fileName);\n\t\t\terr = 1;\n\t\t\treturn err;\n\t\t}\n        \n\t\tuint64_t offset = 0;\n        uint64_t* offsets = NULL;\n        TIFFGetField(tif, TIFFTAG_STRIPOFFSETS, &offsets);\n        if(!offsets){ \n\t\t\tprintf(\"Could not get offsets from the tiff file\\n\");\n       \t\terr = 1;\n\t\t\treturn err;\n\t\t}\n\t\toffset = offsets[0];\n        uint64_t zSize = x*y*bytes;\n    \n        fseek(fp, offset, SEEK_SET);\n\n\n        TIFFClose(tif);\n        \n        if(!flipXY){\n            fread(tiff, 1, zSize, fp);\n        }\n        else{\n            uint64_t size = x*y*z*(bits/8);\n            tiffC = malloc(size);\n            fread(tiffC, 1, zSize, fp);\n        }\n        fclose(fp);\n        if(flipXY){   \n            for(uint64_t k = 0; k < z; k++){\n                for(uint64_t j = 0; j < x; j++){\n                    for(uint64_t i = 0; i < y; i++){\n                        switch(bits){\n                            case 8:\n                                ((uint8_t*)tiff)[i+(j*y)+(k*x*y)] = ((uint8_t*)tiffC)[j+(i*x)+(k*x*y)];\n                                break;\n                            case 16:\n                                ((uint16_t*)tiff)[i+(j*y)+(k*x*y)] = ((uint16_t*)tiffC)[j+(i*x)+(k*x*y)];\n                                break;\n                            case 32:\n                                ((float*)tiff)[i+(j*y)+(k*x*y)] = ((float*)tiffC)[j+(i*x)+(k*x*y)];\n                                break;\n                            case 64:\n                                ((double*)tiff)[i+(j*y)+(k*x*y)] = ((double*)tiffC)[j+(i*x)+(k*x*y)];\n                                break;\n                        }\n                    }\n                }\n            }\n            free(tiffC);\n        }\n    }\n\n    if(err) {\n        if(errBak) return readTiffParallel2DBak(x, y, z, fileName, tiff, bits, startSlice, flipXY);\n        else printf(errString);\n    }\n\treturn err;\n}",
    "uint8_t readTiffParallelImageJ(uint64_t x, uint64_t y, uint64_t z, const char* fileName, void* tiff, uint64_t bits, uint64_t startSlice, uint64_t stripSize, uint8_t flipXY){\n    uint8_t err = 0;\n    FILE *fp = fopen(fileName, \"rb\");\n    if(!fp){ \n\t\tprintf(\"File \\\"%s\\\" cannot be opened from Disk\\n\",fileName);\n\t\terr = 1;\n\t\treturn err;\n\t}\n    TIFF* tif = TIFFOpen(fileName, \"r\");\n    if(!tif){ \n\t\tprintf(\"File \\\"%s\\\" cannot be opened\\n\",fileName);\n\t\terr = 1;\n\t\treturn err;\n\t}\n    uint64_t offset = 0;\n    uint64_t* offsets = NULL;\n    TIFFGetField(tif, TIFFTAG_STRIPOFFSETS, &offsets);\n    if(offsets) offset = offsets[0];\n\n    TIFFClose(tif);\n\n    fseek(fp, offset, SEEK_SET);\n\n    uint64_t bytes = bits/8;\n    //#pragma omp parallel for\n    /*\n    for(uint64_t i = 0; i < z; i++){\n    uint64_t cOffset = x*y*bytes*i;\n    //pread(fd,tiff+cOffset,x*y*bytes,offset+cOffset);\n    read(fd,tiff+cOffset,x*y*bytes);\n    }*/\n    uint64_t chunk = 0;\n    uint64_t tBytes = x*y*z*bytes;\n    uint64_t bytesRead;\n    uint64_t rBytes = tBytes;\n\n    // Can probably read more than INT_MAX now that we use fread\n    if(tBytes < INT_MAX) bytesRead = fread(tiff,1,tBytes,fp);\n    else{\n        while(chunk < tBytes){\n            rBytes = tBytes-chunk;\n            if(rBytes > INT_MAX) bytesRead = fread(tiff+chunk,1,INT_MAX,fp);\n            else bytesRead = fread(tiff+chunk,1,rBytes,fp);\n            chunk += bytesRead;\n        }\n    }\n    fclose(fp);\n    // Swap endianess for types greater than 8 bits\n    // TODO: May need to change later because we may not always need to swap\n    if(bits > 8){\n        #pragma omp parallel for\n        for(uint64_t i = 0; i < x*y*z; i++){\n            switch(bits){\n                case 16:\n                    //((uint16_t*)tiff)[i] = ((((uint16_t*)tiff)[i] & 0xff) >> 8) | (((uint16_t*)tiff)[i] << 8);\n                    //((uint16_t*)tiff)[i] = bswap_16(((uint16_t*)tiff)[i]);\n                    ((uint16_t*)tiff)[i] = ((((uint16_t*)tiff)[i] << 8) & 0xff00) | ((((uint16_t*)tiff)[i] >> 8) & 0x00ff);\n                    break;\n                case 32:\n                    //((num & 0xff000000) >> 24) | ((num & 0x00ff0000) >> 8) | ((num & 0x0000ff00) << 8) | (num << 24)\n                    //((float*)tiff)[i] = bswap_32(((float*)tiff)[i]);\n                    ((uint32_t*)tiff)[i] = ((((uint32_t*)tiff)[i] << 24) & 0xff000000 ) |\n                        ((((uint32_t*)tiff)[i] <<  8) & 0x00ff0000 ) |\n                        ((((uint32_t*)tiff)[i] >>  8) & 0x0000ff00 ) |\n                        ((((uint32_t*)tiff)[i] >> 24) & 0x000000ff );\n                    break;\n                case 64:\n                    //((double*)tiff)[i] = bswap_64(((double*)tiff)[i]);\n                    ((uint64_t*)tiff)[i] = ( (((uint64_t*)tiff)[i] << 56) & 0xff00000000000000UL ) |\n                        ( (((uint64_t*)tiff)[i] << 40) & 0x00ff000000000000UL ) |\n                        ( (((uint64_t*)tiff)[i] << 24) & 0x0000ff0000000000UL ) |\n                        ( (((uint64_t*)tiff)[i] <<  8) & 0x000000ff00000000UL ) |\n                        ( (((uint64_t*)tiff)[i] >>  8) & 0x00000000ff000000UL ) |\n                        ( (((uint64_t*)tiff)[i] >> 24) & 0x0000000000ff0000UL ) |\n                        ( (((uint64_t*)tiff)[i] >> 40) & 0x000000000000ff00UL ) |\n                        ( (((uint64_t*)tiff)[i] >> 56) & 0x00000000000000ffUL );\n                    break;\n            }\n\n        }\n    }\n    // Find a way to do this in-place without making a copy\n    if(flipXY){\n        uint64_t size = x*y*z*(bits/8);\n        void* tiffC = malloc(size);\n        memcpy(tiffC,tiff,size);\n        #pragma omp parallel for\n        for(uint64_t k = 0; k < z; k++){\n            for(uint64_t j = 0; j < x; j++){\n                for(uint64_t i = 0; i < y; i++){\n                    switch(bits){\n                        case 8:\n                            ((uint8_t*)tiff)[i+(j*y)+(k*x*y)] = ((uint8_t*)tiffC)[j+(i*x)+(k*x*y)];\n                            break;\n                        case 16:\n                            ((uint16_t*)tiff)[i+(j*y)+(k*x*y)] = ((uint16_t*)tiffC)[j+(i*x)+(k*x*y)];\n                            break;\n                        case 32:\n                            ((float*)tiff)[i+(j*y)+(k*x*y)] = ((float*)tiffC)[j+(i*x)+(k*x*y)];\n                            break;\n                        case 64:\n                            ((double*)tiff)[i+(j*y)+(k*x*y)] = ((double*)tiffC)[j+(i*x)+(k*x*y)];\n                            break;\n                    }\n                }\n            }\n        }\n        free(tiffC);\n    }\n\treturn err;\n}",
    "void* readTiffParallelWrapperHelper(const char* fileName, void* tiff, uint8_t flipXY)\n{\n\tTIFFSetWarningHandler(DummyHandler);\n\tTIFF* tif = TIFFOpen(fileName, \"r\");\n\tif(!tif) return NULL;\n\n\tuint64_t x = 1,y = 1,z = 1,bits = 1, startSlice = 0;\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &x);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &y);\n    z = getImageSizeZ(fileName);\n\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n\tuint64_t stripSize = 1;\n\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &stripSize);\n\tTIFFClose(tif);\n\n\t// Check if image is an imagej image with imagej metadata\n\t// Get the correct\n\tuint8_t imageJIm = 0;\n\tif(isImageJIm(fileName)){\n\t\timageJIm = 1;\n\t\tuint64_t tempZ = imageJImGetZ(fileName);\n\t\tif(tempZ) z = tempZ;\n\t}\n\n\n\tif(imageJIm){\n\t\tif(bits == 8){\n\t\t\tif(!tiff) tiff = (uint8_t*)malloc(x*y*z*sizeof(uint8_t));\n\t\t\treadTiffParallelImageJ(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize,flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 16){\n\t\t\tif(!tiff) tiff = (uint16_t*)malloc(x*y*z*sizeof(uint16_t));\n\t\t\treadTiffParallelImageJ(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 32){\n\t\t\tif(!tiff) tiff = (float*)malloc(x*y*z*sizeof(float));\n\t\t\treadTiffParallelImageJ(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 64){\n\t\t\tif(!tiff) tiff = (double*)malloc(x*y*z*sizeof(double));\n\t\t\treadTiffParallelImageJ(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse{\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse if(z <= 1){\n\t\tif(bits == 8){\n\t\t\tif(!tiff) tiff = (uint8_t*)malloc(x*y*z*sizeof(uint8_t));\n\t\t\treadTiffParallel2D(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize,flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 16){\n\t\t\tif(!tiff) tiff = (uint16_t*)malloc(x*y*z*sizeof(uint16_t));\n\t\t\treadTiffParallel2D(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 32){\n\t\t\tif(!tiff) tiff = (float*)malloc(x*y*z*sizeof(float));\n\t\t\treadTiffParallel2D(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 64){\n\t\t\tif(!tiff) tiff = (double*)malloc(x*y*z*sizeof(double));\n\t\t\treadTiffParallel2D(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse{\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse{\n\t\tif(bits == 8){\n\t\t\tif(!tiff) tiff = (uint8_t*)malloc(x*y*z*sizeof(uint8_t));\n\t\t\treadTiffParallel(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 16){\n\t\t\tif(!tiff) tiff = (uint16_t*)malloc(x*y*z*sizeof(uint16_t));\n\t\t\treadTiffParallel(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 32){\n\t\t\tif(!tiff) tiff = (float*)malloc(x*y*z*sizeof(float));\n\t\t\treadTiffParallel(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 64){\n\t\t\tif(!tiff) tiff = (double*)malloc(x*y*z*sizeof(double));\n\t\t\treadTiffParallel(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse{\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t// Should never get here but return NULL if we do\n\treturn NULL;\n}",
    "void mexFunction(int nlhs, mxArray *plhs[],\n        int nrhs, const mxArray *prhs[])\n{\n    if(nrhs != 1) mexErrMsgIdAndTxt(\"tiff:inputError\",\"This function requires one argument only\");\n    // Check if the fileName is a char array or matlab style\n    char* fileName = NULL;\n    if(!mxIsClass(prhs[0], \"string\")){\n        if(!mxIsChar(prhs[0])) mexErrMsgIdAndTxt(\"tiff:inputError\",\"The first argument must be a string\");\n        fileName = mxArrayToString(prhs[0]);\n    }\n    else{ \n        mxArray* mString[1];\n        mxArray* mCharA[1];\n\n        // Convert string to char array\n        mString[0] = mxDuplicateArray(prhs[0]);\n        mexCallMATLAB(1, mCharA, 1, mString, \"char\");\n        fileName = mxArrayToString(mCharA[0]);\n    }\n\n    // Handle the tilde character in filenames on Linux/Mac\n    #ifndef _WIN32\n    if(strchr(fileName,'~')) fileName = expandTilde(fileName);\n    #endif\n    \n    TIFFSetWarningHandler(DummyHandler);\n    TIFF* tif = TIFFOpen(fileName, \"r\");\n    if(!tif) mexErrMsgIdAndTxt(\"tiff:inputError\",\"File \\\"%s\\\" cannot be opened\",fileName);\n    \n    uint64_t x = 1,y = 1,z = 1;    \n    if(nrhs == 1){\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &x);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &y);\n        z = getImageSizeZ(fileName);\n    }\n    else{\n        mexErrMsgIdAndTxt(\"tiff:inputError\",\"Function only accepts one input argument\");       \n    }\n  \n    TIFFClose(tif);\n\tif(isImageJIm(fileName)){\n\t\tuint64_t tempZ = imageJImGetZ(fileName);\n\t\tif(tempZ) z = tempZ;\n\t}\n\n    plhs[0] = mxCreateNumericMatrix(1,3,mxDOUBLE_CLASS, mxREAL);\n    double* dims = (double*)mxGetPr(plhs[0]);\n    dims[0] = y;\n    dims[1] = x;\n    dims[2] = z;\n    \n}",
    "void mexFunction(int nlhs, mxArray *plhs[],\n                 int nrhs, const mxArray *prhs[])\n{\n    if(nrhs < 1 || nrhs > 2) mexErrMsgIdAndTxt(\"tiff:inputError\",\"This function takes one or two arguments only\");\n    // Check if the fileName is a char array or matlab style\n    char* fileName = NULL;\n    if(!mxIsClass(prhs[0], \"string\")){\n        if(!mxIsChar(prhs[0])) mexErrMsgIdAndTxt(\"tiff:inputError\",\"The first argument must be a string\");\n        fileName = mxArrayToString(prhs[0]);\n    }\n    else{ \n        mxArray* mString[1];\n        mxArray* mCharA[1];\n\n        // Convert string to char array\n        mString[0] = mxDuplicateArray(prhs[0]);\n        mexCallMATLAB(1, mCharA, 1, mString, \"char\");\n        fileName = mxArrayToString(mCharA[0]);\n    }\n\n    // Handle the tilde character in filenames on Linux/Mac\n    #ifndef _WIN32\n    if(strchr(fileName,'~')) fileName = expandTilde(fileName);\n    #endif\n\n    uint8_t flipXY = 1;\n    //uint8_t flipXY = 0;\n\n\n    //if(nrhs > 2){\n    //    flipXY = (uint8_t)*(mxGetPr(prhs[2]));\n    //}\n\n\n    TIFFSetWarningHandler(DummyHandler);\n    TIFF* tif = TIFFOpen(fileName, \"r\");\n    if(!tif) mexErrMsgIdAndTxt(\"tiff:inputError\",\"File \\\"%s\\\" cannot be opened\",fileName);\n\n    uint64_t x = 1,y = 1,z = 1,bits = 1, startSlice = 0;\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &x);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &y);\n\n    if(nrhs == 1){\n        z = getImageSizeZ(fileName);\n    }\n    else{\n        if(mxGetN(prhs[1]) != 2){\n            mexErrMsgIdAndTxt(\"tiff:inputError\",\"Input range is not 2\");\n        }\n        else{\n            startSlice = (uint64_t)*(mxGetPr(prhs[1]))-1;\n            z = (uint64_t)*((mxGetPr(prhs[1])+1))-startSlice;\n            if (!TIFFSetDirectory(tif,startSlice+z-1) || !TIFFSetDirectory(tif,startSlice)){\n                mexErrMsgIdAndTxt(\"tiff:rangeOutOfBound\",\"Range is out of bounds\");\n            }\n        }\n    }\n\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n    uint64_t stripSize = 1;\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &stripSize);\n    TIFFClose(tif);\n\n    uint8_t imageJIm = 0;\n    if(isImageJIm(fileName)){\n        imageJIm = 1;\n        uint64_t tempZ = imageJImGetZ(fileName);\n        if(tempZ) z = tempZ;\n    }\n\n    uint64_t dim[3];\n    dim[0] = y;\n    dim[1] = x;\n    dim[2] = z;\n\n\n\n    // Case for ImageJ\n    uint8_t err = 0;\n    if(imageJIm){\n        if(bits == 8){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxUINT8_CLASS, mxREAL);\n            uint8_t* tiff = (uint8_t*)mxGetPr(plhs[0]);\n            err = readTiffParallelImageJ(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 16){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxUINT16_CLASS, mxREAL);\n            uint16_t* tiff = (uint16_t*)mxGetPr(plhs[0]);\n            err = readTiffParallelImageJ(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 32){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxSINGLE_CLASS, mxREAL);\n            float* tiff = (float*)mxGetPr(plhs[0]);\n            err = readTiffParallelImageJ(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 64){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxDOUBLE_CLASS, mxREAL);\n            double* tiff = (double*)mxGetPr(plhs[0]);\n            err = readTiffParallelImageJ(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else{\n            mexErrMsgIdAndTxt(\"tiff:dataTypeError\",\"Data type not suppported\");\n        }\n    }\n    // Case for 2D\n    else if(z <= 1){\n        if(bits == 8){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxUINT8_CLASS, mxREAL);\n            uint8_t* tiff = (uint8_t*)mxGetPr(plhs[0]);\n            err = readTiffParallel2D(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 16){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxUINT16_CLASS, mxREAL);\n            uint16_t* tiff = (uint16_t*)mxGetPr(plhs[0]);\n            err = readTiffParallel2D(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 32){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxSINGLE_CLASS, mxREAL);\n            float* tiff = (float*)mxGetPr(plhs[0]);\n            err = readTiffParallel2D(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 64){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxDOUBLE_CLASS, mxREAL);\n            double* tiff = (double*)mxGetPr(plhs[0]);\n            err = readTiffParallel2D(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else{\n            mexErrMsgIdAndTxt(\"tiff:dataTypeError\",\"Data type not suppported\");\n        }\n    }\n    // Case for 3D\n    else{\n        if(bits == 8){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxUINT8_CLASS, mxREAL);\n            uint8_t* tiff = (uint8_t*)mxGetPr(plhs[0]);\n            err = readTiffParallel(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 16){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxUINT16_CLASS, mxREAL);\n            uint16_t* tiff = (uint16_t*)mxGetPr(plhs[0]);\n            err = readTiffParallel(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 32){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxSINGLE_CLASS, mxREAL);\n            float* tiff = (float*)mxGetPr(plhs[0]);\n            err = readTiffParallel(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 64){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxDOUBLE_CLASS, mxREAL);\n            double* tiff = (double*)mxGetPr(plhs[0]);\n            err = readTiffParallel(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else{\n            mexErrMsgIdAndTxt(\"tiff:dataTypeError\",\"Data type not suppported\");\n        }\n    }\n    if(err) mexErrMsgIdAndTxt(\"tiff:tiffError\",\"An Error occured within the read function\");\n}",
    "bool CTiffImg::Open(const char *szFname)\n{\n  Close();\n  m_bRead = true;\n\n  m_hTif = TIFFOpen(szFname, \"r\");\n  if (!m_hTif) {\n    TIFFError(szFname,\"Can not open input image\");\n    return false;\n  }\n  icUInt16Number nPlanar=PLANARCONFIG_CONTIG;\n  icUInt16Number nOrientation=ORIENTATION_TOPLEFT;\n  icUInt16Number nSampleFormat=SAMPLEFORMAT_UINT;\n  icUInt16Number *nSampleInfo=NULL;\n\n  TIFFGetField(m_hTif, TIFFTAG_IMAGEWIDTH, &m_nWidth);\n  TIFFGetField(m_hTif, TIFFTAG_IMAGELENGTH, &m_nHeight);\n  TIFFGetField(m_hTif, TIFFTAG_PHOTOMETRIC, &m_nPhoto);\n  TIFFGetField(m_hTif, TIFFTAG_PLANARCONFIG, &m_nPlanar);\n  TIFFGetField(m_hTif, TIFFTAG_SAMPLESPERPIXEL, &m_nSamples);\n  TIFFGetField(m_hTif, TIFFTAG_EXTRASAMPLES, &m_nExtraSamples, &nSampleInfo);\n  TIFFGetField(m_hTif, TIFFTAG_BITSPERSAMPLE, &m_nBitsPerSample);\n  TIFFGetField(m_hTif, TIFFTAG_SAMPLEFORMAT, &nSampleFormat);\n  TIFFGetField(m_hTif, TIFFTAG_ROWSPERSTRIP, &m_nRowsPerStrip);\n  TIFFGetField(m_hTif, TIFFTAG_ORIENTATION, &nOrientation);\n  TIFFGetField(m_hTif, TIFFTAG_XRESOLUTION, &m_fXRes);\n  TIFFGetField(m_hTif, TIFFTAG_YRESOLUTION, &m_fYRes);\n  TIFFGetField(m_hTif, TIFFTAG_COMPRESSION, &m_nCompress);\n\n  //Validate what we expect to work with\n  if ((m_nBitsPerSample==32 && nSampleFormat!=SAMPLEFORMAT_IEEEFP) ||\n      (m_nBitsPerSample!=32 && nSampleFormat!=SAMPLEFORMAT_UINT) ||\n       nOrientation != ORIENTATION_TOPLEFT) {\n    Close();\n    return false;\n  }\n  m_nCurStrip=(unsigned int)-1;\n  m_nCurLine = 0;\n\n  m_nStripSize = (unsigned int)TIFFStripSize(m_hTif);\n\n  if (m_nSamples>1 && m_nPlanar==PLANARCONFIG_SEPARATE) {\n    m_nStripSamples = m_nSamples;\n    m_nBytesPerLine = (m_nWidth * m_nBitsPerSample * m_nSamples + 7)>>3;\n    m_nBytesPerSample = m_nBitsPerSample / 8;\n    m_nBytesPerStripLine = m_nWidth * m_nBytesPerSample;\n    //Only support bitspersample that fits on byte boundary\n    if (m_nBitsPerSample%8) {\n      Close();\n      return false;\n    }\n    m_nStripsPerSample = m_nHeight / m_nRowsPerStrip;\n    //Only support separations that evenly fit into strips\n    if (m_nHeight % m_nRowsPerStrip) {\n      Close();\n      return false;\n    }\n  }\n  else {\n    m_nStripSamples = 1;\n    m_nBytesPerLine = (m_nWidth * m_nBitsPerSample * m_nSamples + 7)>>3;\n  }\n\n  m_pStripBuf = (unsigned char*)malloc(m_nStripSize*m_nStripSamples);\n\n  if (!m_pStripBuf) {\n    Close();\n    return false;\n  }\n\n  return true;\n}",
    "bool CTiffImg::GetIccProfile(unsigned char *&pProfile, unsigned int &nLen)\n{\n  pProfile = NULL;\n  nLen = 0;\n\n  TIFFGetField(m_hTif, TIFFTAG_ICCPROFILE, &nLen, &pProfile);\n\n  return pProfile!=NULL && nLen>0;\n}",
    "bool wxTIFFHandler::LoadFile( wxImage *image, wxInputStream& stream, bool verbose, int index )\r\n{\r\n    if (index == -1)\r\n        index = 0;\r\n\r\n    image->Destroy();\r\n\r\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"r\" );\r\n\r\n    if (!tif)\r\n    {\r\n        if (verbose)\r\n        {\r\n            wxLogError( _(\"TIFF: Error loading image.\") );\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    if (!TIFFSetDirectory( tif, (tdir_t)index ))\r\n    {\r\n        if (verbose)\r\n        {\r\n            wxLogError( _(\"Invalid TIFF image index.\") );\r\n        }\r\n\r\n        TIFFClose( tif );\r\n\r\n        return false;\r\n    }\r\n\r\n    uint32 w, h;\r\n    uint32 *raster;\r\n\r\n    TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &w );\r\n    TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &h );\r\n\r\n    uint16 extraSamples;\r\n    uint16* samplesInfo;\r\n    TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,\r\n                          &extraSamples, &samplesInfo);\r\n    const bool hasAlpha = (extraSamples == 1 &&\r\n                           (samplesInfo[0] == EXTRASAMPLE_ASSOCALPHA ||\r\n                            samplesInfo[0] == EXTRASAMPLE_UNASSALPHA));\r\n\r\n    // guard against integer overflow during multiplication which could result\r\n    // in allocating a too small buffer and then overflowing it\r\n    const double bytesNeeded = (double)w * (double)h * sizeof(uint32);\r\n    if ( bytesNeeded >= wxUINT32_MAX )\r\n    {\r\n        if ( verbose )\r\n        {\r\n            wxLogError( _(\"TIFF: Image size is abnormally big.\") );\r\n        }\r\n\r\n        TIFFClose(tif);\r\n\r\n        return false;\r\n    }\r\n\r\n    raster = (uint32*) _TIFFmalloc( (uint32)bytesNeeded );\r\n\r\n    if (!raster)\r\n    {\r\n        if (verbose)\r\n        {\r\n            wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\r\n        }\r\n\r\n        TIFFClose( tif );\r\n\r\n        return false;\r\n    }\r\n\r\n    image->Create( (int)w, (int)h );\r\n    if (!image->Ok())\r\n    {\r\n        if (verbose)\r\n        {\r\n            wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\r\n        }\r\n\r\n        _TIFFfree( raster );\r\n        TIFFClose( tif );\r\n\r\n        return false;\r\n    }\r\n\r\n    if ( hasAlpha )\r\n        image->SetAlpha();\r\n\r\n    if (!TIFFReadRGBAImage( tif, w, h, raster, 0 ))\r\n    {\r\n        if (verbose)\r\n        {\r\n            wxLogError( _(\"TIFF: Error reading image.\") );\r\n        }\r\n\r\n        _TIFFfree( raster );\r\n        image->Destroy();\r\n        TIFFClose( tif );\r\n\r\n        return false;\r\n    }\r\n\r\n    unsigned char *ptr = image->GetData();\r\n    ptr += w*3*(h-1);\r\n\r\n    unsigned char *alpha = hasAlpha ? image->GetAlpha() : NULL;\r\n    if ( hasAlpha )\r\n        alpha += w*(h-1);\r\n\r\n    uint32 pos = 0;\r\n\r\n    for (uint32 i = 0; i < h; i++)\r\n    {\r\n        for (uint32 j = 0; j < w; j++)\r\n        {\r\n            *(ptr++) = (unsigned char)TIFFGetR(raster[pos]);\r\n            *(ptr++) = (unsigned char)TIFFGetG(raster[pos]);\r\n            *(ptr++) = (unsigned char)TIFFGetB(raster[pos]);\r\n            if ( hasAlpha )\r\n                *(alpha++) = (unsigned char)TIFFGetA(raster[pos]);\r\n\r\n            pos++;\r\n        }\r\n\r\n        // subtract line we just added plus one line:\r\n        ptr -= 2*w*3;\r\n        if ( hasAlpha )\r\n            alpha -= 2*w;\r\n    }\r\n\r\n    // set the image resolution if it's available\r\n    uint16 tiffRes;\r\n    if ( TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, &tiffRes) )\r\n    {\r\n        wxImageResolution res;\r\n        switch ( tiffRes )\r\n        {\r\n            default:\r\n                wxLogWarning(_(\"Unknown TIFF resolution unit %d ignored\"),\r\n                             tiffRes);\r\n                // fall through\r\n\r\n            case RESUNIT_NONE:\r\n                res = wxIMAGE_RESOLUTION_NONE;\r\n                break;\r\n\r\n            case RESUNIT_INCH:\r\n                res = wxIMAGE_RESOLUTION_INCHES;\r\n                break;\r\n\r\n            case RESUNIT_CENTIMETER:\r\n                res = wxIMAGE_RESOLUTION_CM;\r\n                break;\r\n        }\r\n\r\n        if ( res != wxIMAGE_RESOLUTION_NONE )\r\n        {\r\n            float xres, yres;\r\n            if ( TIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres) )\r\n                image->SetOption(wxIMAGE_OPTION_RESOLUTIONX, wxRound(xres));\r\n\r\n            if ( TIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres) )\r\n                image->SetOption(wxIMAGE_OPTION_RESOLUTIONY, wxRound(yres));\r\n        }\r\n    }\r\n\r\n\r\n    _TIFFfree( raster );\r\n\r\n    TIFFClose( tif );\r\n\r\n    return true;\r\n}",
    "vtkImageAlgorithm* VtkRaster::loadImageFromTIFF(const std::string& fileName)\n{\n    TIFF* tiff = XTIFFOpen(fileName.c_str(), \"r\");\n\n    if (tiff)\n    {\n        GTIF* geoTiff = GTIFNew(tiff);\n\n        int version[3];\n        int count(0);\n        GTIFDirectoryInfo(geoTiff, version, &count);\n\n        if (count == 0)\n            WARN(\"VtkRaster::loadImageFromTIFF - file is not georeferenced.\");\n\n        if (geoTiff)\n        {\n            double x0 = 0.0;\n            double y0 = 0.0;\n            double cellsize = 1.0;\n            int imgWidth = 0;\n            int imgHeight = 0;\n            int nImages = 0;\n            int pntCount = 0;\n            double* pnts = nullptr;\n\n            // get actual number of images in the tiff file\n            do\n            {\n                ++nImages;\n            } while (TIFFReadDirectory(tiff));\n            if (nImages > 1)\n                INFO(\n                    \"VtkRaster::loadImageFromTIFF() - File contains {:d} \"\n                    \"images. This method is not tested for this case.\",\n                    nImages);\n\n            // get image size\n            TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &imgWidth);\n            TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &imgHeight);\n\n            // get cellsize\n            // Note: GeoTiff allows anisotropic pixels. This is not supported\n            // here and equilateral pixels are assumed.\n            if (TIFFGetField(tiff, GTIFF_PIXELSCALE, &pntCount, &pnts))\n            {\n                if (pnts[0] != pnts[1])\n                    WARN(\n                        \"VtkRaster::loadImageFromTIFF(): Original raster data \"\n                        \"has anisotrop pixel size!\");\n                cellsize = pnts[0];\n            }\n\n            // get upper left point / origin\n            if (TIFFGetField(tiff, GTIFF_TIEPOINTS, &pntCount, &pnts))\n            {\n                x0 = pnts[3];\n                y0 = pnts[4] -\n                     (imgHeight * cellsize);  // the origin should be the lower\n                                              // left corner of the img\n            }\n\n            // read pixel values\n            auto* pixVal = static_cast<uint32*>(\n                _TIFFmalloc(imgWidth * imgHeight * sizeof(uint32)));\n            if ((imgWidth > 0) && (imgHeight > 0))\n            {\n                if (!TIFFReadRGBAImage(tiff, imgWidth, imgHeight, pixVal, 0))\n                {\n                    ERR(\"VtkRaster::loadImageFromTIFF(): reading GeoTIFF \"\n                        \"file.\");\n                    _TIFFfree(pixVal);\n                    GTIFFree(geoTiff);\n                    XTIFFClose(tiff);\n                    return nullptr;\n                }\n            }\n\n            // check for colormap\n            uint16 photometric;\n            TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &photometric);\n            // read colormap\n            uint16 *cmap_red = nullptr, *cmap_green = nullptr,\n                   *cmap_blue = nullptr;\n            int colormap_used = TIFFGetField(tiff, TIFFTAG_COLORMAP, &cmap_red,\n                                             &cmap_green, &cmap_blue);\n\n            auto* data = new float[imgWidth * imgHeight * 4];\n            auto* pxl(new int[4]);\n            for (int j = 0; j < imgHeight; ++j)\n            {\n                int lineindex = j * imgWidth;\n                for (int i = 0; i < imgWidth; ++i)\n                {  // scale intensities and set nodata values to white (i.e. the\n                   // background colour)\n                    unsigned pxl_idx(lineindex + i);\n                    unsigned pos = 4 * (pxl_idx);\n                    if (photometric == 1 && colormap_used == 1)\n                    {\n                        int idx = TIFFGetR(pixVal[pxl_idx]);\n                        data[pos] = static_cast<float>(cmap_red[idx] >> 8);\n                        data[pos + 1] =\n                            static_cast<float>(cmap_green[idx] >> 8);\n                        data[pos + 2] = static_cast<float>(cmap_blue[idx] >> 8);\n                        data[pos + 3] = 1;\n                    }\n                    else\n                    {\n                        data[pos] =\n                            static_cast<float>(TIFFGetR(pixVal[pxl_idx]));\n                        data[pos + 1] =\n                            static_cast<float>(TIFFGetG(pixVal[pxl_idx]));\n                        data[pos + 2] =\n                            static_cast<float>(TIFFGetB(pixVal[pxl_idx]));\n                        data[pos + 3] =\n                            static_cast<float>(TIFFGetA(pixVal[pxl_idx]));\n                    }\n                }\n            }\n            delete[] pxl;\n\n            // set transparency values according to maximum pixel value\n            if (photometric == 1)\n            {\n                float max_val(0);\n                unsigned nPixels = 4 * imgWidth * imgHeight;\n                for (unsigned j = 0; j < nPixels; ++j)\n                {\n                    if (data[j] > max_val)\n                    {\n                        max_val = data[j];\n                    }\n                }\n\n                for (unsigned j = 0; j < nPixels; j += 4)\n                {\n                    data[j + 3] = max_val;\n                }\n            }\n\n            vtkImageImport* image = vtkImageImport::New();\n            image->SetDataOrigin(x0, y0, 0);\n            image->SetDataSpacing(cellsize, cellsize, cellsize);\n            image->SetWholeExtent(0, imgWidth - 1, 0, imgHeight - 1, 0, 0);\n            image->SetDataExtent(0, imgWidth - 1, 0, imgHeight - 1, 0, 0);\n            image->SetDataExtentToWholeExtent();\n            image->SetDataScalarTypeToFloat();\n            image->SetNumberOfScalarComponents(4);\n            image->SetImportVoidPointer(data, 0);\n            image->Update();\n\n            _TIFFfree(pixVal);\n            GTIFFree(geoTiff);\n            XTIFFClose(tiff);\n            return image;\n        }\n\n        XTIFFClose(tiff);\n        ERR(\"VtkRaster::loadImageFromTIFF() - File not recognised as \"\n            \"GeoTIFF-Image.\");\n        return nullptr;\n    }\n\n    ERR(\"VtkRaster::loadImageFromTIFF() - File not recognised as TIFF-Image.\");\n    return nullptr;\n}",
    "bool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif);\n    if (!m_tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        tif = TIFFOpen(m_filename.c_str(), \"r\");\n    }\n\n    if( tif )\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            uint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if((bpp == 32 && ncn == 3) || photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric != 2 && photometric != 1) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? wanted_channels : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? wanted_channels : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}",
    "rvoe<RasterImage> do_tiff_load(TIFF *tif) {\n    RawPixelImage result;\n    std::optional<std::string> icc;\n\n    uint32_t w{}, h{};\n    uint16_t bitspersample{}, samplesperpixel{}, photometric{}, planarconf{};\n    uint32_t icc_count{};\n    void *icc_data{};\n\n    if(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w) != 1) {\n        RETERR(UnsupportedTIFF);\n    }\n    if(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h) != 1) {\n        RETERR(UnsupportedTIFF);\n    }\n\n    if(TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample) != 1) {\n        RETERR(UnsupportedTIFF);\n    }\n    if(bitspersample != 8) {\n        RETERR(UnsupportedTIFF);\n    }\n\n    if(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel) != 1) {\n        RETERR(UnsupportedTIFF);\n    }\n\n    if(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric) != 1) {\n        RETERR(UnsupportedTIFF);\n    }\n\n    /*\n     * Note that the output variable is an array, because there can\n     * be more than 1 extra channel.\n    if(TIFFGetField(tif, TIFFTAG_EXTRASAMPLES, &extrasamples) == 1) {\n        if(extrasamples != 0) {\n            fprintf(stderr, \"TIFFs with an alpha channel not supported yet.\");\n            RETERR(UnsupportedTIFF);\n        }\n    }\n    */\n\n    if(TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planarconf) != 1) {\n        RETERR(UnsupportedTIFF);\n    }\n    // Maybe fail for this?\n\n    if(TIFFGetField(tif, TIFFTAG_ICCPROFILE, &icc_count, &icc_data) == 1) {\n        result.icc_profile = std::vector<std::byte>((const std::byte *)icc_data,\n                                                    (const std::byte *)icc_data + icc_count);\n    }\n\n    result.md.pixel_depth = bitspersample;\n    result.md.alpha_depth = bitspersample;\n\n    const auto scanlinesize = TIFFScanlineSize64(tif);\n    std::vector<std::byte> line(scanlinesize, std::byte(0));\n    result.pixels.reserve(scanlinesize * h);\n    for(uint32_t row = 0; row < h; ++row) {\n        if(TIFFReadScanline(tif, line.data(), row) != 1) {\n            fprintf(stderr, \"TIFF decoding failed.\\n\");\n            RETERR(FileReadError);\n        }\n        result.pixels.insert(result.pixels.end(), line.cbegin(), line.cend());\n    }\n    result.md.w = w;\n    result.md.h = h;\n    result.md.pixel_depth = 8;\n    result.md.alpha_depth = 8;\n\n    switch(photometric) {\n    case PHOTOMETRIC_SEPARATED:\n        if(samplesperpixel == 5) {\n            separate_tif_alpha(result, 4);\n        } else if(samplesperpixel != 4) {\n            RETERR(UnsupportedTIFF);\n        }\n        result.md.cs = CAPY_IMAGE_CS_CMYK;\n        break;\n\n    case PHOTOMETRIC_RGB:\n        if(samplesperpixel == 4) {\n            separate_tif_alpha(result, 3);\n        } else if(samplesperpixel != 3) {\n            RETERR(UnsupportedTIFF);\n        }\n        result.md.cs = CAPY_IMAGE_CS_RGB;\n        break;\n\n    case PHOTOMETRIC_MINISBLACK:\n        if(samplesperpixel == 2) {\n            separate_tif_alpha(result, 1);\n        } else if(samplesperpixel != 1) {\n            RETERR(UnsupportedTIFF);\n        }\n        result.md.cs = CAPY_IMAGE_CS_GRAY;\n        break;\n\n    default:\n        RETERR(UnsupportedTIFF);\n    }\n    return RasterImage(std::move(result));\n}",
    "void\nTiffPlugin::setImageFiles(QStringList files)\n{\n  QProgressDialog progress(\"Enumerating files - may take some time...\",\n\t\t\t   0,\n\t\t\t   0, 100,\n\t\t\t   0);\n  progress.setMinimumDuration(0);\n\n  QStringList flist;\n  flist.clear();\n  \n  for(uint i=0; i<files.size(); i++)\n    {\n      progress.setValue(100*(float)i/(float)files.size());\n      qApp->processEvents();\n      \n      QFileInfo fileInfo(m_fileName[0], files[i]);\n      QString imgfl = fileInfo.absoluteFilePath();\n\n      m_imageList.append(imgfl);\n    }\n  \n  progress.setValue(100);\n  qApp->processEvents();\n\n  m_depth = m_imageList.size();\n\n  TIFF *image;\n  image = TIFFOpen((char*)m_imageList[0].toUtf8().data(), \"r\");\n  \n  // -- get number of images(directories) within the file\n  m_dirCount = 0;\n  if (image)\n    {\n      do {\n\tm_dirCount ++;\n      } while (TIFFReadDirectory(image));\n      if (m_dirCount > 1)\n\tQMessageBox::information(0, \"3D Tiff\",\n\t\t\t\t QString(\"Number of images : %1\").arg(m_dirCount));\n      if (m_dirCount > 1)\n\tm_depth = m_dirCount;\n    }\n\n  TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &m_width);\n  TIFFGetField(image, TIFFTAG_IMAGELENGTH, &m_height);\n\n  uint16 bitPerSample;\n  TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &bitPerSample);\n\n  TIFFClose(image);\n\n  if (bitPerSample == 1)\n    {\n      QMessageBox::critical(0, \"Image Format Error\", \"Cannot handle this format : bits per voxel = 1\");\n      m_imageList.clear();\n      return;\n    }\n\n  if (bitPerSample == 8)\n    {\n      m_voxelType = _UChar;\n\n      QStringList vtypes;\n      vtypes << \"UChar\";\n      vtypes << \"Char\";\n      QString option = QInputDialog::getItem(0,\n\t\t\t\t\t     \"Select Voxel Type\",\n\t\t\t\t\t     \"Voxel Type (found 8 bits per voxel)\",\n\t\t\t\t\t     vtypes,\n\t\t\t\t\t     0,\n\t\t\t\t\t     false);\n      int idx = vtypes.indexOf(option);\n      if (idx == 1)\n\tm_voxelType = _Char;\n    }\n  else if (bitPerSample == 16)\n    {\n      m_voxelType = _UShort;\n\n      QStringList vtypes;\n      vtypes << \"UShort\";\n      vtypes << \"Short\";\n      QString option = QInputDialog::getItem(0,\n\t\t\t\t\t     \"Select Voxel Type\",\n\t\t\t\t\t     \"Voxel Type (found 16 bits per voxel)\",\n\t\t\t\t\t     vtypes,\n\t\t\t\t\t     0,\n\t\t\t\t\t     false);\n      int idx = vtypes.indexOf(option);\n      if (idx == 1)\n\tm_voxelType = _Short;\n    }\n  else if (bitPerSample == 32)\n    {\n      m_voxelType = _Float;\n\n      QStringList vtypes;\n      vtypes << \"Float\";\n      vtypes << \"Int\";\n      QString option = QInputDialog::getItem(0,\n\t\t\t\t\t     \"Select Voxel Type\",\n\t\t\t\t\t     \"Voxel Type (found 32 bits per voxel)\",\n\t\t\t\t\t     vtypes,\n\t\t\t\t\t     0,\n\t\t\t\t\t     false);\n      int idx = vtypes.indexOf(option);\n      if (idx == 1)\n\tm_voxelType = _Int;\n    }\n\n  m_headerBytes = 0;\n\n  m_bytesPerVoxel = 1;\n  if (m_voxelType == _UChar) m_bytesPerVoxel = 1;\n  else if (m_voxelType == _Char) m_bytesPerVoxel = 1;\n  else if (m_voxelType == _UShort) m_bytesPerVoxel = 2;\n  else if (m_voxelType == _Short) m_bytesPerVoxel = 2;\n  else if (m_voxelType == _Int) m_bytesPerVoxel = 4;\n  else if (m_voxelType == _Float) m_bytesPerVoxel = 4;\n\n  if (m_voxelType == _UChar ||\n      m_voxelType == _Char ||\n      m_voxelType == _UShort ||\n      m_voxelType == _Short)\n    findMinMaxandGenerateHistogram();\n  else\n    {\n      //QMessageBox::information(0, \"Error\",\n      //\t\t       \"Currently accepting only 1- and 2-byte images\");\n      findMinMax();\n      generateHistogram();\n    }\n}",
    "int main(int argc, char** argv)\r\n{\r\n\tTIFF* image;\r\n\tuint32 width, height;\r\n\tint r1, c1, t1, imagesize;\r\n\tint nsamples;\r\n\tunsigned char* scanline = NULL;\r\n\r\n\tuint16 BitsPerSample;           // normally 8 for grayscale image\r\n\tuint16 SamplesPerPixel;         // normally 1 for grayscale image\r\n\tuint16 i;\r\n\r\n\t// Open the TIFF image\r\n\tif ((image = TIFFOpen(argv[1], \"r\")) == NULL) {\r\n\t\tfprintf(stderr, \"Could not open incoming image\\n\");\r\n\t\texit(42);\r\n\t}\r\n\r\n\t// Find the width and height of the image\r\n\tTIFFGetField(image, TIFFTAG_IMAGEWIDTH, &width);\r\n\tTIFFGetField(image, TIFFTAG_IMAGELENGTH, &height);\r\n\tTIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\r\n\tTIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &SamplesPerPixel);\r\n\timagesize = height * width + 1;\t//get image size\r\n\r\n\t//allocate memory for reading tif image\r\n\tscanline = (unsigned char*)_TIFFmalloc(SamplesPerPixel * width);\r\n\tif (scanline == NULL) {\r\n\t\tfprintf(stderr, \"Could not allocate memory!\\n\");\r\n\t\texit(0);\r\n\t}\r\n\r\n\tfprintf(stderr, \"W=%i H=%i BitsPerSample=%i SamplesPerPixel=%i\\n\", width, height, BitsPerSample, SamplesPerPixel);\r\n\tfor (r1 = 0; r1 < height; r1++)\r\n\t{\r\n\t\tTIFFReadScanline(image, scanline, r1, 0);\r\n\t\tfor (c1 = 0; c1 < width; c1++)\r\n\t\t{\r\n\t\t\tt1 = c1 * SamplesPerPixel;\r\n\r\n\t\t\tfor (i = 0; i < SamplesPerPixel; i++)\r\n\t\t\t\tprintf(\"%u \\t\", *(scanline + t1 + i));\r\n\t\t\tprintf(\"\\n\");\r\n\t\t}\r\n\t}\r\n\r\n\t_TIFFfree(scanline); //free allocate memory\r\n\r\n\tTIFFClose(image);\r\n\r\n}",
    "bool loadImageLibTiff(const std::string& path, Image& img)\n{\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetWarningHandlerExt(nullptr);\n\n    TIFF* tif = TIFFOpen(path.c_str(), \"r\");\n\n    if (!tif) return false;\n\n    uint32_t width, height;\n    uint16_t bitspersample = 0, sample_format = SAMPLEFORMAT_UINT, samples = 1;\n\n    // Get the image width and height\n    if (!TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width))\n    {\n        std::cerr << \"The file '\" << path << \"' has no 'TIFFTAG_IMAGEWIDTH'. The file is probably corrupted\\n\";\n        return false;\n    }\n    if (!TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height))\n    {\n        std::cerr << \"The file '\" << path << \"' has no 'TIFFTAG_IMAGELENGTH'. The file is probably corrupted\\n\";\n        return false;\n    }\n    if (!TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample))\n    {\n        std::cerr << \"The file '\" << path << \"' has no 'TIFFTAG_BITSPERSAMPLE'. The file is probably corrupted\\n\";\n        return false;\n    }\n\n    // These tags might actually be not present. In these cases the default values are used.\n    if (!TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sample_format))\n    {\n        sample_format = SAMPLEFORMAT_UINT;\n    }\n    if (!TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samples))\n    {\n        samples = 1;\n    }\n\n\n    ImageType type = ImageType::UC1;\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n    {\n        type = ImageType::F1;\n    }\n    else if (sample_format == SAMPLEFORMAT_UINT)\n    {\n        type = (bitspersample == 8) ? ImageType::UC1 : (bitspersample == 16) ? ImageType::US1 : ImageType::UI1;\n    }\n    else if (sample_format == SAMPLEFORMAT_INT)\n    {\n        type = (bitspersample == 8) ? ImageType::C1 : (bitspersample == 16) ? ImageType::S1 : ImageType::I1;\n    }\n\n\n    if (samples != 1)\n    {\n        std::cout << \"Image '\" << path << \"' has more than one channel. Only loading first channel\\n\";\n        samples = 1;\n    }\n\n    type = (ImageType)((int)type + samples - 1);\n    img.create(height, width, type);\n\n    // size_t buffer_size = TIFFScanlineSize(tif);\n    // SAIGA_ASSERT(buffer_size == img.pitchBytes);\n\n    for (uint32_t row = 0; row < height; ++row)\n    {\n        TIFFReadScanline(tif, img.rowPtr(row), row);\n    }\n\n\n    TIFFClose(tif);\n\n    return true;\n}",
    "bool loadImageFromMemoryLibTiff(const void* data, size_t size, Image& img)\n{\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetWarningHandlerExt(nullptr);\n\n\n    imemstream strm((const char*)data, size);\n    // TIFF* tif = TIFFOpen(path.c_str(), \"r\");\n    TIFF* tif = TIFFStreamOpen(\"balbla\", &strm);\n\n    if (!tif) return false;\n\n    uint32_t width, height;\n    uint16_t bitspersample = 0, sample_format = SAMPLEFORMAT_UINT, samples = 1;\n\n    // Get the image width and height\n    if (!TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width))\n    {\n        return false;\n    }\n    if (!TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height))\n    {\n        return false;\n    }\n    if (!TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample))\n    {\n        return false;\n    }\n\n    // These tags might actually be not present. In these cases the default values are used.\n    if (!TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sample_format))\n    {\n        sample_format = SAMPLEFORMAT_UINT;\n    }\n    if (!TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samples))\n    {\n        samples = 1;\n    }\n\n\n    ImageType type = ImageType::UC1;\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n    {\n        type = ImageType::F1;\n    }\n    else if (sample_format == SAMPLEFORMAT_UINT)\n    {\n        type = (bitspersample == 8) ? ImageType::UC1 : (bitspersample == 16) ? ImageType::US1 : ImageType::UI1;\n    }\n    else if (sample_format == SAMPLEFORMAT_INT)\n    {\n        type = (bitspersample == 8) ? ImageType::C1 : (bitspersample == 16) ? ImageType::S1 : ImageType::I1;\n    }\n\n\n    if (samples != 1)\n    {\n        samples = 1;\n    }\n\n    type = (ImageType)((int)type + samples - 1);\n    img.create(height, width, type);\n\n    // size_t buffer_size = TIFFScanlineSize(tif);\n    // SAIGA_ASSERT(buffer_size == img.pitchBytes);\n\n    for (uint32_t row = 0; row < height; ++row)\n    {\n        TIFFReadScanline(tif, img.rowPtr(row), row);\n    }\n\n\n    TIFFClose(tif);\n\n    return true;\n}",
    "bool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif.get());\n    if (!tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n            if (!tif)\n                delete buf_helper;\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n        if (tif)\n            m_tif.reset(tif, cv_tiffCloseHandle);\n        else\n            m_tif.release();\n    }\n\n    if (tif)\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &wdth));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hght));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n        {\n            bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n            uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n            if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n            {\n                // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n                bpp = 1;\n            }\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n\n            m_width = wdth;\n            m_height = hght;\n            if (ncn == 3 && photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 1:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, wanted_channels);\n                    result = true;\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, wanted_channels);\n                    result = true;\n                    break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}",
    "void Image::LoadTiffFile(const void* pData, size_t Size, IDataBlob* pDstPixels, ImageDesc& Desc)\n{\n    TIFFClientOpenWrapper TiffClientOpenWrpr{pData, Size};\n\n    auto TiffFile = TIFFClientOpen(\"\", \"rm\", &TiffClientOpenWrpr,\n                                   TIFFClientOpenWrapper::TIFFReadProc,\n                                   TIFFClientOpenWrapper::TIFFWriteProc,\n                                   TIFFClientOpenWrapper::TIFFSeekProc,\n                                   TIFFClientOpenWrapper::TIFFCloseProc,\n                                   TIFFClientOpenWrapper::TIFFSizeProc,\n                                   TIFFClientOpenWrapper::TIFFMapFileProc,\n                                   TIFFClientOpenWrapper::TIFFUnmapFileProc);\n\n    TIFFGetField(TiffFile, TIFFTAG_IMAGEWIDTH, &Desc.Width);\n    TIFFGetField(TiffFile, TIFFTAG_IMAGELENGTH, &Desc.Height);\n\n    Uint16 SamplesPerPixel = 0;\n    // SamplesPerPixel is usually 1 for bilevel, grayscale, and palette-color images.\n    // SamplesPerPixel is usually 3 for RGB images. If this value is higher, ExtraSamples\n    // should give an indication of the meaning of the additional channels.\n    TIFFGetField(TiffFile, TIFFTAG_SAMPLESPERPIXEL, &SamplesPerPixel);\n    Desc.NumComponents = SamplesPerPixel;\n\n    Uint16 BitsPerSample = 0;\n    TIFFGetField(TiffFile, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n\n    Uint16 SampleFormat = 0;\n    TIFFGetField(TiffFile, TIFFTAG_SAMPLEFORMAT, &SampleFormat);\n    if (SampleFormat == 0)\n        SampleFormat = SAMPLEFORMAT_UINT;\n\n    switch (SampleFormat)\n    {\n        case SAMPLEFORMAT_UINT:\n            switch (BitsPerSample)\n            {\n                case 8: Desc.ComponentType = VT_UINT8; break;\n                case 16: Desc.ComponentType = VT_UINT16; break;\n                case 32: Desc.ComponentType = VT_UINT32; break;\n                default: LOG_ERROR_AND_THROW(BitsPerSample, \" is not a valid UINT component bit depth. Only 8, 16 and 32 are allowed\");\n            }\n            break;\n\n        case SAMPLEFORMAT_INT:\n            switch (BitsPerSample)\n            {\n                case 8: Desc.ComponentType = VT_INT8; break;\n                case 16: Desc.ComponentType = VT_INT16; break;\n                case 32: Desc.ComponentType = VT_INT32; break;\n                default: LOG_ERROR_AND_THROW(BitsPerSample, \" is not a valid INT component bit depth. Only 8, 16 and 32 are allowed\");\n            }\n            break;\n\n        case SAMPLEFORMAT_IEEEFP:\n            switch (BitsPerSample)\n            {\n                case 16: Desc.ComponentType = VT_FLOAT16; break;\n                case 32: Desc.ComponentType = VT_FLOAT32; break;\n                default: LOG_ERROR_AND_THROW(BitsPerSample, \" is not a valid FLOAT component bit depth. Only 16 and 32 are allowed\");\n            }\n            break;\n\n        case SAMPLEFORMAT_VOID:\n            LOG_ERROR_AND_THROW(\"Untyped tif images are not supported\");\n            break;\n\n        case SAMPLEFORMAT_COMPLEXINT:\n            LOG_ERROR_AND_THROW(\"Complex int tif images are not supported\");\n            break;\n\n        case SAMPLEFORMAT_COMPLEXIEEEFP:\n            LOG_ERROR_AND_THROW(\"Complex floating point tif images are not supported\");\n            break;\n\n        default:\n            LOG_ERROR_AND_THROW(\"Unknown sample format: \", Uint32{SampleFormat});\n    }\n\n    if (pDstPixels != nullptr)\n    {\n        size_t ScanlineSize = TIFFScanlineSize(TiffFile);\n        Desc.RowStride      = AlignUp(Desc.Width * Desc.NumComponents * (BitsPerSample / 8), 4u);\n        pDstPixels->Resize(size_t{Desc.Height} * size_t{Desc.RowStride});\n\n        Uint16 PlanarConfig = 0;\n        TIFFGetField(TiffFile, TIFFTAG_PLANARCONFIG, &PlanarConfig);\n        if (PlanarConfig == PLANARCONFIG_CONTIG || Desc.NumComponents == 1)\n        {\n            VERIFY_EXPR(Desc.RowStride >= ScanlineSize);\n            Uint8* pDataPtr = pDstPixels->GetDataPtr<Uint8>();\n            for (Uint32 row = 0; row < Desc.Height; row++, pDataPtr += Desc.RowStride)\n            {\n                TIFFReadScanline(TiffFile, pDataPtr, row);\n            }\n        }\n        else if (PlanarConfig == PLANARCONFIG_SEPARATE)\n        {\n            std::vector<Uint8> ScanlineData(ScanlineSize);\n            for (Uint32 row = 0; row < Desc.Height; ++row)\n            {\n                for (Uint16 comp = 0; comp < Desc.NumComponents; ++comp)\n                {\n                    Uint8* const pDstRow = pDstPixels->GetDataPtr<Uint8>() + Desc.RowStride * row + comp;\n\n                    TIFFReadScanline(TiffFile, ScanlineData.data(), row, comp);\n\n                    auto CopyComponet = [Width = Desc.Width, NumComp = Desc.NumComponents](const auto* pSrc, auto* pDst) {\n                        for (Uint32 x = 0; x < Width; ++x)\n                        {\n                            pDst[x * NumComp] = pSrc[x];\n                        }\n                    };\n\n                    switch (BitsPerSample)\n                    {\n                        case 8:\n                            CopyComponet(reinterpret_cast<const Uint8*>(ScanlineData.data()), reinterpret_cast<Uint8*>(pDstRow));\n                            break;\n\n                        case 16:\n                            CopyComponet(reinterpret_cast<const Uint16*>(ScanlineData.data()), reinterpret_cast<Uint16*>(pDstRow));\n                            break;\n\n                        case 32:\n                            CopyComponet(reinterpret_cast<const Uint32*>(ScanlineData.data()), reinterpret_cast<Uint32*>(pDstRow));\n                            break;\n\n                        default:\n                            UNEXPECTED(\"Unexpected component bit depth (\", BitsPerSample, \").\");\n                    }\n                }\n            }\n        }\n        else\n        {\n            UNEXPECTED(\"Unexpected planar configuration (\", PlanarConfig, \").\");\n        }\n    }\n\n    TIFFClose(TiffFile);\n}",
    "void GTiffDataset::FillEmptyTiles()\n\n{\n    toff_t *panByteCounts = NULL;\n    int    nBlockCount, iBlock;\n\n    if (!SetDirectory())\n        return;\n\n/* -------------------------------------------------------------------- */\n/*      How many blocks are there in this file?                         */\n/* -------------------------------------------------------------------- */\n    if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockCount = nBlocksPerBand * nBands;\n    else\n        nBlockCount = nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Fetch block maps.                                               */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled( hTIFF ) )\n        TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts );\n    else\n        TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts );\n\n    if (panByteCounts == NULL)\n    {\n        /* Got here with libtiff 3.9.3 and tiff_write_8 test */\n        CPLError(CE_Failure, CPLE_AppDefined, \"FillEmptyTiles() failed because panByteCounts == NULL\");\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Prepare a blank data buffer to write for uninitialized blocks.  */\n/* -------------------------------------------------------------------- */\n    int nBlockBytes;\n\n    if( TIFFIsTiled( hTIFF ) )\n        nBlockBytes = TIFFTileSize(hTIFF);\n    else\n        nBlockBytes = TIFFStripSize(hTIFF);\n\n    GByte *pabyData = (GByte *) VSICalloc(nBlockBytes,1);\n    if (pabyData == NULL)\n    {\n        CPLError(CE_Failure, CPLE_OutOfMemory,\n                 \"Cannot allocate %d bytes\", nBlockBytes);\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check all blocks, writing out data for uninitialized blocks.    */\n/* -------------------------------------------------------------------- */\n    for( iBlock = 0; iBlock < nBlockCount; iBlock++ )\n    {\n        if( panByteCounts[iBlock] == 0 )\n        {\n            if( WriteEncodedTileOrStrip( iBlock, pabyData, FALSE ) != CE_None )\n                break;\n        }\n    }\n\n    CPLFree( pabyData );\n}",
    "CPLErr GTiffDataset::CreateOverviewsFromSrcOverviews(GDALDataset* poSrcDS)\n{\n    CPLAssert(poSrcDS->GetRasterCount() != 0);\n    CPLAssert(nOverviewCount == 0);\n\n/* -------------------------------------------------------------------- */\n/*      Move to the directory for this dataset.                         */\n/* -------------------------------------------------------------------- */\n    if (!SetDirectory())\n        return CE_Failure;\n    FlushDirectory();\n\n    int nOvBitsPerSample = nBitsPerSample;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed, anTGreen, anTBlue;\n    unsigned short      *panRed=NULL, *panGreen=NULL, *panBlue=NULL;\n\n    if( nPhotometric == PHOTOMETRIC_PALETTE && poColorTable != NULL )\n    {\n        int nColors;\n\n        if( nOvBitsPerSample == 8 )\n            nColors = 256;\n        else if( nOvBitsPerSample < 8 )\n            nColors = 1 << nOvBitsPerSample;\n        else\n            nColors = 65536;\n\n        anTRed.resize(nColors,0);\n        anTGreen.resize(nColors,0);\n        anTBlue.resize(nColors,0);\n\n        for( int iColor = 0; iColor < nColors; iColor++ )\n        {\n            if( iColor < poColorTable->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poColorTable->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = (unsigned short) (256 * sRGB.c1);\n                anTGreen[iColor] = (unsigned short) (256 * sRGB.c2);\n                anTBlue[iColor] = (unsigned short) (256 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = anTGreen[iColor] = anTBlue[iColor] = 0;\n            }\n        }\n\n        panRed = &(anTRed[0]);\n        panGreen = &(anTGreen[0]);\n        panBlue = &(anTBlue[0]);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( \"NONE\", this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = NULL;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples, &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew = (uint16*) CPLMalloc(nExtraSamples * sizeof(uint16));\n        memcpy(panExtraSampleValuesNew, panExtraSampleValues, nExtraSamples * sizeof(uint16));\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = NULL;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if ( nCompression == COMPRESSION_LZW ||\n         nCompression == COMPRESSION_ADOBE_DEFLATE )\n        TIFFGetField( hTIFF, TIFFTAG_PREDICTOR, &nPredictor );\n    int nOvrBlockXSize, nOvrBlockYSize;\n    GTIFFGetOverviewBlockSize(&nOvrBlockXSize, &nOvrBlockYSize);\n\n    int nSrcOverviews = poSrcDS->GetRasterBand(1)->GetOverviewCount();\n    int i;\n    CPLErr eErr = CE_None;\n\n    for(i=0;i<nSrcOverviews && eErr == CE_None;i++)\n    {\n        GDALRasterBand* poOvrBand = poSrcDS->GetRasterBand(1)->GetOverview(i);\n\n        int         nOXSize = poOvrBand->GetXSize(), nOYSize = poOvrBand->GetYSize();\n\n        toff_t nOverviewOffset =\n                GTIFFWriteDirectory(hTIFF, FILETYPE_REDUCEDIMAGE,\n                                    nOXSize, nOYSize,\n                                    nOvBitsPerSample, nPlanarConfig,\n                                    nSamplesPerPixel, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                                    nCompression, nPhotometric, nSampleFormat,\n                                    nPredictor,\n                                    panRed, panGreen, panBlue,\n                                    nExtraSamples, panExtraSampleValues,\n                                    osMetadata );\n\n        if( nOverviewOffset == 0 )\n            eErr = CE_Failure;\n        else\n            eErr = RegisterNewOverviewDataset(nOverviewOffset);\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    if (eErr == CE_None)\n        eErr = CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n\n    return eErr;\n}",
    "CPLErr GTiffDataset::IBuildOverviews( \n    const char * pszResampling, \n    int nOverviews, int * panOverviewList,\n    int nBands, int * panBandList,\n    GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    CPLErr       eErr = CE_None;\n    int          i;\n    GTiffDataset *poODS;\n\n/* -------------------------------------------------------------------- */\n/*      If RRD or external OVR overviews requested, then invoke         */\n/*      generic handling.                                               */\n/* -------------------------------------------------------------------- */\n    if( CSLTestBoolean(CPLGetConfigOption( \"USE_RRD\", \"NO\" )) \n        || CSLTestBoolean(CPLGetConfigOption( \"TIFF_USE_OVR\", \"NO\" )) )\n    {\n        return GDALDataset::IBuildOverviews( \n            pszResampling, nOverviews, panOverviewList, \n            nBands, panBandList, pfnProgress, pProgressData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have read access, then create the overviews         */\n/*      externally.                                                     */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() != GA_Update )\n    {\n        CPLDebug( \"GTiff\",\n                  \"File open for read-only accessing, \"\n                  \"creating overviews externally.\" );\n\n        return GDALDataset::IBuildOverviews( \n            pszResampling, nOverviews, panOverviewList, \n            nBands, panBandList, pfnProgress, pProgressData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Our TIFF overview support currently only works safely if all    */\n/*      bands are handled at the same time.                             */\n/* -------------------------------------------------------------------- */\n    if( nBands != GetRasterCount() )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Generation of overviews in TIFF currently only\"\n                  \" supported when operating on all bands.\\n\" \n                  \"Operation failed.\\n\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Initialize progress counter.                                    */\n/* -------------------------------------------------------------------- */\n    if( !pfnProgress( 0.0, NULL, pProgressData ) )\n    {\n        CPLError( CE_Failure, CPLE_UserInterrupt, \"User terminated\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If zero overviews were requested, we need to clear all          */\n/*      existing overviews.                                             */\n/* -------------------------------------------------------------------- */\n    if( nOverviews == 0 )\n    {\n        if( nOverviewCount == 0 )\n            return GDALDataset::IBuildOverviews( \n                pszResampling, nOverviews, panOverviewList, \n                nBands, panBandList, pfnProgress, pProgressData );\n        else\n            return CleanOverviews();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Move to the directory for this dataset.                         */\n/* -------------------------------------------------------------------- */\n    if (!SetDirectory())\n        return CE_Failure;\n    FlushDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      If we are averaging bit data to grayscale we need to create     */\n/*      8bit overviews.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvBitsPerSample = nBitsPerSample;\n\n    if( EQUALN(pszResampling,\"AVERAGE_BIT2\",12) )\n        nOvBitsPerSample = 8;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed, anTGreen, anTBlue;\n    unsigned short      *panRed=NULL, *panGreen=NULL, *panBlue=NULL;\n\n    if( nPhotometric == PHOTOMETRIC_PALETTE && poColorTable != NULL )\n    {\n        int nColors;\n\n        if( nOvBitsPerSample == 8 )\n            nColors = 256;\n        else if( nOvBitsPerSample < 8 )\n            nColors = 1 << nOvBitsPerSample;\n        else\n            nColors = 65536;\n        \n        anTRed.resize(nColors,0);\n        anTGreen.resize(nColors,0);\n        anTBlue.resize(nColors,0);\n        \n        for( int iColor = 0; iColor < nColors; iColor++ )\n        {\n            if( iColor < poColorTable->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poColorTable->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = (unsigned short) (256 * sRGB.c1);\n                anTGreen[iColor] = (unsigned short) (256 * sRGB.c2);\n                anTBlue[iColor] = (unsigned short) (256 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = anTGreen[iColor] = anTBlue[iColor] = 0;\n            }\n        }\n\n        panRed = &(anTRed[0]);\n        panGreen = &(anTGreen[0]);\n        panBlue = &(anTBlue[0]);\n    }\n        \n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( pszResampling, this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = NULL;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples, &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew = (uint16*) CPLMalloc(nExtraSamples * sizeof(uint16));\n        memcpy(panExtraSampleValuesNew, panExtraSampleValues, nExtraSamples * sizeof(uint16));\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = NULL;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if ( nCompression == COMPRESSION_LZW ||\n         nCompression == COMPRESSION_ADOBE_DEFLATE )\n        TIFFGetField( hTIFF, TIFFTAG_PREDICTOR, &nPredictor );\n\n/* -------------------------------------------------------------------- */\n/*      Establish which of the overview levels we already have, and     */\n/*      which are new.  We assume that band 1 of the file is            */\n/*      representative.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvrBlockXSize, nOvrBlockYSize;\n    GTIFFGetOverviewBlockSize(&nOvrBlockXSize, &nOvrBlockYSize);\n    for( i = 0; i < nOverviews && eErr == CE_None; i++ )\n    {\n        int   j;\n\n        for( j = 0; j < nOverviewCount && eErr == CE_None; j++ )\n        {\n            int    nOvFactor;\n\n            poODS = papoOverviewDS[j];\n\n            nOvFactor = (int) \n                (0.5 + GetRasterXSize() / (double) poODS->GetRasterXSize());\n\n            if( nOvFactor == panOverviewList[i] \n                || nOvFactor == TIFF_OvLevelAdjust( panOverviewList[i],\n                                                    GetRasterXSize() ) )\n                panOverviewList[i] *= -1;\n        }\n\n        if( panOverviewList[i] > 0 )\n        {\n            toff_t\tnOverviewOffset;\n            int         nOXSize, nOYSize;\n\n            nOXSize = (GetRasterXSize() + panOverviewList[i] - 1) \n                / panOverviewList[i];\n            nOYSize = (GetRasterYSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n\n            nOverviewOffset = \n                GTIFFWriteDirectory(hTIFF, FILETYPE_REDUCEDIMAGE,\n                                    nOXSize, nOYSize, \n                                    nOvBitsPerSample, nPlanarConfig,\n                                    nSamplesPerPixel, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                                    nCompression, nPhotometric, nSampleFormat, \n                                    nPredictor,\n                                    panRed, panGreen, panBlue,\n                                    nExtraSamples, panExtraSampleValues,\n                                    osMetadata );\n\n\n            if( nOverviewOffset == 0 )\n                eErr = CE_Failure;\n            else\n                eErr = RegisterNewOverviewDataset(nOverviewOffset);\n        }\n        else\n            panOverviewList[i] *= -1;\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    if (eErr == CE_None)\n        eErr = CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n    else\n        return eErr;\n\n/* -------------------------------------------------------------------- */\n/*      Refresh overviews for the mask                                  */\n/* -------------------------------------------------------------------- */\n    if (poMaskDS != NULL &&\n        poMaskDS->GetRasterCount() == 1)\n    {\n        GDALRasterBand **papoOverviewBands;\n        int nMaskOverviews = 0;\n\n        papoOverviewBands = (GDALRasterBand **) CPLCalloc(sizeof(void*),nOverviewCount);\n        for( i = 0; i < nOverviewCount; i++ )\n        {\n            if (papoOverviewDS[i]->poMaskDS != NULL)\n            {\n                papoOverviewBands[nMaskOverviews ++] =\n                        papoOverviewDS[i]->poMaskDS->GetRasterBand(1);\n            }\n        }\n        eErr = GDALRegenerateOverviews( (GDALRasterBandH) \n                                        poMaskDS->GetRasterBand(1),\n                                        nMaskOverviews, \n                                        (GDALRasterBandH *) papoOverviewBands,\n                                        pszResampling, GDALDummyProgress, NULL);\n        CPLFree(papoOverviewBands);\n    }\n\n\n/* -------------------------------------------------------------------- */\n/*      Refresh old overviews that were listed.                         */\n/* -------------------------------------------------------------------- */\n    if (nCompression != COMPRESSION_NONE &&\n        nPlanarConfig == PLANARCONFIG_CONTIG &&\n        GDALDataTypeIsComplex(GetRasterBand( panBandList[0] )->GetRasterDataType()) == FALSE &&\n        GetRasterBand( panBandList[0] )->GetColorTable() == NULL &&\n        (EQUALN(pszResampling, \"NEAR\", 4) || EQUAL(pszResampling, \"AVERAGE\") || EQUAL(pszResampling, \"GAUSS\")))\n    {\n        /* In the case of pixel interleaved compressed overviews, we want to generate */\n        /* the overviews for all the bands block by block, and not band after band, */\n        /* in order to write the block once and not loose space in the TIFF file */\n\n        GDALRasterBand ***papapoOverviewBands;\n        GDALRasterBand  **papoBandList;\n\n        int nNewOverviews = 0;\n        int iBand;\n\n        papapoOverviewBands = (GDALRasterBand ***) CPLCalloc(sizeof(void*),nBands);\n        papoBandList = (GDALRasterBand **) CPLCalloc(sizeof(void*),nBands);\n        for( iBand = 0; iBand < nBands; iBand++ )\n        {\n            GDALRasterBand* poBand = GetRasterBand( panBandList[iBand] );\n\n            papoBandList[iBand] = poBand;\n            papapoOverviewBands[iBand] = (GDALRasterBand **) CPLCalloc(sizeof(void*), poBand->GetOverviewCount());\n\n            int iCurOverview = 0;\n            for( i = 0; i < nOverviews; i++ )\n            {\n                int   j;\n\n                for( j = 0; j < poBand->GetOverviewCount(); j++ )\n                {\n                    int    nOvFactor;\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    nOvFactor = (int) \n                    (0.5 + poBand->GetXSize() / (double) poOverview->GetXSize());\n\n                    int bHasNoData;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if (bHasNoData)\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    if( nOvFactor == panOverviewList[i] \n                        || nOvFactor == TIFF_OvLevelAdjust( panOverviewList[i],\n                                                            poBand->GetXSize() ) )\n                    {\n                        papapoOverviewBands[iBand][iCurOverview] = poOverview;\n                        iCurOverview++ ;\n                        break;\n                    }\n                }\n            }\n\n            if (nNewOverviews == 0)\n                nNewOverviews = iCurOverview;\n            else if (nNewOverviews != iCurOverview)\n            {\n                CPLAssert(0);\n                return CE_Failure;\n            }\n        }\n\n        GDALRegenerateOverviewsMultiBand(nBands, papoBandList,\n                                         nNewOverviews, papapoOverviewBands,\n                                         pszResampling, pfnProgress, pProgressData );\n\n        for( iBand = 0; iBand < nBands; iBand++ )\n        {\n            CPLFree(papapoOverviewBands[iBand]);\n        }\n        CPLFree(papapoOverviewBands);\n        CPLFree(papoBandList);\n    }\n    else\n    {\n        GDALRasterBand **papoOverviewBands;\n\n        papoOverviewBands = (GDALRasterBand **) \n            CPLCalloc(sizeof(void*),nOverviews);\n\n        for( int iBand = 0; iBand < nBands && eErr == CE_None; iBand++ )\n        {\n            GDALRasterBand *poBand;\n            int            nNewOverviews;\n\n            poBand = GetRasterBand( panBandList[iBand] );\n\n            nNewOverviews = 0;\n            for( i = 0; i < nOverviews && poBand != NULL; i++ )\n            {\n                int   j;\n\n                for( j = 0; j < poBand->GetOverviewCount(); j++ )\n                {\n                    int    nOvFactor;\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    int bHasNoData;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if (bHasNoData)\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    nOvFactor = (int) \n                    (0.5 + poBand->GetXSize() / (double) poOverview->GetXSize());\n\n                    if( nOvFactor == panOverviewList[i] \n                        || nOvFactor == TIFF_OvLevelAdjust( panOverviewList[i],\n                                                            poBand->GetXSize() ) )\n                    {\n                        papoOverviewBands[nNewOverviews++] = poOverview;\n                        break;\n                    }\n                }\n            }\n\n            void         *pScaledProgressData;\n\n            pScaledProgressData = \n                GDALCreateScaledProgress( iBand / (double) nBands, \n                                        (iBand+1) / (double) nBands,\n                                        pfnProgress, pProgressData );\n\n            eErr = GDALRegenerateOverviews( (GDALRasterBandH) poBand,\n                                            nNewOverviews, \n                                            (GDALRasterBandH *) papoOverviewBands,\n                                            pszResampling, \n                                            GDALScaledProgress, \n                                            pScaledProgressData);\n\n            GDALDestroyScaledProgress( pScaledProgressData );\n        }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup                                                         */\n    /* -------------------------------------------------------------------- */\n        CPLFree( papoOverviewBands );\n    }\n\n\n    pfnProgress( 1.0, NULL, pProgressData );\n\n    return eErr;\n}",
    "void GTiffDataset::WriteGeoTIFFInfo()\n\n{\n    bool bPixelIsPoint = false;\n    int  bPointGeoIgnore = FALSE;\n\n    if( GetMetadataItem( GDALMD_AREA_OR_POINT ) \n        && EQUAL(GetMetadataItem(GDALMD_AREA_OR_POINT),\n                 GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore = \n            CSLTestBoolean( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                               \"FALSE\") );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the geotransform is the default, don't bother writing it.    */\n/* -------------------------------------------------------------------- */\n    if( adfGeoTransform[0] != 0.0 || adfGeoTransform[1] != 1.0\n        || adfGeoTransform[2] != 0.0 || adfGeoTransform[3] != 0.0\n        || adfGeoTransform[4] != 0.0 || ABS(adfGeoTransform[5]) != 1.0 )\n    {\n        bNeedsRewrite = TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      Clear old tags to ensure we don't end up with conflicting       */\n/*      information. (#2625)                                            */\n/* -------------------------------------------------------------------- */\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOPIXELSCALE );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTIEPOINTS );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTRANSMATRIX );\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Write the transform.  If we have a normal north-up image we     */\n/*      use the tiepoint plus pixelscale otherwise we use a matrix.     */\n/* -------------------------------------------------------------------- */\n\tif( adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0 \n            && adfGeoTransform[5] < 0.0 )\n\t{\n\t    double\tadfPixelScale[3], adfTiePoints[6];\n\n\t    adfPixelScale[0] = adfGeoTransform[1];\n\t    adfPixelScale[1] = fabs(adfGeoTransform[5]);\n\t    adfPixelScale[2] = 0.0;\n\n            if( !EQUAL(osProfile,\"BASELINE\") )\n                TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n\t    \n\t    adfTiePoints[0] = 0.0;\n\t    adfTiePoints[1] = 0.0;\n\t    adfTiePoints[2] = 0.0;\n\t    adfTiePoints[3] = adfGeoTransform[0];\n\t    adfTiePoints[4] = adfGeoTransform[3];\n\t    adfTiePoints[5] = 0.0;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfTiePoints[3] += adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                adfTiePoints[4] += adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n            }\n\t    \n            if( !EQUAL(osProfile,\"BASELINE\") )\n                TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n\t}\n\telse\n\t{\n\t    double\tadfMatrix[16];\n\t    \n\t    memset(adfMatrix,0,sizeof(double) * 16);\n\t    \n\t    adfMatrix[0] = adfGeoTransform[1];\n\t    adfMatrix[1] = adfGeoTransform[2];\n\t    adfMatrix[3] = adfGeoTransform[0];\n\t    adfMatrix[4] = adfGeoTransform[4];\n\t    adfMatrix[5] = adfGeoTransform[5];\n\t    adfMatrix[7] = adfGeoTransform[3];\n\t    adfMatrix[15] = 1.0;\n\t    \n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfMatrix[3] += adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                adfMatrix[7] += adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n            }\n\n            if( !EQUAL(osProfile,\"BASELINE\") )\n                TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n\t}\n\n        // Do we need a world file?\n        if( CSLFetchBoolean( papszCreationOptions, \"TFW\", FALSE ) )\n            GDALWriteWorldFile( osFilename, \"tfw\", adfGeoTransform );\n        else if( CSLFetchBoolean( papszCreationOptions, \"WORLDFILE\", FALSE ) )\n            GDALWriteWorldFile( osFilename, \"wld\", adfGeoTransform );\n    }\n    else if( GetGCPCount() > 0 )\n    {\n\tdouble\t*padfTiePoints;\n\tint\t\tiGCP;\n        bNeedsRewrite = TRUE;\n\t\n\tpadfTiePoints = (double *) \n\t    CPLMalloc( 6 * sizeof(double) * GetGCPCount() );\n\n\tfor( iGCP = 0; iGCP < GetGCPCount(); iGCP++ )\n\t{\n\n\t    padfTiePoints[iGCP*6+0] = pasGCPList[iGCP].dfGCPPixel;\n\t    padfTiePoints[iGCP*6+1] = pasGCPList[iGCP].dfGCPLine;\n\t    padfTiePoints[iGCP*6+2] = 0;\n\t    padfTiePoints[iGCP*6+3] = pasGCPList[iGCP].dfGCPX;\n\t    padfTiePoints[iGCP*6+4] = pasGCPList[iGCP].dfGCPY;\n\t    padfTiePoints[iGCP*6+5] = pasGCPList[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] += 0.5;\n                padfTiePoints[iGCP*6+1] += 0.5;\n            }\n\t}\n\n        if( !EQUAL(osProfile,\"BASELINE\") )\n            TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, \n                          6 * GetGCPCount(), padfTiePoints );\n\tCPLFree( padfTiePoints );\n    }\n\n/* -------------------------------------------------------------------- */\n/*\tWrite out projection definition.\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    if( pszProjection != NULL && !EQUAL( pszProjection, \"\" )\n        && !EQUAL(osProfile,\"BASELINE\") )\n    {\n        GTIF\t*psGTIF;\n\n        bNeedsRewrite = TRUE;\n\n        // If we have existing geokeys, try to wipe them\n        // by writing a dummy goekey directory. (#2546)\n        uint16 *panVI = NULL;\n        uint16 nKeyCount;\n\n        if( TIFFGetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY, \n                          &nKeyCount, &panVI ) )\n        {\n            GUInt16 anGKVersionInfo[4] = { 1, 1, 0, 0 };\n            double  adfDummyDoubleParams[1] = { 0.0 };\n            TIFFSetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY, \n                          4, anGKVersionInfo );\n            TIFFSetField( hTIFF, TIFFTAG_GEODOUBLEPARAMS, \n                          1, adfDummyDoubleParams );\n            TIFFSetField( hTIFF, TIFFTAG_GEOASCIIPARAMS, \"\" );\n        }\n\n        psGTIF = GTIFNew( hTIFF );  \n\n        // set according to coordinate system.\n        GTIFSetFromOGISDefn( psGTIF, pszProjection );\n\n        if( bPixelIsPoint )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n}",
    "int  GTiffDataset::WriteMetadata( GDALDataset *poSrcDS, TIFF *hTIFF,\n                                  int bSrcIsGeoTIFF,\n                                  const char *pszProfile,\n                                  const char *pszTIFFFilename,\n                                  char **papszCreationOptions,\n                                  int bExcludeRPBandIMGFileWriting)\n\n{\n/* -------------------------------------------------------------------- */\n/*      Convert all the remaining metadata into a simple XML            */\n/*      format.                                                         */\n/* -------------------------------------------------------------------- */\n    CPLXMLNode *psRoot = NULL, *psTail = NULL;\n\n    if( bSrcIsGeoTIFF )\n    {\n        WriteMDMetadata( &(((GTiffDataset *)poSrcDS)->oGTiffMDMD), \n                         hTIFF, &psRoot, &psTail, 0, pszProfile );\n    }\n    else\n    {\n        char **papszMD = poSrcDS->GetMetadata();\n\n        if( CSLCount(papszMD) > 0 )\n        {\n            GDALMultiDomainMetadata oMDMD;\n            oMDMD.SetMetadata( papszMD );\n\n            WriteMDMetadata( &oMDMD, hTIFF, &psRoot, &psTail, 0, pszProfile );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle RPC data written to an RPB file.                         */\n/* -------------------------------------------------------------------- */\n    char **papszRPCMD = poSrcDS->GetMetadata(\"RPC\");\n    if( papszRPCMD != NULL && !bExcludeRPBandIMGFileWriting )\n    {\n        if( EQUAL(pszProfile,\"GDALGeoTIFF\") )\n            WriteRPCTag( hTIFF, papszRPCMD );\n\n        if( !EQUAL(pszProfile,\"GDALGeoTIFF\") \n            || CSLFetchBoolean( papszCreationOptions, \"RPB\", FALSE ) )\n        {\n            GDALWriteRPBFile( pszTIFFFilename, papszRPCMD );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle metadata data written to an IMD file.                    */\n/* -------------------------------------------------------------------- */\n    char **papszIMDMD = poSrcDS->GetMetadata(\"IMD\");\n    if( papszIMDMD != NULL && !bExcludeRPBandIMGFileWriting)\n    {\n        GDALWriteIMDFile( pszTIFFFilename, papszIMDMD );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We also need to address band specific metadata, and special     */\n/*      \"role\" metadata.                                                */\n/* -------------------------------------------------------------------- */\n    int nBand;\n    for( nBand = 1; nBand <= poSrcDS->GetRasterCount(); nBand++ )\n    {\n        GDALRasterBand *poBand = poSrcDS->GetRasterBand( nBand );\n\n        if( bSrcIsGeoTIFF )\n        {\n            WriteMDMetadata( &(((GTiffRasterBand *)poBand)->oGTiffMDMD), \n                             hTIFF, &psRoot, &psTail, nBand, pszProfile );\n        }\n        else\n        {\n            char **papszMD = poBand->GetMetadata();\n            \n            if( CSLCount(papszMD) > 0 )\n            {\n                GDALMultiDomainMetadata oMDMD;\n                oMDMD.SetMetadata( papszMD );\n                \n                WriteMDMetadata( &oMDMD, hTIFF, &psRoot, &psTail, nBand,\n                                 pszProfile );\n            }\n        }\n\n        int bSuccess;\n        double dfOffset = poBand->GetOffset( &bSuccess );\n        double dfScale = poBand->GetScale();\n\n        if( bSuccess && (dfOffset != 0.0 || dfScale != 1.0) )\n        {\n            char szValue[128];\n\n            sprintf( szValue, \"%.18g\", dfOffset );\n            AppendMetadataItem( &psRoot, &psTail, \"OFFSET\", szValue, nBand, \n                                \"offset\", \"\" );\n            sprintf( szValue, \"%.18g\", dfScale );\n            AppendMetadataItem( &psRoot, &psTail, \"SCALE\", szValue, nBand, \n                                \"scale\", \"\" );\n        }\n\n        const char* pszUnitType = poBand->GetUnitType();\n        if (pszUnitType != NULL && pszUnitType[0] != '\\0')\n            AppendMetadataItem( &psRoot, &psTail, \"UNITTYPE\", pszUnitType, nBand, \n                                \"unittype\", \"\" );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the generic XML metadata if there is any.             */\n/* -------------------------------------------------------------------- */\n    if( psRoot != NULL )\n    {\n        int bRet = TRUE;\n\n        if( EQUAL(pszProfile,\"GDALGeoTIFF\") )\n        {\n            char *pszXML_MD = CPLSerializeXMLTree( psRoot );\n            if( strlen(pszXML_MD) > 32000 )\n            {\n                if( bSrcIsGeoTIFF )\n                    ((GTiffDataset *) poSrcDS)->PushMetadataToPam();\n                else\n                    bRet = FALSE;\n                CPLError( CE_Warning, CPLE_AppDefined, \n                          \"Lost metadata writing to GeoTIFF ... too large to fit in tag.\" );\n            }\n            else\n            {\n                TIFFSetField( hTIFF, TIFFTAG_GDAL_METADATA, pszXML_MD );\n            }\n            CPLFree( pszXML_MD );\n        }\n        else\n        {\n            if( bSrcIsGeoTIFF )\n                ((GTiffDataset *) poSrcDS)->PushMetadataToPam();\n            else\n                bRet = FALSE;\n        }\n\n        CPLDestroyXMLNode( psRoot );\n\n        return bRet;\n    }\n    else\n    {\n        /* If we have no more metadata but it existed before, remove the GDAL_METADATA tag */\n        if( EQUAL(pszProfile,\"GDALGeoTIFF\") )\n        {\n            char* pszText = NULL;\n            if( TIFFGetField( hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n            {\n#ifdef HAVE_UNSETFIELD\n                TIFFUnsetField( hTIFF, TIFFTAG_GDAL_METADATA );\n#else\n                TIFFSetField( hTIFF, TIFFTAG_GDAL_METADATA, \"\" );\n#endif\n            }\n        }\n    }\n\n    return TRUE;\n}",
    "int GTiffDataset::SetDirectory( toff_t nNewOffset )\n\n{\n    Crystalize();\n\n    FlushBlockBuf();\n\n    if( nNewOffset == 0 )\n        nNewOffset = nDirOffset;\n\n    if( TIFFCurrentDirOffset(hTIFF) == nNewOffset )\n    {\n        CPLAssert( *ppoActiveDSRef == this || *ppoActiveDSRef == NULL );\n        *ppoActiveDSRef = this;\n        return TRUE;\n    }\n\n    if( GetAccess() == GA_Update )\n    {\n        if( *ppoActiveDSRef != NULL )\n            (*ppoActiveDSRef)->FlushDirectory();\n    }\n    \n    if( nNewOffset == 0)\n        return TRUE;\n\n    (*ppoActiveDSRef) = this;\n\n    int nSetDirResult = TIFFSetSubDirectory( hTIFF, nNewOffset );\n    if (!nSetDirResult)\n        return nSetDirResult;\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n    \n    if( nCompression == COMPRESSION_JPEG \n        && nPhotometric == PHOTOMETRIC_YCBCR \n        && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode;\n\n        TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode );\n        if( nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Propogate any quality settings.                                 */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() == GA_Update )\n    {\n        // Now, reset zip and jpeg quality.\n        if(nJpegQuality > 0 && nCompression == COMPRESSION_JPEG)\n        {\n            CPLDebug( \"GTiff\", \"Propgate JPEG_QUALITY(%d) in SetDirectory()\",\n                      nJpegQuality );\n            TIFFSetField(hTIFF, TIFFTAG_JPEGQUALITY, nJpegQuality); \n        }\n        if(nZLevel > 0 && nCompression == COMPRESSION_ADOBE_DEFLATE)\n            TIFFSetField(hTIFF, TIFFTAG_ZIPQUALITY, nZLevel);\n        if(nLZMAPreset > 0 && nCompression == COMPRESSION_LZMA)\n            TIFFSetField(hTIFF, TIFFTAG_LZMAPRESET, nLZMAPreset);\n    }\n\n    return nSetDirResult;\n}",
    "CPLErr GTiffDataset::OpenOffset( TIFF *hTIFFIn, \n                                 GTiffDataset **ppoActiveDSRef,\n                                 toff_t nDirOffsetIn, \n\t\t\t\t int bBaseIn, GDALAccess eAccess,\n                                 int bAllowRGBAInterface,\n                                 int bReadGeoTransform,\n                                 char** papszSiblingFiles )\n\n{\n    uint32\tnXSize, nYSize;\n    int\t\tbTreatAsBitmap = FALSE;\n    int         bTreatAsOdd = FALSE;\n\n    this->eAccess = eAccess;\n\n    hTIFF = hTIFFIn;\n    this->ppoActiveDSRef = ppoActiveDSRef;\n\n    nDirOffset = nDirOffsetIn;\n\n    if (!SetDirectory( nDirOffsetIn ))\n        return CE_Failure;\n\n    bBase = bBaseIn;\n\n    this->eAccess = eAccess;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some information from the file that is of interest.     */\n/* -------------------------------------------------------------------- */\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    nRasterXSize = nXSize;\n    nRasterYSize = nYSize;\n\n    if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSamplesPerPixel ) )\n        nBands = 1;\n    else\n        nBands = nSamplesPerPixel;\n    \n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &(nBitsPerSample)) )\n        nBitsPerSample = 1;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &(nPlanarConfig) ) )\n        nPlanarConfig = PLANARCONFIG_CONTIG;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLEFORMAT, &(nSampleFormat) ) )\n        nSampleFormat = SAMPLEFORMAT_UINT;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n    \n#if defined(TIFFLIB_VERSION) && TIFFLIB_VERSION > 20031007 /* 3.6.0 */\n    if (nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(nCompression))\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Cannot open TIFF file due to missing codec.\" );\n        return CE_Failure;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( nCompression == COMPRESSION_JPEG \n        && nPhotometric == PHOTOMETRIC_YCBCR \n        && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode;\n\n        SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\" );\n        if ( !TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n              nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get strip/tile layout.                                          */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled(hTIFF) )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(nBlockXSize) );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(nRowsPerStrip) ) )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined, \n                      \"RowsPerStrip not defined ... assuming all one strip.\" );\n            nRowsPerStrip = nYSize; /* dummy value */\n        }\n\n        nBlockXSize = nRasterXSize;\n        nBlockYSize = MIN(nRowsPerStrip,nYSize);\n    }\n        \n    nBlocksPerBand =\n        ((nYSize + nBlockYSize - 1) / nBlockYSize)\n        * ((nXSize + nBlockXSize  - 1) / nBlockXSize);\n\n/* -------------------------------------------------------------------- */\n/*      Should we handle this using the GTiffBitmapBand?                */\n/* -------------------------------------------------------------------- */\n    if( nBitsPerSample == 1 && nBands == 1 )\n    {\n        bTreatAsBitmap = TRUE;\n\n        // Lets treat large \"one row\" bitmaps using the scanline api.\n        if( !TIFFIsTiled(hTIFF) \n            && nBlockYSize == nYSize \n            && nYSize > 2000 \n            && bAllowRGBAInterface )\n            bTreatAsSplitBitmap = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the RGBA interface?                    */\n/* -------------------------------------------------------------------- */\n    if( bAllowRGBAInterface &&\n        !bTreatAsBitmap && !(nBitsPerSample > 8) \n        && (nPhotometric == PHOTOMETRIC_CIELAB ||\n            nPhotometric == PHOTOMETRIC_LOGL ||\n            nPhotometric == PHOTOMETRIC_LOGLUV ||\n            nPhotometric == PHOTOMETRIC_SEPARATED ||\n            ( nPhotometric == PHOTOMETRIC_YCBCR \n              && nCompression != COMPRESSION_JPEG )) )\n    {\n        char\tszMessage[1024];\n\n        if( TIFFRGBAImageOK( hTIFF, szMessage ) == 1 )\n        {\n            const char* pszSourceColorSpace = NULL;\n            switch (nPhotometric)\n            {\n                case PHOTOMETRIC_CIELAB:\n                    pszSourceColorSpace = \"CIELAB\";\n                    break;\n                case PHOTOMETRIC_LOGL:\n                    pszSourceColorSpace = \"LOGL\";\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    pszSourceColorSpace = \"LOGLUV\";\n                    break;\n                case PHOTOMETRIC_SEPARATED:\n                    pszSourceColorSpace = \"CMYK\";\n                    break;\n                case PHOTOMETRIC_YCBCR:\n                    pszSourceColorSpace = \"YCbCr\";\n                    break;\n            }\n            if (pszSourceColorSpace)\n                SetMetadataItem( \"SOURCE_COLOR_SPACE\", pszSourceColorSpace, \"IMAGE_STRUCTURE\" );\n            bTreatAsRGBA = TRUE;\n            nBands = 4;\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"TIFFRGBAImageOK says:\\n%s\", szMessage );\n        }\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the split interface?                   */\n/* -------------------------------------------------------------------- */\n    if( !TIFFIsTiled(hTIFF) \n        && nBitsPerSample == 8\n        && nBlockYSize == nYSize \n        && nYSize > 2000\n        && !bTreatAsRGBA \n        && CSLTestBoolean(CPLGetConfigOption(\"GDAL_ENABLE_TIFF_SPLIT\", \"YES\")))\n    {\n        /* libtiff 3.9.2 (20091104) and older, libtiff 4.0.0beta5 (also 20091104) */\n        /* and older will crash when trying to open a all-in-one-strip */\n        /* YCbCr JPEG compressed TIFF (see #3259). */\n#if (TIFFLIB_VERSION <= 20091104 && !defined(BIGTIFF_SUPPORT)) || \\\n    (TIFFLIB_VERSION <= 20091104 && defined(BIGTIFF_SUPPORT))\n        if (nPhotometric == PHOTOMETRIC_YCBCR  &&\n            nCompression == COMPRESSION_JPEG)\n        {\n            CPLDebug(\"GTiff\", \"Avoid using split band to open all-in-one-strip \"\n                              \"YCbCr JPEG compressed TIFF because of older libtiff\");\n        }\n        else\n#endif\n            bTreatAsSplit = TRUE;\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the odd bits interface?                */\n/* -------------------------------------------------------------------- */\n    if ( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n    {\n        if ( nBitsPerSample == 16 || nBitsPerSample == 24 )\n            bTreatAsOdd = TRUE;\n    }\n    else if ( !bTreatAsRGBA && !bTreatAsBitmap\n              && nBitsPerSample != 8\n              && nBitsPerSample != 16\n              && nBitsPerSample != 32\n              && nBitsPerSample != 64 \n              && nBitsPerSample != 128 )\n        bTreatAsOdd = TRUE;\n\n    int bMinIsWhite = nPhotometric == PHOTOMETRIC_MINISWHITE;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the color table if there is one.                        */\n/* -------------------------------------------------------------------- */\n    unsigned short\t*panRed, *panGreen, *panBlue;\n\n    if( bTreatAsRGBA \n        || TIFFGetField( hTIFF, TIFFTAG_COLORMAP, \n                         &panRed, &panGreen, &panBlue) == 0 )\n    {\n\t// Build inverted palette if we have inverted photometric.\n\t// Pixel values remains unchanged.  Avoid doing this for *deep*\n        // data types (per #1882)\n\tif( nBitsPerSample <= 16 && nPhotometric == PHOTOMETRIC_MINISWHITE )\n\t{\n\t    GDALColorEntry  oEntry;\n\t    int\t\t    iColor, nColorCount;\n\t    \n\t    poColorTable = new GDALColorTable();\n\t    nColorCount = 1 << nBitsPerSample;\n\n\t    for ( iColor = 0; iColor < nColorCount; iColor++ )\n\t    {\n\t\toEntry.c1 = oEntry.c2 = oEntry.c3 = (short) \n                    ((255 * (nColorCount - 1 - iColor)) / (nColorCount-1));\n\t\toEntry.c4 = 255;\n\t\tpoColorTable->SetColorEntry( iColor, &oEntry );\n\t    }\n\n\t    nPhotometric = PHOTOMETRIC_PALETTE;\n\t}\n\telse\n\t    poColorTable = NULL;\n    }\n    else\n    {\n        int\tnColorCount, nMaxColor = 0;\n        GDALColorEntry oEntry;\n\n        poColorTable = new GDALColorTable();\n\n        nColorCount = 1 << nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            oEntry.c1 = panRed[iColor] / 256;\n            oEntry.c2 = panGreen[iColor] / 256;\n            oEntry.c3 = panBlue[iColor] / 256;\n            oEntry.c4 = 255;\n\n            poColorTable->SetColorEntry( iColor, &oEntry );\n\n            nMaxColor = MAX(nMaxColor,panRed[iColor]);\n            nMaxColor = MAX(nMaxColor,panGreen[iColor]);\n            nMaxColor = MAX(nMaxColor,panBlue[iColor]);\n        }\n\n        // Bug 1384 - Some TIFF files are generated with color map entry\n        // values in range 0-255 instead of 0-65535 - try to handle these\n        // gracefully.\n        if( nMaxColor > 0 && nMaxColor < 256 )\n        {\n            CPLDebug( \"GTiff\", \"TIFF ColorTable seems to be improperly scaled, fixing up.\" );\n            \n            for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n            {\n                oEntry.c1 = panRed[iColor];\n                oEntry.c2 = panGreen[iColor];\n                oEntry.c3 = panBlue[iColor];\n                oEntry.c4 = 255;\n                \n                poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n        }\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < nBands; iBand++ )\n    {\n        if( bTreatAsRGBA )\n            SetBand( iBand+1, new GTiffRGBABand( this, iBand+1 ) );\n        else if( bTreatAsSplitBitmap )\n            SetBand( iBand+1, new GTiffSplitBitmapBand( this, iBand+1 ) );\n        else if( bTreatAsSplit )\n            SetBand( iBand+1, new GTiffSplitBand( this, iBand+1 ) );\n        else if( bTreatAsBitmap )\n            SetBand( iBand+1, new GTiffBitmapBand( this, iBand+1 ) );\n        else if( bTreatAsOdd )\n            SetBand( iBand+1, new GTiffOddBitsBand( this, iBand+1 ) );\n        else\n            SetBand( iBand+1, new GTiffRasterBand( this, iBand+1 ) );\n    }\n\n    if( GetRasterBand(1)->GetRasterDataType() == GDT_Unknown )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Unsupported TIFF configuration.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get the transform or gcps from the GeoTIFF file.                */\n/* -------------------------------------------------------------------- */\n    if( bReadGeoTransform )\n    {\n        char    *pszTabWKT = NULL;\n        double\t*padfTiePoints, *padfScale, *padfMatrix;\n        uint16\tnCount;\n        bool    bPixelIsPoint = false;\n        short nRasterType;\n        GTIF\t*psGTIF;\n        int     bPointGeoIgnore = FALSE;\n\n        psGTIF = GTIFNew( hTIFF ); // I wonder how expensive this is?\n\n        if( psGTIF )\n        {\n            if( GTIFKeyGet(psGTIF, GTRasterTypeGeoKey, &nRasterType,\n                        0, 1 ) == 1\n                && nRasterType == (short) RasterPixelIsPoint )\n            {\n                bPixelIsPoint = true;\n                bPointGeoIgnore =\n                    CSLTestBoolean( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                                    \"FALSE\") );\n            }\n\n            GTIFFree( psGTIF );\n        }\n\n        adfGeoTransform[0] = 0.0;\n        adfGeoTransform[1] = 1.0;\n        adfGeoTransform[2] = 0.0;\n        adfGeoTransform[3] = 0.0;\n        adfGeoTransform[4] = 0.0;\n        adfGeoTransform[5] = 1.0;\n    \n        if( TIFFGetField(hTIFF,TIFFTAG_GEOPIXELSCALE,&nCount,&padfScale )\n            && nCount >= 2 \n            && padfScale[0] != 0.0 && padfScale[1] != 0.0 )\n        {\n            adfGeoTransform[1] = padfScale[0];\n            adfGeoTransform[5] = - ABS(padfScale[1]);\n\n            if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n                && nCount >= 6 )\n            {\n                adfGeoTransform[0] =\n                    padfTiePoints[3] - padfTiePoints[0] * adfGeoTransform[1];\n                adfGeoTransform[3] =\n                    padfTiePoints[4] - padfTiePoints[1] * adfGeoTransform[5];\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfGeoTransform[0] -= (adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5);\n                    adfGeoTransform[3] -= (adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5);\n                }\n\n                bGeoTransformValid = TRUE;\n            }\n        }\n\n        else if( TIFFGetField(hTIFF,TIFFTAG_GEOTRANSMATRIX,&nCount,&padfMatrix ) \n                 && nCount == 16 )\n        {\n            adfGeoTransform[0] = padfMatrix[3];\n            adfGeoTransform[1] = padfMatrix[0];\n            adfGeoTransform[2] = padfMatrix[1];\n            adfGeoTransform[3] = padfMatrix[7];\n            adfGeoTransform[4] = padfMatrix[4];\n            adfGeoTransform[5] = padfMatrix[5];\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfGeoTransform[0] -= (adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5);\n                adfGeoTransform[3] -= (adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5);\n            }\n\n            bGeoTransformValid = TRUE;\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise try looking for a .tfw, .tifw or .wld file.           */\n/* -------------------------------------------------------------------- */\n        else\n        {\n            char* pszWldFilename = NULL;\n\n            bGeoTransformValid =\n                GDALReadWorldFile2( osFilename, NULL, adfGeoTransform,\n                                    papszSiblingFiles, &pszWldFilename);\n\n            if( !bGeoTransformValid )\n            {\n                bGeoTransformValid =\n                    GDALReadWorldFile2( osFilename, \"wld\", adfGeoTransform,\n                                        papszSiblingFiles, &pszWldFilename);\n            }\n\n            if( !bGeoTransformValid )\n            {\n                int bTabFileOK =\n                    GDALReadTabFile2( osFilename, adfGeoTransform,\n                                      &pszTabWKT, &nGCPCount, &pasGCPList,\n                                      papszSiblingFiles, &pszWldFilename );\n\n                if( bTabFileOK && nGCPCount == 0 )\n                    bGeoTransformValid = TRUE;\n            }\n\n            if (pszWldFilename)\n            {\n                osWldFilename = pszWldFilename;\n                CPLFree(pszWldFilename);\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Check for GCPs.  Note, we will allow there to be GCPs and a     */\n/*      transform in some circumstances.                                */\n/* -------------------------------------------------------------------- */\n        if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && !bGeoTransformValid )\n        {\n            nGCPCount = nCount / 6;\n            pasGCPList = (GDAL_GCP *) CPLCalloc(sizeof(GDAL_GCP),nGCPCount);\n        \n            for( int iGCP = 0; iGCP < nGCPCount; iGCP++ )\n            {\n                char\tszID[32];\n\n                sprintf( szID, \"%d\", iGCP+1 );\n                pasGCPList[iGCP].pszId = CPLStrdup( szID );\n                pasGCPList[iGCP].pszInfo = CPLStrdup(\"\");\n                pasGCPList[iGCP].dfGCPPixel = padfTiePoints[iGCP*6+0];\n                pasGCPList[iGCP].dfGCPLine = padfTiePoints[iGCP*6+1];\n                pasGCPList[iGCP].dfGCPX = padfTiePoints[iGCP*6+3];\n                pasGCPList[iGCP].dfGCPY = padfTiePoints[iGCP*6+4];\n                pasGCPList[iGCP].dfGCPZ = padfTiePoints[iGCP*6+5];\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    pasGCPList[iGCP].dfGCPPixel -= 0.5;\n                    pasGCPList[iGCP].dfGCPLine -= 0.5;\n                }\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Did we find a tab file?  If so we will use it's coordinate      */\n/*      system and give it precidence.                                  */\n/* -------------------------------------------------------------------- */\n        if( pszTabWKT != NULL \n            && (pszProjection == NULL || pszProjection[0] == '\\0') )\n        {\n            CPLFree( pszProjection );\n            pszProjection = pszTabWKT;\n            pszTabWKT = NULL;\n            bLookedForProjection = TRUE;\n        }\n        \n        CPLFree( pszTabWKT );\n        bGeoTIFFInfoChanged = FALSE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture some other potentially interesting information.         */\n/* -------------------------------------------------------------------- */\n    char\t*pszText, szWorkMDI[200];\n    float   fResolution;\n    uint16  nShort;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_DOCUMENTNAME, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_DOCUMENTNAME\",  pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_IMAGEDESCRIPTION, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_IMAGEDESCRIPTION\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_SOFTWARE, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_SOFTWARE\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_DATETIME, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_DATETIME\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_ARTIST, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_ARTIST\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_HOSTCOMPUTER, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_HOSTCOMPUTER\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_COPYRIGHT, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_COPYRIGHT\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_XRESOLUTION, &fResolution ) )\n    {\n        sprintf( szWorkMDI, \"%.8g\", fResolution );\n        SetMetadataItem( \"TIFFTAG_XRESOLUTION\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_YRESOLUTION, &fResolution ) )\n    {\n        sprintf( szWorkMDI, \"%.8g\", fResolution );\n        SetMetadataItem( \"TIFFTAG_YRESOLUTION\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_MINSAMPLEVALUE, &nShort ) )\n    {\n        sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_MINSAMPLEVALUE\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_MAXSAMPLEVALUE, &nShort ) )\n    {\n        sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_MAXSAMPLEVALUE\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, &nShort ) )\n    {\n        if( nShort == RESUNIT_NONE )\n            sprintf( szWorkMDI, \"%d (unitless)\", nShort );\n        else if( nShort == RESUNIT_INCH )\n            sprintf( szWorkMDI, \"%d (pixels/inch)\", nShort );\n        else if( nShort == RESUNIT_CENTIMETER )\n            sprintf( szWorkMDI, \"%d (pixels/cm)\", nShort );\n        else\n            sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_RESOLUTIONUNIT\", szWorkMDI );\n    }\n\n    if( nCompression == COMPRESSION_NONE )\n        /* no compression tag */;\n    else if( nCompression == COMPRESSION_CCITTRLE )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTRLE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTFAX3 )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTFAX3\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTFAX4 )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTFAX4\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_LZW )\n        SetMetadataItem( \"COMPRESSION\", \"LZW\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_OJPEG )\n        SetMetadataItem( \"COMPRESSION\", \"OJPEG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JPEG )\n    {  \n        if ( nPhotometric == PHOTOMETRIC_YCBCR )\n            SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\", \"IMAGE_STRUCTURE\" );\n        else\n            SetMetadataItem( \"COMPRESSION\", \"JPEG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_NEXT )\n        SetMetadataItem( \"COMPRESSION\", \"NEXT\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTRLEW )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTRLEW\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PACKBITS )\n        SetMetadataItem( \"COMPRESSION\", \"PACKBITS\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_THUNDERSCAN )\n        SetMetadataItem( \"COMPRESSION\", \"THUNDERSCAN\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PIXARFILM )\n        SetMetadataItem( \"COMPRESSION\", \"PIXARFILM\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PIXARLOG )\n        SetMetadataItem( \"COMPRESSION\", \"PIXARLOG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_DEFLATE )\n        SetMetadataItem( \"COMPRESSION\", \"DEFLATE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_ADOBE_DEFLATE )\n        SetMetadataItem( \"COMPRESSION\", \"DEFLATE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_DCS )\n        SetMetadataItem( \"COMPRESSION\", \"DCS\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JBIG )\n        SetMetadataItem( \"COMPRESSION\", \"JBIG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_SGILOG )\n        SetMetadataItem( \"COMPRESSION\", \"SGILOG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_SGILOG24 )\n        SetMetadataItem( \"COMPRESSION\", \"SGILOG24\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JP2000 )\n        SetMetadataItem( \"COMPRESSION\", \"JP2000\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_LZMA )\n        SetMetadataItem( \"COMPRESSION\", \"LZMA\", \"IMAGE_STRUCTURE\" );\n\n    else\n    {\n        CPLString oComp;\n        SetMetadataItem( \"COMPRESSION\", \n                         (const char *) oComp.Printf( \"%d\", nCompression));\n    }\n\n    if( nPlanarConfig == PLANARCONFIG_CONTIG && nBands != 1 )\n        SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    if(  (GetRasterBand(1)->GetRasterDataType() == GDT_Byte   && nBitsPerSample != 8 ) ||\n         (GetRasterBand(1)->GetRasterDataType() == GDT_UInt16 && nBitsPerSample != 16) ||\n         (GetRasterBand(1)->GetRasterDataType() == GDT_UInt32 && nBitsPerSample != 32) )\n    {\n        for (int i = 0; i < nBands; ++i)\n            GetRasterBand(i+1)->SetMetadataItem( \"NBITS\", \n                                                 CPLString().Printf( \"%d\", (int)nBitsPerSample ),\n                                                 \"IMAGE_STRUCTURE\" );\n    }\n        \n    if( bMinIsWhite )\n        SetMetadataItem( \"MINISWHITE\", \"YES\", \"IMAGE_STRUCTURE\" );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n    {\n        CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n        CPLXMLNode *psItem = NULL;\n\n        if( psRoot != NULL && psRoot->eType == CXT_Element\n            && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n            psItem = psRoot->psChild;\n\n        for( ; psItem != NULL; psItem = psItem->psNext )\n        {\n            const char *pszKey, *pszValue, *pszRole, *pszDomain; \n            char *pszUnescapedValue;\n            int nBand, bIsXML = FALSE;\n\n            if( psItem->eType != CXT_Element\n                || !EQUAL(psItem->pszValue,\"Item\") )\n                continue;\n\n            pszKey = CPLGetXMLValue( psItem, \"name\", NULL );\n            pszValue = CPLGetXMLValue( psItem, NULL, NULL );\n            nBand = atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" )) + 1;\n            pszRole = CPLGetXMLValue( psItem, \"role\", \"\" );\n            pszDomain = CPLGetXMLValue( psItem, \"domain\", \"\" );\n                \n            if( pszKey == NULL || pszValue == NULL )\n                continue;\n\n            if( EQUALN(pszDomain,\"xml:\",4) )\n                bIsXML = TRUE;\n\n            pszUnescapedValue = CPLUnescapeString( pszValue, NULL, \n                                                   CPLES_XML );\n            if( nBand == 0 )\n            {\n                if( bIsXML )\n                {\n                    char *apszMD[2] = { pszUnescapedValue, NULL };\n                    SetMetadata( apszMD, pszDomain );\n                }\n                else\n                    SetMetadataItem( pszKey, pszUnescapedValue, pszDomain );\n            }\n            else\n            {\n                GDALRasterBand *poBand = GetRasterBand(nBand);\n                if( poBand != NULL )\n                {\n                    if( EQUAL(pszRole,\"scale\") )\n                        poBand->SetScale( CPLAtofM(pszUnescapedValue) );\n                    else if( EQUAL(pszRole,\"offset\") )\n                        poBand->SetOffset( CPLAtofM(pszUnescapedValue) );\n                    else if( EQUAL(pszRole,\"unittype\") )\n                        poBand->SetUnitType( pszUnescapedValue );\n                    else\n                    {\n                        if( bIsXML )\n                        {\n                            char *apszMD[2] = { pszUnescapedValue, NULL };\n                            poBand->SetMetadata( apszMD, pszDomain );\n                        }\n                        else\n                            poBand->SetMetadataItem(pszKey,pszUnescapedValue,\n                                                    pszDomain );\n                    }\n                }\n            }\n            CPLFree( pszUnescapedValue );\n        }\n\n        CPLDestroyXMLNode( psRoot );\n    }\n\n    bMetadataChanged = FALSE;\n\n/* -------------------------------------------------------------------- */\n/*      Check for NODATA                                                */\n/* -------------------------------------------------------------------- */\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_NODATA, &pszText ) )\n    {\n        bNoDataSet = TRUE;\n        dfNoDataValue = CPLAtofM( pszText );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If this is a \"base\" raster, we should scan for any              */\n/*      associated overviews, internal mask bands and subdatasets.      */\n/* -------------------------------------------------------------------- */\n    if( bBase )\n    {\n        char **papszSubdatasets = NULL;\n        int  iDirIndex = 0;\n\n        FlushDirectory();  \n        while( !TIFFLastDirectory( hTIFF ) \n               && (iDirIndex == 0 || TIFFReadDirectory( hTIFF ) != 0) )\n        {\n            toff_t\tnThisDir = TIFFCurrentDirOffset(hTIFF);\n            uint32\tnSubType = 0;\n\n            *ppoActiveDSRef = NULL; // our directory no longer matches this ds\n            \n            iDirIndex++;\n\n            if( !TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n                nSubType = 0;\n\n            /* Embedded overview of the main image */\n            if ((nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                (nSubType & FILETYPE_MASK) == 0 &&\n                iDirIndex != 1 )\n            {\n                GTiffDataset\t*poODS;\n                \n                poODS = new GTiffDataset();\n                if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE, \n                                       eAccess ) != CE_None \n                    || poODS->GetRasterCount() != GetRasterCount() )\n                {\n                    delete poODS;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened %dx%d overview.\\n\", \n                              poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                    nOverviewCount++;\n                    papoOverviewDS = (GTiffDataset **)\n                        CPLRealloc(papoOverviewDS, \n                                   nOverviewCount * (sizeof(void*)));\n                    papoOverviewDS[nOverviewCount-1] = poODS;\n                    poODS->poBaseDS = this;\n                }\n            }\n            \n            /* Embedded mask of the main image */\n            else if ((nSubType & FILETYPE_MASK) != 0 &&\n                     (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                     poMaskDS == NULL )\n            {\n                poMaskDS = new GTiffDataset();\n                \n                /* The TIFF6 specification - page 37 - only allows 1 SamplesPerPixel and 1 BitsPerSample\n                   Here we support either 1 or 8 bit per sample\n                   and we support either 1 sample per pixel or as many samples as in the main image\n                   We don't check the value of the PhotometricInterpretation tag, which should be\n                   set to \"Transparency mask\" (4) according to the specification (page 36)\n                   ... But the TIFF6 specification allows image masks to have a higher resolution than\n                   the main image, what we don't support here\n                */\n\n                if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, \n                                          FALSE, eAccess ) != CE_None \n                    || poMaskDS->GetRasterCount() == 0\n                    || !(poMaskDS->GetRasterCount() == 1 || poMaskDS->GetRasterCount() == GetRasterCount())\n                    || poMaskDS->GetRasterXSize() != GetRasterXSize()\n                    || poMaskDS->GetRasterYSize() != GetRasterYSize()\n                    || poMaskDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poMaskDS;\n                    poMaskDS = NULL;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened band mask.\\n\");\n                    poMaskDS->poBaseDS = this;\n                    \n                    poMaskDS->bPromoteTo8Bits = CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n                }\n            }\n            \n            /* Embedded mask of an overview */\n            /* The TIFF6 specification allows the combination of the FILETYPE_xxxx masks */\n            else if ((nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                     (nSubType & FILETYPE_MASK) != 0)\n            {\n                GTiffDataset* poDS = new GTiffDataset();\n                if( poDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE, \n                                      eAccess ) != CE_None\n                    || poDS->GetRasterCount() == 0\n                    || poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poDS;\n                }\n                else\n                {\n                    int i;\n                    for(i=0;i<nOverviewCount;i++)\n                    {\n                        if (((GTiffDataset*)papoOverviewDS[i])->poMaskDS == NULL &&\n                            poDS->GetRasterXSize() == papoOverviewDS[i]->GetRasterXSize() &&\n                            poDS->GetRasterYSize() == papoOverviewDS[i]->GetRasterYSize() &&\n                            (poDS->GetRasterCount() == 1 || poDS->GetRasterCount() == GetRasterCount()))\n                        {\n                            CPLDebug( \"GTiff\", \"Opened band mask for %dx%d overview.\\n\",\n                                      poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                            ((GTiffDataset*)papoOverviewDS[i])->poMaskDS = poDS;\n                            poDS->bPromoteTo8Bits = CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n                            poDS->poBaseDS = this;\n                            break;\n                        }\n                    }\n                    if (i == nOverviewCount)\n                    {\n                        delete poDS;\n                    }\n                }\n            }\n            else if( nSubType == 0 ) {\n                CPLString osName, osDesc;\n                uint32\tnXSize, nYSize;\n                uint16  nSPP;\n\n                TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n                TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n                if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP ) )\n                    nSPP = 1;\n\n                osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\", \n                               iDirIndex, iDirIndex, osFilename.c_str() );\n                osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\", \n                               iDirIndex, iDirIndex, \n                               (int)nXSize, (int)nYSize, nSPP );\n\n                papszSubdatasets = \n                    CSLAddString( papszSubdatasets, osName );\n                papszSubdatasets = \n                    CSLAddString( papszSubdatasets, osDesc );\n            }\n\n            // Make sure we are stepping from the expected directory regardless\n            // of churn done processing the above.\n            if( TIFFCurrentDirOffset(hTIFF) != nThisDir )\n                TIFFSetSubDirectory( hTIFF, nThisDir );\n            *ppoActiveDSRef = NULL;\n        }\n\n        /* If we have a mask for the main image, loop over the overviews, and if they */\n        /* have a mask, let's set this mask as an overview of the main mask... */\n        if (poMaskDS != NULL)\n        {\n            int i;\n            for(i=0;i<nOverviewCount;i++)\n            {\n                if (((GTiffDataset*)papoOverviewDS[i])->poMaskDS != NULL)\n                {\n                    poMaskDS->nOverviewCount++;\n                    poMaskDS->papoOverviewDS = (GTiffDataset **)\n                        CPLRealloc(poMaskDS->papoOverviewDS, \n                                poMaskDS->nOverviewCount * (sizeof(void*)));\n                    poMaskDS->papoOverviewDS[poMaskDS->nOverviewCount-1] =\n                            ((GTiffDataset*)papoOverviewDS[i])->poMaskDS;\n                }\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n        if( CSLCount(papszSubdatasets) > 2 )\n        {\n            oGTiffMDMD.SetMetadata( papszSubdatasets, \"SUBDATASETS\" );\n        }\n        CSLDestroy( papszSubdatasets );\n    }\n\n    return( CE_None );\n}",
    "GDALDataset *GTiffDataset::Create( const char * pszFilename,\n                                   int nXSize, int nYSize, int nBands,\n                                   GDALDataType eType,\n                                   char **papszParmList )\n\n{\n    GTiffDataset *\tpoDS;\n    TIFF\t\t*hTIFF;\n\n/* -------------------------------------------------------------------- */\n/*      Create the underlying TIFF file.                                */\n/* -------------------------------------------------------------------- */\n    hTIFF = CreateLL( pszFilename, nXSize, nYSize, nBands, \n                      eType, 0, papszParmList );\n\n    if( hTIFF == NULL )\n        return NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Create the new GTiffDataset object.                             */\n/* -------------------------------------------------------------------- */\n    poDS = new GTiffDataset();\n    poDS->hTIFF = hTIFF;\n    poDS->poActiveDS = poDS;\n    poDS->ppoActiveDSRef = &(poDS->poActiveDS);\n\n    poDS->nRasterXSize = nXSize;\n    poDS->nRasterYSize = nYSize;\n    poDS->eAccess = GA_Update;\n    poDS->bCrystalized = FALSE;\n    poDS->nSamplesPerPixel = (uint16) nBands;\n    poDS->osFilename = pszFilename;\n\n    /* Avoid premature crystalization that will cause directory re-writting */\n    /* if GetProjectionRef() or GetGeoTransform() are called on the newly created GeoTIFF */\n    poDS->bLookedForProjection = TRUE;\n\n    TIFFGetField( hTIFF, TIFFTAG_SAMPLEFORMAT, &(poDS->nSampleFormat) );\n    TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &(poDS->nPlanarConfig) );\n    TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(poDS->nPhotometric) );\n    TIFFGetField( hTIFF, TIFFTAG_BITSPERSAMPLE, &(poDS->nBitsPerSample) );\n    TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(poDS->nCompression) );\n\n    if( TIFFIsTiled(hTIFF) )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(poDS->nBlockXSize) );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(poDS->nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(poDS->nRowsPerStrip) ) )\n            poDS->nRowsPerStrip = 1; /* dummy value */\n\n        poDS->nBlockXSize = nXSize;\n        poDS->nBlockYSize = MIN((int)poDS->nRowsPerStrip,nYSize);\n    }\n\n    poDS->nBlocksPerBand =\n        ((nYSize + poDS->nBlockYSize - 1) / poDS->nBlockYSize)\n        * ((nXSize + poDS->nBlockXSize - 1) / poDS->nBlockXSize);\n\n    if( CSLFetchNameValue( papszParmList, \"PROFILE\" ) != NULL )\n        poDS->osProfile = CSLFetchNameValue( papszParmList, \"PROFILE\" );\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( poDS->nCompression == COMPRESSION_JPEG \n        && poDS->nPhotometric == PHOTOMETRIC_YCBCR \n        && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode;\n\n        poDS->SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\" );\n        if ( !TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n             nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read palette back as a color table if it has one.               */\n/* -------------------------------------------------------------------- */\n    unsigned short\t*panRed, *panGreen, *panBlue;\n    \n    if( poDS->nPhotometric == PHOTOMETRIC_PALETTE\n        && TIFFGetField( hTIFF, TIFFTAG_COLORMAP, \n                         &panRed, &panGreen, &panBlue) )\n    {\n        int\tnColorCount;\n        GDALColorEntry oEntry;\n\n        poDS->poColorTable = new GDALColorTable();\n\n        nColorCount = 1 << poDS->nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            oEntry.c1 = panRed[iColor] / 256;\n            oEntry.c2 = panGreen[iColor] / 256;\n            oEntry.c3 = panBlue[iColor] / 256;\n            oEntry.c4 = 255;\n\n            poDS->poColorTable->SetColorEntry( iColor, &oEntry );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we want to ensure all blocks get written out on close to     */\n/*      avoid sparse files?                                             */\n/* -------------------------------------------------------------------- */\n    if( !CSLFetchBoolean( papszParmList, \"SPARSE_OK\", FALSE ) )\n        poDS->bFillEmptyTiles = TRUE;\n        \n/* -------------------------------------------------------------------- */\n/*      Preserve creation options for consulting later (for instance    */\n/*      to decide if a TFW file should be written).                     */\n/* -------------------------------------------------------------------- */\n    poDS->papszCreationOptions = CSLDuplicate( papszParmList );\n\n    poDS->nZLevel = GTiffGetZLevel(papszParmList);\n    poDS->nLZMAPreset = GTiffGetLZMAPreset(papszParmList);\n    poDS->nJpegQuality = GTiffGetJpegQuality(papszParmList);\n\n/* -------------------------------------------------------------------- */\n/*      If we are writing jpeg compression we need to write some        */\n/*      imagery to force the jpegtables to get created.  This is,       */\n/*      likely only needed with libtiff >= 3.9.3 (#3633)                */\n/* -------------------------------------------------------------------- */\n    if( poDS->nCompression == COMPRESSION_JPEG\n        && strstr(TIFFLIB_VERSION_STR, \"Version 3.9\") != NULL )\n    {\n        CPLDebug( \"GDAL\",\n                  \"Writing zero block to force creation of JPEG tables.\" );\n        if( TIFFIsTiled( hTIFF ) )\n        {\n            int cc = TIFFTileSize( hTIFF );\n            unsigned char *pabyZeros = (unsigned char *) CPLCalloc(cc,1);\n            TIFFWriteEncodedTile(hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        else\n        {\n            int cc = TIFFStripSize( hTIFF );\n            unsigned char *pabyZeros = (unsigned char *) CPLCalloc(cc,1);\n            TIFFWriteEncodedStrip(hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        poDS->bDontReloadFirstBlock = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    int\t\tiBand;\n\n    for( iBand = 0; iBand < nBands; iBand++ )\n    {\n        if( poDS->nBitsPerSample == 8 ||\n            poDS->nBitsPerSample == 16 ||\n            poDS->nBitsPerSample == 32 ||\n            poDS->nBitsPerSample == 64 ||\n            poDS->nBitsPerSample == 128)\n            poDS->SetBand( iBand+1, new GTiffRasterBand( poDS, iBand+1 ) );\n        else\n        {\n            poDS->SetBand( iBand+1, new GTiffOddBitsBand( poDS, iBand+1 ) );\n            poDS->GetRasterBand( iBand+1 )->\n                SetMetadataItem( \"NBITS\", \n                                 CPLString().Printf(\"%d\",poDS->nBitsPerSample),\n                                 \"IMAGE_STRUCTURE\" );\n        }\n    }\n\n    poDS->oOvManager.Initialize( poDS, pszFilename );\n\n    return( poDS );\n}",
    "GDALDataset *\nGTiffDataset::CreateCopy( const char * pszFilename, GDALDataset *poSrcDS, \n                          int bStrict, char ** papszOptions, \n                          GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    TIFF\t*hTIFF;\n    int\t\tnXSize = poSrcDS->GetRasterXSize();\n    int\t\tnYSize = poSrcDS->GetRasterYSize();\n    int\t\tnBands = poSrcDS->GetRasterCount();\n    int         iBand;\n    CPLErr      eErr = CE_None;\n    uint16\tnPlanarConfig;\n    uint16\tnBitsPerSample;\n    GDALRasterBand *poPBand;\n\n    if( poSrcDS->GetRasterCount() == 0 )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Unable to export GeoTIFF files with zero bands.\" );\n        return NULL;\n    }\n        \n    poPBand = poSrcDS->GetRasterBand(1);\n    GDALDataType eType = poPBand->GetRasterDataType();\n\n/* -------------------------------------------------------------------- */\n/*      Check, whether all bands in input dataset has the same type.    */\n/* -------------------------------------------------------------------- */\n    for ( iBand = 2; iBand <= nBands; iBand++ )\n    {\n        if ( eType != poSrcDS->GetRasterBand(iBand)->GetRasterDataType() )\n        {\n            if ( bStrict )\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"Unable to export GeoTIFF file with different datatypes per\\n\"\n                          \"different bands. All bands should have the same types in TIFF.\" );\n                return NULL;\n            }\n            else\n            {\n                CPLError( CE_Warning, CPLE_AppDefined,\n                          \"Unable to export GeoTIFF file with different datatypes per\\n\"\n                          \"different bands. All bands should have the same types in TIFF.\" );\n            }\n        }\n    }\n\n    if( !pfnProgress( 0.0, NULL, pProgressData ) )\n        return NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the profile.                                            */\n/* -------------------------------------------------------------------- */\n    const char          *pszProfile;\n    int                 bGeoTIFF;\n\n    pszProfile = CSLFetchNameValue(papszOptions,\"PROFILE\");\n    if( pszProfile == NULL )\n        pszProfile = \"GDALGeoTIFF\";\n\n    if( !EQUAL(pszProfile,\"BASELINE\") \n        && !EQUAL(pszProfile,\"GeoTIFF\") \n        && !EQUAL(pszProfile,\"GDALGeoTIFF\") )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined, \n                  \"PROFILE=%s not supported in GTIFF driver.\", \n                  pszProfile );\n        return NULL;\n    }\n    \n    if( EQUAL(pszProfile,\"BASELINE\") )\n        bGeoTIFF = FALSE;\n    else\n        bGeoTIFF = TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      Special handling for NBITS.  Copy from band metadata if found.  */\n/* -------------------------------------------------------------------- */\n    char     **papszCreateOptions = CSLDuplicate( papszOptions );\n\n    if( poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" ) != NULL \n        && atoi(poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" )) > 0\n        && CSLFetchNameValue( papszCreateOptions, \"NBITS\") == NULL )\n    {\n        papszCreateOptions = \n            CSLSetNameValue( papszCreateOptions, \"NBITS\",\n                             poPBand->GetMetadataItem( \"NBITS\", \n                                                       \"IMAGE_STRUCTURE\" ) );\n    }\n\n    if( CSLFetchNameValue( papszOptions, \"PIXELTYPE\" ) == NULL\n        && eType == GDT_Byte\n        && poPBand->GetMetadataItem( \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) )\n    {\n        papszCreateOptions = \n            CSLSetNameValue( papszCreateOptions, \"PIXELTYPE\", \n                             poPBand->GetMetadataItem( \n                                 \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) );\n    }\n    \n    int nSrcOverviews = poSrcDS->GetRasterBand(1)->GetOverviewCount();\n    double dfExtraSpaceForOverviews = 0;\n    if (nSrcOverviews != 0 &&\n        CSLFetchBoolean(papszOptions, \"COPY_SRC_OVERVIEWS\", FALSE))\n    {\n        int i;\n        for(i=0;i<nSrcOverviews;i++)\n        {\n            dfExtraSpaceForOverviews += ((double)poSrcDS->GetRasterBand(1)->GetOverview(i)->GetXSize()) *\n                                        poSrcDS->GetRasterBand(1)->GetOverview(i)->GetYSize();\n        }\n        dfExtraSpaceForOverviews *= nBands * (GDALGetDataTypeSize(eType) / 8);\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Create the file.                                                */\n/* -------------------------------------------------------------------- */\n    hTIFF = CreateLL( pszFilename, nXSize, nYSize, nBands, \n                      eType, dfExtraSpaceForOverviews, papszCreateOptions );\n\n    CSLDestroy( papszCreateOptions );\n\n    if( hTIFF == NULL )\n        return NULL;\n\n    TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &nPlanarConfig );\n    TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &nBitsPerSample );\n\n/* -------------------------------------------------------------------- */\n/*      Are we really producing an RGBA image?  If so, set the          */\n/*      associated alpha information.                                   */\n/* -------------------------------------------------------------------- */\n    int bForcePhotometric = \n        CSLFetchNameValue(papszOptions,\"PHOTOMETRIC\") != NULL;\n\n    if( nBands == 4 && !bForcePhotometric\n        && poSrcDS->GetRasterBand(4)->GetColorInterpretation()==GCI_AlphaBand)\n    {\n        uint16 v[1];\n\n        v[0] = EXTRASAMPLE_ASSOCALPHA;\n\tTIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n        TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the output is jpeg compressed, and the input is RGB make     */\n/*      sure we note that.                                              */\n/* -------------------------------------------------------------------- */\n    uint16      nCompression;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n\n    if( nCompression == COMPRESSION_JPEG )\n    {\n        if( nBands >= 3 \n            && (poSrcDS->GetRasterBand(1)->GetColorInterpretation() \n                == GCI_YCbCr_YBand)\n            && (poSrcDS->GetRasterBand(2)->GetColorInterpretation() \n                == GCI_YCbCr_CbBand)\n            && (poSrcDS->GetRasterBand(3)->GetColorInterpretation() \n                == GCI_YCbCr_CrBand) )\n        {\n            /* do nothing ... */\n        }\n        else\n        {\n            /* we assume RGB if it isn't explicitly YCbCr */\n            CPLDebug( \"GTiff\", \"Setting JPEGCOLORMODE_RGB\" );\n            TIFFSetField( hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );\n        }\n    }\n        \n/* -------------------------------------------------------------------- */\n/*      Does the source image consist of one band, with a palette?      */\n/*      If so, copy over.                                               */\n/* -------------------------------------------------------------------- */\n    if( (nBands == 1 || nBands == 2) && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n        && eType == GDT_Byte )\n    {\n        unsigned short\tanTRed[256], anTGreen[256], anTBlue[256];\n        GDALColorTable *poCT;\n\n        poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n        \n        for( int iColor = 0; iColor < 256; iColor++ )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = (unsigned short) (257 * sRGB.c1);\n                anTGreen[iColor] = (unsigned short) (257 * sRGB.c2);\n                anTBlue[iColor] = (unsigned short) (257 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = anTGreen[iColor] = anTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, anTRed, anTGreen, anTBlue );\n    }\n    else if( (nBands == 1 || nBands == 2) \n             && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n             && eType == GDT_UInt16 )\n    {\n        unsigned short\t*panTRed, *panTGreen, *panTBlue;\n        GDALColorTable *poCT;\n\n        panTRed   = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n        panTGreen = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n        panTBlue  = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n\n        poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n        \n        for( int iColor = 0; iColor < 65536; iColor++ )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                panTRed[iColor] = (unsigned short) (256 * sRGB.c1);\n                panTGreen[iColor] = (unsigned short) (256 * sRGB.c2);\n                panTBlue[iColor] = (unsigned short) (256 * sRGB.c3);\n            }\n            else\n            {\n                panTRed[iColor] = panTGreen[iColor] = panTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n    else if( poSrcDS->GetRasterBand(1)->GetColorTable() != NULL )\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"Unable to export color table to GeoTIFF file.  Color tables\\n\"\n                  \"can only be written to 1 band or 2 bands Byte or UInt16 GeoTIFF files.\" );\n\n    if( nBands == 2\n        && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n        && (eType == GDT_Byte || eType == GDT_UInt16) )\n    {\n        uint16 v[1] = { EXTRASAMPLE_UNASSALPHA };\n\n        TIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, 1, v );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Transfer some TIFF specific metadata, if available.             */\n/*      The return value will tell us if we need to try again later with*/\n/*      PAM because the profile doesn't allow to write some metadata    */\n/*      as TIFF tag                                                     */\n/* -------------------------------------------------------------------- */\n    int bHasWrittenMDInGeotiffTAG =\n            GTiffDataset::WriteMetadata( poSrcDS, hTIFF, FALSE, pszProfile,\n                                 pszFilename, papszOptions );\n\n/* -------------------------------------------------------------------- */\n/* \tWrite NoData value, if exist.                                   */\n/* -------------------------------------------------------------------- */\n    if( EQUAL(pszProfile,\"GDALGeoTIFF\") )\n    {\n        int\t\tbSuccess;\n        double\tdfNoData;\n    \n        dfNoData = poSrcDS->GetRasterBand(1)->GetNoDataValue( &bSuccess );\n        if ( bSuccess )\n            GTiffDataset::WriteNoDataValue( hTIFF, dfNoData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Are we addressing PixelIsPoint mode?                            */\n/* -------------------------------------------------------------------- */\n    bool bPixelIsPoint = false;\n    int  bPointGeoIgnore = FALSE;\n\n    if( poSrcDS->GetMetadataItem( GDALMD_AREA_OR_POINT ) \n        && EQUAL(poSrcDS->GetMetadataItem(GDALMD_AREA_OR_POINT),\n                 GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore = \n            CSLTestBoolean( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                               \"FALSE\") );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write affine transform if it is meaningful.                     */\n/* -------------------------------------------------------------------- */\n    const char *pszProjection = NULL;\n    double      adfGeoTransform[6];\n    \n    if( poSrcDS->GetGeoTransform( adfGeoTransform ) == CE_None\n        && (adfGeoTransform[0] != 0.0 || adfGeoTransform[1] != 1.0\n            || adfGeoTransform[2] != 0.0 || adfGeoTransform[3] != 0.0\n            || adfGeoTransform[4] != 0.0 || adfGeoTransform[5] != 1.0 ))\n    {\n        if( bGeoTIFF )\n        {\n            if( adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0 \n                && adfGeoTransform[5] < 0.0 )\n            {\n\n                double\tadfPixelScale[3], adfTiePoints[6];\n\n                adfPixelScale[0] = adfGeoTransform[1];\n                adfPixelScale[1] = fabs(adfGeoTransform[5]);\n                adfPixelScale[2] = 0.0;\n\n                TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n            \n                adfTiePoints[0] = 0.0;\n                adfTiePoints[1] = 0.0;\n                adfTiePoints[2] = 0.0;\n                adfTiePoints[3] = adfGeoTransform[0];\n                adfTiePoints[4] = adfGeoTransform[3];\n                adfTiePoints[5] = 0.0;\n                \n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfTiePoints[3] += adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                    adfTiePoints[4] += adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n                }\n\t    \n                TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n            }\n            else\n            {\n                double\tadfMatrix[16];\n\n                memset(adfMatrix,0,sizeof(double) * 16);\n\n                adfMatrix[0] = adfGeoTransform[1];\n                adfMatrix[1] = adfGeoTransform[2];\n                adfMatrix[3] = adfGeoTransform[0];\n                adfMatrix[4] = adfGeoTransform[4];\n                adfMatrix[5] = adfGeoTransform[5];\n                adfMatrix[7] = adfGeoTransform[3];\n                adfMatrix[15] = 1.0;\n                \n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfMatrix[3] += adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                    adfMatrix[7] += adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n                }\n\n                TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n            }\n            \n            pszProjection = poSrcDS->GetProjectionRef();\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need a TFW file?                                          */\n/* -------------------------------------------------------------------- */\n        if( CSLFetchBoolean( papszOptions, \"TFW\", FALSE ) )\n            GDALWriteWorldFile( pszFilename, \"tfw\", adfGeoTransform );\n        else if( CSLFetchBoolean( papszOptions, \"WORLDFILE\", FALSE ) )\n            GDALWriteWorldFile( pszFilename, \"wld\", adfGeoTransform );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise write tiepoints if they are available.                */\n/* -------------------------------------------------------------------- */\n    else if( poSrcDS->GetGCPCount() > 0 && bGeoTIFF )\n    {\n        const GDAL_GCP *pasGCPs = poSrcDS->GetGCPs();\n        double\t*padfTiePoints;\n\n        padfTiePoints = (double *) \n            CPLMalloc(6*sizeof(double)*poSrcDS->GetGCPCount());\n\n        for( int iGCP = 0; iGCP < poSrcDS->GetGCPCount(); iGCP++ )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPs[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPs[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPs[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPs[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPs[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] += 0.5;\n                padfTiePoints[iGCP*6+1] += 0.5;\n            }\n        }\n\n        TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, \n                      6*poSrcDS->GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n        \n        pszProjection = poSrcDS->GetGCPProjection();\n        \n        if( CSLFetchBoolean( papszOptions, \"TFW\", FALSE ) \n            || CSLFetchBoolean( papszOptions, \"WORLDFILE\", FALSE ) )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"TFW=ON or WORLDFILE=ON creation options are ignored when GCPs are available\");\n        }\n    }\n\n    else\n        pszProjection = poSrcDS->GetProjectionRef();\n\n/* -------------------------------------------------------------------- */\n/*      Write the projection information, if possible.                  */\n/* -------------------------------------------------------------------- */\n    if( pszProjection != NULL && strlen(pszProjection) > 0 && bGeoTIFF )\n    {\n        GTIF\t*psGTIF;\n\n        psGTIF = GTIFNew( hTIFF );\n        GTIFSetFromOGISDefn( psGTIF, pszProjection );\n\n        if( poSrcDS->GetMetadataItem( GDALMD_AREA_OR_POINT ) \n            && EQUAL(poSrcDS->GetMetadataItem(GDALMD_AREA_OR_POINT),\n                     GDALMD_AOP_POINT) )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we are writing jpeg compression we need to write some        */\n/*      imagery to force the jpegtables to get created.  This is,       */\n/*      likely only needed with libtiff >= 3.9.3 (#3633)                */\n/* -------------------------------------------------------------------- */\n    int bDontReloadFirstBlock = FALSE;\n    if( nCompression == COMPRESSION_JPEG\n        && strstr(TIFFLIB_VERSION_STR, \"Version 3.9\") != NULL )\n    {\n        CPLDebug( \"GDAL\", \n                  \"Writing zero block to force creation of JPEG tables.\" );\n        if( TIFFIsTiled( hTIFF ) )\n        {\n            int cc = TIFFTileSize( hTIFF );\n            unsigned char *pabyZeros = (unsigned char *) CPLCalloc(cc,1);\n            TIFFWriteEncodedTile(hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        else\n        {\n            int cc = TIFFStripSize( hTIFF );\n            unsigned char *pabyZeros = (unsigned char *) CPLCalloc(cc,1);\n            TIFFWriteEncodedStrip(hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        bDontReloadFirstBlock = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup                                                         */\n/* -------------------------------------------------------------------- */\n    \n    TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTiffCreateCopy()\");\n    TIFFWriteDirectory( hTIFF );\n    TIFFFlush( hTIFF );\n    XTIFFClose( hTIFF );\n    hTIFF = NULL;\n\n    if( eErr != CE_None )\n    {\n        VSIUnlink( pszFilename );\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Re-open as a dataset and copy over missing metadata using       */\n/*      PAM facilities.                                                 */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS;\n    CPLString osFileName(\"GTIFF_RAW:\");\n\n    osFileName += pszFilename;\n\n    poDS = (GTiffDataset *) GDALOpen( osFileName, GA_Update );\n    if( poDS == NULL )\n        poDS = (GTiffDataset *) GDALOpen( osFileName, GA_ReadOnly );\n\n    if ( poDS == NULL )\n    {\n        VSIUnlink( pszFilename );\n        return NULL;\n    }\n\n    poDS->osProfile = pszProfile;\n    poDS->CloneInfo( poSrcDS, GCIF_PAM_DEFAULT & ~GCIF_MASK );\n    poDS->papszCreationOptions = CSLDuplicate( papszOptions );\n    poDS->bDontReloadFirstBlock = bDontReloadFirstBlock;\n\n/* -------------------------------------------------------------------- */\n/*      CloneInfo() doesn't merge metadata, it just replaces it totally */\n/*      So we have to merge it                                          */\n/* -------------------------------------------------------------------- */\n\n    char **papszSRC_MD = poSrcDS->GetMetadata();\n    char **papszDST_MD = CSLDuplicate(poDS->GetMetadata());\n\n    papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n    poDS->SetMetadata( papszDST_MD );\n    CSLDestroy( papszDST_MD );\n\n    /* Depending on the PHOTOMETRIC tag, the TIFF file may not have */\n    /* the same band count as the source. Will fail later in GDALDatasetCopyWholeRaster anyway... */\n    for( int nBand = 1;\n         nBand <= MIN(poDS->GetRasterCount(), poSrcDS->GetRasterCount()) ;\n         nBand++ )\n    {\n        char **papszSRC_MD = poSrcDS->GetRasterBand(nBand)->GetMetadata();\n        char **papszDST_MD = CSLDuplicate(poDS->GetRasterBand(nBand)->GetMetadata());\n\n        papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n        poDS->GetRasterBand(nBand)->SetMetadata( papszDST_MD );\n        CSLDestroy( papszDST_MD );\n    }\n\n    hTIFF = (TIFF*) poDS->GetInternalHandle(NULL);\n\n/* -------------------------------------------------------------------- */\n/*      Handle forcing xml:ESRI data to be written to PAM.              */\n/* -------------------------------------------------------------------- */\n    if( CSLTestBoolean(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n    {\n        char **papszESRIMD = poSrcDS->GetMetadata(\"xml:ESRI\");\n        if( papszESRIMD )\n        {\n            poDS->SetMetadata( papszESRIMD, \"xml:ESRI\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Second chance : now that we have a PAM dataset, it is possible  */\n/*      to write metadata that we couldn't be writen as TIFF tag        */\n/* -------------------------------------------------------------------- */\n    if (!bHasWrittenMDInGeotiffTAG)\n        GTiffDataset::WriteMetadata( poDS, hTIFF, TRUE, pszProfile,\n                                     pszFilename, papszOptions, TRUE /* don't write RPC and IMD file again */);\n\n    /* To avoid unnecessary directory rewriting */\n    poDS->bMetadataChanged = FALSE;\n    poDS->bGeoTIFFInfoChanged = FALSE;\n\n    /* We must re-set the compression level at this point, since it has */\n    /* been lost a few lines above when closing the newly create TIFF file */\n    /* The TIFFTAG_ZIPQUALITY & TIFFTAG_JPEGQUALITY are not store in the TIFF file. */\n    /* They are just TIFF session parameters */\n\n    poDS->nZLevel = GTiffGetZLevel(papszOptions);\n    poDS->nLZMAPreset = GTiffGetLZMAPreset(papszOptions);\n    poDS->nJpegQuality = GTiffGetJpegQuality(papszOptions);\n\n    if (nCompression == COMPRESSION_ADOBE_DEFLATE)\n    {\n        if (poDS->nZLevel != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_ZIPQUALITY, poDS->nZLevel );\n        }\n    }\n    else if( nCompression == COMPRESSION_JPEG)\n    {\n        if (poDS->nJpegQuality != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_JPEGQUALITY, poDS->nJpegQuality );\n        }\n    }\n    else if( nCompression == COMPRESSION_LZMA)\n    {\n        if (poDS->nLZMAPreset != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_LZMAPRESET, poDS->nLZMAPreset );\n        }\n    }\n\n    /* Precreate (internal) mask, so that the IBuildOverviews() below */\n    /* has a chance to create also the overviews of the mask */\n    int nMaskFlags = poSrcDS->GetRasterBand(1)->GetMaskFlags();\n    if( eErr == CE_None\n        && !(nMaskFlags & (GMF_ALL_VALID|GMF_ALPHA|GMF_NODATA) )\n        && (nMaskFlags & GMF_PER_DATASET) )\n    {\n        eErr = poDS->CreateMaskBand( nMaskFlags );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create and then copy existing overviews if requested            */\n/*  We do it such that all the IFDs are at the beginning of the file,   */\n/*  and that the imagery data for the smallest overview is written      */\n/*  first, that way the file is more usable when embedded in a          */\n/*  compressed stream.                                                  */\n/* -------------------------------------------------------------------- */\n\n    /* For scaled progress due to overview copying */\n    double dfTotalPixels = ((double)nXSize) * nYSize;\n    double dfCurPixels = 0;\n\n    if (eErr == CE_None &&\n        nSrcOverviews != 0 &&\n        CSLFetchBoolean(papszOptions, \"COPY_SRC_OVERVIEWS\", FALSE))\n    {\n        eErr = poDS->CreateOverviewsFromSrcOverviews(poSrcDS);\n\n        if (poDS->nOverviewCount != nSrcOverviews)\n        {\n            CPLError(CE_Failure, CPLE_AppDefined,\n                     \"Did only manage to instanciate %d overview levels, whereas source contains %d\",\n                     poDS->nOverviewCount, nSrcOverviews);\n            eErr = CE_Failure;\n        }\n\n        int i;\n        for(i=0;i<nSrcOverviews;i++)\n        {\n            GDALRasterBand* poOvrBand = poSrcDS->GetRasterBand(1)->GetOverview(i);\n            dfTotalPixels += ((double)poOvrBand->GetXSize()) *\n                                      poOvrBand->GetYSize();\n        }\n\n        char* papszCopyWholeRasterOptions[2] = { NULL, NULL };\n        if (nCompression != COMPRESSION_NONE)\n            papszCopyWholeRasterOptions[0] = (char*) \"COMPRESSED=YES\";\n        /* Now copy the imagery */\n        for(i=0;eErr == CE_None && i<nSrcOverviews;i++)\n        {\n            /* Begin with the smallest overview */\n            int iOvrLevel = nSrcOverviews-1-i;\n            \n            /* Create a fake dataset with the source overview level so that */\n            /* GDALDatasetCopyWholeRaster can cope with it */\n            GDALDataset* poSrcOvrDS = new GDALOverviewDS(poSrcDS, iOvrLevel);\n            \n            GDALRasterBand* poOvrBand =\n                    poSrcDS->GetRasterBand(1)->GetOverview(iOvrLevel);\n            double dfNextCurPixels = dfCurPixels +\n                    ((double)poOvrBand->GetXSize()) * poOvrBand->GetYSize();\n\n            void* pScaledData = GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                      dfNextCurPixels / dfTotalPixels,\n                                      pfnProgress, pProgressData);\n                                \n            eErr = GDALDatasetCopyWholeRaster( (GDALDatasetH) poSrcOvrDS,\n                                                (GDALDatasetH) poDS->papoOverviewDS[iOvrLevel],\n                                                papszCopyWholeRasterOptions,\n                                                GDALScaledProgress, pScaledData );\n                                                \n            dfCurPixels = dfNextCurPixels;\n            GDALDestroyScaledProgress(pScaledData);\n\n            delete poSrcOvrDS;\n            poDS->papoOverviewDS[iOvrLevel]->FlushCache();\n\n            /* Copy mask of the overview */\n            if (eErr == CE_None && poDS->poMaskDS != NULL)\n            {\n                eErr = GDALRasterBandCopyWholeRaster( poOvrBand->GetMaskBand(),\n                                                    poDS->papoOverviewDS[iOvrLevel]->poMaskDS->GetRasterBand(1),\n                                                    papszCopyWholeRasterOptions,\n                                                    GDALDummyProgress, NULL);\n                poDS->papoOverviewDS[iOvrLevel]->poMaskDS->FlushCache();\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy actual imagery.                                            */\n/* -------------------------------------------------------------------- */\n    void* pScaledData = GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                                  1.0,\n                                                  pfnProgress, pProgressData);\n\n    if (poDS->bTreatAsSplit || poDS->bTreatAsSplitBitmap)\n    {\n        /* For split bands, we use TIFFWriteScanline() interface */\n        CPLAssert(poDS->nBitsPerSample == 8 || poDS->nBitsPerSample == 1);\n        \n        if (poDS->nPlanarConfig == PLANARCONFIG_CONTIG && poDS->nBands > 1)\n        {\n            int j;\n            GByte* pabyScanline = (GByte *) CPLMalloc(TIFFScanlineSize(hTIFF));\n            for(j=0;j<nYSize && eErr == CE_None;j++)\n            {\n                eErr = poSrcDS->RasterIO(GF_Read, 0, j, nXSize, 1,\n                                         pabyScanline, nXSize, 1,\n                                         GDT_Byte, nBands, NULL, poDS->nBands, 0, 1);\n                if (eErr == CE_None &&\n                    TIFFWriteScanline( hTIFF, pabyScanline, j, 0) == -1)\n                {\n                    CPLError( CE_Failure, CPLE_AppDefined,\n                              \"TIFFWriteScanline() failed.\" );\n                    eErr = CE_Failure;\n                }\n                if( !GDALScaledProgress( (j+1) * 1.0 / nYSize, NULL, pScaledData ) )\n                    eErr = CE_Failure;\n            }\n            CPLFree(pabyScanline);\n        }\n        else\n        {\n            int iBand, j;\n            GByte* pabyScanline = (GByte *) CPLMalloc(TIFFScanlineSize(hTIFF));\n            eErr = CE_None;\n            for(iBand=1;iBand<=nBands && eErr == CE_None;iBand++)\n            {\n                for(j=0;j<nYSize && eErr == CE_None;j++)\n                {\n                    eErr = poSrcDS->GetRasterBand(iBand)->RasterIO(\n                                                    GF_Read, 0, j, nXSize, 1,\n                                                    pabyScanline, nXSize, 1,\n                                                    GDT_Byte, 0, 0);\n                    if (poDS->bTreatAsSplitBitmap)\n                    {\n                        for(int i=0;i<nXSize;i++)\n                        {\n                            GByte byVal = pabyScanline[i];\n                            if ((i & 0x7) == 0)\n                                pabyScanline[i >> 3] = 0;\n                            if (byVal)\n                                pabyScanline[i >> 3] |= (0x80 >> (i & 0x7));\n                        }\n                    }\n                    if (eErr == CE_None &&\n                        TIFFWriteScanline( hTIFF, pabyScanline, j, (uint16) (iBand-1)) == -1)\n                    {\n                        CPLError( CE_Failure, CPLE_AppDefined,\n                                  \"TIFFWriteScanline() failed.\" );\n                        eErr = CE_Failure;\n                    }\n                    if( !GDALScaledProgress( (j+1 + (iBand - 1) * nYSize) * 1.0 /\n                                      (nBands * nYSize), NULL, pScaledData ) )\n                        eErr = CE_Failure;\n                }\n            }\n            CPLFree(pabyScanline);\n        }\n        \n        /* Necessary to be able to read the file without re-opening */\n#if defined(HAVE_TIFFGETSIZEPROC)\n        TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( hTIFF );\n\n        TIFFFlushData( hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            nNewDirOffset++;\n#endif\n\n        TIFFFlush( hTIFF );\n\n#if defined(HAVE_TIFFGETSIZEPROC)\n        if( poDS->nDirOffset != TIFFCurrentDirOffset( hTIFF ) )\n        {\n            poDS->nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\", \"directory moved during flush.\" );\n        }\n#endif\n    }\n    else if (eErr == CE_None)\n    {\n        char* papszCopyWholeRasterOptions[2] = { NULL, NULL };\n        if (nCompression != COMPRESSION_NONE)\n            papszCopyWholeRasterOptions[0] = (char*) \"COMPRESSED=YES\";\n        eErr = GDALDatasetCopyWholeRaster( (GDALDatasetH) poSrcDS, \n                                            (GDALDatasetH) poDS,\n                                            papszCopyWholeRasterOptions,\n                                            GDALScaledProgress, pScaledData );\n    }\n    \n    GDALDestroyScaledProgress(pScaledData);\n\n    if (eErr == CE_None)\n    {\n        if (poDS->poMaskDS)\n        {\n            const char* papszOptions[2] = { \"COMPRESSED=YES\", NULL };\n            eErr = GDALRasterBandCopyWholeRaster(\n                                    poSrcDS->GetRasterBand(1)->GetMaskBand(),\n                                    poDS->GetRasterBand(1)->GetMaskBand(),\n                                    (char**)papszOptions,\n                                    GDALDummyProgress, NULL);\n        }\n        else\n            eErr = GDALDriver::DefaultCopyMasks( poSrcDS, poDS, bStrict );\n    }\n\n    if( eErr == CE_Failure )\n    {\n        delete poDS;\n        poDS = NULL;\n\n        if (CSLTestBoolean(CPLGetConfigOption(\"GTIFF_DELETE_ON_ERROR\", \"YES\")))\n            VSIUnlink( pszFilename ); // should really delete more carefully.\n    }\n\n    return poDS;\n}",
    "CPLErr GTiffDataset::CreateMaskBand(int nFlags)\n{\n    if (poMaskDS != NULL)\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"This TIFF dataset has already an internal mask band\");\n        return CE_Failure;\n    }\n    else if (CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\")))\n    {\n        toff_t  nOffset;\n        int     bIsTiled;\n        int     bIsOverview = FALSE;\n        uint32\tnSubType;\n        int     nCompression;\n\n        if (nFlags != GMF_PER_DATASET)\n        {\n            CPLError(CE_Failure, CPLE_AppDefined,\n                     \"The only flag value supported for internal mask is GMF_PER_DATASET\");\n            return CE_Failure;\n        }\n\n        if( strstr(GDALGetMetadataItem(GDALGetDriverByName( \"GTiff\" ),\n                                       GDAL_DMD_CREATIONOPTIONLIST, NULL ),\n                   \"<Value>DEFLATE</Value>\") != NULL )\n            nCompression = COMPRESSION_ADOBE_DEFLATE;\n        else\n            nCompression = COMPRESSION_PACKBITS;\n\n    /* -------------------------------------------------------------------- */\n    /*      If we don't have read access, then create the mask externally.  */\n    /* -------------------------------------------------------------------- */\n        if( GetAccess() != GA_Update )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined,\n                    \"File open for read-only accessing, \"\n                    \"creating mask externally.\" );\n\n            return GDALPamDataset::CreateMaskBand(nFlags);\n        }\n\n        if (poBaseDS)\n        {\n            if (!poBaseDS->SetDirectory())\n                return CE_Failure;\n        }\n        if (!SetDirectory())\n            return CE_Failure;\n\n        if( TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType))\n        {\n            bIsOverview = (nSubType & FILETYPE_REDUCEDIMAGE) != 0;\n\n            if ((nSubType & FILETYPE_MASK) != 0)\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"Cannot create a mask on a TIFF mask IFD !\" );\n                return CE_Failure;\n            }\n        }\n\n        bIsTiled = TIFFIsTiled(hTIFF);\n        \n        FlushDirectory();\n        \n        nOffset = GTIFFWriteDirectory(hTIFF,\n                                      (bIsOverview) ? FILETYPE_REDUCEDIMAGE | FILETYPE_MASK : FILETYPE_MASK,\n                                      nRasterXSize, nRasterYSize,\n                                      1, PLANARCONFIG_CONTIG, 1,\n                                      nBlockXSize, nBlockYSize,\n                                      bIsTiled, nCompression, \n                                      PHOTOMETRIC_MASK, PREDICTOR_NONE,\n                                      SAMPLEFORMAT_UINT, NULL, NULL, NULL, 0, NULL, \"\");\n        if (nOffset == 0)\n            return CE_Failure;\n\n        poMaskDS = new GTiffDataset();\n        poMaskDS->bPromoteTo8Bits = CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n        if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nOffset, \n                                  FALSE, GA_Update ) != CE_None)\n        {\n            delete poMaskDS;\n            poMaskDS = NULL;\n            return CE_Failure;\n        }\n\n        return CE_None;\n    }\n    else\n    {\n        return GDALPamDataset::CreateMaskBand(nFlags);\n    }\n}",
    "bool CTiffContext::LoadFrameInfo(int32_t frame,\n                                 int32_t* width,\n                                 int32_t* height,\n                                 int32_t* comps,\n                                 int32_t* bpc,\n                                 CFX_DIBAttribute* pAttribute) {\n  if (!TIFFSetDirectory(m_tif_ctx.get(), (uint16_t)frame))\n    return false;\n\n  uint32_t tif_width = 0;\n  uint32_t tif_height = 0;\n  uint16_t tif_comps = 0;\n  uint16_t tif_bpc = 0;\n  uint32_t tif_rps = 0;\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_IMAGEWIDTH, &tif_width);\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_IMAGELENGTH, &tif_height);\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_SAMPLESPERPIXEL, &tif_comps);\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_BITSPERSAMPLE, &tif_bpc);\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_ROWSPERSTRIP, &tif_rps);\n\n  uint16_t tif_resunit = 0;\n  if (TIFFGetField(m_tif_ctx.get(), TIFFTAG_RESOLUTIONUNIT, &tif_resunit)) {\n    pAttribute->m_wDPIUnit =\n        static_cast<CFX_DIBAttribute::ResUnit>(tif_resunit - 1);\n  } else {\n    pAttribute->m_wDPIUnit = CFX_DIBAttribute::kResUnitInch;\n  }\n\n  float tif_xdpi = 0.0f;\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_XRESOLUTION, &tif_xdpi);\n  if (tif_xdpi)\n    pAttribute->m_nXDPI = static_cast<int32_t>(tif_xdpi + 0.5f);\n\n  float tif_ydpi = 0.0f;\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_YRESOLUTION, &tif_ydpi);\n  if (tif_ydpi)\n    pAttribute->m_nYDPI = static_cast<int32_t>(tif_ydpi + 0.5f);\n\n  FX_SAFE_INT32 checked_width = tif_width;\n  FX_SAFE_INT32 checked_height = tif_height;\n  if (!checked_width.IsValid() || !checked_height.IsValid())\n    return false;\n\n  *width = checked_width.ValueOrDie();\n  *height = checked_height.ValueOrDie();\n  *comps = tif_comps;\n  *bpc = tif_bpc;\n  if (tif_rps > tif_height) {\n    tif_rps = tif_height;\n    TIFFSetField(m_tif_ctx.get(), TIFFTAG_ROWSPERSTRIP, tif_rps);\n  }\n  return true;\n}",
    "void CTiffContext::SetPalette(const RetainPtr<CFX_DIBitmap>& pDIBitmap,\n                              uint16_t bps) {\n  uint16_t* red_orig = nullptr;\n  uint16_t* green_orig = nullptr;\n  uint16_t* blue_orig = nullptr;\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_COLORMAP, &red_orig, &green_orig,\n               &blue_orig);\n#define CVT(x) ((uint16_t)((x) >> 8))\n  UNSAFE_TODO({\n    for (int32_t i = pdfium::checked_cast<int32_t>((1L << bps) - 1); i >= 0;\n         i--) {\n      red_orig[i] = CVT(red_orig[i]);\n      green_orig[i] = CVT(green_orig[i]);\n      blue_orig[i] = CVT(blue_orig[i]);\n    }\n    int32_t len = 1 << bps;\n    for (int32_t index = 0; index < len; index++) {\n      uint32_t r = red_orig[index] & 0xFF;\n      uint32_t g = green_orig[index] & 0xFF;\n      uint32_t b = blue_orig[index] & 0xFF;\n      uint32_t color = (uint32_t)b | ((uint32_t)g << 8) | ((uint32_t)r << 16) |\n                       (((uint32_t)0xffL) << 24);\n      pDIBitmap->SetPaletteArgb(index, color);\n    }\n  });\n#undef CVT\n}",
    "bool CTiffContext::Decode(const RetainPtr<CFX_DIBitmap>& pDIBitmap) {\n  uint32_t img_width = pDIBitmap->GetWidth();\n  uint32_t img_height = pDIBitmap->GetHeight();\n  uint32_t width = 0;\n  uint32_t height = 0;\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_IMAGELENGTH, &height);\n  if (img_width != width || img_height != height)\n    return false;\n\n  if (pDIBitmap->GetBPP() == 32) {\n    uint16_t rotation = ORIENTATION_TOPLEFT;\n    TIFFGetField(m_tif_ctx.get(), TIFFTAG_ORIENTATION, &rotation);\n    uint32_t* data = const_cast<uint32_t*>(\n        reinterpret_cast<const uint32_t*>(pDIBitmap->GetBuffer().data()));\n    if (TIFFReadRGBAImageOriented(m_tif_ctx.get(), img_width, img_height, data,\n                                  rotation, 1)) {\n      for (uint32_t row = 0; row < img_height; row++) {\n        uint8_t* row_buf = pDIBitmap->GetWritableScanline(row).data();\n        TiffBGRA2RGBA(row_buf, img_width, 4);\n      }\n      return true;\n    }\n  }\n  uint16_t spp = 0;\n  uint16_t bps = 0;\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetField(m_tif_ctx.get(), TIFFTAG_BITSPERSAMPLE, &bps);\n  FX_SAFE_UINT32 safe_bpp = bps;\n  safe_bpp *= spp;\n  if (!safe_bpp.IsValid())\n    return false;\n  uint32_t bpp = safe_bpp.ValueOrDie();\n  if (bpp == 1)\n    return Decode1bppRGB(pDIBitmap, height, width, bps, spp);\n  if (bpp <= 8)\n    return Decode8bppRGB(pDIBitmap, height, width, bps, spp);\n  if (bpp <= 24)\n    return Decode24bppRGB(pDIBitmap, height, width, bps, spp);\n  return false;\n}",
    "char *loadTiff3D2Metadata ( char * filename, unsigned int &sz0, unsigned int  &sz1, unsigned int  &sz2, unsigned int  &sz3, int &datatype, int &b_swap, void * &fhandle, int &header_len ) {\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffLoadMetadata)\r\n    #endif\r\n\r\n\tuint32 XSIZE;\r\n\tuint32 YSIZE;\r\n\tuint16 bpp;\r\n\tuint16 spp;\r\n\tuint16 Cpage;\r\n\tuint16 Npages;\r\n    TIFF *input;\r\n    int check;\r\n\r\n\tinput=TIFFOpen(filename,\"r\");\r\n\tif (!input)\r\n    {\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Cannot open the file %s\",finName).c_str());\r\n\t\treturn ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &XSIZE);\r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n\t\treturn ((char *) \"Image width of undefined.\");\r\n\t}\t\t\r\n    \r\n\tcheck=TIFFGetField(input, TIFFTAG_IMAGELENGTH, &YSIZE);\r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n\t\treturn ((char *) \"Image length of undefined.\");\r\n\t}\t\t\r\n    \r\n\tcheck=TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp); \r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n\t\treturn ((char *) \"Undefined bits per sample.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n\t\treturn ((char *) \"Undefined samples per pixel.\");\r\n\t}\r\n\r\n\t// Onofri\r\n\tcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &Npages);\r\n\tif (!check || Npages==0) { // the tag has not been read correctly\r\n\t\t// Add warning?\r\n\t\tNpages = 0;\r\n\t\tdo {\r\n\t\t\tNpages++;\r\n\t\t} while ( TIFFReadDirectory(input) );\r\n\t}\r\n\r\n\tsz0 = XSIZE;\r\n\tsz1 = YSIZE;\r\n\tsz2 = Npages;\r\n\tsz3 = spp;\r\n\tdatatype = bpp/8;\r\n\r\n\t//b_swap = 0;\r\n\tb_swap=TIFFIsByteSwapped(input);\r\n\tfhandle = (void *) input;\r\n\theader_len = -1;\r\n\r\n\t// the file must non be closed (it is responsibility of the caller)\r\n\t//TIFFClose(input);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffLoadMetadata, itm::IO, itm::strprintf(\"successfully loaded metadata from file \\\"%s\\\"\", filename))\r\n    #endif\r\n\r\n\treturn ((char *) 0);\r\n}",
    "char *appendSlice2Tiff3DFile ( char *filename, int slice, unsigned char *img, unsigned int img_width, unsigned int img_height ) {\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffAppendData)\r\n    #endif\r\n\r\n\tTIFF *output;\r\n\tuint16 spp, bpp, NPages, pg0;\r\n\r\n\toutput=TIFFOpen(filename,\"r\");\r\n\tTIFFGetField(output, TIFFTAG_BITSPERSAMPLE, &bpp); \r\n\tTIFFGetField(output, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tTIFFGetField(output, TIFFTAG_PAGENUMBER, &pg0, &NPages);\r\n\tTIFFClose(output);\r\n\t// since we are \r\n\toutput = (slice==0)? TIFFOpen(filename,\"w\") : TIFFOpen(filename,\"a\");\r\n\r\n\tTIFFSetDirectory(output,slice); // WARNING: slice must be the first page after the last, otherwise the file can be corrupted\r\n\r\n\tTIFFSetField(output, TIFFTAG_IMAGEWIDTH, img_width);\r\n\tTIFFSetField(output, TIFFTAG_IMAGELENGTH, img_height);\r\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, bpp); \r\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, spp);\r\n\tTIFFSetField(output, TIFFTAG_ROWSPERSTRIP, img_height);\r\n\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\t//TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\r\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\t\r\n\t//TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\t\r\n\t// We are writing single page of the multipage file \r\n\tTIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n\tTIFFSetField(output, TIFFTAG_PAGENUMBER, (uint16)slice, NPages); \r\n\r\n\tTIFFWriteEncodedStrip(output, 0, img, img_width * img_height * spp * (bpp/8));\r\n\t//img +=  img_width * img_height;\r\n\r\n\tTIFFWriteDirectory(output);\r\n\r\n\tTIFFClose(output);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffAppendData, itm::IO, itm::strprintf(\"appended slice %d x %d to 3D tiff \\\"%s\\\"\", img_width, img_height, filename))\r\n    #endif\r\n\r\n\treturn (char *) 0;\r\n}",
    "char *readTiff3DFile2Buffer ( void *fhandler, unsigned char *img, unsigned int img_width, unsigned int img_height, unsigned int first, unsigned int last, int b_swap ) {\r\n\tuint32 rps;\r\n    uint16 spp, bpp, photo, comp, planar_config;\r\n    int check, StripsPerImage,LastStripSize;\r\n\r\n    TIFF *input = (TIFF *) fhandler;\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rps);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Image length of undefined.\");\r\n\t}\t\r\n\t//rps=600;\r\n    \r\n\tcheck=TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp); \r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Undefined bits per sample.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Undefined samples per pixel.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &photo);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Cannot determine photometric interpretation.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_COMPRESSION, &comp);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Cannot determine compression technique.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_PLANARCONFIG, &planar_config);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Cannot determine planar configuration.\");\r\n\t}\r\n\r\n\r\n\tStripsPerImage =  (img_height + rps - 1) / rps;\r\n\tLastStripSize = img_height % rps;\r\n\tif (LastStripSize==0)\r\n\t\tLastStripSize=rps;\r\n\r\n\tcheck=TIFFSetDirectory(input, first);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Cannot open the requested first strip.\");\r\n\t}\r\n\r\n\tunsigned char *buf = img;\r\n\tint page=0;\r\n\tdo{\r\n\r\n\t\tfor (int i=0; i < StripsPerImage-1; i++){\r\n\t\t\tif (comp==1) {\r\n\t\t\t\tTIFFReadRawStrip(input, i, buf, spp * rps * img_width * (bpp/8));\r\n\t\t\t\tbuf = buf + spp * rps * img_width * (bpp/8);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tTIFFReadEncodedStrip(input, i, buf, spp * rps * img_width * (bpp/8));\r\n\t\t\t\tbuf = buf + spp * rps * img_width * (bpp/8);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (comp==1) {\r\n\t\t\tTIFFReadRawStrip(input, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\r\n\t\t}\r\n\t\telse{\r\n\t\t\tTIFFReadEncodedStrip(input, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\r\n\t\t}\r\n\t\tbuf = buf + spp * LastStripSize * img_width * (bpp/8);\r\n\r\n\t\tpage++;\r\n\t\r\n\t}while ( page < static_cast<int>(last-first+1) && TIFFReadDirectory(input));//while (TIFFReadDirectory(input));\r\n\r\n\t// input file is assumedo ti be already open and it is provided as an handler; the file should be closed by caller\r\n\t//TIFFClose(input);  \r\n\r\n\tif ( page < static_cast<int>(last-first+1) ){\r\n\t\treturn ((char *) \"Cannot read all the pages.\");\r\n\t}\r\n\r\n\t// swap the data bytes if necessary \t\r\n\tif (b_swap)\r\n\t{\r\n\t\tint i;\r\n\t\tsize_t total = img_width * img_height * spp * (last-first+1);\r\n\t\tif (bpp/8 == 2)\r\n\t\t{\r\n\t\t\tfor (i=0;i<total; i++)\r\n\t\t\t{\r\n\t\t\t\tswap2bytes((void *)(img+2*i));\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (bpp/8 == 4)\r\n\t\t{\r\n\t\t\tfor (i=0;i<total; i++)\r\n\t\t\t{\r\n\t\t\t\tswap4bytes((void *)(img+4*i));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn (char *) 0;\r\n}",
    "void \r\n\tiomanager::tiff3D::readMetadata(\r\n\tstd::string img_path,\t\t// (INPUT)\timage filepath\r\n\tint & img_width,\t\t\t// (OUTPUT) image width  (in pixels)\r\n\tint & img_height,\t\t\t// (OUTPUT) image height (in pixels)\r\n\tint & img_depth,\t\t\t// (OUTPUT) image depth (in pixels)\r\n\tint & img_bytes_x_chan,\t// (OUTPUT) number of bytes per channel\r\n\tint & img_chans,\t\t\t// (OUTPUT) number of channels\r\n\tconst std::string & params)\t// (INPUT)\tadditional parameters <param1=val, param2=val, ...> \r\nthrow (iom::exception)\r\n{\r\n\t/**/iom::debug(iom::LEV3, iom::strprintf(\"img_path = %s, img_width = %d, img_height = %d, img_depth = %d, img_bytes_x_chan = %d, img_chans = %d, params = \\\"%s\\\"\",\r\n\t\timg_path.c_str(), img_width, img_height, img_depth,\timg_bytes_x_chan, img_chans, params.c_str()).c_str(), __iom__current__function__);\r\n\r\n\t// disable warning handler to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\r\n\tTIFF* input=TIFFOpen(img_path.c_str(),\"r\");\r\n\tif (!input)\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to open image \\\"%s\\\". Possible unsupported format or it isn't an image.\\nSupported format is 3DTIFF\", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &img_width))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGEWIDTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &img_height))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGELENGTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &img_bytes_x_chan))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_BITSPERSAMPLE' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_bytes_x_chan /= 8;\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &img_chans)) \r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_SAMPLESPERPIXEL' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\t// Onofri\r\n\tuint16 cpage;  // Current page. We do not actually need it.\r\n\tuint16 npages; // Number of pages. \r\n\tint PNcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &cpage, &npages);\r\n\tif (!PNcheck || npages==0) { // the tag has not been read correctly\r\n\t\tiom::warning(iom::strprintf(\"unable to determine 'TIFFTAG_PAGENUMBER' from image file \\\"%s\\\". \", img_path.c_str()).c_str(),__iom__current__function__);\r\n\t\timg_depth = 0;\r\n\t\tdo {\r\n\t\t\timg_depth++;\r\n\t\t} while (TIFFReadDirectory(input));\r\n\t}\r\n\telse\r\n\t\timg_depth = npages;\r\n\r\n\tTIFFClose(input);\r\n}",
    "void \r\n\tiomanager::tiff2D::readMetadata(\r\n\tstd::string img_path,\t\t\t// (INPUT)  image filepath\r\n\tint & img_width,\t\t\t\t// (OUTPUT) image width  (in pixels)\r\n\tint & img_height,\t\t\t\t// (OUTPUT) image height (in pixels)\r\n\tint & img_bytes_x_chan,\t\t\t// (OUTPUT) number of bytes per channel\r\n\tint & img_chans,\t\t\t\t// (OUTPUT) number of channels\r\n\tconst std::string & params)\t\t// (INPUT)  additional parameters <param1=val, param2=val, ...> \r\nthrow (iom::exception)\r\n{\r\n\t/**/iom::debug(iom::LEV3, iom::strprintf(\"img_path = \\\"%s\\\", params = \\\"%s\\\"\",img_path.c_str(), params.c_str()).c_str(), __iom__current__function__);\r\n\r\n\tuint16 bpp;\r\n\tuint16 spp;\r\n\r\n\t // disable warning handler to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\r\n\tTIFF* input=TIFFOpen(img_path.c_str(),\"r\");\r\n\tif (!input)\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to open image \\\"%s\\\". Possible unsupported format or it isn't an image.\\nSupported format is 2DTIFF\", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &img_width))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGEWIDTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &img_height))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGELENGTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_BITSPERSAMPLE' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_bytes_x_chan = bpp/8;\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp)) \r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_SAMPLESPERPIXEL' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_chans = spp;\r\n\r\n\t// Onofri\r\n\tint img_depth;\t\t\t// image depth (in pixels)\r\n\tuint16 cpage;  // Current page. We do not actually need it.\r\n\tuint16 npages; // Number of pages. \r\n\tint PNcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &cpage, &npages);\r\n\tif (!PNcheck || npages==0) { // the tag has not been read correctly\r\n\t\tiom::warning(iom::strprintf(\"unable to determine 'TIFFTAG_PAGENUMBER' from image file \\\"%s\\\". \", img_path.c_str()).c_str(),__iom__current__function__);\r\n\t\timg_depth = 0;\r\n\t\tdo {\r\n\t\t\timg_depth++;\r\n\t\t} while (TIFFReadDirectory(input));\r\n\t}\r\n\telse\r\n\t\timg_depth = npages;\r\n\r\n\tTIFFClose(input);\r\n\t\r\n\t// check the exception after closing the file\r\n\tif ( img_depth > 1 ) \r\n\t\tthrow iom::exception(iom::strprintf(\"image \\\"%s\\\" has more than one page.\\nSupported format is 2DTIFF\", img_path.c_str()), __iom__current__function__);\r\n}",
    "unsigned char *readtiff(char *myfile, int *width, int *height, int *depth, int *channels )\n//================================================================================\n\n{\n    TIFF* tif = TIFFOpen(myfile, \"r\");\n    if (tif)\n    {\n\t\t*depth = 0;\n\t\tdo\n\t\t{\n\t\t\t(*depth)++;\n\t\t\tuint16 compression, cc, bpp         ;\n\t\t\t\n\t\t\t//check if we are reading a compressed image. If so\n\t\t\t//return with an error\n\t\t\tTIFFGetField(tif, TIFFTAG_COMPRESSION, &compression);\n\t\t\t\n\t\t\tif ( compression != COMPRESSION_NONE )\n\t\t\t{\n\t\t\t\tcerr<<\"File is not an Uncompressed TIFF image !\\n\";\n\t\t\t}\n\t\t\t\n\t\t\t//check if the image has 8 bits-per-pixel in each channel\n\t\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp);\n\t\t\t\n\t\t\tif ( bpp != 8 )\n\t\t\t{\n\t\t\t\tcerr<<\"File does not have 8 bits per channel !\\n\";\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t//read the dimensions of the TIFF image\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH , width);//width\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, height);//height\n\t\t\t//determine what type of image is it (color or grayscale)\n\t\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cc);\n\t\t\t\n\t\t\t//get the photometric if a grayscale image is\n\t\t\t//being read\n\t\t\tif (cc == 1)\n\t\t\t{\n\t\t\t\t*channels = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*channels = 3;\n\t\t\t}\n\t\t}while(TIFFReadDirectory(tif));\n\t\t\n\t\tTIFFClose(tif);\n\t}\n\telse\n    {\n        cerr<<\"Unable to open file for reading !\\n\";\n    }\n\t\n\t\n\ttif = TIFFOpen(myfile,\"r\");\n\tif(tif)\n\t{\n\t\tunsigned char *img = new unsigned char[(*channels)*(*width)*(*height)*(*depth)];\n\t\tint layer = 0;\n\t\tdo\n\t\t{\t\t\t\n\t\t\tuint16 p, compression, cc, bpp;\n\t\t\t\n\t\t\t//check if we are reading a compressed image. If so\n\t\t\t//return with an error\n\t\t\tTIFFGetField(tif, TIFFTAG_COMPRESSION, &compression);\n\t\t\t\n\t\t\tif ( compression != COMPRESSION_NONE )\n\t\t\t{\n\t\t\t\tcerr<<\"File is not an Uncompressed TIFF image !\\n\";\n\t\t\t}\n\t\t\t\n\t\t\t//check if the image has 8 bits-per-pixel in each channel\n\t\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp);\n\t\t\t\n\t\t\tif ( bpp != 8 )\n\t\t\t{\n\t\t\t\tcerr<<\"File does not have 8 bits per channel !\\n\";\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t//read the dimensions of the TIFF image\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH , width);//width\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, height);//height\n\t\t\t//determine what type of image is it (color or grayscale)\n\t\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cc);\n\t\t\t\n\t\t\t//get the photometric if a grayscale image is\n\t\t\t//being read\n\t\t\tif (cc == 1)\n\t\t\t{\n\t\t\t\t*channels = 1;\n\t\t\t\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &p);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*channels = 3;\n\t\t\t}\n\t\t\t\n\t\t\t//create the matrix to hold the image data\n\t\t\t\n\t\t\t//create a dummy array\n\t\t\tint linebytes = (*channels)*(*width);\n\t\t\tunsigned char *buf = new unsigned char[linebytes];\n\t\t\t\n\t\t\t//start reading the data from the TIFF file in scanlines\n\t\t\tfor ( int row = 0; row < *height; row++ )\n\t\t\t{\n\t\t\t\tif(TIFFReadScanline(tif, buf, row, 0) != 1)\n\t\t\t\t{\n\t\t\t\t\tcerr<<\"Error reading TIFF scanline !\\n\";\n\t\t\t\t}\n\t\t\t\tmemcpy(&img[layer*(*channels)*(*width)*(*height)+row*linebytes], buf, linebytes);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tdelete(buf);\n\t\t\n\t\t\tlayer++;\n\t\t} while(TIFFReadDirectory(tif));\n\t\t\t\n        TIFFClose(tif);\n\t\t\n\t\treturn img;\n    }\n\t\n\treturn NULL;\n}",
    "bool QTiffHandlerPrivate::openForRead(QIODevice *device)\n{\n    if (tiff)\n        return true;\n\n    if (!canRead(device))\n        return false;\n\n    tiff = TIFFClientOpen(\"foo\",\n                          \"r\",\n                          device,\n                          qtiffReadProc,\n                          qtiffWriteProc,\n                          qtiffSeekProc,\n                          qtiffCloseProc,\n                          qtiffSizeProc,\n                          qtiffMapProc,\n                          qtiffUnmapProc);\n\n    if (!tiff) {\n        return false;\n    }\n    uint32 width;\n    uint32 height;\n    if (!TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width)\n        || !TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height)\n        || !TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &photometric)) {\n        close();\n        return false;\n    }\n    size = QSize(width, height);\n\n    uint16 orientationTag;\n    if (TIFFGetField(tiff, TIFFTAG_ORIENTATION, &orientationTag))\n        transformation = exif2Qt(orientationTag);\n\n    // BitsPerSample defaults to 1 according to the TIFF spec.\n    uint16 bitPerSample;\n    if (!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitPerSample))\n        bitPerSample = 1;\n    uint16 samplesPerPixel; // they may be e.g. grayscale with 2 samples per pixel\n    if (!TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel))\n        samplesPerPixel = 1;\n\n    grayscale = photometric == PHOTOMETRIC_MINISBLACK || photometric == PHOTOMETRIC_MINISWHITE;\n\n    if (grayscale && bitPerSample == 1 && samplesPerPixel == 1)\n        format = QImage::Format_Mono;\n    else if (photometric == PHOTOMETRIC_MINISBLACK && bitPerSample == 8 && samplesPerPixel == 1)\n        format = QImage::Format_Grayscale8;\n    else if ((grayscale || photometric == PHOTOMETRIC_PALETTE) && bitPerSample == 8 && samplesPerPixel == 1)\n        format = QImage::Format_Indexed8;\n    else if (samplesPerPixel < 4)\n        format = QImage::Format_RGB32;\n    else\n        format = QImage::Format_ARGB32_Premultiplied;\n\n    headersRead = true;\n    return true;\n}",
    "bool QTiffHandler::read(QImage *image)\n{\n    // Open file and read headers if it hasn't already been done.\n    if (!d->openForRead(device()))\n        return false;\n\n    QImage::Format format = d->format;\n    if (format == QImage::Format_RGB32 &&\n            (image->format() == QImage::Format_ARGB32 ||\n             image->format() == QImage::Format_ARGB32_Premultiplied))\n        format = image->format();\n\n    if (image->size() != d->size || image->format() != format)\n        *image = QImage(d->size, format);\n\n    TIFF *const tiff = d->tiff;\n    const uint32 width = d->size.width();\n    const uint32 height = d->size.height();\n\n    if (format == QImage::Format_Mono) {\n        QVector<QRgb> colortable(2);\n        if (d->photometric == PHOTOMETRIC_MINISBLACK) {\n            colortable[0] = 0xff000000;\n            colortable[1] = 0xffffffff;\n        } else {\n            colortable[0] = 0xffffffff;\n            colortable[1] = 0xff000000;\n        }\n        image->setColorTable(colortable);\n\n        if (!image->isNull()) {\n            for (uint32 y=0; y<height; ++y) {\n                if (TIFFReadScanline(tiff, image->scanLine(y), y, 0) < 0) {\n                    d->close();\n                    return false;\n                }\n            }\n        }\n    } else {\n        if (format == QImage::Format_Indexed8) {\n            if (!image->isNull()) {\n                const uint16 tableSize = 256;\n                QVector<QRgb> qtColorTable(tableSize);\n                if (d->grayscale) {\n                    for (int i = 0; i<tableSize; ++i) {\n                        const int c = (d->photometric == PHOTOMETRIC_MINISBLACK) ? i : (255 - i);\n                        qtColorTable[i] = qRgb(c, c, c);\n                    }\n                } else {\n                    // create the color table\n                    uint16 *redTable = 0;\n                    uint16 *greenTable = 0;\n                    uint16 *blueTable = 0;\n                    if (!TIFFGetField(tiff, TIFFTAG_COLORMAP, &redTable, &greenTable, &blueTable)) {\n                        d->close();\n                        return false;\n                    }\n                    if (!redTable || !greenTable || !blueTable) {\n                        d->close();\n                        return false;\n                    }\n\n                    for (int i = 0; i<tableSize ;++i) {\n                        const int red = redTable[i] / 257;\n                        const int green = greenTable[i] / 257;\n                        const int blue = blueTable[i] / 257;\n                        qtColorTable[i] = qRgb(red, green, blue);\n                    }\n                }\n\n                image->setColorTable(qtColorTable);\n                for (uint32 y=0; y<height; ++y) {\n                    if (TIFFReadScanline(tiff, image->scanLine(y), y, 0) < 0) {\n                        d->close();\n                        return false;\n                    }\n                }\n\n                // free redTable, greenTable and greenTable done by libtiff\n            }\n        } else if (format == QImage::Format_Grayscale8) {\n            if (!image->isNull()) {\n                for (uint32 y = 0; y < height; ++y) {\n                    if (TIFFReadScanline(tiff, image->scanLine(y), y, 0) < 0) {\n                        d->close();\n                        return false;\n                    }\n                }\n            }\n        } else {\n            if (!image->isNull()) {\n                const int stopOnError = 1;\n                if (TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32 *>(image->bits()), qt2Exif(d->transformation), stopOnError)) {\n                    for (uint32 y=0; y<height; ++y)\n                        convert32BitOrder(image->scanLine(y), width);\n                } else {\n                    d->close();\n                    return false;\n                }\n            }\n        }\n    }\n\n    if (image->isNull()) {\n        d->close();\n        return false;\n    }\n\n    float resX = 0;\n    float resY = 0;\n    uint16 resUnit;\n    if (!TIFFGetField(tiff, TIFFTAG_RESOLUTIONUNIT, &resUnit))\n        resUnit = RESUNIT_INCH;\n\n    if (TIFFGetField(tiff, TIFFTAG_XRESOLUTION, &resX)\n        && TIFFGetField(tiff, TIFFTAG_YRESOLUTION, &resY)) {\n\n        switch(resUnit) {\n        case RESUNIT_CENTIMETER:\n            image->setDotsPerMeterX(qRound(resX * 100));\n            image->setDotsPerMeterY(qRound(resY * 100));\n            break;\n        case RESUNIT_INCH:\n            image->setDotsPerMeterX(qRound(resX * (100 / 2.54)));\n            image->setDotsPerMeterY(qRound(resY * (100 / 2.54)));\n            break;\n        default:\n            // do nothing as defaults have already\n            // been set within the QImage class\n            break;\n        }\n    }\n\n    d->close();\n    return true;\n}",
    "TiffInfo GetTiffInfo(TIFF* tiffptr)\n{\n    TiffInfo info = {};\n\n    LIBTIFF_CALL(TIFFGetField(tiffptr, TIFFTAG_IMAGEWIDTH, &info.image_width));\n    LIBTIFF_CALL(TIFFGetField(tiffptr, TIFFTAG_IMAGELENGTH, &info.image_height));\n    LIBTIFF_CALL(TIFFGetFieldDefaulted(tiffptr, TIFFTAG_SAMPLESPERPIXEL, &info.channels));\n    LIBTIFF_CALL(TIFFGetFieldDefaulted(tiffptr, TIFFTAG_BITSPERSAMPLE, &info.bit_depth));\n    LIBTIFF_CALL(TIFFGetFieldDefaulted(tiffptr, TIFFTAG_ORIENTATION, &info.orientation));\n    LIBTIFF_CALL(TIFFGetFieldDefaulted(tiffptr, TIFFTAG_COMPRESSION, &info.compression));\n    LIBTIFF_CALL(TIFFGetFieldDefaulted(tiffptr, TIFFTAG_ROWSPERSTRIP, &info.rows_per_strip));\n    LIBTIFF_CALL(TIFFGetFieldDefaulted(tiffptr, TIFFTAG_FILLORDER, &info.fill_order));\n\n    info.is_tiled = TIFFIsTiled(tiffptr);\n    if (info.is_tiled) {\n        LIBTIFF_CALL(TIFFGetField(tiffptr, TIFFTAG_TILEWIDTH, &info.tile_width));\n        LIBTIFF_CALL(TIFFGetField(tiffptr, TIFFTAG_TILELENGTH, &info.tile_height));\n    } else {\n        // We will be reading data line-by-line and pretend that lines are tiles\n        info.tile_width = info.image_width;\n        info.tile_height = 1;\n    }\n\n    if (TIFFGetField(tiffptr, TIFFTAG_PHOTOMETRIC, &info.photometric_interpretation)) {\n        info.is_palette = (info.photometric_interpretation == PHOTOMETRIC_PALETTE);\n    } else {\n        info.photometric_interpretation = PHOTOMETRIC_MINISBLACK;\n    }\n\n    uint16_t planar_config;\n    LIBTIFF_CALL(TIFFGetFieldDefaulted(tiffptr, TIFFTAG_PLANARCONFIG, &planar_config));\n    info.is_planar = (planar_config == PLANARCONFIG_SEPARATE);\n\n    if (info.is_palette) {\n        LIBTIFF_CALL(TIFFGetField(tiffptr, TIFFTAG_COLORMAP, &info.palette.red, &info.palette.green, &info.palette.blue));\n        info.channels = 3; // Palette is always RGB\n        info.key_bit_depth = info.bit_depth;\n        info.bit_depth = 16; // Palette colors are always 16 bits\n    }\n\n    return info;\n}",
    "char *loadTiffMetaInfo(char* filename, uint32 &sz0, uint32  &sz1, uint32  &sz2, uint32  &sz3, uint16 &datatype)\n{\n    //\n    TIFFSetWarningHandler(0);\n    TIFFSetErrorHandler(0);\n\n    //\n    TIFF *input = TIFFOpen(filename,\"r\");\n    if (!input)\n    {\n        return ((char *) \"Cannot open the file.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &sz0))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image width of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &sz1))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image length of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &datatype))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined bits per sample.\");\n    }\n\n//    if (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &sz3))\n//    {\n//        sz3 = 1;\n//    }\n\n    sz3 = 1; // hard coded here 6/8/2018\n\n    uint16 Cpage;\n    if (!TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &sz2) || sz2==0)\n    {\n        sz2 = 1;\n        while ( TIFFReadDirectory(input) )\n        {\n            sz2++;\n        }\n    }\n    datatype /= 8;\n\n    //\n    TIFFClose(input);\n\n    //\n    return ((char *) 0);\n}",
    "void readTiff( stringstream *dataStreamInMemory, unsigned char *&img, unsigned int first, unsigned int last, int starti, int endi, int startj, int endj )\n{\n    //\n    TIFF* input = TIFFStreamOpen(\"MemTIFF\", (istream *)dataStreamInMemory);\n\n    //\n    uint32 rps;\n    uint16 spp, bpp, photo, comp, planar_config;\n    int StripsPerImage,LastStripSize;\n    unsigned int img_width, img_height;\n\n    //\n    if (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &img_width))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &img_height))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp))\n    {\n        spp = 1;\n    }\n\n    int b_swap=TIFFIsByteSwapped(input);\n\n    //\n    if (!TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &photo))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_COMPRESSION, &comp))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_PLANARCONFIG, &planar_config))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    //\n    starti = (starti == -1) ? 0 : starti;\n    endi   = (endi == -1) ? img_height-1 : endi;\n    startj = (startj == -1) ? 0 : startj;\n    endj   = (endj == -1) ? img_width-1 : endj;\n\n    // file is internally tiled\n    if (TIFFIsTiled(input))\n    {\n        uint32 tilewidth;\n        uint32 tilelength;\n        uint32 tiledepth;\n        tsize_t tilenum;\n        tsize_t tilesize;\n        tsize_t tilenum_width;\n        tsize_t tilenum_length;\n        ttile_t tile;\n        tdata_t data;\n        unsigned char *psrc; // pointer in the tile buffer to the top left pixel of the current block to be copied\n        unsigned char *pdst; // pointer in the image buffer to the top left pixel of the current block to be filled\n        uint32 stride_src;\n        uint32 stride_dst;\n        int i; // row index in the slice of the top left pixel of the current block to be filled\n        int j; // column index in the slice of the top left pixel of the current block to be filled\n        uint32 width; // width of the current block to be filled (in pixels)\n        uint32 len; // length of the current block to be filled (in pixels)\n        int page;\n\n        // checks\n        if ( TIFFGetField(input, TIFFTAG_TILEDEPTH, &tiledepth) )\n        {\n            cout<<\"Tiling among slices (z direction) not supported.\"<<endl;\n            return;\n        }\n        if ( spp > 1 )\n        {\n            if ( TIFFGetField(input, TIFFTAG_PLANARCONFIG, &planar_config) )\n            {\n                if ( planar_config > 1 )\n                {\n                    cout<<\"Non-interleaved multiple channels not supported with tiling.\"<<endl;\n                    return;\n                }\n            }\n        }\n\n        // tiling is in x,y only\n        TIFFGetField(input, TIFFTAG_TILEWIDTH, &tilewidth);\n        TIFFGetField(input, TIFFTAG_TILELENGTH, &tilelength);\n        tilenum = TIFFNumberOfTiles(input);\n        tilesize = TIFFTileSize(input);\n        tilenum_width  = (img_width % tilewidth) ? (img_width / tilewidth) + 1 : img_width / tilewidth;\n        tilenum_length = (img_height % tilelength) ? (img_height / tilelength) + 1 : img_height / tilelength;\n\n        data = new unsigned char[tilesize];\n        stride_src = tilewidth * spp; // width of tile (in bytes)\n        stride_dst = (endj - startj + 1) * spp; // width of subregion (in bytes)\n\n        page = 0;\n        do {\n\n            psrc = ((unsigned char *)data) + ((starti % tilelength)*tilewidth + (startj % tilewidth)) * spp; // in the first tile skip (starti % tilelength) rows plus (startj % tilewidth) pixels\n            pdst = img; // the buffer has the size of the subregion\n            len = tilelength - (starti % tilelength); // rows to be copied for the first row of tiles\n            tile = TIFFComputeTile(input,startj,starti,0,0); // index of the first tile to be copied in the current row of tiles\n            for ( i=starti; i<=endi; ) {\n                width = tilewidth - (startj%tilewidth); // width of the first block to be copied/filled\n                for ( j=startj; j<=endj; ) {\n                    TIFFReadEncodedTile(input,tile,data,(tsize_t) -1); // read tile into tile buffer\n                    copydata (psrc,stride_src,pdst,stride_dst,(width * spp),len); // copy the block\n                    j += width;\n                    tile++; // index of the next tile in the same row of tiles\n                    psrc = ((unsigned char *)data) + ((i % tilelength)*tilewidth) * spp; // the block in the next tile begins just after (i % tilelength) rows\n                    pdst += width * spp; // the block in the image buffer move forward of width pixels\n                    width = (((tile%tilenum_width) + 1) * tilewidth <= (endj+1)) ? tilewidth : ((endj+1)%tilewidth); // if the next tile in the row is all within the subregion, width is tilewidth otherwise it is shorter\n                }\n                i += len;\n                tile = TIFFComputeTile(input,startj,i,0,0); // index of the first tile to be copied in the current row of tiles\n                psrc = ((unsigned char *)data) + ((i % tilelength)*tilewidth + (startj % tilewidth)) * spp; // in the first tile of the next row of tiles skip (i % tilelength) rows plus (startj % tilewidth) pixels\n                pdst = img + ((i-starti) * stride_dst); // the block in the image buffer begin after (i-starti) rows\n                len = (((tile/tilenum_width) + 1) * tilelength <= (endi+1)) ? tilelength : ((endi+1)%tilelength); // if the next row of tiles is all within the subregion, len is tilelength otherwise it is shorter\n            }\n\n            page++;\n\n        }while ( page < static_cast<int>(last-first+1) && TIFFReadDirectory(input));\n\n        return;\n    }\n\n    //\n    if (!TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rps))\n    {\n        TIFFClose(input);\n        dataStreamInMemory->clear();\n        dataStreamInMemory->str(string());\n        return;\n    }\n\n    StripsPerImage =  (img_height + rps - 1) / rps;\n    LastStripSize = img_height % rps;\n    if (LastStripSize==0)\n        LastStripSize=rps;\n\n    unsigned char *buf = img;\n    int page=0;\n\n    if ( starti < 0 || endi >= img_height || startj < 0 || endj >= img_width || starti >= endi || startj >= endj )\n    {\n        cout<<\"Wrong substack indices.\"<<endl;\n        return;\n    }\n\n    if ( starti == 0 && endi == (img_height-1) && startj == 0 && endj == (img_width-1) ) { // read whole images from files\n\n        if (!TIFFSetDirectory(input, first))\n        {\n            TIFFClose(input);\n            dataStreamInMemory->clear();\n            dataStreamInMemory->str(string());\n            return;\n        }\n\n        do{\n\n            for (int i=0; i < StripsPerImage-1; i++){\n                if (comp==1) {\n                    TIFFReadRawStrip(input, i, buf, spp * rps * img_width * (bpp/8));\n                    buf = buf + spp * rps * img_width * (bpp/8);\n                }\n                else{\n                    TIFFReadEncodedStrip(input, i, buf, spp * rps * img_width * (bpp/8));\n                    buf = buf + spp * rps * img_width * (bpp/8);\n                }\n            }\n\n            if (comp==1) {\n                TIFFReadRawStrip(input, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\n            }\n            else{\n                TIFFReadEncodedStrip(input, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\n            }\n            buf = buf + spp * LastStripSize * img_width * (bpp/8);\n\n            page++;\n\n        }while ( page < static_cast<int>(last-first+1) && TIFFReadDirectory(input));// while (TIFFReadDirectory(input));\n\n    }\n    else { // read only a subregion of images from files\n\n        unsigned int XSIZE = img_width;\n\n        unsigned char *rowbuf = new unsigned char[spp * rps * XSIZE * (bpp/8)];\n        unsigned char *bufptr;\n\n        do{\n            if (!TIFFSetDirectory(input, first + page))\n            {\n                TIFFClose(input);\n                ssclear(dataStreamInMemory);\n                return;\n            }\n\n            int stripIndex = (starti / rps) - 1; // the strip preceeding the first one\n            for (int i=starti; i <= endi; i++) {\n                if ( floor((double)i / rps) > stripIndex ) { // read a new strip\n                    stripIndex = (int)floor((double)i / rps);\n                    if (comp==1) {\n                        TIFFReadRawStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\n                    }\n                    else{\n                        TIFFReadEncodedStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\n                    }\n                }\n                bufptr = rowbuf + (i % rps) * (spp * XSIZE * (bpp/8));\n                if ( bpp == 8 )\n                    for (int j=0, j1=startj; j<=(endj-startj); j++, j1++) {\n                        for (int c=0; c<spp; c++) {\n                            buf[j * spp + c] = bufptr[j1 * spp + c];\n                        }\n                    }\n                else\n                    for (int j=0 , j1=startj; j<=(endj-startj); j++, j1++) {\n                        for (int c=0; c<spp; c++) {\n                            ((uint16 *)buf)[j * spp + c] = ((uint16 *)bufptr)[j1 * spp + c];\n                        }\n                    }\n                buf = buf + spp * (endj-startj+1) * (bpp/8);\n            }\n\n            page++;\n\n        }while ( page < static_cast<int>(last-first+1) );\n\n        delete []rowbuf;\n\n    }\n\n    if ( page < static_cast<int>(last-first+1) ){\n        return;\n    }\n\n    //\n    TIFFClose(input);\n    ssclear(dataStreamInMemory);\n\n    // swap the data bytes if necessary\n    if (b_swap)\n    {\n        int i;\n        size_t total = img_width * img_height * spp * (last-first+1);\n        if (bpp/8 == 2)\n        {\n            for (i=0;i<total; i++)\n            {\n                swap2bytes((void *)(img+2*i));\n            }\n        }\n        else if (bpp/8 == 4)\n        {\n            for (i=0;i<total; i++)\n            {\n                swap4bytes((void *)(img+4*i));\n            }\n        }\n    }\n\n    //\n    return;\n}",
    "char *tiffread(const char* filename, unsigned char *&p, uint32 &sz0, uint32  &sz1, uint32  &sz2, uint16 &datatype)\n{\n    //\n    TIFF *input = TIFFOpen(filename,\"r\");\n    if (!input)\n    {\n        return ((char *) \"Cannot open the file.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &sz0))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image width of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &sz1))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image length of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &datatype))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined bits per sample.\");\n    }\n\n    uint16 Cpage;\n    if (!TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &sz2) || sz2==0)\n    {\n        sz2 = 1;\n        while ( TIFFReadDirectory(input) )\n        {\n            sz2++;\n        }\n    }\n    datatype /= 8;\n\n    //cout<<\"test \"<<sz0<<\" \"<<sz1<<\" \"<<sz2<<\" \"<<datatype<<endl;\n\n    V3DLONG imgsz = (V3DLONG)sz0*(V3DLONG)sz1*(V3DLONG)sz2*(V3DLONG)datatype;\n\n    //\n    try\n    {\n        p = new unsigned char [imgsz];\n    }\n    catch(...)\n    {\n        return ((char*) \"fail to alloc memory for loading a tiff image.\");\n    }\n\n    //\n    uint32 rps;\n    int StripsPerImage,LastStripSize;\n\n    //\n    if (!TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rps))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined rowsperstrip.\");\n    }\n\n    uint16 comp;\n    if (!TIFFGetField(input, TIFFTAG_COMPRESSION, &comp))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined compression.\");\n    }\n\n    StripsPerImage =  (sz1 + rps - 1) / rps;\n    LastStripSize = sz1 % rps;\n    if (LastStripSize==0)\n        LastStripSize=rps;\n\n    if (!TIFFSetDirectory(input, 0)) // init\n    {\n        TIFFClose(input);\n        return ((char *) \"fail to setdir.\");\n    }\n\n    unsigned char *buf = p;\n    do{\n        for (int i=0; i < StripsPerImage-1; i++)\n        {\n            cout<<\"i \"<<i<<endl;\n\n            if (comp==1)\n            {\n                TIFFReadRawStrip(input, i, buf,  rps * sz0 * datatype);\n                buf = buf + rps * sz0 * datatype;\n            }\n            else\n            {\n                TIFFReadEncodedStrip(input, i, buf, rps * sz0 * datatype);\n                buf = buf + rps * sz0 * datatype;\n            }\n        }\n\n        if (comp==1)\n        {\n            TIFFReadRawStrip(input, StripsPerImage-1, buf, LastStripSize * sz0 * datatype);\n        }\n        else\n        {\n            TIFFReadEncodedStrip(input, StripsPerImage-1, buf, LastStripSize * sz0 * datatype);\n        }\n        buf = buf + LastStripSize * sz0 * datatype;\n\n    } while(TIFFReadDirectory(input));\n\n    //\n    TIFFClose(input);\n\n    //\n    return ((char *) 0);\n}",
    "char *tiffread(char* filename, unsigned char *&p, uint32 &sz0, uint32  &sz1, uint32  &sz2, uint16 &datatype, uint16 &comp)\n{\n    //\n    TIFF *input = TIFFOpen(filename,\"r\");\n    if (!input)\n    {\n        return ((char *) \"Cannot open the file.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &sz0))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image width of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &sz1))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image length of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &datatype))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined bits per sample.\");\n    }\n\n    uint16 Cpage;\n    if (!TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &sz2) || sz2==0)\n    {\n        sz2 = 1;\n        while ( TIFFReadDirectory(input) )\n        {\n            sz2++;\n        }\n    }\n    datatype /= 8;\n\n    //cout<<\"test \"<<sz0<<\" \"<<sz1<<\" \"<<sz2<<\" \"<<datatype<<endl;\n\n    long imgsz = (long)sz0*(long)sz1*(long)sz2*(long)datatype;\n\n    //\n    try\n    {\n        p = new unsigned char [imgsz];\n    }\n    catch(...)\n    {\n        return ((char*) \"fail to alloc memory for loading a tiff image.\");\n    }\n\n    //\n    uint32 rps;\n    int StripsPerImage,LastStripSize;\n\n    //\n    if (!TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rps))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined rowsperstrip.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_COMPRESSION, &comp))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined compression.\");\n    }\n\n    StripsPerImage =  (sz1 + rps - 1) / rps;\n    LastStripSize = sz1 % rps;\n    if (LastStripSize==0)\n        LastStripSize=rps;\n\n    if (!TIFFSetDirectory(input, 0)) // init\n    {\n        TIFFClose(input);\n        return ((char *) \"fail to setdir.\");\n    }\n\n    unsigned char *buf = p;\n\n    do{\n        for (int i=0; i < StripsPerImage-1; i++)\n        {\n            if (comp==1)\n            {\n                TIFFReadRawStrip(input, i, buf,  rps * sz0 * datatype);\n                buf = buf + rps * sz0 * datatype;\n            }\n            else\n            {\n                TIFFReadEncodedStrip(input, i, buf, rps * sz0 * datatype);\n                buf = buf + rps * sz0 * datatype;\n            }\n        }\n\n        if (comp==1)\n        {\n            TIFFReadRawStrip(input, StripsPerImage-1, buf, LastStripSize * sz0 * datatype);\n        }\n        else\n        {\n            TIFFReadEncodedStrip(input, StripsPerImage-1, buf, LastStripSize * sz0 * datatype);\n        }\n        buf = buf + LastStripSize * sz0 * datatype;\n\n    }\n    while (TIFFReadDirectory(input)); // while (TIFFReadDirectory(input));\n\n    //\n    TIFFClose(input);\n\n    //\n    return ((char *) 0);\n}",
    "char *loadTiff3D2Metadata ( char * filename, unsigned int &sz0, unsigned int  &sz1, unsigned int  &sz2, unsigned int  &sz3, int &datatype, int &b_swap, void * &fhandle, int &header_len ) {\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffLoadMetadata);\r\n    #endif\r\n\r\n    uint32 XSIZE;\r\n    uint32 YSIZE;\r\n    uint16 bpp;\r\n    uint16 spp;\r\n    uint16 Cpage;\r\n    uint16 Npages;\r\n    TIFF *input;\r\n    int check;\r\n\r\n    //disable warning and error handlers to avoid messages on unrecognized tags\r\n    TIFFSetWarningHandler(0);\r\n    TIFFSetErrorHandler(0);\r\n\r\n    input=TIFFOpen(filename,\"r\");\r\n    if (!input)\r\n    {\r\n        //throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Cannot open the file %s\",finName).c_str());\r\n        return ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n    check=TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &XSIZE);\r\n    if (!check)\r\n    {\r\n        TIFFClose(input);\r\n        //throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n        return ((char *) \"Image width of undefined.\");\r\n    }\r\n    \r\n    check=TIFFGetField(input, TIFFTAG_IMAGELENGTH, &YSIZE);\r\n    if (!check)\r\n    {\r\n        TIFFClose(input);\r\n        //throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n        return ((char *) \"Image length of undefined.\");\r\n    }\r\n    \r\n    check=TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp);\r\n    if (!check)\r\n    {\r\n        TIFFClose(input);\r\n        //throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n        return ((char *) \"Undefined bits per sample.\");\r\n    }\r\n\r\n    check=TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n    if (!check)\r\n    {\r\n        spp = 1;\r\n        //TIFFClose(input);\r\n        //throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n        //return ((char *) \"Undefined samples per pixel.\");\r\n    }\r\n\r\n    // Onofri\r\n    check=TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &Npages);\r\n    if (!check || Npages==0) { // the tag has not been read correctly\r\n        // Add warning?\r\n        Npages = 0;\r\n        do {\r\n            Npages++;\r\n        } while ( TIFFReadDirectory(input) );\r\n    }\r\n\r\n    sz0 = XSIZE;\r\n    sz1 = YSIZE;\r\n    sz2 = Npages;\r\n    sz3 = spp;\r\n    datatype = bpp/8;\r\n\r\n    //b_swap = 0;\r\n    b_swap=TIFFIsByteSwapped(input);\r\n    fhandle = (void *) input;\r\n    header_len = -1;\r\n\r\n    // the file must non be closed (it is responsibility of the caller)\r\n    //TIFFClose(input);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffLoadMetadata, tf::IO, tf::strprintf(\"successfully loaded metadata from file \\\"%s\\\"\", filename));\r\n    #endif\r\n\r\n    return ((char *) 0);\r\n}",
    "int read_lsm_slice_strip(TIFF *in, unsigned char * pointer_first_page, long pagepixelnumber, long channelpixelnumber, int datatype)\n{\n\ttsize_t bufsize  = TIFFStripSize(in);\n\tif ((pagepixelnumber*datatype)!=bufsize)\n\t{\n\t\tfprintf(stderr, \"The current strip has a different size from the expected size in read_lsm_slice_strip(). No data is read.\\n\");\n\t\treturn 1;\n\t}\n\t\n\t//unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);\n\t\n\t/*\n    uint8 * row = image->array;\n\tlong width  = image->width;\n\tlong height = image->height;\n\tlong totalpixel=width*height; \n\t*/\n\n\t//if (buf) {\n\tif (pointer_first_page) {\n\t\ttstrip_t s, ns = TIFFNumberOfStrips(in);\n\t\tuint32 *bytecounts;\n\t\tuint32 *stripoffsets;\n\n\t\tTIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts);\n\t\t\n\t\tTIFFGetField(in, TIFFTAG_STRIPOFFSETS, &stripoffsets);\n\n\t\tfor (s = 0; s < ns; s++) \n\t\t{\n\t\t\t//printf(\"TIFFTAG_STRIPBYTECOUNTS and TIFFTAG_STRIPOFFSETS are [%d][%ld][%ld]\\n\", s, bytecounts[s], stripoffsets[s]); \n\t\t\t//if (TIFFReadEncodedStrip(in, s, pointer_first_page + long(s)*channelpixelnumber, (tsize_t) -1)<0) \n\n\t\t\t//if (TIFFReadEncodedStrip(in, s, pointer_first_page + long(s)*channelpixelnumber, pagepixelnumber)<0) //*datatype, 080301\n\t\t\tif (TIFFReadEncodedStrip(in, s, pointer_first_page + long(s)*channelpixelnumber*datatype, pagepixelnumber*datatype)<0) //*datatype, 080301 to handle 12/16 bit LSM\n\t\t\t//if (phc_TIFFReadEncodedStrip(in, s, pointer_first_page + long(s)*channelpixelnumber, pagepixelnumber)<0) \n\t\t\t{\n//\t\t\t\t_TIFFfree(buf);\n\t\t\t\t//return (0);\n\t\t\t\t//(*in->tif_postdecode)(in, pointer_first_page + long(s)*channelpixelnumber, pagepixelnumber);\n\t\t\t\tcontinue;\n\t\t\t}\n/*\t\t\telse\n\t\t\t{\n\t\t\t\tunsigned char * curpt = ;\n\t\t\t\tlong i;\n\t\t\t\tfor (i=0;i<bufsize;i++)\n\t\t\t\t{\n\t\t\t\t\t*curpt++ = (uint8)(buf[i]); //force the conversion. no work for 12-bit lsm yet. PHC 070806\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t//_TIFFfree(buf);\n\t\treturn (1);\n\t}\n\treturn 0;\n}",
    "int read_lsm_slice_tile(TIFF *in, unsigned char * pointer_first_page, long pagepixelnumber, long channelpixelnumber, int datatype)\n{\n\ttsize_t bufsize = TIFFTileSize(in);\n\tif ((pagepixelnumber*datatype)!=bufsize)\n\t{\n\t\tfprintf(stderr, \"The current tile has a different size from the expected size in read_lsm_slice_tile(). No data is read.\\n\");\n\t\treturn 1;\n\t}\n\t\n\t//unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);\n\n\t//if (buf) {\n\tif (pointer_first_page) {\n\t\tttile_t t, nt = TIFFNumberOfTiles(in);\n\t\tuint32 *bytecounts;\n\n\t\tTIFFGetField(in, TIFFTAG_TILEBYTECOUNTS, &bytecounts);\n\t\tfor (t = 0; t < nt; t++) \n\t\t{\n\t\t\t//if (TIFFReadEncodedTile(in, t, buf, bytecounts[t]) < 0) \n\t\t\tif (TIFFReadEncodedTile(in, t, pointer_first_page + long(t)*channelpixelnumber, bytecounts[t]) < 0) \n\t\t\t{\n//\t\t\t\t_TIFFfree(buf);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\t/*\n\t\t\telse\n\t\t\t{\n\t\t\t\tlong i;\n\t\t\t\tfor (i=0;i<bufsize;i++)\n\t\t\t\t{\n\t\t\t\t\trow[i*3+s] = (uint8)(buf[i]); //force the conversion. no work for 12-bit lsm yet. PHC 070806\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t//_TIFFfree(buf);\n\t\treturn (1);\n\t}\n\treturn 0;\n}",
    "int loadLsm2Stack(char * filename, unsigned char * & img, long * & sz, int & datatype)\n{\n\tint berror=0;\n\t\n\tTIFF  *tif=0;\n\tint depth, width, height;\n\tshort bits, colorchannels;\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tif (!tif) \n\t{\n\t\tfprintf(stderr, \"Cannot open the specified LSM file in loadLsm2Stack(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tdepth = 1;\n\twhile (TIFFReadDirectory(tif))\n\t\tdepth += 1;\n\tTIFFClose(tif);\n\t\n\tprintf(\"Total # of directories is %d, half of them are thumbnails So real data have %d slices.\\n\", depth, depth/2);\n\tdepth = depth / 2;\t\t/* half the dirs are thumbnails */\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); \n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n\t\n\tif (bits<=8 && bits>0) datatype=1;\n\telse if (bits<=16 && bits>0) datatype=2;\n\telse \n\t{\n\t\tfprintf(stderr, \"LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tlong pixel_per_slice, pixel_per_channel, ntotalpixel;\n\tif (sz) {delete []sz; sz=0;}\n\tsz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */\n\tif (!sz)  \n\t{\n\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\tberror = 1;\n\t\treturn berror;\n\t}\n\telse\n\t{\n\t\tsz[0] = width;\n\t\tsz[1] = height;\n\t\tsz[2] = depth;\n\t\tsz[3] = colorchannels;\n\t\tpixel_per_slice = long(width)*long(height);\n\t\tpixel_per_channel = pixel_per_slice*long(depth);\n\t\tntotalpixel = pixel_per_channel*colorchannels;\n\t}\n\t\n\tif (img) {delete []img; img=0;}\n\telse \n\t{\n\t\timg = new unsigned char [long(ntotalpixel)*long(datatype)];\n\t\tif (!img)\n\t\t{\n\t\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\t\tif (sz) {delete []sz;sz=0;}\n\t\t\tberror = 1;\n\t\t\treturn berror;\n\t\t}\n\t}\n\t\n\t// read every other directory (real data, the in between are thumbnails \n\tlong d;\n\tshort cur_colorchannels, cur_bits;\n\tint cur_width, cur_height;\n\tfor (d=0;d<depth;d++)\n\t{\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); \n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);\n\n\t\tprintf(\"d=%ld, current width=%d, height=%d, cur_colorchannels=%d, cur_bits=%d\\n\", d, cur_width, cur_height, cur_colorchannels, cur_bits); fflush(stdout); //080301\n\n\t\tif (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) \n\t\t{\n\t\t\tfprintf(stderr, \"The %ld Individual image slice has a different size/colorchannel/bits from the first slice!\", d);\n\t\t\t//in this case, do nothing to read the data and leave it empty\n\t\t}\n\t\telse\n\t\t{\n\t\t\tread_lsm_slice(tif, img+long(d)*long(pixel_per_slice)*long(datatype), pixel_per_slice, pixel_per_channel, datatype);\n\t\t}\n\t\t\n\t\tif (d==depth-1)\n\t\t\tbreak; //no need to do read directory anymore once the last one is read\n\t\telse\n\t\t{ \n\t\t\tif (!TIFFReadDirectory(tif)) break;\t  /* skip the one we just read, it's a thumbnail  */\n\t\t\tif (!TIFFReadDirectory(tif)) break;\t  /* get the next slice  */\n\t\t}\n\t}\n\t\n\tTIFFClose(tif);\n\t\n\t//return (stack);\n\treturn berror;\n}",
    "int loadLsmThumbnail2Stack_middle(char * filename, unsigned char * & img, long * & sz, int & datatype)\n{\n\tint berror=0;\n\t\n\tTIFF  *tif=0;\n\tint depth, width, height;\n\tshort bits, colorchannels;\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tif (!tif) \n\t{\n\t\tfprintf(stderr, \"Cannot open the specified LSM file in loadLsm2Stack(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tdepth = 1;\n\twhile (TIFFReadDirectory(tif))\n\t\tdepth += 1;\n\tTIFFClose(tif);\n\t\n\tprintf(\"Total # of directories is %d, half of them are thumbnails So real data have %d slices.\\n\", depth, depth/2);\n\tdepth = depth / 2;\t\t/* half the dirs are thumbnails */\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tTIFFReadDirectory(tif); //bypass a big image and get to the first thumbnail image\n\t\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); \n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n\n\tif (bits<=8 && bits>0) datatype=1;\n\telse if (bits<=16 && bits>0) datatype=2;\n\telse \n\t{\n\t\tfprintf(stderr, \"LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tlong pixel_per_slice, pixel_per_channel, ntotalpixel;\n\tif (sz) {delete []sz; sz=0;}\n\tsz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */\n\tif (!sz)  \n\t{\n\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\tberror = 1;\n\t\treturn berror;\n\t}\n\telse\n\t{\n\t\tsz[0] = width;\n\t\tsz[1] = height;\n\t\tsz[2] = 1;\n\t\tsz[3] = colorchannels;\n\t\tpixel_per_slice = long(width)*long(height);\n\t\tpixel_per_channel = pixel_per_slice*long(sz[2]);\n\t\tntotalpixel = pixel_per_channel*colorchannels;\n\t}\n\t\n\tif (img) {delete []img; img=0;}\n\telse \n\t{\n\t\timg = new unsigned char [long(ntotalpixel)*long(datatype)];\n\t\tif (!img)\n\t\t{\n\t\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\t\tif (sz) {delete []sz;sz=0;}\n\t\t\tberror = 1;\n\t\t\treturn berror;\n\t\t}\n\t}\n\t\n\t// read every other directory (real data, the in between are thumbnails )\n\t\n\tlong d;\n\tshort cur_colorchannels, cur_bits;\n\tint cur_width, cur_height;\n\tfor (d=0;d<=int(depth/2);d++)\n\t{\n\t\tif (d<int(depth/2))\n\t\t{\n\t\t\tTIFFReadDirectory(tif); //bypass a thumbnail \n\t\t\tTIFFReadDirectory(tif); //bypass a big image\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); \n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);\n\n\t\tprintf(\"d=%ld, current width=%d, height=%d\\n\", d, cur_width, cur_height); fflush(stdout);\n\n\t\tif (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) \n\t\t{\n\t\t\tfprintf(stderr, \"The %ld Individual image slice has a different size/colorchannel/bits from the first slice!\", d);\n\t\t\t//in this case, do nothing to read the data and leave it empty\n\t\t}\n\t\telse\n\t\t{\n\t\t    //note that as we onlky read one slice here, the \"img+long(d)*long(pixel_per_slice)*long(datatype)\" equals \"img\"\n\t\t\tread_lsm_slice(tif, img, pixel_per_slice, pixel_per_channel, datatype);\n\t\t}\n\t\t\n\t\tbreak; //after we read one slice, then stop;\n\t}\n\t\n\tTIFFClose(tif);\n\t\n\treturn berror;\n}",
    "int loadLsmSlice(char * filename, unsigned char * & img, long * & sz, int & datatype, long sliceno, bool b_thumbnail)\n{\n\tint berror=0;\n\t\n\tif (sliceno<-2)\n\t{\n\t\tfprintf(stderr, \"The sliceno parameter is invalid. Must not <-2: -2 to read all slices, -1 to read middle only, 0 to N-1 to read the 1 to N-1 slice. If bigger than N-1, then just read the last slice.\\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tTIFF  *tif=0;\n\tint depth, width, height;\n\tshort bits, colorchannels;\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tif (!tif) \n\t{\n\t\tfprintf(stderr, \"Cannot open the specified LSM file in loadLsmSlice(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tdepth = 1;\n\twhile (TIFFReadDirectory(tif))\n\t\tdepth += 1;\n\tTIFFClose(tif);\n\t\n\tprintf(\"%d\\n\", depth/2);\n\t//printf(\"Total # of directories is %d, half of them are thumbnails So real data have %d slices.\\n\", depth, depth/2);\n\tdepth = depth / 2;\t\t/* half the dirs are thumbnails */\n\tif (sliceno>depth-1) sliceno=depth-1; \n\t//printf(\"slice #=%d\\n\", sliceno);\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\n\tif (b_thumbnail)\n\t\tTIFFReadDirectory(tif); //by pass one big image and get to the first thumbnail image\n\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); \n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n\t\n\tif (bits<=8 && bits>0) datatype=1;\n\telse if (bits<=16 && bits>0) datatype=2;\n\telse \n\t{\n\t\tfprintf(stderr, \"LSM file should not support more than 16 bits data. Check the codes in loadLsm2Slice(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tlong pixel_per_slice, pixel_per_channel, ntotalpixel;\n\tif (sz) {delete []sz; sz=0;}\n\tsz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */\n\tif (!sz)  \n\t{\n\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\tberror = 1;\n\t\treturn berror;\n\t}\n\telse\n\t{\n\t\tsz[0] = width;\n\t\tsz[1] = height;\n\t\tsz[2] = (sliceno==-2) ? depth : 1;\n\t\tsz[3] = colorchannels;\n\t\tpixel_per_slice = long(sz[1])*long(sz[0]);\n\t\tpixel_per_channel = pixel_per_slice*long(sz[2]);\n\t\tntotalpixel = pixel_per_channel*colorchannels;\n\t}\n\t\n\tif (img) {delete []img; img=0;}\n\telse \n\t{\n\t\timg = new unsigned char [long(ntotalpixel)*long(datatype)];\n\t\tif (!img)\n\t\t{\n\t\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\t\tif (sz) {delete []sz;sz=0;}\n\t\t\tberror = 1;\n\t\t\treturn berror;\n\t\t}\n\t}\n\t\n\t// read every other directory (real data, the in between are thumbnails \n    bool b_readnow=false;\n\tlong d;\n\tshort cur_colorchannels, cur_bits;\n\tint cur_width, cur_height;\n\tfor (d=0;d<depth;d++)\n\t{\n\t\tif (sliceno>-2)\n\t\t{\n\t\t\tif (sliceno==-1) //middle slice only\n\t\t\t{\n\t\t\t\tb_readnow=(d==int(depth/2))?true:false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb_readnow=(d==sliceno)?true:false;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb_readnow=true;\n\t\t}\n\n\t\tif (b_readnow)\n\t\t{\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);\n\t\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); \n\t\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);\n\n\t\t\t//printf(\"d=%d, current width=%d, height=%d, cur_colorchannels=%d, cur_bits=%d\\n\", d, cur_width, cur_height, cur_colorchannels, cur_bits); fflush(stdout); //080301\n\n\t\t\tif (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) \n\t\t\t{\n\t\t\t\tfprintf(stderr, \"The %ld Individual image slice has a different size/colorchannel/bits from the first slice!\", d);\n\t\t\t\t//in this case, do nothing to read the data and leave it empty\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (sliceno==-2)\n\t\t\t\t{\n\t\t\t\t\tread_lsm_slice(tif, img+long(d)*long(pixel_per_slice)*long(datatype), pixel_per_slice, pixel_per_channel, datatype);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tread_lsm_slice(tif, img, pixel_per_slice, pixel_per_channel, datatype);\n\t\t\t\t\tbreak; //because only 1 read is needed in this case\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (d==depth-1)\n\t\t\tbreak; //no need to do read directory anymore once the last one is read\n\t\telse\n\t\t{ \n\t\t\tif (!TIFFReadDirectory(tif)) break;\t  /* one directory  */\n\t\t\tif (!TIFFReadDirectory(tif)) break;\t  /* another directory */\n\t\t}\n\t}\n\t\n\tTIFFClose(tif);\n\t\n\treturn berror;\n}",
    "int loadTifSlice(char * filename, unsigned char * & img, long * & sz, int & datatype, long sliceno, bool b_thumbnail)\n{\n\tint berror=0;\n\t\n\tif (sliceno<-2)\n\t{\n\t\tfprintf(stderr, \"The sliceno parameter is invalid. Must not <-2: -2 to read all slices, -1 to read middle only, 0 to N-1 to read the 1 to N-1 slice. If bigger than N-1, then just read the last slice.\\n\");\n\t\treturn 1; \n\t}\n\t\n\tTIFF  *tif=0;\n\tint depth, width, height;\n\tshort bits, colorchannels;\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tif (!tif) \n\t{\n\t\tfprintf(stderr, \"Cannot open the specified TIFF file in loadTifSlice(). \\n\");\n\t\treturn 1; \n\t}\n\t\n\tdepth = 1;\n\twhile (TIFFReadDirectory(tif))\n\t\tdepth += 1;\n\tTIFFClose(tif);\n\t\n\tprintf(\"%d\\n\", depth); //note that this sentence will be output an important info to use the pop_thumbnail php program\n\t//printf(\"Total # of directories is %d, half of them are thumbnails So real data have %d slices.\\n\", depth, depth/2);\n\t//depth = depth / 2;\t\t/* half the dirs are thumbnails */\n\tif (sliceno>depth-1) sliceno=depth-1; \n\t//printf(\"slice #=%d\\n\", sliceno);\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\n\t//if (b_thumbnail) TIFFReadDirectory(tif); //by pass one big image and get to the first thumbnail image\n\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); \n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n\t\n\tif (bits<=8 && bits>0) datatype=1;\n\telse if (bits<=16 && bits>0) datatype=2;\n\telse \n\t{\n\t\tfprintf(stderr, \"TIF file should not support more than 16 bits data. Check the codes in loadTifSlice(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tlong pixel_per_slice, pixel_per_channel, ntotalpixel;\n\tif (sz) {delete []sz; sz=0;}\n\tsz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */\n\tif (!sz)  \n\t{\n\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\tberror = 1;\n\t\treturn berror;\n\t}\n\telse\n\t{\n\t\tsz[0] = width;\n\t\tsz[1] = height;\n\t\tsz[2] = (sliceno==-2) ? depth : 1;\n\t\tsz[3] = colorchannels;\n\t\tpixel_per_slice = long(sz[1])*long(sz[0]);\n\t\tpixel_per_channel = pixel_per_slice*long(sz[2]);\n\t\tntotalpixel = pixel_per_channel*colorchannels;\n\t}\n\t\n\tif (img) {delete []img; img=0;}\n\telse \n\t{\n\t\timg = new unsigned char [long(ntotalpixel)*long(datatype)];\n\t\tif (!img)\n\t\t{\n\t\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\t\tif (sz) {delete []sz;sz=0;}\n\t\t\tberror = 1;\n\t\t\treturn berror;\n\t\t}\n\t}\n\t\n\t// read every other directory (real data, the in between are thumbnails \n    bool b_readnow=false;\n\tlong d;\n\tshort cur_colorchannels, cur_bits;\n\tint cur_width, cur_height;\n\tfor (d=0;d<depth;d++)\n\t{\n\t\tif (sliceno>-2)\n\t\t{\n\t\t\tif (sliceno==-1) //middle slice only\n\t\t\t{\n\t\t\t\tb_readnow=(d==int(depth/2))?true:false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb_readnow=(d==sliceno)?true:false;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb_readnow=true;\n\t\t}\n\n\t\tif (b_readnow)\n\t\t{\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);\n\t\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); \n\t\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);\n\n\t\t\t//printf(\"d=%d, current width=%d, height=%d\\n\", d, cur_width, cur_height); fflush(stdout);\n\n\t\t\tif (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) \n\t\t\t{\n\t\t\t\tfprintf(stderr, \"The %ld Individual image slice has a different size/colorchannel/bits from the first slice!\", d);\n\t\t\t\t//in this case, do nothing to read the data and leave it empty\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (sliceno==-2)\n\t\t\t\t{\n\t\t\t\t\tread_tif_slice(tif, img+long(d)*long(pixel_per_slice)*long(datatype)*sz[3], width, height);\n\t\t\t\t\t//printf(\"Read No. %d slice.\\n\", d);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tread_tif_slice(tif, img, width, height);\n\t\t\t\t\t//printf(\"width=[%d] height=[%d] color=[%d] bits-per-sample=[%d].\\n\", width, height, cur_colorchannels, cur_bits);\n\t\t\t\t\t//printf(\"Read No. %d slice.\\n\", d);\n\t\t\t\t\t//read_directory(tif,Select_Plane(stack,d),\"Read_Stack\");\n\t\t\t\t\tbreak; //because only 1 read is needed in this case\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (d==depth-1)\n\t\t\tbreak; //no need to do read directory anymore once the last one is read\n\t\telse\n\t\t{ \n\t\t\tif (!TIFFReadDirectory(tif)) break;\t  /* one directory  */\n\t\t\t//if (!TIFFReadDirectory(tif)) break;\t  /* another directory */\n\t\t}\n\t}\n\t\n\tTIFFClose(tif);\n\t\n\t//debugging code: verification succeeds in Matlab reading code: \n\t//t=fopen('/Users/pengh/Desktop/temp/test1.dat');a=fread(t, 512*512*3, 'uint8');a=reshape(a,[3 512 512]);a=permute(a, [2 3 1]);fclose(t); imshow(a(:,:,1:3)/255)\n\t\t\t\n\t//FILE * tmp_fp=fopen(\"/Users/pengh/temp/test1.dat\", \"w\");\n\t//fwrite(img, 3, width*height,tmp_fp);\n\t//fclose(tmp_fp);\n\t\n\t\n\t//produce thumbnail if required\n\tif (b_thumbnail)\n\t{\n\t\tlong thumbsz0=128, thumbsz1=128;\n\t\tif (sz[0]>thumbsz0 || sz[1]>thumbsz1)\n\t\t{\t\n\t\t\tunsigned char * img1 = new unsigned char [long(thumbsz0)*thumbsz1*sz[2]*sz[3]*long(datatype)];\n\t\t\tunsigned char ****img4d1 = 0;\n\t\t\tnew4dpointer(img4d1, sz[3], thumbsz0, thumbsz1, sz[2], img1);\n\t\n\t\t\tunsigned char ****img4d = 0;\n\t\t\tnew4dpointer(img4d, sz[3], sz[0], sz[1], sz[2], img);\n\t\t\t\n\t\t\tdouble factor_jj=sz[1]/thumbsz1, factor_ii=sz[0]/thumbsz0;\n\t\t\tfor (long kk=0;kk<sz[2];kk++)\n\t\t\t{\n\t\t\t\tfor (long jj=0; jj<thumbsz1; jj++)\n\t\t\t\t{\n\t\t\t\t\tfor (long ii=0;ii<thumbsz0; ii++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (long cc=0;cc<sz[3];cc++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\timg4d1[kk][jj][ii][cc] = img4d[kk][long(floor(jj*factor_jj))][long(floor(ii*factor_ii))][cc];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdelete4dpointer(img4d, sz[3], sz[0], sz[1], sz[2]);\n\t\t\tdelete4dpointer(img4d1, sz[3], thumbsz0, thumbsz1, sz[2]);\n\n\t\t\tdelete []img;\n\t\t\timg = img1;\n\t\t\tsz[0] = thumbsz0;\n\t\t\tsz[1] = thumbsz1;\n\t\t\t//sz[2] and sz[3] do not need change\n\t\t}\n\t}\n\n\t//FILE * tmp_fp=fopen(\"/Users/pengh/temp/test1.dat\", \"w\");\n\t//fwrite(img, 3, width*height,tmp_fp);\n\t//fclose(tmp_fp);\n\t\n\t//permute the data to make sure it will be output correctly\n\tunsigned char ****img4d = 0;\n\tnew4dpointer(img4d, sz[3], sz[0], sz[1], sz[2], img); //must realize this order!\n\t\n\tunsigned char * img1 = new unsigned char [sz[0]*sz[1]*sz[2]*sz[3]];\n\tunsigned char ****img4d1 = 0;\n\tnew4dpointer(img4d1, sz[0], sz[1], sz[2], sz[3], img1);\n\t\n\tfor (long tcc=0;tcc<sz[3];tcc++)\n\t{\n\t\tfor (long tkk=0;tkk<sz[2];tkk++)\n\t\t{\n\t\t\tfor (long tjj=0;tjj<sz[1];tjj++)\n\t\t\t{\n\t\t\t\tfor (long tii=0;tii<sz[0];tii++)\n\t\t\t\t{\n\t\t\t\t\timg4d1[tcc][tkk][tjj][tii] = img4d[tkk][tjj][tii][tcc];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdelete4dpointer(img4d1, sz[0], sz[1], sz[2], sz[3]);\n\tdelete4dpointer(img4d, sz[3], sz[0], sz[1], sz[2]);\n\tif (img) {delete []img; img=0;}\n\timg = img1;\n\t\n\treturn berror;\n}",
    "int read_tif_slice(TIFF *tif, unsigned char * pointer_first_page, long width, long height) \n//note that this is not a general tif slice reader, - but should work for date generated using Gene's code\n{\n\t//\tif (TIFFIsTiled(in))\n\t//\t\treturn (read_tif_slice_tile(in, pointer_first_page, pagepixelnumber, channelpixelnumber, datatype));\n\t//\telse\n\t//\t\treturn (read_tif_slice_strip(in, pointer_first_page, pagepixelnumber, channelpixelnumber, datatype));\n\t\n\t//\n\t\n\t//first determine the image type\n\t\n\tenum PImagePixelType {PTIF_GREY, PTIF_GREY16, PTIF_COLOR};\n\tPImagePixelType pixelType;\n\t\n\t\n\tshort bits, channels, photo;\n\t\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels);\n\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photo);\n\tif (photo <= 1)\n    {\n\t\tif (channels > 1)\n\t\t\tfprintf(stderr, \"Black and white tiff has more than 1 channel!\");\n\t\tif (bits == 16)\n\t\t\tpixelType = PTIF_GREY16;\n\t\telse\n\t\t\tpixelType = PTIF_GREY;\n    }\n\telse\n\t\tpixelType = PTIF_COLOR;\n\t\n\t// then read data\n\t\n\tuint32 *raster = new uint32 [width*height];\n\tif (!raster)\n\t{\n\t\tfprintf(stderr, \"Fail to allocate memory in read_tif_slice();\\n\");\n\t\treturn 1;\n\t}\n\t\n\tunsigned char  *row;\n\t\n\trow = pointer_first_page;\n\t\n\tif (pixelType != PTIF_GREY16)\n    {\n\t\tint i, j;\n\t\tuint32 *in;\n\t\tuint8  *out;\n\t\t\n\t\tif (TIFFReadRGBAImage(tif,width,height,raster,0) == 0)\n\t\t{\n\t\t\tfprintf(stderr, \"read of tif failed\");\n\t\t\tif (raster) {delete []raster; raster=0;}\n\t\t\treturn 1;\n\t\t}\n\t\n\t\t//debugging code: verification succeeds in Matlab reading code: \n\t\t//t=fopen('/Users/pengh/Desktop/temp/test1.dat');a=fread(t, 512*512*4, 'uint8');a=reshape(a,[4 512 512]);a=permute(a, [2 3 1]);fclose(t); imshow(a(:,:,1:3)/255)\n\t\t\t\t\n\t\t//FILE * tmp_fp=fopen(\"/Users/pengh/temp/test1.dat\", \"w\");\n\t\t//fwrite(raster, 4, width*height,tmp_fp);\n\t\t//fclose(tmp_fp);\n\t\t\n\t\tin = raster;\n\t\tif (pixelType == PTIF_GREY)\n        {\n\t\t\tfor (j = height-1; j >= 0; j--)\n\t\t\t{\n\t\t\t\tout = row;\n\t\t\t\tfor (i = 0; i < width; i++)\n\t\t\t\t{\n\t\t\t\t\tuint32 pixel = *in++;\n\t\t\t\t\t*out++ = TIFFGetR(pixel);\n\t\t\t\t}\n\t\t\t\trow += width;\n\t\t\t}\n        }\n\t\telse\n        {\n\t\t\tfor (j = height-1; j >= 0; j--)\n\t\t\t{\n\t\t\t\tout = row;\n\t\t\t\tfor (i = 0; i < width; i++)\n\t\t\t\t{ \n\t\t\t\t\tuint32 pixel = *in++;\n\t\t\t\t\t*out++ = TIFFGetR(pixel);\n\t\t\t\t\t*out++ = TIFFGetG(pixel);\n\t\t\t\t\t*out++ = TIFFGetB(pixel);\n\t\t\t\t}\n\t\t\t\trow += width*3;\n\t\t\t}\n        }\n    }\n\t\n\telse\n\t\t\n    { \n\t\tint tile_width, tile_height;\n\t\t\n\t\tif (TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width))    // File is tiled  \n        { int x, y;\n\t\t\tint i, j;\n\t\t\tint m, n;\n\t\t\tuint16 *buffer = (uint16 *) raster;\n\t\t\tuint16 *out, *in; //, *rous;\n\t\t\t\n\t\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height);\n\t\t\t\n\t\t\tfor (y = 0; y < height; y += tile_height)\n            { if (y + tile_height > height)\n                n = height - y;\n\t\t\t\telse\n\t\t\t\t\tn = tile_height;\n\t\t\t\tfor (x = 0; x < width; x += tile_width)\n                { TIFFReadTile(tif, buffer, x, y, 0, 0);\n\t\t\t\t\tif (x + tile_width > width)\n\t\t\t\t\t\tm = width - x;\n\t\t\t\t\telse\n\t\t\t\t\t\tm = tile_width;\n\t\t\t\t\tfor (j = 0; j < n; j++)\n                    { out = (uint16 *) (row + 2*(j*width + x));\n\t\t\t\t\t\tin  = buffer + j*tile_width;\n\t\t\t\t\t\tfor (i = 0; i < m; i++)\n\t\t\t\t\t\t\t*out++ = *in++; \n                    }\n                }\n\t\t\t\trow += n*width*2;\n            }\n        }\n\t\t\n\t\telse    // File is striped\n\t\t\t\n        { int     y;\n\t\t\t\n\t\t\tfor (y = 0; y < height; y++)\n            { TIFFReadScanline(tif, row, y, 0);\n\t\t\t\trow += width*2;\n            }\n        }\n    }\n\t\n\tif (raster) {delete []raster; raster=0;}\n\t//\n\treturn 0;\n\t//\n\t\n}",
    "int read_tif_slice_strip(TIFF *in, unsigned char * pointer_first_page, long pagepixelnumber, long channelpixelnumber, int datatype)\n{\n\ttsize_t bufsize  = TIFFStripSize(in);\n\tif (pagepixelnumber!=bufsize)\n\t{\n\t\tfprintf(stderr, \"The current strip has a different size [%ld] from the expected size [%ld] in read_tif_slice_strip(). No data is read.\\n\", long(bufsize), pagepixelnumber);\n\t\treturn 1;\n\t}\n\t\n\tif (pointer_first_page) {\n\t\ttstrip_t s, ns = TIFFNumberOfStrips(in);\n\t\tuint32 *bytecounts;\n\t\tuint32 *stripoffsets;\n\n\t\tTIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts);\n\t\t\n\t\tTIFFGetField(in, TIFFTAG_STRIPOFFSETS, &stripoffsets);\n\n\t\tfor (s = 0; s < ns; s++) \n\t\t{\n\t\t\tif (TIFFReadEncodedStrip(in, s, pointer_first_page + long(s)*channelpixelnumber, pagepixelnumber)<0) \n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\treturn (1);\n\t}\n\treturn 0;\n}",
    "int read_tif_slice_tile(TIFF *in, unsigned char * pointer_first_page, long pagepixelnumber, long channelpixelnumber, int datatype)\n{\n\ttsize_t bufsize = TIFFTileSize(in);\n\tif (pagepixelnumber!=bufsize)\n\t{\n\t\tfprintf(stderr, \"The current tile has a different size from the expected size in read_tif_slice_tile(). No data is read.\\n\");\n\t\treturn 1;\n\t}\n\t\n\tif (pointer_first_page) {\n\t\tttile_t t, nt = TIFFNumberOfTiles(in);\n\t\tuint32 *bytecounts;\n\n\t\tTIFFGetField(in, TIFFTAG_TILEBYTECOUNTS, &bytecounts);\n\t\tfor (t = 0; t < nt; t++) \n\t\t{\n\t\t\tif (TIFFReadEncodedTile(in, t, pointer_first_page + long(t)*channelpixelnumber, bytecounts[t]) < 0) \n\t\t\t{\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\treturn (1);\n\t}\n\treturn 0;\n}",
    "static int determine_kind(TIFF *tif)   //  Determine nature of current tif image\n{ short bits, channels, photo;\n\n  TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n  TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels);\n  TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photo);\n  if (photo <= 1)\n    { if (channels > 1)\n        error(\"Black and white tiff has more than 1 channel!\",NULL);\n      if (bits == 16)\n        return (GREY16);\n      else\n        return (GREY);\n    }\n  else\n    return (COLOR);\n}",
    "static void read_directory(TIFF *tif, Image *image, char *routine)   //  Used by all readers\n{ uint32 *raster;\n  uint8  *row;\n  int     width, height;\n\n  width  = image->width;\n  height = image->height;\n  raster = get_raster(width*height,routine);\n\n  row = image->array;\n\n  if (image->kind != GREY16)\n\n    { int i, j;\n      uint32 *in;\n      uint8  *out;\n\n      if (TIFFReadRGBAImage(tif,width,height,raster,0) == 0)\n        error(\"read of tif failed\", NULL);\n\n      in = raster;\n      if (image->kind == GREY)\n        { for (j = height-1; j >= 0; j--)\n            { out = row;\n              for (i = 0; i < width; i++)\n                { uint32 pixel = *in++;\n                  *out++ = TIFFGetR(pixel);\n                }\n              row += width;\n            }\n        }\n      else\n        { for (j = height-1; j >= 0; j--)\n            { out = row;\n              for (i = 0; i < width; i++)\n                { uint32 pixel = *in++;\n                  *out++ = TIFFGetR(pixel);\n                  *out++ = TIFFGetG(pixel);\n                  *out++ = TIFFGetB(pixel);\n                }\n              row += width*3;\n            }\n        }\n    }\n\n  else\n\n    { int tile_width, tile_height;\n\n      if (TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width))    // File is tiled  \n        { int x, y;\n          int i, j;\n          int m, n;\n          uint16 *buffer = (uint16 *) raster;\n          uint16 *out, *in, *rous;\n    \n          TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height);\n\n          for (y = 0; y < height; y += tile_height)\n            { if (y + tile_height > height)\n                n = height - y;\n              else\n                n = tile_height;\n              for (x = 0; x < width; x += tile_width)\n                { TIFFReadTile(tif, buffer, x, y, 0, 0);\n                  if (x + tile_width > width)\n                    m = width - x;\n                  else\n                    m = tile_width;\n                  for (j = 0; j < n; j++)\n                    { out = (uint16 *) (row + 2*(j*width + x));\n                      in  = buffer + j*tile_width;\n                      for (i = 0; i < m; i++)\n                        *out++ = *in++; \n                    }\n                }\n              row += n*width*2;\n            }\n        }\n\n      else    // File is striped\n   \n        { int     y;\n\n          for (y = 0; y < height; y++)\n            { TIFFReadScanline(tif, row, y, 0);\n              row += width*2;\n            }\n        }\n    }\n}",
    "Image *Read_Tiff(TIFF *tif, int *lastone)\n{ Image *image;\n\n  int   width, height, kind;\n\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\n  kind = determine_kind(tif);\n\n  image = new_image(height*width*kind,\"Read_Tiff\");\n\n  image->width  = width;\n  image->height = height;\n  image->kind   = kind;\n\n  read_directory(tif,image,\"Read_Tiff\");\n\n  *lastone = (! TIFFReadDirectory(tif));\n  return (image);\n}",
    "Stack *Read_Stack(char *file_name)\n{ Stack *stack;\n\n  TIFF  *tif;\n  int    depth, width, height, kind;\n\n  tif = Open_Tiff(file_name,\"r\");\n  depth = 1;\n  while (TIFFReadDirectory(tif))\n    depth += 1;\n  TIFFClose(tif);\n\n  tif = Open_Tiff(file_name,\"r\");\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\n  kind  = determine_kind(tif);\n  stack = new_stack(depth*height*width*kind,\"Read_Stack\");\n\n  stack->width  = width;\n  stack->height = height;\n  stack->depth  = depth;\n  stack->kind   = kind;\n\n  { int d;\n\n    d = 0;\n    while (1)\n      { read_directory(tif,Select_Plane(stack,d),\"Read_Stack\");\n\n        d += 1;\n        if (!TIFFReadDirectory(tif)) break;\n\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        if (width != stack->width || height != stack->height)\n          error(\"Images of stack are not of the same dimensions!\",NULL);\n\n        kind = determine_kind(tif);\n        if (kind != stack->kind)\n          error(\"Images of stack are not of the same type (GREY, GREY16, or COLOR)!\",NULL);\n      }\n  }\n\n  TIFFClose(tif);\n\n  return (stack);\n}",
    "Stack *Read_LSM_Stack(char *file_name)\n{\n  Stack *stack;\n\n  TIFF  *tif;\n  int    depth, width, height, kind;\n\n  tif = Open_Tiff(file_name,\"r\");\n  if (!tif) return 0; //070805, bu Hanchuan Peng\n\t\n  depth = 1;\n  while (TIFFReadDirectory(tif))\n    depth += 1;\n  TIFFClose(tif);\n  depth = depth / 2;\t\t/* half the dirs are thumbnails */\n\n  tif = Open_Tiff(file_name,\"r\");\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\n  kind  = determine_kind(tif);\n  stack = new_stack(depth*height*width*kind,\"Read_Stack\");\n\n  stack->width  = width;\n  stack->height = height;\n  stack->depth  = depth;\n  stack->kind   = kind;\n\n  printf(\"test1 done\\n\");\n\n  int d;\n\n  d = 0;\n  /* read every other directory (real data, the in between are thumbnails */\n  while (1)\n  {\n\t  read_directory(tif,Select_Plane(stack,d),\"Read_Stack\");\n\t  \n\t  d += 1;\n\t  if (!TIFFReadDirectory(tif)) break;\n\t  /* skip the one we just read, it's a thumbnail  */\n\n\t  if (!TIFFReadDirectory(tif)) break;\n\t  \n\t  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\t  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\t  if (width != stack->width || height != stack->height)\n          error(\"Images of stack are not of the same dimensions!\",NULL);\n\t  \n\t  kind = determine_kind(tif);\n\t  if (kind != stack->kind)\n          error(\"Images of stack are not of the same type (GREY, GREY16, or COLOR)!\",NULL);\n  }\n  \n  TIFFClose(tif);\n\n  return (stack);\n}",
    "Stack *Read_Stack_Planes(char *prefix, int num_width, int first_num)\n{ Stack *stack;\n\n  char  sname[1000];\n  int   width, height, depth, kind;\n  TIFF *tif;\n\n  depth = 0;\n  while (1)\n    { FILE *fd;\n\n      sprintf(sname,\"%s%0*d.tif\",prefix,num_width,first_num+depth);\n      if ((fd = fopen(sname,\"r\")) == NULL)\n        break;\n      fclose(fd);\n\n      depth += 1;\n    }\n\n  sprintf(sname,\"%s%0*d.tif\",prefix,num_width,first_num);\n  tif = Open_Tiff(sname,\"r\");\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\n  kind  = determine_kind(tif);\n  stack = new_stack(depth*height*width*kind,\"Read_Stack_Planes\");\n\n  stack->width  = width;\n  stack->height = height;\n  stack->depth  = depth;\n  stack->kind   = kind;\n\n  { int d;\n\n    d = 0;\n    while (1)\n      { read_directory(tif,Select_Plane(stack,d),\"Read_Stack_Planes\");\n        TIFFClose(tif);\n\n        d += 1;\n        if (d >= depth) break;\n\n        sprintf(sname,\"%s%0*d.tif\",prefix,num_width,first_num+d);\n        tif = Open_Tiff(sname,\"r\");\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        if (width != stack->width || height != stack->height)\n          error(\"Images of stack are not of the same dimensions!\",NULL);\n\n        kind = determine_kind(tif);\n        if (kind != stack->kind)\n          error(\"Images of stack are not of the same type (GREY, GREY16, or COLOR)!\",NULL);\n      }\n  }\n\n  return (stack);\n}",
    "bool QFImageReaderLIBTIFF::open(QString filename) {\n    close();\n\n\n    fileinfo.init(filename);\n    //TIFFSetWarningHandler(0);\n    //qDebug()<<\"QFImageReaderLIBTIFF::open(\"<<filename<<\")     tif=\"<<tif;\n    tif = TIFFOpen(filename.toLatin1().data(),\"r\");\n    if (tif) {\n        uint32 nx,ny;\n        uint16 nc;\n        uint16 photo;\n        TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\n        TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\n        TIFFGetField(tif,TIFFTAG_PHOTOMETRIC,&photo);\n        bool hasSPP=(bool)TIFFGetField(tif,TIFFTAG_SAMPLESPERPIXEL,&nc);\n\n        char* val=NULL;\n        TIFFGetField(tif,TIFFTAG_IMAGEDESCRIPTION,&val);\n        if (val) {\n            imageDescription=val;\n        }\n        width=nx;\n        height=ny;\n        channels = nc;\n        if (!hasSPP) {\n            if (photo==3) channels=3;\n            else channels=1;\n        }\n        this->filename=filename;\n        char* desc=NULL;\n        if (!TIFFGetField(tif, TIFFTAG_DOCUMENTNAME, &desc)) {\n            TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &desc);\n        }\n        if (desc) fileinfo.comment=desc;\n\n        qfimdtGetQuickFitMetaData(fileinfo.properties, filename);\n\n        bool metaOK=false;\n        int cnt=0;\n        while (!metaOK && cnt<5) {\n            char* vall=NULL;\n            TIFFGetField(tif,TIFFTAG_IMAGEDESCRIPTION,&vall);\n            QByteArray imgD;\n            if (vall) {\n                imgD=vall;\n            }\n\n            if (imgD.size()>0) {\n                metaOK=qfimdtGetOMEMetaData(fileinfo.properties, imgD);\n                if (!metaOK) {\n                    metaOK=qfimdtGetImageJMetaData(fileinfo.properties, imgD);\n                }\n                if (!metaOK) {\n                    metaOK=qfimdtGetTinyTIFFMetaData(fileinfo.properties, imgD);\n                }\n                imageDescription+=QString(\"\\n\\n%1\").arg(QString::fromLatin1(imgD.data()));\n            }\n            metaOK=metaOK||(!nextFrame());\n            cnt++;\n        }\n        reset();\n\n\n        //TIFFSetWarningHandler(NULL);\n        //qDebug()<<\"  QFImageReaderLIBTIFF::open(\"<<filename<<\")   tif=\"<<tif<<\"  result=false\";\n        logTIFFMessage(\"QFImageReaderLIBTIFF\", \"opened file %s\\n\", filename.toLocal8Bit().data());\n        return true;\n    } else {\n        width=0;\n        channels=1;\n        height=0;\n        setLastError(QObject::tr(\"libtiff: error opening file '%1'\").arg(filename));\n        this->filename=\"\";\n        //qDebug()<<\"  QFImageReaderLIBTIFF::open(\"<<filename<<\")   tif=\"<<tif<<\"  result=false\";\n        return false;\n    }\n}",
    "bool QFImageReaderLIBTIFF::intReadFrameUINT16(uint16_t* data, int channel) {\n    if (!tif) return false;\n    bool ok=true;\n    uint16 samplesperpixel, bitspersample;\n    uint16 sampleformat = SAMPLEFORMAT_UINT;\n    uint32 nx,ny;\n    TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\n    TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\n    bool hasSPP=(bool)TIFFGetField(tif,TIFFTAG_SAMPLESPERPIXEL,&samplesperpixel);\n    TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleformat);\n    TIFFGetFieldDefaulted(tif,TIFFTAG_BITSPERSAMPLE,&bitspersample);\n    //if (samplesperpixel>1 && samplesperpixel<500) {\n    //    // if there are more than 500 samples, we assume this is an error in the file and read only one sample!\n    //    setLastError(QObject::tr(\"can not load frames with more than one sample/pixel (RGB, RGBA, ...)   (from file '%1' with %2 samples/pixel)\").arg(filename).arg(samplesperpixel));\n    //    return false;\n    if (samplesperpixel>500) {\n        // if there are more than 500 samples, we assume this is an error in the file and read only one sample!\n        setLastError(QObject::tr(\"can not load files with more than 500 samples/pixel   (from file '%1' with %2 samples/pixel)\").arg(filename).arg(samplesperpixel));\n        return false;\n    } else {\n        uint16  planarconfig;\n        TIFFGetField(tif,TIFFTAG_PLANARCONFIG,&planarconfig);\n\n        // we only read image with one sample per pixel, so we do nothave to care for TIFFTAG_PLANARCONFIG\n        if (!TIFFReadRGB(tif, data, nx, ny, channel)) {\n            if (TIFFIsTiled(tif)) { // load a tiled frame\n                uint32 tw, th;\n                TIFFGetField(tif,TIFFTAG_TILEWIDTH,&tw);\n                TIFFGetField(tif,TIFFTAG_TILELENGTH,&th);\n                switch (bitspersample) {\n                    case 8 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadTiled<uint8_t,  uint16_t>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 8-bit tiled image in format different from UINT   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    case 16 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadTiled<uint16_t,  uint16_t>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 16-bit tiled image in format different from UINT   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    default: {\n                            setLastError(QObject::tr(\"can not load tiled frame sample format in TIFF file   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                }\n            } else { // load a non-tiled frame\n                switch (bitspersample) {\n                    case 8 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadNontiled<uint8_t,  uint16_t>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 8-bit image in format different from UINT   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    case 16 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadNontiled<uint16_t,  uint16_t>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 16-bit image in format different from UINT   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    default: {\n                            setLastError(QObject::tr(\"can not load frame sample format in TIFF file   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                }\n            }\n        }\n    }\n    if (!ok) {\n        setLastError(QObject::tr(\"unknown error when reading frame from TIFF file   (from file '%1')\").arg(filename));\n    }\n    return ok;\n}",
    "bool QFImageReaderLIBTIFF::intReadFrameDouble(double *data, int channel) {\n    if (!tif) return false;\n\n    bool ok=true;\n\n    uint16 samplesperpixel, bitspersample;\n    uint16 sampleformat = SAMPLEFORMAT_UINT;\n    uint32 nx,ny;\n    TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\n    TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\n   bool hasSPP=(bool)TIFFGetField(tif,TIFFTAG_SAMPLESPERPIXEL,&samplesperpixel);\n    TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleformat);\n    TIFFGetFieldDefaulted(tif,TIFFTAG_BITSPERSAMPLE,&bitspersample);\n    //if (samplesperpixel>1 && samplesperpixel<500) {\n    //    // if there are more than 500 samples, we assume this is an error in the file and read only one sample!\n    //    setLastError(QObject::tr(\"can not load frames with more than one sample/pixel (RGB, RGBA, ...)   (from file '%1' with %2 samples/pixel)\").arg(filename).arg(samplesperpixel));\n    //    return false;\n    if (samplesperpixel>500) {\n        // if there are more than 500 samples, we assume this is an error in the file and read only one sample!\n        setLastError(QObject::tr(\"can not load files with more than 500 samples/pixel   (from file '%1' with %2 samples/pixel)\").arg(filename).arg(samplesperpixel));\n        return false;\n    } else {\n        uint16  planarconfig;\n        TIFFGetField(tif,TIFFTAG_PLANARCONFIG,&planarconfig);\n        // we only read image with one sample per pixel, so we do nothave to care for TIFFTAG_PLANARCONFIG\n        if (!TIFFReadRGB(tif, data, nx, ny, channel)) {\n            if (TIFFIsTiled(tif)) { // load a tiled frame\n                uint32 tw, th;\n                TIFFGetField(tif,TIFFTAG_TILEWIDTH,&tw);\n                TIFFGetField(tif,TIFFTAG_TILELENGTH,&th);\n                switch (bitspersample) {\n                    case 8 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadTiled<uint8_t,  double>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_INT) ok=TIFFLoadTiled<int8_t,  double>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 8-bit tiled image in format different from INT or UINT   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    case 16 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadTiled<uint16_t,  double>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_INT) ok=TIFFLoadTiled<int16_t,  double>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 16-bit tiled image in format different from INT or UINT   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    case 32 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadTiled<uint32_t,  double>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_INT) ok=TIFFLoadTiled<int32_t,  double>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_IEEEFP) ok=TIFFLoadTiled<float,  double>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 32-bit tiled image in format different from INT, UINT, IEEE   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    case 64 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadTiled<uint64_t,  double>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_INT) ok=TIFFLoadTiled<int64_t,  double>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_IEEEFP) ok=TIFFLoadTiled<double,  double>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 64-bit tiled image in format different from INT, UINT, IEEE   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    default: {\n                            setLastError(QObject::tr(\"can not load tiled frame sample format in TIFF file   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                }\n            } else { // load a non-tiled frame\n                switch (bitspersample) {\n                    case 8 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadNontiled<uint8_t,  double>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_INT) ok=TIFFLoadNontiled<int8_t,  double>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 8-bit image in format different from INT or UINT   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    case 16 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadNontiled<uint16_t,  double>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_INT) ok=TIFFLoadNontiled<int16_t,  double>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 16-bit image in format different from INT or UINT   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    case 32 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadNontiled<uint32_t,  double>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_INT) ok=TIFFLoadNontiled<int32_t,  double>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_IEEEFP) ok=TIFFLoadNontiled<float,  double>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 32-bit image in format different from INT, UINT, IEEE   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    case 64 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadNontiled<uint64_t,  double>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_INT) ok=TIFFLoadNontiled<int64_t,  double>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_IEEEFP) ok=TIFFLoadNontiled<double,  double>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 64-bit image in format different from INT, UINT, IEEE   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    default: {\n                            setLastError(QObject::tr(\"can not load frame sample format in TIFF file   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                }\n            }\n        }\n    }\n    if (!ok) {\n        setLastError(QObject::tr(\"unknown error when reading frame from TIFF file   (from file '%1')\").arg(filename));\n    }\n    return ok;\n}",
    "bool QFImageReaderLIBTIFF::intReadFrameFloat(float* data, int channel) {\n    if (!tif) return false;\n\n    bool ok=true;\n\n    uint16 samplesperpixel, bitspersample;\n    uint16 sampleformat = SAMPLEFORMAT_UINT;\n    uint32 nx,ny;\n    TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\n    TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\n    if (nx!=width || ny!=height) {\n        setLastError(QObject::tr(\"ERROR reading TIFF: frame has a size, unequal to the previous frames (file '%1')\").arg(filename));\n        return false;\n    }\n    TIFFGetField(tif,TIFFTAG_SAMPLESPERPIXEL,&samplesperpixel);\n    TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleformat);\n    TIFFGetFieldDefaulted(tif,TIFFTAG_BITSPERSAMPLE,&bitspersample);\n    //if (samplesperpixel>1 && samplesperpixel<500) {\n    //    // if there are more than 500 samples, we assume this is an error in the file and read only one sample!\n    //    setLastError(QObject::tr(\"can not load frames with more than one sample/pixel (RGB, RGBA, ...)   (from file '%1' with %2 samples/pixel)\").arg(filename).arg(samplesperpixel));\n    //    return false;\n    if (samplesperpixel>500) {\n        // if there are more than 500 samples, we assume this is an error in the file and read only one sample!\n        setLastError(QObject::tr(\"can not load files with more than 500 samples/pixel   (from file '%1' with %2 samples/pixel)\").arg(filename).arg(samplesperpixel));\n        return false;\n    } else {\n        uint16 planarconfig;\n        TIFFGetField(tif,TIFFTAG_PLANARCONFIG,&planarconfig);\n\n\n        // we only read image with one sample per pixel, so we do nothave to care for TIFFTAG_PLANARCONFIG\n        if (!TIFFReadRGB(tif, data, nx, ny, channel)) {\n            if (TIFFIsTiled(tif)) { // load a tiled frame\n                uint32 tw, th;\n                TIFFGetField(tif,TIFFTAG_TILEWIDTH,&tw);\n                TIFFGetField(tif,TIFFTAG_TILELENGTH,&th);\n                switch (bitspersample) {\n                    case 8 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadTiled<uint8_t,  float>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_INT) ok=TIFFLoadTiled<int8_t,  float>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 8-bit tiled image in format different from INT or UINT   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    case 16 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadTiled<uint16_t,  float>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_INT) ok=TIFFLoadTiled<int16_t,  float>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 16-bit tiled image in format different from INT or UINT   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    case 32 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadTiled<uint32_t,  float>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_INT) ok=TIFFLoadTiled<int32_t,  float>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_IEEEFP) ok=TIFFLoadTiled<float,  float>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 32-bit tiled image in format different from INT, UINT, IEEE   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    case 64 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadTiled<uint64_t,  float>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_INT) ok=TIFFLoadTiled<int64_t,  float>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_IEEEFP) ok=TIFFLoadTiled<double,  float>(data,  tif, nx, ny, tw, th, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 64-bit tiled image in format different from INT, UINT, IEEE   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    default: {\n                            setLastError(QObject::tr(\"can not load tiled frame sample format in TIFF file   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                }\n            } else { // load a non-tiled frame\n                switch (bitspersample) {\n                    case 8 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadNontiled<uint8_t,  float>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_INT) ok=TIFFLoadNontiled<int8_t,  float>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 8-bit image in format different from INT or UINT   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    case 16 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadNontiled<uint16_t,  float>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_INT) ok=TIFFLoadNontiled<int16_t,  float>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 16-bit image in format different from INT or UINT   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    case 32 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadNontiled<uint32_t,  float>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_INT) ok=TIFFLoadNontiled<int32_t,  float>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_IEEEFP) ok=TIFFLoadNontiled<float,  float>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 32-bit image in format different from INT, UINT, IEEE   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    case 64 :\n                        if (sampleformat==SAMPLEFORMAT_UINT) ok=TIFFLoadNontiled<uint64_t,  float>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_INT) ok=TIFFLoadNontiled<int64_t,  float>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else if (sampleformat==SAMPLEFORMAT_IEEEFP) ok=TIFFLoadNontiled<double,  float>(data,  tif, nx, ny, channel, samplesperpixel, planarconfig);\n                        else {\n                            setLastError(QObject::tr(\"can not load 64-bit image in format different from INT, UINT, IEEE   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                    default: {\n                            setLastError(QObject::tr(\"can not load frame sample format in TIFF file   (from file '%1')\").arg(filename));\n                            return false;\n                        }\n                        break;\n                }\n            }\n        }\n    }\n    if (!ok) {\n        setLastError(QObject::tr(\"unknown error when reading frame from TIFF file   (from file '%1')\").arg(filename));\n    }\n    return ok;\n}",
    "bool QFRDRImagingFCSData::loadOverview(double* overviewF, double* overviewF2, const QString& filename) {\r\n    bool ok=false;\r\n\r\n    if (!overviewF && !overviewF2) return false;\r\n\r\n    //qDebug()<<getID()<<\"loadedOverview \"<<filename;\r\n    if (QFile::exists(filename)) {\r\n        TIFF* tif=TIFFOpen(filename.toLatin1().data(), \"r\");\r\n        if (tif) {\r\n            uint32 nx,ny;\r\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\r\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\r\n            double* tmp=(double*)qfMalloc(nx*ny*sizeof(double));\r\n            ok=TIFFReadFrame<double>(tif, tmp);\r\n            TIFFClose(tif);\r\n\r\n            if (ok) {\r\n\r\n                splitImage(overviewF, overviewF2, tmp, nx, ny);\r\n            }\r\n            qfFree(tmp);\r\n        } else {\r\n            log_warning(tr(\"WARNING: could not load overview image file '%1'\\n\").arg(filename));\r\n        }\r\n    } else {\r\n        log_warning(tr(\"WARNING: could not find overview image file '%1'\\n\").arg(filename));\r\n    }\r\n\r\n    //QFRawDataRecordReadLocker locker(this);\r\n    if (!ok && overviewF) {\r\n        for (int i=0; i<width*height; i++) {\r\n            overviewF[i]=0;\r\n        }\r\n    }\r\n    if (!ok && overviewF2) {\r\n        for (int i=0; i<width*height; i++) {\r\n            overviewF2[i]=0;\r\n        }\r\n    }\r\n    double crscaling=getProperty(\"OVERVIEW_SCALING\", 1.0).toDouble();\r\n    if (crscaling!=1.0 && overviewF) {\r\n        for (int i=0; i<width*height; i++) {\r\n            overviewF[i]=overviewF[i]*crscaling;\r\n        }\r\n\r\n    }\r\n    if (crscaling!=1.0 && overviewF2) {\r\n        for (int i=0; i<width*height; i++) {\r\n            overviewF2[i]=overviewF2[i]*crscaling;\r\n        }\r\n\r\n    }\r\n    //qDebug()<<getID()<<\"loadedOverview \"<<filename<<\"   OK=\"<<ok;\r\n    return ok;\r\n}",
    "bool QFRDRImagingFCSData::loadImage(const QString& filename, double** data, int* width, int* height) {\r\n    bool ok=false;\r\n\r\n    if (*data) qfFree(*data);\r\n    *data=NULL;\r\n    *width=0;\r\n    *height=0;\r\n\r\n    if (QFile::exists(filename)) {\r\n        TIFF* tif=TIFFOpen(filename.toLatin1().data(), \"r\");\r\n        if (tif) {\r\n            uint32 nx,ny;\r\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\r\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\r\n            *width=nx;\r\n            *height=ny;\r\n            *data=(double*)qfMalloc(nx*ny*sizeof(double));\r\n            ok=TIFFReadFrame<double>(tif, *data);\r\n            TIFFClose(tif);\r\n        } else {\r\n            log_warning(tr(\"WARNING: could not load overview image file '%1'\\n\").arg(filename));\r\n        }\r\n    } else {\r\n        log_warning(tr(\"WARNING: could not find overview image file '%1'\\n\").arg(filename));\r\n    }\r\n\r\n    double crscaling=getProperty(\"OVERVIEW_SCALING\", 1.0).toDouble();\r\n    if (crscaling!=1.0 && (*data)) {\r\n        for (int i=0; i<(*width)*(*height); i++) {\r\n            (*data)[i]=(*data)[i]*crscaling;\r\n        }\r\n\r\n    }\r\n    return ok;\r\n}",
    "bool QFRDRImagingFCSData::loadVideo(const QString& filename, double** data, int* width, int* height, uint32_t* frames, double scaleFactor, double scaleOffset) {\r\n    bool ok=false;\r\n\r\n    //qDebug()<<filename<<data<<width<<height<<frames;\r\n    if (!data || !width || !height || !frames) return false;\r\n\r\n    if (*data) qfFree(*data);\r\n    *data=NULL;\r\n    *width=0;\r\n    *height=0;\r\n    *frames=0;\r\n\r\n    if (QFile::exists(filename)) {\r\n        TIFF* tif=TIFFOpen(filename.toLatin1().data(), \"r\");\r\n        if (tif) {\r\n            *frames=TIFFCountDirectories(tif);\r\n            uint32 nx,ny;\r\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\r\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\r\n            uint16 bitspersample;\r\n            uint16 sampleformat = SAMPLEFORMAT_UINT;\r\n            TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleformat);\r\n            TIFFGetFieldDefaulted(tif,TIFFTAG_BITSPERSAMPLE,&bitspersample);\r\n\r\n            *width=nx;\r\n            *height=ny;\r\n            if (*frames>0 && *width>0 && *height>0) {\r\n                *data=(double*)qfMalloc(nx*ny*(*frames)*sizeof(double));\r\n                uint32_t i=0;\r\n                if (*data) {\r\n                    do {\r\n                        ok=ok & TIFFReadFrame<double>(tif, &((*data)[i*nx*ny]));\r\n                        if (sampleformat == SAMPLEFORMAT_UINT && bitspersample==16 && (scaleFactor!=1.0 || scaleOffset!=0.0)) {\r\n                            for (uint32_t jj=0; jj<nx*ny; jj++) {\r\n                                (*data)[i*nx*ny+jj]=scaleOffset+(*data)[i*nx*ny+jj]*scaleFactor;\r\n                            }\r\n                        }\r\n                        i++;\r\n                    } while (TIFFReadDirectory(tif) && i<=(*frames));\r\n                }\r\n            } else {\r\n                log_warning(tr(\"WARNING: could not load overview image file '%1'\\n\").arg(filename));\r\n            }\r\n            TIFFClose(tif);\r\n            //qDebug()<<getID()<<\"loading video \"<<filename<<\"   siez=\"<<*width<<\"x\"<<*height<<\"   frames=\"<<*frames;\r\n        } else {\r\n            log_warning(tr(\"WARNING: could not load overview image file '%1'\\n\").arg(filename));\r\n        }\r\n    } else {\r\n        log_warning(tr(\"WARNING: could not find overview image file '%1'\\n\").arg(filename));\r\n    }\r\n    return ok;\r\n}",
    "bool QFRDRNumberAndBrightnessData::loadFile(double *target, const QString &filename, QFRDRNumberAndBrightnessData::FileOperations op)\n{\n    bool ok=false;\n\n    if (!target) return false;\n\n\n    QFImageHalf ihalf=getSelectedImageHalf();\n\n    if (QFile::exists(filename)) {\n        TIFF* tif=TIFFOpen(filename.toLatin1().data(), \"r\");\n        if (tif) {\n            uint32 nx,ny;\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\n            if (ihalf==qfihNone) {\n                if ((int64_t)nx!=width || (int64_t)ny!=height) {\n                    ok=false;\n                } else {\n                    //double* filedata=(double*)qfMalloc(nx*ny*sizeof(double));\n                    //ok=TIFFReadFrame<double>(tif, filedata);\n                    ok=TIFFReadFrame<double>(tif, target);\n                }\n            } else if (ihalf==qfihLeft || ihalf==qfihRight) {\n                if ((int64_t)nx/2!=width || (int64_t)ny!=height) {\n                    ok=false;\n                } else {\n                    double* filedata=(double*)qfMalloc(nx*ny*sizeof(double));\n                    ok=TIFFReadFrame<double>(tif, filedata);\n                    qfCopyImageHalf(target, filedata, nx, ny, ihalf);\n                    qfFree(filedata);\n                }\n            } else if (ihalf==qfihTop || ihalf==qfihBottom) {\n                if ((int64_t)nx!=width || (int64_t)ny/2!=height) {\n                    ok=false;\n                } else {\n                    double* filedata=(double*)qfMalloc(nx*ny*sizeof(double));\n                    ok=TIFFReadFrame<double>(tif, filedata);\n                    qfCopyImageHalf(target, filedata, nx, ny, ihalf);\n                    qfFree(filedata);\n                }\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    if (!ok && target) {\n        for (int i=0; i<width*height; i++) {\n            target[i]=0;\n        }\n    }\n\n\n    switch(op) {\n        case QFRDRNumberAndBrightnessData::TakeSqrt:\n            for (int i=0; i<width*height; i++) {\n                target[i]=sqrt(target[i]);\n            }\n            break;\n        case QFRDRNumberAndBrightnessData::Square:\n            for (int i=0; i<width*height; i++) {\n                target[i]=target[i]*target[i];\n            }\n            break;\n        default:\n            break;\n    }\n    return ok;\n}",
    "bool QFRDRNumberAndBrightnessData::loadImage(const QString& filename, double** data, int* width, int* height) {\n    bool ok=false;\n\n    if (*data) qfFree(*data);\n    *data=NULL;\n    *width=0;\n    *height=0;\n\n    if (QFile::exists(filename)) {\n        TIFF* tif=TIFFOpen(filename.toLatin1().data(), \"r\");\n        if (tif) {\n            uint32 nx,ny;\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\n            *width=nx;\n            *height=ny;\n            *data=(double*)qfMalloc(nx*ny*sizeof(double));\n            ok=TIFFReadFrame<double>(tif, *data);\n            TIFFClose(tif);\n        }\n    }\n    return ok;\n}",
    "bool QFRDRNumberAndBrightnessData::loadVideo(const QString& filename, double** data, int* width, int* height, uint32_t* frames) {\n    bool ok=false;\n\n    if (*data) qfFree(*data);\n    *data=NULL;\n    *width=0;\n    *height=0;\n    *frames=0;\n\n    if (QFile::exists(filename)) {\n        TIFF* tif=TIFFOpen(filename.toLatin1().data(), \"r\");\n        if (tif) {\n            *frames=TIFFCountDirectories(tif);\n            uint32 nx,ny;\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\n            *width=nx;\n            *height=ny;\n            *data=(double*)qfMalloc(nx*ny*(*frames)*sizeof(double));\n            uint32_t i=0;\n            do {\n                ok=ok & TIFFReadFrame<double>(tif, &((*data)[i*nx*ny]));\n                i++;\n            } while (TIFFReadDirectory(tif) && i<=(*frames));\n            TIFFClose(tif);\n        }\n    }\n    return ok;\n}",
    "bool CxImageTIF::Decode(FILE * infile)\n{\n\t//Open file and fill the TIFF structure\n\t// m_tif = TIFFOpen(imageFileName,\"rb\");\n\tTIFF* m_tif = TIFFOpenEx(infile, \"rb\");\n\n\tuint32 height=0;\n\tuint32 width=0;\n\tuint16 bitspersample=1;\n\tuint16 samplesperpixel=1;\n\tuint32 rowsperstrip=-1;\n\tuint16 photometric=0;\n\tuint16 compression=1;\n\tuint32 x, y;\n\tBOOL isRGB;\n\tBYTE *bits;\t\t//pointer to source data\n\tBYTE *bits2;\t//pointer to destination data\n\n  try{\n\t//check if it's a tiff file\n\tif (!m_tif)\n\t\tthrow \"Error encountered while opening TIFF file\";\n\n\tinfo.nNumFrames=0;\n\twhile(TIFFSetDirectory(m_tif,(uint16)info.nNumFrames)) info.nNumFrames++;\n\n\n\tif (!TIFFSetDirectory(m_tif, (uint16)info.nFrame))\n\t\tthrow \"Error: page not present in TIFF file\";\t\t\t\n\n\t//get image info\n\tTIFFGetField(m_tif, TIFFTAG_COMPRESSION, &compression);\n\tif (compression == COMPRESSION_LZW)\n\t\tthrow \"LZW compression is no longer supported due to Unisys patent enforcement\";\t\t\t\n\n\tTIFFGetField(m_tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(m_tif, TIFFTAG_IMAGELENGTH, &height);\n\tTIFFGetField(m_tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\tTIFFGetField(m_tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\tTIFFGetField(m_tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);   \n\tTIFFGetField(m_tif, TIFFTAG_PHOTOMETRIC, &photometric);\n\n\thead.biWidth  = width;\n\thead.biHeight = height;\n\thead.biClrUsed=0;\n\tinfo.nBkgndIndex =-1;\n\n\tisRGB = (bitspersample >= 8) &&\n\t\t(photometric == PHOTOMETRIC_RGB) ||\n\t\t(photometric == PHOTOMETRIC_YCBCR) ||\n\t\t(photometric == PHOTOMETRIC_SEPARATED) ||\n\t\t(photometric == PHOTOMETRIC_LOGLUV);\n\n\tif (isRGB){\n\t\thead.biBitCount=24;\n\t\tinfo.bColorType = COLORTYPE_COLOR;\n\t}else{\n\t\tinfo.bColorType = COLORTYPE_PALETTE;\n\t\tif ((photometric==PHOTOMETRIC_MINISBLACK)||(photometric==PHOTOMETRIC_MINISWHITE)){\n\t\t\tif\t(bitspersample == 1){\n\t\t\t\thead.biBitCount=1;\t\t//B&W image\n\t\t\t\thead.biClrUsed =2;\n\t\t\t} else {\n\t\t\t\thead.biBitCount=8;\t\t//gray scale\n\t\t\t\thead.biClrUsed =256;\n\t\t\t}\n\t\t} else if (bitspersample == 4) {\n\t\t\thead.biBitCount=4;\t\t\t// 16 colors\n\t\t\thead.biClrUsed=16;\n\t\t} else {\n\t\t\thead.biBitCount=8;\t\t\t//256 colors\n\t\t\thead.biClrUsed=256;\n\t\t}\n\t}\n\n\tCreate(head.biWidth,head.biHeight,head.biBitCount);\t//image creation\n\n\tif (isRGB) {\n\t\t// Read the whole image into one big RGBA buffer using\n\t\t// the traditional TIFFReadRGBAImage() API that we trust.\n\t\tuint32* raster;\t\t// retrieve RGBA image\n\t\tuint32 *row;\n\n\t\traster = (uint32*)_TIFFmalloc(width * height * sizeof (uint32));\n\t\tif (raster == NULL) throw \"No space for raster buffer\";\n\t\t\t\n\t\t// Read the image in one chunk into an RGBA array\n\t\tif(!TIFFReadRGBAImage(m_tif, width, height, raster, 1)) {\n\t\t\t\t_TIFFfree(raster);\n\t\t\t\tthrow \"Corrupted TIFF file!\";\n\t\t}\n\n\t\t// read the raster lines and save them in the DIB\n\t\t// with RGB mode, we have to change the order of the 3 samples RGB\n\t\trow = &raster[0];\n\t\tbits2 = info.pImage;\n\t\tfor (y = 0; y < height; y++) {\n\t\t\tbits = bits2;\n\t\t\tfor (x = 0; x < width; x++) {\n\t\t\t\t*bits++ = (BYTE)TIFFGetB(row[x]);\n\t\t\t\t*bits++ = (BYTE)TIFFGetG(row[x]);\n\t\t\t\t*bits++ = (BYTE)TIFFGetR(row[x]);\n\t\t\t}\n\t\t\trow += width;\n\t\t\tbits2 += info.dwEffWidth;\n\t\t}\n\t\t_TIFFfree(raster);\n\t} else {\n\t\tRGBQUAD *pal;\n\t\tpal=(RGBQUAD*)calloc(256,sizeof(RGBQUAD));\n\t\tif (pal==NULL) throw \"Unable to allocate TIFF palette\";\n\n\t\t// set up the colormap based on photometric\t\n\t\tswitch(photometric) {\n\t\t\tcase PHOTOMETRIC_MINISBLACK:\t// bitmap and greyscale image types\n\t\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\t\t\tif (bitspersample == 1) {\t// Monochrome image\n\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISBLACK) {\n\t\t\t\t\t\tpal[1].rgbRed = pal[1].rgbGreen = pal[1].rgbBlue = 255;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpal[0].rgbRed = pal[0].rgbGreen = pal[0].rgbBlue = 255;\n\t\t\t\t\t}\n\t\t\t\t} else {\t\t// need to build the scale for greyscale images\n\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISBLACK) {\n\t\t\t\t\t\tfor (int i = 0; i < 256; i++) {\n\t\t\t\t\t\t\tpal[i].rgbRed = pal[i].rgbGreen = pal[i].rgbBlue = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (int i = 0; i < 256; i++) {\n\t\t\t\t\t\t\tpal[i].rgbRed =\tpal[i].rgbGreen = pal[i].rgbBlue = 255 - i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_PALETTE:\t// color map indexed\n\t\t\t\tuint16 *red;\n\t\t\t\tuint16 *green;\n\t\t\t\tuint16 *blue;\n\t\t\t\tTIFFGetField(m_tif, TIFFTAG_COLORMAP, &red, &green, &blue); \n\n\t\t\t\t// Is the palette 16 or 8 bits ?\n\t\t\t\tBOOL Palette16Bits = FALSE;\n\t\t\t\tint n=1<<bitspersample;\n\t\t\t\twhile (n-- > 0) {\n\t\t\t\t\tif (red[n] >= 256 || green[n] >= 256 || blue[n] >= 256) {\n\t\t\t\t\t\tPalette16Bits=TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// load the palette in the DIB\n\t\t\t\tfor (int i = (1 << bitspersample) - 1; i >= 0; i--) {\n\t\t\t\t\tif (Palette16Bits) {\n\t\t\t\t\t\tpal[i].rgbRed =(BYTE) CVT(red[i]);\n\t\t\t\t\t\tpal[i].rgbGreen = (BYTE) CVT(green[i]);\n\t\t\t\t\t\tpal[i].rgbBlue = (BYTE) CVT(blue[i]);           \n\t\t\t\t\t} else {\n\t\t\t\t\t\tpal[i].rgbRed = (BYTE) red[i];\n\t\t\t\t\t\tpal[i].rgbGreen = (BYTE) green[i];\n\t\t\t\t\t\tpal[i].rgbBlue = (BYTE) blue[i];        \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tSetPalette(pal,head.biClrUsed);\t//palette assign\n\t\tfree(pal);\n\n\t\t// read the tiff lines and save them in the DIB\n\t\tuint32 nrow;\n\t\tuint32 ys;\n\t\tint line = CalculateLine(width, bitspersample * samplesperpixel);\n//\t\tint pitch = CalculatePitch(line);\n\t\tlong bitsize= TIFFStripSize(m_tif);\n\t\tbits = (BYTE*)malloc(bitsize);\n\n\t\tfor (ys = 0; ys < height; ys += rowsperstrip) {\n\t\t\tnrow = (ys + rowsperstrip > height ? height - ys : rowsperstrip);\n\t\t\tif (TIFFReadEncodedStrip(m_tif, TIFFComputeStrip(m_tif, ys, 0), bits, nrow * line) == -1) {\n\t\t\t\tfree(bits);\n\t\t\t\tthrow \"Corrupted TIFF file!\";\n\t\t\t}\n\t\t\tfor (y = 0; y < nrow; y++) {\n\t\t\t\tmemcpy(info.pImage+info.dwEffWidth*(height-ys-nrow+y),bits+(nrow-y-1)*line,line);\n\t\t\t}\n\t\t\t/*if (head.biClrUsed==2){\n\t\t\t\tfor (y = 0; y < nrow; y++) { for (x = 0; x < width; x++) {\n\t\t\t\t\tSetPixelIndex(x,y+ys,(bits[y*line+(x>>3)]>>(7-x%8))&0x01);\n\t\t\t}}}*/\n\t\t}\n\t\tfree(bits);\n\t}\n  } catch (char *message) {\n\t  strncpy(info.szLastError,message,255);\n\t  if (m_tif) TIFFClose(m_tif);\n\t  return FALSE;\n  }\n\tTIFFClose(m_tif);\n\treturn TRUE;\n}",
    "ImageMetadata\nTiffReader::currentPageMetadata(TiffHandle const& tif)\n{\n    uint32_t width = 0, height = 0;\n    TIFFGetField(tif.handle(), TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tif.handle(), TIFFTAG_IMAGELENGTH, &height);\n    return ImageMetadata(QSize(width, height));\n}",
    "QImage\nTiffReader::extractBinaryOrIndexed8Image(\n    TiffHandle const& tif, TiffInfo const& info)\n{\n    QImage::Format format = QImage::Format_Indexed8;\n    if (info.bits_per_sample == 1)\n    {\n        // Because we specify B option when opening, we can\n        // always use Format_Mono, and not Format_MonoLSB.\n        format = QImage::Format_Mono;\n    }\n\n    QImage image(info.width, info.height, format);\n    if (image.isNull())\n    {\n        throw std::bad_alloc();\n    }\n\n    int const num_colors = 1 << info.bits_per_sample;\n    image.setColorCount(num_colors);\n\n    if (info.photometric == PHOTOMETRIC_PALETTE)\n    {\n        uint16_t* pr = 0;\n        uint16_t* pg = 0;\n        uint16_t* pb = 0;\n        TIFFGetField(tif.handle(), TIFFTAG_COLORMAP, &pr, &pg, &pb);\n        if (!pr || !pg || !pb)\n        {\n            return QImage();\n        }\n        if (info.host_big_endian != info.file_big_endian)\n        {\n            TIFFSwabArrayOfShort(pr, num_colors);\n            TIFFSwabArrayOfShort(pg, num_colors);\n            TIFFSwabArrayOfShort(pb, num_colors);\n        }\n        double const f = 255.0/65535.0;\n        for (int i = 0; i < num_colors; ++i)\n        {\n            uint32_t const r = (uint32_t)(pr[i] * f + 0.5);\n            uint32_t const g = (uint32_t)(pg[i] * f + 0.5);\n            uint32_t const b = (uint32_t)(pb[i] * f + 0.5);\n            uint32_t const a = 0xFF000000;\n            image.setColor(i, a | (r << 16) | (g << 8) | b);\n        }\n    }\n    else if (info.photometric == PHOTOMETRIC_MINISBLACK)\n    {\n        double const f = 255.0 / (num_colors - 1);\n        for (int i = 0; i < num_colors; ++i)\n        {\n            int const gray = (int)(i * f + 0.5);\n            image.setColor(i, qRgb(gray, gray, gray));\n        }\n    }\n    else if (info.photometric == PHOTOMETRIC_MINISWHITE)\n    {\n        double const f = 255.0 / (num_colors - 1);\n        int c = num_colors - 1;\n        for (int i = 0; i < num_colors; ++i, --c)\n        {\n            int const gray = (int)(c * f + 0.5);\n            image.setColor(i, qRgb(gray, gray, gray));\n        }\n    }\n    else\n    {\n        return QImage();\n    }\n\n    if (info.bits_per_sample == 1 || info.bits_per_sample == 8)\n    {\n        readLines(tif, image);\n    }\n    else\n    {\n        readAndUnpackLines(tif, info, image);\n    }\n\n    return image;\n}",
    "Img * Img::loadTIF(void *_tex, ImageReader read_func)\n{\n#if HAVE_LIBTIFF\n  // downloads the tiff file and put it into the cache\n\n  Texture *tex = static_cast<Texture *>(_tex);\n  char filename[PATH_LEN] = {0};\n\n  Cache::setCachePath(tex->url, filename);\n  Cache *cache = new Cache();\n  FILE *f = cache->open(filename, tex->http);\n  if (! f) {\n    error(\"can't read %s\", tex->url);\n    delete cache;\n    return NULL;\n  }\n  cache->close();\n  delete cache;\n\n  // opens the tiff file\n  TIFF *fp;\n  if (! (fp = TIFFOpen(filename, \"r\"))) return NULL;\n\n  /* reads the header */\n  uint32_t width, height;\n  uint8_t bpp = Img::RGB;\n\n  TIFFGetField(fp, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(fp, TIFFTAG_IMAGELENGTH, &height);\n  TIFFGetField(fp, TIFFTAG_SAMPLESPERPIXEL, &bpp);\n  if (bpp <= Img::RGB) bpp = Img::RGB;\n  else bpp = Img::RGBA;\n\n  trace1(DBG_2D, \"loadTIF: w=%d h=%d c=%d\", width, height, bpp);\n\n  // always 4 bytes per pixel for this\n  uint32_t * tifImage = static_cast<uint32_t *>(_TIFFmalloc((tsize_t)(width * height * sizeof(uint32_t))));\n\n  // reads the data with the library\n  if (! TIFFReadRGBAImage(fp, width, height, tifImage, 0)) {\n    error(\"loadTIF: error reading file %s\", filename);\n    return NULL;\n  }\n\n  // allocs img\n  Img *img = new Img(width, height, bpp);\n\n  // converts component format\n  uint8_t *pixptr = img->pixmap;\n\n  // fills the pixmap\n  for (int i=0; i < height ; i++) {\n    for (int j=0; j < width ; j++) {\n      uint32_t pixel = tifImage[(i*width) + j];\n\n      *pixptr++ = (uint8_t)TIFFGetR(pixel);\n      *pixptr++ = (uint8_t)TIFFGetG(pixel);\n      *pixptr++ = (uint8_t)TIFFGetB(pixel);\n      if (bpp == Img::RGBA) {\n        *pixptr++ = (uint8_t)TIFFGetA(pixel);\n      }\n    }\n  }\n  _TIFFfree(tifImage);\n  TIFFClose(fp);\n\n  return img;\n#else\n  return NULL;\n#endif\n}",
    "char **GTiffDatasetReadRPCTag(TIFF *hTIFF)\n\n{\n    double *padfRPCTag = nullptr;\n    uint16_t nCount;\n\n    if (!TIFFGetField(hTIFF, TIFFTAG_RPCCOEFFICIENT, &nCount, &padfRPCTag) ||\n        nCount != 92)\n        return nullptr;\n\n    CPLStringList asMD;\n    asMD.SetNameValue(RPC_ERR_BIAS, CPLOPrintf(\"%.15g\", padfRPCTag[0]));\n    asMD.SetNameValue(RPC_ERR_RAND, CPLOPrintf(\"%.15g\", padfRPCTag[1]));\n    asMD.SetNameValue(RPC_LINE_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[2]));\n    asMD.SetNameValue(RPC_SAMP_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[3]));\n    asMD.SetNameValue(RPC_LAT_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[4]));\n    asMD.SetNameValue(RPC_LONG_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[5]));\n    asMD.SetNameValue(RPC_HEIGHT_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[6]));\n    asMD.SetNameValue(RPC_LINE_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[7]));\n    asMD.SetNameValue(RPC_SAMP_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[8]));\n    asMD.SetNameValue(RPC_LAT_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[9]));\n    asMD.SetNameValue(RPC_LONG_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[10]));\n    asMD.SetNameValue(RPC_HEIGHT_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[11]));\n\n    CPLString osField;\n    CPLString osMultiField;\n\n    for (int i = 0; i < 20; ++i)\n    {\n        osField.Printf(\"%.15g\", padfRPCTag[12 + i]);\n        if (i > 0)\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue(RPC_LINE_NUM_COEFF, osMultiField);\n\n    for (int i = 0; i < 20; ++i)\n    {\n        osField.Printf(\"%.15g\", padfRPCTag[32 + i]);\n        if (i > 0)\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue(RPC_LINE_DEN_COEFF, osMultiField);\n\n    for (int i = 0; i < 20; ++i)\n    {\n        osField.Printf(\"%.15g\", padfRPCTag[52 + i]);\n        if (i > 0)\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue(RPC_SAMP_NUM_COEFF, osMultiField);\n\n    for (int i = 0; i < 20; ++i)\n    {\n        osField.Printf(\"%.15g\", padfRPCTag[72 + i]);\n        if (i > 0)\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue(RPC_SAMP_DEN_COEFF, osMultiField);\n\n    return asMD.StealList();\n}",
    "void GTiffWriteJPEGTables(TIFF *hTIFF, const char *pszPhotometric,\n                          const char *pszJPEGQuality,\n                          const char *pszJPEGTablesMode)\n{\n    // This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n    uint16_t nBands = 0;\n    if (!TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nBands))\n        nBands = 1;\n\n    uint16_t l_nBitsPerSample = 0;\n    if (!TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &(l_nBitsPerSample)))\n        l_nBitsPerSample = 1;\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf(\"%s%p\", szJPEGGTiffDatasetTmpPrefix, hTIFF);\n    VSILFILE *fpTmp = nullptr;\n    CPLString osTmp;\n    char **papszLocalParameters = nullptr;\n    const int nInMemImageWidth = 16;\n    const int nInMemImageHeight = 16;\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"COMPRESS\", \"JPEG\");\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"JPEG_QUALITY\", pszJPEGQuality);\n    if (nBands <= 4)\n    {\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                               \"PHOTOMETRIC\", pszPhotometric);\n    }\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters, \"BLOCKYSIZE\",\n                                           CPLSPrintf(\"%u\", nInMemImageHeight));\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters, \"NBITS\",\n                                           CPLSPrintf(\"%u\", l_nBitsPerSample));\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                           \"JPEGTABLESMODE\", pszJPEGTablesMode);\n\n    TIFF *hTIFFTmp =\n        GTiffDataset::CreateLL(osTmpFilenameIn, nInMemImageWidth,\n                               nInMemImageHeight, (nBands <= 4) ? nBands : 1,\n                               (l_nBitsPerSample <= 8) ? GDT_Byte : GDT_UInt16,\n                               0.0, papszLocalParameters, &fpTmp, osTmp);\n    CSLDestroy(papszLocalParameters);\n    if (hTIFFTmp)\n    {\n        uint16_t l_nPhotometric = 0;\n        int nJpegTablesModeIn = 0;\n        TIFFGetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, &(l_nPhotometric));\n        TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLESMODE, &nJpegTablesModeIn);\n        TIFFWriteCheck(hTIFFTmp, FALSE, \"CreateLL\");\n        TIFFWriteDirectory(hTIFFTmp);\n        TIFFSetDirectory(hTIFFTmp, 0);\n        // Now, reset quality and jpegcolormode.\n        const int l_nJpegQuality = pszJPEGQuality ? atoi(pszJPEGQuality) : 0;\n        if (l_nJpegQuality > 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGQUALITY, l_nJpegQuality);\n        if (l_nPhotometric == PHOTOMETRIC_YCBCR &&\n            CPLTestBool(CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\")))\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n        if (nJpegTablesModeIn >= 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGTABLESMODE, nJpegTablesModeIn);\n\n        GPtrDiff_t nBlockSize = static_cast<GPtrDiff_t>(nInMemImageWidth) *\n                                nInMemImageHeight *\n                                ((nBands <= 4) ? nBands : 1);\n        if (l_nBitsPerSample == 12)\n            nBlockSize = (nBlockSize * 3) / 2;\n        std::vector<GByte> abyZeroData(nBlockSize, 0);\n        TIFFWriteEncodedStrip(hTIFFTmp, 0, &abyZeroData[0], nBlockSize);\n\n        uint32_t nJPEGTableSize = 0;\n        void *pJPEGTable = nullptr;\n        if (TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSize,\n                         &pJPEGTable))\n            TIFFSetField(hTIFF, TIFFTAG_JPEGTABLES, nJPEGTableSize, pJPEGTable);\n\n        float *ref = nullptr;\n        if (TIFFGetField(hTIFFTmp, TIFFTAG_REFERENCEBLACKWHITE, &ref))\n            TIFFSetField(hTIFF, TIFFTAG_REFERENCEBLACKWHITE, ref);\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n    VSIUnlink(osTmpFilenameIn);\n}",
    "void VICARDataset::BuildLabelPropertyGeoTIFF(CPLJSONObject &oLabel)\n{\n    auto oProperty = GetOrCreateJSONObject(oLabel, \"PROPERTY\");\n    auto oGeoTIFF = GetOrCreateJSONObject(oProperty, \"GEOTIFF\");\n\n    // Ported from Vicar Open Source: Afids expects to be able to read\n    // NITF_NROWS and NITF_NCOLS\n\n    oGeoTIFF.Add(\"NITF_NROWS\", nRasterYSize);\n    oGeoTIFF.Add(\"NITF_NCOLS\", nRasterXSize);\n\n    // Create a in-memory GeoTIFF file\n\n    char szFilename[100] = {};\n    snprintf(szFilename, sizeof(szFilename), \"/vsimem/vicar_tmp_%p.tif\", this);\n    GDALDriver *poGTiffDriver =\n        GDALDriver::FromHandle(GDALGetDriverByName(\"GTiff\"));\n    if (poGTiffDriver == nullptr)\n    {\n        CPLError(CE_Failure, CPLE_AppDefined, \"GTiff driver not available\");\n        return;\n    }\n    const char *const apszOptions[] = {\"GEOTIFF_VERSION=1.0\", nullptr};\n    auto poDS = std::unique_ptr<GDALDataset>(\n        poGTiffDriver->Create(szFilename, 1, 1, 1, GDT_Byte, apszOptions));\n    if (!poDS)\n        return;\n    poDS->SetSpatialRef(&m_oSRS);\n    if (m_bGotTransform)\n        poDS->SetGeoTransform(&m_adfGeoTransform[0]);\n    poDS->SetMetadataItem(GDALMD_AREA_OR_POINT,\n                          GetMetadataItem(GDALMD_AREA_OR_POINT));\n    poDS.reset();\n\n    // Open it with libtiff/libgeotiff\n    VSILFILE *fpL = VSIFOpenL(szFilename, \"r\");\n    if (fpL == nullptr)\n    {\n        VSIUnlink(szFilename);\n        return;\n    }\n\n    TIFF *hTIFF = VSI_TIFFOpen(szFilename, \"r\", fpL);\n    CPLAssert(hTIFF);\n\n    GTIF *hGTIF = GTIFNew(hTIFF);\n    CPLAssert(hGTIF);\n\n    // Get geotiff keys and write them as VICAR metadata\n    for (const auto &gkey : GTiffShortKeys)\n    {\n        unsigned short val = 0;\n        if (GDALGTIFKeyGetSHORT(hGTIF, gkey, &val, 0, 1))\n        {\n            oGeoTIFF.Add(\n                CPLString(GTIFKeyName(gkey)).toupper(),\n                CPLSPrintf(\"%d(%s)\", val, GTIFValueNameEx(hGTIF, gkey, val)));\n        }\n    }\n\n    for (const auto &gkey : GTiffDoubleKeys)\n    {\n        double val = 0;\n        if (GDALGTIFKeyGetDOUBLE(hGTIF, gkey, &val, 0, 1))\n        {\n            oGeoTIFF.Add(CPLString(GTIFKeyName(gkey)).toupper(),\n                         CPLSPrintf(\"%.18g\", val));\n        }\n    }\n\n    for (const auto &gkey : GTiffAsciiKeys)\n    {\n        char szAscii[1024];\n        if (GDALGTIFKeyGetASCII(hGTIF, gkey, szAscii,\n                                static_cast<int>(sizeof(szAscii))))\n        {\n            oGeoTIFF.Add(CPLString(GTIFKeyName(gkey)).toupper(), szAscii);\n        }\n    }\n\n    GTIFFree(hGTIF);\n\n    // Get geotiff tags and write them as VICAR metadata\n    const std::map<int, const char *> oMapTagCodeToName = {\n        {TIFFTAG_GEOPIXELSCALE, \"MODELPIXELSCALETAG\"},\n        {TIFFTAG_GEOTIEPOINTS, \"MODELTIEPOINTTAG\"},\n        {TIFFTAG_GEOTRANSMATRIX, \"MODELTRANSFORMATIONTAG\"}};\n\n    for (const auto &kv : oMapTagCodeToName)\n    {\n        uint16_t nCount = 0;\n        double *padfValues = nullptr;\n        if (TIFFGetField(hTIFF, kv.first, &nCount, &padfValues))\n        {\n            std::string osVal(\"(\");\n            for (uint16_t i = 0; i < nCount; ++i)\n            {\n                if (i > 0)\n                    osVal += ',';\n                osVal += CPLSPrintf(\"%.18g\", padfValues[i]);\n            }\n            osVal += ')';\n            oGeoTIFF.Add(kv.second, osVal);\n        }\n    }\n\n    XTIFFClose(hTIFF);\n    CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n    VSIUnlink(szFilename);\n}",
    "CPLErr GTIFWktFromMemBufEx(int nSize, unsigned char *pabyBuffer,\n                           OGRSpatialReferenceH *phSRS,\n                           double *padfGeoTransform, int *pnGCPCount,\n                           GDAL_GCP **ppasGCPList, int *pbPixelIsPoint,\n                           char ***ppapszRPCMD)\n\n{\n    char szFilename[100] = {};\n\n    snprintf(szFilename, sizeof(szFilename), \"/vsimem/wkt_from_mem_buf_%ld.tif\",\n             static_cast<long>(CPLGetPID()));\n\n    /* -------------------------------------------------------------------- */\n    /*      Initialization of libtiff and libgeotiff.                       */\n    /* -------------------------------------------------------------------- */\n    GTiffOneTimeInit();  // For RPC tag.\n    LibgeotiffOneTimeInit();\n\n    /* -------------------------------------------------------------------- */\n    /*      Create a memory file from the buffer.                           */\n    /* -------------------------------------------------------------------- */\n    VSILFILE *fp = VSIFileFromMemBuffer(szFilename, pabyBuffer, nSize, FALSE);\n    if (fp == nullptr)\n        return CE_Failure;\n\n    /* -------------------------------------------------------------------- */\n    /*      Initialize access to the memory geotiff structure.              */\n    /* -------------------------------------------------------------------- */\n    TIFF *hTIFF = VSI_TIFFOpen(szFilename, \"rc\", fp);\n\n    if (hTIFF == nullptr)\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"TIFF/GeoTIFF structure is corrupt.\");\n        VSIUnlink(szFilename);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n        return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Get the projection definition.                                  */\n    /* -------------------------------------------------------------------- */\n    bool bPixelIsPoint = false;\n    bool bPointGeoIgnore = false;\n    unsigned short nRasterType = 0;\n\n    GTIF *hGTIF = GTIFNew(hTIFF);\n    if (hGTIF)\n        GTIFAttachPROJContext(hGTIF, OSRGetProjTLSContext());\n\n    if (hGTIF != nullptr &&\n        GDALGTIFKeyGetSHORT(hGTIF, GTRasterTypeGeoKey, &nRasterType, 0, 1) ==\n            1 &&\n        nRasterType == static_cast<unsigned short>(RasterPixelIsPoint))\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore =\n            CPLTestBool(CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\", \"FALSE\"));\n    }\n    if (pbPixelIsPoint)\n        *pbPixelIsPoint = bPixelIsPoint;\n    if (ppapszRPCMD)\n        *ppapszRPCMD = nullptr;\n\n    if (phSRS)\n    {\n        *phSRS = nullptr;\n        if (hGTIF != nullptr)\n        {\n            GTIFDefn *psGTIFDefn = GTIFAllocDefn();\n            if (GTIFGetDefn(hGTIF, psGTIFDefn))\n            {\n                *phSRS = GTIFGetOGISDefnAsOSR(hGTIF, psGTIFDefn);\n            }\n            GTIFFreeDefn(psGTIFDefn);\n        }\n    }\n    if (hGTIF)\n        GTIFFree(hGTIF);\n\n    /* -------------------------------------------------------------------- */\n    /*      Get geotransform or tiepoints.                                  */\n    /* -------------------------------------------------------------------- */\n    double *padfTiePoints = nullptr;\n    double *padfScale = nullptr;\n    double *padfMatrix = nullptr;\n    int16_t nCount = 0;\n\n    padfGeoTransform[0] = 0.0;\n    padfGeoTransform[1] = 1.0;\n    padfGeoTransform[2] = 0.0;\n    padfGeoTransform[3] = 0.0;\n    padfGeoTransform[4] = 0.0;\n    padfGeoTransform[5] = 1.0;\n\n    *pnGCPCount = 0;\n    *ppasGCPList = nullptr;\n\n    if (TIFFGetField(hTIFF, TIFFTAG_GEOPIXELSCALE, &nCount, &padfScale) &&\n        nCount >= 2)\n    {\n        padfGeoTransform[1] = padfScale[0];\n        padfGeoTransform[5] = -std::abs(padfScale[1]);\n\n        if (TIFFGetField(hTIFF, TIFFTAG_GEOTIEPOINTS, &nCount,\n                         &padfTiePoints) &&\n            nCount >= 6)\n        {\n            padfGeoTransform[0] =\n                padfTiePoints[3] - padfTiePoints[0] * padfGeoTransform[1];\n            padfGeoTransform[3] =\n                padfTiePoints[4] - padfTiePoints[1] * padfGeoTransform[5];\n\n            // Adjust for pixel is point in transform.\n            if (bPixelIsPoint && !bPointGeoIgnore)\n            {\n                padfGeoTransform[0] -=\n                    padfGeoTransform[1] * 0.5 + padfGeoTransform[2] * 0.5;\n                padfGeoTransform[3] -=\n                    padfGeoTransform[4] * 0.5 + padfGeoTransform[5] * 0.5;\n            }\n        }\n    }\n    else if (TIFFGetField(hTIFF, TIFFTAG_GEOTIEPOINTS, &nCount,\n                          &padfTiePoints) &&\n             nCount >= 6)\n    {\n        *pnGCPCount = nCount / 6;\n        *ppasGCPList =\n            static_cast<GDAL_GCP *>(CPLCalloc(sizeof(GDAL_GCP), *pnGCPCount));\n\n        for (int iGCP = 0; iGCP < *pnGCPCount; iGCP++)\n        {\n            char szID[32] = {};\n            GDAL_GCP *psGCP = *ppasGCPList + iGCP;\n\n            snprintf(szID, sizeof(szID), \"%d\", iGCP + 1);\n            psGCP->pszId = CPLStrdup(szID);\n            psGCP->pszInfo = CPLStrdup(\"\");\n            psGCP->dfGCPPixel = padfTiePoints[iGCP * 6 + 0];\n            psGCP->dfGCPLine = padfTiePoints[iGCP * 6 + 1];\n            psGCP->dfGCPX = padfTiePoints[iGCP * 6 + 3];\n            psGCP->dfGCPY = padfTiePoints[iGCP * 6 + 4];\n            psGCP->dfGCPZ = padfTiePoints[iGCP * 6 + 5];\n        }\n    }\n    else if (TIFFGetField(hTIFF, TIFFTAG_GEOTRANSMATRIX, &nCount,\n                          &padfMatrix) &&\n             nCount == 16)\n    {\n        padfGeoTransform[0] = padfMatrix[3];\n        padfGeoTransform[1] = padfMatrix[0];\n        padfGeoTransform[2] = padfMatrix[1];\n        padfGeoTransform[3] = padfMatrix[7];\n        padfGeoTransform[4] = padfMatrix[4];\n        padfGeoTransform[5] = padfMatrix[5];\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Read RPC                                                        */\n    /* -------------------------------------------------------------------- */\n    if (ppapszRPCMD != nullptr)\n    {\n        *ppapszRPCMD = GTiffDatasetReadRPCTag(hTIFF);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup.                                                        */\n    /* -------------------------------------------------------------------- */\n    XTIFFClose(hTIFF);\n    CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n\n    VSIUnlink(szFilename);\n\n    if (phSRS && *phSRS == nullptr)\n        return CE_Failure;\n\n    return CE_None;\n}",
    "static void GTIFF_Set_TIFFTAG_JPEGTABLES(TIFF *hTIFF,\n                                         jpeg_decompress_struct &sDInfo,\n                                         jpeg_compress_struct &sCInfo)\n{\n    char szTmpFilename[128] = {'\\0'};\n    snprintf(szTmpFilename, sizeof(szTmpFilename), \"/vsimem/tables_%p\",\n             &sDInfo);\n    VSILFILE *fpTABLES = VSIFOpenL(szTmpFilename, \"wb+\");\n\n    uint16_t nPhotometric = 0;\n    TIFFGetField(hTIFF, TIFFTAG_PHOTOMETRIC, &nPhotometric);\n\n    jpeg_vsiio_dest(&sCInfo, fpTABLES);\n\n    // Avoid unnecessary tables to be emitted.\n    if (nPhotometric != PHOTOMETRIC_YCBCR)\n    {\n        JQUANT_TBL *qtbl = sCInfo.quant_tbl_ptrs[1];\n        if (qtbl != nullptr)\n            qtbl->sent_table = TRUE;\n        JHUFF_TBL *htbl = sCInfo.dc_huff_tbl_ptrs[1];\n        if (htbl != nullptr)\n            htbl->sent_table = TRUE;\n        htbl = sCInfo.ac_huff_tbl_ptrs[1];\n        if (htbl != nullptr)\n            htbl->sent_table = TRUE;\n    }\n    jpeg_write_tables(&sCInfo);\n\n    CPL_IGNORE_RET_VAL(VSIFCloseL(fpTABLES));\n\n    vsi_l_offset nSizeTables = 0;\n    GByte *pabyJPEGTablesData =\n        VSIGetMemFileBuffer(szTmpFilename, &nSizeTables, FALSE);\n    TIFFSetField(hTIFF, TIFFTAG_JPEGTABLES, static_cast<int>(nSizeTables),\n                 pabyJPEGTablesData);\n\n    VSIUnlink(szTmpFilename);\n}",
    "bool GTiffDataset::IsBlockAvailable(int nBlockId, vsi_l_offset *pnOffset,\n                                    vsi_l_offset *pnSize, bool *pbErrOccurred)\n\n{\n    if (pbErrOccurred)\n        *pbErrOccurred = false;\n\n    std::pair<vsi_l_offset, vsi_l_offset> oPair;\n    if (m_oCacheStrileToOffsetByteCount.tryGet(nBlockId, oPair))\n    {\n        if (pnOffset)\n            *pnOffset = oPair.first;\n        if (pnSize)\n            *pnSize = oPair.second;\n        return oPair.first != 0;\n    }\n\n    WaitCompletionForBlock(nBlockId);\n\n    // Optimization to avoid fetching the whole Strip/TileCounts and\n    // Strip/TileOffsets arrays.\n    if (eAccess == GA_ReadOnly && !m_bStreamingIn)\n    {\n        int nErrOccurred = 0;\n        auto bytecount =\n            TIFFGetStrileByteCountWithErr(m_hTIFF, nBlockId, &nErrOccurred);\n        if (nErrOccurred && pbErrOccurred)\n            *pbErrOccurred = true;\n        if (pnOffset)\n        {\n            *pnOffset =\n                TIFFGetStrileOffsetWithErr(m_hTIFF, nBlockId, &nErrOccurred);\n            if (nErrOccurred && pbErrOccurred)\n                *pbErrOccurred = true;\n        }\n        if (pnSize)\n            *pnSize = bytecount;\n        return bytecount != 0;\n    }\n\n    toff_t *panByteCounts = nullptr;\n    toff_t *panOffsets = nullptr;\n    const bool bIsTiled = CPL_TO_BOOL(TIFFIsTiled(m_hTIFF));\n\n    if ((bIsTiled &&\n         TIFFGetField(m_hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts) &&\n         (pnOffset == nullptr ||\n          TIFFGetField(m_hTIFF, TIFFTAG_TILEOFFSETS, &panOffsets))) ||\n        (!bIsTiled &&\n         TIFFGetField(m_hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts) &&\n         (pnOffset == nullptr ||\n          TIFFGetField(m_hTIFF, TIFFTAG_STRIPOFFSETS, &panOffsets))))\n    {\n        if (panByteCounts == nullptr ||\n            (pnOffset != nullptr && panOffsets == nullptr))\n        {\n            if (pbErrOccurred)\n                *pbErrOccurred = true;\n            return false;\n        }\n        const int nBlockCount =\n            bIsTiled ? TIFFNumberOfTiles(m_hTIFF) : TIFFNumberOfStrips(m_hTIFF);\n        if (nBlockId >= nBlockCount)\n        {\n            if (pbErrOccurred)\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        if (pnOffset)\n            *pnOffset = panOffsets[nBlockId];\n        if (pnSize)\n            *pnSize = panByteCounts[nBlockId];\n        return panByteCounts[nBlockId] != 0;\n    }\n    else\n    {\n        if (pbErrOccurred)\n            *pbErrOccurred = true;\n    }\n\n    return false;\n}",
    "GDALDataset *GTiffDataset::Open(GDALOpenInfo *poOpenInfo)\n\n{\n    const char *pszFilename = poOpenInfo->pszFilename;\n\n    /* -------------------------------------------------------------------- */\n    /*      Check if it looks like a TIFF file.                             */\n    /* -------------------------------------------------------------------- */\n    if (!Identify(poOpenInfo))\n        return nullptr;\n\n    bool bAllowRGBAInterface = true;\n    if (STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\"))\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      We have a special hook for handling opening a specific          */\n    /*      directory of a TIFF file.                                       */\n    /* -------------------------------------------------------------------- */\n    if (STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\"))\n        return OpenDir(poOpenInfo);\n\n    GTiffOneTimeInit();\n\n    /* -------------------------------------------------------------------- */\n    /*      Try opening the dataset.                                        */\n    /* -------------------------------------------------------------------- */\n    bool bStreaming = false;\n    const char *pszReadStreaming =\n        CPLGetConfigOption(\"TIFF_READ_STREAMING\", nullptr);\n    if (poOpenInfo->fpL == nullptr)\n    {\n        poOpenInfo->fpL = VSIFOpenL(\n            pszFilename, poOpenInfo->eAccess == GA_ReadOnly ? \"rb\" : \"r+b\");\n        if (poOpenInfo->fpL == nullptr)\n            return nullptr;\n    }\n    else if (!(pszReadStreaming && !CPLTestBool(pszReadStreaming)) &&\n             poOpenInfo->nHeaderBytes >= 24 &&\n             // A pipe has no seeking capability, so its position is 0 despite\n             // having read bytes.\n             (static_cast<int>(VSIFTellL(poOpenInfo->fpL)) ==\n                  poOpenInfo->nHeaderBytes ||\n              strcmp(pszFilename, \"/vsistdin/\") == 0 ||\n              // STARTS_WITH(pszFilename, \"/vsicurl_streaming/\") ||\n              (pszReadStreaming && CPLTestBool(pszReadStreaming))))\n    {\n        bStreaming = true;\n        if (!GTIFFMakeBufferedStream(poOpenInfo))\n            return nullptr;\n    }\n\n    // Store errors/warnings and emit them later.\n    std::vector<CPLErrorHandlerAccumulatorStruct> aoErrors;\n    CPLInstallErrorHandlerAccumulator(aoErrors);\n    CPLSetCurrentErrorHandlerCatchDebug(FALSE);\n    const bool bDeferStrileLoading = CPLTestBool(\n        CPLGetConfigOption(\"GTIFF_USE_DEFER_STRILE_LOADING\", \"YES\"));\n    TIFF *l_hTIFF = VSI_TIFFOpen(\n        pszFilename,\n        poOpenInfo->eAccess == GA_ReadOnly\n            ? ((bStreaming || !bDeferStrileLoading) ? \"rC\" : \"rDOC\")\n            : (!bDeferStrileLoading ? \"r+C\" : \"r+DC\"),\n        poOpenInfo->fpL);\n    CPLUninstallErrorHandlerAccumulator();\n\n    // Now emit errors and change their criticality if needed\n    // We only emit failures if we didn't manage to open the file.\n    // Otherwise it makes Python bindings unhappy (#5616).\n    for (size_t iError = 0; iError < aoErrors.size(); ++iError)\n    {\n        ReportError(pszFilename,\n                    (l_hTIFF == nullptr && aoErrors[iError].type == CE_Failure)\n                        ? CE_Failure\n                        : CE_Warning,\n                    aoErrors[iError].no, \"%s\", aoErrors[iError].msg.c_str());\n    }\n    aoErrors.resize(0);\n\n    if (l_hTIFF == nullptr)\n        return nullptr;\n\n    uint32_t nXSize = 0;\n    TIFFGetField(l_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize);\n    uint32_t nYSize = 0;\n    TIFFGetField(l_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize);\n\n    if (nXSize > INT_MAX || nYSize > INT_MAX)\n    {\n        // GDAL only supports signed 32bit dimensions.\n        ReportError(pszFilename, CE_Failure, CPLE_NotSupported,\n                    \"Too large image size: %u x %u\", nXSize, nYSize);\n        XTIFFClose(l_hTIFF);\n        return nullptr;\n    }\n\n    uint16_t l_nCompression = 0;\n    if (!TIFFGetField(l_hTIFF, TIFFTAG_COMPRESSION, &(l_nCompression)))\n        l_nCompression = COMPRESSION_NONE;\n\n    /* -------------------------------------------------------------------- */\n    /*      Create a corresponding GDALDataset.                             */\n    /* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription(pszFilename);\n    poDS->m_pszFilename = CPLStrdup(pszFilename);\n    poDS->m_fpL = poOpenInfo->fpL;\n    poOpenInfo->fpL = nullptr;\n    poDS->m_bStreamingIn = bStreaming;\n    poDS->m_nCompression = l_nCompression;\n\n    // Check structural metadata (for COG)\n    const int nOffsetOfStructuralMetadata =\n        poOpenInfo->nHeaderBytes && ((poOpenInfo->pabyHeader[2] == 0x2B ||\n                                      poOpenInfo->pabyHeader[3] == 0x2B))\n            ? 16\n            : 8;\n    if (poOpenInfo->nHeaderBytes >\n            nOffsetOfStructuralMetadata +\n                static_cast<int>(strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\")) &&\n        memcmp(poOpenInfo->pabyHeader + nOffsetOfStructuralMetadata,\n               \"GDAL_STRUCTURAL_METADATA_SIZE=\",\n               strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\")) == 0)\n    {\n        const char *pszStructuralMD = reinterpret_cast<const char *>(\n            poOpenInfo->pabyHeader + nOffsetOfStructuralMetadata);\n        poDS->m_bLayoutIFDSBeforeData =\n            strstr(pszStructuralMD, \"LAYOUT=IFDS_BEFORE_DATA\") != nullptr;\n        poDS->m_bBlockOrderRowMajor =\n            strstr(pszStructuralMD, \"BLOCK_ORDER=ROW_MAJOR\") != nullptr;\n        poDS->m_bLeaderSizeAsUInt4 =\n            strstr(pszStructuralMD, \"BLOCK_LEADER=SIZE_AS_UINT4\") != nullptr;\n        poDS->m_bTrailerRepeatedLast4BytesRepeated =\n            strstr(pszStructuralMD, \"BLOCK_TRAILER=LAST_4_BYTES_REPEATED\") !=\n            nullptr;\n        poDS->m_bMaskInterleavedWithImagery =\n            strstr(pszStructuralMD, \"MASK_INTERLEAVED_WITH_IMAGERY=YES\") !=\n            nullptr;\n        poDS->m_bKnownIncompatibleEdition =\n            strstr(pszStructuralMD, \"KNOWN_INCOMPATIBLE_EDITION=YES\") !=\n            nullptr;\n        if (poDS->m_bKnownIncompatibleEdition)\n        {\n            poDS->ReportError(\n                CE_Warning, CPLE_AppDefined,\n                \"This file used to have optimizations in its layout, \"\n                \"but those have been, at least partly, invalidated by \"\n                \"later changes\");\n        }\n        else if (poDS->m_bLayoutIFDSBeforeData && poDS->m_bBlockOrderRowMajor &&\n                 poDS->m_bLeaderSizeAsUInt4 &&\n                 poDS->m_bTrailerRepeatedLast4BytesRepeated)\n        {\n            if (poOpenInfo->eAccess == GA_Update &&\n                !CPLTestBool(CSLFetchNameValueDef(poOpenInfo->papszOpenOptions,\n                                                  \"IGNORE_COG_LAYOUT_BREAK\",\n                                                  \"FALSE\")))\n            {\n                CPLError(CE_Failure, CPLE_AppDefined,\n                         \"File %s has C(loud) O(ptimized) G(eoTIFF) layout. \"\n                         \"Updating it will generally result in losing part of \"\n                         \"the optimizations (but will still produce a valid \"\n                         \"GeoTIFF file). If this is acceptable, open the file \"\n                         \"with the IGNORE_COG_LAYOUT_BREAK open option set \"\n                         \"to YES.\",\n                         pszFilename);\n                delete poDS;\n                return nullptr;\n            }\n            poDS->m_oGTiffMDMD.SetMetadataItem(\"LAYOUT\", \"COG\",\n                                               \"IMAGE_STRUCTURE\");\n        }\n    }\n\n    // In the case of GDAL_DISABLE_READDIR_ON_OPEN = NO / EMPTY_DIR\n    if (poOpenInfo->AreSiblingFilesLoaded() &&\n        CSLCount(poOpenInfo->GetSiblingFiles()) <= 1)\n    {\n        poDS->oOvManager.TransferSiblingFiles(\n            CSLDuplicate(poOpenInfo->GetSiblingFiles()));\n        poDS->m_bHasGotSiblingFiles = true;\n    }\n\n    if (poDS->OpenOffset(l_hTIFF, TIFFCurrentDirOffset(l_hTIFF),\n                         poOpenInfo->eAccess, bAllowRGBAInterface,\n                         true) != CE_None)\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    // Do we want blocks that are set to zero and that haven't yet being\n    // allocated as tile/strip to remain implicit?\n    if (CPLFetchBool(poOpenInfo->papszOpenOptions, \"SPARSE_OK\", false))\n        poDS->m_bWriteEmptyTiles = false;\n\n    poDS->InitCreationOrOpenOptions(poOpenInfo->eAccess == GA_Update,\n                                    poOpenInfo->papszOpenOptions);\n\n    poDS->m_bLoadPam = true;\n    poDS->m_bColorProfileMetadataChanged = false;\n    poDS->m_bMetadataChanged = false;\n    poDS->m_bGeoTIFFInfoChanged = false;\n    poDS->m_bNoDataChanged = false;\n    poDS->m_bForceUnsetGTOrGCPs = false;\n    poDS->m_bForceUnsetProjection = false;\n\n    // Used by GTIFFBuildOverviewsEx() for the COG driver\n    const char *pszMaskOverviewDS = CSLFetchNameValue(\n        poOpenInfo->papszOpenOptions, \"MASK_OVERVIEW_DATASET\");\n    if (pszMaskOverviewDS)\n    {\n        poDS->m_poMaskExtOvrDS.reset(GDALDataset::Open(\n            pszMaskOverviewDS, GDAL_OF_RASTER | GDAL_OF_INTERNAL));\n        if (!poDS->m_poMaskExtOvrDS || !poDS->AssociateExternalMask())\n        {\n            CPLDebug(\"GTiff\",\n                     \"Association with external mask overview file failed\");\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Initialize info for external overviews.                         */\n    /* -------------------------------------------------------------------- */\n    poDS->oOvManager.Initialize(poDS, pszFilename);\n    if (poOpenInfo->AreSiblingFilesLoaded())\n        poDS->oOvManager.TransferSiblingFiles(poOpenInfo->StealSiblingFiles());\n\n    // For backward compatibility, in case GTIFF_POINT_GEO_IGNORE is defined\n    // load georeferencing right now so as to not require it to be defined\n    // at the GetGeoTransform() time.\n    if (CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\", nullptr) != nullptr)\n    {\n        poDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    return poDS;\n}",
    "CPLErr GTiffDataset::OpenOffset(TIFF *hTIFFIn, toff_t nDirOffsetIn,\n                                GDALAccess eAccessIn, bool bAllowRGBAInterface,\n                                bool bReadGeoTransform)\n\n{\n    if (!hTIFFIn)\n        return CE_Failure;\n\n    eAccess = eAccessIn;\n\n    m_hTIFF = hTIFFIn;\n\n    m_nDirOffset = nDirOffsetIn;\n\n    if (!SetDirectory())\n        return CE_Failure;\n\n    /* -------------------------------------------------------------------- */\n    /*      Capture some information from the file that is of interest.     */\n    /* -------------------------------------------------------------------- */\n    uint32_t nXSize = 0;\n    uint32_t nYSize = 0;\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize);\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize);\n\n    // Unlikely to occur, but could happen on a disk full situation.\n    if (nXSize == 0 || nYSize == 0)\n        return CE_Failure;\n\n    if (nXSize > INT_MAX || nYSize > INT_MAX)\n    {\n        // GDAL only supports signed 32bit dimensions.\n        ReportError(CE_Failure, CPLE_NotSupported,\n                    \"Too large image size: %u x %u\", nXSize, nYSize);\n        return CE_Failure;\n    }\n    nRasterXSize = nXSize;\n    nRasterYSize = nYSize;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &m_nSamplesPerPixel))\n        nBands = 1;\n    else\n        nBands = m_nSamplesPerPixel;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_BITSPERSAMPLE, &(m_nBitsPerSample)))\n        m_nBitsPerSample = 1;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PLANARCONFIG, &(m_nPlanarConfig)))\n        m_nPlanarConfig = PLANARCONFIG_CONTIG;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PHOTOMETRIC, &(m_nPhotometric)))\n        m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLEFORMAT, &(m_nSampleFormat)))\n        m_nSampleFormat = SAMPLEFORMAT_UINT;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_COMPRESSION, &(m_nCompression)))\n        m_nCompression = COMPRESSION_NONE;\n\n    if (m_nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(m_nCompression))\n    {\n        const char *pszCompressionMethodName =\n            GTIFFGetCompressionMethodName(m_nCompression);\n        if (pszCompressionMethodName)\n        {\n            ReportError(CE_Failure, CPLE_AppDefined,\n                        \"Cannot open TIFF file due to missing codec %s.\",\n                        pszCompressionMethodName);\n        }\n        else\n        {\n            ReportError(\n                CE_Failure, CPLE_AppDefined,\n                \"Cannot open TIFF file due to missing codec of code %d.\",\n                m_nCompression);\n        }\n        return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      YCbCr JPEG compressed images should be translated on the fly    */\n    /*      to RGB by libtiff/libjpeg unless specifically requested         */\n    /*      otherwise.                                                      */\n    /* -------------------------------------------------------------------- */\n    if (m_nCompression == COMPRESSION_JPEG &&\n        m_nPhotometric == PHOTOMETRIC_YCBCR &&\n        CPLTestBool(CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\")))\n    {\n        m_oGTiffMDMD.SetMetadataItem(\"SOURCE_COLOR_SPACE\", \"YCbCr\",\n                                     \"IMAGE_STRUCTURE\");\n        int nColorMode = 0;\n        if (!TIFFGetField(m_hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode) ||\n            nColorMode != JPEGCOLORMODE_RGB)\n        {\n            TIFFSetField(m_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Get strip/tile layout.                                          */\n    /* -------------------------------------------------------------------- */\n    if (TIFFIsTiled(m_hTIFF))\n    {\n        uint32_t l_nBlockXSize = 0;\n        uint32_t l_nBlockYSize = 0;\n        TIFFGetField(m_hTIFF, TIFFTAG_TILEWIDTH, &(l_nBlockXSize));\n        TIFFGetField(m_hTIFF, TIFFTAG_TILELENGTH, &(l_nBlockYSize));\n        if (l_nBlockXSize > INT_MAX || l_nBlockYSize > INT_MAX)\n        {\n            ReportError(CE_Failure, CPLE_NotSupported,\n                        \"Too large block size: %u x %u\", l_nBlockXSize,\n                        l_nBlockYSize);\n            return CE_Failure;\n        }\n        m_nBlockXSize = static_cast<int>(l_nBlockXSize);\n        m_nBlockYSize = static_cast<int>(l_nBlockYSize);\n    }\n    else\n    {\n        if (!TIFFGetField(m_hTIFF, TIFFTAG_ROWSPERSTRIP, &(m_nRowsPerStrip)))\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                        \"RowsPerStrip not defined ... assuming all one strip.\");\n            m_nRowsPerStrip = nYSize;  // Dummy value.\n        }\n\n        // If the rows per strip is larger than the file we will get\n        // confused.  libtiff internally will treat the rowsperstrip as\n        // the image height and it is best if we do too. (#4468)\n        if (m_nRowsPerStrip > static_cast<uint32_t>(nRasterYSize))\n            m_nRowsPerStrip = nRasterYSize;\n\n        m_nBlockXSize = nRasterXSize;\n        m_nBlockYSize = m_nRowsPerStrip;\n    }\n\n    if (!ComputeBlocksPerColRowAndBand(nBands))\n        return CE_Failure;\n\n    /* -------------------------------------------------------------------- */\n    /*      Should we handle this using the GTiffBitmapBand?                */\n    /* -------------------------------------------------------------------- */\n    bool bTreatAsBitmap = false;\n\n    if (m_nBitsPerSample == 1 && nBands == 1)\n    {\n        bTreatAsBitmap = true;\n\n        // Lets treat large \"one row\" bitmaps using the scanline api.\n        if (!TIFFIsTiled(m_hTIFF) && m_nBlockYSize == nRasterYSize &&\n            nRasterYSize > 2000\n            // libtiff does not support reading JBIG files with\n            // TIFFReadScanline().\n            && m_nCompression != COMPRESSION_JBIG)\n        {\n            m_bTreatAsSplitBitmap = true;\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Should we treat this via the RGBA interface?                    */\n    /* -------------------------------------------------------------------- */\n    bool bTreatAsRGBA = false;\n    if (\n#ifdef DEBUG\n        CPLTestBool(CPLGetConfigOption(\"GTIFF_FORCE_RGBA\", \"NO\")) ||\n#endif\n        (bAllowRGBAInterface && !bTreatAsBitmap && !(m_nBitsPerSample > 8) &&\n         (m_nPhotometric == PHOTOMETRIC_CIELAB ||\n          m_nPhotometric == PHOTOMETRIC_LOGL ||\n          m_nPhotometric == PHOTOMETRIC_LOGLUV ||\n          m_nPhotometric == PHOTOMETRIC_SEPARATED ||\n          (m_nPhotometric == PHOTOMETRIC_YCBCR &&\n           m_nCompression != COMPRESSION_JPEG))))\n    {\n        char szMessage[1024] = {};\n\n        if (TIFFRGBAImageOK(m_hTIFF, szMessage) == 1)\n        {\n            const char *pszSourceColorSpace = nullptr;\n            nBands = 4;\n            switch (m_nPhotometric)\n            {\n                case PHOTOMETRIC_CIELAB:\n                    pszSourceColorSpace = \"CIELAB\";\n                    break;\n                case PHOTOMETRIC_LOGL:\n                    pszSourceColorSpace = \"LOGL\";\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    pszSourceColorSpace = \"LOGLUV\";\n                    break;\n                case PHOTOMETRIC_SEPARATED:\n                    pszSourceColorSpace = \"CMYK\";\n                    break;\n                case PHOTOMETRIC_YCBCR:\n                    pszSourceColorSpace = \"YCbCr\";\n                    nBands = 3;  // probably true for other photometric values\n                    break;\n            }\n            if (pszSourceColorSpace)\n                m_oGTiffMDMD.SetMetadataItem(\"SOURCE_COLOR_SPACE\",\n                                             pszSourceColorSpace,\n                                             \"IMAGE_STRUCTURE\");\n            bTreatAsRGBA = true;\n        }\n        else\n        {\n            CPLDebug(\"GTiff\", \"TIFFRGBAImageOK says:\\n%s\", szMessage);\n        }\n    }\n\n    // libtiff has various issues with OJPEG compression and chunky-strip\n    // support with the \"classic\" scanline/strip/tile interfaces, and that\n    // wouldn't work either, so better bail out.\n    if (m_nCompression == COMPRESSION_OJPEG && !bTreatAsRGBA)\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Old-JPEG compression only supported through RGBA interface, \"\n            \"which cannot be used probably because the file is corrupted\");\n        return CE_Failure;\n    }\n\n    // If photometric is YCbCr, scanline/strip/tile interfaces assumes that\n    // we are ready with downsampled data. And we are not.\n    if (m_nCompression != COMPRESSION_JPEG &&\n        m_nCompression != COMPRESSION_OJPEG &&\n        m_nPhotometric == PHOTOMETRIC_YCBCR &&\n        m_nPlanarConfig == PLANARCONFIG_CONTIG && !bTreatAsRGBA)\n    {\n        uint16_t nF1, nF2;\n        TIFFGetFieldDefaulted(m_hTIFF, TIFFTAG_YCBCRSUBSAMPLING, &nF1, &nF2);\n        if (nF1 != 1 || nF2 != 1)\n        {\n            ReportError(CE_Failure, CPLE_AppDefined,\n                        \"Cannot open TIFF file with YCbCr, subsampling and \"\n                        \"BitsPerSample > 8 that is not JPEG compressed\");\n            return CE_Failure;\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Should we treat this via the split interface?                   */\n    /* -------------------------------------------------------------------- */\n    if (!TIFFIsTiled(m_hTIFF) && m_nBitsPerSample == 8 &&\n        m_nBlockYSize == nRasterYSize && nRasterYSize > 2000 && !bTreatAsRGBA &&\n        CPLTestBool(CPLGetConfigOption(\"GDAL_ENABLE_TIFF_SPLIT\", \"YES\")))\n    {\n        m_bTreatAsSplit = true;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Should we treat this via the odd bits interface?                */\n    /* -------------------------------------------------------------------- */\n    bool bTreatAsOdd = false;\n    if (m_nSampleFormat == SAMPLEFORMAT_IEEEFP)\n    {\n        if (m_nBitsPerSample == 16 || m_nBitsPerSample == 24)\n            bTreatAsOdd = true;\n        else if (m_nBitsPerSample != 32 && m_nBitsPerSample != 64)\n        {\n            ReportError(CE_Failure, CPLE_AppDefined,\n                        \"Cannot open TIFF file with SampleFormat=IEEEFP \"\n                        \"and BitsPerSample=%d\",\n                        m_nBitsPerSample);\n            return CE_Failure;\n        }\n    }\n    else if (!bTreatAsRGBA && !bTreatAsBitmap && m_nBitsPerSample != 8 &&\n             m_nBitsPerSample != 16 && m_nBitsPerSample != 32 &&\n             m_nBitsPerSample != 64 && m_nBitsPerSample != 128)\n    {\n        bTreatAsOdd = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We can't support 'chunks' bigger than 2GB on 32 bit builds      */\n/* -------------------------------------------------------------------- */\n#if SIZEOF_VOIDP == 4\n    uint64_t nChunkSize = 0;\n    if (m_bTreatAsSplit || m_bTreatAsSplitBitmap)\n    {\n        nChunkSize = TIFFScanlineSize64(m_hTIFF);\n    }\n    else\n    {\n        if (TIFFIsTiled(m_hTIFF))\n            nChunkSize = TIFFTileSize64(m_hTIFF);\n        else\n            nChunkSize = TIFFStripSize64(m_hTIFF);\n    }\n    if (bTreatAsRGBA)\n    {\n        nChunkSize =\n            std::max(nChunkSize,\n                     4 * static_cast<uint64_t>(m_nBlockXSize) * m_nBlockYSize);\n    }\n    if (nChunkSize > static_cast<uint64_t>(INT_MAX))\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                    \"Scanline/tile/strip size bigger than 2GB unsupported \"\n                    \"on 32-bit builds.\");\n        return CE_Failure;\n    }\n#endif\n\n    const bool bMinIsWhite = m_nPhotometric == PHOTOMETRIC_MINISWHITE;\n\n    /* -------------------------------------------------------------------- */\n    /*      Check for NODATA                                                */\n    /* -------------------------------------------------------------------- */\n    char *pszText = nullptr;\n    if (TIFFGetField(m_hTIFF, TIFFTAG_GDAL_NODATA, &pszText) &&\n        !EQUAL(pszText, \"\"))\n    {\n        if (m_nBitsPerSample > 32 && m_nBitsPerSample <= 64 &&\n            m_nSampleFormat == SAMPLEFORMAT_INT)\n        {\n            m_bNoDataSetAsInt64 = true;\n            m_nNoDataValueInt64 =\n                static_cast<int64_t>(std::strtoll(pszText, nullptr, 10));\n        }\n        else if (m_nBitsPerSample > 32 && m_nBitsPerSample <= 64 &&\n                 m_nSampleFormat == SAMPLEFORMAT_UINT)\n        {\n            m_bNoDataSetAsUInt64 = true;\n            m_nNoDataValueUInt64 =\n                static_cast<uint64_t>(std::strtoull(pszText, nullptr, 10));\n        }\n        else\n        {\n            m_bNoDataSet = true;\n            m_dfNoDataValue = CPLAtofM(pszText);\n            if (m_nBitsPerSample == 32 &&\n                m_nSampleFormat == SAMPLEFORMAT_IEEEFP)\n            {\n                m_dfNoDataValue =\n                    GDALAdjustNoDataCloseToFloatMax(m_dfNoDataValue);\n                m_dfNoDataValue = static_cast<float>(m_dfNoDataValue);\n            }\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Capture the color table if there is one.                        */\n    /* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if (bTreatAsRGBA || m_nBitsPerSample > 16 ||\n        TIFFGetField(m_hTIFF, TIFFTAG_COLORMAP, &panRed, &panGreen, &panBlue) ==\n            0)\n    {\n        // Build inverted palette if we have inverted photometric.\n        // Pixel values remains unchanged.  Avoid doing this for *deep*\n        // data types (per #1882)\n        if (m_nBitsPerSample <= 16 && m_nPhotometric == PHOTOMETRIC_MINISWHITE)\n        {\n            m_poColorTable = new GDALColorTable();\n            const int nColorCount = 1 << m_nBitsPerSample;\n\n            for (int iColor = 0; iColor < nColorCount; ++iColor)\n            {\n                const short nValue = static_cast<short>(\n                    ((255 * (nColorCount - 1 - iColor)) / (nColorCount - 1)));\n                const GDALColorEntry oEntry = {nValue, nValue, nValue,\n                                               static_cast<short>(255)};\n                m_poColorTable->SetColorEntry(iColor, &oEntry);\n            }\n\n            m_nPhotometric = PHOTOMETRIC_PALETTE;\n        }\n        else\n        {\n            m_poColorTable = nullptr;\n        }\n    }\n    else\n    {\n        unsigned short nMaxColor = 0;\n\n        m_poColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 << m_nBitsPerSample;\n\n        for (int iColor = nColorCount - 1; iColor >= 0; iColor--)\n        {\n            // TODO(schwehr): Ensure the color entries are never negative?\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast<short>(panRed[iColor] / divisor),\n                static_cast<short>(panGreen[iColor] / divisor),\n                static_cast<short>(panBlue[iColor] / divisor),\n                static_cast<short>(\n                    m_bNoDataSet && static_cast<int>(m_dfNoDataValue) == iColor\n                        ? 0\n                        : 255)};\n\n            m_poColorTable->SetColorEntry(iColor, &oEntry);\n\n            nMaxColor = std::max(nMaxColor, panRed[iColor]);\n            nMaxColor = std::max(nMaxColor, panGreen[iColor]);\n            nMaxColor = std::max(nMaxColor, panBlue[iColor]);\n        }\n\n        // Bug 1384 - Some TIFF files are generated with color map entry\n        // values in range 0-255 instead of 0-65535 - try to handle these\n        // gracefully.\n        if (nMaxColor > 0 && nMaxColor < 256)\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"TIFF ColorTable seems to be improperly scaled, fixing up.\");\n\n            for (int iColor = nColorCount - 1; iColor >= 0; iColor--)\n            {\n                // TODO(schwehr): Ensure the color entries are never negative?\n                const GDALColorEntry oEntry = {\n                    static_cast<short>(panRed[iColor]),\n                    static_cast<short>(panGreen[iColor]),\n                    static_cast<short>(panBlue[iColor]),\n                    m_bNoDataSet && static_cast<int>(m_dfNoDataValue) == iColor\n                        ? static_cast<short>(0)\n                        : static_cast<short>(255)};\n\n                m_poColorTable->SetColorEntry(iColor, &oEntry);\n            }\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Create band information objects.                                */\n    /* -------------------------------------------------------------------- */\n    for (int iBand = 0; iBand < nBands; ++iBand)\n    {\n        if (bTreatAsRGBA)\n            SetBand(iBand + 1, new GTiffRGBABand(this, iBand + 1));\n        else if (m_bTreatAsSplitBitmap)\n            SetBand(iBand + 1, new GTiffSplitBitmapBand(this, iBand + 1));\n        else if (m_bTreatAsSplit)\n            SetBand(iBand + 1, new GTiffSplitBand(this, iBand + 1));\n        else if (bTreatAsBitmap)\n            SetBand(iBand + 1, new GTiffBitmapBand(this, iBand + 1));\n        else if (bTreatAsOdd)\n            SetBand(iBand + 1, new GTiffOddBitsBand(this, iBand + 1));\n        else\n            SetBand(iBand + 1, new GTiffRasterBand(this, iBand + 1));\n    }\n\n    if (GetRasterBand(1)->GetRasterDataType() == GDT_Unknown)\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                    \"Unsupported TIFF configuration: BitsPerSample(=%d) and \"\n                    \"SampleType(=%d)\",\n                    m_nBitsPerSample, m_nSampleFormat);\n        return CE_Failure;\n    }\n\n    m_bReadGeoTransform = bReadGeoTransform;\n\n    /* -------------------------------------------------------------------- */\n    /*      Capture some other potentially interesting information.         */\n    /* -------------------------------------------------------------------- */\n    char szWorkMDI[200] = {};\n    uint16_t nShort = 0;\n\n    const auto *pasTIFFTags = GetTIFFTags();\n    for (size_t iTag = 0; pasTIFFTags[iTag].pszTagName; ++iTag)\n    {\n        if (pasTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING)\n        {\n            if (TIFFGetField(m_hTIFF, pasTIFFTags[iTag].nTagVal, &pszText))\n                m_oGTiffMDMD.SetMetadataItem(pasTIFFTags[iTag].pszTagName,\n                                             pszText);\n        }\n        else if (pasTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT)\n        {\n            float fVal = 0.0;\n            if (TIFFGetField(m_hTIFF, pasTIFFTags[iTag].nTagVal, &fVal))\n            {\n                CPLsnprintf(szWorkMDI, sizeof(szWorkMDI), \"%.8g\", fVal);\n                m_oGTiffMDMD.SetMetadataItem(pasTIFFTags[iTag].pszTagName,\n                                             szWorkMDI);\n            }\n        }\n        else if (pasTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT &&\n                 pasTIFFTags[iTag].nTagVal != TIFFTAG_RESOLUTIONUNIT)\n        {\n            if (TIFFGetField(m_hTIFF, pasTIFFTags[iTag].nTagVal, &nShort))\n            {\n                snprintf(szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort);\n                m_oGTiffMDMD.SetMetadataItem(pasTIFFTags[iTag].pszTagName,\n                                             szWorkMDI);\n            }\n        }\n        else if (pasTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING)\n        {\n            uint32_t nCount = 0;\n            if (TIFFGetField(m_hTIFF, pasTIFFTags[iTag].nTagVal, &nCount,\n                             &pszText))\n            {\n                std::string osStr;\n                osStr.assign(pszText, nCount);\n                m_oGTiffMDMD.SetMetadataItem(pasTIFFTags[iTag].pszTagName,\n                                             osStr.c_str());\n            }\n        }\n    }\n\n    if (TIFFGetField(m_hTIFF, TIFFTAG_RESOLUTIONUNIT, &nShort))\n    {\n        if (nShort == RESUNIT_NONE)\n            snprintf(szWorkMDI, sizeof(szWorkMDI), \"%d (unitless)\", nShort);\n        else if (nShort == RESUNIT_INCH)\n            snprintf(szWorkMDI, sizeof(szWorkMDI), \"%d (pixels/inch)\", nShort);\n        else if (nShort == RESUNIT_CENTIMETER)\n            snprintf(szWorkMDI, sizeof(szWorkMDI), \"%d (pixels/cm)\", nShort);\n        else\n            snprintf(szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort);\n        m_oGTiffMDMD.SetMetadataItem(\"TIFFTAG_RESOLUTIONUNIT\", szWorkMDI);\n    }\n\n    int nTagSize = 0;\n    void *pData = nullptr;\n    if (TIFFGetField(m_hTIFF, TIFFTAG_XMLPACKET, &nTagSize, &pData))\n    {\n        char *pszXMP = static_cast<char *>(VSI_MALLOC_VERBOSE(nTagSize + 1));\n        if (pszXMP)\n        {\n            memcpy(pszXMP, pData, nTagSize);\n            pszXMP[nTagSize] = '\\0';\n\n            char *apszMDList[2] = {pszXMP, nullptr};\n            m_oGTiffMDMD.SetMetadata(apszMDList, \"xml:XMP\");\n\n            CPLFree(pszXMP);\n        }\n    }\n\n    if (m_nCompression != COMPRESSION_NONE)\n    {\n        const char *pszCompressionMethodName =\n            GTIFFGetCompressionMethodName(m_nCompression);\n        if (pszCompressionMethodName)\n        {\n            m_oGTiffMDMD.SetMetadataItem(\n                \"COMPRESSION\", pszCompressionMethodName, \"IMAGE_STRUCTURE\");\n        }\n        else\n        {\n            CPLString oComp;\n            oComp.Printf(\"%d\", m_nCompression);\n            m_oGTiffMDMD.SetMetadataItem(\"COMPRESSION\", oComp.c_str());\n        }\n    }\n\n    if (m_nCompression == COMPRESSION_JPEG &&\n        m_nPhotometric == PHOTOMETRIC_YCBCR)\n    {\n        m_oGTiffMDMD.SetMetadataItem(\"COMPRESSION\", \"YCbCr JPEG\",\n                                     \"IMAGE_STRUCTURE\");\n    }\n    else if (m_nCompression == COMPRESSION_LERC)\n    {\n        uint32_t nLercParamCount = 0;\n        uint32_t *panLercParams = nullptr;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_LERC_PARAMETERS, &nLercParamCount,\n                         &panLercParams) &&\n            nLercParamCount == 2)\n        {\n            memcpy(m_anLercAddCompressionAndVersion, panLercParams,\n                   sizeof(m_anLercAddCompressionAndVersion));\n        }\n\n        uint32_t nAddVersion = LERC_ADD_COMPRESSION_NONE;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION, &nAddVersion) &&\n            nAddVersion != LERC_ADD_COMPRESSION_NONE)\n        {\n            if (nAddVersion == LERC_ADD_COMPRESSION_DEFLATE)\n            {\n                m_oGTiffMDMD.SetMetadataItem(\"COMPRESSION\", \"LERC_DEFLATE\",\n                                             \"IMAGE_STRUCTURE\");\n            }\n            else if (nAddVersion == LERC_ADD_COMPRESSION_ZSTD)\n            {\n                m_oGTiffMDMD.SetMetadataItem(\"COMPRESSION\", \"LERC_ZSTD\",\n                                             \"IMAGE_STRUCTURE\");\n            }\n        }\n        uint32_t nLercVersion = LERC_VERSION_2_4;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_LERC_VERSION, &nLercVersion))\n        {\n            if (nLercVersion == LERC_VERSION_2_4)\n            {\n                m_oGTiffMDMD.SetMetadataItem(\"LERC_VERSION\", \"2.4\",\n                                             \"IMAGE_STRUCTURE\");\n            }\n            else\n            {\n                ReportError(CE_Warning, CPLE_AppDefined,\n                            \"Unknown Lerc version: %d\", nLercVersion);\n            }\n        }\n    }\n\n    if (m_nPlanarConfig == PLANARCONFIG_CONTIG && nBands != 1)\n        m_oGTiffMDMD.SetMetadataItem(\"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\");\n    else\n        m_oGTiffMDMD.SetMetadataItem(\"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\");\n\n    if ((GetRasterBand(1)->GetRasterDataType() == GDT_Byte &&\n         m_nBitsPerSample != 8) ||\n        (GetRasterBand(1)->GetRasterDataType() == GDT_UInt16 &&\n         m_nBitsPerSample != 16) ||\n        ((GetRasterBand(1)->GetRasterDataType() == GDT_UInt32 ||\n          GetRasterBand(1)->GetRasterDataType() == GDT_Float32) &&\n         m_nBitsPerSample != 32))\n    {\n        for (int i = 0; i < nBands; ++i)\n            cpl::down_cast<GTiffRasterBand *>(GetRasterBand(i + 1))\n                ->m_oGTiffMDMD.SetMetadataItem(\n                    \"NBITS\",\n                    CPLString().Printf(\"%d\",\n                                       static_cast<int>(m_nBitsPerSample)),\n                    \"IMAGE_STRUCTURE\");\n    }\n\n    if (bMinIsWhite)\n        m_oGTiffMDMD.SetMetadataItem(\"MINISWHITE\", \"YES\", \"IMAGE_STRUCTURE\");\n\n    if (TIFFGetField(m_hTIFF, TIFFTAG_GDAL_METADATA, &pszText))\n    {\n        CPLXMLNode *psRoot = CPLParseXMLString(pszText);\n        const CPLXMLNode *psItem =\n            psRoot ? CPLGetXMLNode(psRoot, \"=GDALMetadata\") : nullptr;\n        if (psItem)\n            psItem = psItem->psChild;\n        bool bMaxZErrorFound = false;\n        bool bMaxZErrorOverviewFound = false;\n        for (; psItem != nullptr; psItem = psItem->psNext)\n        {\n\n            if (psItem->eType != CXT_Element ||\n                !EQUAL(psItem->pszValue, \"Item\"))\n                continue;\n\n            const char *pszKey = CPLGetXMLValue(psItem, \"name\", nullptr);\n            const char *pszValue = CPLGetXMLValue(psItem, nullptr, nullptr);\n            int nBand = atoi(CPLGetXMLValue(psItem, \"sample\", \"-1\"));\n            if (nBand < -1 || nBand > 65535)\n                continue;\n            nBand++;\n            const char *pszRole = CPLGetXMLValue(psItem, \"role\", \"\");\n            const char *pszDomain = CPLGetXMLValue(psItem, \"domain\", \"\");\n\n            if (pszKey == nullptr || pszValue == nullptr)\n                continue;\n            if (EQUAL(pszDomain, \"IMAGE_STRUCTURE\"))\n            {\n                if (m_nCompression == COMPRESSION_WEBP &&\n                    EQUAL(pszKey, \"COMPRESSION_REVERSIBILITY\"))\n                {\n                    if (EQUAL(pszValue, \"LOSSLESS\"))\n                        m_bWebPLossless = true;\n                    else if (EQUAL(pszValue, \"LOSSY\"))\n                        m_bWebPLossless = false;\n                }\n                else if (m_nCompression == COMPRESSION_WEBP &&\n                         EQUAL(pszKey, \"WEBP_LEVEL\"))\n                {\n                    const int nLevel = atoi(pszValue);\n                    if (nLevel >= 1 && nLevel <= 100)\n                    {\n                        m_oGTiffMDMD.SetMetadataItem(\n                            \"COMPRESSION_REVERSIBILITY\", \"LOSSY\",\n                            \"IMAGE_STRUCTURE\");\n                        m_bWebPLossless = false;\n                        m_nWebPLevel = static_cast<signed char>(nLevel);\n                    }\n                }\n                else if (m_nCompression == COMPRESSION_LERC &&\n                         EQUAL(pszKey, \"MAX_Z_ERROR\"))\n                {\n                    bMaxZErrorFound = true;\n                    m_dfMaxZError = CPLAtof(pszValue);\n                }\n                else if (m_nCompression == COMPRESSION_LERC &&\n                         EQUAL(pszKey, \"MAX_Z_ERROR_OVERVIEW\"))\n                {\n                    bMaxZErrorOverviewFound = true;\n                    m_dfMaxZErrorOverview = CPLAtof(pszValue);\n                }\n#if HAVE_JXL\n                else if (m_nCompression == COMPRESSION_JXL &&\n                         EQUAL(pszKey, \"COMPRESSION_REVERSIBILITY\"))\n                {\n                    if (EQUAL(pszValue, \"LOSSLESS\"))\n                        m_bJXLLossless = true;\n                    else if (EQUAL(pszValue, \"LOSSY\"))\n                        m_bJXLLossless = false;\n                }\n                else if (m_nCompression == COMPRESSION_JXL &&\n                         EQUAL(pszKey, \"JXL_DISTANCE\"))\n                {\n                    const double dfVal = CPLAtof(pszValue);\n                    if (dfVal > 0 && dfVal <= 15)\n                    {\n                        m_oGTiffMDMD.SetMetadataItem(\n                            \"COMPRESSION_REVERSIBILITY\", \"LOSSY\",\n                            \"IMAGE_STRUCTURE\");\n                        m_bJXLLossless = false;\n                        m_fJXLDistance = static_cast<float>(dfVal);\n                    }\n                }\n                else if (m_nCompression == COMPRESSION_JXL &&\n                         EQUAL(pszKey, \"JXL_ALPHA_DISTANCE\"))\n                {\n                    const double dfVal = CPLAtof(pszValue);\n                    if (dfVal > 0 && dfVal <= 15)\n                    {\n                        m_oGTiffMDMD.SetMetadataItem(\n                            \"COMPRESSION_REVERSIBILITY\", \"LOSSY\",\n                            \"IMAGE_STRUCTURE\");\n                        m_fJXLAlphaDistance = static_cast<float>(dfVal);\n                    }\n                }\n                else if (m_nCompression == COMPRESSION_JXL &&\n                         EQUAL(pszKey, \"JXL_EFFORT\"))\n                {\n                    const int nEffort = atoi(pszValue);\n                    if (nEffort >= 1 && nEffort <= 9)\n                    {\n                        m_nJXLEffort = nEffort;\n                    }\n                }\n#endif\n                else\n                {\n                    continue;\n                }\n            }\n\n            bool bIsXML = false;\n\n            if (STARTS_WITH_CI(pszDomain, \"xml:\"))\n                bIsXML = TRUE;\n\n            // Note: this un-escaping should not normally be done, as the\n            // deserialization of the tree from XML also does it, so we end up\n            // width double XML escaping, but keep it for backward\n            // compatibility.\n            char *pszUnescapedValue =\n                CPLUnescapeString(pszValue, nullptr, CPLES_XML);\n            if (nBand == 0)\n            {\n                if (bIsXML)\n                {\n                    char *apszMD[2] = {pszUnescapedValue, nullptr};\n                    m_oGTiffMDMD.SetMetadata(apszMD, pszDomain);\n                }\n                else\n                {\n                    m_oGTiffMDMD.SetMetadataItem(pszKey, pszUnescapedValue,\n                                                 pszDomain);\n                }\n            }\n            else\n            {\n                GTiffRasterBand *poBand =\n                    cpl::down_cast<GTiffRasterBand *>(GetRasterBand(nBand));\n                if (poBand != nullptr)\n                {\n                    if (EQUAL(pszRole, \"scale\"))\n                    {\n                        poBand->m_bHaveOffsetScale = true;\n                        poBand->m_dfScale = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if (EQUAL(pszRole, \"offset\"))\n                    {\n                        poBand->m_bHaveOffsetScale = true;\n                        poBand->m_dfOffset = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if (EQUAL(pszRole, \"unittype\"))\n                    {\n                        poBand->m_osUnitType = pszUnescapedValue;\n                    }\n                    else if (EQUAL(pszRole, \"description\"))\n                    {\n                        poBand->m_osDescription = pszUnescapedValue;\n                    }\n                    else if (EQUAL(pszRole, \"colorinterp\"))\n                    {\n                        poBand->m_eBandInterp =\n                            GDALGetColorInterpretationByName(pszUnescapedValue);\n                    }\n                    else\n                    {\n                        if (bIsXML)\n                        {\n                            char *apszMD[2] = {pszUnescapedValue, nullptr};\n                            poBand->m_oGTiffMDMD.SetMetadata(apszMD, pszDomain);\n                        }\n                        else\n                        {\n                            poBand->m_oGTiffMDMD.SetMetadataItem(\n                                pszKey, pszUnescapedValue, pszDomain);\n                        }\n                    }\n                }\n            }\n            CPLFree(pszUnescapedValue);\n        }\n\n        if (bMaxZErrorFound && !bMaxZErrorOverviewFound)\n        {\n            m_dfMaxZErrorOverview = m_dfMaxZError;\n        }\n\n        CPLDestroyXMLNode(psRoot);\n    }",
    "void GTiffDataset::ThreadCompressionFunc(void *pData)\n{\n    GTiffCompressionJob *psJob = static_cast<GTiffCompressionJob *>(pData);\n    GTiffDataset *poDS = psJob->poDS;\n\n    VSILFILE *fpTmp = VSIFOpenL(psJob->pszTmpFilename, \"wb+\");\n    TIFF *hTIFFTmp = VSI_TIFFOpen(\n        psJob->pszTmpFilename, psJob->bTIFFIsBigEndian ? \"wb+\" : \"wl+\", fpTmp);\n    CPLAssert(hTIFFTmp != nullptr);\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGEWIDTH, poDS->m_nBlockXSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGELENGTH, psJob->nHeight);\n    TIFFSetField(hTIFFTmp, TIFFTAG_BITSPERSAMPLE, poDS->m_nBitsPerSample);\n    TIFFSetField(hTIFFTmp, TIFFTAG_COMPRESSION, poDS->m_nCompression);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, poDS->m_nPhotometric);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLEFORMAT, poDS->m_nSampleFormat);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLESPERPIXEL, poDS->m_nSamplesPerPixel);\n    TIFFSetField(hTIFFTmp, TIFFTAG_ROWSPERSTRIP, poDS->m_nBlockYSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PLANARCONFIG, poDS->m_nPlanarConfig);\n    if (psJob->nPredictor != PREDICTOR_NONE)\n        TIFFSetField(hTIFFTmp, TIFFTAG_PREDICTOR, psJob->nPredictor);\n    if (poDS->m_nCompression == COMPRESSION_LERC)\n    {\n        TIFFSetField(hTIFFTmp, TIFFTAG_LERC_PARAMETERS, 2,\n                     poDS->m_anLercAddCompressionAndVersion);\n    }\n    if (psJob->nExtraSampleCount)\n    {\n        TIFFSetField(hTIFFTmp, TIFFTAG_EXTRASAMPLES, psJob->nExtraSampleCount,\n                     psJob->pExtraSamples);\n    }\n\n    poDS->RestoreVolatileParameters(hTIFFTmp);\n\n    bool bOK = TIFFWriteEncodedStrip(hTIFFTmp, 0, psJob->pabyBuffer,\n                                     psJob->nBufferSize) == psJob->nBufferSize;\n\n    toff_t nOffset = 0;\n    if (bOK)\n    {\n        toff_t *panOffsets = nullptr;\n        toff_t *panByteCounts = nullptr;\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPOFFSETS, &panOffsets);\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts);\n\n        nOffset = panOffsets[0];\n        psJob->nCompressedBufferSize =\n            static_cast<GPtrDiff_t>(panByteCounts[0]);\n    }\n    else\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"Error when compressing strip/tile %d\", psJob->nStripOrTile);\n    }\n\n    XTIFFClose(hTIFFTmp);\n    if (VSIFCloseL(fpTmp) != 0)\n    {\n        if (bOK)\n        {\n            bOK = false;\n            CPLError(CE_Failure, CPLE_AppDefined,\n                     \"Error when compressing strip/tile %d\",\n                     psJob->nStripOrTile);\n        }\n    }\n\n    if (bOK)\n    {\n        vsi_l_offset nFileSize = 0;\n        GByte *pabyCompressedBuffer =\n            VSIGetMemFileBuffer(psJob->pszTmpFilename, &nFileSize, FALSE);\n        CPLAssert(static_cast<vsi_l_offset>(\n                      nOffset + psJob->nCompressedBufferSize) <= nFileSize);\n        psJob->pabyCompressedBuffer = pabyCompressedBuffer + nOffset;\n    }\n    else\n    {\n        psJob->pabyCompressedBuffer = nullptr;\n        psJob->nCompressedBufferSize = 0;\n    }\n\n    auto mutex = poDS->m_poBaseDS ? poDS->m_poBaseDS->m_hCompressThreadPoolMutex\n                                  : poDS->m_hCompressThreadPoolMutex;\n    if (mutex)\n    {\n        CPLAcquireMutex(mutex, 1000.0);\n        psJob->bReady = true;\n        CPLReleaseMutex(mutex);\n    }\n}",
    "bool GTiffDataset::SubmitCompressionJob(int nStripOrTile, GByte *pabyData,\n                                        GPtrDiff_t cc, int nHeight)\n{\n    /* -------------------------------------------------------------------- */\n    /*      Should we do compression in a worker thread ?                   */\n    /* -------------------------------------------------------------------- */\n    auto poQueue = m_poBaseDS ? m_poBaseDS->m_poCompressQueue.get()\n                              : m_poCompressQueue.get();\n\n    if (poQueue && m_nCompression == COMPRESSION_NONE)\n    {\n        // We don't do multi-threaded compression for uncompressed...\n        // but we must wait for other related compression tasks (e.g mask)\n        // to be completed\n        poQueue->WaitCompletion();\n\n        // Flush remaining data\n        // cppcheck-suppress constVariableReference\n        auto &oQueue =\n            m_poBaseDS ? m_poBaseDS->m_asQueueJobIdx : m_asQueueJobIdx;\n        while (!oQueue.empty())\n        {\n            WaitCompletionForJobIdx(oQueue.front());\n        }\n    }\n\n    const auto SetupJob =\n        [this, pabyData, cc, nHeight, nStripOrTile](GTiffCompressionJob &sJob)\n    {\n        sJob.poDS = this;\n        sJob.bTIFFIsBigEndian = CPL_TO_BOOL(TIFFIsBigEndian(m_hTIFF));\n        sJob.pabyBuffer = static_cast<GByte *>(CPLRealloc(sJob.pabyBuffer, cc));\n        memcpy(sJob.pabyBuffer, pabyData, cc);\n        sJob.nBufferSize = cc;\n        sJob.nHeight = nHeight;\n        sJob.nStripOrTile = nStripOrTile;\n        sJob.nPredictor = PREDICTOR_NONE;\n        if (GTIFFSupportsPredictor(m_nCompression))\n        {\n            TIFFGetField(m_hTIFF, TIFFTAG_PREDICTOR, &sJob.nPredictor);\n        }\n\n        sJob.pExtraSamples = nullptr;\n        sJob.nExtraSampleCount = 0;\n        TIFFGetField(m_hTIFF, TIFFTAG_EXTRASAMPLES, &sJob.nExtraSampleCount,\n                     &sJob.pExtraSamples);\n    };\n\n    if (poQueue == nullptr || !(m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n                                m_nCompression == COMPRESSION_LZW ||\n                                m_nCompression == COMPRESSION_PACKBITS ||\n                                m_nCompression == COMPRESSION_LZMA ||\n                                m_nCompression == COMPRESSION_ZSTD ||\n                                m_nCompression == COMPRESSION_LERC ||\n                                m_nCompression == COMPRESSION_JXL ||\n                                m_nCompression == COMPRESSION_WEBP ||\n                                m_nCompression == COMPRESSION_JPEG))\n    {\n        if (m_bBlockOrderRowMajor || m_bLeaderSizeAsUInt4 ||\n            m_bTrailerRepeatedLast4BytesRepeated)\n        {\n            GTiffCompressionJob sJob;\n            memset(&sJob, 0, sizeof(sJob));\n            SetupJob(sJob);\n            sJob.pszTmpFilename =\n                CPLStrdup(CPLSPrintf(\"/vsimem/gtiff/%p\", this));\n\n            ThreadCompressionFunc(&sJob);\n\n            if (sJob.nCompressedBufferSize)\n            {\n                sJob.poDS->WriteRawStripOrTile(sJob.nStripOrTile,\n                                               sJob.pabyCompressedBuffer,\n                                               sJob.nCompressedBufferSize);\n            }\n\n            CPLFree(sJob.pabyBuffer);\n            VSIUnlink(sJob.pszTmpFilename);\n            CPLFree(sJob.pszTmpFilename);\n            return sJob.nCompressedBufferSize > 0 && !m_bWriteError;\n        }\n\n        return false;\n    }\n\n    auto &oQueue = m_poBaseDS ? m_poBaseDS->m_asQueueJobIdx : m_asQueueJobIdx;\n    auto &asJobs =\n        m_poBaseDS ? m_poBaseDS->m_asCompressionJobs : m_asCompressionJobs;\n\n    int nNextCompressionJobAvail = -1;\n\n    if (oQueue.size() == asJobs.size())\n    {\n        CPLAssert(!oQueue.empty());\n        nNextCompressionJobAvail = oQueue.front();\n        WaitCompletionForJobIdx(nNextCompressionJobAvail);\n    }\n    else\n    {\n        const int nJobs = static_cast<int>(asJobs.size());\n        for (int i = 0; i < nJobs; ++i)\n        {\n            if (asJobs[i].nBufferSize == 0)\n            {\n                nNextCompressionJobAvail = i;\n                break;\n            }\n        }\n    }\n    CPLAssert(nNextCompressionJobAvail >= 0);\n\n    GTiffCompressionJob *psJob = &asJobs[nNextCompressionJobAvail];\n    SetupJob(*psJob);\n    poQueue->SubmitJob(ThreadCompressionFunc, psJob);\n    oQueue.push(nNextCompressionJobAvail);\n\n    return true;\n}",
    "bool GTiffDataset::WriteMetadata(GDALDataset *poSrcDS, TIFF *l_hTIFF,\n                                 bool bSrcIsGeoTIFF, GTiffProfile eProfile,\n                                 const char *pszTIFFFilename,\n                                 CSLConstList papszCreationOptions,\n                                 bool bExcludeRPBandIMGFileWriting)\n\n{\n    /* -------------------------------------------------------------------- */\n    /*      Convert all the remaining metadata into a simple XML            */\n    /*      format.                                                         */\n    /* -------------------------------------------------------------------- */\n    CPLXMLNode *psRoot = nullptr;\n    CPLXMLNode *psTail = nullptr;\n\n    if (bSrcIsGeoTIFF)\n    {\n        GTiffDataset *poSrcDSGTiff = cpl::down_cast<GTiffDataset *>(poSrcDS);\n        assert(poSrcDSGTiff);\n        WriteMDMetadata(&poSrcDSGTiff->m_oGTiffMDMD, l_hTIFF, &psRoot, &psTail,\n                        0, eProfile);\n    }\n    else\n    {\n        const char *pszCopySrcMDD =\n            CSLFetchNameValueDef(papszCreationOptions, \"COPY_SRC_MDD\", \"AUTO\");\n        char **papszSrcMDD =\n            CSLFetchNameValueMultiple(papszCreationOptions, \"SRC_MDD\");\n        if (EQUAL(pszCopySrcMDD, \"AUTO\") || CPLTestBool(pszCopySrcMDD) ||\n            papszSrcMDD)\n        {\n            GDALMultiDomainMetadata l_oMDMD;\n            char **papszMD = poSrcDS->GetMetadata();\n            if (CSLCount(papszMD) > 0 &&\n                (!papszSrcMDD || CSLFindString(papszSrcMDD, \"\") >= 0 ||\n                 CSLFindString(papszSrcMDD, \"_DEFAULT_\") >= 0))\n            {\n                l_oMDMD.SetMetadata(papszMD);\n            }\n\n            if ((!EQUAL(pszCopySrcMDD, \"AUTO\") && CPLTestBool(pszCopySrcMDD)) ||\n                papszSrcMDD)\n            {\n                char **papszDomainList = poSrcDS->GetMetadataDomainList();\n                for (char **papszIter = papszDomainList;\n                     papszIter && *papszIter; ++papszIter)\n                {\n                    const char *pszDomain = *papszIter;\n                    if (pszDomain[0] != 0 &&\n                        (!papszSrcMDD ||\n                         CSLFindString(papszSrcMDD, pszDomain) >= 0))\n                    {\n                        l_oMDMD.SetMetadata(poSrcDS->GetMetadata(pszDomain),\n                                            pszDomain);\n                    }\n                }\n                CSLDestroy(papszDomainList);\n            }\n\n            WriteMDMetadata(&l_oMDMD, l_hTIFF, &psRoot, &psTail, 0, eProfile);\n        }\n        CSLDestroy(papszSrcMDD);\n    }\n\n    if (!bExcludeRPBandIMGFileWriting)\n    {\n        WriteRPC(poSrcDS, l_hTIFF, bSrcIsGeoTIFF, eProfile, pszTIFFFilename,\n                 papszCreationOptions);\n\n        /* --------------------------------------------------------------------\n         */\n        /*      Handle metadata data written to an IMD file. */\n        /* --------------------------------------------------------------------\n         */\n        char **papszIMDMD = poSrcDS->GetMetadata(MD_DOMAIN_IMD);\n        if (papszIMDMD != nullptr)\n        {\n            GDALWriteIMDFile(pszTIFFFilename, papszIMDMD);\n        }\n    }\n\n    uint16_t nPhotometric = 0;\n    if (!TIFFGetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric)))\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    const bool bStandardColorInterp = GTIFFIsStandardColorInterpretation(\n        GDALDataset::ToHandle(poSrcDS), nPhotometric, papszCreationOptions);\n\n    /* -------------------------------------------------------------------- */\n    /*      We also need to address band specific metadata, and special     */\n    /*      \"role\" metadata.                                                */\n    /* -------------------------------------------------------------------- */\n    for (int nBand = 1; nBand <= poSrcDS->GetRasterCount(); ++nBand)\n    {\n        GDALRasterBand *poBand = poSrcDS->GetRasterBand(nBand);\n\n        if (bSrcIsGeoTIFF)\n        {\n            GTiffRasterBand *poSrcBandGTiff =\n                cpl::down_cast<GTiffRasterBand *>(poBand);\n            assert(poSrcBandGTiff);\n            WriteMDMetadata(&poSrcBandGTiff->m_oGTiffMDMD, l_hTIFF, &psRoot,\n                            &psTail, nBand, eProfile);\n        }\n        else\n        {\n            char **papszMD = poBand->GetMetadata();\n\n            if (CSLCount(papszMD) > 0)\n            {\n                GDALMultiDomainMetadata l_oMDMD;\n                l_oMDMD.SetMetadata(papszMD);\n\n                WriteMDMetadata(&l_oMDMD, l_hTIFF, &psRoot, &psTail, nBand,\n                                eProfile);\n            }\n        }\n\n        const double dfOffset = poBand->GetOffset();\n        const double dfScale = poBand->GetScale();\n        bool bGeoTIFFScaleOffsetInZ = false;\n        double adfGeoTransform[6];\n        // Check if we have already encoded scale/offset in the GeoTIFF tags\n        if (poSrcDS->GetGeoTransform(adfGeoTransform) == CE_None &&\n            adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0 &&\n            adfGeoTransform[5] < 0.0 && poSrcDS->GetSpatialRef() &&\n            poSrcDS->GetSpatialRef()->IsVertical() &&\n            poSrcDS->GetRasterCount() == 1)\n        {\n            bGeoTIFFScaleOffsetInZ = true;\n        }\n\n        if ((dfOffset != 0.0 || dfScale != 1.0) && !bGeoTIFFScaleOffsetInZ)\n        {\n            char szValue[128] = {};\n\n            CPLsnprintf(szValue, sizeof(szValue), \"%.18g\", dfOffset);\n            AppendMetadataItem(&psRoot, &psTail, \"OFFSET\", szValue, nBand,\n                               \"offset\", \"\");\n            CPLsnprintf(szValue, sizeof(szValue), \"%.18g\", dfScale);\n            AppendMetadataItem(&psRoot, &psTail, \"SCALE\", szValue, nBand,\n                               \"scale\", \"\");\n        }\n\n        const char *pszUnitType = poBand->GetUnitType();\n        if (pszUnitType != nullptr && pszUnitType[0] != '\\0')\n        {\n            bool bWriteUnit = true;\n            auto poSRS = poSrcDS->GetSpatialRef();\n            if (poSRS && poSRS->IsCompound())\n            {\n                const char *pszVertUnit = nullptr;\n                poSRS->GetTargetLinearUnits(\"COMPD_CS|VERT_CS\", &pszVertUnit);\n                if (pszVertUnit && EQUAL(pszVertUnit, pszUnitType))\n                {\n                    bWriteUnit = false;\n                }\n            }\n            if (bWriteUnit)\n            {\n                AppendMetadataItem(&psRoot, &psTail, \"UNITTYPE\", pszUnitType,\n                                   nBand, \"unittype\", \"\");\n            }\n        }\n\n        if (strlen(poBand->GetDescription()) > 0)\n        {\n            AppendMetadataItem(&psRoot, &psTail, \"DESCRIPTION\",\n                               poBand->GetDescription(), nBand, \"description\",\n                               \"\");\n        }\n\n        if (!bStandardColorInterp &&\n            !(nBand <= 3 && EQUAL(CSLFetchNameValueDef(papszCreationOptions,\n                                                       \"PHOTOMETRIC\", \"\"),\n                                  \"RGB\")))\n        {\n            AppendMetadataItem(&psRoot, &psTail, \"COLORINTERP\",\n                               GDALGetColorInterpretationName(\n                                   poBand->GetColorInterpretation()),\n                               nBand, \"colorinterp\", \"\");\n        }\n    }\n\n    const char *pszTilingSchemeName =\n        CSLFetchNameValue(papszCreationOptions, \"@TILING_SCHEME_NAME\");\n    if (pszTilingSchemeName)\n    {\n        AppendMetadataItem(&psRoot, &psTail, \"NAME\", pszTilingSchemeName, 0,\n                           nullptr, \"TILING_SCHEME\");\n\n        const char *pszZoomLevel = CSLFetchNameValue(\n            papszCreationOptions, \"@TILING_SCHEME_ZOOM_LEVEL\");\n        if (pszZoomLevel)\n        {\n            AppendMetadataItem(&psRoot, &psTail, \"ZOOM_LEVEL\", pszZoomLevel, 0,\n                               nullptr, \"TILING_SCHEME\");\n        }\n\n        const char *pszAlignedLevels = CSLFetchNameValue(\n            papszCreationOptions, \"@TILING_SCHEME_ALIGNED_LEVELS\");\n        if (pszAlignedLevels)\n        {\n            AppendMetadataItem(&psRoot, &psTail, \"ALIGNED_LEVELS\",\n                               pszAlignedLevels, 0, nullptr, \"TILING_SCHEME\");\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write information about some codecs.                            */\n    /* -------------------------------------------------------------------- */\n    if (CPLTestBool(\n            CPLGetConfigOption(\"GTIFF_WRITE_IMAGE_STRUCTURE_METADATA\", \"YES\")))\n    {\n        const char *pszCompress =\n            CSLFetchNameValue(papszCreationOptions, \"COMPRESS\");\n        if (pszCompress && EQUAL(pszCompress, \"WEBP\"))\n        {\n            if (GTiffGetWebPLossless(papszCreationOptions))\n            {\n                AppendMetadataItem(&psRoot, &psTail,\n                                   \"COMPRESSION_REVERSIBILITY\", \"LOSSLESS\", 0,\n                                   nullptr, \"IMAGE_STRUCTURE\");\n            }\n            else\n            {\n                AppendMetadataItem(\n                    &psRoot, &psTail, \"WEBP_LEVEL\",\n                    CPLSPrintf(\"%d\", GTiffGetWebPLevel(papszCreationOptions)),\n                    0, nullptr, \"IMAGE_STRUCTURE\");\n            }\n        }\n        else if (pszCompress && STARTS_WITH_CI(pszCompress, \"LERC\"))\n        {\n            const double dfMaxZError =\n                GTiffGetLERCMaxZError(papszCreationOptions);\n            const double dfMaxZErrorOverview =\n                GTiffGetLERCMaxZErrorOverview(papszCreationOptions);\n            if (dfMaxZError == 0.0 && dfMaxZErrorOverview == 0.0)\n            {\n                AppendMetadataItem(&psRoot, &psTail,\n                                   \"COMPRESSION_REVERSIBILITY\", \"LOSSLESS\", 0,\n                                   nullptr, \"IMAGE_STRUCTURE\");\n            }\n            else\n            {\n                AppendMetadataItem(&psRoot, &psTail, \"MAX_Z_ERROR\",\n                                   CSLFetchNameValueDef(papszCreationOptions,\n                                                        \"MAX_Z_ERROR\", \"\"),\n                                   0, nullptr, \"IMAGE_STRUCTURE\");\n                if (dfMaxZError != dfMaxZErrorOverview)\n                {\n                    AppendMetadataItem(\n                        &psRoot, &psTail, \"MAX_Z_ERROR_OVERVIEW\",\n                        CSLFetchNameValueDef(papszCreationOptions,\n                                             \"MAX_Z_ERROR_OVERVIEW\", \"\"),\n                        0, nullptr, \"IMAGE_STRUCTURE\");\n                }\n            }\n        }\n#if HAVE_JXL\n        else if (pszCompress && EQUAL(pszCompress, \"JXL\"))\n        {\n            float fDistance = 0.0f;\n            if (GTiffGetJXLLossless(papszCreationOptions))\n            {\n                AppendMetadataItem(&psRoot, &psTail,\n                                   \"COMPRESSION_REVERSIBILITY\", \"LOSSLESS\", 0,\n                                   nullptr, \"IMAGE_STRUCTURE\");\n            }\n            else\n            {\n                fDistance = GTiffGetJXLDistance(papszCreationOptions);\n                AppendMetadataItem(&psRoot, &psTail, \"JXL_DISTANCE\",\n                                   CPLSPrintf(\"%f\", fDistance), 0, nullptr,\n                                   \"IMAGE_STRUCTURE\");\n            }\n            const float fAlphaDistance =\n                GTiffGetJXLAlphaDistance(papszCreationOptions);\n            if (fAlphaDistance >= 0.0f && fAlphaDistance != fDistance)\n            {\n                AppendMetadataItem(&psRoot, &psTail, \"JXL_ALPHA_DISTANCE\",\n                                   CPLSPrintf(\"%f\", fAlphaDistance), 0, nullptr,\n                                   \"IMAGE_STRUCTURE\");\n            }\n            AppendMetadataItem(\n                &psRoot, &psTail, \"JXL_EFFORT\",\n                CPLSPrintf(\"%d\", GTiffGetJXLEffort(papszCreationOptions)), 0,\n                nullptr, \"IMAGE_STRUCTURE\");\n        }\n#endif\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write out the generic XML metadata if there is any.             */\n    /* -------------------------------------------------------------------- */\n    if (psRoot != nullptr)\n    {\n        bool bRet = true;\n\n        if (eProfile == GTiffProfile::GDALGEOTIFF)\n        {\n            char *pszXML_MD = CPLSerializeXMLTree(psRoot);\n            TIFFSetField(l_hTIFF, TIFFTAG_GDAL_METADATA, pszXML_MD);\n            CPLFree(pszXML_MD);\n        }\n        else\n        {\n            if (bSrcIsGeoTIFF)\n                cpl::down_cast<GTiffDataset *>(poSrcDS)->PushMetadataToPam();\n            else\n                bRet = false;\n        }\n\n        CPLDestroyXMLNode(psRoot);\n\n        return bRet;\n    }\n\n    // If we have no more metadata but it existed before,\n    // remove the GDAL_METADATA tag.\n    if (eProfile == GTiffProfile::GDALGEOTIFF)\n    {\n        char *pszText = nullptr;\n        if (TIFFGetField(l_hTIFF, TIFFTAG_GDAL_METADATA, &pszText))\n        {\n            TIFFUnsetField(l_hTIFF, TIFFTAG_GDAL_METADATA);\n        }\n    }\n\n    return true;\n}",
    "int GTiffDataset::GuessJPEGQuality(bool &bOutHasQuantizationTable,\n                                   bool &bOutHasHuffmanTable)\n{\n    CPLAssert(m_nCompression == COMPRESSION_JPEG);\n    uint32_t nJPEGTableSize = 0;\n    void *pJPEGTable = nullptr;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize,\n                      &pJPEGTable))\n    {\n        bOutHasQuantizationTable = false;\n        bOutHasHuffmanTable = false;\n        return -1;\n    }\n\n    bOutHasQuantizationTable =\n        GTIFFFindNextTable(static_cast<const GByte *>(pJPEGTable),\n                           MARKER_QUANT_TABLE, nJPEGTableSize,\n                           nullptr) != nullptr;\n    bOutHasHuffmanTable =\n        GTIFFFindNextTable(static_cast<const GByte *>(pJPEGTable),\n                           MARKER_HUFFMAN_TABLE, nJPEGTableSize,\n                           nullptr) != nullptr;\n    if (!bOutHasQuantizationTable)\n        return -1;\n\n    if ((nBands == 1 && m_nBitsPerSample == 8) ||\n        (nBands == 3 && m_nBitsPerSample == 8 &&\n         m_nPhotometric == PHOTOMETRIC_RGB) ||\n        (nBands == 4 && m_nBitsPerSample == 8 &&\n         m_nPhotometric == PHOTOMETRIC_SEPARATED))\n    {\n        return GuessJPEGQualityFromMD5(md5JPEGQuantTable_generic_8bit,\n                                       static_cast<const GByte *>(pJPEGTable),\n                                       static_cast<int>(nJPEGTableSize));\n    }\n\n    if (nBands == 3 && m_nBitsPerSample == 8 &&\n        m_nPhotometric == PHOTOMETRIC_YCBCR)\n    {\n        int nRet =\n            GuessJPEGQualityFromMD5(md5JPEGQuantTable_3_YCBCR_8bit,\n                                    static_cast<const GByte *>(pJPEGTable),\n                                    static_cast<int>(nJPEGTableSize));\n        if (nRet < 0)\n        {\n            // libjpeg 9e has modified the YCbCr quantization tables.\n            nRet =\n                GuessJPEGQualityFromMD5(md5JPEGQuantTable_3_YCBCR_8bit_jpeg9e,\n                                        static_cast<const GByte *>(pJPEGTable),\n                                        static_cast<int>(nJPEGTableSize));\n        }\n        return nRet;\n    }\n\n    char **papszLocalParameters = nullptr;\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"COMPRESS\", \"JPEG\");\n    if (m_nPhotometric == PHOTOMETRIC_YCBCR)\n        papszLocalParameters =\n            CSLSetNameValue(papszLocalParameters, \"PHOTOMETRIC\", \"YCBCR\");\n    else if (m_nPhotometric == PHOTOMETRIC_SEPARATED)\n        papszLocalParameters =\n            CSLSetNameValue(papszLocalParameters, \"PHOTOMETRIC\", \"CMYK\");\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"BLOCKYSIZE\", \"16\");\n    if (m_nBitsPerSample == 12)\n        papszLocalParameters =\n            CSLSetNameValue(papszLocalParameters, \"NBITS\", \"12\");\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf(\"/vsimem/gtiffdataset_guess_jpeg_quality_tmp_%p\",\n                           this);\n\n    int nRet = -1;\n    for (int nQuality = 0; nQuality <= 100 && nRet < 0; ++nQuality)\n    {\n        VSILFILE *fpTmp = nullptr;\n        if (nQuality == 0)\n            papszLocalParameters =\n                CSLSetNameValue(papszLocalParameters, \"JPEG_QUALITY\", \"75\");\n        else\n            papszLocalParameters =\n                CSLSetNameValue(papszLocalParameters, \"JPEG_QUALITY\",\n                                CPLSPrintf(\"%d\", nQuality));\n\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        CPLString osTmp;\n        TIFF *hTIFFTmp =\n            CreateLL(osTmpFilenameIn, 16, 16, (nBands <= 4) ? nBands : 1,\n                     GetRasterBand(1)->GetRasterDataType(), 0.0,\n                     papszLocalParameters, &fpTmp, osTmp);\n        CPLPopErrorHandler();\n        if (!hTIFFTmp)\n        {\n            break;\n        }\n\n        TIFFWriteCheck(hTIFFTmp, FALSE, \"CreateLL\");\n        TIFFWriteDirectory(hTIFFTmp);\n        TIFFSetDirectory(hTIFFTmp, 0);\n        // Now reset jpegcolormode.\n        if (m_nPhotometric == PHOTOMETRIC_YCBCR &&\n            CPLTestBool(CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\")))\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n\n        GByte abyZeroData[(16 * 16 * 4 * 3) / 2] = {};\n        const int nBlockSize =\n            (16 * 16 * ((nBands <= 4) ? nBands : 1) * m_nBitsPerSample) / 8;\n        TIFFWriteEncodedStrip(hTIFFTmp, 0, abyZeroData, nBlockSize);\n\n        uint32_t nJPEGTableSizeTry = 0;\n        void *pJPEGTableTry = nullptr;\n        if (TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSizeTry,\n                         &pJPEGTableTry))\n        {\n            if (GTIFFQuantizationTablesEqual(\n                    static_cast<GByte *>(pJPEGTable), nJPEGTableSize,\n                    static_cast<GByte *>(pJPEGTableTry), nJPEGTableSizeTry))\n            {\n                nRet = (nQuality == 0) ? 75 : nQuality;\n            }\n        }\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n\n    CSLDestroy(papszLocalParameters);\n    VSIUnlink(osTmpFilenameIn);\n\n    return nRet;\n}",
    "GDALDataset *GTiffDataset::Create(const char *pszFilename, int nXSize,\n                                  int nYSize, int l_nBands, GDALDataType eType,\n                                  char **papszParamList)\n\n{\n    VSILFILE *l_fpL = nullptr;\n    CPLString l_osTmpFilename;\n\n    /* -------------------------------------------------------------------- */\n    /*      Create the underlying TIFF file.                                */\n    /* -------------------------------------------------------------------- */\n    TIFF *l_hTIFF = CreateLL(pszFilename, nXSize, nYSize, l_nBands, eType, 0,\n                             papszParamList, &l_fpL, l_osTmpFilename);\n    const bool bStreaming = !l_osTmpFilename.empty();\n\n    if (l_hTIFF == nullptr)\n        return nullptr;\n\n    /* -------------------------------------------------------------------- */\n    /*      Create the new GTiffDataset object.                             */\n    /* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->m_hTIFF = l_hTIFF;\n    poDS->m_fpL = l_fpL;\n    if (bStreaming)\n    {\n        poDS->m_bStreamingOut = true;\n        poDS->m_pszTmpFilename = CPLStrdup(l_osTmpFilename);\n        poDS->m_fpToWrite = VSIFOpenL(pszFilename, \"wb\");\n        if (poDS->m_fpToWrite == nullptr)\n        {\n            VSIUnlink(l_osTmpFilename);\n            delete poDS;\n            return nullptr;\n        }\n    }\n    poDS->nRasterXSize = nXSize;\n    poDS->nRasterYSize = nYSize;\n    poDS->eAccess = GA_Update;\n    poDS->m_bCrystalized = false;\n    poDS->m_nSamplesPerPixel = static_cast<uint16_t>(l_nBands);\n    poDS->m_pszFilename = CPLStrdup(pszFilename);\n\n    // Don't try to load external metadata files (#6597).\n    poDS->m_bIMDRPCMetadataLoaded = true;\n\n    // Avoid premature crystalization that will cause directory re-writing if\n    // GetProjectionRef() or GetGeoTransform() are called on the newly created\n    // GeoTIFF.\n    poDS->m_bLookedForProjection = true;\n\n    TIFFGetField(l_hTIFF, TIFFTAG_SAMPLEFORMAT, &(poDS->m_nSampleFormat));\n    TIFFGetField(l_hTIFF, TIFFTAG_PLANARCONFIG, &(poDS->m_nPlanarConfig));\n    // Weird that we need this, but otherwise we get a Valgrind warning on\n    // tiff_write_124.\n    if (!TIFFGetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, &(poDS->m_nPhotometric)))\n        poDS->m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n    TIFFGetField(l_hTIFF, TIFFTAG_BITSPERSAMPLE, &(poDS->m_nBitsPerSample));\n    TIFFGetField(l_hTIFF, TIFFTAG_COMPRESSION, &(poDS->m_nCompression));\n\n    if (TIFFIsTiled(l_hTIFF))\n    {\n        TIFFGetField(l_hTIFF, TIFFTAG_TILEWIDTH, &(poDS->m_nBlockXSize));\n        TIFFGetField(l_hTIFF, TIFFTAG_TILELENGTH, &(poDS->m_nBlockYSize));\n    }\n    else\n    {\n        if (!TIFFGetField(l_hTIFF, TIFFTAG_ROWSPERSTRIP,\n                          &(poDS->m_nRowsPerStrip)))\n            poDS->m_nRowsPerStrip = 1;  // Dummy value.\n\n        poDS->m_nBlockXSize = nXSize;\n        poDS->m_nBlockYSize =\n            std::min(static_cast<int>(poDS->m_nRowsPerStrip), nYSize);\n    }\n\n    if (!poDS->ComputeBlocksPerColRowAndBand(l_nBands))\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    poDS->m_eProfile = GetProfile(CSLFetchNameValue(papszParamList, \"PROFILE\"));\n\n    /* -------------------------------------------------------------------- */\n    /*      YCbCr JPEG compressed images should be translated on the fly    */\n    /*      to RGB by libtiff/libjpeg unless specifically requested         */\n    /*      otherwise.                                                      */\n    /* -------------------------------------------------------------------- */\n    if (poDS->m_nCompression == COMPRESSION_JPEG &&\n        poDS->m_nPhotometric == PHOTOMETRIC_YCBCR &&\n        CPLTestBool(CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\")))\n    {\n        int nColorMode = 0;\n\n        poDS->SetMetadataItem(\"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\");\n        if (!TIFFGetField(l_hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode) ||\n            nColorMode != JPEGCOLORMODE_RGB)\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n    if (poDS->m_nCompression == COMPRESSION_LERC)\n    {\n        uint32_t nLercParamCount = 0;\n        uint32_t *panLercParams = nullptr;\n        if (TIFFGetField(l_hTIFF, TIFFTAG_LERC_PARAMETERS, &nLercParamCount,\n                         &panLercParams) &&\n            nLercParamCount == 2)\n        {\n            memcpy(poDS->m_anLercAddCompressionAndVersion, panLercParams,\n                   sizeof(poDS->m_anLercAddCompressionAndVersion));\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Read palette back as a color table if it has one.               */\n    /* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if (poDS->m_nPhotometric == PHOTOMETRIC_PALETTE &&\n        TIFFGetField(l_hTIFF, TIFFTAG_COLORMAP, &panRed, &panGreen, &panBlue))\n    {\n\n        poDS->m_poColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 << poDS->m_nBitsPerSample;\n\n        for (int iColor = nColorCount - 1; iColor >= 0; iColor--)\n        {\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast<short>(panRed[iColor] / divisor),\n                static_cast<short>(panGreen[iColor] / divisor),\n                static_cast<short>(panBlue[iColor] / divisor),\n                static_cast<short>(255)};\n\n            poDS->m_poColorTable->SetColorEntry(iColor, &oEntry);\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Do we want to ensure all blocks get written out on close to     */\n    /*      avoid sparse files?                                             */\n    /* -------------------------------------------------------------------- */\n    if (!CPLFetchBool(papszParamList, \"SPARSE_OK\", false))\n        poDS->m_bFillEmptyTilesAtClosing = true;\n\n    poDS->m_bWriteEmptyTiles =\n        bStreaming || (poDS->m_nCompression != COMPRESSION_NONE &&\n                       poDS->m_bFillEmptyTilesAtClosing);\n    // Only required for people writing non-compressed striped files in the\n    // right order and wanting all tstrips to be written in the same order\n    // so that the end result can be memory mapped without knowledge of each\n    // strip offset.\n    if (CPLTestBool(CSLFetchNameValueDef(\n            papszParamList, \"WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\")) ||\n        CPLTestBool(CSLFetchNameValueDef(\n            papszParamList, \"@WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\")))\n    {\n        poDS->m_bWriteEmptyTiles = true;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Preserve creation options for consulting later (for instance    */\n    /*      to decide if a TFW file should be written).                     */\n    /* -------------------------------------------------------------------- */\n    poDS->m_papszCreationOptions = CSLDuplicate(papszParamList);\n\n    poDS->m_nZLevel = GTiffGetZLevel(papszParamList);\n    poDS->m_nLZMAPreset = GTiffGetLZMAPreset(papszParamList);\n    poDS->m_nZSTDLevel = GTiffGetZSTDPreset(papszParamList);\n    poDS->m_nWebPLevel = GTiffGetWebPLevel(papszParamList);\n    poDS->m_bWebPLossless = GTiffGetWebPLossless(papszParamList);\n    if (poDS->m_nWebPLevel != 100 && poDS->m_bWebPLossless &&\n        CSLFetchNameValue(papszParamList, \"WEBP_LEVEL\"))\n    {\n        CPLError(CE_Warning, CPLE_AppDefined,\n                 \"WEBP_LEVEL is specified, but WEBP_LOSSLESS=YES. \"\n                 \"WEBP_LEVEL will be ignored.\");\n    }\n    poDS->m_nJpegQuality = GTiffGetJpegQuality(papszParamList);\n    poDS->m_nJpegTablesMode = GTiffGetJpegTablesMode(papszParamList);\n    poDS->m_dfMaxZError = GTiffGetLERCMaxZError(papszParamList);\n    poDS->m_dfMaxZErrorOverview = GTiffGetLERCMaxZErrorOverview(papszParamList);\n#if HAVE_JXL\n    poDS->m_bJXLLossless = GTiffGetJXLLossless(papszParamList);\n    poDS->m_nJXLEffort = GTiffGetJXLEffort(papszParamList);\n    poDS->m_fJXLDistance = GTiffGetJXLDistance(papszParamList);\n    poDS->m_fJXLAlphaDistance = GTiffGetJXLAlphaDistance(papszParamList);\n#endif\n    poDS->InitCreationOrOpenOptions(true, papszParamList);\n\n    /* -------------------------------------------------------------------- */\n    /*      Create band information objects.                                */\n    /* -------------------------------------------------------------------- */\n    for (int iBand = 0; iBand < l_nBands; ++iBand)\n    {\n        if (poDS->m_nBitsPerSample == 8 ||\n            (poDS->m_nBitsPerSample == 16 && eType != GDT_Float32) ||\n            poDS->m_nBitsPerSample == 32 || poDS->m_nBitsPerSample == 64 ||\n            poDS->m_nBitsPerSample == 128)\n        {\n            poDS->SetBand(iBand + 1, new GTiffRasterBand(poDS, iBand + 1));\n        }\n        else\n        {\n            poDS->SetBand(iBand + 1, new GTiffOddBitsBand(poDS, iBand + 1));\n            poDS->GetRasterBand(iBand + 1)->SetMetadataItem(\n                \"NBITS\", CPLString().Printf(\"%d\", poDS->m_nBitsPerSample),\n                \"IMAGE_STRUCTURE\");\n        }\n    }\n\n    poDS->GetDiscardLsbOption(papszParamList);\n\n    if (poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG && l_nBands != 1)\n        poDS->SetMetadataItem(\"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\");\n    else\n        poDS->SetMetadataItem(\"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\");\n\n    poDS->oOvManager.Initialize(poDS, pszFilename);\n\n    return poDS;\n}"
]