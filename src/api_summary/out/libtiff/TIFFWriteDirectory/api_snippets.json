[
    "toff_t GTIFFWriteDirectory( TIFF *hTIFF, int nSubfileType,\n                            int nXSize, int nYSize,\n                            int nBitsPerPixel, int nPlanarConfig, int nSamples,\n                            int nBlockXSize, int nBlockYSize,\n                            int bTiled, int nCompressFlag, int nPhotometric,\n                            int nSampleFormat,\n                            int nPredictor,\n                            unsigned short *panRed,\n                            unsigned short *panGreen,\n                            unsigned short *panBlue,\n                            int nExtraSamples,\n                            unsigned short *panExtraSampleValues,\n                            const char *pszMetadata,\n                            const char* pszJPEGQuality,\n                            const char* pszJPEGTablesMode,\n                            const char* pszNoData,\n                            CPL_UNUSED const uint32* panLercAddCompressionAndVersion\n                           )\n\n{\n    const toff_t nBaseDirOffset = TIFFCurrentDirOffset( hTIFF );\n\n    // This is a bit of a hack to cause (*tif->tif_cleanup)(tif); to be called.\n    // See https://trac.osgeo.org/gdal/ticket/2055\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, COMPRESSION_NONE );\n\n#if defined(TIFFLIB_VERSION) && TIFFLIB_VERSION >= 20051201  // 3.8.0\n    TIFFFreeDirectory( hTIFF );\n#endif\n\n    TIFFCreateDirectory( hTIFF );\n\n/* -------------------------------------------------------------------- */\n/*      Setup TIFF fields.                                              */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, nXSize );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, nYSize );\n    if( nSamples == 1 )\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n    else\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, nPlanarConfig );\n\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, nBitsPerPixel );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, nSamples );\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, nCompressFlag );\n    TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, nPhotometric );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT, nSampleFormat );\n\n    if( bTiled )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_TILEWIDTH, nBlockXSize );\n        TIFFSetField( hTIFF, TIFFTAG_TILELENGTH, nBlockYSize );\n    }\n    else\n    {\n        TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, nBlockYSize );\n    }\n\n    TIFFSetField( hTIFF, TIFFTAG_SUBFILETYPE, nSubfileType );\n\n    if( panExtraSampleValues != nullptr )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_EXTRASAMPLES, nExtraSamples,\n                      panExtraSampleValues );\n    }\n\n    if( nCompressFlag == COMPRESSION_LZW ||\n        nCompressFlag == COMPRESSION_ADOBE_DEFLATE ||\n        nCompressFlag == COMPRESSION_ZSTD )\n        TIFFSetField( hTIFF, TIFFTAG_PREDICTOR, nPredictor );\n\n/* -------------------------------------------------------------------- */\n/*      Write color table if one is present.                            */\n/* -------------------------------------------------------------------- */\n    if( panRed != nullptr )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panRed, panGreen, panBlue );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write metadata if we have some.                                 */\n/* -------------------------------------------------------------------- */\n    if( pszMetadata && strlen(pszMetadata) > 0 )\n        TIFFSetField( hTIFF, TIFFTAG_GDAL_METADATA, pszMetadata );\n\n\n/* -------------------------------------------------------------------- */\n/*      Write JPEG tables if needed.                                    */\n/* -------------------------------------------------------------------- */\n    if( nCompressFlag == COMPRESSION_JPEG )\n    {\n        GTiffWriteJPEGTables( hTIFF,\n                              (nPhotometric == PHOTOMETRIC_RGB) ? \"RGB\" :\n                              (nPhotometric == PHOTOMETRIC_YCBCR) ? \"YCBCR\" :\n                                                                \"MINISBLACK\",\n                              pszJPEGQuality,\n                              pszJPEGTablesMode );\n\n        if( nPhotometric == PHOTOMETRIC_YCBCR )\n        {\n            // Explicitly register the subsampling so that JPEGFixupTags\n            // is a no-op (helps for cloud optimized geotiffs)\n            TIFFSetField( hTIFF, TIFFTAG_YCBCRSUBSAMPLING, 2, 2 );\n        }\n    }\n\n#ifdef HAVE_LERC\n    if( nCompressFlag == COMPRESSION_LERC && panLercAddCompressionAndVersion )\n    {\n        TIFFSetField(hTIFF, TIFFTAG_LERC_PARAMETERS, 2,\n                     panLercAddCompressionAndVersion);\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Write no data value if we have one.                             */\n/* -------------------------------------------------------------------- */\n    if( pszNoData != nullptr )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_GDAL_NODATA, pszNoData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write directory, and return byte offset.                        */\n/* -------------------------------------------------------------------- */\n    if( TIFFWriteCheck( hTIFF, bTiled, \"GTIFFWriteDirectory\" ) == 0 )\n    {\n        TIFFSetSubDirectory( hTIFF, nBaseDirOffset );\n        return 0;\n    }\n\n    TIFFWriteDirectory( hTIFF );\n    TIFFSetDirectory( hTIFF,\n                      static_cast<tdir_t>(TIFFNumberOfDirectories(hTIFF) - 1) );\n\n    const toff_t nOffset = TIFFCurrentDirOffset( hTIFF );\n\n    TIFFSetSubDirectory( hTIFF, nBaseDirOffset );\n\n    return nOffset;\n}",
    "toff_t GTIFFWriteDirectory( TIFF *hTIFF, int nSubfileType,\n                            int nXSize, int nYSize,\n                            int nBitsPerPixel, int nPlanarConfig, int nSamples,\n                            int nBlockXSize, int nBlockYSize,\n                            int bTiled, int nCompressFlag, int nPhotometric,\n                            int nSampleFormat,\n                            int nPredictor,\n                            unsigned short *panRed,\n                            unsigned short *panGreen,\n                            unsigned short *panBlue,\n                            int nExtraSamples,\n                            unsigned short *panExtraSampleValues,\n                            const char *pszMetadata,\n                            const char* pszJPEGQuality,\n                            const char* pszJPEGTablesMode,\n                            const char* pszNoData,\n                            CPL_UNUSED const uint32* panLercAddCompressionAndVersion,\n                            bool bDeferStrileArrayWriting,\n                            const char *pszWebpLevel)\n\n{\n    const toff_t nBaseDirOffset = TIFFCurrentDirOffset( hTIFF );\n\n    // This is a bit of a hack to cause (*tif->tif_cleanup)(tif); to be called.\n    // See https://trac.osgeo.org/gdal/ticket/2055\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, COMPRESSION_NONE );\n    TIFFFreeDirectory( hTIFF );\n\n    TIFFCreateDirectory( hTIFF );\n\n/* -------------------------------------------------------------------- */\n/*      Setup TIFF fields.                                              */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, nXSize );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, nYSize );\n    if( nSamples == 1 )\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n    else\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, nPlanarConfig );\n\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, nBitsPerPixel );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, nSamples );\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, nCompressFlag );\n    TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, nPhotometric );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT, nSampleFormat );\n\n    if( bTiled )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_TILEWIDTH, nBlockXSize );\n        TIFFSetField( hTIFF, TIFFTAG_TILELENGTH, nBlockYSize );\n    }\n    else\n    {\n        TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, nBlockYSize );\n    }\n\n    TIFFSetField( hTIFF, TIFFTAG_SUBFILETYPE, nSubfileType );\n\n    if( panExtraSampleValues != nullptr )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_EXTRASAMPLES, nExtraSamples,\n                      panExtraSampleValues );\n    }\n\n    if( nCompressFlag == COMPRESSION_LZW ||\n        nCompressFlag == COMPRESSION_ADOBE_DEFLATE ||\n        nCompressFlag == COMPRESSION_ZSTD )\n        TIFFSetField( hTIFF, TIFFTAG_PREDICTOR, nPredictor );\n\n/* -------------------------------------------------------------------- */\n/*      Write color table if one is present.                            */\n/* -------------------------------------------------------------------- */\n    if( panRed != nullptr )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panRed, panGreen, panBlue );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write metadata if we have some.                                 */\n/* -------------------------------------------------------------------- */\n    if( pszMetadata && strlen(pszMetadata) > 0 )\n        TIFFSetField( hTIFF, TIFFTAG_GDAL_METADATA, pszMetadata );\n\n\n/* -------------------------------------------------------------------- */\n/*      Write JPEG tables if needed.                                    */\n/* -------------------------------------------------------------------- */\n    if( nCompressFlag == COMPRESSION_JPEG )\n    {\n        GTiffWriteJPEGTables( hTIFF,\n                              (nPhotometric == PHOTOMETRIC_RGB) ? \"RGB\" :\n                              (nPhotometric == PHOTOMETRIC_YCBCR) ? \"YCBCR\" :\n                                                                \"MINISBLACK\",\n                              pszJPEGQuality,\n                              pszJPEGTablesMode );\n\n        if( nPhotometric == PHOTOMETRIC_YCBCR )\n        {\n            // Explicitly register the subsampling so that JPEGFixupTags\n            // is a no-op (helps for cloud optimized geotiffs)\n            TIFFSetField( hTIFF, TIFFTAG_YCBCRSUBSAMPLING, 2, 2 );\n        }\n    }\n\n    if (nCompressFlag == COMPRESSION_WEBP  && pszWebpLevel != nullptr)\n    {\n        const int nWebpLevel = atoi(pszWebpLevel);\n        if ( nWebpLevel >= 1 )\n            TIFFSetField( hTIFF, TIFFTAG_WEBP_LEVEL, nWebpLevel );\n    }\n\n#ifdef HAVE_LERC\n    if( nCompressFlag == COMPRESSION_LERC && panLercAddCompressionAndVersion )\n    {\n        TIFFSetField(hTIFF, TIFFTAG_LERC_PARAMETERS, 2,\n                     panLercAddCompressionAndVersion);\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Write no data value if we have one.                             */\n/* -------------------------------------------------------------------- */\n    if( pszNoData != nullptr )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_GDAL_NODATA, pszNoData );\n    }\n\n    if( bDeferStrileArrayWriting )\n    {\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n        TIFFDeferStrileArrayWriting( hTIFF );\n#endif\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write directory, and return byte offset.                        */\n/* -------------------------------------------------------------------- */\n    if( TIFFWriteCheck( hTIFF, bTiled, \"GTIFFWriteDirectory\" ) == 0 )\n    {\n        TIFFSetSubDirectory( hTIFF, nBaseDirOffset );\n        return 0;\n    }\n\n    TIFFWriteDirectory( hTIFF );\n    TIFFSetDirectory( hTIFF,\n                      static_cast<tdir_t>(TIFFNumberOfDirectories(hTIFF) - 1) );\n\n    const toff_t nOffset = TIFFCurrentDirOffset( hTIFF );\n\n    TIFFSetSubDirectory( hTIFF, nBaseDirOffset );\n\n    return nOffset;\n}",
    "CPL_C_END\n\n/************************************************************************/\n/*                         GTIFFWriteDirectory()                        */\n/*                                                                      */\n/*      Create a new directory, without any image data for an overview  */\n/*      or a mask                                                       */\n/*      Returns offset of newly created directory, but the              */\n/*      current directory is reset to be the one in used when this      */\n/*      function is called.                                             */\n/************************************************************************/\n\ntoff_t GTIFFWriteDirectory(TIFF *hTIFF, int nSubfileType, int nXSize, int nYSize,\n                           int nBitsPerPixel, int nPlanarConfig, int nSamples, \n                           int nBlockXSize, int nBlockYSize,\n                           int bTiled, int nCompressFlag, int nPhotometric,\n                           int nSampleFormat, \n                           unsigned short *panRed,\n                           unsigned short *panGreen,\n                           unsigned short *panBlue,\n                           int nExtraSamples,\n                           unsigned short *panExtraSampleValues,\n                           const char *pszMetadata )\n\n{\n    toff_t\tnBaseDirOffset;\n    toff_t\tnOffset;\n\n    nBaseDirOffset = TIFFCurrentDirOffset( hTIFF );\n\n#if defined(TIFFLIB_VERSION) && TIFFLIB_VERSION >= 20051201 /* 3.8.0 */\n    TIFFFreeDirectory( hTIFF );\n#endif\n\n    TIFFCreateDirectory( hTIFF );\n    \n/* -------------------------------------------------------------------- */\n/*      Setup TIFF fields.                                              */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, nXSize );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, nYSize );\n    if( nSamples == 1 )\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n    else\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, nPlanarConfig );\n\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, nBitsPerPixel );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, nSamples );\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, nCompressFlag );\n    TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, nPhotometric );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT, nSampleFormat );\n\n    if( bTiled )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_TILEWIDTH, nBlockXSize );\n        TIFFSetField( hTIFF, TIFFTAG_TILELENGTH, nBlockYSize );\n    }\n    else\n        TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, nBlockYSize );\n\n    TIFFSetField( hTIFF, TIFFTAG_SUBFILETYPE, nSubfileType );\n\n    if (panExtraSampleValues != NULL)\n    {\n        TIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, nExtraSamples, panExtraSampleValues );\n    }\n    \n/* -------------------------------------------------------------------- */\n/*\tWrite color table if one is present.\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    if( panRed != NULL )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panRed, panGreen, panBlue );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write metadata if we have some.                                 */\n/* -------------------------------------------------------------------- */\n    if( pszMetadata && strlen(pszMetadata) > 0 )\n        TIFFSetField( hTIFF, TIFFTAG_GDAL_METADATA, pszMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Write directory, and return byte offset.                        */\n/* -------------------------------------------------------------------- */\n    if( TIFFWriteCheck( hTIFF, bTiled, \"GTIFFWriteDirectory\" ) == 0 )\n    {\n        TIFFSetSubDirectory( hTIFF, nBaseDirOffset );\n        return 0;\n    }\n\n    TIFFWriteDirectory( hTIFF );\n    TIFFSetDirectory( hTIFF, (tdir_t) (TIFFNumberOfDirectories(hTIFF)-1) );\n\n    nOffset = TIFFCurrentDirOffset( hTIFF );\n\n    TIFFSetSubDirectory( hTIFF, nBaseDirOffset );\n\n    return nOffset;\n}",
    "int DNGWriter::write(const char *filename, const Camera *camera,\n\t\t     const StreamConfiguration &config,\n\t\t     const ControlList &metadata,\n\t\t     [[maybe_unused]] const FrameBuffer *buffer,\n\t\t     const void *data)\n{\n\tconst ControlList &cameraProperties = camera->properties();\n\n\tconst auto it = formatInfo.find(config.pixelFormat);\n\tif (it == formatInfo.cend()) {\n\t\tstd::cerr << \"Unsupported pixel format\" << std::endl;\n\t\treturn -EINVAL;\n\t}\n\tconst FormatInfo *info = &it->second;\n\n\tTIFF *tif = TIFFOpen(filename, \"w\");\n\tif (!tif) {\n\t\tstd::cerr << \"Failed to open tiff file\" << std::endl;\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Scanline buffer, has to be large enough to store both a RAW scanline\n\t * or a thumbnail scanline. The latter will always be much smaller than\n\t * the former as we downscale by 16 in both directions.\n\t */\n\tstd::vector<uint8_t> scanline((config.size.width * info->bitsPerSample + 7) / 8);\n\n\ttoff_t rawIFDOffset = 0;\n\ttoff_t exifIFDOffset = 0;\n\n\t/*\n\t * Start with a thumbnail in IFD 0 for compatibility with TIFF baseline\n\t * readers, as required by the TIFF/EP specification. Tags that apply to\n\t * the whole file are stored here.\n\t */\n\tconst uint8_t version[] = { 1, 2, 0, 0 };\n\n\tTIFFSetField(tif, TIFFTAG_DNGVERSION, version);\n\tTIFFSetField(tif, TIFFTAG_DNGBACKWARDVERSION, version);\n\tTIFFSetField(tif, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\tTIFFSetField(tif, TIFFTAG_MAKE, \"libcamera\");\n\n\tconst auto &model = cameraProperties.get(properties::Model);\n\tif (model) {\n\t\tTIFFSetField(tif, TIFFTAG_MODEL, model->c_str());\n\t\t/* \\todo set TIFFTAG_UNIQUECAMERAMODEL. */\n\t}\n\n\tTIFFSetField(tif, TIFFTAG_SOFTWARE, \"qcam\");\n\tTIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n\t/*\n\t * Thumbnail-specific tags. The thumbnail is stored as an RGB image\n\t * with 1/16 of the raw image resolution. Greyscale would save space,\n\t * but doesn't seem well supported by RawTherapee.\n\t */\n\tTIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE);\n\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, config.size.width / 16);\n\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, config.size.height / 16);\n\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\n\t/*\n\t * Fill in some reasonable colour information in the DNG. We supply\n\t * the \"neutral\" colour values which determine the white balance, and the\n\t * \"ColorMatrix1\" which converts XYZ to (un-white-balanced) camera RGB.\n\t * Note that this is not a \"proper\" colour calibration for the DNG,\n\t * nonetheless, many tools should be able to render the colours better.\n\t */\n\tfloat neutral[3] = { 1, 1, 1 };\n\tMatrix3d wbGain = Matrix3d::identity();\n\t/* From http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html */\n\tconst Matrix3d rgb2xyz(0.4124564, 0.3575761, 0.1804375,\n\t\t\t       0.2126729, 0.7151522, 0.0721750,\n\t\t\t       0.0193339, 0.1191920, 0.9503041);\n\tMatrix3d ccm = Matrix3d::identity();\n\t/*\n\t * Pick a reasonable number eps to protect against singularities. It\n\t * should be comfortably larger than the point at which we run into\n\t * numerical trouble, yet smaller than any plausible gain that we might\n\t * apply to a colour, either explicitly or as part of the colour matrix.\n\t */\n\tconst double eps = 1e-2;\n\n\tconst auto &colourGains = metadata.get(controls::ColourGains);\n\tif (colourGains) {\n\t\tif ((*colourGains)[0] > eps && (*colourGains)[1] > eps) {\n\t\t\twbGain = Matrix3d::diag((*colourGains)[0], 1, (*colourGains)[1]);\n\t\t\tneutral[0] = 1.0 / (*colourGains)[0]; /* red */\n\t\t\tneutral[2] = 1.0 / (*colourGains)[1]; /* blue */\n\t\t}\n\t}\n\n\tconst auto &ccmControl = metadata.get(controls::ColourCorrectionMatrix);\n\tif (ccmControl) {\n\t\tMatrix3d ccmSupplied(*ccmControl);\n\t\tif (ccmSupplied.determinant() > eps)\n\t\t\tccm = ccmSupplied;\n\t}\n\n\t/*\n\t * rgb2xyz is known to be invertible, and we've ensured above that both\n\t * the ccm and wbGain matrices are non-singular, so the product of all\n\t * three is guaranteed to be invertible too.\n\t */\n\tMatrix3d colorMatrix1 = (rgb2xyz * ccm * wbGain).inverse();\n\n\tTIFFSetField(tif, TIFFTAG_COLORMATRIX1, 9, colorMatrix1.m);\n\tTIFFSetField(tif, TIFFTAG_ASSHOTNEUTRAL, 3, neutral);\n\n\t/*\n\t * Reserve space for the SubIFD and ExifIFD tags, pointing to the IFD\n\t * for the raw image and EXIF data respectively. The real offsets will\n\t * be set later.\n\t */\n\tTIFFSetField(tif, TIFFTAG_SUBIFD, 1, &rawIFDOffset);\n\tTIFFSetField(tif, TIFFTAG_EXIFIFD, exifIFDOffset);\n\n\t/* Write the thumbnail. */\n\tconst uint8_t *row = static_cast<const uint8_t *>(data);\n\tfor (unsigned int y = 0; y < config.size.height / 16; y++) {\n\t\tinfo->thumbScanline(*info, scanline.data(), row,\n\t\t\t\t    config.size.width / 16, config.stride);\n\n\t\tif (TIFFWriteScanline(tif, scanline.data(), y, 0) != 1) {\n\t\t\tstd::cerr << \"Failed to write thumbnail scanline\"\n\t\t\t\t  << std::endl;\n\t\t\tTIFFClose(tif);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trow += config.stride * 16;\n\t}\n\n\tTIFFWriteDirectory(tif);\n\n\t/*\n\t * Workaround for a bug introduced in libtiff version 4.5.1 and no fix\n\t * released. In these versions the CFA* tags were missing in the field\n\t * info.\n\t * Introduced by: https://gitlab.com/libtiff/libtiff/-/commit/738e04099b13192bb1f654e74e9b5829313f3161\n\t * Fixed by: https://gitlab.com/libtiff/libtiff/-/commit/49856998c3d82e65444b47bb4fb11b7830a0c2be\n\t */\n\tif (!TIFFFindField(tif, TIFFTAG_CFAREPEATPATTERNDIM, TIFF_ANY)) {\n\t\tstatic const TIFFFieldInfo infos[] = {\n\t\t\t{ TIFFTAG_CFAREPEATPATTERNDIM, 2, 2, TIFF_SHORT, FIELD_CUSTOM,\n\t\t\t  1, 0, const_cast<char *>(\"CFARepeatPatternDim\") },\n\t\t\t{ TIFFTAG_CFAPATTERN, -1, -1, TIFF_BYTE, FIELD_CUSTOM,\n\t\t\t  1, 1, const_cast<char *>(\"CFAPattern\") },\n\t\t};\n\t\tTIFFMergeFieldInfo(tif, infos, 2);\n\t}\n\n\t/* Create a new IFD for the RAW image. */\n\tconst uint16_t cfaRepeatPatternDim[] = { 2, 2 };\n\tconst uint8_t cfaPlaneColor[] = {\n\t\tCFAPatternRed,\n\t\tCFAPatternGreen,\n\t\tCFAPatternBlue\n\t};\n\n\tTIFFSetField(tif, TIFFTAG_SUBFILETYPE, 0);\n\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, config.size.width);\n\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, config.size.height);\n\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, info->bitsPerSample);\n\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CFA);\n\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\tTIFFSetField(tif, TIFFTAG_CFAREPEATPATTERNDIM, cfaRepeatPatternDim);\n\tif (TIFFLIB_VERSION < 20201219)\n\t\tTIFFSetField(tif, TIFFTAG_CFAPATTERN, info->pattern);\n\telse\n\t\tTIFFSetField(tif, TIFFTAG_CFAPATTERN, 4, info->pattern);\n\tTIFFSetField(tif, TIFFTAG_CFAPLANECOLOR, 3, cfaPlaneColor);\n\tTIFFSetField(tif, TIFFTAG_CFALAYOUT, 1);\n\n\tconst uint16_t blackLevelRepeatDim[] = { 2, 2 };\n\tfloat blackLevel[] = { 0.0f, 0.0f, 0.0f, 0.0f };\n\tuint32_t whiteLevel = (1 << info->bitsPerSample) - 1;\n\n\tconst auto &blackLevels = metadata.get(controls::SensorBlackLevels);\n\tif (blackLevels) {\n\t\tSpan<const int32_t, 4> levels = *blackLevels;\n\n\t\t/*\n\t\t * The black levels control is specified in R, Gr, Gb, B order.\n\t\t * Map it to the TIFF tag that is specified in CFA pattern\n\t\t * order.\n\t\t */\n\t\tunsigned int green = (info->pattern[0] == CFAPatternRed ||\n\t\t\t\t      info->pattern[1] == CFAPatternRed)\n\t\t\t\t   ? 0 : 1;\n\n\t\tfor (unsigned int i = 0; i < 4; ++i) {\n\t\t\tunsigned int level;\n\n\t\t\tswitch (info->pattern[i]) {\n\t\t\tcase CFAPatternRed:\n\t\t\t\tlevel = levels[0];\n\t\t\t\tbreak;\n\t\t\tcase CFAPatternGreen:\n\t\t\t\tlevel = levels[green + 1];\n\t\t\t\tgreen = (green + 1) % 2;\n\t\t\t\tbreak;\n\t\t\tcase CFAPatternBlue:\n\t\t\tdefault:\n\t\t\t\tlevel = levels[3];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Map the 16-bit value to the bits per sample range. */\n\t\t\tblackLevel[i] = level >> (16 - info->bitsPerSample);\n\t\t}\n\t}\n\n\tTIFFSetField(tif, TIFFTAG_BLACKLEVELREPEATDIM, &blackLevelRepeatDim);\n\tTIFFSetField(tif, TIFFTAG_BLACKLEVEL, 4, &blackLevel);\n\tTIFFSetField(tif, TIFFTAG_WHITELEVEL, 1, &whiteLevel);\n\n\t/* Write RAW content. */\n\trow = static_cast<const uint8_t *>(data);\n\tfor (unsigned int y = 0; y < config.size.height; y++) {\n\t\tinfo->packScanline(scanline.data(), row, config.size.width);\n\n\t\tif (TIFFWriteScanline(tif, scanline.data(), y, 0) != 1) {\n\t\t\tstd::cerr << \"Failed to write RAW scanline\"\n\t\t\t\t  << std::endl;\n\t\t\tTIFFClose(tif);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trow += config.stride;\n\t}\n\n\t/* Checkpoint the IFD to retrieve its offset, and write it out. */\n\tTIFFCheckpointDirectory(tif);\n\trawIFDOffset = TIFFCurrentDirOffset(tif);\n\tTIFFWriteDirectory(tif);\n\n\t/* Create a new IFD for the EXIF data and fill it. */\n\tTIFFCreateEXIFDirectory(tif);\n\n\t/* Store creation time. */\n\ttime_t rawtime;\n\tstruct tm *timeinfo;\n\tchar strTime[20];\n\n\ttime(&rawtime);\n\ttimeinfo = localtime(&rawtime);\n\tstrftime(strTime, 20, \"%Y:%m:%d %H:%M:%S\", timeinfo);\n\n\t/*\n\t * \\todo Handle timezone information by setting OffsetTimeOriginal and\n\t * OffsetTimeDigitized once libtiff catches up to the specification and\n\t * has EXIFTAG_ defines to handle them.\n\t */\n\tTIFFSetField(tif, EXIFTAG_DATETIMEORIGINAL, strTime);\n\tTIFFSetField(tif, EXIFTAG_DATETIMEDIGITIZED, strTime);\n\n\tconst auto &analogGain = metadata.get(controls::AnalogueGain);\n\tif (analogGain) {\n\t\tuint16_t iso = std::min(std::max(*analogGain * 100, 0.0f), 65535.0f);\n\t\tTIFFSetField(tif, EXIFTAG_ISOSPEEDRATINGS, 1, &iso);\n\t}\n\n\tconst auto &exposureTime = metadata.get(controls::ExposureTime);\n\tif (exposureTime)\n\t\tTIFFSetField(tif, EXIFTAG_EXPOSURETIME, *exposureTime / 1e6);\n\n\tTIFFWriteCustomDirectory(tif, &exifIFDOffset);\n\n\t/* Update the IFD offsets and close the file. */\n\tTIFFSetDirectory(tif, 0);\n\tTIFFSetField(tif, TIFFTAG_SUBIFD, 1, &rawIFDOffset);\n\tTIFFSetField(tif, TIFFTAG_EXIFIFD, exifIFDOffset);\n\tTIFFWriteDirectory(tif);\n\n\tTIFFClose(tif);\n\n\treturn 0;\n}",
    "bool CxImageTIF::Encode(CxFile * hFile, bool bAppend)\n{\n  cx_try\n  {\n\tif (hFile==NULL) cx_throw(CXIMAGE_ERR_NOFILE);\n\tif (pDib==NULL) cx_throw(CXIMAGE_ERR_NOIMAGE);\n\n\t// <RJ> replaced \"w+b\" with \"a\", to append an image directly on an existing file\n\tif (m_tif2==NULL) m_tif2=_TIFFOpenEx(hFile, \"a\");\n\tif (m_tif2==NULL) cx_throw(\"initialization fail\");\n\n\tif (bAppend || m_pages) m_multipage=true;\n\tm_pages++;\n\n\tif (!EncodeBody(m_tif2,m_multipage,m_pages,m_pages)) cx_throw(\"Error saving TIFF file\");\n\tif (bAppend) {\n\t\tif (!TIFFWriteDirectory(m_tif2)) cx_throw(\"Error saving TIFF directory\");\n\t}\n  }",
    "bool tImageTIFF::Save(const tString& tiffFile, const SaveParams& params) const\n{\n\tif (!IsValid() || (params.Format == tFormat::Invalid))\n\t\treturn false;\n\n\tif (tSystem::tGetFileType(tiffFile) != tSystem::tFileType::TIFF)\n\t\treturn false;\n\n\tTIFF* tiff = TIFFOpen(tiffFile.Chr(), \"wb\");\n\tif (!tiff)\n\t\treturn false;\n\n\tint rowSize = 0;\n\tuint8* rowBuf = nullptr;\n\tfor (tFrame* frame = Frames.First(); frame; frame = frame->Next())\n\t{\n\t\t// Writes image from last loop and starts a new directory.\n\t\tif (frame != Frames.First())\n\t\t\tTIFFWriteDirectory(tiff);\n\n\t\tbool isOpaque = frame->IsOpaque();\n\t\tint bytesPerPixel = 0;\n\t\tswitch (params.Format)\n\t\t{\n\t\t\tcase tFormat::Auto:\t\tbytesPerPixel = isOpaque ? 3 : 4;\tbreak;\n\t\t\tcase tFormat::BPP24:\tbytesPerPixel = 3;\t\t\t\t\tbreak;\n\t\t\tcase tFormat::BPP32:\tbytesPerPixel = 4;\t\t\t\t\tbreak;\n\t\t}\n\t\ttAssert(bytesPerPixel);\n\n\t\tint w = frame->Width;\n\t\tint h = frame->Height;\n\n\t\tTIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, w);\n\t\tTIFFSetField(tiff, TIFFTAG_IMAGELENGTH, h);\n\t\tTIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, bytesPerPixel);\n\t\tTIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n\t\tTIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\tTIFFSetField(tiff, TIFFTAG_COMPRESSION, params.UseZLibCompression ? COMPRESSION_DEFLATE : COMPRESSION_NONE);\n\t\tTIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t\tif (bytesPerPixel == 4)\n\t\t{\n\t\t\t// Unassociated alpha means the extra channel is not a premultiplied alpha channel.\n\t\t\tuint16 extraSampleTypes[] = { EXTRASAMPLE_UNASSALPHA };\n\t\t\tTIFFSetField(tiff, TIFFTAG_EXTRASAMPLES, tNumElements(extraSampleTypes), extraSampleTypes);\n\t\t}\n\n\t\tint pageDurMilliSec = (params.OverrideFrameDuration >= 0) ? params.OverrideFrameDuration : int(frame->Duration*1000.0f);\n\t\tWriteSoftwarePageDuration(tiff, pageDurMilliSec);\n\n\t\tint rowSizeNeeded = TIFFScanlineSize(tiff);\n\t\ttAssert(rowSizeNeeded == (w*bytesPerPixel));\n\n\t\t// Let's not reallocate the line buffer every frame. Often all frames will be the same size.\n\t\tif (rowSize != rowSizeNeeded)\n\t\t{\n\t\t\tif (rowBuf)\n\t\t\t\t_TIFFfree(rowBuf);\n\t\t\trowBuf = (uint8*)_TIFFmalloc(rowSizeNeeded);\n\t\t\trowSize = rowSizeNeeded;\n\t\t}\n\n\t\tTIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tiff, w*bytesPerPixel));\n\t\tfor (int r = 0; r < h; r++)\n\t\t{\n\t\t\tfor (int x = 0; x < w; x++)\n\t\t\t{\n\t\t\t\tint idx = (h-r-1)*w + x;\n\t\t\t\trowBuf[x*bytesPerPixel + 0] = frame->Pixels[idx].R;\n\t\t\t\trowBuf[x*bytesPerPixel + 1] = frame->Pixels[idx].G;\n\t\t\t\trowBuf[x*bytesPerPixel + 2] = frame->Pixels[idx].B;\n\t\t\t\tif (bytesPerPixel == 4)\n\t\t\t\t\trowBuf[x*bytesPerPixel + 3] = frame->Pixels[idx].A;\n\t\t\t}\n\n\t\t\tint errCode = TIFFWriteScanline(tiff, rowBuf, r, 0);\n\t\t\tif (errCode < 0)\n\t\t\t\tcontinue;\n\t\t}\n    }\n\n\tif (rowBuf)\n\t\t_TIFFfree(rowBuf);\n\tTIFFClose(tiff);\n\n\treturn true;\n}",
    "void CqTiffFileHandle::writeDirectory()\n{\n\tassert(!m_isInputFile);\n\tif(!TIFFWriteDirectory(m_tiffPtr.get()))\n\t\tAQSIS_THROW_XQERROR(XqInternal, EqE_BadFile,\n\t\t\t\"Could not write tiff subimage to file\");\n\t++m_currDir;\n}",
    "void SaveAsShadowMap(const std::string& filename, SqDisplayInstance* image, char *mydescription)\n{\n\tTqChar version[ 80 ];\n\tTqUint twidth = 32;\n\tTqUint tlength = 32;\n\n\tstruct tm *ct;\n\tint year;\n\n\ttime_t long_time;\n\n\ttime( &long_time );           /* Get time as long integer. */\n\tct = localtime( &long_time ); /* Convert to local time. */\n\n\n\tyear=1900 + ct->tm_year;\n\tsprintf(datetime, \"%04d:%02d:%02d %02d:%02d:%02d\", year, ct->tm_mon + 1,\n\t        ct->tm_mday, ct->tm_hour, ct->tm_min, ct->tm_sec);\n\n\n\tconst char* mode = (image->m_append)? \"a\" : \"w\";\n\n\t// Save the shadowmap to a binary file.\n\tif ( filename.compare( \"\" ) != 0 )\n\t{\n\t\tTIFF * pshadow = TIFFOpen( filename.c_str(), mode );\n\t\tif( pshadow != NULL )\n\t\t{\n\t\t\t// Set common tags\n\t\t\tTIFFCreateDirectory( pshadow );\n\n\t\t\tsprintf( version, \"Aqsis %s (%s %s)\", AQSIS_VERSION_STR, __DATE__, __TIME__);\n\n\t\t\tTIFFSetField( pshadow, TIFFTAG_SOFTWARE, ( char* ) version );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA, image->m_matWorldToCamera );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN, image->m_matWorldToScreen );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_PIXAR_TEXTUREFORMAT, SHADOWMAP_HEADER );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n\n\t\t\tif (!image->m_hostname.empty())\n\t\t\t\tTIFFSetField( pshadow, TIFFTAG_HOSTCOMPUTER, image->m_hostname.c_str() );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_IMAGEDESCRIPTION, mydescription);\n\t\t\t// Write the floating point image to the directory.\n\t\t\tTIFFSetField( pshadow, TIFFTAG_IMAGEWIDTH, image->m_width );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_IMAGELENGTH, image->m_height );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_BITSPERSAMPLE, 32 );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_SAMPLESPERPIXEL, image->m_iFormatCount );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_TILEWIDTH, twidth );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_TILELENGTH, tlength );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_COMPRESSION, image->m_compression );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_DATETIME, datetime);\n\n\t\t\tTqDouble minz = FLT_MAX;\n\t\t\tTqFloat* ptdata = reinterpret_cast<TqFloat*>(image->m_data) ;\n\t\t\tfor (TqInt y = 0; y < image->m_height; y++)\n\t\t\t\tfor (TqInt x = 0; x < image->m_width; x++)\n\t\t\t\t{\n\t\t\t\t\tTqDouble value = (TqDouble) ptdata[y*image->m_width + x];\n\t\t\t\t\tif (value < minz) minz = value;\t\n\t\t\t\t}\n\t\t\tTIFFSetField( pshadow, TIFFTAG_SMINSAMPLEVALUE, minz );\n\n\t\t\tTqUint tsize = twidth * tlength;\n\t\t\tTqUint tperrow = ( image->m_width + twidth - 1 ) / twidth;\n\t\t\tTqFloat* ptile = static_cast<TqFloat*>( _TIFFmalloc( tsize * sizeof( TqFloat ) ) );\n\n\n\t\t\tif ( ptile != NULL )\n\t\t\t{\n\t\t\t\tTqUint ctiles = tperrow * ( ( image->m_width + tlength - 1 ) / tlength );\n\t\t\t\tTqUint itile;\n\t\t\t\tfor ( itile = 0; itile < ctiles; itile++ )\n\t\t\t\t{\n\t\t\t\t\tTqUint x = ( itile % tperrow ) * twidth;\n\t\t\t\t\tTqUint y = ( itile / tperrow ) * tlength;\n\t\t\t\t\tptdata = reinterpret_cast<TqFloat*>(image->m_data) + ( ( y * image->m_width ) + x ) * image->m_iFormatCount;\n\t\t\t\t\t// Clear the tile to black.\n\t\t\t\t\tmemset( ptile, 0, tsize * sizeof( TqFloat ) );\n\t\t\t\t\tfor ( TqUlong i = 0; i < tlength; i++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tfor ( TqUlong j = 0; j < twidth; j++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( ( x + j ) < (TqUlong) image->m_width && ( y + i ) < (TqUlong) image->m_height )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tTqInt ii;\n\t\t\t\t\t\t\t\tfor ( ii = 0; ii < image->m_iFormatCount; ii++ ) \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tTqFloat value = ptdata[ ( ( j * image->m_iFormatCount ) + ii ) ];\n\t\t\t\t\t\t\t\t\tptile[ ( i * twidth * image->m_iFormatCount ) + ( ( ( j * image->m_iFormatCount ) + ii ) ) ] = value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tptdata += ( image->m_width * image->m_iFormatCount );\n\t\t\t\t\t}\n\t\t\t\t\tTIFFWriteTile( pshadow, ptile, x, y, 0, 0 );\n\t\t\t\t}\n\t\t\t\tTIFFWriteDirectory( pshadow );\n\n\t\t\t}\n\n\n\t\t\tTIFFClose( pshadow );\n\t\t}\n\t}\n}",
    "void writeStripTiff(const char* fileName)\n{\n\tuint32 height = 4;\n\tuint32 width = 6;\n\tuint32 rowsPerStrip = height/2;\n\tuint16 samplesPerPixel = 3;\n\tuint16 bitsPerSample = 8;\n\n\tconst unsigned char red[] = {0xFF, 0, 0};\n\tconst unsigned char blue[] = {0, 0, 0xFF};\n\n\t//TIFF* outFile = TIFFStreamOpen(\"stream\", &outStream);\n\tTIFF* outFile = TIFFOpen(fileName, \"w\");\n\n\tsetTiffFields(outFile, width, height, samplesPerPixel, bitsPerSample);\n\tTIFFSetField(outFile, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\tTIFFSetField(outFile, TIFFTAG_IMAGEDESCRIPTION, \"Strip-allocated tiff for unit tests\");\n\n\ttsize_t bufSize = TIFFStripSize(outFile);\n\tunsigned char* buf = reinterpret_cast<unsigned char*>(_TIFFmalloc(bufSize));\n\n\t// first directory is a red strip and a blue strip.\n\tsetBufToColor(buf, bufSize/samplesPerPixel, red, samplesPerPixel);\n\tTIFFWriteEncodedStrip(outFile, 0, buf, bufSize);\n\tsetBufToColor(buf, bufSize/samplesPerPixel, blue, samplesPerPixel);\n\tTIFFWriteEncodedStrip(outFile, 1, buf, bufSize);\n\n\tTIFFWriteDirectory(outFile);\n\n\tsetTiffFields(outFile, width, height, samplesPerPixel, bitsPerSample);\n\tTIFFSetField(outFile, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n\t// second directory is a white strip and a black strip\n\t_TIFFmemset(buf, 0xFF, bufSize);\n\tTIFFWriteEncodedStrip(outFile, 0, buf, bufSize);\n\t_TIFFmemset(buf, 0x00, bufSize);\n\tTIFFWriteEncodedStrip(outFile, 1, buf, bufSize);\n\n\tTIFFClose(outFile);\n\t_TIFFfree(buf);\n\t//TIFFSetField(outFile, TIFFTAG_TILEWIDTH, tileWidth);\n\t//TIFFSetField(outFile, TIFFTAG_TILELENGTH, tileHeight);\n}",
    "void writeTiledTiff(const char* fileName)\n{\n\tuint32 height = 5;\n\tuint32 width = 4;\n\tuint16 samplesPerPixel = 3;\n\tuint16 bitsPerSample = 8;\n\tuint32 tileWidth = 16;\n\tuint32 tileHeight = 16;\n\n\t//TIFF* outFile = TIFFStreamOpen(\"stream\", &outStream);\n\tTIFF* outFile = TIFFOpen(fileName, \"w\");\n\n\tsetTiffFields(outFile, width, height, samplesPerPixel, bitsPerSample);\n\tTIFFSetField(outFile, TIFFTAG_TILEWIDTH, tileWidth);\n\tTIFFSetField(outFile, TIFFTAG_TILELENGTH, tileHeight);\n\n\ttsize_t bufSize = TIFFTileSize(outFile);\n\tchar* buf = reinterpret_cast<char*>(_TIFFmalloc(bufSize));\n\t_TIFFmemset(buf, 0x00, bufSize);\n\n\t// first directory\n\tTIFFWriteEncodedTile(outFile, 0, buf, bufSize);\n\tTIFFWriteDirectory(outFile);\n\n\t// rest of the directories\n\twhile(width > 1 || height > 1)\n\t{\n\t\twidth = std::max<uint32>((width+1)/2, 1);\n\t\theight = std::max<uint32>((height+1)/2, 1);\n\t\tsetTiffFields(outFile, width, height, samplesPerPixel, bitsPerSample);\n\t\tTIFFSetField(outFile, TIFFTAG_TILEWIDTH, tileWidth);\n\t\tTIFFSetField(outFile, TIFFTAG_TILELENGTH, tileHeight);\n\n\t\tTIFFWriteEncodedTile(outFile, 0, buf, bufSize);\n\t\tTIFFWriteDirectory(outFile);\n\t}\n\n\tTIFFClose(outFile);\n\t_TIFFfree(buf);\n}",
    "void CqTextureMapOld::WriteImage( TIFF* ptex, TqPuchar raster, TqUlong width, TqUlong length, TqInt samples, TqInt compression, TqInt quality )\n{\n\t// First check if we can support the requested compression format.\n\tif(!TIFFIsCODECConfigured(compression))\n\t{\n\t\tAqsis::log() << error << \"Compression type \" << compression << \" not supported by the libtiff implementation\" << std::endl;\n\t\treturn;\n\t}\n\tTqChar version[ 80 ];\n\tTIFFCreateDirectory( ptex );\n\n\tsprintf( version, \"%s %s\", \"Aqsis\", AQSIS_VERSION_STR );\n\tTIFFSetField( ptex, TIFFTAG_SOFTWARE, ( char* ) version );\n\tTIFFSetField( ptex, TIFFTAG_IMAGEWIDTH, width );\n\tTIFFSetField( ptex, TIFFTAG_IMAGELENGTH, length );\n\tTIFFSetField( ptex, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n\tTIFFSetField( ptex, TIFFTAG_BITSPERSAMPLE, 8 );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLESPERPIXEL, samples );\n\tTIFFSetField( ptex, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT );\n\tTIFFSetField( ptex, TIFFTAG_COMPRESSION, compression );\n\tTIFFSetField( ptex, TIFFTAG_ROWSPERSTRIP, 1 );\n\n\tunsigned char *pdata = raster;\n\tfor ( TqUlong i = 0; i < length; i++ )\n\t{\n\t\tTIFFWriteScanline( ptex, pdata, i );\n\t\tpdata += ( width * samples );\n\t}\n\tTIFFWriteDirectory( ptex );\n}",
    "void CqTextureMapOld::WriteImage( TIFF* ptex, TqFloat *raster, TqUlong width, TqUlong length, TqInt samples, TqInt compression, TqInt quality )\n{\n\t// First check if we can support the requested compression format.\n\tif(!TIFFIsCODECConfigured(compression))\n\t{\n\t\tAqsis::log() << error << \"Compression type \" << compression << \" not supported by the libtiff implementation\" << std::endl;\n\t\treturn;\n\t}\n\tTqChar version[ 80 ];\n\tTIFFCreateDirectory( ptex );\n\n\tsprintf( version, \"%s %s\", \"Aqsis\", AQSIS_VERSION_STR );\n\tTIFFSetField( ptex, TIFFTAG_SOFTWARE, ( char* ) version );\n\tTIFFSetField( ptex, TIFFTAG_IMAGEWIDTH, width );\n\tTIFFSetField( ptex, TIFFTAG_IMAGELENGTH, length );\n\tTIFFSetField( ptex, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n\tTIFFSetField( ptex, TIFFTAG_BITSPERSAMPLE, 32 );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLESPERPIXEL, samples );\n\tTIFFSetField( ptex, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP );\n\tTIFFSetField( ptex, TIFFTAG_COMPRESSION, compression ); /* COMPRESSION_DEFLATE */\n\tTIFFSetField( ptex, TIFFTAG_ROWSPERSTRIP, 1 );\n\tTIFFSetField( ptex, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n\n\tTqFloat *pdata = raster;\n\tfor ( TqUlong i = 0; i < length; i++ )\n\t{\n\t\tTIFFWriteScanline( ptex, pdata, i );\n\t\tpdata += ( width * samples );\n\t}\n\tTIFFWriteDirectory( ptex );\n}",
    "void CqTextureMapOld::WriteImage( TIFF* ptex, TqUshort *raster, TqUlong width, TqUlong length, TqInt samples, TqInt compression, TqInt quality )\n{\n\t// First check if we can support the requested compression format.\n\tif(!TIFFIsCODECConfigured(compression))\n\t{\n\t\tAqsis::log() << error << \"Compression type \" << compression << \" not supported by the libtiff implementation\" << std::endl;\n\t\treturn;\n\t}\n\tTqChar version[ 80 ];\n\tTIFFCreateDirectory( ptex );\n\n\tsprintf( version, \"%s %s\", \"Aqsis\", AQSIS_VERSION_STR );\n\tTIFFSetField( ptex, TIFFTAG_SOFTWARE, ( char* ) version );\n\tTIFFSetField( ptex, TIFFTAG_IMAGEWIDTH, width );\n\tTIFFSetField( ptex, TIFFTAG_IMAGELENGTH, length );\n\tTIFFSetField( ptex, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n\tTIFFSetField( ptex, TIFFTAG_BITSPERSAMPLE, 16 );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLESPERPIXEL, samples );\n\tTIFFSetField( ptex, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT );\n\tTIFFSetField( ptex, TIFFTAG_COMPRESSION, compression ); /* COMPRESSION_DEFLATE */\n\tTIFFSetField( ptex, TIFFTAG_ROWSPERSTRIP, 1 );\n\tTIFFSetField( ptex, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n\n\tTqUshort *pdata = raster;\n\tfor ( TqUlong i = 0; i < length; i++ )\n\t{\n\t\tTIFFWriteScanline( ptex, pdata, i );\n\t\tpdata += ( width * samples );\n\t}\n\tTIFFWriteDirectory( ptex );\n}",
    "void CqTextureMapOld::WriteTileImage( TIFF* ptex, TqFloat *raster, TqUlong width, TqUlong length, TqUlong twidth, TqUlong tlength, TqInt samples, TqInt compression, TqInt quality )\n{\n\t// First check if we can support the requested compression format.\n\tif(!TIFFIsCODECConfigured(compression))\n\t{\n\t\tAqsis::log() << error << \"Compression type \" << compression << \" not supported by the libtiff implementation\" << std::endl;\n\t\treturn;\n\t}\n\t//TIFFCreateDirectory(ptex);\n\tstd::ostringstream version;\n\tversion << \"Aqsis\" << \" \" << AQSIS_VERSION_STR << std::ends;\n\tTIFFSetField( ptex, TIFFTAG_SOFTWARE, version.str ().c_str () );\n\tTIFFSetField( ptex, TIFFTAG_IMAGEWIDTH, width );\n\tTIFFSetField( ptex, TIFFTAG_IMAGELENGTH, length );\n\tTIFFSetField( ptex, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n\tTIFFSetField( ptex, TIFFTAG_BITSPERSAMPLE, 32 );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLESPERPIXEL, samples );\n\tif(samples == 1)\n\t\tTIFFSetField( ptex, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n\telse\n\t\tTIFFSetField( ptex, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n\tTIFFSetField( ptex, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n\tTIFFSetField( ptex, TIFFTAG_TILEWIDTH, twidth );\n\tTIFFSetField( ptex, TIFFTAG_TILELENGTH, tlength );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP );\n\tTIFFSetField( ptex, TIFFTAG_COMPRESSION, compression );\n\n\n\tTqInt tsize = twidth * tlength;\n\tTqInt tperrow = ( width + twidth - 1 ) / twidth;\n\tTqFloat* ptile = static_cast<TqFloat*>( _TIFFmalloc( tsize * samples * sizeof( TqFloat ) ) );\n\n\tif ( ptile != NULL )\n\t{\n\t\tTqInt ctiles = tperrow * ( ( length + tlength - 1 ) / tlength );\n\t\tTqInt itile;\n\t\tfor ( itile = 0; itile < ctiles; itile++ )\n\t\t{\n\t\t\tTqInt x = ( itile % tperrow ) * twidth;\n\t\t\tTqInt y = ( itile / tperrow ) * tlength;\n\t\t\tTqFloat* ptdata = raster + ( ( y * width ) + x ) * samples;\n\t\t\t// Clear the tile to black.\n\t\t\tmemset( ptile, 0, tsize * samples * sizeof( TqFloat ) );\n\t\t\tfor ( TqUlong i = 0; i < tlength; i++ )\n\t\t\t{\n\t\t\t\tfor ( TqUlong j = 0; j < twidth; j++ )\n\t\t\t\t{\n\t\t\t\t\tif ( ( x + j ) < width && ( y + i ) < length )\n\t\t\t\t\t{\n\t\t\t\t\t\tTqInt ii;\n\t\t\t\t\t\tfor ( ii = 0; ii < samples; ii++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTqFloat value = ptdata[ ( ( j * samples ) + ii ) ];\n\t\t\t\t\t\t\tptile[ ( i * twidth * samples ) + ( ( ( j * samples ) + ii ) ) ] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tptdata += ( width * samples );\n\t\t\t}\n\t\t\tTIFFWriteTile( ptex, ptile, x, y, 0, 0 );\n\t\t}\n\t\tTIFFWriteDirectory( ptex );\n\t\t_TIFFfree( ptile );\n\t}\n}",
    "void CqTextureMapOld::WriteTileImage( TIFF* ptex, TqUshort *raster, TqUlong width, TqUlong length, TqUlong twidth, TqUlong tlength, TqInt samples, TqInt compression, TqInt quality )\n{\n\t// First check if we can support the requested compression format.\n\tif(!TIFFIsCODECConfigured(compression))\n\t{\n\t\tAqsis::log() << error << \"Compression type \" << compression << \" not supported by the libtiff implementation\" << std::endl;\n\t\treturn;\n\t}\n\t//TIFFCreateDirectory(ptex);\n\tstd::ostringstream version;\n\tversion << \"Aqsis\" << \" \" << AQSIS_VERSION_STR << std::ends;\n\tTIFFSetField( ptex, TIFFTAG_SOFTWARE, version.str ().c_str () );\n\tTIFFSetField( ptex, TIFFTAG_IMAGEWIDTH, width );\n\tTIFFSetField( ptex, TIFFTAG_IMAGELENGTH, length );\n\tTIFFSetField( ptex, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n\tTIFFSetField( ptex, TIFFTAG_BITSPERSAMPLE, 16 );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLESPERPIXEL, samples );\n\tif(samples == 1)\n\t\tTIFFSetField( ptex, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n\telse\n\t\tTIFFSetField( ptex, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n\tTIFFSetField( ptex, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n\tTIFFSetField( ptex, TIFFTAG_TILEWIDTH, twidth );\n\tTIFFSetField( ptex, TIFFTAG_TILELENGTH, tlength );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT );\n\tTIFFSetField( ptex, TIFFTAG_COMPRESSION, compression );\n\n\n\tTqInt tsize = twidth * tlength;\n\tTqInt tperrow = ( width + twidth - 1 ) / twidth;\n\tTqUshort* ptile = static_cast<TqUshort*>( _TIFFmalloc( tsize * samples * sizeof( TqUshort ) ) );\n\n\tif ( ptile != NULL )\n\t{\n\t\tTqInt ctiles = tperrow * ( ( length + tlength - 1 ) / tlength );\n\t\tTqInt itile;\n\t\tfor ( itile = 0; itile < ctiles; itile++ )\n\t\t{\n\t\t\tTqInt x = ( itile % tperrow ) * twidth;\n\t\t\tTqInt y = ( itile / tperrow ) * tlength;\n\t\t\tTqUshort* ptdata = raster + ( ( y * width ) + x ) * samples;\n\t\t\t// Clear the tile to black.\n\t\t\tmemset( ptile, 0, tsize * samples * sizeof( TqUshort ) );\n\t\t\tfor ( TqUlong i = 0; i < tlength; i++ )\n\t\t\t{\n\t\t\t\tfor ( TqUlong j = 0; j < twidth; j++ )\n\t\t\t\t{\n\t\t\t\t\tif ( ( x + j ) < width && ( y + i ) < length )\n\t\t\t\t\t{\n\t\t\t\t\t\tTqInt ii;\n\t\t\t\t\t\tfor ( ii = 0; ii < samples; ii++ )\n\t\t\t\t\t\t\tptile[ ( i * twidth * samples ) + ( ( ( j * samples ) + ii ) ) ] = ptdata[ ( ( j * samples ) + ii ) ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tptdata += ( width * samples );\n\t\t\t}\n\t\t\tTIFFWriteTile( ptex, ptile, x, y, 0, 0 );\n\t\t}\n\t\tTIFFWriteDirectory( ptex );\n\t\t_TIFFfree( ptile );\n\t}\n}",
    "void CqTextureMapOld::WriteTileImage( TIFF* ptex, TqPuchar raster, TqUlong width, TqUlong length, TqUlong twidth, TqUlong tlength, TqInt samples, TqInt compression, TqInt quality )\n{\n\t// First check if we can support the requested compression format.\n\tif(!TIFFIsCODECConfigured(compression))\n\t{\n\t\tAqsis::log() << error << \"Compression type \" << compression << \" not supported by the libtiff implementation\" << std::endl;\n\t\treturn;\n\t}\n\tstd::ostringstream version;\n\tversion << \"Aqsis\" << \" \" << AQSIS_VERSION_STR << std::ends;\n\tTIFFSetField( ptex, TIFFTAG_SOFTWARE, version.str ().c_str () );\n\tTIFFSetField( ptex, TIFFTAG_IMAGEWIDTH, width );\n\tTIFFSetField( ptex, TIFFTAG_IMAGELENGTH, length );\n\tTIFFSetField( ptex, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n\tTIFFSetField( ptex, TIFFTAG_BITSPERSAMPLE, 8 );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLESPERPIXEL, samples );\n\tTIFFSetField( ptex, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n\tTIFFSetField( ptex, TIFFTAG_TILEWIDTH, twidth );\n\tTIFFSetField( ptex, TIFFTAG_TILELENGTH, tlength );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT );\n\tTIFFSetField( ptex, TIFFTAG_COMPRESSION, compression );\n\tTIFFSetField( ptex, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n\n\tTqInt tsize = twidth * tlength;\n\tTqInt tperrow = ( width + twidth - 1 ) / twidth;\n\tTqPuchar ptile = static_cast<TqPuchar>( _TIFFmalloc( tsize * samples ) );\n\n\tif ( ptile != NULL )\n\t{\n\t\tTqInt ctiles = tperrow * ( ( length + tlength - 1 ) / tlength );\n\t\tTqInt itile;\n\t\tfor ( itile = 0; itile < ctiles; itile++ )\n\t\t{\n\t\t\tTqInt x = ( itile % tperrow ) * twidth;\n\t\t\tTqInt y = ( itile / tperrow ) * tlength;\n\t\t\tTqPuchar ptdata = raster + ( ( y * width ) + x ) * samples;\n\t\t\t// Clear the tile to black.\n\t\t\tmemset( ptile, 0, tsize * samples );\n\t\t\tfor ( TqUlong i = 0; i < tlength; i++ )\n\t\t\t{\n\t\t\t\tfor ( TqUlong j = 0; j < twidth; j++ )\n\t\t\t\t{\n\t\t\t\t\tif ( ( x + j ) < width && ( y + i ) < length )\n\t\t\t\t\t{\n\t\t\t\t\t\tTqInt ii;\n\t\t\t\t\t\tfor ( ii = 0; ii < samples; ii++ )\n\t\t\t\t\t\t\tptile[ ( i * twidth * samples ) + ( ( ( j * samples ) + ii ) ) ] = ptdata[ ( ( j * samples ) + ii ) ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tptdata += ( width * samples );\n\t\t\t}\n\t\t\tTIFFWriteTile( ptex, ptile, x, y, 0, 0 );\n\t\t}\n\t\tTIFFWriteDirectory( ptex );\n\t\t_TIFFfree( ptile );\n\t}\n}",
    "void dng_save(std::vector<libcamera::Span<uint8_t>> const &mem, StreamInfo const &info, ControlList const &metadata,\n\t\t\t  std::string const &filename, std::string const &cam_model, StillOptions const *options)\n{\n\t// Check the Bayer format and unpack it to u16.\n\n\tauto it = bayer_formats.find(info.pixel_format);\n\tif (it == bayer_formats.end())\n\t\tthrow std::runtime_error(\"unsupported Bayer format\");\n\tBayerFormat const &bayer_format = it->second;\n\tLOG(1, \"Bayer format is \" << bayer_format.name);\n\n\t// Decompression will require a buffer that's 8 pixels aligned.\n\tunsigned int buf_stride_pixels = info.width;\n\tunsigned int buf_stride_pixels_padded = (buf_stride_pixels + 7) & ~7;\n\tstd::vector<uint16_t> buf(buf_stride_pixels_padded * info.height);\n\tif (bayer_format.compressed)\n\t{\n\t\tuncompress(mem[0].data(), info, &buf[0]);\n\t\tbuf_stride_pixels = buf_stride_pixels_padded;\n\t}\n\telse if (bayer_format.packed)\n\t{\n\t\tswitch (bayer_format.bits)\n\t\t{\n\t\tcase 10:\n\t\t\tunpack_10bit(mem[0].data(), info, &buf[0]);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tunpack_12bit(mem[0].data(), info, &buf[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t\tunpack_16bit(mem[0].data(), info, &buf[0]);\n\n\t// We need to fish out some metadata values for the DNG.\n\tfloat black = 4096 * (1 << bayer_format.bits) / 65536.0;\n\tfloat black_levels[] = { black, black, black, black };\n\tauto bl = metadata.get(controls::SensorBlackLevels);\n\tif (bl)\n\t{\n\t\t// levels is in the order R, Gr, Gb, B. Re-order it for the actual bayer order.\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint j = bayer_format.order[i];\n\t\t\tj = j == 0 ? 0 : (j == 2 ? 3 : 1 + !!bayer_format.order[i ^ 1]);\n\t\t\tblack_levels[j] = (*bl)[i] * (1 << bayer_format.bits) / 65536.0;\n\t\t}\n\t}\n\telse\n\t\tLOG_ERROR(\"WARNING: no black level found, using default\");\n\n\tauto exp = metadata.get(controls::ExposureTime);\n\tfloat exp_time = 10000;\n\tif (exp)\n\t\texp_time = *exp;\n\telse\n\t\tLOG_ERROR(\"WARNING: default to exposure time of \" << exp_time << \"us\");\n\texp_time /= 1e6;\n\n\tauto ag = metadata.get(controls::AnalogueGain);\n\tuint16_t iso = 100;\n\tif (ag)\n\t\tiso = *ag * 100.0;\n\telse\n\t\tLOG_ERROR(\"WARNING: default to ISO value of \" << iso);\n\n\tfloat NEUTRAL[] = { 1, 1, 1 };\n\tMatrix WB_GAINS(1, 1, 1);\n\tauto cg = metadata.get(controls::ColourGains);\n\tif (cg)\n\t{\n\t\tNEUTRAL[0] = 1.0 / (*cg)[0];\n\t\tNEUTRAL[2] = 1.0 / (*cg)[1];\n\t\tWB_GAINS = Matrix((*cg)[0], 1, (*cg)[1]);\n\t}\n\n\t// Use a slightly plausible default CCM in case the metadata doesn't have one (it should!).\n\tMatrix CCM(1.90255, -0.77478, -0.12777,\n\t\t\t   -0.31338, 1.88197, -0.56858,\n\t\t\t   -0.06001, -0.61785, 1.67786);\n\tauto ccm = metadata.get(controls::ColourCorrectionMatrix);\n\tif (ccm)\n\t{\n\t\tCCM = Matrix((*ccm)[0], (*ccm)[1], (*ccm)[2], (*ccm)[3], (*ccm)[4], (*ccm)[5], (*ccm)[6], (*ccm)[7], (*ccm)[8]);\n\t}\n\telse\n\t\tLOG_ERROR(\"WARNING: no CCM metadata found\");\n\n\t// This maxtrix from http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\tMatrix RGB2XYZ(0.4124564, 0.3575761, 0.1804375,\n\t\t\t\t   0.2126729, 0.7151522, 0.0721750,\n\t\t\t\t   0.0193339, 0.1191920, 0.9503041);\n\tMatrix CAM_XYZ = (RGB2XYZ * CCM * WB_GAINS).Inv();\n\n\tLOG(2, \"Black levels \" << black_levels[0] << \" \" << black_levels[1] << \" \" << black_levels[2] << \" \"\n\t\t\t\t\t\t   << black_levels[3] << \", exposure time \" << exp_time * 1e6 << \"us, ISO \" << iso);\n\tLOG(2, \"Neutral \" << NEUTRAL[0] << \" \" << NEUTRAL[1] << \" \" << NEUTRAL[2]);\n\tLOG(2, \"Cam_XYZ: \");\n\tLOG(2, CAM_XYZ.m[0] << \" \" << CAM_XYZ.m[1] << \" \" << CAM_XYZ.m[2]);\n\tLOG(2, CAM_XYZ.m[3] << \" \" << CAM_XYZ.m[4] << \" \" << CAM_XYZ.m[5]);\n\tLOG(2, CAM_XYZ.m[6] << \" \" << CAM_XYZ.m[7] << \" \" << CAM_XYZ.m[8]);\n\n\t// Finally write the DNG.\n\n\tTIFF *tif = nullptr;\n\n\ttry\n\t{\n\t\tconst short cfa_repeat_pattern_dim[] = { 2, 2 };\n\t\tuint32_t white = (1 << bayer_format.bits) - 1;\n\t\ttoff_t offset_subifd = 0, offset_exififd = 0;\n\t\tstd::string unique_model = std::string(MAKE_STRING \" \") + cam_model;\n\n\t\ttif = TIFFOpen(filename.c_str(), \"w\");\n\t\tif (!tif)\n\t\t\tthrow std::runtime_error(\"could not open file \" + filename);\n\n\t\t// This is just the thumbnail, but put it first to help software that only\n\t\t// reads the first IFD.\n\t\tTIFFSetField(tif, TIFFTAG_SUBFILETYPE, 1);\n\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, info.width >> 4);\n\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, info.height >> 4);\n\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t\tTIFFSetField(tif, TIFFTAG_MAKE, MAKE_STRING);\n\t\tTIFFSetField(tif, TIFFTAG_MODEL, cam_model.c_str());\n\t\tTIFFSetField(tif, TIFFTAG_DNGVERSION, \"\\001\\001\\000\\000\");\n\t\tTIFFSetField(tif, TIFFTAG_DNGBACKWARDVERSION, \"\\001\\000\\000\\000\");\n\t\tTIFFSetField(tif, TIFFTAG_UNIQUECAMERAMODEL, unique_model.c_str());\n\t\tTIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(tif, TIFFTAG_SOFTWARE, \"rpicam-still\");\n\t\tTIFFSetField(tif, TIFFTAG_COLORMATRIX1, 9, CAM_XYZ.m);\n\t\tTIFFSetField(tif, TIFFTAG_ASSHOTNEUTRAL, 3, NEUTRAL);\n\t\tTIFFSetField(tif, TIFFTAG_CALIBRATIONILLUMINANT1, 21);\n\t\tTIFFSetField(tif, TIFFTAG_SUBIFD, 1, &offset_subifd);\n\t\tTIFFSetField(tif, TIFFTAG_EXIFIFD, offset_exififd);\n\n\t\t// Make a small greyscale thumbnail, just to give some clue what's in here.\n\t\tstd::vector<uint8_t> thumb_buf((info.width >> 4) * 3);\n\n\t\tfor (unsigned int y = 0; y < (info.height >> 4); y++)\n\t\t{\n\t\t\tfor (unsigned int x = 0; x < (info.width >> 4); x++)\n\t\t\t{\n\t\t\t\tunsigned int off = (y * buf_stride_pixels + x) << 4;\n\t\t\t\tuint32_t grey =\n\t\t\t\t\tbuf[off] + buf[off + 1] + buf[off + buf_stride_pixels] + buf[off + buf_stride_pixels + 1];\n\t\t\t\tgrey = (grey << 14) >> bayer_format.bits;\n\t\t\t\tgrey = sqrt((double)grey); // simple \"gamma correction\"\n\t\t\t\tthumb_buf[3 * x] = thumb_buf[3 * x + 1] = thumb_buf[3 * x + 2] = grey;\n\t\t\t}\n\t\t\tif (TIFFWriteScanline(tif, &thumb_buf[0], y, 0) != 1)\n\t\t\t\tthrow std::runtime_error(\"error writing DNG thumbnail data\");\n\t\t}\n\n\t\tTIFFWriteDirectory(tif);\n\n\t\t// The main image (actually tends to show up as \"sub-image 1\").\n\t\tTIFFSetField(tif, TIFFTAG_SUBFILETYPE, 0);\n\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, info.width);\n\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, info.height);\n\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);\n\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CFA);\n\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(tif, TIFFTAG_CFAREPEATPATTERNDIM, cfa_repeat_pattern_dim);\n#if TIFFLIB_VERSION >= 20201219 // version 4.2.0 or later\n\t\tTIFFSetField(tif, TIFFTAG_CFAPATTERN, 4, bayer_format.order);\n#else\n\t\tTIFFSetField(tif, TIFFTAG_CFAPATTERN, bayer_format.order);\n#endif\n\t\tTIFFSetField(tif, TIFFTAG_WHITELEVEL, 1, &white);\n\t\tconst uint16_t black_level_repeat_dim[] = { 2, 2 };\n\t\tTIFFSetField(tif, TIFFTAG_BLACKLEVELREPEATDIM, &black_level_repeat_dim);\n\t\tTIFFSetField(tif, TIFFTAG_BLACKLEVEL, 4, &black_levels);\n\n\t\tfor (unsigned int y = 0; y < info.height; y++)\n\t\t{\n\t\t\tif (TIFFWriteScanline(tif, &buf[buf_stride_pixels * y], y, 0) != 1)\n\t\t\t\tthrow std::runtime_error(\"error writing DNG image data\");\n\t\t}\n\n\t\t// We have to checkpoint before the directory offset is valid.\n\t\tTIFFCheckpointDirectory(tif);\n\t\toffset_subifd = TIFFCurrentDirOffset(tif);\n\t\tTIFFWriteDirectory(tif);\n\n\t\t// Create a separate IFD just for the EXIF tags. Why we couldn't simply have\n\t\t// DNG tags for these, which would have made life so much easier, I have no idea.\n\t\tTIFFCreateEXIFDirectory(tif);\n\n\t\ttime_t t;\n\t\ttime(&t);\n\t\tstruct tm *time_info = localtime(&t);\n\t\tchar time_str[32];\n\t\tstrftime(time_str, 32, \"%Y:%m:%d %H:%M:%S\", time_info);\n\t\tTIFFSetField(tif, EXIFTAG_DATETIMEORIGINAL, time_str);\n\n\t\tTIFFSetField(tif, EXIFTAG_ISOSPEEDRATINGS, 1, &iso);\n\t\tTIFFSetField(tif, EXIFTAG_EXPOSURETIME, exp_time);\n\n\t\tauto lp = metadata.get(libcamera::controls::LensPosition);\n\t\tif (lp)\n\t\t{\n\t\t\tdouble dist = (*lp > 0.0) ? (1.0 / *lp) : std::numeric_limits<double>::infinity();\n\t\t\tTIFFSetField(tif, EXIFTAG_SUBJECTDISTANCE, dist);\n\t\t}\n\n\t\tTIFFCheckpointDirectory(tif);\n\t\toffset_exififd = TIFFCurrentDirOffset(tif);\n\t\tTIFFWriteDirectory(tif);\n\n\t\t// Now got back to the initial IFD and correct the offsets to its sub-thingies\n\t\tTIFFSetDirectory(tif, 0);\n\t\tTIFFSetField(tif, TIFFTAG_SUBIFD, 1, &offset_subifd);\n\t\tTIFFSetField(tif, TIFFTAG_EXIFIFD, offset_exififd);\n\t\tTIFFWriteDirectory(tif);\n\n\t\t// For reasons unknown, the last sub-IFD that we make seems to reappear at the\n\t\t// end of the file as IDF1, and some tools (exiftool for example) are prone to\n\t\t// complain about it. As far as I can see the code above is doing the correct\n\t\t// things, and I can't find any references to this problem anywhere. So frankly\n\t\t// I have no idea what is happening - please let us know if you do. Anyway,\n\t\t// this bodge appears to make the problem go away...\n\t\tTIFFUnlinkDirectory(tif, 2);\n\n\t\tTIFFClose(tif);\n\t}\n\tcatch (std::exception const &e)\n\t{\n\t\tif (tif)\n\t\t\tTIFFClose(tif);\n\t\tthrow;\n\t}\n}",
    "void imageIO::writeImage(const float * steady_state, uint max_visits, pixel center) {\n  //const uint Z_AREA = 1;\n  const double block_size = (2 * AREA + 1) * (2 * AREA + 1);// * (Z_AREA * Z_AREA + 1);\n\n  uint i, j;\n  float block_mean = 0.0;\n  float min_val    = 1.0 / max_visits;\n\n  // Do thresholding\n  if (OPT_THRESHOLD){\n\n    // find the block of pixels aroung the center that we will use for thresholding\n    for (i = (center.x - AREA); i <= (center.x + AREA); ++i) {\n      for (j = (center.y - AREA); j <= (center.y + AREA); ++j) {\n\t//for (k = (center.z - Z_AREA); k <= (center.z + Z_AREA); ++k) {\n\t  pixel cur = {i, j, center.z};\n\t  block_mean += steady_state[OFFSET(img, cur)];\n\t  //}\n      }      \n    }\n    \n    block_mean /= block_size;\n\n    if (fout.is_open()){\n      fout << \"Cell body size        : \" << block_size << endl \n\t   << \"Mean cell body value  : \" << block_mean << endl\n\t   << \"Min threshold         : \" << min_val << endl << endl;\n    }\n      \n    if (OPT_DEBUG > 0){\n      cout << \"Cell body size      : \" << block_size << endl \n\t   << \"Mean cell body value: \" << block_mean << endl\n\t   << \"Min threshold       : \" << min_val << endl;\n    }\n\n    block_mean -= min_val;\n  }else{\n    block_mean = 1.0;\n    min_val    = 0.0;\n  }\n\n  /*\n   * ************** WRITE MULTI-PLANAR TIFF FILE **************\n   */ \n  string outfile = OPT_IMAGEOUT + \"stack.tif\";\n  TIFF * image;\n  uint rowsperstrip, page;\n  double norm;\n  char page_number[20], z_depth[40];\n\n  uchar * row = (uchar *) malloc(img.width * sizeof(uchar));\n  \n  // Open the TIFF file\n  if((image = TIFFOpen(outfile.c_str(), \"w\")) == NULL){\n    cerr << \"Could not open \" << outfile << \" for writing\\n\";\n  }\n  \n  // Loop through each plane of the image\n  for (page = 0; page < img.depth; ++page){\n      TIFFSetField(image, TIFFTAG_IMAGEWIDTH, img.width);\n      TIFFSetField(image, TIFFTAG_IMAGELENGTH, img.height);\n      TIFFSetField(image, TIFFTAG_IMAGEDEPTH, img.depth);      \n      TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 8);\n      TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);\n      \n      rowsperstrip = TIFFDefaultStripSize(image, -1);\n      \n      TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n      TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n      TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n      \n      TIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n      TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n      // set the resolution, we multiply by 10,000 to convert from\n      // microns (10^-6) to centimerters (10^-2)\n      TIFFSetField(image, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER);\n      sprintf(z_depth, \"z_resolution: %f\", (img.z_dist * 10000));\n      TIFFSetField(image, TIFFTAG_XRESOLUTION, (img.xy_dist * 10000));\n      TIFFSetField(image, TIFFTAG_YRESOLUTION, (img.xy_dist * 10000));\n      // not sure where else to put the z_resolution data????\n      TIFFSetField(image, TIFFTAG_ARTIST, z_depth);\n\n      sprintf(page_number, \"Page %d\", page + 1);\n      TIFFSetField(image, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n      TIFFSetField(image, TIFFTAG_PAGENUMBER, page + 1, page + 1);\n      TIFFSetField(image, TIFFTAG_PAGENAME, page_number);\n   \n\n      for (i = 0; i < img.height; ++i){\n\t\n\t// compute pixel values\n\tfor (j = 0; j < img.width; ++j) {\n\t  norm = (fabs(steady_state[(page * img.height * img.width) + \n\t\t\t\t    (img.width * i) + j] - min_val) / block_mean);\n\t  row[j] = (uchar)(min(1.0, norm) * 255);\n\t}\n\t\n\t// write a single row of the image\n\tif (TIFFWriteScanline(image, row, i, 0) == -1){ \n\t  printf(\"Error!!\\n\");\n\t}\n      }\n\n      // write one plane of the image\n      if (img.depth > 1){\n\tTIFFWriteDirectory(image);\n      }\n  }\n  \n  free(row);\n  TIFFClose(image);\n}",
    "JNIEXPORT jboolean JNICALL LCTIFFWriter_METHOD(append)\n    ( JNIEnv *env, jobject jLCTIFFWriter, jbyteArray jFileNameUtf8 )\n{\n    TIFF *const destTIFF = getNativePtr( env, jLCTIFFWriter );\n    TIFFSetField( destTIFF, TIFFTAG_PAGENUMBER, 0, 2 );\n    int result = TIFFWriteDirectory( destTIFF );\n    if ( !result )\n        return JNI_FALSE;\n    jbyteArray_to_c const cFileName( env, jFileNameUtf8 );\n    TIFF *const srcTIFF = LC_TIFFOpen( cFileName, \"r\" );\n    if ( !srcTIFF )\n        return JNI_FALSE;\n    if ( isLightZoneLayeredTIFF( srcTIFF ) )\n        TIFFReadDirectory( srcTIFF );\n    result = tiffcp( srcTIFF, destTIFF );\n    TIFFSetField( destTIFF, TIFFTAG_PAGENUMBER, 1, 2 );\n    TIFFClose( srcTIFF );\n    return result ? JNI_TRUE : JNI_FALSE;\n}",
    "CPLErr GTIFMemBufFromWktEx( const char *pszWKT, const double *padfGeoTransform,\n                            int nGCPCount, const GDAL_GCP *pasGCPList,\n                            int *pnSize, unsigned char **ppabyBuffer,\n                            int bPixelIsPoint )\n\n{\n    TIFF        *hTIFF;\n    GTIF \t*hGTIF;\n    char        szFilename[100];\n\n    sprintf( szFilename, \"/vsimem/wkt_from_mem_buf_%ld.tif\",\n             (long) CPLGetPID() );\n\n/* -------------------------------------------------------------------- */\n/*      Make sure we have hooked CSVFilename().                         */\n/* -------------------------------------------------------------------- */\n    LibgeotiffOneTimeInit();\n\n/* -------------------------------------------------------------------- */\n/*      Initialize access to the memory geotiff structure.              */\n/* -------------------------------------------------------------------- */\n    hTIFF = VSI_TIFFOpen( szFilename, \"w\" );\n\n    if( hTIFF == NULL )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"TIFF/GeoTIFF structure is corrupt.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write some minimal set of image parameters.                     */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, 8 );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n    TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n\n/* -------------------------------------------------------------------- */\n/*      Get the projection definition.                                  */\n/* -------------------------------------------------------------------- */\n\n    int  bPointGeoIgnore = FALSE;\n    if( bPixelIsPoint )\n    {\n        bPointGeoIgnore =\n            CSLTestBoolean( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                               \"FALSE\") );\n    }\n\n    if( pszWKT != NULL || bPixelIsPoint )\n    {\n        hGTIF = GTIFNew(hTIFF);\n        if( pszWKT != NULL )\n            GTIFSetFromOGISDefn( hGTIF, pszWKT );\n\n        if( bPixelIsPoint )\n        {\n            GTIFKeySet(hGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( hGTIF );\n        GTIFFree( hGTIF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Set the geotransform, or GCPs.                                  */\n/* -------------------------------------------------------------------- */\n\n    if( padfGeoTransform[0] != 0.0 || padfGeoTransform[1] != 1.0\n        || padfGeoTransform[2] != 0.0 || padfGeoTransform[3] != 0.0\n        || padfGeoTransform[4] != 0.0 || ABS(padfGeoTransform[5]) != 1.0 )\n    {\n\n        if( padfGeoTransform[2] == 0.0 && padfGeoTransform[4] == 0.0 )\n        {\n            double\tadfPixelScale[3], adfTiePoints[6];\n\n            adfPixelScale[0] = padfGeoTransform[1];\n            adfPixelScale[1] = fabs(padfGeoTransform[5]);\n            adfPixelScale[2] = 0.0;\n\n            TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n\n            adfTiePoints[0] = 0.0;\n            adfTiePoints[1] = 0.0;\n            adfTiePoints[2] = 0.0;\n            adfTiePoints[3] = padfGeoTransform[0];\n            adfTiePoints[4] = padfGeoTransform[3];\n            adfTiePoints[5] = 0.0;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfTiePoints[3] += padfGeoTransform[1] * 0.5 + padfGeoTransform[2] * 0.5;\n                adfTiePoints[4] += padfGeoTransform[4] * 0.5 + padfGeoTransform[5] * 0.5;\n            }\n\n            TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n        }\n        else\n        {\n            double\tadfMatrix[16];\n\n            memset(adfMatrix,0,sizeof(double) * 16);\n\n            adfMatrix[0] = padfGeoTransform[1];\n            adfMatrix[1] = padfGeoTransform[2];\n            adfMatrix[3] = padfGeoTransform[0];\n            adfMatrix[4] = padfGeoTransform[4];\n            adfMatrix[5] = padfGeoTransform[5];\n            adfMatrix[7] = padfGeoTransform[3];\n            adfMatrix[15] = 1.0;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfMatrix[3] += padfGeoTransform[1] * 0.5 + padfGeoTransform[2] * 0.5;\n                adfMatrix[7] += padfGeoTransform[4] * 0.5 + padfGeoTransform[5] * 0.5;\n            }\n\n            TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise write tiepoints if they are available.                */\n/* -------------------------------------------------------------------- */\n    else if( nGCPCount > 0 )\n    {\n        double\t*padfTiePoints;\n\n        padfTiePoints = (double *) CPLMalloc(6*sizeof(double)*nGCPCount);\n\n        for( int iGCP = 0; iGCP < nGCPCount; iGCP++ )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPList[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPList[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPList[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPList[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPList[iGCP].dfGCPZ;\n        }\n\n        TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6*nGCPCount, padfTiePoints);\n        CPLFree( padfTiePoints );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup and return the created memory buffer.                   */\n/* -------------------------------------------------------------------- */\n    GByte bySmallImage = 0;\n\n    TIFFWriteEncodedStrip( hTIFF, 0, (char *) &bySmallImage, 1 );\n    TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTIFMemBufFromWkt\");\n    TIFFWriteDirectory( hTIFF );\n\n    XTIFFClose( hTIFF );\n\n/* -------------------------------------------------------------------- */\n/*      Read back from the memory buffer.  It would be preferrable      */\n/*      to be able to \"steal\" the memory buffer, but there isn't        */\n/*      currently any support for this.                                 */\n/* -------------------------------------------------------------------- */\n    GUIntBig nBigLength;\n\n    *ppabyBuffer = VSIGetMemFileBuffer( szFilename, &nBigLength, TRUE );\n    *pnSize = (int) nBigLength;\n\n    return CE_None;\n}",
    "void SAVE_TIFF_libtiff(const std::string& filename, const TDATA* data, size_t width, size_t height, bool little_endian=true) {\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    TIFF* tifvideo;\r\n    if (little_endian) {\r\n        tifvideo=TIFFOpen(filename.c_str(), \"wl\");\r\n    } else {\r\n        tifvideo=TIFFOpen(filename.c_str(), \"wb\");\r\n    }\r\n    if (tifvideo) {\r\n        TIFFWrite<TDATA>(tifvideo, data, width, height);\r\n        TIFFWriteDirectory(tifvideo);\r\n        TIFFClose(tifvideo);\r\n    }\r\n#endif\r\n}",
    "void performLibTIFFWriteTest(const std::string& name, const char* filename, const T* imagedata, size_t WIDTH, size_t HEIGHT, size_t SAMPLES, size_t FRAMES, std::vector<TestResult>& test_results, const float SPEEDTEST_REMOVESLOWEST_PERCENT = 0.1) {\n#ifdef TINYTIFF_TEST_LIBTIFF\n    const size_t bits=sizeof(T)*8;\n    std::string desc=std::to_string(WIDTH)+\"x\"+std::to_string(HEIGHT)+\"pix/\"+std::to_string(bits)+\"bit/\"+std::to_string(SAMPLES)+\"ch/\"+std::to_string(FRAMES)+\"frames\";\n    test_results.emplace_back();\n    test_results.back().name=name+\" [\"+desc+\", \"+std::string(filename)+\"]\";\n    test_results.back().success=true;\n    std::cout<<\"\\n\\n*****************************************************************************\\n\";\n    std::cout<<\"* \"<<test_results.back().name<<\"\\n\";\n    HighResTimer timer, timer1;\n    timer.start();\n    TIFF* tifvideo=TIFFOpen(filename, \"w\");\n    if (tifvideo) {\n        std::vector<double> runtimes;\n        runtimes.reserve(FRAMES);\n        for (size_t f=0; f<FRAMES; f++) {\n            timer1.start();\n            TIFFWrite<T>(tifvideo, imagedata, WIDTH, HEIGHT);\n            TIFFWriteDirectory(tifvideo);\n            runtimes.push_back(timer1.get_time());\n        }\n        TIFFClose(tifvideo);\n        test_results.back().duration_ms=timer.get_time()/1e3;\n        test_results.back().success=true;\n        test_results.back().numImages=FRAMES;\n        reportRuntimes(name, runtimes, SPEEDTEST_REMOVESLOWEST_PERCENT, &test_results);\n    } else {\n        std::cout<<\"ERROR: could not open '\"<<filename<<\"' for writing!\\n\";\n        test_results.back().success=false;\n    }\n    if (test_results.back().success) {\n        std::cout<<\"* ==> SUCCESSFUL,   duration=\"<<test_results.back().duration_ms<<\"ms\\n\";\n    } else {\n        std::cout<<\"* ==> FAILED\\n\";\n    }\n#endif\n}",
    "char *initTiff3DFile ( char *filename, unsigned int sz0, unsigned int sz1, unsigned int sz2, unsigned int sz3, int datatype ) {\r\n//int initTiff3DFile ( char *filename, uint32 XSIZE, uint32 YSIZE, uint16 spp, uint16 Npages, int datatype){\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffInitData)\r\n    #endif\r\n\r\n\tuint32 XSIZE  = sz0;\r\n\tuint32 YSIZE  = sz1;\r\n\tuint16 Npages = sz2;\r\n\tuint16 spp    = sz3;\r\n\r\n\tuint16 bpp=8 * datatype;\r\n\t\r\n\tint check;\r\n \r\n\tif ( sz3 == 1 )\r\n\t\tspp = sz3; \r\n\telse if ( sz3 < 4 )\r\n\t\tspp = 3;\r\n\telse\r\n\t\treturn ((char *) \"More than 3 channels in Tiff files.\");\r\n\r\n\tunsigned char *fakeData=new unsigned char[((iim::sint64) XSIZE) * ((iim::sint64) YSIZE) * spp * (bpp/8)];\r\n\r\n\tchar *completeFilename = (char *) 0;\r\n\tint fname_len = (int) strlen(filename);\r\n\tchar *suffix = strstr(filename,\".tif\");\r\n\twhile ( suffix && (fname_len - (suffix-filename) > 5) )\r\n\t\tsuffix = strstr(suffix+4,\".tif\");\r\n\t//if ( (suffix != 0) && (fname_len - (suffix-filename) <= 5) ) { // a substring \".tif is already at the end of the filename\r\n\tif ( suffix ) { // a substring \".tif is already at the very end of the filename\r\n\t\tcompleteFilename = new char[fname_len+1];\r\n\t\tstrcpy(completeFilename,filename);\r\n\t}\r\n\telse {\t\r\n\t\tcompleteFilename = new char[fname_len+4+1];\r\n\t\tstrcpy(completeFilename,filename);\r\n\t\tstrcat(completeFilename,\".\");\r\n\t\tstrcat(completeFilename,TIFF3D_SUFFIX);\r\n\t}\r\n\r\n\r\n\t// 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffInitData, tf::CPU, tf::strprintf(\"generated fake data for 3D tiff \\\"%s\\\"\", completeFilename))\r\n    TERAFLY_TIME_RESTART(TiffInitData)\r\n    #endif\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\tTIFF *output;\r\n\t\r\n\tiim::sint64 expectedSize = ((iim::sint64) sz0) * ((iim::sint64) sz1) * ((iim::sint64) sz2) * ((iim::sint64) sz3) * ((iim::sint64) datatype); \r\n\r\n\tif ( bigtiff || expectedSize > (4*GBSIZE) ) {\r\n\t\tif ( (rowsPerStrip == -1 && (((iim::sint64) sz0) * ((iim::sint64) sz1)) > (4*GBSIZE)) || ((rowsPerStrip * ((iim::sint64) sz0)) > (4*GBSIZE)) )\r\n\t\t\t// one strip is larger than 4GB\r\n\t\t\treturn ((char *) \"Too many rows per strip for this image width.\");\r\n\t\telse \r\n\t\t\toutput = TIFFOpen(completeFilename,\"w8\");\r\n\t}\r\n\telse\r\n\t\toutput = TIFFOpen(completeFilename,\"w\");\r\n\r\n\r\n\tif (!output) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_IMAGEWIDTH, XSIZE);\r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the image width.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_IMAGELENGTH, YSIZE);\r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the image height.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, bpp); \r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the image bit per sample.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, spp);\r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the image sample per pixel.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, (rowsPerStrip == -1) ? YSIZE : (uint32)rowsPerStrip); \r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the image rows per strip.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT); \r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the image orientation.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_COMPRESSION, compressed ? COMPRESSION_LZW : COMPRESSION_NONE);\r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the compression tag.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the planarconfig tag.\");\r\n    }\r\n\r\n\tif ( spp == 1 )\r\n\t\tcheck = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\t\r\n\telse // spp == 3\r\n\t\tcheck = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\t\r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the photometric tag.\");\r\n    }\r\n\r\n\t/* We are writing single page of the multipage file */\r\n\tcheck = TIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the subfiletype tag.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_PAGENUMBER, 0, Npages); \r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the page number.\");\r\n    }\r\n\r\n\r\n\t//check = (int)TIFFWriteEncodedStrip(output, 0, fakeData, XSIZE * YSIZE);\r\n\t//if (!check) {\r\n\t//\tdelete completeFilename;\r\n\t//\treturn ((char *) \"Cannot write encoded strip to file.\");\r\n //   }\r\n\r\n\tif ( rowsPerStrip == -1 ) {\r\n\t\tcheck = TIFFWriteEncodedStrip(output, 0, fakeData, XSIZE * YSIZE * spp * (bpp/8));\r\n\t\tif (!check) {\r\n\t\t\tdelete completeFilename;\r\n\t\t\treturn ((char *) \"Cannot write encoded strip to file.\");\r\n\t\t}\r\n\t}\r\n\telse { \r\n\t\tint check,StripsPerImage,LastStripSize;\r\n\t\tuint32 rps = (uint32)rowsPerStrip;\r\n\t\tunsigned char *buf = fakeData;\r\n\r\n\t\tStripsPerImage =  (YSIZE + rps - 1) / rps;\r\n\t\tLastStripSize = YSIZE % rps;\r\n\t\tif (LastStripSize==0)\r\n\t\t\tLastStripSize=rps;\r\n\r\n\t\tfor (int i=0; i < StripsPerImage-1; i++){\r\n\t\t\tcheck = TIFFWriteEncodedStrip(output, i, buf, spp * rps * XSIZE * (bpp/8));\r\n\t\t\tif (!check) {\r\n\t\t\t\tdelete completeFilename;\r\n\t\t\t\treturn ((char *) \"Cannot write encoded strip to file.\");\r\n\t\t\t}\r\n\t\t\tbuf = buf + spp * rps * XSIZE * (bpp/8);\r\n\t\t}\r\n\r\n\t\tcheck = TIFFWriteEncodedStrip(output, StripsPerImage-1, buf, spp * LastStripSize * XSIZE * (bpp/8));\r\n\t\tif (!check) {\r\n\t\t\tdelete completeFilename;\r\n\t\t\treturn ((char *) \"Cannot write encoded strip to file.\");\r\n\t\t}\r\n\t\t//}\r\n\t\tbuf = buf + spp * LastStripSize * XSIZE * (bpp/8);\r\n\t}\r\n\r\n\tdelete[] fakeData;\r\n\r\n\tcheck = TIFFWriteDirectory(output);\r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot write a new directory.\");\r\n    }\r\n\r\n\tTIFFClose(output);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffInitData, tf::IO, tf::strprintf(\"written initialized 3D tiff \\\"%s\\\"\", completeFilename))\r\n    #endif\r\n\r\n\tdelete completeFilename;\r\n\r\n\treturn (char *) 0;\r\n}",
    "char *appendSlice2Tiff3DFile ( char *filename, int slice, unsigned char *img, unsigned int img_width, unsigned int img_height ) {\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffAppendData)\r\n    #endif\r\n\r\n\tTIFF *output;\r\n\tuint16 spp, bpp, NPages, pg0;\r\n\tuint32 rperstrip;\r\n\tuint16 cmprssd;\r\n\tuint16 photomtrcintrp;\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\toutput=TIFFOpen(filename,\"r\");\r\n\tTIFFGetField(output, TIFFTAG_BITSPERSAMPLE, &bpp); \r\n\tTIFFGetField(output, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tTIFFGetField(output, TIFFTAG_PAGENUMBER, &pg0, &NPages);\r\n\tTIFFGetField(output, TIFFTAG_ROWSPERSTRIP, &rperstrip);\r\n\tTIFFGetField(output, TIFFTAG_COMPRESSION, &cmprssd);\r\n\tTIFFGetField(output, TIFFTAG_PHOTOMETRIC, &photomtrcintrp);\r\n\tTIFFClose(output);\r\n\r\n\tiim::sint64 expectedSize = ((iim::sint64) img_width) * ((iim::sint64) img_height) * ((iim::sint64) NPages) * ((iim::sint64) spp) * ((iim::sint64) (bpp/8)); \r\n\r\n\tif ( bigtiff || expectedSize > (4*GBSIZE) ) {\r\n\t\tif ( (rowsPerStrip == -1 && (((iim::sint64) img_width) * ((iim::sint64) img_height)) > (4*GBSIZE)) || ((rowsPerStrip * ((iim::sint64) img_width)) > (4*GBSIZE)) )\r\n\t\t\t// one strip is larger than 4GB\r\n\t\t\treturn ((char *) \"Too many rows per strip for this image width.\");\r\n\t\telse \r\n\t\t\toutput = (slice==0)? TIFFOpen(filename,\"w8\") : TIFFOpen(filename,\"a8\");\r\n\t}\r\n\telse\r\n\t\toutput = (slice==0)? TIFFOpen(filename,\"w\") : TIFFOpen(filename,\"a\");\r\n\r\n\tTIFFSetDirectory(output,slice); // WARNING: slice must be the first page after the last, otherwise the file can be corrupted\r\n\r\n\tTIFFSetField(output, TIFFTAG_IMAGEWIDTH, img_width);\r\n\tTIFFSetField(output, TIFFTAG_IMAGELENGTH, img_height);\r\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, bpp); \r\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, spp);\r\n\tTIFFSetField(output, TIFFTAG_ROWSPERSTRIP, rperstrip);\r\n\tTIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n\tTIFFSetField(output, TIFFTAG_COMPRESSION, cmprssd);\r\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, photomtrcintrp);\t\r\n\t// We are writing single page of the multipage file \r\n\tTIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n\tTIFFSetField(output, TIFFTAG_PAGENUMBER, (uint16)slice, NPages); \r\n\r\n\tif ( rowsPerStrip == -1 ) \r\n\t\tTIFFWriteEncodedStrip(output, 0, img, img_width * img_height * spp * (bpp/8));\r\n\telse { \r\n\t\tint check,StripsPerImage,LastStripSize;\r\n\t\tuint32 rps = rperstrip;\r\n\t\tunsigned char *buf = img;\r\n\r\n\t\tStripsPerImage =  (img_height + rps - 1) / rps;\r\n\t\tLastStripSize = img_height % rps;\r\n\t\tif (LastStripSize==0)\r\n\t\t\tLastStripSize=rps;\r\n\r\n\t\tfor (int i=0; i < StripsPerImage-1; i++){\r\n\t\t\tTIFFWriteEncodedStrip(output, i, buf, spp * rps * img_width * (bpp/8));\r\n\t\t\tbuf = buf + spp * rps * img_width * (bpp/8);\r\n\t\t}\r\n\r\n\t\tTIFFWriteEncodedStrip(output, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\r\n\t\tbuf = buf + spp * LastStripSize * img_width * (bpp/8);\r\n\t}\r\n\t//img +=  img_width * img_height;\r\n\r\n\tTIFFWriteDirectory(output);\r\n\r\n\tTIFFClose(output);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffAppendData, tf::IO, tf::strprintf(\"appended slice %d x %d to 3D tiff \\\"%s\\\"\", img_width, img_height, filename))\r\n    #endif\r\n\r\n\treturn (char *) 0;\r\n}",
    "char *appendSlice2Tiff3DFile ( void *fhandler, int slice, unsigned char *img, unsigned int  img_width, unsigned int  img_height, int spp, int bpp, int NPages ) {\r\n\tTIFF *output = (TIFF *) fhandler;\r\n\r\n\tTIFFSetDirectory(output,slice); // WARNING: slice must be the first page after the last, otherwise the file can be corrupted\r\n\r\n\tTIFFSetField(output, TIFFTAG_IMAGEWIDTH, img_width);\r\n\tTIFFSetField(output, TIFFTAG_IMAGELENGTH, img_height);\r\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, (uint16)bpp); \r\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, (uint16)spp);\r\n\tTIFFSetField(output, TIFFTAG_ROWSPERSTRIP, (rowsPerStrip == -1) ? img_height : (uint32)rowsPerStrip);\r\n\tTIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n\tTIFFSetField(output, TIFFTAG_COMPRESSION, compressed ? COMPRESSION_LZW : COMPRESSION_NONE);\r\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n\tif ( spp == 1 )\r\n\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\t\r\n\telse // spp == 3\r\n\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\t\r\n\t// We are writing single page of the multipage file \r\n\tTIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n\tTIFFSetField(output, TIFFTAG_PAGENUMBER, (uint16)slice, (uint16)NPages); \r\n\r\n\t// the file has been already opened: rowsPerStrip it is not too large for this image width\r\n\tif ( rowsPerStrip == -1 ) \r\n\t\tTIFFWriteEncodedStrip(output, 0, img, img_width * img_height * spp * (bpp/8));\r\n\telse { \r\n\t\tint check,StripsPerImage,LastStripSize;\r\n\t\tuint32 rps = (uint32)rowsPerStrip;\r\n\t\tunsigned char *buf = img;\r\n\r\n\t\tStripsPerImage =  (img_height + rps - 1) / rps;\r\n\t\tLastStripSize = img_height % rps;\r\n\t\tif (LastStripSize==0)\r\n\t\t\tLastStripSize=rps;\r\n\r\n\t\tfor (int i=0; i < StripsPerImage-1; i++){\r\n\t\t\tTIFFWriteEncodedStrip(output, i, buf, spp * rps * img_width * (bpp/8));\r\n\t\t\tbuf = buf + spp * rps * img_width * (bpp/8);\r\n\t\t}\r\n\r\n\t\tTIFFWriteEncodedStrip(output, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\r\n\t\tbuf = buf + spp * LastStripSize * img_width * (bpp/8);\r\n\t}\r\n\t//img +=  img_width * img_height;\r\n\r\n\tTIFFWriteDirectory(output);\r\n\r\n\treturn (char *) 0;\r\n}",
    "bool Export_3DTiff_Workspace::exportHelper() {\n\n    range = 255;\n\n    const int samplesPerPixel = 1;\n    const int bitsPerSample = 8;\n\n    std::vector<uint8_t> svec(width);\n\n    TIFF *output_image;\n\n    if((output_image = TIFFOpen(fileName.c_str(), \"w\")) == NULL){\n        std::cerr << \"Unable to write tif file: \" << \"image.tiff\" << std::endl;\n        return false;\n    }\n\n    for (int page = 0; page < numberOfPages; page++) {\n\n        TIFFSetField(output_image,TIFFTAG_IMAGEWIDTH, width);\n        TIFFSetField(output_image,TIFFTAG_SAMPLESPERPIXEL, samplesPerPixel);\n        TIFFSetField(output_image,TIFFTAG_BITSPERSAMPLE, bitsPerSample);\n        TIFFSetField(output_image,TIFFTAG_ORIENTATION, (int)ORIENTATION_TOPLEFT);\n        TIFFSetField(output_image,TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n        TIFFSetField(output_image,TIFFTAG_ROWSPERSTRIP, height / samplesPerPixel);\n        TIFFSetField(output_image,TIFFTAG_XRESOLUTION, 100.0);\n        TIFFSetField(output_image,TIFFTAG_YRESOLUTION, 100.0);\n        TIFFSetField(output_image,TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\n        // specify that it's a page within the multipage file\n        TIFFSetField(output_image,TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n        // specify the page number\n        TIFFSetField(output_image,TIFFTAG_PAGENUMBER, page, numberOfPages);\n\n        if(normalized) {\n            for (int y = 0; y < height; y++) {\n                for(int i=0;i<width;i++) {\n                    svec[i] = (uint8_t)((range*(work->matrix(i,y,page)-min)/(max-min)));\n                }\n                if (TIFFWriteScanline(output_image,&svec[0], y, 0)==-1) {\n                    std::cout << \"Complete or error\" << std::endl;\n                }\n            }\n        }\n        else {\n            for (int y = 0; y < height; y++) {\n                for(int i=0;i<width;i++) {\n                    svec[i] = (uint8_t)work->matrix(i,y,page);\n                }\n                if (TIFFWriteScanline(output_image,&svec[0], y, 0)==-1) {\n                    std::cout << \"Complete or error\" << std::endl;\n                }\n            }\n        }\n\n        TIFFWriteDirectory(output_image);\n    }\n\n\n    return true;\n\n}",
    "void AperioSVSWriter::writeThumbnail() {\r\n  unsigned long w = 0, h = 0, nrsamples = 0;\r\n  TIFF* lowestResTiff = TIFFOpen(_levelFiles[_levelFiles.size()-1].c_str(), \"r\");\r\n  TIFFGetField(lowestResTiff, TIFFTAG_IMAGEWIDTH, &w);\r\n  TIFFGetField(lowestResTiff, TIFFTAG_IMAGELENGTH, &h);\r\n  TIFFGetField(lowestResTiff, TIFFTAG_SAMPLESPERPIXEL, &nrsamples);\r\n\r\n  setBaseTags(_tiff);\r\n  TIFFSetField(_tiff, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\r\n  TIFFSetField(_tiff, TIFFTAG_JPEGQUALITY, 70);\r\n  TIFFSetField(_tiff, TIFFTAG_ROWSPERSTRIP, 16);\r\n  TIFFSetField(_tiff, TIFFTAG_IMAGEWIDTH, w);\r\n  TIFFSetField(_tiff, TIFFTAG_IMAGELENGTH, h);\r\n  TIFFSetField(_tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER);\r\n  TIFFSetField(_tiff, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE);\r\n\r\n  unsigned int npixels = w * h * nrsamples;\r\n  T* raster = (T*)_TIFFmalloc(npixels * sizeof(T));\r\n  unsigned int nrTiles = TIFFNumberOfTiles(lowestResTiff);\r\n  unsigned int tileW = 0, tileH = 0;\r\n  TIFFGetField(lowestResTiff, TIFFTAG_TILEWIDTH, &tileW);\r\n  TIFFGetField(lowestResTiff, TIFFTAG_TILELENGTH, &tileH);\r\n  T* tile = (T*)_TIFFmalloc(tileW * tileH * nrsamples * sizeof(T));\r\n  JPEG2000Codec cod;\r\n  for (unsigned int tileY = 0; tileY < h; tileY += tileH) {\r\n    for (unsigned int tileX = 0; tileX < w; tileX += tileW) {\r\n      if (getCompression() == Compression::JPEG2000) {\r\n        unsigned int no = TIFFComputeTile(lowestResTiff, tileX, tileY, 0, 0);\r\n        unsigned int rawSize = TIFFReadRawTile(lowestResTiff, no, tile, tileW*tileH*nrsamples*sizeof(T));\r\n        cod.decode((unsigned char*)tile, rawSize, tileW*tileH*nrsamples*sizeof(T));\r\n      }\r\n      else {\r\n        TIFFReadTile(lowestResTiff, tile, tileX, tileY, 0, 0);\r\n      }\r\n      for (unsigned int y = 0; y < tileH; ++y){\r\n        for (unsigned int x = 0; x < tileW; ++x){\r\n          if ((tileX + x) < w && (tileY + y) < h) {\r\n            for (unsigned int s = 0; s < nrsamples; ++s) {\r\n              (*(raster + (tileY + y) * w * nrsamples + (tileX + x) * nrsamples + s)) = (*(tile + y * tileW * nrsamples + x * nrsamples + s));\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  _TIFFfree(tile);\r\n  tile = NULL;\r\n  if (raster != NULL) {\r\n    unsigned int nrOfStrips = TIFFNumberOfStrips(_tiff);\r\n    for (unsigned int i = 0; i < nrOfStrips; ++i) {\r\n      T* strip = (T*)_TIFFmalloc(16 * w * nrsamples * sizeof(T));\r\n      unsigned int startOfStrip = i * 16 * w * nrsamples;\r\n      unsigned int endOfStrip = (i + 1) * 16 * w * nrsamples;\r\n      if (endOfStrip>npixels) {\r\n        endOfStrip = npixels;\r\n      }\r\n      for (unsigned int j = startOfStrip, k = 0; j < endOfStrip; ++j, ++k) {\r\n        T val = *(raster + j);\r\n        *(strip + k) = val;\r\n      }\r\n      TIFFWriteEncodedStrip(_tiff, i, strip, 16 * w * nrsamples * sizeof(T));\r\n      _TIFFfree(strip);\r\n    }\r\n    _TIFFfree(raster);\r\n  }\r\n\r\n  TIFFClose(lowestResTiff);\r\n  lowestResTiff = NULL;\r\n  if (TIFFNumberOfDirectories(_tiff) > 1) {\r\n    TIFFSetField(_tiff, TIFFTAG_IMAGEDESCRIPTION, \"Aperio Image macro\");\r\n  }\r\n  TIFFWriteDirectory(_tiff);\r\n}",
    "int MultiResolutionImageWriter::writePyramidToDisk() {\r\n\r\n\t//! First get the overall image width and height;\r\n\tunsigned long w = 0, h = 0, nrsamples = 0, nrbits = 0;\r\n\t// TIFF idiosyncracy, when setting resolution tags one uses doubles,\r\n\t// getting them requires floats\r\n\tfloat spacingX = 0, spacingY = 0;\r\n\tstd::vector<double> spacing;\r\n\tTIFFGetField(_tiff, TIFFTAG_IMAGEWIDTH, &w);\r\n\tTIFFGetField(_tiff, TIFFTAG_IMAGELENGTH, &h);\r\n\tTIFFGetField(_tiff, TIFFTAG_SAMPLESPERPIXEL, &nrsamples);\r\n\tTIFFGetField(_tiff, TIFFTAG_BITSPERSAMPLE, &nrbits);\r\n\tif (TIFFGetField(_tiff, TIFFTAG_XRESOLUTION, &spacingX) == 1) {\r\n\t\tif (TIFFGetField(_tiff, TIFFTAG_YRESOLUTION, &spacingY) == 1) {\r\n\t\t\tspacing.push_back(1. / (spacingX / (10000.)));\r\n\t\t\tspacing.push_back(1. / (spacingY / (10000.)));\r\n\t\t}\r\n\t}\r\n\t// Determine the amount of pyramid levels\r\n\tunsigned int pyramidlevels = 1;\r\n\tunsigned int lowestwidth = w;\r\n\tif (_maxPyramidLevels < 0) {\r\n\t\twhile (lowestwidth > 1024) {\r\n\t\t\tlowestwidth /= _downsamplePerLevel;\r\n\t\t\tpyramidlevels += 1;\r\n\t\t}\r\n\t\tif (abs(1024. - lowestwidth) > abs(1024. - lowestwidth * 2)) {\r\n\t\t\tlowestwidth *= _downsamplePerLevel;\r\n\t\t\tpyramidlevels -= 1;\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tpyramidlevels = _maxPyramidLevels;\r\n\t\tlowestwidth /= pow(_downsamplePerLevel, pyramidlevels);\r\n\t}\r\n\t// Setup the image directory for the thumbnail\r\n\tunsigned int lowestheight = (unsigned int)(h / pow(_downsamplePerLevel, (double)pyramidlevels));\r\n\r\n\t// Write temporary image to store previous level (LibTiff does not allow to go back and forth between\r\n\t// empty directories\r\n#ifdef WIN32\r\n\tsize_t found = _fileName.find_last_of(\"/\\\\\");\r\n#else \r\n\tsize_t found = _fileName.find_last_of(\"/\");\r\n#endif\r\n\tstring tmpPth = _fileName.substr(0, found + 1);\r\n\tstring fileName = _fileName.substr(found + 1);\r\n\tsize_t dotLoc = fileName.find_last_of(\".\");\r\n\tstring baseName = fileName.substr(0, dotLoc);\r\n\tfor (unsigned int level = 1; level <= pyramidlevels; ++level) {\r\n\t\tif (_monitor) {\r\n\t\t\t_monitor->setProgress((_monitor->maximumProgress() / 2.) + (static_cast<float>(level) / static_cast<float>(pyramidlevels))* (_monitor->maximumProgress() / 4.));\r\n\t\t}\r\n\t\tTIFF* prevLevelTiff = _tiff;\r\n\t\tif (level != 1) {\r\n\t\t\tstd::stringstream ssm;\r\n\t\t\tssm << tmpPth << \"temp\" << baseName << \"Level\" << level - 1 << \".tif\";\r\n\t\t\tprevLevelTiff = TIFFOpen(ssm.str().c_str(), \"r\");\r\n\t\t}\r\n\t\tstd::stringstream ssm;\r\n\t\tssm << tmpPth << \"temp\" << baseName << \"Level\" << level << \".tif\";\r\n\t\tTIFF* levelTiff = TIFFOpen(ssm.str().c_str(), \"w8\");\r\n\t\t_levelFiles.push_back(ssm.str());\r\n\t\tunsigned int levelw = (unsigned int)(w / pow(_downsamplePerLevel, (double)level));\r\n\t\tunsigned int levelh = (unsigned int)(h / pow(_downsamplePerLevel, (double)level));\r\n\t\tunsigned int prevLevelw = (unsigned int)(w / pow(_downsamplePerLevel, (double)level - 1));\r\n\t\tunsigned int prevLevelh = (unsigned int)(h / pow(_downsamplePerLevel, (double)level - 1));\r\n\t\tsetTempPyramidTags(levelTiff, levelw, levelh);\r\n\t\tunsigned int nrTilesX = (unsigned int)ceil(float(levelw) / _tileSize);\r\n\t\tunsigned int nrTilesY = (unsigned int)ceil(float(levelh) / _tileSize);\r\n\t\tunsigned int levelTiles = nrTilesX * nrTilesY;\r\n\t\tunsigned int npixels = _tileSize * _tileSize * nrsamples;\r\n\t\tint rowOrg = -_downsamplePerLevel, colOrg = 0;\r\n\t\tfor (unsigned int i = 0; i < levelTiles; ++i) {\r\n\t\t\tif (i % nrTilesX == 0) {\r\n\t\t\t\trowOrg += _downsamplePerLevel;\r\n\t\t\t\tcolOrg = 0;\r\n\t\t\t}\r\n\t\t\tunsigned int xpos = _tileSize * colOrg;\r\n\t\t\tunsigned int ypos = _tileSize * rowOrg;\r\n\t\t\tint inpTilesForOutpTile = _downsamplePerLevel * _downsamplePerLevel;\r\n\t\t\tstd::vector<T*> tiles;\r\n\t\t\tstd::vector<bool> tiles_valid;\r\n\t\t\tfor (int inTileNr = 0; inTileNr < inpTilesForOutpTile; ++inTileNr) {\r\n\t\t\t\ttiles.push_back((T*)_TIFFmalloc(npixels * sizeof(T)));\r\n\t\t\t\ttiles_valid.push_back(false);\r\n\t\t\t}\r\n\t\t\tT* outTile = (T*)_TIFFmalloc(npixels * sizeof(T));\r\n\t\t\tunsigned int size = npixels * sizeof(T);\r\n\t\t\tif (level == 1 && (getCompression() == Compression::JPEG2000)) {\r\n\t\t\t\tfor (int inRow = 0; inRow < _downsamplePerLevel; inRow++) {\r\n\t\t\t\t\tfor (int inCol = 0; inCol < _downsamplePerLevel; inCol++) {\r\n\t\t\t\t\t\tif (xpos + inCol * _tileSize >= prevLevelw || ypos + inRow * _tileSize >= prevLevelh) {\r\n\t\t\t\t\t\t\tstd::fill_n(tiles[inRow * _downsamplePerLevel + inCol], npixels, static_cast<T>(0));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tint tileNr = TIFFComputeTile(prevLevelTiff, xpos + inCol * _tileSize, ypos + inRow * _tileSize, 0, 0);\r\n\t\t\t\t\t\t\tunsigned int outTileSize = _tileSize * _tileSize * nrsamples * (nrbits / 8);\r\n\t\t\t\t\t\t\tint rawSize = TIFFReadRawTile(prevLevelTiff, tileNr, tiles[inRow * _downsamplePerLevel + inCol], outTileSize);\r\n\t\t\t\t\t\t\tif (rawSize > 0) {\r\n\t\t\t\t\t\t\t\ttiles_valid[inRow * _downsamplePerLevel + inCol] = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tstd::fill_n(tiles[inRow * _downsamplePerLevel + inCol], npixels, static_cast<T>(0));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfor (int inRow = 0; inRow < _downsamplePerLevel; inRow++) {\r\n\t\t\t\t\tfor (int inCol = 0; inCol < _downsamplePerLevel; inCol++) {\r\n\t\t\t\t\t\tif (xpos + inCol * _tileSize >= prevLevelw || ypos + inRow * _tileSize >= prevLevelh) {\r\n\t\t\t\t\t\t\tstd::fill_n(tiles[inRow * _downsamplePerLevel + inCol], npixels, static_cast<T>(0));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (TIFFReadTile(prevLevelTiff, tiles[inRow * _downsamplePerLevel + inCol], xpos + inCol * _tileSize, ypos + inRow * _tileSize, 0, 0) < 0) {\r\n\t\t\t\t\t\t\t\tstd::fill_n(tiles[inRow * _downsamplePerLevel + inCol], npixels, static_cast<T>(0));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\ttiles_valid[inRow * _downsamplePerLevel + inCol] = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (std::any_of(tiles_valid.begin(), tiles_valid.end(), [](bool v) { return v; })) {\r\n\t\t\t\tstd::vector<T*> dsTiles;\r\n\t\t\t\tfor (auto tile : tiles) {\r\n\t\t\t\t\tdsTiles.push_back(downscaleTile(tile, _tileSize, nrsamples));\r\n\t\t\t\t}\r\n\t\t\t\tunsigned int dsSize = _tileSize / _downsamplePerLevel;\r\n\t\t\t\tfor (unsigned int y = 0; y < _tileSize; ++y) {\r\n\t\t\t\t\tfor (unsigned int x = 0; x < _tileSize; ++x) {\r\n\t\t\t\t\t\tfor (unsigned int s = 0; s < nrsamples; ++s) {\r\n\t\t\t\t\t\t\tunsigned int outIndex = nrsamples * (y * _tileSize + x) + s;\r\n\t\t\t\t\t\t\tunsigned int colTile = std::floor(x / dsSize);\r\n\t\t\t\t\t\t\tunsigned int rowTile = std::floor(y / dsSize);\r\n\t\t\t\t\t\t\tunsigned int inIndex = y * dsSize * nrsamples + x * nrsamples + s;\r\n\t\t\t\t\t\t\tT* usedTile = dsTiles[rowTile * _downsamplePerLevel + colTile];\r\n\t\t\t\t\t\t\tinIndex = ((y - rowTile * dsSize) * dsSize * nrsamples) + ((x - colTile * dsSize) * nrsamples) + s;\r\n\t\t\t\t\t\t\tT val = *(usedTile + inIndex);\r\n\t\t\t\t\t\t\t*(outTile + outIndex) = val;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tTIFFWriteEncodedTile(levelTiff, i, outTile, npixels * sizeof(T));\r\n\t\t\t\tfor (auto tile : dsTiles) {\r\n\t\t\t\t\t_TIFFfree(tile);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (auto tile : tiles) {\r\n\t\t\t\t_TIFFfree(tile);\r\n\t\t\t}\r\n\t\t\t_TIFFfree(outTile);\r\n\t\t\tcolOrg += _downsamplePerLevel;\r\n\t\t}\r\n\t\tif (level != 1) {\r\n\t\t\tTIFFClose(prevLevelTiff);\r\n\t\t}\r\n\t\tTIFFSetField(_tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER);\r\n\t\tif (!spacing.empty()) {\r\n\t\t\tspacing[0] *= _downsamplePerLevel;\r\n\t\t\tspacing[1] *= _downsamplePerLevel;\r\n\t\t\tdouble pixPerCmX = (1. / spacing[0]) * 10000;\r\n\t\t\tdouble pixPerCmY = (1. / spacing[1]) * 10000;\r\n\t\t\tTIFFSetField(levelTiff, TIFFTAG_XRESOLUTION, pixPerCmX);\r\n\t\t\tTIFFSetField(levelTiff, TIFFTAG_YRESOLUTION, pixPerCmY);\r\n\t\t}\r\n\t\tTIFFClose(levelTiff);\r\n\t}\r\n\t//! Write base directory to disk\r\n\tTIFFWriteDirectory(_tiff);\r\n\treturn 0;\r\n}",
    "int MultiResolutionImageWriter::incorporatePyramid() {\r\n\tunsigned long nrsamples = 0;\r\n\r\n\t//// Now add all the pyramid levels\r\n\tfor (vector<string>::const_iterator it = _levelFiles.begin(); it != _levelFiles.end(); ++it) {\r\n\t\tif (_monitor) {\r\n\t\t\t_monitor->setProgress(3 * (_monitor->maximumProgress() / 4.) + ((static_cast<float>(it - _levelFiles.begin()) + 1.0) / static_cast<float>(_levelFiles.size()))* (_monitor->maximumProgress() / 4.));\r\n\t\t}\r\n\t\tTIFF* level = TIFFOpen(it->c_str(), \"rm\");\r\n\r\n\t\tfloat spacingX = 0, spacingY = 0;\r\n\t\tstd::vector<double> spacing;\r\n\t\tif (TIFFGetField(level, TIFFTAG_XRESOLUTION, &spacingX) == 1) {\r\n\t\t\tif (TIFFGetField(level, TIFFTAG_YRESOLUTION, &spacingY) == 1) {\r\n\t\t\t\tspacing.push_back(1. / (spacingX / (10000.)));\r\n\t\t\t\tspacing.push_back(1. / (spacingY / (10000.)));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tunsigned int levelw, levelh;\r\n\t\tTIFFGetField(level, TIFFTAG_IMAGEWIDTH, &levelw);\r\n\t\tTIFFGetField(level, TIFFTAG_IMAGELENGTH, &levelh);\r\n\t\tsetPyramidTags(_tiff, levelw, levelh);\r\n\t\tTIFFSetField(_tiff, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE);\r\n\t\tTIFFGetField(level, TIFFTAG_SAMPLESPERPIXEL, &nrsamples);\r\n\t\twritePyramidLevel<T>(level, levelw, levelh, nrsamples);\r\n\r\n\t\tsetSpacing(spacing);\r\n\t\tTIFFWriteDirectory(_tiff);\r\n\t\tTIFFClose(level);\r\n\t}\r\n\treturn 0;\r\n}",
    "void \nopenfile(int pageno)\n{\n  /* Compute filename */\n  const char *filename = outputfilename;\n  if (flag_eachpage)\n    {\n      sprintf(pagefilename, filename, pageno);\n      filename = pagefilename;\n    }\n  \n  /* Open */\n  if (flag_format == 't') /* tiff file */\n    { \n#if HAVE_TIFF\n      if (tiff) \n        {\n          if (! TIFFWriteDirectory(tiff))\n            die(i18n(\"Problem writing TIFF directory.\"));\n        }\n      else\n        {\n          if (! strcmp(filename,\"-\"))\n            die(i18n(\"TIFF output requires a valid output file name.\"));\n          if (! (tiff = TIFFOpen(filename, \"w\")))\n            die(i18n(\"Cannot open output tiff file '%s'.\"), filename);\n        }\n#else\n      die(i18n(\"TIFF output is not compiled\"));\n#endif\n    }\n  else if (flag_format == 'f') /* temporary tiff, later converted to pdf */\n    {\n#if HAVE_TIFF2PDF\n      if (tiff) \n        {\n          if (! TIFFWriteDirectory(tiff))\n            die(i18n(\"Problem writing directory in temporary TIFF file.\"));\n        }\n      else\n        {\n          if (! strcmp(filename,\"-\"))\n            die(i18n(\"PDF output requires a valid output file name.\"));\n          if (! (tempfilename = (char*)malloc(strlen(outputfilename) + 8)))\n            die(i18n(\"Out of memory.\"));\n          strcpy(tempfilename, outputfilename);\n          strcat(tempfilename, \".XXXXXX\");\n          tiff = 0;\n# ifdef _WIN32\n          if (_mktemp(tempfilename))\n            tiff = TIFFOpen(tempfilename,\"w\");\n# elif HAVE_MKSTEMP\n          if ((tiffd = mkstemp(tempfilename)) >= 0)\n            tiff = TIFFFdOpen(tiffd, tempfilename, \"w\");\n# else\n          if (mktemp(tempfilename))\n            if ((tiffd = open(tempfilename, O_RDWR|O_CREAT)) >= 0)\n              tiff = TIFFFdOpen(tiffd, tempfilename, \"w\");\n# endif\n          if (! tiff)\n            die(i18n(\"Cannot create temporary TIFF file '%s'.\"), tempfilename);\n        }\n#else\n      die(i18n(\"PDF output is not compiled\"));\n#endif\n    } \n  else if (! fout) /* file output */\n    {\n      if (! strcmp(filename,\"-\")) {\n        fout = stdout;\n#if defined(__CYGWIN32__)\n        setmode(fileno(fout), O_BINARY);\n#elif defined(_WIN32)\n        _setmode(_fileno(fout), _O_BINARY);\n#endif\n      } else if (! (fout = fopen(filename, \"wb\")))\n        die(i18n(\"Cannot open output file '%s'.\"), filename);\n    }\n}",
    "void GTiffDataset::Crystalize()\n\n{\n    if( bCrystalized )\n        return;\n\n    // TODO: libtiff writes extended tags in the order they are specified\n    // and not in increasing order.\n    WriteMetadata( this, hTIFF, true, osProfile, osFilename,\n                   papszCreationOptions );\n    WriteGeoTIFFInfo();\n    if( bNoDataSet )\n        WriteNoDataValue( hTIFF, dfNoDataValue );\n\n    bMetadataChanged = false;\n    bGeoTIFFInfoChanged = false;\n    bNoDataChanged = false;\n    bNeedsRewrite = false;\n\n    bCrystalized = true;\n\n    TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTiffDataset::Crystalize\");\n\n    TIFFWriteDirectory( hTIFF );\n    if( bStreamingOut )\n    {\n        // We need to write twice the directory to be sure that custom\n        // TIFF tags are correctly sorted and that padding bytes have been\n        // added.\n        TIFFSetDirectory( hTIFF, 0 );\n        TIFFWriteDirectory( hTIFF );\n\n        if( VSIFSeekL( fpL, 0, SEEK_END ) != 0 )\n        {\n            CPLError(CE_Failure, CPLE_FileIO, \"Could not seek\");\n        }\n        const int nSize = static_cast<int>( VSIFTellL(fpL) );\n\n        TIFFSetDirectory( hTIFF, 0 );\n        GTiffFillStreamableOffsetAndCount( hTIFF, nSize );\n        TIFFWriteDirectory( hTIFF );\n\n        vsi_l_offset nDataLength = 0;\n        void* pabyBuffer =\n            VSIGetMemFileBuffer( osTmpFilename, &nDataLength, FALSE);\n        if( static_cast<int>(\n                VSIFWriteL( pabyBuffer, 1,\n                            static_cast<int>(nDataLength), fpToWrite ) ) !=\n            static_cast<int>(nDataLength) )\n        {\n            CPLError( CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                      static_cast<int>(nDataLength) );\n        }\n        // In case of single strip file, there's a libtiff check that would\n        // issue a warning since the file hasn't the required size.\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        TIFFSetDirectory( hTIFF, 0 );\n        CPLPopErrorHandler();\n    }\n    else\n    {\n        TIFFSetDirectory( hTIFF, 0 );\n    }\n\n    RestoreVolatileParameters( hTIFF );\n\n    nDirOffset = TIFFCurrentDirOffset( hTIFF );\n}",
    "void GTiffWriteJPEGTables( TIFF* hTIFF,\n                           const char* pszPhotometric,\n                           const char* pszJPEGQuality,\n                           const char* pszJPEGTablesMode )\n{\n    // Would perhaps works with libtiff 3.X but didn't bother trying This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n#if defined(BIGTIFF_SUPPORT)\n    uint16 nBands = 0;\n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL,\n                        &nBands ) )\n        nBands = 1;\n\n    uint16 l_nBitsPerSample = 0;\n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE,\n                        &(l_nBitsPerSample)) )\n        l_nBitsPerSample = 1;\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf(\"%s%p\", szJPEGGTiffDatasetTmpPrefix, hTIFF);\n    VSILFILE* fpTmp = nullptr;\n    CPLString osTmp;\n    char** papszLocalParameters = nullptr;\n    const int nInMemImageWidth = 16;\n    const int nInMemImageHeight = 16;\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\" );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEG_QUALITY\",\n                                            pszJPEGQuality );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"PHOTOMETRIC\", pszPhotometric );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"BLOCKYSIZE\",\n                                            CPLSPrintf(\"%u\", nInMemImageHeight)\n                                          );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"NBITS\",\n                                            CPLSPrintf(\"%u\", l_nBitsPerSample));\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEGTABLESMODE\",\n                                            pszJPEGTablesMode );\n\n    TIFF* hTIFFTmp = GTiffDataset::CreateLL(\n                    osTmpFilenameIn, nInMemImageWidth, nInMemImageHeight,\n                    (nBands <= 4) ? nBands : 1,\n                    (l_nBitsPerSample <= 8) ? GDT_Byte : GDT_UInt16, 0.0,\n                    papszLocalParameters, &fpTmp, osTmp );\n    CSLDestroy(papszLocalParameters);\n    if( hTIFFTmp )\n    {\n        uint16 l_nPhotometric = 0;\n        int nJpegTablesModeIn = 0;\n        TIFFGetField( hTIFFTmp, TIFFTAG_PHOTOMETRIC, &(l_nPhotometric) );\n        TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                        &nJpegTablesModeIn );\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now, reset quality and jpegcolormode.\n        const int l_nJpegQuality = pszJPEGQuality ? atoi(pszJPEGQuality) : 0;\n        if(l_nJpegQuality > 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGQUALITY, l_nJpegQuality);\n        if( l_nPhotometric == PHOTOMETRIC_YCBCR\n            && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGCOLORMODE,\n                            JPEGCOLORMODE_RGB);\n        }\n        if( nJpegTablesModeIn >= 0 )\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                            nJpegTablesModeIn);\n\n        int nBlockSize = nInMemImageWidth * nInMemImageHeight *\n                                        ((nBands <= 4) ? nBands : 1);\n        if( l_nBitsPerSample == 12 )\n            nBlockSize = (nBlockSize * 3) / 2;\n        std::vector<GByte> abyZeroData( nBlockSize, 0 );\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, &abyZeroData[0], nBlockSize);\n\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSize,\n                            &pJPEGTable) )\n            TIFFSetField( hTIFF, TIFFTAG_JPEGTABLES, nJPEGTableSize,\n                            pJPEGTable);\n\n        float *ref = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_REFERENCEBLACKWHITE, &ref) )\n            TIFFSetField(hTIFF, TIFFTAG_REFERENCEBLACKWHITE, ref);\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n    VSIUnlink(osTmpFilenameIn);\n#endif\n}",
    "int GTiffDataset::GuessJPEGQuality( bool& bOutHasQuantizationTable,\n                                    bool& bOutHasHuffmanTable )\n{\n    CPLAssert( nCompression == COMPRESSION_JPEG );\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    if( !TIFFGetField(hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize, &pJPEGTable) )\n    {\n        bOutHasQuantizationTable = false;\n        bOutHasHuffmanTable = false;\n        return -1;\n    }\n\n    bOutHasQuantizationTable =\n        GTIFFFindNextTable( static_cast<const GByte*>(pJPEGTable), 0xDB,\n                            nJPEGTableSize, nullptr) != nullptr;\n    bOutHasHuffmanTable =\n        GTIFFFindNextTable( static_cast<const GByte*>(pJPEGTable), 0xC4,\n                            nJPEGTableSize, nullptr) != nullptr;\n    if( !bOutHasQuantizationTable )\n        return -1;\n\n    char** papszLocalParameters = nullptr;\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\");\n    if( nPhotometric == PHOTOMETRIC_YCBCR )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"YCBCR\");\n    else if( nPhotometric == PHOTOMETRIC_SEPARATED )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"CMYK\");\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"BLOCKYSIZE\", \"16\");\n    if( nBitsPerSample == 12 )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                \"NBITS\", \"12\");\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf( \"/vsimem/gtiffdataset_guess_jpeg_quality_tmp_%p\",\n                            this );\n\n    int nRet = -1;\n    for( int nQuality = 0; nQuality <= 100 && nRet < 0; ++nQuality )\n    {\n        VSILFILE* fpTmp = nullptr;\n        if( nQuality == 0 )\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                   \"JPEG_QUALITY\", \"75\");\n        else\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                \"JPEG_QUALITY\", CPLSPrintf(\"%d\", nQuality));\n\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        CPLString osTmp;\n        TIFF* hTIFFTmp =\n            CreateLL( osTmpFilenameIn, 16, 16, (nBands <= 4) ? nBands : 1,\n                      GetRasterBand(1)->GetRasterDataType(), 0.0,\n                      papszLocalParameters, &fpTmp, osTmp );\n        CPLPopErrorHandler();\n        if( !hTIFFTmp )\n        {\n            break;\n        }\n\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now reset jpegcolormode.\n        if( nPhotometric == PHOTOMETRIC_YCBCR\n            && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n\n        GByte abyZeroData[(16*16*4*3)/2] = {};\n        const int nBlockSize =\n            (16 * 16 * ((nBands <= 4) ? nBands : 1) * nBitsPerSample) / 8;\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, abyZeroData, nBlockSize);\n\n        uint32 nJPEGTableSizeTry = 0;\n        void* pJPEGTableTry = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES,\n                         &nJPEGTableSizeTry, &pJPEGTableTry) )\n        {\n            if( GTIFFQuantizationTablesEqual(\n                   static_cast<GByte *>(pJPEGTable), nJPEGTableSize,\n                   static_cast<GByte *>(pJPEGTableTry), nJPEGTableSizeTry) )\n            {\n                nRet = (nQuality == 0 ) ? 75 : nQuality;\n            }\n        }\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n\n    CSLDestroy(papszLocalParameters);\n    VSIUnlink(osTmpFilenameIn);\n\n    return nRet;\n}",
    "INGR_VirtualFile CPL_STDCALL INGR_CreateVirtualFile( const char *pszFilename,\n                                                     INGR_Format eFormat,\n                                                     int nXSize,\n                                                     int nYSize,\n                                                     int nTileSize,\n                                                     int nQuality,\n                                                     GByte *pabyBuffer,\n                                                     int nBufferSize,\n                                                     int nBand )\n{\n    INGR_VirtualFile hVirtual = {nullptr, nullptr, nullptr};\n\n    hVirtual.pszFileName = CPLSPrintf( \"/vsimem/%s.virtual\",\n        CPLGetBasename( pszFilename ) );\n\n    int nJPGComponents = 1;\n\n    switch( eFormat )\n    {\n    case JPEGRGB:\n        nJPGComponents = 3;\n        CPL_FALLTHROUGH\n    case JPEGGRAY:\n        {\n            GByte *pabyHeader = (GByte*) CPLCalloc( 1, 2048 );\n            int nHeaderSize   = JPGHLP_HeaderMaker( pabyHeader,\n                                                    nTileSize,\n                                                    nTileSize,\n                                                    nJPGComponents,\n                                                    0,\n                                                    nQuality );\n            VSILFILE *fp = VSIFOpenL( hVirtual.pszFileName, \"w+\" );\n            VSIFWriteL( pabyHeader, 1, nHeaderSize, fp );\n            VSIFWriteL( pabyBuffer, 1, nBufferSize, fp );\n            VSIFCloseL( fp );\n            CPLFree( pabyHeader );\n            break;\n        }\n    case CCITTGroup4:\n        {\n            REVERSEBITSBUFFER( pabyBuffer, nBufferSize );\n            VSILFILE *fpL = VSIFOpenL( hVirtual.pszFileName, \"w+\" );\n            TIFF *hTIFF = VSI_TIFFOpen( hVirtual.pszFileName, \"w+\", fpL );\n            if( hTIFF == nullptr ) /* shouldn't happen */\n                return hVirtual;\n            TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH,      nXSize );\n            TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH,     nYSize );\n            TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE,   1 );\n            TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT,    SAMPLEFORMAT_UINT );\n            TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG,    PLANARCONFIG_CONTIG );\n            TIFFSetField( hTIFF, TIFFTAG_FILLORDER,       FILLORDER_MSB2LSB );\n            TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP,    -1 );\n            TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, 1 );\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC,     PHOTOMETRIC_MINISWHITE );\n            TIFFSetField( hTIFF, TIFFTAG_COMPRESSION,     COMPRESSION_CCITTFAX4 );\n            TIFFWriteRawStrip( hTIFF, 0, pabyBuffer, nBufferSize );\n            TIFFWriteDirectory( hTIFF );\n            TIFFClose( hTIFF );\n            VSIFCloseL(fpL);\n            break;\n        }\n    default:\n        return hVirtual;\n    }",
    "CPLErr GTIFMemBufFromWktEx( const char *pszWKT, const double *padfGeoTransform,\n                            int nGCPCount, const GDAL_GCP *pasGCPList,\n                            int *pnSize, unsigned char **ppabyBuffer,\n                            int bPixelIsPoint, char** papszRPCMD )\n\n{\n    char szFilename[100] = {};\n\n    snprintf( szFilename, sizeof(szFilename),\n              \"/vsimem/wkt_from_mem_buf_%ld.tif\",\n              static_cast<long>( CPLGetPID() ) );\n\n/* -------------------------------------------------------------------- */\n/*      Make sure we have hooked CSVFilename().                         */\n/* -------------------------------------------------------------------- */\n    GTiffOneTimeInit();  // For RPC tag.\n    LibgeotiffOneTimeInit();\n\n/* -------------------------------------------------------------------- */\n/*      Initialize access to the memory geotiff structure.              */\n/* -------------------------------------------------------------------- */\n    VSILFILE* fpL = VSIFOpenL( szFilename, \"w\" );\n    if( fpL == nullptr )\n        return CE_Failure;\n\n    TIFF *hTIFF = VSI_TIFFOpen( szFilename, \"w\", fpL );\n\n    if( hTIFF == nullptr )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"TIFF/GeoTIFF structure is corrupt.\" );\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write some minimal set of image parameters.                     */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, 8 );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n    TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n\n/* -------------------------------------------------------------------- */\n/*      Get the projection definition.                                  */\n/* -------------------------------------------------------------------- */\n\n    bool bPointGeoIgnore = false;\n    if( bPixelIsPoint )\n    {\n        bPointGeoIgnore =\n            CPLTestBool( CPLGetConfigOption( \"GTIFF_POINT_GEO_IGNORE\",\n                                             \"FALSE\") );\n    }\n\n    GTIF *hGTIF = nullptr;\n    if( pszWKT != nullptr || bPixelIsPoint )\n    {\n        hGTIF = GTIFNew(hTIFF);\n        if( pszWKT != nullptr )\n            GTIFSetFromOGISDefn( hGTIF, pszWKT );\n\n        if( bPixelIsPoint )\n        {\n            GTIFKeySet(hGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( hGTIF );\n        GTIFFree( hGTIF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Set the geotransform, or GCPs.                                  */\n/* -------------------------------------------------------------------- */\n\n    if( padfGeoTransform[0] != 0.0 || padfGeoTransform[1] != 1.0\n        || padfGeoTransform[2] != 0.0 || padfGeoTransform[3] != 0.0\n        || padfGeoTransform[4] != 0.0 || std::abs(padfGeoTransform[5]) != 1.0 )\n    {\n\n        if( padfGeoTransform[2] == 0.0 && padfGeoTransform[4] == 0.0 )\n        {\n            double adfPixelScale[3] = {\n                padfGeoTransform[1],\n                fabs(padfGeoTransform[5]),\n                0.0\n            };\n\n            TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n\n            double adfTiePoints[6] = {\n                0.0, 0.0, 0.0, padfGeoTransform[0], padfGeoTransform[3], 0.0 };\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfTiePoints[3] +=\n                    padfGeoTransform[1] * 0.5 + padfGeoTransform[2] * 0.5;\n                adfTiePoints[4] +=\n                    padfGeoTransform[4] * 0.5 + padfGeoTransform[5] * 0.5;\n            }\n\n            TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n        }\n        else\n        {\n            double adfMatrix[16] = { 0.0 };\n\n            adfMatrix[0] = padfGeoTransform[1];\n            adfMatrix[1] = padfGeoTransform[2];\n            adfMatrix[3] = padfGeoTransform[0];\n            adfMatrix[4] = padfGeoTransform[4];\n            adfMatrix[5] = padfGeoTransform[5];\n            adfMatrix[7] = padfGeoTransform[3];\n            adfMatrix[15] = 1.0;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfMatrix[3] +=\n                    padfGeoTransform[1] * 0.5 + padfGeoTransform[2] * 0.5;\n                adfMatrix[7] +=\n                    padfGeoTransform[4] * 0.5 + padfGeoTransform[5] * 0.5;\n            }\n\n            TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise write tiepoints if they are available.                */\n/* -------------------------------------------------------------------- */\n    else if( nGCPCount > 0 )\n    {\n        double *padfTiePoints = static_cast<double *>(\n            CPLMalloc(6*sizeof(double)*nGCPCount) );\n\n        for( int iGCP = 0; iGCP < nGCPCount; iGCP++ )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPList[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPList[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPList[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPList[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPList[iGCP].dfGCPZ;\n        }\n\n        TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6*nGCPCount, padfTiePoints);\n        CPLFree( padfTiePoints );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write RPC                                                       */\n/* -------------------------------------------------------------------- */\n    if( papszRPCMD != nullptr )\n    {\n        GTiffDatasetWriteRPCTag( hTIFF, papszRPCMD );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup and return the created memory buffer.                   */\n/* -------------------------------------------------------------------- */\n    GByte bySmallImage = 0;\n\n    TIFFWriteEncodedStrip( hTIFF, 0, reinterpret_cast<char *>(&bySmallImage), 1 );\n    TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTIFMemBufFromWkt\");\n    TIFFWriteDirectory( hTIFF );\n\n    XTIFFClose( hTIFF );\n    CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n\n/* -------------------------------------------------------------------- */\n/*      Read back from the memory buffer.  It would be preferable       */\n/*      to be able to \"steal\" the memory buffer, but there isn't        */\n/*      currently any support for this.                                 */\n/* -------------------------------------------------------------------- */\n    GUIntBig nBigLength = 0;\n\n    *ppabyBuffer = VSIGetMemFileBuffer( szFilename, &nBigLength, TRUE );\n    *pnSize = static_cast<int>( nBigLength );\n\n    return CE_None;\n}",
    "int NITFUncompressBILEVEL( NITFImage *psImage,\n                           GByte *pabyInputData, int nInputBytes,\n                           GByte *pabyOutputImage )\n\n{\n/* -------------------------------------------------------------------- */\n/*      Write memory TIFF with the bilevel data.                        */\n/* -------------------------------------------------------------------- */\n    const int nOutputBytes= (psImage->nBlockWidth * psImage->nBlockHeight + 7)/8;\n\n    CPLString osFilename;\n\n    osFilename.Printf( \"/vsimem/nitf-wrk-%ld.tif\", (long) CPLGetPID() );\n\n    VSILFILE* fpL = VSIFOpenL(osFilename, \"w+\");\n    if( fpL == nullptr )\n        return FALSE;\n    TIFF *hTIFF = VSI_TIFFOpen( osFilename, \"w+\", fpL );\n    if (hTIFF == nullptr)\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n        return FALSE;\n    }\n\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH,    psImage->nBlockWidth );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH,   psImage->nBlockHeight );\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT,  SAMPLEFORMAT_UINT );\n    TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG,  PLANARCONFIG_CONTIG );\n    TIFFSetField( hTIFF, TIFFTAG_FILLORDER,     FILLORDER_MSB2LSB );\n\n    TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP,  psImage->nBlockHeight );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX3 );\n\n    if( psImage->szCOMRAT[0] == '2' )\n        TIFFSetField( hTIFF, TIFFTAG_GROUP3OPTIONS, GROUP3OPT_2DENCODING );\n\n    TIFFWriteRawStrip( hTIFF, 0, pabyInputData, nInputBytes );\n    TIFFWriteDirectory( hTIFF );\n\n    TIFFClose( hTIFF );\n\n/* -------------------------------------------------------------------- */\n/*      Now open and read it back.                                      */\n/* -------------------------------------------------------------------- */\n    bool bResult = true;\n\n    hTIFF = VSI_TIFFOpen( osFilename, \"r\", fpL );\n    if (hTIFF == nullptr)\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n        return FALSE;\n    }\n\n    if( TIFFReadEncodedStrip( hTIFF, 0, pabyOutputImage, nOutputBytes ) == -1 )\n    {\n        memset( pabyOutputImage, 0, nOutputBytes );\n        bResult = false;\n    }\n\n    TIFFClose( hTIFF );\n    CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n\n    VSIUnlink( osFilename );\n\n    return bResult;\n}",
    "void GTiffDataset::Crystalize()\n\n{\n    if( m_bCrystalized )\n        return;\n\n    // TODO: libtiff writes extended tags in the order they are specified\n    // and not in increasing order.\n    WriteMetadata( this, m_hTIFF, true, m_eProfile, m_pszFilename,\n                   m_papszCreationOptions );\n    WriteGeoTIFFInfo();\n    if( m_bNoDataSet )\n        WriteNoDataValue( m_hTIFF, m_dfNoDataValue );\n\n    m_bMetadataChanged = false;\n    m_bGeoTIFFInfoChanged = false;\n    m_bNoDataChanged = false;\n    m_bNeedsRewrite = false;\n\n    m_bCrystalized = true;\n\n    TIFFWriteCheck( m_hTIFF, TIFFIsTiled(m_hTIFF), \"GTiffDataset::Crystalize\");\n\n    TIFFWriteDirectory( m_hTIFF );\n    if( m_bStreamingOut )\n    {\n        // We need to write twice the directory to be sure that custom\n        // TIFF tags are correctly sorted and that padding bytes have been\n        // added.\n        TIFFSetDirectory( m_hTIFF, 0 );\n        TIFFWriteDirectory( m_hTIFF );\n\n        if( VSIFSeekL( m_fpL, 0, SEEK_END ) != 0 )\n        {\n            ReportError(CE_Failure, CPLE_FileIO, \"Could not seek\");\n        }\n        const int nSize = static_cast<int>( VSIFTellL(m_fpL) );\n\n        TIFFSetDirectory( m_hTIFF, 0 );\n        GTiffFillStreamableOffsetAndCount( m_hTIFF, nSize );\n        TIFFWriteDirectory( m_hTIFF );\n\n        vsi_l_offset nDataLength = 0;\n        void* pabyBuffer =\n            VSIGetMemFileBuffer( m_pszTmpFilename, &nDataLength, FALSE);\n        if( static_cast<int>(\n                VSIFWriteL( pabyBuffer, 1,\n                            static_cast<int>(nDataLength), m_fpToWrite ) ) !=\n            static_cast<int>(nDataLength) )\n        {\n            ReportError( CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                      static_cast<int>(nDataLength) );\n        }\n        // In case of single strip file, there's a libtiff check that would\n        // issue a warning since the file hasn't the required size.\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        TIFFSetDirectory( m_hTIFF, 0 );\n        CPLPopErrorHandler();\n    }\n    else\n    {\n        TIFFSetDirectory( m_hTIFF,\n                      static_cast<tdir_t>(TIFFNumberOfDirectories(m_hTIFF) - 1) );\n    }\n\n    RestoreVolatileParameters( m_hTIFF );\n\n    m_nDirOffset = TIFFCurrentDirOffset( m_hTIFF );\n}",
    "void GTiffWriteJPEGTables( TIFF* hTIFF,\n                           const char* pszPhotometric,\n                           const char* pszJPEGQuality,\n                           const char* pszJPEGTablesMode )\n{\n    // This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n    uint16 nBands = 0;\n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL,\n                        &nBands ) )\n        nBands = 1;\n\n    uint16 l_nBitsPerSample = 0;\n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE,\n                        &(l_nBitsPerSample)) )\n        l_nBitsPerSample = 1;\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf(\"%s%p\", szJPEGGTiffDatasetTmpPrefix, hTIFF);\n    VSILFILE* fpTmp = nullptr;\n    CPLString osTmp;\n    char** papszLocalParameters = nullptr;\n    const int nInMemImageWidth = 16;\n    const int nInMemImageHeight = 16;\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\" );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEG_QUALITY\",\n                                            pszJPEGQuality );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"PHOTOMETRIC\", pszPhotometric );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"BLOCKYSIZE\",\n                                            CPLSPrintf(\"%u\", nInMemImageHeight)\n                                          );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"NBITS\",\n                                            CPLSPrintf(\"%u\", l_nBitsPerSample));\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEGTABLESMODE\",\n                                            pszJPEGTablesMode );\n\n    TIFF* hTIFFTmp = GTiffDataset::CreateLL(\n                    osTmpFilenameIn, nInMemImageWidth, nInMemImageHeight,\n                    (nBands <= 4) ? nBands : 1,\n                    (l_nBitsPerSample <= 8) ? GDT_Byte : GDT_UInt16, 0.0,\n                    papszLocalParameters, &fpTmp, osTmp );\n    CSLDestroy(papszLocalParameters);\n    if( hTIFFTmp )\n    {\n        uint16 l_nPhotometric = 0;\n        int nJpegTablesModeIn = 0;\n        TIFFGetField( hTIFFTmp, TIFFTAG_PHOTOMETRIC, &(l_nPhotometric) );\n        TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                        &nJpegTablesModeIn );\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now, reset quality and jpegcolormode.\n        const int l_nJpegQuality = pszJPEGQuality ? atoi(pszJPEGQuality) : 0;\n        if(l_nJpegQuality > 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGQUALITY, l_nJpegQuality);\n        if( l_nPhotometric == PHOTOMETRIC_YCBCR\n            && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGCOLORMODE,\n                            JPEGCOLORMODE_RGB);\n        }\n        if( nJpegTablesModeIn >= 0 )\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                            nJpegTablesModeIn);\n\n        GPtrDiff_t nBlockSize = static_cast<GPtrDiff_t>(nInMemImageWidth) * nInMemImageHeight *\n                                        ((nBands <= 4) ? nBands : 1);\n        if( l_nBitsPerSample == 12 )\n            nBlockSize = (nBlockSize * 3) / 2;\n        std::vector<GByte> abyZeroData( nBlockSize, 0 );\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, &abyZeroData[0], nBlockSize);\n\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSize,\n                            &pJPEGTable) )\n            TIFFSetField( hTIFF, TIFFTAG_JPEGTABLES, nJPEGTableSize,\n                            pJPEGTable);\n\n        float *ref = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_REFERENCEBLACKWHITE, &ref) )\n            TIFFSetField(hTIFF, TIFFTAG_REFERENCEBLACKWHITE, ref);\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n    VSIUnlink(osTmpFilenameIn);\n}",
    "int GTiffDataset::GuessJPEGQuality( bool& bOutHasQuantizationTable,\n                                    bool& bOutHasHuffmanTable )\n{\n    CPLAssert( m_nCompression == COMPRESSION_JPEG );\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    if( !TIFFGetField(m_hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize, &pJPEGTable) )\n    {\n        bOutHasQuantizationTable = false;\n        bOutHasHuffmanTable = false;\n        return -1;\n    }\n\n    bOutHasQuantizationTable =\n        GTIFFFindNextTable( static_cast<const GByte*>(pJPEGTable), 0xDB,\n                            nJPEGTableSize, nullptr) != nullptr;\n    bOutHasHuffmanTable =\n        GTIFFFindNextTable( static_cast<const GByte*>(pJPEGTable), 0xC4,\n                            nJPEGTableSize, nullptr) != nullptr;\n    if( !bOutHasQuantizationTable )\n        return -1;\n\n    char** papszLocalParameters = nullptr;\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\");\n    if( m_nPhotometric == PHOTOMETRIC_YCBCR )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"YCBCR\");\n    else if( m_nPhotometric == PHOTOMETRIC_SEPARATED )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"CMYK\");\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"BLOCKYSIZE\", \"16\");\n    if( m_nBitsPerSample == 12 )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                \"NBITS\", \"12\");\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf( \"/vsimem/gtiffdataset_guess_jpeg_quality_tmp_%p\",\n                            this );\n\n    int nRet = -1;\n    for( int nQuality = 0; nQuality <= 100 && nRet < 0; ++nQuality )\n    {\n        VSILFILE* fpTmp = nullptr;\n        if( nQuality == 0 )\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                   \"JPEG_QUALITY\", \"75\");\n        else\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                \"JPEG_QUALITY\", CPLSPrintf(\"%d\", nQuality));\n\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        CPLString osTmp;\n        TIFF* hTIFFTmp =\n            CreateLL( osTmpFilenameIn, 16, 16, (nBands <= 4) ? nBands : 1,\n                      GetRasterBand(1)->GetRasterDataType(), 0.0,\n                      papszLocalParameters, &fpTmp, osTmp );\n        CPLPopErrorHandler();\n        if( !hTIFFTmp )\n        {\n            break;\n        }\n\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now reset jpegcolormode.\n        if( m_nPhotometric == PHOTOMETRIC_YCBCR\n            && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n\n        GByte abyZeroData[(16*16*4*3)/2] = {};\n        const int nBlockSize =\n            (16 * 16 * ((nBands <= 4) ? nBands : 1) * m_nBitsPerSample) / 8;\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, abyZeroData, nBlockSize);\n\n        uint32 nJPEGTableSizeTry = 0;\n        void* pJPEGTableTry = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES,\n                         &nJPEGTableSizeTry, &pJPEGTableTry) )\n        {\n            if( GTIFFQuantizationTablesEqual(\n                   static_cast<GByte *>(pJPEGTable), nJPEGTableSize,\n                   static_cast<GByte *>(pJPEGTableTry), nJPEGTableSizeTry) )\n            {\n                nRet = (nQuality == 0 ) ? 75 : nQuality;\n            }\n        }\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n\n    CSLDestroy(papszLocalParameters);\n    VSIUnlink(osTmpFilenameIn);\n\n    return nRet;\n}",
    "bool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        pTiffHandle = buf_helper.open();\n    }\n    else\n    {\n        pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    //Settings that matter to all images\n    // defaults for now, maybe base them on params in the future\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int depth = img.depth();\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n        if (rowsPerStrip < 1)\n            rowsPerStrip = 1;\n\n        if (rowsPerStrip > height)\n            rowsPerStrip = height;\n\n        int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        if (!TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n            || (img_vec.size() > 1 && (\n               !TIFFSetField(pTiffHandle, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PAGENUMBER, page, img_vec.size() )))\n            )\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        if (compression != COMPRESSION_NONE && !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor))\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer;\n        if (!buffer)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, cvSize(width, 1));\n                    else\n                        icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width, 1));\n                    break;\n                }\n\n                case 4:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, cvSize(width, 1));\n                    else\n                        icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width, 1));\n                    break;\n                }\n\n                default:\n                {\n                    TIFFClose(pTiffHandle);\n                    return false;\n                }\n            }\n\n            int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n            if (writeResult != 1)\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        TIFFWriteDirectory(pTiffHandle);\n\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}",
    "bool TiffEncoder::write_32FC1(const Mat& _img)\n{\n\n    TIFF* tif;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n\n    if (!tif)\n    {\n        return false;\n    }\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, _img.cols);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, _img.rows);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    for (uint32 row = 0; row < (uint32)_img.rows; row++)\n    {\n        if (TIFFWriteScanline(tif, (tdata_t)_img.ptr<float>(row), row, 1) != 1)\n        {\n            TIFFClose(tif);\n            return false;\n        }\n    }\n    TIFFWriteDirectory(tif);\n    TIFFClose(tif);\n\n    return true;\n}",
    "bool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        pTiffHandle = buf_helper.open();\n    }\n    else\n    {\n        pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    //Settings that matter to all images\n    // defaults for now, maybe base them on params in the future\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int depth = img.depth();\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n        if (rowsPerStrip < 1)\n            rowsPerStrip = 1;\n\n        if (rowsPerStrip > height)\n            rowsPerStrip = height;\n\n        int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        if (!TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n            || (img_vec.size() > 1 && (\n               !TIFFSetField(pTiffHandle, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PAGENUMBER, page, img_vec.size() )))\n            )\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        if (compression != COMPRESSION_NONE && !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor))\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        if (((resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER) && !TIFFSetField(pTiffHandle, TIFFTAG_RESOLUTIONUNIT, resUnit))\n            || (dpiX >= 0 && !TIFFSetField(pTiffHandle, TIFFTAG_XRESOLUTION, (float)dpiX))\n            || (dpiY >= 0 && !TIFFSetField(pTiffHandle, TIFFTAG_YRESOLUTION, (float)dpiY))\n            )\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data();\n        if (!buffer)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, Size(width, 1));\n                    else\n                        icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, Size(width, 1));\n                    break;\n                }\n\n                case 4:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, Size(width, 1));\n                    else\n                        icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, Size(width, 1));\n                    break;\n                }\n\n                default:\n                {\n                    TIFFClose(pTiffHandle);\n                    return false;\n                }\n            }\n\n            int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n            if (writeResult != 1)\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        TIFFWriteDirectory(pTiffHandle);\n\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}",
    "bool CxImageTIF::Encode(CxFile * hFile, bool bAppend)\n{\n  try{\n\tif (hFile==NULL) throw CXIMAGE_ERR_NOFILE;\n\tif (pDib==NULL) throw CXIMAGE_ERR_NOIMAGE;\n\n\t// <RJ> replaced \"w+b\" with \"a\", to append an image directly on an existing file\n\tif (m_tif2==NULL) m_tif2=_TIFFOpenEx(hFile, \"a\");\n\tif (m_tif2==NULL) throw \"initialization fail\";\n\n\tif (bAppend || m_pages) m_multipage=true;\n\tm_pages++;\n\n\tif (!EncodeBody(m_tif2,m_multipage,m_pages,m_pages)) throw \"Error saving TIFF file\";\n\tif (bAppend) {\n\t\tif (!TIFFWriteDirectory(m_tif2)) throw \"Error saving TIFF directory\";\n\t}\n  } catch (char *message) {\n\t  strncpy(info.szLastError,message,255);\n\t  if (m_tif2){\n\t\t  TIFFClose(m_tif2);\n\t\t  m_tif2=NULL;\n\t\t  m_multipage=false;\n\t\t  m_pages=0;\n\t  }\n\t  return false;\n  }\n\tif (!bAppend){\n\t\tTIFFClose(m_tif2);\n\t\tm_tif2=NULL;\n\t\tm_multipage=false;\n\t\tm_pages=0;\n\t}\n\treturn true;\n}",
    "void ColorMipmap::buildBaseLevelTile(int tx, int ty, TIFF *f)\n{\n\tint off = 0;\n\tfor (int j = -border; j < tileSize + border; ++j) {\n\t\tfor (int i = -border; i < tileSize + border; ++i) {\n\t\t\tvec4f c = colorf->getColor(tx * tileSize + i, ty * tileSize + j);\n    \t\ttile[off++] = int(roundf(c.x));\n    \t\tif (channels > 1) {\n    \t\t    tile[off++] = int(roundf(c.y));\n    \t\t}\n    \t\tif (channels > 2) {\n    \t\t    tile[off++] = int(roundf(c.z));\n    \t\t}\n    \t\tif (channels > 3) {\n    \t\t    tile[off++] = int(roundf(c.w));\n    \t\t}\n\t\t}\n\t}\n\n    TIFFSetField(f, TIFFTAG_IMAGEWIDTH, tileSize + 2*border);\n    TIFFSetField(f, TIFFTAG_IMAGELENGTH, tileSize + 2*border);\n    TIFFSetField(f, TIFFTAG_SAMPLESPERPIXEL, channels);\n    TIFFSetField(f, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(f, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n    TIFFSetField(f, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n    TIFFSetField(f, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    if (channels == 1) {\n        TIFFSetField(f, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    } else {\n        TIFFSetField(f, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    }\n    TIFFWriteEncodedStrip(f, 0, tile, (tileSize + 2*border) * (tileSize + 2*border) * channels);\n\tTIFFWriteDirectory(f);\n}",
    "void ColorMipmap::buildMipmapLevel(int level)\n{\n    char buf[256];\n    int nTiles = 1 << level;\n    int nTilesPerFile = min(nTiles, 16);\n\n    printf(\"Build mipmap level %d...\\n\", level);\n\n    currentLevel = level + 1;\n    reset(tileSize << currentLevel, tileSize << currentLevel, tileSize);\n\n    for (int dy = 0; dy < nTiles / nTilesPerFile; ++dy) {\n        for (int dx = 0; dx < nTiles / nTilesPerFile; ++dx) {\n            sprintf(buf, \"%s/%.2d-%.4d-%.4d.tiff\", cache.c_str(), level, dx, dy);\n            if (flog(buf)) {\n                TIFF* f = TIFFOpen(buf, \"wb\");\n                for (int ny = 0; ny < nTilesPerFile; ++ny) {\n                    for (int nx = 0; nx < nTilesPerFile; ++nx) {\n                        int tx = nx + dx * nTilesPerFile;\n                        int ty = ny + dy * nTilesPerFile;\n\n                        int off = 0;\n                        for (int j = -border; j < tileSize + border; ++j) {\n                            for (int i = -border; i < tileSize + border; ++i) {\n                                int ix = 2 * (tx * tileSize + i);\n                                int iy = 2 * (ty * tileSize + j);\n\n                                vec4f c1 = getTileColor(ix, iy);\n                                vec4f c2 = getTileColor(ix+1, iy);\n                                vec4f c3 = getTileColor(ix, iy+1);\n                                vec4f c4 = getTileColor(ix+1, iy+1);\n\n                                tile[off++] = int(roundf(l2r((r2l(c1.x)+r2l(c2.x)+r2l(c3.x)+r2l(c4.x))/4.0)));\n                                if (channels > 1) {\n                                    tile[off++] = int(roundf(l2r((r2l(c1.y)+r2l(c2.y)+r2l(c3.y)+r2l(c4.y))/4.0)));\n                                }\n                                if (channels > 2) {\n                                    tile[off++] = int(roundf(l2r((r2l(c1.z)+r2l(c2.z)+r2l(c3.z)+r2l(c4.z))/4.0)));\n                                }\n                                if (channels > 3) {\n                                    float w1 = max(2.0 * c1.w - 255.0, 0.0);\n                                    float n1 = max(255.0 - 2.0 * c1.w, 0.0);\n                                    float w2 = max(2.0 * c2.w - 255.0, 0.0);\n                                    float n2 = max(255.0 - 2.0 * c2.w, 0.0);\n                                    float w3 = max(2.0 * c3.w - 255.0, 0.0);\n                                    float n3 = max(255.0 - 2.0 * c3.w, 0.0);\n                                    float w4 = max(2.0 * c4.w - 255.0, 0.0);\n                                    float n4 = max(255.0 - 2.0 * c4.w, 0.0);\n                                    int w = int(roundf((w1 + w2 + w3 + w4) / 4));\n                                    int n = int(roundf((n1 + n2 + n3 + n4) / 4));\n                                    tile[off++] = 127 + w / 2 - n / 2;\n                                }\n                            }\n                        }\n\n                        TIFFSetField(f, TIFFTAG_IMAGEWIDTH, tileSize + 2*border);\n                        TIFFSetField(f, TIFFTAG_IMAGELENGTH, tileSize + 2*border);\n                        TIFFSetField(f, TIFFTAG_SAMPLESPERPIXEL, channels);\n                        TIFFSetField(f, TIFFTAG_BITSPERSAMPLE, 8);\n                        TIFFSetField(f, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n                        TIFFSetField(f, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n                        TIFFSetField(f, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n                        if (channels == 1) {\n                            TIFFSetField(f, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n                        } else {\n                            TIFFSetField(f, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n                        }\n                        TIFFWriteEncodedStrip(f, 0, tile, (tileSize + 2*border) * (tileSize + 2*border) * channels);\n                        TIFFWriteDirectory(f);\n                    }\n                }\n                TIFFClose(f);\n            }\n        }\n    }\n}",
    "void HeightMipmap::buildBaseLevelTile(int tx, int ty, TIFF *f)\n{\n\tint off = 0;\n\tfor (int j = -2; j <= tileSize + 2; ++j) {\n\t\tfor (int i = -2; i <= tileSize + 2; ++i) {\n\t\t\tfloat h = height->getHeight(tx * tileSize + i, ty * tileSize + j);\n\t\t\tshort sh = (short) h;\n    \t\ttile[off++] = sh & 0xFF;\n\t\t\ttile[off++] = sh >> 8;\n\t\t}\n\t}\n\n    TIFFSetField(f, TIFFTAG_IMAGEWIDTH, tileSize + 5);\n    TIFFSetField(f, TIFFTAG_IMAGELENGTH, tileSize + 5);\n    TIFFSetField(f, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(f, TIFFTAG_BITSPERSAMPLE, 16);\n    TIFFSetField(f, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n    TIFFSetField(f, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n    TIFFSetField(f, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(f, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFWriteEncodedStrip(f, 0, tile, (tileSize + 5) * (tileSize + 5) * 2);\n\tTIFFWriteDirectory(f);\n}",
    "void HeightMipmap::buildMipmapLevel(int level)\n{\n    char buf[256];\n    int nTiles = max(1, (baseLevelSize / tileSize) >> (maxLevel - level));\n    int nTilesPerFile = min(nTiles, 16);\n\n    printf(\"Build mipmap level %d...\\n\", level);\n\n    currentLevel = level + 1;\n    reset(baseLevelSize >> (maxLevel - currentLevel), baseLevelSize >> (maxLevel - currentLevel), min(topLevelSize << currentLevel, tileSize));\n\n    for (int dy = 0; dy < nTiles / nTilesPerFile; ++dy) {\n        for (int dx = 0; dx < nTiles / nTilesPerFile; ++dx) {\n            sprintf(buf, \"%s/%.2d-%.4d-%.4d.tiff\", cache.c_str(), level, dx, dy);\n            if (flog(buf)) {\n                TIFF* f = TIFFOpen(buf, \"wb\");\n                for (int ny = 0; ny < nTilesPerFile; ++ny) {\n                    for (int nx = 0; nx < nTilesPerFile; ++nx) {\n                        int tx = nx + dx * nTilesPerFile;\n                        int ty = ny + dy * nTilesPerFile;\n\n                        int off = 0;\n                        int currentTileSize = min(topLevelSize << level, tileSize);\n                        for (int j = -2; j <= currentTileSize + 2; ++j) {\n                            for (int i = -2; i <= currentTileSize + 2; ++i) {\n                                int ix = 2 * (tx * currentTileSize + i);\n                                int iy = 2 * (ty * currentTileSize + j);\n                                /*float h1 = getTileHeight(ix, iy);\n                                float h2 = getTileHeight(ix+1, iy);\n                                float h3 = getTileHeight(ix, iy+1);\n                                float h4 = getTileHeight(ix+1, iy+1);\n                                short sh = (short) ((h1 + h2 + h3 + h4) / 4);*/\n                                short sh = (short) (getTileHeight(ix, iy));\n                                tile[off++] = sh & 0xFF;\n                                tile[off++] = sh >> 8;\n                            }\n                        }\n\n                        TIFFSetField(f, TIFFTAG_IMAGEWIDTH, currentTileSize + 5);\n                        TIFFSetField(f, TIFFTAG_IMAGELENGTH, currentTileSize + 5);\n                        TIFFSetField(f, TIFFTAG_SAMPLESPERPIXEL, 1);\n                        TIFFSetField(f, TIFFTAG_BITSPERSAMPLE, 16);\n                        TIFFSetField(f, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n                        TIFFSetField(f, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n                        TIFFSetField(f, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n                        TIFFSetField(f, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n                        TIFFWriteEncodedStrip(f, 0, tile, (currentTileSize + 5) * (currentTileSize + 5) * 2);\n                        TIFFWriteDirectory(f);\n                    }\n                }\n                TIFFClose(f);\n            }\n        }\n    }\n}",
    "void HeightMipmap::buildResiduals(int level)\n{\n    int nTiles = max(1, (baseLevelSize / this->tileSize) >> (maxLevel - level));\n    int nTilesPerFile = min(nTiles, 16);\n    int tileSize = min(topLevelSize << level, this->tileSize);\n\n    printf(\"Build residuals level %d...\\n\", level);\n\n    currentLevel = level;\n    reset(baseLevelSize >> (maxLevel - currentLevel), baseLevelSize >> (maxLevel - currentLevel), min(topLevelSize << currentLevel, this->tileSize));\n\n    float *parentTile = new float[(this->tileSize + 5) * (this->tileSize + 5)];\n    float *currentTile = new float[(this->tileSize + 5) * (this->tileSize + 5)];\n    float *residualTile = new float[(this->tileSize + 5) * (this->tileSize + 5)];\n    unsigned char *encodedResidual = new unsigned char[(this->tileSize + 5) * (this->tileSize + 5) * 2];\n\n    float maxRR = 0.0;\n    float maxEE = 0.0;\n    for (int dy = 0; dy < nTiles / nTilesPerFile; ++dy) {\n        for (int dx = 0; dx < nTiles / nTilesPerFile; ++dx) {\n            char buf[256];\n            sprintf(buf, \"%s/residual-%.2d-%.4d-%.4d.tiff\", cache.c_str(), level, dx, dy);\n\n            if (flog(buf)) {\n                TIFF* f = TIFFOpen(buf, \"wb\");\n                for (int ny = 0; ny < nTilesPerFile; ++ny) {\n                    for (int nx = 0; nx < nTilesPerFile; ++nx) {\n                        int tx = nx + dx * nTilesPerFile;\n                        int ty = ny + dy * nTilesPerFile;\n                        float maxR, meanR, maxErr;\n\n                        getApproxTile(level - 1, tx / 2, ty / 2, parentTile);\n                        getTile(level, tx, ty, currentTile);\n                        computeResidual(parentTile, currentTile, level, tx, ty, residualTile, maxR, meanR);\n                        encodeResidual(level, residualTile, encodedResidual);\n                        computeApproxTile(parentTile, residualTile, level, tx, ty, currentTile, maxErr);\n                        if (level < maxLevel) {\n                            saveApproxTile(level, tx, ty, currentTile);\n                        }\n\n                        TIFFSetField(f, TIFFTAG_IMAGEWIDTH, tileSize + 5);\n                        TIFFSetField(f, TIFFTAG_IMAGELENGTH, tileSize + 5);\n                        TIFFSetField(f, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n                        TIFFSetField(f, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n                        TIFFSetField(f, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n                        TIFFSetField(f, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n                        /*TIFFSetField(f, TIFFTAG_SAMPLESPERPIXEL, 1);\n                        TIFFSetField(f, TIFFTAG_BITSPERSAMPLE, 16);*/\n                        TIFFSetField(f, TIFFTAG_SAMPLESPERPIXEL, 2);\n                        TIFFSetField(f, TIFFTAG_BITSPERSAMPLE, 8);\n                        TIFFWriteEncodedStrip(f, 0, encodedResidual, (tileSize + 5) * (tileSize + 5) * 2);\n                        TIFFWriteDirectory(f);\n\n                        maxRR = max(maxR, maxRR);\n                        maxEE = max(maxErr, maxEE);\n                    }\n                }\n\n                TIFFClose(f);\n                printf(\"%f max residual, %f max err\\n\", maxRR, maxEE);\n            }\n        }\n    }\n\n    delete[] parentTile;\n    delete[] currentTile;\n    delete[] residualTile;\n    delete[] encodedResidual;\n}",
    "virtual void buildMipmapLevel(int level)\n    {\n        char buf[256];\n        int nTiles = 1 << level;\n        int nTilesPerFile = min(nTiles, 16);\n\n        printf(\"Build mipmap level %d...\\n\", level);\n\n        currentLevel = level + 1;\n        reset(tileSize << currentLevel, tileSize << currentLevel, tileSize);\n\n        for (int dy = 0; dy < nTiles / nTilesPerFile; ++dy) {\n            for (int dx = 0; dx < nTiles / nTilesPerFile; ++dx) {\n                sprintf(buf, \"%s/%.2d-%.4d-%.4d.tiff\", cache.c_str(), level, dx, dy);\n                if (flog(buf)) {\n                    TIFF* f = TIFFOpen(buf, \"wb\");\n                    for (int ny = 0; ny < nTilesPerFile; ++ny) {\n                        for (int nx = 0; nx < nTilesPerFile; ++nx) {\n                            int tx = nx + dx * nTilesPerFile;\n                            int ty = ny + dy * nTilesPerFile;\n\n                            vec3d pc = vec3d((tx + 0.5) / (1 << level) * (2.0 * R) - R, (ty + 0.5) / (1 << level) * (2.0 * R) - R, R);\n                            vec3d uz = pc.normalize();\n                            vec3d ux = vec3d::UNIT_Y.crossProduct(uz).normalize();\n                            vec3d uy = uz.crossProduct(ux);\n                            mat3d worldToTangentFrame = mat3d(\n                                ux.x, ux.y, ux.z,\n                                uy.x, uy.y, uy.z,\n                                uz.x, uz.y, uz.z);\n\n                            mat3d childToParentFrame[4][4];\n                            for (int j = -1; j < 3; ++j) {\n                                for (int i = -1; i < 3; ++i) {\n                                    pc = vec3d((2*tx+i + 0.5) / (2 << level) * (2.0 * R) - R, (2*ty+j + 0.5) / (2 << level) * (2.0 * R) - R, R);\n                                    uz = pc.normalize();\n                                    ux = vec3d::UNIT_Y.crossProduct(uz).normalize();\n                                    uy = uz.crossProduct(ux);\n                                    childToParentFrame[i+1][j+1] = worldToTangentFrame * mat3d(\n                                        ux.x, uy.x, uz.x,\n                                        ux.y, uy.y, uz.y,\n                                        ux.z, uy.z, uz.z);\n                                }\n                            }\n\n                            int off = 0;\n                            for (int j = -border; j < tileSize + border; ++j) {\n                                for (int i = -border; i < tileSize + border; ++i) {\n                                    int ix = 2 * (tx * tileSize + i);\n                                    int iy = 2 * (ty * tileSize + j);\n\n                                    vec4f c1 = getTileColor(ix, iy);\n                                    vec4f c2 = getTileColor(ix+1, iy);\n                                    vec4f c3 = getTileColor(ix, iy+1);\n                                    vec4f c4 = getTileColor(ix+1, iy+1);\n\n                                    float a1 = pow(c1.x / 255, 0.25f);\n                                    float a2 = pow(c2.x / 255, 0.25f);\n                                    float a3 = pow(c3.x / 255, 0.25f);\n                                    float a4 = pow(c4.x / 255, 0.25f);\n                                    float a = (a1 + a2 + a3 + a4) / 4.0;\n                                    //float a = max(a1, max(a2, max(a3, a4)));\n                                    //float a = ((a1 + a2 + a3 + a4) / 4.0 + max(a1, max(a2, max(a3, a4)))) / 2.0;\n                                    tile[off++] = int(roundf(pow(a, 4.0f) * 255));\n\n                                    #define X(x) tan(x * (2.9 / 255.0) - 1.45) / 8.0\n                                    vec3d n1 = vec3d(X(c1.y), X(c1.z), 0.0);\n                                    vec3d n2 = vec3d(X(c2.y), X(c2.z), 0.0);\n                                    vec3d n3 = vec3d(X(c3.y), X(c3.z), 0.0);\n                                    vec3d n4 = vec3d(X(c4.y), X(c4.z), 0.0);\n                                    n1.z = sqrt(1.0 - n1.squaredLength());\n                                    n2.z = sqrt(1.0 - n2.squaredLength());\n                                    n3.z = sqrt(1.0 - n3.squaredLength());\n                                    n4.z = sqrt(1.0 - n4.squaredLength());\n\n                                    int ui = (i + tileSize / 2) / (tileSize / 2);\n                                    int uj = (j + tileSize / 2) / (tileSize / 2);\n                                    vec3d n = childToParentFrame[ui][uj] * n1;\n                                    n += childToParentFrame[ui][uj] * n2;\n                                    n += childToParentFrame[ui][uj] * n3;\n                                    n += childToParentFrame[ui][uj] * n4;\n                                    n = n.normalize();\n\n                                    tile[off++] = int((atan(8.0*n.x)/2.9 + 0.5) * 255);\n                                    tile[off++] = int((atan(8.0*n.y)/2.9 + 0.5) * 255);\n                                }\n                            }\n\n                            TIFFSetField(f, TIFFTAG_IMAGEWIDTH, tileSize + 2*border);\n                            TIFFSetField(f, TIFFTAG_IMAGELENGTH, tileSize + 2*border);\n                            TIFFSetField(f, TIFFTAG_SAMPLESPERPIXEL, channels);\n                            TIFFSetField(f, TIFFTAG_BITSPERSAMPLE, 8);\n                            TIFFSetField(f, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n                            TIFFSetField(f, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n                            TIFFSetField(f, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n                            if (channels == 1) {\n                                TIFFSetField(f, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n                            } else {\n                                TIFFSetField(f, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n                            }\n                            TIFFWriteEncodedStrip(f, 0, tile, (tileSize + 2*border) * (tileSize + 2*border) * channels);\n                            TIFFWriteDirectory(f);\n                        }\n                    }\n                    TIFFClose(f);\n                }\n            }\n        }\n    }",
    "JNIEXPORT jboolean JNICALL LCTIFFWriter_METHOD(append)\n    ( JNIEnv *env, jobject jLCTIFFWriter, jstring jFileName )\n{\n    TIFF *const destTIFF = getNativePtr( env, jLCTIFFWriter );\n    TIFFSetField( destTIFF, TIFFTAG_PAGENUMBER, 0, 2 );\n    int result = TIFFWriteDirectory( destTIFF );\n    if ( !result )\n        return JNI_FALSE;\n    jstring_to_c const cFileName( env, jFileName );\n    TIFF *const srcTIFF = LC_TIFFOpen( cFileName, \"r\" );\n    if ( !srcTIFF )\n        return JNI_FALSE;\n    if ( isLightZoneLayeredTIFF( srcTIFF ) )\n        TIFFReadDirectory( srcTIFF );\n    result = tiffcp( srcTIFF, destTIFF );\n    TIFFSetField( destTIFF, TIFFTAG_PAGENUMBER, 1, 2 );\n    TIFFClose( srcTIFF );\n    return result ? JNI_TRUE : JNI_FALSE;\n}",
    "void GTiffDataset::Crystalize()\n\n{\n    if( !bCrystalized )\n    {\n        WriteMetadata( this, hTIFF, TRUE, osProfile, osFilename,\n                       papszCreationOptions );\n        WriteGeoTIFFInfo();\n\n        bMetadataChanged = FALSE;\n        bGeoTIFFInfoChanged = FALSE;\n        bNeedsRewrite = FALSE;\n\n        bCrystalized = TRUE;\n\n        TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTiffDataset::Crystalize\");\n\n \t// Keep zip and tiff quality, and jpegcolormode which get reset when we call \n        // TIFFWriteDirectory \n        int jquality = -1, zquality = -1, nColorMode = -1; \n        TIFFGetField(hTIFF, TIFFTAG_JPEGQUALITY, &jquality); \n        TIFFGetField(hTIFF, TIFFTAG_ZIPQUALITY, &zquality); \n        TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode );\n\n        TIFFWriteDirectory( hTIFF );\n        TIFFSetDirectory( hTIFF, 0 );\n\n\n        // Now, reset zip and tiff quality and jpegcolormode. \n        if(jquality > 0) \n            TIFFSetField(hTIFF, TIFFTAG_JPEGQUALITY, jquality); \n        if(zquality > 0) \n            TIFFSetField(hTIFF, TIFFTAG_ZIPQUALITY, zquality);\n        if (nColorMode >= 0)\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, nColorMode);\n\n        nDirOffset = TIFFCurrentDirOffset( hTIFF );\n    }\n}",
    "GDALDataset *\nGTiffDataset::CreateCopy( const char * pszFilename, GDALDataset *poSrcDS, \n                          int bStrict, char ** papszOptions, \n                          GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    TIFF\t*hTIFF;\n    int\t\tnXSize = poSrcDS->GetRasterXSize();\n    int\t\tnYSize = poSrcDS->GetRasterYSize();\n    int\t\tnBands = poSrcDS->GetRasterCount();\n    int         iBand;\n    CPLErr      eErr = CE_None;\n    uint16\tnPlanarConfig;\n    uint16\tnBitsPerSample;\n    GDALRasterBand *poPBand;\n\n    if( poSrcDS->GetRasterCount() == 0 )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Unable to export GeoTIFF files with zero bands.\" );\n        return NULL;\n    }\n        \n    poPBand = poSrcDS->GetRasterBand(1);\n    GDALDataType eType = poPBand->GetRasterDataType();\n\n/* -------------------------------------------------------------------- */\n/*      Check, whether all bands in input dataset has the same type.    */\n/* -------------------------------------------------------------------- */\n    for ( iBand = 2; iBand <= nBands; iBand++ )\n    {\n        if ( eType != poSrcDS->GetRasterBand(iBand)->GetRasterDataType() )\n        {\n            if ( bStrict )\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"Unable to export GeoTIFF file with different datatypes per\\n\"\n                          \"different bands. All bands should have the same types in TIFF.\" );\n                return NULL;\n            }\n            else\n            {\n                CPLError( CE_Warning, CPLE_AppDefined,\n                          \"Unable to export GeoTIFF file with different datatypes per\\n\"\n                          \"different bands. All bands should have the same types in TIFF.\" );\n            }\n        }\n    }\n\n    if( !pfnProgress( 0.0, NULL, pProgressData ) )\n        return NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the profile.                                            */\n/* -------------------------------------------------------------------- */\n    const char          *pszProfile;\n    int                 bGeoTIFF;\n\n    pszProfile = CSLFetchNameValue(papszOptions,\"PROFILE\");\n    if( pszProfile == NULL )\n        pszProfile = \"GDALGeoTIFF\";\n\n    if( !EQUAL(pszProfile,\"BASELINE\") \n        && !EQUAL(pszProfile,\"GeoTIFF\") \n        && !EQUAL(pszProfile,\"GDALGeoTIFF\") )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined, \n                  \"PROFILE=%s not supported in GTIFF driver.\", \n                  pszProfile );\n        return NULL;\n    }\n    \n    if( EQUAL(pszProfile,\"BASELINE\") )\n        bGeoTIFF = FALSE;\n    else\n        bGeoTIFF = TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      Special handling for NBITS.  Copy from band metadata if found.  */\n/* -------------------------------------------------------------------- */\n    char     **papszCreateOptions = CSLDuplicate( papszOptions );\n\n    if( poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" ) != NULL \n        && atoi(poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" )) > 0\n        && CSLFetchNameValue( papszCreateOptions, \"NBITS\") == NULL )\n    {\n        papszCreateOptions = \n            CSLSetNameValue( papszCreateOptions, \"NBITS\",\n                             poPBand->GetMetadataItem( \"NBITS\", \n                                                       \"IMAGE_STRUCTURE\" ) );\n    }\n\n    if( CSLFetchNameValue( papszOptions, \"PIXELTYPE\" ) == NULL\n        && eType == GDT_Byte\n        && poPBand->GetMetadataItem( \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) )\n    {\n        papszCreateOptions = \n            CSLSetNameValue( papszCreateOptions, \"PIXELTYPE\", \n                             poPBand->GetMetadataItem( \n                                 \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create the file.                                                */\n/* -------------------------------------------------------------------- */\n    hTIFF = CreateLL( pszFilename, nXSize, nYSize, nBands, \n                      eType, papszCreateOptions );\n\n    CSLDestroy( papszCreateOptions );\n\n    if( hTIFF == NULL )\n        return NULL;\n\n    TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &nPlanarConfig );\n    TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &nBitsPerSample );\n\n/* -------------------------------------------------------------------- */\n/*      Are we really producing an RGBA image?  If so, set the          */\n/*      associated alpha information.                                   */\n/* -------------------------------------------------------------------- */\n    int bForcePhotometric = \n        CSLFetchNameValue(papszOptions,\"PHOTOMETRIC\") != NULL;\n\n    if( nBands == 4 && !bForcePhotometric\n        && poSrcDS->GetRasterBand(4)->GetColorInterpretation()==GCI_AlphaBand)\n    {\n        uint16 v[1];\n\n        v[0] = EXTRASAMPLE_ASSOCALPHA;\n\tTIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n        TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the output is jpeg compressed, and the input is RGB make     */\n/*      sure we note that.                                              */\n/* -------------------------------------------------------------------- */\n    uint16      nCompression;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n\n    if( nCompression == COMPRESSION_JPEG )\n    {\n        if( nBands >= 3 \n            && (poSrcDS->GetRasterBand(1)->GetColorInterpretation() \n                == GCI_YCbCr_YBand)\n            && (poSrcDS->GetRasterBand(2)->GetColorInterpretation() \n                == GCI_YCbCr_CbBand)\n            && (poSrcDS->GetRasterBand(3)->GetColorInterpretation() \n                == GCI_YCbCr_CrBand) )\n        {\n            /* do nothing ... */\n        }\n        else\n        {\n            /* we assume RGB if it isn't explicitly YCbCr */\n            CPLDebug( \"GTiff\", \"Setting JPEGCOLORMODE_RGB\" );\n            TIFFSetField( hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );\n        }\n    }\n        \n/* -------------------------------------------------------------------- */\n/*      Does the source image consist of one band, with a palette?      */\n/*      If so, copy over.                                               */\n/* -------------------------------------------------------------------- */\n    if( nBands == 1 && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n        && eType == GDT_Byte )\n    {\n        unsigned short\tanTRed[256], anTGreen[256], anTBlue[256];\n        GDALColorTable *poCT;\n\n        poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n        \n        for( int iColor = 0; iColor < 256; iColor++ )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = (unsigned short) (257 * sRGB.c1);\n                anTGreen[iColor] = (unsigned short) (257 * sRGB.c2);\n                anTBlue[iColor] = (unsigned short) (257 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = anTGreen[iColor] = anTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, anTRed, anTGreen, anTBlue );\n    }\n    else if( nBands == 1 \n             && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n             && eType == GDT_UInt16 )\n    {\n        unsigned short\t*panTRed, *panTGreen, *panTBlue;\n        GDALColorTable *poCT;\n\n        panTRed   = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n        panTGreen = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n        panTBlue  = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n\n        poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n        \n        for( int iColor = 0; iColor < 65536; iColor++ )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                panTRed[iColor] = (unsigned short) (256 * sRGB.c1);\n                panTGreen[iColor] = (unsigned short) (256 * sRGB.c2);\n                panTBlue[iColor] = (unsigned short) (256 * sRGB.c3);\n            }\n            else\n            {\n                panTRed[iColor] = panTGreen[iColor] = panTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n    else if( poSrcDS->GetRasterBand(1)->GetColorTable() != NULL )\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"Unable to export color table to GeoTIFF file.  Color tables\\n\"\n                  \"can only be written to 1 band Byte or UInt16 GeoTIFF files.\" );\n\n/* -------------------------------------------------------------------- */\n/*      Transfer some TIFF specific metadata, if available.             */\n/*      The return value will tell us if we need to try again later with*/\n/*      PAM because the profile doesn't allow to write some metadata    */\n/*      as TIFF tag                                                     */\n/* -------------------------------------------------------------------- */\n    int bHasWrittenMDInGeotiffTAG =\n            GTiffDataset::WriteMetadata( poSrcDS, hTIFF, FALSE, pszProfile,\n                                 pszFilename, papszOptions );\n\n/* -------------------------------------------------------------------- */\n/* \tWrite NoData value, if exist.                                   */\n/* -------------------------------------------------------------------- */\n    if( EQUAL(pszProfile,\"GDALGeoTIFF\") )\n    {\n        int\t\tbSuccess;\n        double\tdfNoData;\n    \n        dfNoData = poSrcDS->GetRasterBand(1)->GetNoDataValue( &bSuccess );\n        if ( bSuccess )\n            GTiffDataset::WriteNoDataValue( hTIFF, dfNoData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write affine transform if it is meaningful.                     */\n/* -------------------------------------------------------------------- */\n    const char *pszProjection = NULL;\n    double      adfGeoTransform[6];\n    \n    if( poSrcDS->GetGeoTransform( adfGeoTransform ) == CE_None\n        && (adfGeoTransform[0] != 0.0 || adfGeoTransform[1] != 1.0\n            || adfGeoTransform[2] != 0.0 || adfGeoTransform[3] != 0.0\n            || adfGeoTransform[4] != 0.0 || ABS(adfGeoTransform[5]) != 1.0 ))\n    {\n        if( bGeoTIFF )\n        {\n            if( adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0 \n                && adfGeoTransform[5] < 0.0 )\n            {\n\n                double\tadfPixelScale[3], adfTiePoints[6];\n\n                adfPixelScale[0] = adfGeoTransform[1];\n                adfPixelScale[1] = fabs(adfGeoTransform[5]);\n                adfPixelScale[2] = 0.0;\n\n                TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n            \n                adfTiePoints[0] = 0.0;\n                adfTiePoints[1] = 0.0;\n                adfTiePoints[2] = 0.0;\n                adfTiePoints[3] = adfGeoTransform[0];\n                adfTiePoints[4] = adfGeoTransform[3];\n                adfTiePoints[5] = 0.0;\n        \n                TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n            }\n            else\n            {\n                double\tadfMatrix[16];\n\n                memset(adfMatrix,0,sizeof(double) * 16);\n\n                adfMatrix[0] = adfGeoTransform[1];\n                adfMatrix[1] = adfGeoTransform[2];\n                adfMatrix[3] = adfGeoTransform[0];\n                adfMatrix[4] = adfGeoTransform[4];\n                adfMatrix[5] = adfGeoTransform[5];\n                adfMatrix[7] = adfGeoTransform[3];\n                adfMatrix[15] = 1.0;\n\n                TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n            }\n            \n            pszProjection = poSrcDS->GetProjectionRef();\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need a TFW file?                                          */\n/* -------------------------------------------------------------------- */\n        if( CSLFetchBoolean( papszOptions, \"TFW\", FALSE ) )\n            GDALWriteWorldFile( pszFilename, \"tfw\", adfGeoTransform );\n        else if( CSLFetchBoolean( papszOptions, \"WORLDFILE\", FALSE ) )\n            GDALWriteWorldFile( pszFilename, \"wld\", adfGeoTransform );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise write tiepoints if they are available.                */\n/* -------------------------------------------------------------------- */\n    else if( poSrcDS->GetGCPCount() > 0 && bGeoTIFF )\n    {\n        const GDAL_GCP *pasGCPs = poSrcDS->GetGCPs();\n        double\t*padfTiePoints;\n\n        padfTiePoints = (double *) \n            CPLMalloc(6*sizeof(double)*poSrcDS->GetGCPCount());\n\n        for( int iGCP = 0; iGCP < poSrcDS->GetGCPCount(); iGCP++ )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPs[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPs[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPs[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPs[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPs[iGCP].dfGCPZ;\n        }\n\n        TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, \n                      6*poSrcDS->GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n        \n        pszProjection = poSrcDS->GetGCPProjection();\n        \n        if( CSLFetchBoolean( papszOptions, \"TFW\", FALSE ) \n            || CSLFetchBoolean( papszOptions, \"WORLDFILE\", FALSE ) )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"TFW=ON or WORLDFILE=ON creation options are ignored when GCPs are available\");\n        }\n    }\n\n    else\n        pszProjection = poSrcDS->GetProjectionRef();\n\n/* -------------------------------------------------------------------- */\n/*      Write the projection information, if possible.                  */\n/* -------------------------------------------------------------------- */\n    if( pszProjection != NULL && strlen(pszProjection) > 0 && bGeoTIFF )\n    {\n        GTIF\t*psGTIF;\n\n        psGTIF = GTIFNew( hTIFF );\n        GTIFSetFromOGISDefn( psGTIF, pszProjection );\n\n        if( poSrcDS->GetMetadataItem( GDALMD_AREA_OR_POINT ) \n            && EQUAL(poSrcDS->GetMetadataItem(GDALMD_AREA_OR_POINT),\n                     GDALMD_AOP_POINT) )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup                                                         */\n/* -------------------------------------------------------------------- */\n    \n    TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTiffCreateCopy()\");\n    TIFFWriteDirectory( hTIFF );\n    TIFFFlush( hTIFF );\n    XTIFFClose( hTIFF );\n    hTIFF = NULL;\n\n    if( eErr != CE_None )\n    {\n        VSIUnlink( pszFilename );\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Re-open as a dataset and copy over missing metadata using       */\n/*      PAM facilities.                                                 */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS;\n    CPLString osFileName(\"GTIFF_RAW:\");\n\n    osFileName += pszFilename;\n\n    poDS = (GTiffDataset *) GDALOpen( osFileName, GA_Update );\n    if( poDS == NULL )\n        poDS = (GTiffDataset *) GDALOpen( osFileName, GA_ReadOnly );\n\n    if ( poDS == NULL )\n    {\n        VSIUnlink( pszFilename );\n        return NULL;\n    }\n\n    poDS->osProfile = pszProfile;\n    poDS->CloneInfo( poSrcDS, GCIF_PAM_DEFAULT );\n    poDS->papszCreationOptions = CSLDuplicate( papszOptions );\n\n/* -------------------------------------------------------------------- */\n/*      CloneInfo() doesn't merge metadata, it just replaces it totally */\n/*      So we have to merge it                                          */\n/* -------------------------------------------------------------------- */\n\n    char **papszSRC_MD = poSrcDS->GetMetadata();\n    char **papszDST_MD = CSLDuplicate(poDS->GetMetadata());\n\n    papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n    poDS->SetMetadata( papszDST_MD );\n    CSLDestroy( papszDST_MD );\n\n    /* Depending on the PHOTOMETRIC tag, the TIFF file may not have */\n    /* the same band count as the source. Will fail later in GDALDatasetCopyWholeRaster anyway... */\n    for( int nBand = 1;\n         nBand <= MIN(poDS->GetRasterCount(), poSrcDS->GetRasterCount()) ;\n         nBand++ )\n    {\n        char **papszSRC_MD = poSrcDS->GetRasterBand(nBand)->GetMetadata();\n        char **papszDST_MD = CSLDuplicate(poDS->GetRasterBand(nBand)->GetMetadata());\n\n        papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n        poDS->GetRasterBand(nBand)->SetMetadata( papszDST_MD );\n        CSLDestroy( papszDST_MD );\n    }\n\n    hTIFF = (TIFF*) poDS->GetInternalHandle(NULL);\n\n/* -------------------------------------------------------------------- */\n/*      Second chance : now that we have a PAM dataset, it is possible  */\n/*      to write metadata that we couldn't be writen as TIFF tag        */\n/* -------------------------------------------------------------------- */\n    if (!bHasWrittenMDInGeotiffTAG)\n        GTiffDataset::WriteMetadata( poDS, hTIFF, TRUE, pszProfile,\n                                     pszFilename, papszOptions, TRUE /* don't write RPC and IMG file again */);\n\n    /* To avoid unnecessary directory rewriting */\n    poDS->bMetadataChanged = FALSE;\n    poDS->bGeoTIFFInfoChanged = FALSE;\n\n    /* We must re-set the compression level at this point, since it has */\n    /* been lost a few lines above when closing the newly create TIFF file */\n    /* The TIFFTAG_ZIPQUALITY & TIFFTAG_JPEGQUALITY are not store in the TIFF file. */\n    /* They are just TIFF session parameters */\n    if (nCompression == COMPRESSION_ADOBE_DEFLATE)\n    {\n        int nZLevel = GTiffGetZLevel(papszOptions);\n        if (nZLevel != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_ZIPQUALITY, nZLevel );\n        }\n    }\n    else if( nCompression == COMPRESSION_JPEG)\n    {\n        int nJpegQuality = GTiffGetJpegQuality(papszOptions);\n        if (nJpegQuality != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_JPEGQUALITY, nJpegQuality );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy actual imagery.                                            */\n/* -------------------------------------------------------------------- */\n\n    if (poDS->bTreatAsSplit || poDS->bTreatAsSplitBitmap)\n    {\n        /* For split bands, we use TIFFWriteScanline() interface */\n        CPLAssert(poDS->nBitsPerSample == 8 || poDS->nBitsPerSample == 1);\n        \n        if (poDS->nPlanarConfig == PLANARCONFIG_CONTIG && poDS->nBands > 1)\n        {\n            int j;\n            GByte* pabyScanline = (GByte *) CPLMalloc(TIFFScanlineSize(hTIFF));\n            eErr = CE_None;\n            for(j=0;j<nYSize && eErr == CE_None;j++)\n            {\n                eErr = poSrcDS->RasterIO(GF_Read, 0, j, nXSize, 1,\n                                         pabyScanline, nXSize, 1,\n                                         GDT_Byte, nBands, NULL, poDS->nBands, 0, 1);\n                if (eErr == CE_None &&\n                    TIFFWriteScanline( hTIFF, pabyScanline, j, 0) == -1)\n                {\n                    CPLError( CE_Failure, CPLE_AppDefined,\n                              \"TIFFWriteScanline() failed.\" );\n                    eErr = CE_Failure;\n                }\n                if( !pfnProgress( (j+1) * 1.0 / nYSize, NULL, pProgressData ) )\n                    eErr = CE_Failure;\n            }\n            CPLFree(pabyScanline);\n        }\n        else\n        {\n            int iBand, j;\n            GByte* pabyScanline = (GByte *) CPLMalloc(TIFFScanlineSize(hTIFF));\n            eErr = CE_None;\n            for(iBand=1;iBand<=nBands && eErr == CE_None;iBand++)\n            {\n                for(j=0;j<nYSize && eErr == CE_None;j++)\n                {\n                    eErr = poSrcDS->GetRasterBand(iBand)->RasterIO(\n                                                    GF_Read, 0, j, nXSize, 1,\n                                                    pabyScanline, nXSize, 1,\n                                                    GDT_Byte, 0, 0);\n                    if (poDS->bTreatAsSplitBitmap)\n                    {\n                        for(int i=0;i<nXSize;i++)\n                        {\n                            GByte byVal = pabyScanline[i];\n                            if ((i & 0x7) == 0)\n                                pabyScanline[i >> 3] = 0;\n                            if (byVal)\n                                pabyScanline[i >> 3] |= (0x80 >> (i & 0x7));\n                        }\n                    }\n                    if (eErr == CE_None &&\n                        TIFFWriteScanline( hTIFF, pabyScanline, j, iBand - 1) == -1)\n                    {\n                        CPLError( CE_Failure, CPLE_AppDefined,\n                                  \"TIFFWriteScanline() failed.\" );\n                        eErr = CE_Failure;\n                    }\n                    if( !pfnProgress( (j+1 + (iBand - 1) * nYSize) * 1.0 /\n                                      (nBands * nYSize), NULL, pProgressData ) )\n                        eErr = CE_Failure;\n                }\n            }\n            CPLFree(pabyScanline);\n        }\n        \n        /* Necessary to be able to read the file without re-opening */\n        TIFFFlush( hTIFF );\n    }\n    else\n    {\n        char* papszCopyWholeRasterOptions[2] = { NULL, NULL };\n        if (nCompression != COMPRESSION_NONE)\n            papszCopyWholeRasterOptions[0] = (char*) \"COMPRESSED=YES\";\n        eErr = GDALDatasetCopyWholeRaster( (GDALDatasetH) poSrcDS, \n                                            (GDALDatasetH) poDS,\n                                            papszCopyWholeRasterOptions,\n                                            pfnProgress, pProgressData );\n    }\n\n    if( eErr == CE_Failure )\n    {\n        delete poDS;\n        poDS = NULL;\n\n        VSIUnlink( pszFilename ); // should really delete more carefully.\n    }\n\n    return poDS;\n}",
    "INGR_VirtualFile CPL_STDCALL INGR_CreateVirtualFile( const char *pszFilename,\n                                                     INGR_Format eFormat,\n                                                     int nXSize, \n                                                     int nYSize,\n                                                     int nTileSize,\n                                                     int nQuality,\n                                                     GByte *pabyBuffer,\n                                                     int nBufferSize,\n                                                     int nBand )\n{\n    INGR_VirtualFile hVirtual;\n\n    hVirtual.pszFileName = CPLSPrintf( \"/vsimem/%s.virtual\",\n        CPLGetBasename( pszFilename ) );\n\n    int nJPGComponents = 1;\n\n    switch( eFormat )\n    {\n    case JPEGRGB: \n        nJPGComponents = 3;\n    case JPEGGRAY:\n        {\n            GByte *pabyHeader = (GByte*) CPLCalloc( 1, 2048 );\n            int nHeaderSize   = JPGHLP_HeaderMaker( pabyHeader,\n                                                    nTileSize,\n                                                    nTileSize,\n                                                    nJPGComponents,\n                                                    0,\n                                                    nQuality );\n            FILE *fp = VSIFOpenL( hVirtual.pszFileName, \"w+\" );\n            VSIFWriteL( pabyHeader, 1, nHeaderSize, fp );\n            VSIFWriteL( pabyBuffer, 1, nBufferSize, fp );\n            VSIFCloseL( fp );\n            CPLFree( pabyHeader );\n            break;\n        }\n    case CCITTGroup4:\n        {\n            REVERSEBITSBUFFER( pabyBuffer, nBufferSize );\n            TIFF *hTIFF = VSI_TIFFOpen( hVirtual.pszFileName, \"w+\" );\n            TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH,      nXSize );\n            TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH,     nYSize );\n            TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE,   1 );\n            TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT,    SAMPLEFORMAT_UINT );\n            TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG,    PLANARCONFIG_CONTIG );\n            TIFFSetField( hTIFF, TIFFTAG_FILLORDER,       FILLORDER_MSB2LSB );\n            TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP,    -1 );\n            TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, 1 );\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC,     PHOTOMETRIC_MINISWHITE );\n            TIFFSetField( hTIFF, TIFFTAG_COMPRESSION,     COMPRESSION_CCITTFAX4 );\n            TIFFWriteRawStrip( hTIFF, 0, pabyBuffer, nBufferSize );\n            TIFFWriteDirectory( hTIFF );\n            TIFFClose( hTIFF );\n            break;\n        }\n    default:\n        return hVirtual;\n    }\n\n    hVirtual.poDS   = (GDALDataset*) GDALOpen( hVirtual.pszFileName, GA_ReadOnly );\n\n    if( hVirtual.poDS )\n    {\n        hVirtual.poBand = (GDALRasterBand*) GDALGetRasterBand( hVirtual.poDS, nBand );\n    }\n\n    return hVirtual;\n}",
    "CPLErr GTIFMemBufFromWkt( const char *pszWKT, const double *padfGeoTransform,\n                          int nGCPCount, const GDAL_GCP *pasGCPList,\n                          int *pnSize, unsigned char **ppabyBuffer )\n\n{\n    TIFF        *hTIFF;\n    GTIF \t*hGTIF;\n    char        szFilename[100];\n\n    sprintf( szFilename, \"/vsimem/wkt_from_mem_buf_%ld.tif\", \n             (long) CPLGetPID() );\n\n/* -------------------------------------------------------------------- */\n/*      Initialize access to the memory geotiff structure.              */\n/* -------------------------------------------------------------------- */\n    hTIFF = VSI_TIFFOpen( szFilename, \"w\" );\n\n    if( hTIFF == NULL )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"TIFF/GeoTIFF structure is corrupt.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write some minimal set of image parameters.                     */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, 8 );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n    TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n    \n/* -------------------------------------------------------------------- */\n/*      Get the projection definition.                                  */\n/* -------------------------------------------------------------------- */\n\n    if( pszWKT != NULL )\n    {\n        hGTIF = GTIFNew(hTIFF);\n        GTIFSetFromOGISDefn( hGTIF, pszWKT );\n        GTIFWriteKeys( hGTIF );\n        GTIFFree( hGTIF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Set the geotransform, or GCPs.                                  */\n/* -------------------------------------------------------------------- */\n    if( padfGeoTransform[0] != 0.0 || padfGeoTransform[1] != 1.0\n        || padfGeoTransform[2] != 0.0 || padfGeoTransform[3] != 0.0\n        || padfGeoTransform[4] != 0.0 || ABS(padfGeoTransform[5]) != 1.0 )\n    {\n\n        if( padfGeoTransform[2] == 0.0 && padfGeoTransform[4] == 0.0 )\n        {\n            double\tadfPixelScale[3], adfTiePoints[6];\n\n            adfPixelScale[0] = padfGeoTransform[1];\n            adfPixelScale[1] = fabs(padfGeoTransform[5]);\n            adfPixelScale[2] = 0.0;\n\n            TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n            \n            adfTiePoints[0] = 0.0;\n            adfTiePoints[1] = 0.0;\n            adfTiePoints[2] = 0.0;\n            adfTiePoints[3] = padfGeoTransform[0];\n            adfTiePoints[4] = padfGeoTransform[3];\n            adfTiePoints[5] = 0.0;\n        \n            TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n        }\n        else\n        {\n            double\tadfMatrix[16];\n\n            memset(adfMatrix,0,sizeof(double) * 16);\n\n            adfMatrix[0] = padfGeoTransform[1];\n            adfMatrix[1] = padfGeoTransform[2];\n            adfMatrix[3] = padfGeoTransform[0];\n            adfMatrix[4] = padfGeoTransform[4];\n            adfMatrix[5] = padfGeoTransform[5];\n            adfMatrix[7] = padfGeoTransform[3];\n            adfMatrix[15] = 1.0;\n\n            TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise write tiepoints if they are available.                */\n/* -------------------------------------------------------------------- */\n    else if( nGCPCount > 0 )\n    {\n        double\t*padfTiePoints;\n\n        padfTiePoints = (double *) CPLMalloc(6*sizeof(double)*nGCPCount);\n\n        for( int iGCP = 0; iGCP < nGCPCount; iGCP++ )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPList[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPList[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPList[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPList[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPList[iGCP].dfGCPZ;\n        }\n\n        TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6*nGCPCount, padfTiePoints);\n        CPLFree( padfTiePoints );\n    } \n\n/* -------------------------------------------------------------------- */\n/*      Cleanup and return the created memory buffer.                   */\n/* -------------------------------------------------------------------- */\n    GByte bySmallImage = 0;\n\n    TIFFWriteEncodedStrip( hTIFF, 0, (char *) &bySmallImage, 1 );\n    TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTIFMemBufFromWkt\");\n    TIFFWriteDirectory( hTIFF );\n\n    XTIFFClose( hTIFF );\n\n/* -------------------------------------------------------------------- */\n/*      Read back from the memory buffer.  It would be preferrable      */\n/*      to be able to \"steal\" the memory buffer, but there isn't        */\n/*      currently any support for this.                                 */\n/* -------------------------------------------------------------------- */\n    GUIntBig nBigLength;\n\n    *ppabyBuffer = VSIGetMemFileBuffer( szFilename, &nBigLength, TRUE );\n    *pnSize = (int) nBigLength;\n\n    return CE_None;\n}",
    "int NITFUncompressBILEVEL( NITFImage *psImage, \n                           GByte *pabyInputData, int nInputBytes,\n                           GByte *pabyOutputImage )\n\n{\n    int nOutputBytes= (psImage->nBlockWidth * psImage->nBlockHeight + 7)/8;\n\n/* -------------------------------------------------------------------- */\n/*      Write memory TIFF with the bilevel data.                        */\n/* -------------------------------------------------------------------- */\n    CPLString osFilename;\n\n    osFilename.Printf( \"/vsimem/nitf-wrk-%ld.tif\", (long) CPLGetPID() );\n\n    TIFF *hTIFF = VSI_TIFFOpen( osFilename, \"w+\" );\n    if (hTIFF == NULL)\n    {\n        return FALSE;\n    }\n\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH,    psImage->nBlockWidth );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH,   psImage->nBlockHeight );\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT,  SAMPLEFORMAT_UINT );\n    TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG,  PLANARCONFIG_CONTIG );\n    TIFFSetField( hTIFF, TIFFTAG_FILLORDER,     FILLORDER_MSB2LSB );\n\n    TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP,  psImage->nBlockHeight );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX3 );\n    \n    if( psImage->szCOMRAT[0] == '2' )\n        TIFFSetField( hTIFF, TIFFTAG_GROUP3OPTIONS, GROUP3OPT_2DENCODING );\n\n    TIFFWriteRawStrip( hTIFF, 0, pabyInputData, nInputBytes );\n    TIFFWriteDirectory( hTIFF );\n\n    TIFFClose( hTIFF );\n\n/* -------------------------------------------------------------------- */\n/*      Now open and read it back.                                      */\n/* -------------------------------------------------------------------- */\n    int bResult = TRUE;\n\n    hTIFF = VSI_TIFFOpen( osFilename, \"r\" );\n    if (hTIFF == NULL)\n    {\n        return FALSE;\n    }\n\n\n    if( TIFFReadEncodedStrip( hTIFF, 0, pabyOutputImage, nOutputBytes ) == -1 )\n    {\n        memset( pabyOutputImage, 0, nOutputBytes );\n        bResult = FALSE;\n    }\n\n    TIFFClose( hTIFF );\n\n    VSIUnlink( osFilename );\n\n    return bResult;\n}",
    "bool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.simplesystems.org/libtiff/functions/TIFFOpen.html\n    TIFF* tif = NULL;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!tif)\n    {\n        return false;\n    }\n    cv::Ptr<void> tif_cleanup(tif, cv_tiffCloseHandle);\n\n    //Settings that matter to all images\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, IMWRITE_TIFF_COMPRESSION, compression);\n    readParam(params, IMWRITE_TIFF_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        CV_Assert(!img.empty());\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int type = img.type();\n        int depth = CV_MAT_DEPTH(type);\n        CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n        CV_CheckType(type, channels >= 1 && channels <= 4, \"\");\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height));\n\n        if (img_vec.size() > 1)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE));\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PAGENUMBER, page, img_vec.size()));\n        }\n\n        int compression_param = -1;  // OPENCV_FUTURE\n        if (type == CV_32FC3 && (!readParam(params, IMWRITE_TIFF_COMPRESSION, compression_param) || compression_param == COMPRESSION_SGILOG))\n        {\n            if (!write_32FC3_SGILOG(img, tif))\n                return false;\n            continue;\n        }\n\n        int page_compression = compression;\n\n        int bitsPerChannel = -1;\n        uint16_t sample_format = SAMPLEFORMAT_INT;\n        switch (depth)\n        {\n            case CV_8U:\n                sample_format = SAMPLEFORMAT_UINT;\n                /* FALLTHRU */\n            case CV_8S:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n\n            case CV_16U:\n                sample_format = SAMPLEFORMAT_UINT;\n                /* FALLTHRU */\n            case CV_16S:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n\n            case CV_32S:\n            {\n                bitsPerChannel = 32;\n                sample_format = SAMPLEFORMAT_INT;\n                break;\n            }\n            case CV_32F:\n            {\n                bitsPerChannel = 32;\n                page_compression = COMPRESSION_NONE;\n                sample_format = SAMPLEFORMAT_IEEEFP;\n                break;\n            }\n            case CV_64F:\n            {\n                bitsPerChannel = 64;\n                page_compression = COMPRESSION_NONE;\n                sample_format = SAMPLEFORMAT_IEEEFP;\n                break;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n        CV_Assert(fileStep > 0);\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, IMWRITE_TIFF_ROWSPERSTRIP, rowsPerStrip);\n        rowsPerStrip = std::max(1, std::min(height, rowsPerStrip));\n\n        int colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerChannel));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, page_compression));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, colorspace));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsPerStrip));\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, sample_format));\n\n        if (page_compression == COMPRESSION_LZW || page_compression == COMPRESSION_ADOBE_DEFLATE || page_compression == COMPRESSION_DEFLATE)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor));\n        }\n\n        if (resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resUnit));\n        }\n        if (dpiX >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)dpiX));\n        }\n        if (dpiY >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)dpiY));\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(tif);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data(); CV_DbgAssert(buffer);\n        Mat m_buffer(Size(width, 1), CV_MAKETYPE(depth, channels), buffer, (size_t)scanlineSize);\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    std::memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    extend_cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGR2RGB);\n                    break;\n                }\n\n                case 4:\n                {\n                    extend_cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGRA2RGBA);\n                    break;\n                }\n\n                default:\n                {\n                    CV_Assert(0);\n                }\n            }\n\n            CV_TIFF_CHECK_CALL(TIFFWriteScanline(tif, buffer, y, 0) == 1);\n        }\n\n        CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    }\n\n    return true;\n}",
    "bool TiffEncoder::write_32FC3_SGILOG(const Mat& _img, void* tif_)\n{\n    TIFF* tif = (TIFF*)tif_;\n    CV_Assert(tif);\n\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols));\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1));\n    const int strip_size = 3 * img.cols;\n    for (int i = 0; i < img.rows; i++)\n    {\n        CV_TIFF_CHECK_CALL(TIFFWriteEncodedStrip(tif, i, (tdata_t)img.ptr<float>(i), strip_size * sizeof(float)) != (tsize_t)-1);\n    }\n    CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    return true;\n}",
    "bool KisTIFFWriterVisitor::saveLayerProjection(KisLayer *layer)\n{\n    dbgFile << \"visiting on layer\" << layer->name() << \"\";\n    KisPaintDeviceSP pd = layer->projection();\n\n    uint16_t color_type = 0;\n    uint16_t sample_format = SAMPLEFORMAT_UINT;\n    const KoColorSpace *destColorSpace = nullptr;\n    // Check colorspace\n    if (!writeColorSpaceInformation(image(), pd->colorSpace(), color_type, sample_format, destColorSpace)) { // unsupported colorspace\n        if (!destColorSpace) {\n            return false;\n        }\n        pd.attach(new KisPaintDevice(*pd));\n        pd->convertTo(destColorSpace);\n    }\n\n    {\n        // WORKAROUND: block any attempts to use YCbCr with alpha channels.\n        // This should not happen because alpha is disabled by default\n        // and the checkbox is blocked for YCbCr and CMYK.\n        KIS_SAFE_ASSERT_RECOVER(color_type != PHOTOMETRIC_YCBCR\n                                || !m_options->alpha)\n        {\n            warnFile << \"TIFF does not support exporting alpha channels with \"\n                        \"YCbCr. Skipping...\";\n            m_options->alpha = false;\n        }\n    }\n\n    // Save depth\n    uint32_t depth = 8 * pd->pixelSize() / pd->channelCount();\n    TIFFSetField(image(), TIFFTAG_BITSPERSAMPLE, depth);\n\n    {\n        // WORKAROUND: block any attempts to use JPEG with >= 8 bits\n\n        if (m_options->compressionType == COMPRESSION_JPEG && depth != 8) {\n            warnFile << \"Attempt to export JPEG with multi-byte depth, \"\n                        \"disabling compression\";\n            m_options->compressionType = COMPRESSION_NONE;\n        }\n    }\n\n    // Save number of samples\n    if (m_options->alpha) {\n        TIFFSetField(image(), TIFFTAG_SAMPLESPERPIXEL, pd->channelCount());\n        const std::array<uint16_t, 1> sampleinfo = {EXTRASAMPLE_UNASSALPHA};\n        TIFFSetField(image(), TIFFTAG_EXTRASAMPLES, 1, sampleinfo.data());\n    } else {\n        TIFFSetField(image(), TIFFTAG_SAMPLESPERPIXEL, pd->channelCount() - 1);\n        TIFFSetField(image(), TIFFTAG_EXTRASAMPLES, 0);\n    }\n\n    // Save colorspace information\n    TIFFSetField(image(), TIFFTAG_PHOTOMETRIC, color_type);\n    TIFFSetField(image(), TIFFTAG_SAMPLEFORMAT, sample_format);\n    TIFFSetField(image(), TIFFTAG_IMAGEWIDTH, layer->image()->width());\n    TIFFSetField(image(), TIFFTAG_IMAGELENGTH, layer->image()->height());\n\n    // Set the compression options\n    TIFFSetField(image(), TIFFTAG_COMPRESSION, m_options->compressionType);\n    if (m_options->compressionType == COMPRESSION_JPEG) {\n        TIFFSetField(image(), TIFFTAG_JPEGQUALITY, m_options->jpegQuality);\n    } else if (m_options->compressionType == COMPRESSION_ADOBE_DEFLATE) {\n        TIFFSetField(image(), TIFFTAG_ZIPQUALITY, m_options->deflateCompress);\n    } else if (m_options->compressionType == COMPRESSION_PIXARLOG) {\n        TIFFSetField(image(),\n                     TIFFTAG_PIXARLOGQUALITY,\n                     m_options->pixarLogCompress);\n    }\n\n    // Set the predictor\n    if (m_options->compressionType == COMPRESSION_LZW\n        || m_options->compressionType == COMPRESSION_ADOBE_DEFLATE)\n        TIFFSetField(image(), TIFFTAG_PREDICTOR, m_options->predictor);\n\n    // Use contiguous configuration\n    TIFFSetField(image(), TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n    // Do not set the rowsperstrip, as it's incompatible with JPEG\n\n    // But do set YCbCr 4:4:4 if applicable\n    if (color_type == PHOTOMETRIC_YCBCR) {\n        TIFFSetField(image(), TIFFTAG_YCBCRSUBSAMPLING, 1, 1);\n        TIFFSetField(image(), TIFFTAG_YCBCRPOSITIONING, YCBCRPOSITION_CENTERED);\n        if (m_options->compressionType == COMPRESSION_JPEG) {\n            TIFFSetField(image(), TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n        }\n    }\n\n    // Save profile\n    if (m_options->saveProfile) {\n        const KoColorProfile* profile = pd->colorSpace()->profile();\n        if (profile && profile->type() == \"icc\" && !profile->rawData().isEmpty()) {\n            QByteArray ba = profile->rawData();\n            TIFFSetField(image(), TIFFTAG_ICCPROFILE, ba.size(), ba.constData());\n        }\n    }\n\n    {\n        // IPTC\n        KisMetaData::IOBackend *io =\n            KisMetadataBackendRegistry::instance()->value(\"iptc\");\n        QBuffer buf;\n        io->saveTo(layer->metaData(), &buf, KisMetaData::IOBackend::NoHeader);\n\n        if (buf.size()\n            && !TIFFSetField(image(),\n                             TIFFTAG_RICHTIFFIPTC,\n                             static_cast<uint32_t>(buf.size()),\n                             buf.data().data())) {\n            dbgFile << \"Failed to write the IPTC metadata to the TIFF field\";\n        }\n    }\n\n    {\n        // XMP\n        KisMetaData::IOBackend *io =\n            KisMetadataBackendRegistry::instance()->value(\"xmp\");\n        QBuffer buf;\n        io->saveTo(layer->metaData(), &buf, KisMetaData::IOBackend::NoHeader);\n\n        if (buf.size()\n            && !TIFFSetField(image(),\n                             TIFFTAG_XMLPACKET,\n                             static_cast<uint32_t>(buf.size()),\n                             buf.data().data())) {\n            dbgFile << \"Failed to write the XMP metadata to the TIFF field\";\n        }\n    }\n\n    tsize_t stripsize = TIFFStripSize(image());\n    std::unique_ptr<std::remove_pointer_t<tdata_t>, decltype(&_TIFFfree)> buff(\n        _TIFFmalloc(stripsize),\n        &_TIFFfree);\n    KIS_ASSERT_RECOVER_RETURN_VALUE(\n        buff && \"Unable to allocate buffer for TIFF!\",\n        false);\n    qint32 height = layer->image()->height();\n    qint32 width = layer->image()->width();\n    bool r = true;\n    for (int y = 0; y < height; y++) {\n        KisHLineConstIteratorSP it = pd->createHLineConstIteratorNG(0, y, width);\n        switch (color_type) {\n        case PHOTOMETRIC_MINISBLACK: {\n            const std::array<quint8, 5> poses = {0, 1};\n            r = copyDataToStrips(it,\n                                 buff.get(),\n                                 depth,\n                                 sample_format,\n                                 1,\n                                 poses);\n            }\n            break;\n        case PHOTOMETRIC_RGB: {\n            const auto poses = [&]() -> std::array<quint8, 5> {\n                if (sample_format == SAMPLEFORMAT_IEEEFP) {\n                    return {0, 1, 2, 3};\n                } else {\n                    return {2, 1, 0, 3};\n                }\n            }();\n            r = copyDataToStrips(it,\n                                 buff.get(),\n                                 depth,\n                                 sample_format,\n                                 3,\n                                 poses);\n            }\n            break;\n        case PHOTOMETRIC_SEPARATED: {\n            const std::array<quint8, 5> poses = {0, 1, 2, 3, 4};\n            r = copyDataToStrips(it,\n                                 buff.get(),\n                                 depth,\n                                 sample_format,\n                                 4,\n                                 poses);\n            }\n            break;\n            case PHOTOMETRIC_ICCLAB:\n            case PHOTOMETRIC_YCBCR: {\n                const std::array<quint8, 5> poses = {0, 1, 2, 3};\n                r = copyDataToStrips(it,\n                                     buff.get(),\n                                     depth,\n                                     sample_format,\n                                     3,\n                                     poses);\n            } break;\n        }\n        if (!r) return false;\n        TIFFWriteScanline(image(),\n                          buff.get(),\n                          static_cast<uint32_t>(y),\n                          (tsample_t)-1);\n    }\n    buff.reset();\n\n    return TIFFWriteDirectory(image());\n}",
    "KisImportExportErrorCode KisTiffPsdWriter::writeImage(KisGroupLayerSP layer)\n{\n    dbgFile << \"Starting write of Photoshop layer data\";\n\n    /**\n     * For Photoshop tiff files, first thing is to write the\n     * projection of the image file.\n     */\n\n    if (layer->image()->width() > MAX_PSD_SIZE || layer->image()->height() > MAX_PSD_SIZE) {\n        dbgFile << \"This TIFF file is too big to be represented as a PSD blob!\";\n        return ImportExportCodes::Failure;\n    }\n\n    dbgFile << \"Writing root layer projection\";\n    KisPaintDeviceSP pd = layer->projection();\n\n    uint16_t color_type = 0;\n    uint16_t sample_format = SAMPLEFORMAT_UINT;\n    const KoColorSpace *destColorSpace = nullptr;\n    // Check colorspace\n    if (!writeColorSpaceInformation(image(), pd->colorSpace(), color_type, sample_format, destColorSpace)) { // unsupported colorspace\n        if (!destColorSpace) {\n            dbgFile << \"Unsupported colorspace\" << pd->colorSpace()->name();\n            return ImportExportCodes::FormatColorSpaceUnsupported;\n        }\n        pd.attach(new KisPaintDevice(*pd));\n        pd->convertTo(destColorSpace);\n    }\n\n    {\n        // WORKAROUND: block any attempts to use YCbCr with alpha channels.\n        // This should not happen because alpha is disabled by default\n        // and the checkbox is blocked for YCbCr and CMYK.\n        KIS_SAFE_ASSERT_RECOVER(color_type != PHOTOMETRIC_YCBCR\n                                || !m_options->alpha)\n        {\n            warnFile << \"TIFF does not support exporting alpha channels with \"\n                        \"YCbCr. Skipping...\";\n            m_options->alpha = false;\n        }\n    }\n\n    // Save depth\n    uint32_t depth = 8 * pd->pixelSize() / pd->channelCount();\n    TIFFSetField(image(), TIFFTAG_BITSPERSAMPLE, depth);\n\n    {\n        // WORKAROUND: block any attempts to use JPEG with >= 8 bits\n\n        if (m_options->compressionType == COMPRESSION_JPEG && depth != 8) {\n            warnFile << \"Attempt to export JPEG with multi-byte depth, \"\n                        \"disabling compression\";\n            m_options->compressionType = COMPRESSION_NONE;\n        }\n    }\n\n    // Save number of samples\n    if (m_options->alpha) {\n        TIFFSetField(image(), TIFFTAG_SAMPLESPERPIXEL, pd->channelCount());\n        const std::array<uint16_t, 1> sampleinfo = {EXTRASAMPLE_UNASSALPHA};\n        TIFFSetField(image(), TIFFTAG_EXTRASAMPLES, 1, sampleinfo.data());\n    } else {\n        TIFFSetField(image(), TIFFTAG_SAMPLESPERPIXEL, pd->channelCount() - 1);\n        TIFFSetField(image(), TIFFTAG_EXTRASAMPLES, 0);\n    }\n\n    // Save colorspace information\n    TIFFSetField(image(), TIFFTAG_PHOTOMETRIC, color_type);\n    TIFFSetField(image(), TIFFTAG_SAMPLEFORMAT, sample_format);\n    TIFFSetField(image(), TIFFTAG_IMAGEWIDTH, layer->image()->width());\n    TIFFSetField(image(), TIFFTAG_IMAGELENGTH, layer->image()->height());\n\n    // Set the compression options\n    TIFFSetField(image(), TIFFTAG_COMPRESSION, m_options->compressionType);\n    if (m_options->compressionType == COMPRESSION_JPEG) {\n        TIFFSetField(image(), TIFFTAG_JPEGQUALITY, m_options->jpegQuality);\n    } else if (m_options->compressionType == COMPRESSION_ADOBE_DEFLATE) {\n        TIFFSetField(image(), TIFFTAG_ZIPQUALITY, m_options->deflateCompress);\n    } else if (m_options->compressionType == COMPRESSION_PIXARLOG) {\n        TIFFSetField(image(),\n                     TIFFTAG_PIXARLOGQUALITY,\n                     m_options->pixarLogCompress);\n    }\n\n    // Set the predictor\n    if (m_options->compressionType == COMPRESSION_LZW\n        || m_options->compressionType == COMPRESSION_ADOBE_DEFLATE)\n        TIFFSetField(image(), TIFFTAG_PREDICTOR, m_options->predictor);\n\n    // Use contiguous configuration\n    TIFFSetField(image(), TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n    // Do not set the rowsperstrip, as it's incompatible with JPEG\n\n    // But do set YCbCr 4:4:4 if applicable\n    if (color_type == PHOTOMETRIC_YCBCR) {\n        TIFFSetField(image(), TIFFTAG_YCBCRSUBSAMPLING, 1, 1);\n        TIFFSetField(image(), TIFFTAG_YCBCRPOSITIONING, YCBCRPOSITION_CENTERED);\n        if (m_options->compressionType == COMPRESSION_JPEG) {\n            TIFFSetField(image(), TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n        }\n    }\n\n    // Save profile\n    if (m_options->saveProfile) {\n        const KoColorProfile *profile = pd->colorSpace()->profile();\n        if (profile && profile->type() == \"icc\" && !profile->rawData().isEmpty()) {\n            QByteArray ba = profile->rawData();\n            TIFFSetField(image(), TIFFTAG_ICCPROFILE, ba.size(), ba.constData());\n        }\n    }\n    tsize_t stripsize = TIFFStripSize(image());\n    std::unique_ptr<std::remove_pointer_t<tdata_t>, decltype(&_TIFFfree)> buff(\n        _TIFFmalloc(stripsize),\n        &_TIFFfree);\n    KIS_ASSERT_RECOVER_RETURN_VALUE(\n        buff && \"Unable to allocate buffer for TIFF!\",\n        ImportExportCodes::InsufficientMemory);\n    qint32 height = layer->image()->height();\n    qint32 width = layer->image()->width();\n    bool r = true;\n    for (qint32 y = 0; y < height; y++) {\n        KisHLineConstIteratorSP it = pd->createHLineConstIteratorNG(0, y, width);\n        switch (color_type) {\n        case PHOTOMETRIC_MINISBLACK: {\n            const std::array<quint8, 5> poses = {0, 1};\n            r = copyDataToStrips(it,\n                                 buff.get(),\n                                 depth,\n                                 sample_format,\n                                 1,\n                                 poses);\n        } break;\n        case PHOTOMETRIC_RGB: {\n            const auto poses = [&]() -> std::array<quint8, 5> {\n                if (sample_format == SAMPLEFORMAT_IEEEFP) {\n                    return {0, 1, 2, 3};\n                } else {\n                    return {2, 1, 0, 3};\n                }\n            }();\n            r = copyDataToStrips(it,\n                                 buff.get(),\n                                 depth,\n                                 sample_format,\n                                 3,\n                                 poses);\n        } break;\n        case PHOTOMETRIC_SEPARATED: {\n            const std::array<quint8, 5> poses = {0, 1, 2, 3, 4};\n            r = copyDataToStrips(it,\n                                 buff.get(),\n                                 depth,\n                                 sample_format,\n                                 4,\n                                 poses);\n        } break;\n        case PHOTOMETRIC_ICCLAB:\n        case PHOTOMETRIC_YCBCR: {\n            const std::array<quint8, 5> poses = {0, 1, 2, 3};\n            r = copyDataToStrips(it,\n                                 buff.get(),\n                                 depth,\n                                 sample_format,\n                                 3,\n                                 poses);\n        } break;\n        }\n        if (!r)\n            return ImportExportCodes::InternalError;\n        TIFFWriteScanline(image(),\n                          buff.get(),\n                          static_cast<quint32>(y),\n                          (tsample_t)-1);\n    }\n    buff.reset();\n\n    ///* BEGIN PHOTOSHOP SPECIFIC HANDLING CODE *///\n\n    /**\n     * Synthesize the PSD file into the TIFFTAG_IMAGESOURCEDATA field.\n     */\n\n    {\n        const bool haveLayers = layer->childCount() > 1 || KisPainter::checkDeviceHasTransparency(layer->firstChild()->projection());\n\n        QBuffer buf;\n        buf.open(QIODevice::WriteOnly);\n\n        dbgFile << \"m_image->rootLayer->childCount\" << layer->childCount() << buf.pos();\n\n        if (haveLayers) {\n            KisTiffPsdLayerRecord layerSection(\n                TIFFIsBigEndian(image()),\n                static_cast<uint32_t>(width),\n                static_cast<uint32_t>(height),\n                static_cast<uint16_t>(depth),\n                static_cast<uint16_t>(pd->channelCount()),\n                color_type,\n                true);\n\n            if (!layerSection.write(buf, layer, static_cast<psd_compression_type>(m_options->psdCompressionType))) {\n                dbgFile << \"failed to write layer section. Error:\" << layerSection.record()->error << buf.pos();\n                return ImportExportCodes::ErrorWhileWriting;\n            }\n        } else {\n            // else write a zero length block\n            dbgFile << \"No layers, saving empty layers/mask block\" << buf.pos();\n            psdwrite(buf, (quint32)0);\n        }\n\n        buf.close();\n        buf.open(QIODevice::ReadOnly);\n\n        if (!TIFFSetField(image(), TIFFTAG_IMAGESOURCEDATA, static_cast<uint32_t>(buf.size()), buf.data().constData())) {\n            dbgFile << \"Failed to write the PSD image block to the TIFF field\";\n            return ImportExportCodes::ErrorWhileWriting;\n        }\n    }\n\n    /**\n     * Write all the annotations into the TIFFTAG_PHOTOSHOP field.\n     */\n\n    {\n        // IMAGE RESOURCES SECTION\n        KisTiffPsdResourceRecord resourceSection;\n\n        for (vKisAnnotationSP_it it = layer->image()->beginAnnotations(); it != layer->image()->endAnnotations(); ++it) {\n            KisAnnotationSP annotation = (*it);\n            if (!annotation || annotation->type().isEmpty()) {\n                dbgFile << \"Warning: empty annotation\";\n                continue;\n            }\n\n            dbgFile << \"Annotation:\" << annotation->type() << annotation->description();\n\n            if (annotation->type().startsWith(QString(\"PSD Resource Block:\"))) { //\n                PSDResourceBlock *resourceBlock =\n                    dynamic_cast<PSDResourceBlock *>(annotation.data());\n                if (resourceBlock) {\n                    dbgFile << \"Adding PSD Resource Block\" << resourceBlock->identifier;\n                    resourceSection.resources[(KisTiffPsdResourceRecord::PSDResourceID)resourceBlock->identifier] = resourceBlock;\n                }\n            }\n        }\n\n        // Add resolution block\n        {\n            auto *resInfo = new RESN_INFO_1005();\n            resInfo->hRes = static_cast<int>(INCH_TO_POINT(layer->image()->xRes()));\n            resInfo->vRes = static_cast<int>(INCH_TO_POINT(layer->image()->yRes()));\n            auto *block = new PSDResourceBlock();\n            block->identifier = KisTiffPsdResourceRecord::RESN_INFO;\n            block->resource = resInfo;\n            resourceSection.resources[KisTiffPsdResourceRecord::RESN_INFO] = block;\n        }\n\n        // Add icc block\n        {\n            auto *profileInfo = new ICC_PROFILE_1039();\n            profileInfo->icc = layer->image()->profile()->rawData();\n            auto *block = new PSDResourceBlock();\n            block->identifier = KisTiffPsdResourceRecord::ICC_PROFILE;\n            block->resource = profileInfo;\n            resourceSection.resources[KisTiffPsdResourceRecord::ICC_PROFILE] = block;\n        }\n\n        dbgFile << \"Resource section ready to write\";\n\n        QBuffer buf;\n        buf.open(QIODevice::WriteOnly);\n\n        if (!resourceSection.write(buf)) {\n            dbgFile << \"Failed to write resource section. Error:\" << resourceSection.error << buf.pos();\n            return ImportExportCodes::ErrorWhileWriting;\n        }\n\n        buf.close();\n        buf.open(QIODevice::WriteOnly);\n\n        if (!TIFFSetField(image(), TIFFTAG_PHOTOSHOP, static_cast<uint32_t>(buf.size()), buf.data().data())) {\n            dbgFile << \"Failed to write the PSD resource block to the TIFF field\";\n            return ImportExportCodes::ErrorWhileWriting;\n        }\n    }\n\n    /**\n     * Freshly baked Photoshoppy TIFF file!\n     */\n\n    ///* END PHOTOSHOP SPECIFIC HANDLING CODE *///\n\n    TIFFWriteDirectory(image());\n    return ImportExportCodes::OK;\n}",
    "void tiffWriterClose(TIFF** pTiff)\n{\n#ifdef EMGU_CV_WITH_TIFF\n\tTIFFWriteDirectory(*pTiff);\n\tXTIFFClose(*pTiff);\n\t*pTiff = 0;\n#else\n\tthrow_no_tiff();\n#endif\n}",
    "bool\nTIFFOutput::write_exif_data()\n{\n#if defined(TIFF_VERSION_BIG) && TIFFLIB_VERSION >= 20120922\n    // Older versions of libtiff do not support writing Exif directories\n\n    if (m_spec.get_int_attribute(\"tiff:write_exif\", 1) == 0) {\n        // The special metadata \"tiff:write_exif\", if present and set to 0\n        // (the default is 1), will cause us to skip outputting Exif data.\n        // This is useful in cases where we think the TIFF file will need to\n        // be read by an app that links against an old version of libtiff\n        // that will have trouble reading the Exif directory.\n        return true;\n    }\n\n    // First, see if we have any Exif data at all\n    bool any_exif = false;\n    for (size_t i = 0, e = m_spec.extra_attribs.size(); i < e; ++i) {\n        const ParamValue& p(m_spec.extra_attribs[i]);\n        int tag, tifftype, count;\n        if (exif_tag_lookup(p.name(), tag, tifftype, count)\n            && tifftype != TIFF_NOTYPE) {\n            if (tag == EXIF_SECURITYCLASSIFICATION || tag == EXIF_IMAGEHISTORY\n                || tag == EXIF_PHOTOGRAPHICSENSITIVITY)\n                continue;  // libtiff doesn't understand these\n            any_exif = true;\n            break;\n        }\n    }\n    if (!any_exif)\n        return true;\n\n    if (m_compression == COMPRESSION_JPEG) {\n        // For reasons we don't understand, JPEG-compressed TIFF seems\n        // to not output properly without a directory checkpoint here.\n        TIFFCheckpointDirectory(m_tif);\n    }\n\n    // First, finish writing the current directory\n    if (!TIFFWriteDirectory(m_tif)) {\n        error(\"failed TIFFWriteDirectory()\");\n        return false;\n    }\n\n    // Create an Exif directory\n    if (TIFFCreateEXIFDirectory(m_tif) != 0) {\n        error(\"failed TIFFCreateEXIFDirectory()\");\n        return false;\n    }\n\n    for (size_t i = 0, e = m_spec.extra_attribs.size(); i < e; ++i) {\n        const ParamValue& p(m_spec.extra_attribs[i]);\n        int tag, tifftype, count;\n        if (exif_tag_lookup(p.name(), tag, tifftype, count)\n            && tifftype != TIFF_NOTYPE) {\n            if (tag == EXIF_SECURITYCLASSIFICATION || tag == EXIF_IMAGEHISTORY\n                || tag == EXIF_PHOTOGRAPHICSENSITIVITY)\n                continue;  // libtiff doesn't understand these\n            bool ok = false;\n            if (tifftype == TIFF_ASCII) {\n                ok = TIFFSetField(m_tif, tag, *(char**)p.data());\n            } else if ((tifftype == TIFF_SHORT || tifftype == TIFF_LONG)\n                       && p.type() == TypeDesc::SHORT) {\n                ok = TIFFSetField(m_tif, tag, (int)*(short*)p.data());\n            } else if ((tifftype == TIFF_SHORT || tifftype == TIFF_LONG)\n                       && p.type() == TypeDesc::INT) {\n                ok = TIFFSetField(m_tif, tag, *(int*)p.data());\n            } else if ((tifftype == TIFF_RATIONAL || tifftype == TIFF_SRATIONAL)\n                       && p.type() == TypeDesc::FLOAT) {\n                ok = TIFFSetField(m_tif, tag, *(float*)p.data());\n            } else if ((tifftype == TIFF_RATIONAL || tifftype == TIFF_SRATIONAL)\n                       && p.type() == TypeDesc::DOUBLE) {\n                ok = TIFFSetField(m_tif, tag, *(double*)p.data());\n            }\n            if (!ok) {\n                // std::cout << \"Unhandled EXIF \" << p.name() << \" \" << p.type() << \"\\n\";\n            }\n        }\n    }\n\n    // Now write the directory of Exif data\n    uint64 dir_offset = 0;\n    if (!TIFFWriteCustomDirectory(m_tif, &dir_offset)) {\n        error(\"failed TIFFWriteCustomDirectory() of the Exif data\");\n        return false;\n    }\n    // Go back to the first directory, and add the EXIFIFD pointer.\n    // std::cout << \"diffdir = \" << tiffdir << \"\\n\";\n    TIFFSetDirectory(m_tif, 0);\n    TIFFSetField(m_tif, TIFFTAG_EXIFIFD, dir_offset);\n#endif\n\n    return true;  // all is ok\n}",
    "void DngWriter::WriteDNG() {\n\n    LOGD(\"init ext tags\");\n    LOGD(\"init ext tags done\");\n    TIFF *tif;\n    LOGD(\"has file description: %b\", hasFileDes);\n    if(hasFileDes == true)\n    {\n        tif = openfTIFFFD(\"\", fileDes);\n    }\n    else\n        tif = openfTIFF(fileSavePath);\n\n    LOGD(\"writeIfd0\");\n    writeIfd0(tif);\n\n    if(opCode != NULL)\n    {\n        if(opCode->op2Size > 0)\n        {\n            LOGD(\"Set OP2 %i\", opCode->op2Size);\n            TIFFSetField(tif, TIFFTAG_OPC2, opCode->op2Size, opCode->op2);\n        }\n        else\n        {\n            LOGD(\"opcode2 null\");\n        }\n        if(opCode->op3Size > 0)\n        {\n            LOGD(\"Set OP3 %i\", opCode->op3Size);\n            TIFFSetField(tif, TIFFTAG_OPC3, opCode->op3Size, opCode->op3);\n        }\n        else\n        {\n            LOGD(\"opcode3 null\");\n        }\n    } else\n    {\n        LOGD(\"opcode null\");\n    }\n    LOGD(\"writeRawStuff\");\n    writeRawStuff(tif);\n\n    TIFFWriteDirectory(tif);\n    LOGD(\"set exif\");\n    if(exifInfo != NULL)\n    {\n        uint64 exif_offset = 0;\n        TIFFCreateEXIFDirectory(tif);\n        writeExifIfd(tif);\n        TIFFWriteCustomDirectory(tif, &exif_offset);\n        TIFFSetDirectory(tif, 0);\n        TIFFSetField (tif, TIFFTAG_EXIFIFD, exif_offset);\n        TIFFRewriteDirectory(tif);\n    }\n\n    if(gpsInfo != NULL)\n    {\n        uint64 gps_offset = 0;\n        LOGD(\"makeGPSIFD\");\n        makeGPS_IFD(tif);\n        LOGD(\"TIFFWriteCustomDirectory\");\n        TIFFWriteCustomDirectory(tif, &gps_offset);\n        // set GPSIFD tag\n        LOGD(\"TIFFSetDirectory\");\n        TIFFSetDirectory(tif, 0);\n        LOGD(\"setgpsoffset\");\n        TIFFSetField (tif, TIFFTAG_GPSIFD, gps_offset);\n\n    }\n\n    TIFFClose(tif);\n\n\n    LOGD(\"DONE\");\n}",
    "bool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = NULL;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!tif)\n    {\n        return false;\n    }\n    cv::Ptr<void> tif_cleanup(tif, cv_tiffCloseHandle);\n\n    //Settings that matter to all images\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, IMWRITE_TIFF_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        CV_Assert(!img.empty());\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int type = img.type();\n        int depth = CV_MAT_DEPTH(type);\n        CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n        CV_CheckType(type, channels >= 1 && channels <= 4, \"\");\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height));\n\n        if (img_vec.size() > 1)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE));\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PAGENUMBER, page, img_vec.size()));\n        }\n\n        int compression_param = -1;  // OPENCV_FUTURE\n        if (type == CV_32FC3 && (!readParam(params, IMWRITE_TIFF_COMPRESSION, compression_param) || compression_param == COMPRESSION_SGILOG))\n        {\n            if (!write_32FC3_SGILOG(img, tif))\n                return false;\n            continue;\n        }\n\n        int page_compression = compression;\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            case CV_32F:\n            {\n                bitsPerChannel = 32;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            case CV_64F:\n            {\n                bitsPerChannel = 64;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n        CV_Assert(fileStep > 0);\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n        rowsPerStrip = std::max(1, std::min(height, rowsPerStrip));\n\n        int colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerChannel));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, page_compression));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, colorspace));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsPerStrip));\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, depth >= CV_32F ? SAMPLEFORMAT_IEEEFP : SAMPLEFORMAT_UINT));\n\n        if (page_compression != COMPRESSION_NONE)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor));\n        }\n\n        if (resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resUnit));\n        }\n        if (dpiX >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)dpiX));\n        }\n        if (dpiY >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)dpiY));\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(tif);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data(); CV_DbgAssert(buffer);\n        Mat m_buffer(Size(width, 1), CV_MAKETYPE(depth, channels), buffer, (size_t)scanlineSize);\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGR2RGB);\n                    break;\n                }\n\n                case 4:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGRA2RGBA);\n                    break;\n                }\n\n                default:\n                {\n                    CV_Assert(0);\n                }\n            }\n\n            CV_TIFF_CHECK_CALL(TIFFWriteScanline(tif, buffer, y, 0) == 1);\n        }\n\n        CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    }\n\n    return true;\n}",
    "bool TIFFWriteObject<SinkType>::write_directory()\n{\n  if (impl_->tif == nullptr)\n  {\n    return false;\n  }\n\n  int res = TIFFWriteDirectory(impl_->tif);\n  return res != 0;\n}",
    "static\nvoid TIFF_WriteOverview( TIFF *hTIFF, int nSamples, RawBlockedImage **papoRBI,\n                         int bTiled, int nCompressFlag, int nPhotometric,\n                         unsigned short *panRed,\n                         unsigned short *panGreen,\n                         unsigned short *panBlue,\n                         int bUseSubIFDs )\n\n{\n    int\t\tiSample;\n    RawBlockedImage\t*poRBI = papoRBI[0];\n                                   \n/* -------------------------------------------------------------------- */\n/*      Setup TIFF fields.                                              */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, poRBI->GetXSize() );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, poRBI->GetYSize() );\n    TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG,\n                  PLANARCONFIG_SEPARATE );\n\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, poRBI->GetBitsPerPixel() );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, nSamples );\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, nCompressFlag );\n    TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, nPhotometric );\n\n    if( bTiled )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_TILEWIDTH, poRBI->GetBlockXSize() );\n        TIFFSetField( hTIFF, TIFFTAG_TILELENGTH, poRBI->GetBlockYSize() );\n    }\n    else\n        TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, poRBI->GetBlockYSize() );\n\n    TIFFSetField( hTIFF, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE );\n    \n/* -------------------------------------------------------------------- */\n/*\tWrite color table if one is present.\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    if( panRed != NULL )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panRed, panGreen, panBlue );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write blocks to TIFF file.                                      */\n/* -------------------------------------------------------------------- */\n    for( iSample = 0; iSample < nSamples; iSample++ )\n    {\n        int\t\tiTileX, iTileY;\n        \n        poRBI = papoRBI[iSample];\n        \n        for( iTileY = 0;\n             iTileY*poRBI->GetBlockYSize() < poRBI->GetYSize();\n             iTileY++ )\n        {\n            for( iTileX = 0;\n                 iTileX*poRBI->GetBlockXSize() < poRBI->GetXSize();\n                 iTileX++ )\n            {\n                unsigned char\t*pabyData = poRBI->GetTile( iTileX, iTileY );\n                int\tnTileID;\n\n                if( bTiled )\n                {\n                    nTileID =\n                        TIFFComputeTile(hTIFF,\n                                        iTileX * poRBI->GetBlockXSize(),\n                                        iTileY * poRBI->GetBlockYSize(),\n                                        0, iSample );\n                    TIFFWriteEncodedTile( hTIFF, nTileID, \n                                          pabyData, TIFFTileSize(hTIFF) );\n                }\n                else\n                {\n                    nTileID =\n                        TIFFComputeStrip(hTIFF, iTileY*poRBI->GetBlockYSize(),\n                                         iSample);\n\n                    TIFFWriteEncodedStrip( hTIFF, nTileID,\n                                           pabyData, TIFFStripSize( hTIFF ) );\n                }\n            }\n        }\n    }\n\n    TIFFWriteDirectory( hTIFF );\n}",
    "void TIFFFormat::do_write(image_list* input, byte_sink* output, const options_map& opts, bool is_multi) {\n    tiff_warn_error twe;\n    tsize_t (*read_function)(thandle_t, void*, tsize_t) =\n         (dynamic_cast<byte_source*>(output) ?\n                            tiff_read_from_writer :\n                            tiff_no_read);\n    tif_holder t = TIFFClientOpen(\n                    \"internal\",\n                    \"w\",\n                    output,\n                    read_function,\n                    tiff_write,\n                    tiff_seek<byte_sink>,\n                    tiff_close,\n                    tiff_size<byte_sink>,\n                    NULL,\n                    NULL);\n    std::vector<uint8_t> bufdata;\n    const unsigned n_pages = input->size();\n    for (unsigned i = 0; i != n_pages; ++i) {\n        Image* im = input->at(i);\n        void* bufp = 0;\n        bool copy_data = false;\n        const uint32_t h = im->dim(0);\n        const uint32_t nchannels = uint16_t(im->dim_or(2, 1));\n        const uint16_t photometric = ((im->ndims() == 3 && im->dim(2)) ?\n                                                        PHOTOMETRIC_RGB :\n                                                        PHOTOMETRIC_MINISBLACK);\n        TIFFSetField(t.tif, TIFFTAG_IMAGELENGTH, uint32_t(h));\n        TIFFSetField(t.tif, TIFFTAG_IMAGEWIDTH, uint32_t(im->dim(1)));\n        TIFFSetField(t.tif, TIFFTAG_BITSPERSAMPLE, uint16_t(im->nbits()));\n        TIFFSetField(t.tif, TIFFTAG_SAMPLESPERPIXEL, uint16_t(im->dim_or(2, 1)));\n        TIFFSetField(t.tif, TIFFTAG_PHOTOMETRIC, uint16_t(photometric));\n        TIFFSetField(t.tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n        if (get_optional_bool(opts, \"tiff:compress\", true)) {\n            TIFFSetField(t.tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n            // For 8 bit images, prediction defaults to false; for 16 bit images,\n            // it defaults to true. This is because compression of raw 16 bit\n            // images is often counter-productive without this flag. See the\n            // discusssion at http://www.asmail.be/msg0055176395.html\n            const bool prediction_default = im->nbits() != 8;\n            if (get_optional_bool(opts, \"tiff:horizontal-predictor\", prediction_default)) {\n                TIFFSetField(t.tif, TIFFTAG_PREDICTOR, PREDICTOR_HORIZONTAL);\n                if (!copy_data) {\n                    bufdata.resize(im->dim(1) * im->nbytes() * nchannels);\n                    bufp = &bufdata[0];\n                    copy_data = true;\n                }\n            }\n        }\n\n        TIFFSetField(t.tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n        const char* meta = get_optional_cstring(opts, \"metadata\");\n        if (meta) {\n            TIFFSetField(t.tif, TIFFTAG_IMAGEDESCRIPTION, meta);\n        }\n        options_map::const_iterator x_iter = opts.find(\"tiff:XResolution\");\n        if (x_iter != opts.end()) {\n            double d;\n            int i;\n            float value;\n            if (x_iter->second.get_int(i)) { value = i; }\n            else if (x_iter->second.get_double(d)) { value = d; }\n            else { throw WriteOptionsError(\"XResolution must be an integer or floating point value.\"); }\n\n            TIFFSetField(t.tif, TIFFTAG_XRESOLUTION, value);\n        }\n\n        options_map::const_iterator y_iter = opts.find(\"tiff:YResolution\");\n        if (x_iter != opts.end()) {\n            double d;\n            int i;\n            float value;\n            if (x_iter->second.get_int(i)) { value = i; }\n            else if (x_iter->second.get_double(d)) { value = d; }\n            else { throw WriteOptionsError(\"YResolution must be an integer or floating point value.\"); }\n\n            TIFFSetField(t.tif, TIFFTAG_YRESOLUTION, value);\n        }\n\n        const uint16_t resolution_unit = get_optional_int(opts, \"tiff:XResolutionUnit\", uint16_t(-1));\n        if (resolution_unit != uint16_t(-1)) {\n            TIFFSetField(t.tif, TIFFTAG_RESOLUTIONUNIT, resolution_unit);\n        }\n\n        if (is_multi) {\n            TIFFSetField(t.tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n            TIFFSetField(t.tif, TIFFTAG_PAGENUMBER, i, n_pages);\n        }\n\n        for (uint32_t r = 0; r != h; ++r) {\n            void* rowp = im->rowp(r);\n            if (copy_data) {\n                std::memcpy(bufp, rowp, im->dim(1) * im->nbytes() * nchannels);\n                rowp = bufp;\n            }\n            if (TIFFWriteScanline(t.tif, rowp, r) == -1) {\n                throw CannotWriteError(\"imread.imsave._tiff: Error writing TIFF file\");\n            }\n        }\n        if (is_multi) {\n            if (!TIFFWriteDirectory(t.tif)) {\n                throw CannotWriteError(\"TIFFWriteDirectory failed\");\n            }\n        }\n    }\n    TIFFFlush(t.tif);\n}",
    "JNIEXPORT jboolean JNICALL Java_org_beyka_tiffbitmapfactory_TiffSaver_save\n    (JNIEnv *env, jclass clazz, jstring filePath, jint fileDescriptor, jobject bitmap, jobject options, jboolean append) {\n\n__android_log_write(ANDROID_LOG_ERROR, \"NativeTiffSaver\", \"Test Error here\");\n\n        //Options class\n        jclass jSaveOptionsClass = env->FindClass(\"org/beyka/tiffbitmapfactory/TiffSaver$SaveOptions\");\n\n        //How much memory can we use?\n        jfieldID availableMemoryFieldID = env->GetFieldID(jSaveOptionsClass,\n                                                                          \"inAvailableMemory\",\n                                                                          \"J\");\n        unsigned long inAvailableMemory = env->GetLongField(options, availableMemoryFieldID);\n\n        //If we need to throw exceptions\n        jfieldID throwExceptionFieldID = env->GetFieldID(jSaveOptionsClass,\n                                                                           \"inThrowException\",\n                                                                           \"Z\");\n        jboolean throwException = env->GetBooleanField(options, throwExceptionFieldID);\n\n        // check is bitmap null\n        if (bitmap == NULL) {\n            const char *message = \"Bitmap is null\\0\";\n            LOGE(message);\n            if (throwException) {\n                jstring jmessage = env->NewStringUTF(message);\n                throw_decode_file_exception(env, filePath, jmessage);\n                env->DeleteLocalRef(jmessage);\n            }\n            return JNI_FALSE;\n        }\n\n\n        jclass bitmapClass = env->FindClass(\"android/graphics/Bitmap\");\n\n        //check is bitmap recycled\n        jmethodID isRecycledMethodid = env->GetMethodID(bitmapClass, \"isRecycled\", \"()Z\");\n        jboolean isRecycled = env->CallBooleanMethod(bitmap, isRecycledMethodid);\n        if (isRecycled) {\n            const char *message = \"Bitmap is recycled\\0\";\n            LOGE(message);\n            if (throwException) {\n                jstring jmessage = env->NewStringUTF(message);\n                throw_decode_file_exception(env, filePath, jmessage);\n                env->DeleteLocalRef(jmessage);\n            }\n            return JNI_FALSE;\n        }\n\n        //Read pixels from bitmap\n\n        AndroidBitmapInfo  info;\n        void* pixels;\n        int ret;\n\n\n\n        if ((ret = AndroidBitmap_getInfo(env, bitmap, &info)) < 0) {\n            LOGE(\"AndroidBitmap_getInfo() failed ! error=\");\n            return JNI_FALSE;\n        }\n\n        if ((ret = AndroidBitmap_lockPixels(env, bitmap, &pixels)) < 0) {\n                LOGE(\"AndroidBitmap_lockPixels() failed ! error=\");\n                return JNI_FALSE;\n        }\n\n        uint32 img_width = info.width;\n        uint32 img_height= info.height;\n\n/*\n        //Get array of jint from jintArray\n        jint *c_array;\n        c_array = env->GetIntArrayElements(img, NULL);\n        if (c_array == NULL) {\n            //if array is null - nothing to save\n            LOGE(\"array is null\");\n            return JNI_FALSE;\n        }\n*/\n\n\n        //Get options\n\n        //Get compression mode from options object\n        jfieldID gOptions_CompressionModeFieldID = env->GetFieldID(jSaveOptionsClass,\n        \"compressionScheme\",\n        \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n        jobject compressionMode = env->GetObjectField(options, gOptions_CompressionModeFieldID);\n\n        jclass compressionModeClass = env->FindClass(\n        \"org/beyka/tiffbitmapfactory/CompressionScheme\");\n        jfieldID ordinalFieldID = env->GetFieldID(compressionModeClass, \"ordinal\", \"I\");\n        jint compressionInt = env->GetIntField(compressionMode, ordinalFieldID);\n\n        //Get image orientation from options object\n        jfieldID gOptions_OrientationFieldID = env->GetFieldID(jSaveOptionsClass,\n        \"orientation\",\n        \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n        jobject orientation = env->GetObjectField(options, gOptions_OrientationFieldID);\n\n        jclass orientationClass = env->FindClass(\n        \"org/beyka/tiffbitmapfactory/Orientation\");\n        jfieldID orientationOrdinalFieldID = env->GetFieldID(orientationClass, \"ordinal\", \"I\");\n        jint orientationInt = env->GetIntField(orientation, orientationOrdinalFieldID);\n        env->DeleteLocalRef(orientationClass);\n\n        // variables for resolution\n        jfieldID gOptions_xResolutionFieldID = env->GetFieldID(jSaveOptionsClass, \"xResolution\", \"F\");\n        float xRes = env->GetFloatField(options, gOptions_xResolutionFieldID);\n        jfieldID gOptions_yResolutionFieldID = env->GetFieldID(jSaveOptionsClass, \"yResolution\", \"F\");\n        float yRes = env->GetFloatField(options, gOptions_yResolutionFieldID);\n        jfieldID gOptions_resUnitFieldID = env->GetFieldID(jSaveOptionsClass,\n                                                           \"resUnit\",\n                                                           \"Lorg/beyka/tiffbitmapfactory/ResolutionUnit;\");\n        jobject resUnitObject = env->GetObjectField(options, gOptions_resUnitFieldID);\n        //Get res int from resUnitObject\n        jclass resolutionUnitClass = env->FindClass(\"org/beyka/tiffbitmapfactory/ResolutionUnit\");\n        jfieldID resUnitOrdinalFieldID = env->GetFieldID(resolutionUnitClass, \"ordinal\", \"I\");\n        uint16 resUnit = env->GetIntField(resUnitObject, resUnitOrdinalFieldID);\n        env->DeleteLocalRef(resolutionUnitClass);\n\n        //Get author field if exist\n        jfieldID gOptions_authorFieldID = env->GetFieldID(jSaveOptionsClass, \"author\", \"Ljava/lang/String;\");\n        jstring jAuthor = (jstring)env->GetObjectField(options, gOptions_authorFieldID);\n        const char *authorString = NULL;\n        if (jAuthor) {\n            authorString = env->GetStringUTFChars(jAuthor, 0);\n            LOGIS(\"Author: \", authorString);\n        }\n\n        //Get copyright field if exist\n        jfieldID gOptions_copyrightFieldID = env->GetFieldID(jSaveOptionsClass, \"copyright\", \"Ljava/lang/String;\");\n        jstring jCopyright = (jstring)env->GetObjectField(options, gOptions_copyrightFieldID);\n        const char *copyrightString = NULL;\n        if (jCopyright) {\n            copyrightString = env->GetStringUTFChars(jCopyright, 0);\n            LOGIS(\"Copyright: \", copyrightString);\n        }\n\n        //Get image description field if exist\n        jfieldID gOptions_imgDescrFieldID = env->GetFieldID(jSaveOptionsClass, \"imageDescription\", \"Ljava/lang/String;\");\n        jstring jImgDescr = (jstring)env->GetObjectField(options, gOptions_imgDescrFieldID);\n        const char *imgDescrString = NULL;\n        if (jImgDescr) {\n            imgDescrString = env->GetStringUTFChars(jImgDescr, 0);\n            LOGIS(\"Image Description: \", imgDescrString);\n        }\n\n        //Get software name and number from buildconfig\n        jclass jBuildConfigClass = env->FindClass(\n                \"org/beyka/tiffbitmapfactory/BuildConfig\");\n        jfieldID softwareNameFieldID = env->GetStaticFieldID(jBuildConfigClass, \"softwarename\", \"Ljava/lang/String;\");\n        jstring jsoftwarename = (jstring)env->GetStaticObjectField(jBuildConfigClass, softwareNameFieldID);\n        const char *softwareNameString = NULL;\n        if (jsoftwarename) {\n            softwareNameString = env->GetStringUTFChars(jsoftwarename, 0);\n            LOGIS(\"Software Name: \", softwareNameString);\n        }\n\n        //Get android version\n        jclass build_class = env->FindClass(\"android/os/Build$VERSION\");\n        jfieldID releaseFieldID = env->GetStaticFieldID(build_class, \"RELEASE\", \"Ljava/lang/String;\");\n        jstring jrelease = (jstring)env->GetStaticObjectField(build_class, releaseFieldID);\n        const char *releaseString = NULL;\n        if (jrelease) {\n            releaseString = env->GetStringUTFChars(jrelease, 0);\n            LOGIS(\"Release: \", releaseString);\n        }\n        char *fullReleaseName = concat(\"Android \", releaseString);\n        LOGIS(\"Full Release: \", fullReleaseName);\n\n\n        uint32 pixelsBufferSize = img_width * img_height;\n        uint32* img = NULL;\n        int tmpImgArrayCreated = 0;\n        switch (info.format) {\n            case ANDROID_BITMAP_FORMAT_RGBA_8888:\n            {\n                LOGI(\"ANDROID_BITMAP_FORMAT_RGBA_8888\");\n                img = (uint32*)pixels;\n                break;\n            }\n            case ANDROID_BITMAP_FORMAT_RGBA_4444:\n            {\n                LOGI(\"ANDROID_BITMAP_FORMAT_RGBA_4444\");\n                uint16_t* tmp4444 = (uint16_t*)pixels;\n                img = (uint32*) malloc(sizeof(uint32) * pixelsBufferSize);\n                for (int x = 0; x < img_width; x++) {\n                    for (int y = 0; y < img_height; y++) {\n                        uint16_t pix = tmp4444[y * img_width + x];\n                        int alpha = colorMask & pix >> 16;\n                        int red = colorMask & pix >> 8;\n                        int green = colorMask & pix >> 4;\n                        int blue = colorMask & pix;\n                        uint32 crPix = (alpha << 24) | (blue << 16) | (green << 8) | (red);\n                        img[y * img_width + x] = crPix;\n                    }\n                }\n                tmpImgArrayCreated = 1;\n                break;\n            }\n            case ANDROID_BITMAP_FORMAT_RGB_565:\n            {\n                LOGI(\"ANDROID_BITMAP_FORMAT_RGB_565\");\n                uint16_t* tmp565 = (uint16_t*)pixels;\n                img = (uint32*) malloc(sizeof(uint32) * pixelsBufferSize);\n                for (int x = 0; x < img_width; x++) {\n                    for (int y = 0; y < img_height; y++) {\n                        uint16_t pix = tmp565[y * img_width + x];\n                        unsigned char red = 0b11111 & pix >> 11;\n                        unsigned char green = 0b111111 & pix >> 5;\n                        unsigned char blue = 0b11111 & pix;\n                        uint32 crPix = (blue << 3 << 16) | (green << 2 << 8) | (red<<3);\n                        img[y * img_width + x] = crPix;\n                    }\n                }\n                tmpImgArrayCreated = 1;\n                break;\n            }\n            case ANDROID_BITMAP_FORMAT_A_8:\n            {\n                LOGI(\"ANDROID_BITMAP_FORMAT_A_8\");\n                uint8_t* tmp8 = (uint8_t*)pixels;\n                img = (uint32*) malloc(sizeof(uint32) * pixelsBufferSize);\n                for (int x = 0; x < img_width; x++) {\n                    for (int y = 0; y < img_height; y++) {\n                        uint8_t pix = tmp8[y * img_width + x];\n                        img[y * img_width + x] = pix << 24;\n                    }\n                }\n                tmpImgArrayCreated = 1;\n                break;\n            }\n        }\n\n/*\n        int pixelsBufferSize = img_width * img_height;\n        uint32 *array = (uint32 *) malloc(sizeof(uint32) * pixelsBufferSize);\n        if (!array) {\n            throw_not_enought_memory_exception(env, sizeof(uint32) * pixelsBufferSize, 0);//todo change for estimating memory\n            return JNI_FALSE;\n        }\n\n        uint32_t* img = (uint32_t*)pixels;\n        for (int y = 0; y < img_height; y++) {\n            for (int x = 0; x < img_width; x++) {\n                uint32_t pix = img[y * img_width + x];\n                int alpha = colorMask & pix >> 24;\n                int red = colorMask & pix >> 16;\n                int green = colorMask & pix >> 8;\n                int blue = colorMask & pix;\n                uint32 crPix = (alpha << 24) | (blue << 16) | (green << 8) | (red);\n                array[y * img_width + x] = crPix;\n            }\n        }\n*/\n\n/*\n        for (int i = 0; i < img_width; i++) {\n            for (int j = 0; j < img_height; j++) {\n\n                uint32 crPix = getPixel(pixels,info,i,j);\n\n                //jint crPix = c_array[j * img_width + i];\n                int alpha = colorMask & crPix >> 24;\n                int red = colorMask & crPix >> 16;\n                int green = colorMask & crPix >> 8;\n                int blue = colorMask & crPix;\n\n                crPix = (alpha << 24) | (blue << 16) | (green << 8) | (red);\n                array[j * img_width + i] = crPix;\n            }\n        }\n*/\n        TIFF *output_image;\n\n        LOGII(\"Check file descripor\", fileDescriptor);\n\n        const char *strPath = NULL;\n        if (fileDescriptor == -1) {\n            strPath = env->GetStringUTFChars(filePath, 0);\n            LOGIS(\"nativeTiffOpenForSave\", strPath);\n            int mode = O_RDWR | O_CREAT | O_TRUNC | 0;\n            if (append) {\n                mode = O_RDWR | O_CREAT;\n            }\n            fileDescriptor = open(strPath, mode, 0666);\n            if (fileDescriptor < 0) {\n                throw_cant_open_file_exception(env, filePath);\n                return JNI_FALSE;\n            }\n        }\n\n        // Open the TIFF file\n        if (!append) {\n            if ((output_image = TIFFFdOpen(fileDescriptor, \"\", \"w\")) == NULL) {\n                LOGE(\"Unable to write tif file\");\n                if (strPath) {\n                    throw_cant_open_file_exception(env, filePath);\n                } else {\n                    throw_cant_open_file_exception_fd(env, fileDescriptor);\n                }\n                return JNI_FALSE;\n            }\n        } else {\n            if ((output_image = TIFFFdOpen(fileDescriptor, \"\", \"a\")) == NULL) {\n                LOGE(\"Unable to write tif file\");\n                if (strPath) {\n                    throw_cant_open_file_exception(env, filePath);\n                } else {\n                    throw_cant_open_file_exception_fd(env, fileDescriptor);\n                return JNI_FALSE;\n                }\n            }\n        }\n\n        TIFFSetField(output_image, TIFFTAG_IMAGEWIDTH, img_width);\n        TIFFSetField(output_image, TIFFTAG_IMAGELENGTH, img_height);\n        TIFFSetField(output_image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(output_image, TIFFTAG_COMPRESSION, compressionInt);\n        TIFFSetField(output_image, TIFFTAG_ORIENTATION, orientationInt);\n        TIFFSetField(output_image, TIFFTAG_XRESOLUTION, xRes);\n        TIFFSetField(output_image, TIFFTAG_YRESOLUTION, yRes);\n        TIFFSetField(output_image, TIFFTAG_RESOLUTIONUNIT, resUnit);\n\n        if (compressionInt == COMPRESSION_CCITTRLE ||compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n            TIFFSetField(output_image, TIFFTAG_BITSPERSAMPLE,\t1);\n            TIFFSetField(output_image, TIFFTAG_SAMPLESPERPIXEL,\t1);\n            TIFFSetField(output_image, TIFFTAG_ROWSPERSTRIP, 1);\n            TIFFSetField(output_image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n            TIFFSetField(output_image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n        } else {\n            TIFFSetField(output_image, TIFFTAG_BITSPERSAMPLE, 8);\n            TIFFSetField(output_image, TIFFTAG_SAMPLESPERPIXEL, 4);\n            TIFFSetField(output_image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        }\n\n        //Write additiona tags\n        //CreationDate tag\n        char *date = getCreationDate();\n        TIFFSetField(output_image, TIFFTAG_DATETIME, date);\n        free(date);\n        //Host system\n        TIFFSetField(output_image, TIFFTAG_HOSTCOMPUTER, fullReleaseName);\n\n        //software\n        if (softwareNameString) {\n            TIFFSetField(output_image, TIFFTAG_SOFTWARE, softwareNameString);\n        }\n        //image description\n        if (imgDescrString) {\n            TIFFSetField(output_image, TIFFTAG_IMAGEDESCRIPTION, imgDescrString);\n        }\n        //author\n        if (authorString) {\n            TIFFSetField(output_image, TIFFTAG_ARTIST, authorString);\n        }\n        //copyright\n        if (copyrightString) {\n            TIFFSetField(output_image, TIFFTAG_COPYRIGHT, copyrightString);\n        }\n\n        // Write the information to the file\n        if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n            unsigned char *bilevel = convertArgbToBilevel(img, img_width, img_height);\n            int compressedWidth = (img_width/8 + 0.5);\n            for (int i = 0; i < img_height; i++) {\n                TIFFWriteEncodedStrip(output_image, i, &bilevel[i * compressedWidth], (compressedWidth));\n            }\n            free(bilevel);\n        } else if (compressionInt == COMPRESSION_JPEG) {\n            for (int row = 0; row < img_height; row++) {\n                TIFFWriteScanline(output_image, &img[row * img_width], row, 0);\n            }\n        } else {\n            TIFFSetField(output_image, TIFFTAG_ROWSPERSTRIP, 1);\n            for (int row = 0; row < img_height; row++) {\n                TIFFWriteEncodedStrip(output_image, row, &img[row * img_width], img_width * sizeof(uint32));\n                //TIFFWriteScanline(output_image, &img[row * img_width], row, 0);\n            }\n        }\n       ret = TIFFWriteDirectory(output_image);\n        LOGII(\"ret = \", ret);\n\n        // Close the file\n        TIFFClose(output_image);\n/*\n        //free temp array\n        free (array);\n*/\n        if (tmpImgArrayCreated) {\n            free(img);\n        }\n\n        //Now we don't need android pixels, so unlock\n                 AndroidBitmap_unlockPixels(env, bitmap);\n\n        //Remove variables\n        if (releaseString) {\n            env->ReleaseStringUTFChars(jrelease, releaseString);\n        }\n        free(fullReleaseName);\n        if (softwareNameString) {\n            env->ReleaseStringUTFChars(jsoftwarename, softwareNameString);\n        }\n        if (imgDescrString) {\n            env->ReleaseStringUTFChars(jImgDescr, imgDescrString);\n        }\n        if (authorString) {\n            env->ReleaseStringUTFChars(jAuthor, authorString);\n        }\n        if (copyrightString) {\n            env->ReleaseStringUTFChars(jCopyright, copyrightString);\n        }\n        if (strPath) {\n            env->ReleaseStringUTFChars(filePath, strPath);\n        }\n//        env->ReleaseIntArrayElements(img, c_array, 0);\n\n        if (ret == -1) return JNI_FALSE;\n        return JNI_TRUE;\n    }",
    "jboolean BmpToTiffConverter::convert()\n{\n    LOGI(\"CONVERT\");\n    readOptions();\n\n    if(outFd < 0) {\n        //open tiff file for writing or appending\n        const char *outCPath = NULL;\n        outCPath = env->GetStringUTFChars(outPath, 0);\n        LOGIS(\"OUT path\", outCPath);\n        LOGIS(\"nativeTiffOpenForSave\", outCPath);\n        int mode = O_RDWR | O_CREAT | O_TRUNC | 0;\n        if (appendTiff) {\n            mode = O_RDWR | O_CREAT;\n        }\n         outFd = open(outCPath, mode, 0666);\n         if (outFd < 0) {\n            throw_cant_open_file_exception(env, outPath);\n            env->ReleaseStringUTFChars(outPath, outCPath);\n            return JNI_FALSE;\n         }\n         env->ReleaseStringUTFChars(outPath, outCPath);\n    }\n\n    if (!appendTiff) {\n        if ((tiffImage = TIFFFdOpen(outFd, \"\", \"w\")) == NULL) {\n            LOGE(\"Unable to open tif file\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, outFd);\n            }\n            return JNI_FALSE;\n        }\n    } else {\n         if ((tiffImage = TIFFFdOpen(outFd, \"\", \"a\")) == NULL) {\n            LOGE(\"Unable to open tif file\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, outFd);\n            }\n            return JNI_FALSE;\n         }\n    }\n\n    //open bmp file fow reading\n    if(inFd < 0) {\n        const char *inCPath = NULL;\n        inCPath = env->GetStringUTFChars(inPath, 0);\n        LOGIS(\"IN path\", inCPath);\n        int mode = O_RDONLY;\n        inFd = open(inCPath, mode, 0666);\n        if (inFd < 0) {\n            LOGES(\"Can\\'t open in file\", inCPath);\n            throw_cant_open_file_exception(env, inPath);\n            env->ReleaseStringUTFChars(inPath, inCPath);\n            return JNI_FALSE;\n        }\n        env->ReleaseStringUTFChars(inPath, inCPath);\n    }\n\n    //Read header of bitmap file\n    readHeaders();\n\n    //Check is file is BMP image\n    bool is_bmp = !strncmp( (const char*)&bmp->bfType, \"BM\", 2 );\n    if (!is_bmp) {\n        LOGE(\"Not bmp file\");\n        if (throwException) {\n            throw_cant_open_file_exception_fd(env, inFd);\n        }\n        return JNI_FALSE;\n    }\n\n    //check is bitmap has 24  bit per pixel. other format not supported\n    if (inf->biBitCount != 16 && inf->biBitCount != 24 && inf->biBitCount != 32 && inf->biBitCount != 0) {\n        LOGE(\"Support only 24bpp bitmaps\");\n        if (throwException) {\n            throw_cant_open_file_exception_fd(env, inFd);\n        }\n        return JNI_FALSE;\n    }\n    LOGII(\"Bits per pixel\", inf->biBitCount);\n\n    int compression = inf->biCompression;\n    LOGII(\"compression\", inf->biCompression);\n    for (int i = 0; i < 3; i++) {\n        LOGII(\"mask\", inf->biPalete[i]);\n    }\n\n    //Component per pixel will be always 4. Alpha will be always 0xff\n    int componentsPerPixel = 4;//inf->biBitCount / 8;\n\n    int width = inf->biWidth;\n    int height = inf->biHeight;\n    LOGII(\"width\", width);\n    LOGII(\"height\", height);\n\n    //Create tiff structure\n    TIFFSetField(tiffImage, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tiffImage, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tiffImage, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiffImage, TIFFTAG_COMPRESSION, compressionInt);\n    TIFFSetField(tiffImage, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tiffImage, TIFFTAG_XRESOLUTION, xRes);\n    TIFFSetField(tiffImage, TIFFTAG_YRESOLUTION, yRes);\n    TIFFSetField(tiffImage, TIFFTAG_RESOLUTIONUNIT, resUnit);\n\n    if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n        TIFFSetField(tiffImage, TIFFTAG_BITSPERSAMPLE,\t1);\n        TIFFSetField(tiffImage, TIFFTAG_SAMPLESPERPIXEL,\t1);\n        TIFFSetField(tiffImage, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        TIFFSetField(tiffImage, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n    } else {\n        TIFFSetField(tiffImage, TIFFTAG_BITSPERSAMPLE, 8);\n        TIFFSetField(tiffImage, TIFFTAG_SAMPLESPERPIXEL, componentsPerPixel);\n        TIFFSetField(tiffImage, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    }\n\n    //creation date\n    char *date = getCreationDate();\n    TIFFSetField(tiffImage, TIFFTAG_DATETIME, date);\n    free(date);\n    //image description\n    if (cdescription) {\n        TIFFSetField(tiffImage, TIFFTAG_IMAGEDESCRIPTION, cdescription);\n    }\n    //software tag\n    if (csoftware) {\n        TIFFSetField(tiffImage, TIFFTAG_SOFTWARE, csoftware);\n    }\n\n    //progress reporter\n    jlong total = width * height;\n    sendProgress(0, total);\n\n    int rowSize = width * componentsPerPixel;\n    //Calculate row per strip\n    //maximum size for strip should be less than 2Mb if memory available\n    unsigned long MB2 = (availableMemory == -1 || availableMemory > 3 * 1024 * 1024) ? 2 * 1024 * 1024 : width * 4;\n    int rowPerStrip = MB2/rowSize;\n    if (rowPerStrip >= height) {\n        rowPerStrip = height / 4;\n    }\n    if (rowPerStrip < 1) rowPerStrip = 1;\n    LOGII(\"rowPerStrip\", rowPerStrip);\n\n    unsigned long estimateMem = rowPerStrip * width * 4 * 2;//need 2 buffers for read data from bitmap. Check getPixelsFromBmp method\n\n    if (compressionInt == COMPRESSION_JPEG) {\n        estimateMem += width * sizeof(uint32);//temp array for writing JPEG lines\n        estimateMem += width * sizeof(uint32);//temp array for fliping bitmap data in getPixelsFromBmp method\n    } else if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n        estimateMem += (width/8 + 0.5) * rowPerStrip; // bilevel array\n    } else {\n        estimateMem += 0;\n    }\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enough memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    if (checkStop()) {\n        conversion_result = JNI_FALSE;\n        return conversion_result;\n    }\n\n    int ret;\n\n    if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n        TIFFSetField(tiffImage, TIFFTAG_ROWSPERSTRIP, rowPerStrip);\n        int compressedWidth = (width/8 + 0.5);\n        for (int y = 0; y < height; y+=rowPerStrip) {\n            if (checkStop()) {\n                conversion_result = JNI_FALSE;\n                return conversion_result;\n            }\n            int rowToRead = rowPerStrip;\n            if (rowToRead + y >= height) {\n                rowToRead = height - y;\n            }\n            sendProgress(y * width, total);\n            uint32 *pixels = getPixelsFromBmp(y, rowToRead);\n            unsigned char *bilevel = convertArgbToBilevel(pixels, width, rowToRead);\n            free(pixels);\n            ret = TIFFWriteEncodedStrip(tiffImage, y/rowToRead, bilevel, compressedWidth * sizeof(unsigned char) * rowToRead);\n            free(bilevel);\n        }\n    } else if (compressionInt == COMPRESSION_JPEG) {\n        for (int ys = 0; ys < height; ys+=rowPerStrip) {\n        if (checkStop()) {\n            return JNI_FALSE;\n        }\n        int rowToRead = rowPerStrip;\n        if (rowToRead + ys >= height) {\n            rowToRead = height - ys;\n        }\n        sendProgress(ys * width, total);\n        uint32 *pixels = getPixelsFromBmp(ys, rowToRead);\n        uint32 *pixelsline = new uint32[width];\n        for (int k = 0; k < rowToRead; k++) {\n            memcpy(pixelsline, &pixels [k * width], width * sizeof(uint32));\n            ret = TIFFWriteScanline(tiffImage, pixelsline, ys + k, 0);\n        }\n        delete[] pixelsline;\n        free(pixels);\n        }\n    } else {\n        TIFFSetField(tiffImage, TIFFTAG_ROWSPERSTRIP, rowPerStrip);\n        for (int y = 0; y < height; y+=rowPerStrip) {\n            if (checkStop()) {\n                return JNI_FALSE;\n            }\n            int rowToRead = rowPerStrip;\n            if (rowToRead + y >= height) {\n                rowToRead = height - y;\n            }\n            //LOGII(\"rowToRead\", rowToRead);\n            sendProgress(y * width, total);\n            uint32 *pixels = getPixelsFromBmp(y, rowToRead);\n            TIFFWriteEncodedStrip(tiffImage, y/rowPerStrip, pixels, width * sizeof(uint32) * rowToRead);\n            free(pixels);\n        }\n    }\n\n    ret = TIFFWriteDirectory(tiffImage);\n    LOGII(\"ret = \", ret);\n\n    sendProgress(total, total);\n    conversion_result = JNI_TRUE;\n    return conversion_result;\n}",
    "jboolean JpgToTiffConverter::convert()\n{\n    readOptions();\n\n    if(outFd < 0) {\n        //open tiff file for writing or appending\n        const char *outCPath = NULL;\n        outCPath = env->GetStringUTFChars(outPath, 0);\n        LOGIS(\"OUT path\", outCPath);\n        LOGIS(\"nativeTiffOpenForSave\", outCPath);\n        int mode = O_RDWR | O_CREAT | O_TRUNC | 0;\n        if (appendTiff) {\n            mode = O_RDWR | O_CREAT;\n        }\n        outFd = open(outCPath, mode, 0666);\n        if (outFd < 0) {\n            throw_cant_open_file_exception(env, outPath);\n            env->ReleaseStringUTFChars(outPath, outCPath);\n            return JNI_FALSE;\n        }\n        env->ReleaseStringUTFChars(outPath, outCPath);\n    }\n\n    if (!appendTiff) {\n        if ((tiffImage = TIFFFdOpen(outFd, \"\", \"w\")) == NULL) {\n        LOGE(\"Unable to open tif file\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, outFd);\n            }\n            return JNI_FALSE;\n        }\n    } else {\n        if ((tiffImage = TIFFFdOpen(outFd, \"\", \"a\")) == NULL) {\n            LOGE(\"Unable to open tif file\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, outFd);\n            }\n            return JNI_FALSE;\n        }\n    }\n\n    //open jpg file fow reading\n    if (inFd < 0) {\n        const char *inCPath = NULL;\n        inCPath = env->GetStringUTFChars(inPath, 0);\n        LOGIS(\"IN path\", inCPath);\n        inFile = fopen(inCPath, \"rb\");\n        if (!inFile) {\n            if (throwException) {\n                throw_cant_open_file_exception(env, inPath);\n            }\n            LOGES(\"Can\\'t open out file\", inCPath);\n            env->ReleaseStringUTFChars(inPath, inCPath);\n            return JNI_FALSE;\n        }\n        env->ReleaseStringUTFChars(inPath, inCPath);\n    } else {\n        inFile = fdopen(inFd, \"rb\");\n        if (!inFile) {\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n            LOGES(\"Can\\'t open out file descriptor\", inFd);\n            return JNI_FALSE;\n        }\n    }\n\n    //read file header\n    size_t byte_count = 8;\n    unsigned char *header = (unsigned char *)malloc(sizeof(unsigned char) * byte_count);\n    fread(header, 1, byte_count, inFile);\n\n    //Check is file is JPG image\n    bool is_jpg = !strncmp( (const char*)header, \"\\xFF\\xD8\\xFF\", 3 );\n    //seek file to begin\n    rewind(inFile);\n    if (!is_jpg) {\n        LOGE(\"Not jpeg file\");\n        if (throwException) {\n            if (inFd < 0) {\n                throw_cant_open_file_exception(env, inPath);\n            } else {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n        }\n        return JNI_FALSE;\n    } else {\n        LOGI(\"IS JPEG\");\n    }\n\n    /* We set up the normal JPEG error routines, then override error_exit. */\n    cinfo.err = jpeg_std_error(&jerr);\n\n    jpeg_create_decompress(&cinfo);\n    jpeg_struct_init = 1;\n    LOGI(\"decompress created\");\n\n    jpeg_stdio_src(&cinfo, inFile);\n    LOGI(\"set file\");\n\n    //read file parameters\n    int readHeader = jpeg_read_header(&cinfo, TRUE);\n    LOGII(\"read jpeg header\", readHeader);\n\n    //start decompress\n    int startDecompress = jpeg_start_decompress(&cinfo);\n    LOGII(\"start decompress\", startDecompress);\n\n    width = cinfo.image_width;\n    height = cinfo.image_height;\n    LOGII(\"width\", width);\n    LOGII(\"height\", height);\n\n    componentsPerPixel = cinfo.output_components;\n\n    //Create tiff structure\n    TIFFSetField(tiffImage, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tiffImage, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tiffImage, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiffImage, TIFFTAG_COMPRESSION, compressionInt);\n    TIFFSetField(tiffImage, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tiffImage, TIFFTAG_XRESOLUTION, xRes);\n    TIFFSetField(tiffImage, TIFFTAG_YRESOLUTION, yRes);\n    TIFFSetField(tiffImage, TIFFTAG_RESOLUTIONUNIT, resUnit);\n\n    if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n        TIFFSetField(tiffImage, TIFFTAG_BITSPERSAMPLE,\t1);\n        TIFFSetField(tiffImage, TIFFTAG_SAMPLESPERPIXEL,\t1);\n        TIFFSetField(tiffImage, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        TIFFSetField(tiffImage, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n    } else {\n        TIFFSetField(tiffImage, TIFFTAG_BITSPERSAMPLE, 8);\n        TIFFSetField(tiffImage, TIFFTAG_SAMPLESPERPIXEL, componentsPerPixel);\n        if (componentsPerPixel == 1) {\n            TIFFSetField(tiffImage, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        } else {\n            TIFFSetField(tiffImage, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        }\n    }\n    //creation date\n    char *date = getCreationDate();\n    TIFFSetField(tiffImage, TIFFTAG_DATETIME, date);\n    free(date);\n    //image description\n    if (cdescription) {\n        TIFFSetField(tiffImage, TIFFTAG_IMAGEDESCRIPTION, cdescription);\n    }\n    //software tag\n    if (csoftware) {\n        TIFFSetField(tiffImage, TIFFTAG_SOFTWARE, csoftware);\n    }\n\n    //progress reporter\n    jlong total = width * height;\n    sendProgress(0, total);\n\n    int rowSize = width * componentsPerPixel;\n    LOGII(\"jpg samples\", componentsPerPixel);\n\n    //Calculate row per strip\n    //maximum size for strip should be less than 2Mb if memory available\n    unsigned long MB2 = (availableMemory == -1 || availableMemory > 3 * 1024 * 1024) ? 2 * 1024 * 1024 : width * 4;\n    int rowPerStrip = MB2/rowSize;\n    //TODO This is workaround. Need to understand why FAX compression schemes have shift in strips.\n    if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n        rowPerStrip = 1;\n    }\n\n    if (rowPerStrip >= height) {\n        rowPerStrip = height / 4;\n    }\n    if (rowPerStrip < 1) rowPerStrip = 1;\n    LOGII(\"rowPerStrip\", rowPerStrip);\n\n    unsigned long estimateMem = rowPerStrip * width * 4;\n    estimateMem += sizeof(JSAMPLE) * rowSize;//jpg buffer\n    if (compressionInt == COMPRESSION_JPEG) {\n        estimateMem += 0;\n    } else if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n        estimateMem += (width/8 + 0.5) * rowPerStrip;\n    } else {\n        estimateMem += rowPerStrip * rowSize;\n    }\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enough memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    if (checkStop()) {\n        //jpeg_finish_decompress(&cinfo);\n        conversion_result = JNI_FALSE;\n        return conversion_result;\n    }\n\n    //Buffer for read jpeg image line by line\n    int buffer_height = 1;\n    JSAMPARRAY buffer = (JSAMPARRAY)malloc(sizeof(JSAMPROW) * buffer_height);\n    buffer[0] = (JSAMPROW)malloc(sizeof(JSAMPLE) * rowSize);\n\n    //buffer for format strips for tiff\n\n\n    int ret;\n    if (compressionInt == COMPRESSION_JPEG) {\n        int line = 0;\n        while (cinfo.output_scanline < height) {\n            if (checkStop()) {\n                free(buffer[0]);\n                free(buffer);\n                conversion_result = JNI_FALSE;\n                return conversion_result;\n            }\n            if (line % rowPerStrip == 0) {\n                sendProgress(line * width, total);\n            }\n            jpeg_read_scanlines(&cinfo, buffer, 1);\n            ret = TIFFWriteScanline(tiffImage, buffer[0], line, 0);\n            line++;\n        }\n    } else {\n        TIFFSetField(tiffImage, TIFFTAG_ROWSPERSTRIP, rowPerStrip);\n        unsigned char *data = new unsigned char[rowSize * rowPerStrip];\n        int totalRowCounter = 0;\n        int rowCounter = 0;\n        bool shouldWrite = false;\n        while (cinfo.output_scanline < height) {\n            shouldWrite = true;\n            jpeg_read_scanlines(&cinfo, buffer, 1);\n            memcpy(data + rowCounter * rowSize, buffer[0], rowSize);\n            rowCounter++;\n            totalRowCounter++;\n            if (rowCounter == rowPerStrip) {\n                if (checkStop()) {\n                    //jpeg_finish_decompress(&cinfo);\n                    delete[] data;\n                    free(buffer[0]);\n                    free(buffer);\n                    conversion_result = JNI_FALSE;\n                    return conversion_result;\n                }\n                if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n                    int compressedWidth = (width/8 + 0.5);\n                    unsigned char *bilevel = convertArgbToBilevel(data, componentsPerPixel, width, rowPerStrip);\n                    ret = TIFFWriteEncodedStrip(tiffImage, totalRowCounter/rowPerStrip - 1, bilevel, compressedWidth * sizeof(unsigned char) * rowPerStrip);\n                    free(bilevel);\n                } else {\n                    ret = TIFFWriteEncodedStrip(tiffImage, totalRowCounter/rowPerStrip - 1, data, rowPerStrip * rowSize);\n                }\n                rowCounter = 0;\n                shouldWrite = false;\n                sendProgress(totalRowCounter * width, total);\n            }\n        }\n        if (shouldWrite) {  LOGI(\"last stage\");\n            if (checkStop()) {\n                //jpeg_finish_decompress(&cinfo);\n                delete[] data;\n                free(buffer[0]);\n                free(buffer);\n                conversion_result = JNI_FALSE;\n                return conversion_result;\n            }\n            if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n                int compressedWidth = (width/8 + 0.5);\n                unsigned char *bilevel = convertArgbToBilevel(data, componentsPerPixel, width, rowPerStrip);\n                ret = TIFFWriteEncodedStrip(tiffImage, totalRowCounter/rowPerStrip, bilevel, compressedWidth * sizeof(unsigned char) * rowPerStrip);\n                free(bilevel);\n            } else {\n                ret = TIFFWriteEncodedStrip(tiffImage, totalRowCounter/rowPerStrip, data, rowPerStrip * rowSize);\n            }\n        }\n        delete[] data;\n    }\n\n    ret = TIFFWriteDirectory(tiffImage);\n    LOGII(\"ret = \", ret);\n\n    jpeg_finish_decompress(&cinfo);\n\n\n    free(buffer[0]);\n    free(buffer);\n\n    sendProgress(total, total);\n    conversion_result = JNI_TRUE;\n    return conversion_result;\n}",
    "jboolean PngToTiffConverter::convert()\n{\n    readOptions();\n\n    //open tiff file for writing or appending\n    if(outFd < 0) {\n        //open tiff file for writing or appending\n        const char *outCPath = NULL;\n        outCPath = env->GetStringUTFChars(outPath, 0);\n        LOGIS(\"OUT path\", outCPath);\n        LOGIS(\"nativeTiffOpenForSave\", outCPath);\n        int mode = O_RDWR | O_CREAT | O_TRUNC | 0;\n        if (appendTiff) {\n            mode = O_RDWR | O_CREAT;\n        }\n        outFd = open(outCPath, mode, 0666);\n        if (outFd < 0) {\n            throw_cant_open_file_exception(env, outPath);\n            env->ReleaseStringUTFChars(outPath, outCPath);\n            return JNI_FALSE;\n        }\n        env->ReleaseStringUTFChars(outPath, outCPath);\n    }\n\n    if (!appendTiff) {\n        if ((tiffImage = TIFFFdOpen(outFd, \"\", \"w\")) == NULL) {\n            LOGE(\"Unable to open tif file\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, outFd);\n            }\n            return JNI_FALSE;\n        }\n    } else {\n        if ((tiffImage = TIFFFdOpen(outFd, \"\", \"a\")) == NULL) {\n            LOGE(\"Unable to open tif file\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, outFd);\n            }\n            return JNI_FALSE;\n        }\n    }\n\n    //open png file fow reading\n    if (inFd == -1) {\n        const char *inCPath = NULL;\n        inCPath = env->GetStringUTFChars(inPath, 0);\n        LOGIS(\"IN path\", inCPath);\n        inFile = fopen(inCPath, \"rb\");\n        if (!inFile) {\n            if (throwException) {\n                throw_cant_open_file_exception(env, inPath);\n            }\n            LOGES(\"Can\\'t open in file\", inCPath);\n            env->ReleaseStringUTFChars(inPath, inCPath);\n            return JNI_FALSE;\n        }\n        env->ReleaseStringUTFChars(inPath, inCPath);\n    } else {\n        inFile = fdopen(inFd, \"rb\");\n        if (!inFile) {\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n            LOGES(\"Can\\'t open out file descriptor\", inFd);\n            return JNI_FALSE;\n        }\n    }\n\n    //read file header\n    size_t byte_count = 8;\n    unsigned char *header = (unsigned char *)malloc(sizeof(unsigned char) * byte_count);\n    fread(header, 1, byte_count, inFile);\n\n    //check is file is PNG or not\n    bool is_png = !png_sig_cmp(header, 0, byte_count);\n    if (!is_png) {\n        LOGE(\"Not png file\");\n        if (throwException) {\n            if (inFd == -1) {\n                throw_cant_open_file_exception(env, inPath);\n            } else {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n        }\n        return JNI_FALSE;\n    } else {\n        LOGI(\"Is png\");\n    }\n\n    //init png struct\n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n    if (!png_ptr) {\n        const char *message = \"Can\\'t create PNG structure\";\n        LOGE(*message);\n        if (throwException) {\n            jstring er = env->NewStringUTF(message);\n            if (inFd < 0) {\n                throw_decode_file_exception(env, inPath, er);\n            } else {\n                throw_decode_file_exception_fd(env, inFd, er);\n            }\n            env->DeleteLocalRef(er);\n        }\n        return JNI_FALSE;\n    }\n    png_ptr_init = 1;\n\n    png_set_sig_bytes(png_ptr, byte_count);\n\n    //create png info pointer\n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        const char *message = \"Can\\'t create PNG info structure\";\n        LOGE(*message);\n        if (throwException) {\n            jstring er = env->NewStringUTF(message);\n            if (inFd < 0) {\n                throw_decode_file_exception(env, inPath, er);\n            } else {\n                throw_decode_file_exception_fd(env, inFd, er);\n            }\n            env->DeleteLocalRef(er);\n        }\n        return JNI_FALSE;\n    }\n    png_info_init = 1;\n\n    //png error handler\n    if (setjmp(png_jmpbuf(png_ptr))) {\n        const char *message = \"Error reading PNG\";\n        LOGE(message);\n        if (throwException) {\n            jstring er = env->NewStringUTF(message);\n            if (inFd < 0) {\n                throw_decode_file_exception(env, inPath, er);\n            } else {\n                throw_decode_file_exception_fd(env, inFd, er);\n            }\n            env->DeleteLocalRef(er);\n        }\n        return JNI_FALSE;\n    }\n\n    //Init PNG IO\n    png_init_io(png_ptr, inFile);\n    //seek file header\n    png_set_sig_bytes(png_ptr, byte_count);\n\n    png_read_info(png_ptr, info_ptr);\n    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, NULL, NULL, NULL);\n\n    LOGII(\"width\", width);\n    LOGII(\"height\", height);\n    LOGII(\"bit_depth\", bit_depth);\n    LOGII(\"color_type\", color_type);\n\n\n\n    // cast any pixel data to RGBA data for simplest reading\n    if(bit_depth == 16)\n        png_set_strip_16(png_ptr);\n\n    if(color_type == PNG_COLOR_TYPE_PALETTE)\n        png_set_palette_to_rgb(png_ptr);\n\n      // PNG_COLOR_TYPE_GRAY_ALPHA is always 8 or 16bit depth.\n    if(color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)\n        png_set_expand_gray_1_2_4_to_8(png_ptr);\n\n    if(png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))\n        png_set_tRNS_to_alpha(png_ptr);\n\n      // These color_type don't have an alpha channel then fill it with 0xff.\n    if(color_type == PNG_COLOR_TYPE_RGB ||\n         color_type == PNG_COLOR_TYPE_GRAY ||\n         color_type == PNG_COLOR_TYPE_PALETTE)\n        png_set_filler(png_ptr, 0xFF, PNG_FILLER_AFTER);\n\n    if(color_type == PNG_COLOR_TYPE_GRAY ||\n         color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n        png_set_gray_to_rgb(png_ptr);\n\n    int number_passes = png_set_interlace_handling(png_ptr);\n    LOGII(\"number_passes\", number_passes);\n\n    png_read_update_info(png_ptr, info_ptr);\n\n\n    LOGII(\"compression\", compressionInt);\n    //Set tiff parameters\n    //Set various text parameters\n    //Set image parameters\n    TIFFSetField(tiffImage, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tiffImage, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tiffImage, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiffImage, TIFFTAG_COMPRESSION, compressionInt);\n    TIFFSetField(tiffImage, TIFFTAG_ORIENTATION, orientationInt);\n    TIFFSetField(tiffImage, TIFFTAG_XRESOLUTION, xRes);\n    TIFFSetField(tiffImage, TIFFTAG_YRESOLUTION, yRes);\n    TIFFSetField(tiffImage, TIFFTAG_RESOLUTIONUNIT, resUnit);\n\n    if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n        TIFFSetField(tiffImage, TIFFTAG_BITSPERSAMPLE,\t1);\n        TIFFSetField(tiffImage, TIFFTAG_SAMPLESPERPIXEL,\t1);\n        TIFFSetField(tiffImage, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        TIFFSetField(tiffImage, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n    } else {\n        TIFFSetField(tiffImage, TIFFTAG_BITSPERSAMPLE, 8);\n        TIFFSetField(tiffImage, TIFFTAG_SAMPLESPERPIXEL, 4);\n        TIFFSetField(tiffImage, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    }\n    //creation date\n    char *date = getCreationDate();\n    TIFFSetField(tiffImage, TIFFTAG_DATETIME, date);\n    free(date);\n    //image description\n    if (cdescription) {\n        TIFFSetField(tiffImage, TIFFTAG_IMAGEDESCRIPTION, cdescription);\n    }\n    //software tag\n    if (csoftware) {\n        TIFFSetField(tiffImage, TIFFTAG_SOFTWARE, csoftware);\n    }\n\n    //Calculate row per strip\n    //maximum size for strip should be less than 2Mb if memory available\n    unsigned long MB2 = (availableMemory == -1 || availableMemory > 3 * 1024 * 1024) ? 2 * 1024 * 1024 : width * 4;\n    unsigned long rowSizeBytes = width * 4;\n    int rowPerStrip = MB2/rowSizeBytes;\n    if (rowPerStrip >= height) {\n        rowPerStrip = height / 4;\n    }\n    if (rowPerStrip < 1) rowPerStrip = 1;\n    LOGII(\"rowPerStrip\", rowPerStrip);\n\n    //check available memory and estimate memory\n    unsigned long estimateMem = rowPerStrip * width * 4;\n    estimateMem += (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) ? (width/8 + 0.5) * rowPerStrip : 0;\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enough memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    if (checkStop()) {\n        conversion_result = JNI_FALSE;\n        return conversion_result;\n    }\n\n    //progress reporter\n    jlong total = width * height;\n    sendProgress(0, total);\n\n\n    int rowbytes = png_get_rowbytes(png_ptr,info_ptr);\n    png_bytep row_pointers[rowPerStrip];\n    for (int sy = 0; sy < rowPerStrip; sy++) {\n        row_pointers[sy] = (png_byte*)malloc(rowbytes);\n    }\n\n    int ret;\n\n    // Write the information to the file\n    if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n        TIFFSetField(tiffImage, TIFFTAG_ROWSPERSTRIP, rowPerStrip);\n        int compressedWidth = (width/8 + 0.5);\n        for (int y = 0; y < height; y+=rowPerStrip) {\n            if (checkStop()) {\n                for (int sy = 0; sy < rowPerStrip; sy++) {\n                    free(row_pointers[sy]);\n                }\n                conversion_result = JNI_FALSE;\n                return conversion_result;\n            }\n            int rowToRead = rowPerStrip;\n            if (rowToRead + y >= height) {\n                rowToRead = height - y;\n            }\n            sendProgress(y * width, total);\n            png_read_rows(png_ptr, &row_pointers[0], NULL, rowToRead);\n            unsigned char *bilevel = convertArgbToBilevel(&row_pointers[0], 4, width, rowToRead);\n            TIFFWriteEncodedStrip(tiffImage, y/rowPerStrip, bilevel, compressedWidth * sizeof(unsigned char) * rowToRead);\n            free(bilevel);\n        }\n    } else if (compressionInt == COMPRESSION_JPEG) {\n        for (int ys = 0; ys < height; ys+=rowPerStrip) {\n            if (checkStop()) {\n                for (int sy = 0; sy < rowPerStrip; sy++) {\n                    free(row_pointers[sy]);\n                }\n                conversion_result = JNI_FALSE;\n                return conversion_result;\n            }\n            int rowToRead = rowPerStrip;\n            if (rowToRead + ys >= height) {\n                rowToRead = height - ys;\n            }\n            LOGII(\"rowToRead\", rowToRead);\n            sendProgress(ys * width, total);\n            png_read_rows(png_ptr, &row_pointers[0], NULL, rowToRead);\n            uint32 *pixels = new uint32[width];\n            for (int k = 0; k < rowToRead; k++) {\n                memcpy(pixels, row_pointers[k], width * sizeof(uint32));\n                ret = TIFFWriteScanline(tiffImage, pixels, ys + k, 0);\n            }\n            //TIFFWriteEncodedStrip(tiffImage, y/rowPerStrip, pixels, width * sizeof(uint32) * rowToRead);\n            delete[] pixels;\n\n        }\n    } else {\n        TIFFSetField(tiffImage, TIFFTAG_ROWSPERSTRIP, rowPerStrip);\n        for (int y = 0; y < height; y+=rowPerStrip) {\n            if (checkStop()) {\n                for (int sy = 0; sy < rowPerStrip; sy++) {\n                    free(row_pointers[sy]);\n                }\n                conversion_result = JNI_FALSE;\n                return conversion_result;\n            }\n            int rowToRead = rowPerStrip;\n            if (rowToRead + y >= height) {\n                rowToRead = height - y;\n            }\n            LOGII(\"rowToRead\", rowToRead);\n            sendProgress(y * width, total);\n            png_read_rows(png_ptr, &row_pointers[0], NULL, rowToRead);\n            uint32 *pixels = new uint32[width * rowPerStrip];\n            for (int k = 0; k < rowToRead; k++) {\n                memcpy(pixels+k*width, row_pointers[k], width * sizeof(uint32));\n            }\n            TIFFWriteEncodedStrip(tiffImage, y/rowPerStrip, pixels, width * sizeof(uint32) * rowToRead);\n            delete[] pixels;\n        }\n    }\n    //free memory allocated for png rows\n    for (int sy = 0; sy < rowPerStrip; sy++) {\n        free(row_pointers[sy]);\n    }\n    ret = TIFFWriteDirectory(tiffImage);\n    LOGII(\"ret = \", ret);\n\n\n    sendProgress(total, total);\n    conversion_result = JNI_TRUE;\n    return conversion_result;\n}",
    "int main(int argc, char **argv) {\n\n\tint devId = 0;\n\n\tchar *fname = NULL;\n\n\tint verbose = 0;\n\tint decWriteOutN = 0;\n\n\tint frameBeg = INT_MIN;\n\tint frameEnd = INT_MAX;\n\tint decodeRange = 0;\n\tint doEncode = 0;\n\tint encWriteOut = 0;\n\n\tint och;\n\twhile(1) {\n\t\tint option_index = 0;\n\t\tstatic struct option long_options[] = {\n\t\t\t{      \"file\", required_argument, 0, 'f'},\n\t\t\t{    \"device\", required_argument, 0, 'd'},\n\t\t\t{\"decode-out\", optional_argument, 0,   1},\n\t\t\t{ \"frame-beg\", required_argument, 0, 'b'},\n\t\t\t{ \"frame-end\", required_argument, 0, 'e'},\n\t\t\t{   \"memtype\", required_argument, 0, 'm'},\n\t\t\t{   \"copyh2d\", required_argument, 0, 'c'},\n\t\t\t{   \"verbose\",       no_argument, 0, 'v'},\n\t\t\t{    \"encode\",       no_argument, 0, 'E'},\n\t\t\t{\"rowsxstrip\", required_argument, 0, 'r'},\n\t\t\t{\"stripalloc\", required_argument, 0, 's'},\n\t\t\t{\"encode-out\", optional_argument, 0,   2},\n\t\t\t{      \"help\",       no_argument, 0, 'h'},\n\t\t\t{           0,                 0, 0,   0}\n\t\t};\n\n\t\toch = getopt_long(argc, argv, \"f:d:vo::hb:e:m:cEr:s:\", long_options, &option_index);\n\t\tif (och == -1) break;\n\t\tswitch (och) {\n\t\t\tcase   0:// handles long opts with non-NULL flag field\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tdevId = atoi(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tfname = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tframeBeg = atoi(optarg);\n\t\t\t\tdecodeRange = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tframeEnd = atoi(optarg);\n\t\t\t\tdecodeRange = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tverbose++;\n\t\t\t\tbreak;\n\t\t\tcase   1:\n\t\t\t\tdecWriteOutN = 1;\n\t\t\t\tif(!optarg                 &&\n\t\t\t\t   argv[optind]    != NULL &&\n\t\t\t\t   argv[optind][0] != '-') {\n\n\t\t\t\t\tdecWriteOutN = atoi(argv[optind++]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tdoEncode = 1;\n\t\t\t\tbreak;\n\t\t\tcase   2:\n\t\t\t\tencWriteOut = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\tcase '?':\n\t\t\t\tusage(argv[0]);\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"unknown option: %c\\n\", och);\n\t\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\n\tif (!fname) {\n\t\tfprintf(stderr, \"Please specify a TIFF file with the -f option!\\n\");\n\t\tusage(argv[0]);\n\t}\n\n\tif (frameBeg > frameEnd) {\n\t\tfprintf(stderr, \"Invalid frame range!\\n\");\n\t\tusage(argv[0]);\n\t}\n\n\tCHECK_CUDA(cudaSetDevice(devId));\n\n\tcudaDeviceProp props;\n\n\tprintf(\"\\nUsing GPU:\\n\");\n\tCHECK_CUDA(cudaGetDeviceProperties(&props, devId));\n\tprintf(\"\\t%2d (%s, %d SMs, %d th/SM max, CC %d.%d, ECC %s)\\n\",\n\t\t\tdevId, props.name, props.multiProcessorCount,\n\t\t\tprops.maxThreadsPerMultiProcessor,\n\t\t\tprops.major, props.minor,\n\t\t\tprops.ECCEnabled?\"on\":\"off\");\n\tprintf(\"\\n\");\n\n\t// dummy allocation to initialize subsystems\n\tunsigned char *dummy;\n\tCHECK_CUDA(cudaMalloc(&dummy, 1024*1024*10));\n\tCHECK_CUDA(cudaFree(dummy));\n\n\tcudaStream_t stream;\n\tCHECK_CUDA(cudaStreamCreate(&stream));\n\n\n\tnvtiffStream_t tiff_stream;\n\tnvtiffDecoder_t decoder;\n    CHECK_NVTIFF(nvtiffStreamCreate(&tiff_stream));\n\tCHECK_NVTIFF(nvtiffDecoderCreate(&decoder,\n        nullptr, nullptr, 0));\n\n    CHECK_NVTIFF(nvtiffStreamParseFromFile(fname, tiff_stream));\n\n\tuint32_t num_images = 0;\n    CHECK_NVTIFF(nvtiffStreamGetNumImages(tiff_stream, &num_images));\n\tstd::vector<nvtiffImageInfo_t> image_info(num_images);\n    std::vector<uint8_t*> nvtiff_out(num_images);\n    std::vector<size_t> nvtiff_out_size(num_images);\n    \n\t// BEGIN work (possibly) overlapped with H2D copy of the file data\n\tif (verbose) {\n\t\tCHECK_NVTIFF(nvtiffStreamPrint(tiff_stream));\n\t}\n\t\n\tframeBeg = fmax(frameBeg, 0);\n\tframeEnd = fmin(frameEnd, num_images-1);\n\tconst int nDecode = frameEnd-frameBeg+1;\n\n\tfor (uint32_t image_id = 0; image_id < num_images; image_id++) {\n        CHECK_NVTIFF(nvtiffStreamGetImageInfo(tiff_stream, image_id, &image_info[image_id]));\n        nvtiff_out_size[image_id] = DIV_UP((size_t)image_info[image_id].bits_per_pixel * image_info[image_id].image_width, 8) *\n                                    (size_t)image_info[image_id].image_height;\n        if (image_info[image_id].photometric_int == NVTIFF_PHOTOMETRIC_PALETTE) {\n            nvtiff_out_size[image_id] = image_info[image_id].image_width * image_info[image_id].image_height * 3 * sizeof(uint16_t);\n        }\n        CHECK_CUDA(cudaMalloc(&nvtiff_out[image_id], nvtiff_out_size[image_id]));\n    }\n\n\tprintf(\"Decoding %u, images [%d, %d], from file %s... \",\n\t\tnDecode,\n\t\tframeBeg,\n\t\tframeEnd,\n\t\tfname);\n\tfflush(stdout);\n\n\n\tauto decode_start = perfclock::now();\n\tif (!decodeRange) {\n\t\tCHECK_NVTIFF(nvtiffDecode(tiff_stream, decoder, nvtiff_out.data(), stream));\n\t} else { \n\t\tCHECK_NVTIFF(nvtiffDecodeRange(tiff_stream, decoder, frameBeg, nDecode, nvtiff_out.data(), stream));\n\t}\n\tCHECK_CUDA(cudaStreamSynchronize(stream));\n\tauto decode_end = perfclock::now();\n    double decode_time = std::chrono::duration<float>(decode_end - decode_start).count();\n\n\tprintf(\"done in %lf secs\\n\\n\", decode_time);\n\n\tif (decWriteOutN) {\n        const uint32_t nout = std::min(decWriteOutN, nDecode);\n\n        printf(\"Writing images for the first %d subfile(s)...\\n\", nout);\n        fflush(stdout);\n\n        for (uint32_t image_id = 0; image_id < nout; image_id++) {\n            auto& info = image_info[image_id];\n            std::vector<uint8_t> imageOut_h(nvtiff_out_size[image_id]);\n            CHECK_CUDA(cudaMemcpy(imageOut_h.data(), nvtiff_out[image_id], nvtiff_out_size[image_id], cudaMemcpyDeviceToHost));\n            write_image(fname, info, imageOut_h.data(), image_id);\n        }\n    }\n\n#ifdef LIBTIFF_TEST\n\tTIFF* tif = TIFFOpen(fname, \"r\");\n\tif (tif) {\n\n\t\t// we alredy know that all subfiles have the same porperties\n\t\tuint32_t *raster;\n\t\traster = (uint32_t *)_TIFFmalloc(tiffData->subFiles[0].ncol*tiffData->subFiles[0].nrow * sizeof (uint32_t));\n\n\t\tprintf(\"\\tDecoding with libTIFF... \"); fflush(stdout);\n\t\tauto decode_start = perfclock::now();\n\t\tfor(int i = 0; i < tiffData->nSubFiles; i++) {\n\t\t\tif (!TIFFReadRGBAImage(tif,\n\t\t\t\t\t       tiffData->subFiles[i].ncol,\n\t\t\t\t\t       tiffData->subFiles[i].nrow,\n\t\t\t\t\t       raster, 0)) {\n\t\t\t\tfprintf(stderr, \"Error while decoding image %d with libTiff\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tTIFFReadDirectory(tif);\n\t\t}\n\t\tauto decode_end = perfclock::now();\n\t\tdouble decode_time = std::chrono::duration<float>(decode_end - decode_start).count();\n\t\tprintf(\"done in %lf secs\\n\\n\", decode_time);\n\n\t\t_TIFFfree(raster);\n\t\tTIFFClose(tif);\n\t}\n#endif\n\tbool identical_multi_tiff = check_identical(image_info.data(), num_images);\n\tif(!identical_multi_tiff && doEncode){\n\t\tprintf(\"Encoding will be skipped since the images within the tiff file do not have identical properties...\\n\");\n\t}\n\t// TODO check identical\n\tif (doEncode && identical_multi_tiff) {\n\n\t\tunsigned int nrow              = image_info[0].image_height;\n\t\tunsigned int ncol              = image_info[0].image_width;\n\t\tunsigned int photometricInt    = (unsigned int)image_info[0].photometric_int;\n\t\tunsigned int planarConf        = (unsigned int)image_info[0].planar_config;\n\t\tunsigned short pixelSize       = image_info[0].bits_per_pixel/8;\n\t\tunsigned short samplesPerPixel = image_info[0].samples_per_pixel;\n\t\tunsigned short sampleFormat    = image_info[0].sample_format[0];\n\n\t\tunsigned short *bitsPerSample = (unsigned short *)malloc(sizeof(*bitsPerSample)*samplesPerPixel);\n\t\tmemcpy(bitsPerSample,\n\t\t\timage_info[0].bits_per_sample,\n\t\t       sizeof(*bitsPerSample)*samplesPerPixel);\n\n\t\tCHECK_NVTIFF(nvtiffStreamDestroy(tiff_stream));\n        CHECK_NVTIFF(nvtiffDecoderDestroy(decoder, stream));\n\t\ttiff_stream = NULL;\n\t\tdecoder = NULL;\n\n\t\tunsigned int nSubFiles = nDecode;\n\n\t\tprintf(\"Encoding %u, %s %ux%u images ... \",\n\t\t\tnDecode, image_info[0].photometric_int == 2 ? \"RGB\" : \"Grayscale\",\n\t\t\timage_info[0].image_width, image_info[0].image_height);\n\t\tfflush(stdout);\n\n        auto enc_start = perfclock::now();\n\n\t\tnvtiffEncoder_t encoder;\n\t\tCHECK_NVTIFF(nvtiffEncoderCreate(&encoder, nullptr, nullptr, stream));\n\t\tnvtiffEncodeParams_t params;\n\t\tCHECK_NVTIFF(nvtiffEncodeParamsCreate(&params));\n\t\tCHECK_NVTIFF(nvtiffEncodeParamsSetImageInfo(params, &image_info[0]));\n\t\tCHECK_NVTIFF(nvtiffEncodeParamsSetInputs(params, nvtiff_out.data(), nSubFiles));\n\t\tCHECK_NVTIFF(nvtiffEncode(encoder, &params, 1, stream));\n\t\tCHECK_NVTIFF(nvtiffEncodeFinalize(encoder, &params, 1, stream));\n\n\t\tCHECK_CUDA(cudaStreamSynchronize(stream));\n\t\tauto enc_end = perfclock::now();\n\t\tdouble enc_time = std::chrono::duration<float>(enc_end - enc_start).count();\n\n\t    size_t stripSizeTotal = 0;\n        size_t metadataSize = 0;\n\t\tCHECK_NVTIFF(nvtiffGetBitstreamSize(encoder, &params, 1, &metadataSize, &stripSizeTotal));\n\t\tprintf(\"done in %lf secs (compr. ratio: %.2lfx)\\n\\n\",\n\t\t\t\tenc_time, double(nvtiff_out_size[0])*nSubFiles/stripSizeTotal);\n\n\t\tif (encWriteOut) {\n\t\t\tprintf(\"\\tWriting %u compressed images to TIFF file... \", nDecode); fflush(stdout);\n\t\t\tauto write_start = perfclock::now();\n\t\t\tCHECK_NVTIFF(nvtiffWriteTiffFile(encoder, &params, 1, \"outFile.tif\", stream));\n\t\t\tauto write_end = perfclock::now();\n\t\t\tdouble write_time = std::chrono::duration<float>(write_end - write_start).count();\n\t\t\tprintf(\"done in %lf secs\\n\\n\", write_time);\n\n\t\t}\n        CHECK_NVTIFF(nvtiffEncodeParamsDestroy(params, stream));\n\t\tCHECK_NVTIFF(nvtiffEncoderDestroy(encoder, stream));\n\n#ifdef LIBTIFF_TEST\n\t\ttif = TIFFOpen(\"libTiffOut.tif\", \"w\");\n\t\tif (tif) {\n\n\t\t\tunsigned char **imageOut_h = (unsigned char **)Malloc(sizeof(*imageOut_h)*nDecode);\n\t\t\tfor(unsigned int i = 0; i < nDecode; i++) {\n\t\t\t\timageOut_h[i] = (unsigned char *)Malloc(sizeof(*imageOut_h)*imageSize);\n\t\t\t\tCHECK_CUDA(cudaMemcpy(imageOut_h[i],\n\t\t\t\t\t\t\timageOut_d[i],\n\t\t\t\t\t\t\timageSize,\n\t\t\t\t\t\t\tcudaMemcpyDeviceToHost));\n\t\t\t}\n\n\t\t\tsize_t stripSize = sizeof(**imageOut_h)*encRowsPerStrip*ncol*pixelSize;\n\n\t\t\tprintf(\"\\tEncoding with libTIFF... \"); fflush(stdout);\n\t\t\t__t = Wtime();\n\t\t\tfor(unsigned int i = 0; i < nDecode; i++) {\n\n\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, nrow);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, ncol);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometricInt);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_FILLORDER, 1);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, samplesPerPixel);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, planarConf);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, encRowsPerStrip);\n\n\t\t\t\tfor(unsigned int j = 0; j < nStripOut; j++) {\n\n\t\t\t\t\tunsigned int currStripSize = stripSize;\n\t\t\t\t\tif (j == nStripOut-1) {\n\t\t\t\t\t\tcurrStripSize = imageSize - j*stripSize;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (-1 == TIFFWriteEncodedStrip(tif,\n\t\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\t\timageOut_h[i]+j*stripSize,\n\t\t\t\t\t\t\t\tcurrStripSize)) {\n\n\t\t\t\t\t\tfprintf(stderr, \"Error while encoding image %d with libTiff\\n\", i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// need to find a way to have libTiff to encode in \n\t\t\t\t// memory without writing to disk the last direnctory\n\t\t\t\t// after each TIFFWriteDirectory() call\n\t\t\t\tTIFFWriteDirectory(tif);\n\t\t\t\t//TIFFRewriteDirectory(tif);\n\t\t\t}\n\t\t\t__t = Wtime()-__t;\n\t\t\tprintf(\"done in %lf secs\\n\\n\", __t);\n\n\t\t\tTIFFClose(tif);\n\t\t}\n#endif\n\t}\n\n\t// cleanup\n\tfor(unsigned int i = 0; i < nDecode; i++) {\n\t\tCHECK_CUDA(cudaFree(nvtiff_out[i]));\n\t}\n\n\tfree(fname);\n\t\n\tif(tiff_stream)\t{\n\t\tCHECK_NVTIFF(nvtiffStreamDestroy(tiff_stream));\n\t}\n    \n\tif(decoder){\n\t    CHECK_NVTIFF(nvtiffDecoderDestroy(decoder, stream));\n\t }\n\t\n\tCHECK_CUDA(cudaStreamDestroy(stream));\n\n\tCHECK_CUDA(cudaDeviceReset());\n\n\treturn 0;\n}",
    "bool ossimGeoTiff::writeJp2GeotiffBox(const ossimFilename &tmpFile,\n                                      const ossimIrect &rect,\n                                      const ossimProjection *proj,\n                                      std::vector<ossim_uint8> &buf,\n                                      ossimPixelType pixelType)\n{\n   //---\n   // Snip from The \"GeoTIFF Box\" Specification for JPEG 2000 Metadata:\n   // This box contains a valid GeoTIFF image.  The image is \"degenerate\", in\n   // that it represents a very simple image with specific constraints:\n   // . the image height and width are both 1\n   // . the datatype is 8-bit\n   // . the colorspace is grayscale\n   // . the (single) pixel must have a value of 0 for its (single) sample\n   //\n   // NOTE: It also states little endian but I think libtiff writes whatever\n   // endianesss the host is.\n   //\n   // Also assuming class tiff for now.  Not big tiff.\n   //---\n   bool result = true;\n\n   TIFF *tiff = XTIFFOpen(tmpFile.c_str(), \"w\");\n   if (tiff)\n   {\n      // Write the projection info out.\n      ossimMapProjection *mapProj = PTR_CAST(ossimMapProjection, proj);\n      if (mapProj)\n      {\n         ossimRefPtr<ossimMapProjectionInfo> projectionInfo = new ossimMapProjectionInfo(mapProj, ossimDrect(rect));\n\n         // Set the pixel type to point of area.\n         projectionInfo->setPixelType(pixelType);\n\n         // Write the geotiff keys.\n         ossimGeoTiff::writeTags(tiff, projectionInfo, false);\n      }\n\n      // Basic tiff tags.\n      TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, 1);\n      TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, 1);\n      TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n      TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 1);\n      TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n      TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n      TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\n      // One pixel image:\n      ossim_uint8 pixel = 0;\n      TIFFWriteEncodedStrip(tiff, 0, (char *)&pixel, 1);\n\n      TIFFWriteDirectory(tiff);\n      XTIFFClose(tiff);\n\n      // Get the size.  Note 16 bytes added for the JP2 UUID:\n      const std::vector<ossim_uint8>::size_type UUID_SIZE = 16;\n      const std::vector<ossim_uint8>::size_type BOX_SIZE = UUID_SIZE +\n                                                           static_cast<std::vector<ossim_uint8>::size_type>(tmpFile.fileSize());\n\n      // Create the buffer.\n      buf.resize(BOX_SIZE);\n\n      if (BOX_SIZE == buf.size())\n      {\n         const ossim_uint8 GEOTIFF_UUID[UUID_SIZE] =\n             {\n                 0xb1, 0x4b, 0xf8, 0xbd,\n                 0x08, 0x3d, 0x4b, 0x43,\n                 0xa5, 0xae, 0x8c, 0xd7,\n                 0xd5, 0xa6, 0xce, 0x03};\n\n         // Copy the UUID.\n         std::vector<ossim_uint8>::size_type i;\n         for (i = 0; i < UUID_SIZE; ++i)\n         {\n            buf[i] = GEOTIFF_UUID[i];\n         }\n\n         // Copy the tiff.\n         std::ifstream str;\n         str.open(tmpFile.c_str(), ios::in | ios::binary);\n         if (str.is_open())\n         {\n            char ch;\n            for (; i < BOX_SIZE; ++i)\n            {\n               str.get(ch);\n               buf[i] = static_cast<ossim_uint8>(ch);\n            }\n         }\n      }\n      else\n      {\n         result = false;\n      }\n\n      // Remove the temp file.\n      tmpFile.remove();\n   }\n   else\n   {\n      result = false;\n\n      if (traceDebug())\n      {\n         ossimNotify(ossimNotifyLevel_WARN)\n             << \"ossimGeoTiff::writeJp2GeotiffBox ERROR:\\n\"\n             << \"Could not open \" << tmpFile << std::endl;\n      }\n   }\n   return result;\n}",
    "bool ossimTiffOverviewBuilder::writeR0(TIFF* tif)\n{\n   static const char MODULE[] = \"ossimTiffOverviewBuilder::writeR0\";\n\n   ossimIrect rect = m_imageHandler->getImageRectangle();\n\n   if (!setTags(tif, rect, 0))\n   {\n      closeTiff(tif);\n      ossimNotify(ossimNotifyLevel_WARN) << MODULE << \" Error writing tags!\" << std::endl;\n      return false;\n   }\n   \n   // Set the geotiff tags.\n   if ( setGeotiffTags(m_imageHandler->getImageGeometry().get(),\n                       m_imageHandler->getBoundingRect(),\n                       0,\n                       tif) == false )\n   {\n      if (traceDebug())\n      {\n         ossimNotify(ossimNotifyLevel_NOTICE)\n            << MODULE << \" NOTICE: geotiff tags not set.\" << std::endl;\n      } \n   }\n   \n   ossim_int32 samples         = m_imageHandler->getNumberOfSamples();\n   ossim_int32 lines           = m_imageHandler->getNumberOfLines();\n   ossim_int32 tilesWide       = samples % m_tileWidth ?\n                           samples / m_tileWidth + 1 : samples / m_tileWidth;\n   ossim_int32 tilesHigh       = lines % m_tileHeight ?\n                           lines / m_tileHeight + 1 : lines / m_tileHeight;\n   ossim_int32 numberOfTiles   = tilesWide * tilesHigh;\n\n   int tileNumber = 0;\n\n   if (traceDebug())\n   {\n      ossimNotify(ossimNotifyLevel_DEBUG)\n         << \"ossimTiffOverviewBuilder::writeR0 DEBUG:\"\n         << \"\\nsamples:        \" << samples\n         << \"\\nlines:          \" << lines\n         << \"\\ntilesWide:      \" << tilesWide\n         << \"\\ntilesHigh:      \" << tilesHigh\n         << \"\\nnumberOfTiles:  \" << numberOfTiles\n         << std::endl;\n   }\n\n   setCurrentMessage(ossimString(\"Copying r0...\"));\n   \n   //***\n   // Tile loop in the line direction.\n   //***\n   for(int i = 0; i < tilesHigh; ++i)\n   {\n      ossimIpt origin(0, 0);\n      origin.y = i * m_tileHeight;\n      \n      //***\n      // Tile loop in the sample (width) direction.\n      //***\n      for(int j = 0; (j < tilesWide)&&(!needsAborting()); ++j)\n      {\n         origin.x = j * m_tileWidth;\n\n         ossimRefPtr<ossimImageData> t =\n            m_imageHandler->getTile(ossimIrect(origin.x,\n                                                origin.y,\n                                                origin.x +(m_tileWidth-1),\n                                                origin.y +(m_tileHeight-1)));\n\n         // Check for errors reading tile:\n         if ( m_imageHandler->hasError() )\n         {\n            ossimNotify(ossimNotifyLevel_WARN)\n               << MODULE << \" ERROR: reading tile:  \" << i << std::endl;\n            return false;\n         }\n\n         // If masking was enabled, pass the tile onto that object for processing:\n         if (m_maskWriter.valid())\n            m_maskWriter->generateMask(t, 0);\n\n         //***\n         // Band loop.\n         //***\n         for (ossim_uint32 band=0;\n              (band < m_imageHandler->getNumberOfOutputBands())&&!needsAborting();\n              ++band)\n         {\n            tdata_t data;\n            \n            if ( t.valid() && (t->getDataObjectStatus() != OSSIM_NULL) )\n            {\n               // Grab a pointer to the tile for the band.\n               data = static_cast<tdata_t>(t->getBuf(band));\n            }\n            else\n            {\n               data = static_cast<tdata_t>(&(m_nullDataBuffer.front()));\n            }\n\n            // Write the tile.\n            int bytesWritten = 0;\n            bytesWritten = TIFFWriteTile(tif,\n                                         data,\n                                         origin.x,\n                                         origin.y,\n                                         0,        // z\n                                         band);    // sample\n\n            if (bytesWritten != m_tileSizeInBytes)\n            {\n               ossimNotify(ossimNotifyLevel_WARN)\n                  << MODULE << \" ERROR:\"\n                  << \"Error returned writing tiff tile:  \" << i\n                  << \"\\nExpected bytes written:  \" << m_tileSizeInBytes\n                  << \"\\nBytes written:  \" << bytesWritten\n                  << std::endl;\n               theErrorStatus = ossimErrorCodes::OSSIM_ERROR;\n               return false;\n            }\n\n         } // End of band loop.  \n        \n         ++tileNumber;\n\n      } // End of tile loop in the sample (width) direction.\n\n      if (needsAborting())\n      {\n         setPercentComplete(100.0);\n         break;\n      }\n      else\n      {\n         double tile = tileNumber;\n         double numTiles = numberOfTiles;\n         setPercentComplete(tile / numTiles * 100.0);\n      }\n\n   } // End of tile loop in the line (height) direction.\n\n   //***\n   // Write the current dirctory.\n   //***\n   if (!TIFFWriteDirectory(tif))\n   {\n      ossimNotify(ossimNotifyLevel_WARN)\n         << MODULE << \" Error writing directory!\" << std::endl;\n      return false;\n   }\n\n   ++m_currentTiffDir;\n\n   return true;\n}",
    "bool imwrite_tiff(const matrix<unsigned short>& output, string outputfilename,\n                  Exiv2::ExifData exifData)\n{\n    int xsize, ysize;\n    xsize = output.nc()/3;\n    ysize = output.nr();\n\n\n\n    outputfilename = outputfilename + \".tif\";\n    TIFF *out = TIFFOpen(outputfilename.c_str(),\"w\");\n    if (!out)\n    {\n        cerr << \"Can't open file for writing\" << endl;\n        return 1;\n    }\t\n    TIFFSetField(out, TIFFTAG_IMAGEWIDTH, xsize);  \n    TIFFSetField(out, TIFFTAG_IMAGELENGTH, ysize);\n    TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3); //RGB\n    TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 16);\n    TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);    // set the origin of the image.\n    //Magic below\n    TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    if(!TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_NONE)) {cout << \"couldn't set tiff compression\" << endl;}\n    //End Magic\n\n    std::string make = exifData[\"Exif.Image.Make\"].toString();\n    TIFFSetField(out, TIFFTAG_MAKE, make.c_str());\n    std::string model = exifData[\"Exif.Image.Model\"].toString();\n    TIFFSetField(out, TIFFTAG_MODEL, model.c_str());\n    TIFFSetField(out, TIFFTAG_SOFTWARE, \"Filmulator\");\n    std::string copyright = exifData[\"Exif.Image.Copyright\"].toString();\n    TIFFSetField(out, TIFFTAG_COPYRIGHT, copyright.c_str());\n    std::string lensinfo = exifData[\"Exif.Image.LensInfo\"].toString();\n    TIFFSetField(out, TIFFTAG_LENSINFO, lensinfo.c_str());\n    std::string datetime = exifData[\"Exif.Image.DateTime\"].toString();\n    TIFFSetField(out, TIFFTAG_DATETIME, datetime.c_str());\n\n    tsize_t linebytes = 3 * xsize * 2;//Size in bytes of a line\n    unsigned short *buf = NULL;\n    buf =(unsigned short *)_TIFFmalloc(linebytes);\n    for (int j = 0; j < ysize; j++)\n    {\n        for(int i = 0; i < xsize; i ++)\n        {\n            buf[i*3  ] = output(j,i*3  );\n            buf[i*3+1] = output(j,i*3+1);\n            buf[i*3+2] = output(j,i*3+2);\n        }\n        if (TIFFWriteScanline(out, buf, j, 0) < 0)\n            break;\n    }\n\n    TIFFWriteDirectory(out);\n\n    (void) TIFFClose(out);\n\n    if (buf)\n        _TIFFfree(buf);\n\n    //Programs reading tiffs really freak out if you write the full exif data\n    //So we write only the basics here.\n    Exiv2::ExifData minimumData;\n    minimumData[\"Exif.Photo.ISOSpeedRatings\"] = exifData[\"Exif.Photo.ISOSpeedRatings\"];\n    minimumData[\"Exif.Photo.ExposureTime\"]    = exifData[\"Exif.Photo.ExposureTime\"];\n    minimumData[\"Exif.Photo.FNumber\"]         = exifData[\"Exif.Photo.FNumber\"];\n    minimumData[\"Exif.Photo.FocalLength\"]     = exifData[\"Exif.Photo.FocalLength\"];\n\n    minimumData.sortByTag(); //darktable's does this so maybe we should\n\n    auto image = Exiv2::ImageFactory::open(outputfilename);\n    assert(image.get() != 0);\n\n    image->setExifData(minimumData);\n    image->writeMetadata();\n\n    return 0;\n}",
    "bool CTIFFWriter::Open()\n{\n\tZFUNCTRACE_RUNTIME();\n\tbool bResult = false;\n\tconstexpr unsigned char exifVersion[4] {'0', '2', '3', '1' }; // EXIF 2.31 version is 4 characters of a string!\n\tuint64_t dir_offset_EXIF{ 0 };\n\n#ifdef Q_OS_WIN\n\tm_tiff = TIFFOpenW(file.wstring().c_str(), \"w\");\n#else\n\tm_tiff = TIFFOpen(reinterpret_cast<const char*>(file.u8string().c_str()), \"w\");\n#endif\n\tif (m_tiff != nullptr)\n\t{\n\t\tphoto = PHOTOMETRIC_RGB;\n\n\t\tbResult = OnOpen();\n\t\tif (bResult)\n\t\t{\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_IMAGEWIDTH, w);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_IMAGELENGTH, h);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_COMPRESSION, compression);\n\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_BITSPERSAMPLE, bps);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_SAMPLESPERPIXEL, spp);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n\t\t\tif (spp == 1)\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Only support CFA types BGGR, GRBG, GBRG, RGGB\n\t\t\t\t//\n\t\t\t\tif (cfa && cfatype >= static_cast<uint32_t>(CFATYPE_BGGR) && cfatype <= static_cast<uint32_t>(CFATYPE_RGGB))\n\t\t\t\t{\n\t\t\t\t\tcfaDimPat = {};\n\t\t\t\t\t// TIFFSetField(m_tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CFA);  // Don't use this - breaks too many things\n\t\t\t\t\tcfaDimPat.dim[0] = 2; cfaDimPat.dim[1] = 2;\n\t\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_CFAREPEATPATTERNDIM, cfaDimPat.dim);\n\t\t\t\t\t//\n\t\t\t\t\t// Note that when writing the CFA pattern, need to specify how many\n\t\t\t\t\t// octets are to be written.\n\t\t\t\t\t//\n\t\t\t\t\tswitch (cfatype)\n\t\t\t\t\t{\n\t\t\t\t\tcase CFATYPE_BGGR:\n\t\t\t\t\t\tmemcpy(cfaDimPat.cfa.cfa4, TIFF_CFAPattern_BGGR.data(), sizeof(cfaDimPat.cfa.cfa4));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CFATYPE_GRBG:\n\t\t\t\t\t\tmemcpy(cfaDimPat.cfa.cfa4, TIFF_CFAPattern_GRBG.data(), sizeof(cfaDimPat.cfa.cfa4));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CFATYPE_GBRG:\n\t\t\t\t\t\tmemcpy(cfaDimPat.cfa.cfa4, TIFF_CFAPattern_GBRG.data(), sizeof(cfaDimPat.cfa.cfa4));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CFATYPE_RGGB:\n\t\t\t\t\t\tmemcpy(cfaDimPat.cfa.cfa4, TIFF_CFAPattern_RGGB.data(), sizeof(cfaDimPat.cfa.cfa4));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_CFAPATTERN, 4, cfaDimPat.cfa.cfa4);\n\n\t\t\t\t}\n\t\t\t\tphoto = PHOTOMETRIC_MINISBLACK;\n\t\t\t}\n\t\t\t\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_PHOTOMETRIC, photo);\n\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_SAMPLEFORMAT, sampleformat);\n\n\t\t\t//\n\t\t\t// Following line commented out as enabling this broke Photoshop (16 August 2020)\n\t\t\t//\n\t\t\t//if (IsFloat()) TIFFSetField(m_tiff, TIFFTAG_PREDICTOR, PREDICTOR_FLOATINGPOINT);\n\n\t\t\tif (samplemax != samplemin)\n\t\t\t{\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_SMINSAMPLEVALUE, samplemin);\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_SMAXSAMPLEVALUE, samplemax);\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Set Software name in the same way we do elsewhere.\n\t\t\t//\n\t\t\tconst QString strSoftware{ QString(\"DeepSkyStacker %1\").arg(VERSION_DEEPSKYSTACKER) };\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_SOFTWARE, strSoftware.toLatin1().constData());\n\n\t\t\tif (!m_strDescription.isEmpty())\n\t\t\t{\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_IMAGEDESCRIPTION, m_strDescription.toStdString().c_str());\n\t\t\t}\n\n\t\t\tif (m_DateTime.isValid())\n\t\t\t{\n\t\t\t\t// Set the DATETIME TIFF tag\n\t\t\t\tQString strDateTime = m_DateTime.toString(\"yyyy:MM:dd hh:mm:ss\");\n\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DATETIME, strDateTime.toStdString().c_str());\n\t\t\t}\n\n\t\t\t/* It is good to set resolutions too (but it is not nesessary) */\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_XRESOLUTION, 100.0f);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_YRESOLUTION, 100.0f);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\n\t\t\tif (cfa)\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DSS_CFA, cfa ? 1 : 0);\n\t\t\tif (cfa && cfatype)\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DSS_CFATYPE, cfatype);\n\n\t\t\tif (master)\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DSS_MASTER, master);\n\n\t\t\tif (isospeed)\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DSS_ISO, isospeed);\n\n\t\t\tif (gain >= 0)\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DSS_GAIN, gain);\n\n\t\t\tif (exposureTime)\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DSS_TOTALEXPOSURE, exposureTime);\n\n\t\t\tif (aperture)\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DSS_APERTURE, aperture);\n\n\t\t\tif (nrframes)\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DSS_NRFRAMES, nrframes);\n\n\t\t\tconst tmsize_t scanLineSize = TIFFScanlineSize(m_tiff);\n\t\t\tZTRACE_RUNTIME(\"TIFF Scan Line Size %zu\", scanLineSize);\n\n\t\t\t//\n\t\t\t// Work out how many scanlines fit into the default strip\n\t\t\t//\n\t\t\tconst unsigned int rowsPerStrip = STRIP_SIZE_DEFAULT / scanLineSize;\n\n\t\t\tZTRACE_RUNTIME(\"Seting TIFFTAG_ROWSPERSTRIP to: %u\", rowsPerStrip);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n\t\t\tint numStrips = h / rowsPerStrip;\n\t\t\t//\n\t\t\t// If it wasn't an exact division (IOW there's a remainder), add one\n\t\t\t// for the final (short) strip.\n\t\t\t//\n\t\t\tif (0 != (h % rowsPerStrip))\n\t\t\t\t++numStrips;\n\n\t\t\t//\n\t\t\t// Pre-fill the StripOffsets and StripByteCounts tags with values of zero.\n\t\t\t// \n\t\t\t// The values will be updated when the data is actually written, but the size\n\t\t\t// of the base IFD won't change which in turn means it can be rewritten in \n\t\t\t// the same location as the file is closed.\n\t\t\t// \n\t\t\t// Turn off the TIFF error handle while we do this, otherwise an error message\n\t\t\t// \n\t\t\t//\t\tZIPEncode: Encoder error: buffer error.\n\t\t\t//\n\t\t\t// is issued for each empty strip.\n\t\t\t//\n\t\t\tTIFFErrorHandler    oldHandler = TIFFSetErrorHandler(nullptr);\n\t\t\tTIFFErrorHandlerExt oldHandlerExt = TIFFSetErrorHandlerExt(nullptr);\n\t\t\tZTRACE_RUNTIME(\"Writing %d empty encoded strips\", numStrips);\n\t\t\tfor (int strip = 0; strip < numStrips; ++strip)\n\t\t\t{\n\t\t\t\tTIFFWriteEncodedStrip(m_tiff, strip, nullptr, 0);\n\t\t\t}\n\t\t\tTIFFSetErrorHandler(oldHandler);\n\t\t\tTIFFSetErrorHandlerExt(oldHandlerExt);\n\n\n\t\t\t//***************************************************************************\n\t\t\t// \n\t\t\t// Now write the EXIF IFD\n\t\t\t// \n\t\t\t// **************************************************************************\n\t\t\t\n\t\t\t//\n\t\t\t// Set a dummy EXIF tag in the original tiff-structure in order to reserve\n\t\t\t// space for final dir_offset value, which is properly written at the end.\n\t\t\t// \n\t\t\t// Initially use a value of 0 for dir_offset_EXIF\n\t\t\t//\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_EXIFIFD, dir_offset_EXIF);\n\n\t\t\t//\n\t\t\t// Save current tiff-directory to file before directory is changed.\n\t\t\t// Otherwise it will be lost! The tif-structure is overwritten/ freshly\n\t\t\t// initialized by any \"CreateDirectory\"\n\t\t\t//\n\t\t\tTIFFWriteDirectory(m_tiff);\n\t\t\t//\n\t\t\t// Get current TIFF Directory so we can return to it\n\t\t\t//\n\t\t\tconst auto currentIFD = TIFFCurrentDirectory(m_tiff);\n\t\t\tTIFFCreateEXIFDirectory(m_tiff);\n\t\t\tTIFFSetField(m_tiff, EXIFTAG_EXIFVERSION, exifVersion);\n\n\t\t\t//\n\t\t\t// Now we can write EXIF tags we want to ...\n\t\t\t//\n\t\t\tif (0.0 != exposureTime)\n\t\t\t{\n\t\t\t\tTIFFSetField(m_tiff, EXIFTAG_EXPOSURETIME, exposureTime);\n\t\t\t}\n\t\t\tif (0.0 != aperture)\n\t\t\t{\n\t\t\t\tTIFFSetField(m_tiff, EXIFTAG_FNUMBER, aperture);\n\t\t\t}\n\t\t\tif (0 != isospeed)\n\t\t\t{\n\t\t\t\t// EXIFTAG_ISOSPEEDRATINGS is array of uint16 according to the EXIF spec\n\t\t\t\tconstexpr uint16_t count = 1U;\n\t\t\t\tconst uint16_t iso_setting = static_cast<uint16_t>(isospeed);\n\t\t\t\tTIFFSetField(m_tiff, EXIFTAG_ISOSPEEDRATINGS, count, &iso_setting);\n\t\t\t}\n\t\t\t\n\t\t\t//\n\t\t\t// Now write EXIFTAG_CFAPATTERN which is basically what we put into cfaDimPat \n\t\t\t// when the other (non-EXIF) CFA related tags were written.\n\t\t\t//\n\t\t\tif (cfa)\n\t\t\t{\n\t\t\t\tconstexpr uint16_t count = sizeof(cfaDimPat.dim) + sizeof(cfaDimPat.cfa.cfa4);\n\t\t\t\tTIFFSetField(m_tiff, EXIFTAG_CFAPATTERN, count, cfaDimPat);\n\t\t\t}\n\t\t\t\n\t\t\t//\n\t\t\t// Now that all the EXIF tags are written, need to write the EXIF\n\t\t\t// custom directory into the file...\n\t\t\t// \n\t\t\t// WriteCustomDirectory returns the actual offset of the EXIF directory.\n\t\t\t//\n\t\t\tTIFFWriteCustomDirectory(m_tiff, &dir_offset_EXIF);\n\n\t\t\t// Go back to the first (main) directory, and set correct value of the\n\t\t\t// EXIFIFD pointer. Note that the directory is reloaded from the file!\n\t\t\t//\n\t\t\tTIFFSetDirectory(m_tiff, currentIFD);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_EXIFIFD, dir_offset_EXIF);\n\t\t\tTIFFCheckpointDirectory(m_tiff);\n\n\t\t\t//\n\t\t\t// The ZIP compression level must be set after the ZIP state has been re-initialised by TIFFSetDirectory().\n\t\t\t//\n\t\t\tif (COMPRESSION_DEFLATE == compression) TIFFSetField(m_tiff, TIFFTAG_ZIPQUALITY, Z_BEST_SPEED);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTIFFClose(m_tiff);\n\t\t\tm_tiff = nullptr;\n\t\t}\n\t}\n\n\treturn bResult;\n}",
    "bool CTIFFWriter::Close()\n{\n\tZFUNCTRACE_RUNTIME();\n\tbool\t\t\tbResult = true;\n\n\tif (m_tiff != nullptr)\n\t{\n\t\tbResult = OnClose();\n\t\t//\n\t\t// Write the updated base IFD to disk.  This is only safe to do if the directory SIZE\n\t\t// hasn't changed at all since the end of the Open() member function.\n\t\t// \n\t\t// This should be be case if the number of entries in the StripOffsets and StripByteCounts\n\t\t// tags haven't changed.\n\t\t//\n\t\tTIFFWriteDirectory(m_tiff);\n\t\tif (bResult)\n\t\t{\n\t\t\tTIFFClose(m_tiff);\n\t\t\tm_tiff = nullptr;\n\t\t}\n\t}\n\n\treturn bResult;\n}",
    "static BOOL \nSaveOneTIFF(FreeImageIO *io, FIBITMAP *dib, fi_handle handle, int page, int flags, void *data, unsigned ifd, unsigned ifdCount) {\n\tif (!dib || !handle || !data) {\n\t\treturn FALSE;\n\t} \n\t\n\ttry { \n\t\tfi_TIFFIO *fio = (fi_TIFFIO*)data;\n\t\tTIFF *out = fio->tif;\n\n\t\tconst FREE_IMAGE_TYPE image_type = FreeImage_GetImageType(dib);\n\n\t\tconst uint32 width = FreeImage_GetWidth(dib);\n\t\tconst uint32 height = FreeImage_GetHeight(dib);\n\t\tconst uint16 bitsperpixel = (uint16)FreeImage_GetBPP(dib);\n\n\t\tconst FIICCPROFILE* iccProfile = FreeImage_GetICCProfile(dib);\n\t\t\n\t\t// setup out-variables based on dib and flag options\n\t\t\n\t\tuint16 bitspersample;\n\t\tuint16 samplesperpixel;\n\t\tuint16 photometric;\n\n\t\tif(image_type == FIT_BITMAP) {\n\t\t\t// standard image: 1-, 4-, 8-, 16-, 24-, 32-bit\n\n\t\t\tsamplesperpixel = ((bitsperpixel == 24) ? 3 : ((bitsperpixel == 32) ? 4 : 1));\n\t\t\tbitspersample = bitsperpixel / samplesperpixel;\n\t\t\tphotometric\t= GetPhotometric(dib);\n\n\t\t\tif((bitsperpixel == 8) && FreeImage_IsTransparent(dib)) {\n\t\t\t\t// 8-bit transparent picture : convert later to 8-bit + 8-bit alpha\n\t\t\t\tsamplesperpixel = 2;\n\t\t\t\tbitspersample = 8;\n\t\t\t}\n\t\t\telse if(bitsperpixel == 32) {\n\t\t\t\t// 32-bit images : check for CMYK or alpha transparency\n\n\t\t\t\tif((((iccProfile->flags & FIICC_COLOR_IS_CMYK) == FIICC_COLOR_IS_CMYK) || ((flags & TIFF_CMYK) == TIFF_CMYK))) {\n\t\t\t\t\t// CMYK support\n\t\t\t\t\tphotometric = PHOTOMETRIC_SEPARATED;\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_INKSET, INKSET_CMYK);\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_NUMBEROFINKS, 4);\n\t\t\t\t}\n\t\t\t\telse if(photometric == PHOTOMETRIC_RGB) {\n\t\t\t\t\t// transparency mask support\n\t\t\t\t\tuint16 sampleinfo[1]; \n\t\t\t\t\t// unassociated alpha data is transparency information\n\t\t\t\t\tsampleinfo[0] = EXTRASAMPLE_UNASSALPHA;\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_EXTRASAMPLES, 1, sampleinfo);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if(image_type == FIT_RGB16) {\n\t\t\t// 48-bit RGB\n\n\t\t\tsamplesperpixel = 3;\n\t\t\tbitspersample = bitsperpixel / samplesperpixel;\n\t\t\tphotometric\t= PHOTOMETRIC_RGB;\n\t\t} else if(image_type == FIT_RGBA16) {\n\t\t\t// 64-bit RGBA\n\n\t\t\tsamplesperpixel = 4;\n\t\t\tbitspersample = bitsperpixel / samplesperpixel;\n\t\t\tif((((iccProfile->flags & FIICC_COLOR_IS_CMYK) == FIICC_COLOR_IS_CMYK) || ((flags & TIFF_CMYK) == TIFF_CMYK))) {\n\t\t\t\t// CMYK support\n\t\t\t\tphotometric = PHOTOMETRIC_SEPARATED;\n\t\t\t\tTIFFSetField(out, TIFFTAG_INKSET, INKSET_CMYK);\n\t\t\t\tTIFFSetField(out, TIFFTAG_NUMBEROFINKS, 4);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tphotometric\t= PHOTOMETRIC_RGB;\n\t\t\t\t// transparency mask support\n\t\t\t\tuint16 sampleinfo[1]; \n\t\t\t\t// unassociated alpha data is transparency information\n\t\t\t\tsampleinfo[0] = EXTRASAMPLE_UNASSALPHA;\n\t\t\t\tTIFFSetField(out, TIFFTAG_EXTRASAMPLES, 1, sampleinfo);\n\t\t\t}\n\t\t} else if(image_type == FIT_RGBF) {\n\t\t\t// 96-bit RGBF => store with a LogLuv encoding ?\n\n\t\t\tsamplesperpixel = 3;\n\t\t\tbitspersample = bitsperpixel / samplesperpixel;\n\t\t\t// the library converts to and from floating-point XYZ CIE values\n\t\t\tif((flags & TIFF_LOGLUV) == TIFF_LOGLUV) {\n\t\t\t\tphotometric\t= PHOTOMETRIC_LOGLUV;\n\t\t\t\tTIFFSetField(out, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n\t\t\t\t// TIFFSetField(out, TIFFTAG_STONITS, 1.0);   // assume unknown \n\t\t\t}\n\t\t\telse {\n\t\t\t\t// store with default compression (LZW) or with input compression flag\n\t\t\t\tphotometric\t= PHOTOMETRIC_RGB;\n\t\t\t}\n\t\t\t\n\t\t} else if (image_type == FIT_RGBAF) {\n\t\t\t// 128-bit RGBAF => store with default compression (LZW) or with input compression flag\n\t\t\t\n\t\t\tsamplesperpixel = 4;\n\t\t\tbitspersample = bitsperpixel / samplesperpixel;\n\t\t\tphotometric\t= PHOTOMETRIC_RGB;\n\t\t} else {\n\t\t\t// special image type (int, long, double, ...)\n\t\t\t\n\t\t\tsamplesperpixel = 1;\n\t\t\tbitspersample = bitsperpixel;\n\t\t\tphotometric\t= PHOTOMETRIC_MINISBLACK;\n\t\t}\n\n\t\t// set image data type\n\n\t\tWriteImageType(out, image_type);\n\t\t\n\t\t// write possible ICC profile\n\n\t\tif (iccProfile->size && iccProfile->data) {\n\t\t\tTIFFSetField(out, TIFFTAG_ICCPROFILE, iccProfile->size, iccProfile->data);\n\t\t}\n\n\t\t// handle standard width/height/bpp stuff\n\n\t\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n\t\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, height);\n\t\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n\t\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bitspersample);\n\t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\n\t\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\t// single image plane \n\t\tTIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\tTIFFSetField(out, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(out, (uint32) -1)); \n\n\t\t// handle metrics\n\n\t\tWriteResolution(out, dib);\n\n\t\t// multi-paging\n\n\t\tif (page >= 0) {\n\t\t\tchar page_number[20];\n\t\t\tsprintf(page_number, \"Page %d\", page);\n\n\t\t\tTIFFSetField(out, TIFFTAG_SUBFILETYPE, (uint32)FILETYPE_PAGE);\n\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, (uint16)page, (uint16)0);\n\t\t\tTIFFSetField(out, TIFFTAG_PAGENAME, page_number);\n\n\t\t} else {\n\t\t\t// is it a thumbnail ? \n\t\t\tTIFFSetField(out, TIFFTAG_SUBFILETYPE, (ifd == 0) ? (uint32)0 : (uint32)FILETYPE_REDUCEDIMAGE);\n\t\t}\n\n\t\t// palettes (image colormaps are automatically scaled to 16-bits)\n\n\t\tif (photometric == PHOTOMETRIC_PALETTE) {\n\t\t\tuint16 *r, *g, *b;\n\t\t\tuint16 nColors = (uint16)FreeImage_GetColorsUsed(dib);\n\t\t\tRGBQUAD *pal = FreeImage_GetPalette(dib);\n\n\t\t\tr = (uint16 *) _TIFFmalloc(sizeof(uint16) * 3 * nColors);\n\t\t\tif(r == NULL) {\n\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t}\n\t\t\tg = r + nColors;\n\t\t\tb = g + nColors;\n\n\t\t\tfor (int i = nColors - 1; i >= 0; i--) {\n\t\t\t\tr[i] = SCALE((uint16)pal[i].rgbRed);\n\t\t\t\tg[i] = SCALE((uint16)pal[i].rgbGreen);\n\t\t\t\tb[i] = SCALE((uint16)pal[i].rgbBlue);\n\t\t\t}\n\n\t\t\tTIFFSetField(out, TIFFTAG_COLORMAP, r, g, b);\n\n\t\t\t_TIFFfree(r);\n\t\t}\n\n\t\t// compression tag\n\n\t\tWriteCompression(out, bitspersample, samplesperpixel, photometric, flags);\n\n\t\t// metadata\n\n\t\tWriteMetadata(out, dib);\n\n\t\t// thumbnail tag\n\n\t\tif((ifd == 0) && (ifdCount > 1)) {\n\t\t\tuint16 nsubifd = 1;\n\t\t\tuint64 subifd[1];\n\t\t\tsubifd[0] = 0;\n\t\t\tTIFFSetField(out, TIFFTAG_SUBIFD, nsubifd, subifd);\n\t\t}\n\n\t\t// read the DIB lines from bottom to top\n\t\t// and save them in the TIF\n\t\t// -------------------------------------\n\t\t\n\t\tconst uint32 pitch = FreeImage_GetPitch(dib);\n\n\t\tif(image_type == FIT_BITMAP) {\n\t\t\t// standard bitmap type\n\t\t\n\t\t\tswitch(bitsperpixel) {\n\t\t\t\tcase 1 :\n\t\t\t\tcase 4 :\n\t\t\t\tcase 8 :\n\t\t\t\t{\n\t\t\t\t\tif((bitsperpixel == 8) && FreeImage_IsTransparent(dib)) {\n\t\t\t\t\t\t// 8-bit transparent picture : convert to 8-bit + 8-bit alpha\n\n\t\t\t\t\t\t// get the transparency table\n\t\t\t\t\t\tBYTE *trns = FreeImage_GetTransparencyTable(dib);\n\n\t\t\t\t\t\tBYTE *buffer = (BYTE *)malloc(2 * width * sizeof(BYTE));\n\t\t\t\t\t\tif(buffer == NULL) {\n\t\t\t\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int y = height - 1; y >= 0; y--) {\n\t\t\t\t\t\t\tBYTE *bits = FreeImage_GetScanLine(dib, y);\n\n\t\t\t\t\t\t\tBYTE *p = bits, *b = buffer;\n\n\t\t\t\t\t\t\tfor(uint32 x = 0; x < width; x++) {\n\t\t\t\t\t\t\t\t// copy the 8-bit layer\n\t\t\t\t\t\t\t\tb[0] = *p;\n\t\t\t\t\t\t\t\t// convert the trns table to a 8-bit alpha layer\n\t\t\t\t\t\t\t\tb[1] = trns[ b[0] ];\n\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\tb += samplesperpixel;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// write the scanline to disc\n\n\t\t\t\t\t\t\tTIFFWriteScanline(out, buffer, height - y - 1, 0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfree(buffer);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// other cases\n\t\t\t\t\t\tBYTE *buffer = (BYTE *)malloc(pitch * sizeof(BYTE));\n\t\t\t\t\t\tif(buffer == NULL) {\n\t\t\t\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (uint32 y = 0; y < height; y++) {\n\t\t\t\t\t\t\t// get a copy of the scanline\n\t\t\t\t\t\t\tmemcpy(buffer, FreeImage_GetScanLine(dib, height - y - 1), pitch);\n\t\t\t\t\t\t\t// write the scanline to disc\n\t\t\t\t\t\t\tTIFFWriteScanline(out, buffer, y, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(buffer);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\t\t\t\n\n\t\t\t\tcase 24:\n\t\t\t\tcase 32:\n\t\t\t\t{\n\t\t\t\t\tBYTE *buffer = (BYTE *)malloc(pitch * sizeof(BYTE));\n\t\t\t\t\tif(buffer == NULL) {\n\t\t\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (uint32 y = 0; y < height; y++) {\n\t\t\t\t\t\t// get a copy of the scanline\n\n\t\t\t\t\t\tmemcpy(buffer, FreeImage_GetScanLine(dib, height - y - 1), pitch);\n\n#if FREEIMAGE_COLORORDER == FREEIMAGE_COLORORDER_BGR\n\t\t\t\t\t\tif (photometric != PHOTOMETRIC_SEPARATED) {\n\t\t\t\t\t\t\t// TIFFs store color data RGB(A) instead of BGR(A)\n\t\t\n\t\t\t\t\t\t\tBYTE *pBuf = buffer;\n\t\t\n\t\t\t\t\t\t\tfor (uint32 x = 0; x < width; x++) {\n\t\t\t\t\t\t\t\tINPLACESWAP(pBuf[0], pBuf[2]);\n\t\t\t\t\t\t\t\tpBuf += samplesperpixel;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\t// write the scanline to disc\n\n\t\t\t\t\t\tTIFFWriteScanline(out, buffer, y, 0);\n\t\t\t\t\t}\n\n\t\t\t\t\tfree(buffer);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}//< switch (bitsperpixel)\n\n\t\t} else if(image_type == FIT_RGBF && (flags & TIFF_LOGLUV) == TIFF_LOGLUV) {\n\t\t\t// RGBF image => store as XYZ using a LogLuv encoding\n\n\t\t\tBYTE *buffer = (BYTE *)malloc(pitch * sizeof(BYTE));\n\t\t\tif(buffer == NULL) {\n\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t}\n\n\t\t\tfor (uint32 y = 0; y < height; y++) {\n\t\t\t\t// get a copy of the scanline and convert from RGB to XYZ\n\t\t\t\ttiff_ConvertLineRGBToXYZ(buffer, FreeImage_GetScanLine(dib, height - y - 1), width);\n\t\t\t\t// write the scanline to disc\n\t\t\t\tTIFFWriteScanline(out, buffer, y, 0);\n\t\t\t}\n\t\t\tfree(buffer);\n\t\t} else {\n\t\t\t// just dump the dib (tiff supports all dib types)\n\t\t\t\n\t\t\tBYTE *buffer = (BYTE *)malloc(pitch * sizeof(BYTE));\n\t\t\tif(buffer == NULL) {\n\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t}\n\t\t\t\n\t\t\tfor (uint32 y = 0; y < height; y++) {\n\t\t\t\t// get a copy of the scanline\n\t\t\t\tmemcpy(buffer, FreeImage_GetScanLine(dib, height - y - 1), pitch);\n\t\t\t\t// write the scanline to disc\n\t\t\t\tTIFFWriteScanline(out, buffer, y, 0);\n\t\t\t}\n\t\t\tfree(buffer);\n\t\t}\n\n\t\t// write out the directory tag if we wrote a page other than -1 or if we have a thumbnail to write later\n\n\t\tif( (page >= 0) || ((ifd == 0) && (ifdCount > 1)) ) {\n\t\t\tTIFFWriteDirectory(out);\n\t\t\t// else: TIFFClose will WriteDirectory\n\t\t}\n\n\t\treturn TRUE;\n\t\t\n\t} catch(const char *text) {\n\t\tFreeImage_OutputMessageProc(s_format_id, text);\n\t\treturn FALSE;\n\t} \n}",
    "absl::Status TiffWriter::Context::WriteImage(\n    const ImageInfo& info, tensorstore::span<const unsigned char> source) {\n  image_number++;\n  if (image_number > 0) {\n    return absl::UnknownError(\n        \"Failed to write TIFF file; multi-page write support incomplete\");\n  }\n\n  TIFFSetField(tiff_, TIFFTAG_IMAGEWIDTH, info.width);\n  TIFFSetField(tiff_, TIFFTAG_IMAGELENGTH, info.height);\n  TIFFSetField(tiff_, TIFFTAG_BITSPERSAMPLE, info.dtype.size() * 8);\n  TIFFSetField(tiff_, TIFFTAG_SAMPLESPERPIXEL, info.num_components);\n\n  if (info.num_components == 3 || info.num_components == 4) {\n    TIFFSetField(tiff_, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  } else {\n    // Grayscale, black is 0\n    TIFFSetField(tiff_, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n  }\n\n  // TODO: extra samples?\n  // TODO: Compression config.\n  // TODO: Orientation\n  TIFFSetField(tiff_, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n  TIFFSetField(tiff_, TIFFTAG_ROWSPERSTRIP, 1);\n  TIFFSetField(tiff_, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(tiff_, TIFFTAG_SOFTWARE, \"tensorstore\");\n\n  // This assumes that no conversion is required.\n  ImageView view = MakeWriteImageView(info, source);\n  for (int row = 0; row < info.height; ++row) {\n    if (!TIFFWriteScanline(tiff_, view.data_row(row).data(), row, 0)) {\n      error_.Update(absl::InvalidArgumentError(\"Failed to write scanline\"));\n      return ExtractErrors();\n    }\n  }\n\n  if (TIFFWriteDirectory(tiff_) == 0) {\n    error_.Update(absl::InvalidArgumentError(\"Failed to write directory\"));\n  }\n  return ExtractErrors();\n}",
    "void write3D(\n    std::string const& path, float* texture, int width, int height, int depth, int components) {\n  auto* tiff = TIFFOpen(path.c_str(), \"w\");\n\n  for (int z = 0; z < depth; ++z) {\n    TIFFSetField(tiff, TIFFTAG_PAGENUMBER, z, z);\n    TIFFSetField(tiff, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n    TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, components);\n    TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 32);\n    TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n    for (int y = 0; y < height; ++y) {\n      TIFFWriteScanline(\n          tiff, texture + z * width * height * components + y * width * components, height - y - 1);\n    }\n    TIFFWriteDirectory(tiff);\n  }\n  TIFFClose(tiff);\n}",
    "void Preprocessor::save(std::string const& directory) {\n  std::cout << \"Saving precomputed atmosphere to disk...\" << std::endl;\n\n  // For debugging purposes, we print the maximum ray deviation in degrees.\n  std::vector<float> pixels(\n      mParams.mTransmittanceTextureWidth.get() * mParams.mTransmittanceTextureHeight.get() * 3);\n  glBindTexture(GL_TEXTURE_2D, mThetaDeviationTexture);\n  glGetTexImage(GL_TEXTURE_2D, 0, GL_RGB, GL_FLOAT, pixels.data());\n  glBindTexture(GL_TEXTURE_2D, 0);\n\n  float maxThetaDeviation = 0.F;\n  for (int x = 0; x < mParams.mTransmittanceTextureWidth.get(); ++x) {\n    for (int y = 0; y < mParams.mTransmittanceTextureHeight.get(); ++y) {\n      int i = 3 * (y * mParams.mTransmittanceTextureWidth.get() + x);\n\n      float thetaDeviation = pixels[i];\n      float contactRadius  = pixels[i + 1];\n\n      if (contactRadius > 0.F) {\n        maxThetaDeviation = std::max(maxThetaDeviation, thetaDeviation);\n      }\n    }\n  }\n\n  std::cout << \"Maximum ray deviation: \" << maxThetaDeviation * 180.F / glm::pi<float>()\n            << \" degrees.\" << std::endl;\n\n  auto write2D = [](std::string const& path, GLuint texture, int width, int height) {\n    std::vector<float> data(width * height * 3);\n    glBindTexture(GL_TEXTURE_2D, texture);\n    glGetTexImage(GL_TEXTURE_2D, 0, GL_RGB, GL_FLOAT, data.data());\n    glBindTexture(GL_TEXTURE_2D, 0);\n\n    auto* tiff = TIFFOpen(path.c_str(), \"w\");\n    TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 32);\n    TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n    for (int y = 0; y < height; ++y) {\n      TIFFWriteScanline(tiff, data.data() + y * width * 3, y);\n    }\n    TIFFClose(tiff);\n  };\n\n  auto write3D = [](std::string const& path, GLuint texture, int width, int height, int depth) {\n    std::vector<float> data(width * height * depth * 3);\n    glBindTexture(GL_TEXTURE_3D, texture);\n    glGetTexImage(GL_TEXTURE_3D, 0, GL_RGB, GL_FLOAT, data.data());\n    glBindTexture(GL_TEXTURE_3D, 0);\n\n    auto* tiff = TIFFOpen(path.c_str(), \"w\");\n\n    for (int z = 0; z < depth; ++z) {\n      TIFFSetField(tiff, TIFFTAG_PAGENUMBER, z, z);\n      TIFFSetField(tiff, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n      TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n      TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height);\n      TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 3);\n      TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 32);\n      TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n      TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n      TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n      TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n      for (int y = 0; y < height; ++y) {\n        TIFFWriteScanline(tiff, data.data() + z * width * height * 3 + y * width * 3, y);\n      }\n      TIFFWriteDirectory(tiff);\n    }\n    TIFFClose(tiff);\n  };\n\n  int numAngles = static_cast<int>(mParams.mMolecules.mPhase.size());\n  write2D(directory + \"/phase.tif\", mPhaseTexture, numAngles, 2);\n  write2D(directory + \"/transmittance.tif\", mTransmittanceTexture,\n      mParams.mTransmittanceTextureWidth.get(), mParams.mTransmittanceTextureHeight.get());\n  write2D(directory + \"/indirect_illuminance.tif\", mIrradianceTexture,\n      mParams.mIrradianceTextureWidth.get(), mParams.mIrradianceTextureHeight.get());\n  write3D(directory + \"/multiple_scattering.tif\", mMultipleScatteringTexture,\n      mScatteringTextureWidth, mScatteringTextureHeight, mScatteringTextureDepth);\n  write3D(directory + \"/single_aerosols_scattering.tif\", mSingleAerosolsScatteringTexture,\n      mScatteringTextureWidth, mScatteringTextureHeight, mScatteringTextureDepth);\n\n  if (mParams.mRefraction.get()) {\n    write2D(directory + \"/theta_deviation.tif\", mThetaDeviationTexture,\n        mParams.mTransmittanceTextureWidth.get(), mParams.mTransmittanceTextureHeight.get());\n  }\n\n  std::ofstream  out(directory + \"/metadata.json\");\n  nlohmann::json data = mMetadata;\n  out << std::setw(2) << data;\n\n  std::cout << \"Precomputed atmosphere saved to disk.\" << std::endl;\n}",
    "ImagePyramid::ImagePyramid(int width, int height, int channels, int patchWidth, int patchHeight, ImageCompression compression, int compressionQuality, DataType dataType) {\n    if(channels <= 0 || channels > 4)\n        throw Exception(\"Nr of channels must be between 1 and 4\");\n\n    // Determine how many levels\n    int currentLevel = 0;\n    int currentWidth = width;\n    int currentHeight = height;\n    m_channels = channels;\n    m_tempFile = true;\n\n    do {\n        std::string randomString = generateRandomString(32);\n#ifdef WIN32\n        m_tiffPath = \"C:/windows/temp/fast_image_pyramid_\" + randomString + \".tiff\";\n#else\n        m_tiffPath = \"/tmp/fast_image_pyramid_\" + randomString + \".tiff\";\n#endif\n    } while(fileExists(m_tiffPath));\n\n    TIFFSetErrorHandler([](const char* module, const char* fmt, va_list ap) {\n        auto str = make_uninitialized_unique<char[]>(512);\n        sprintf(str.get(), fmt, ap);\n        std::string str2 = str.get();\n        if(strcmp(module, \"TIFFAppendToStrip\") == 0 && str2.substr(0, 23) == \"Write error at scanline\") // Suppress error when writing 0 byte patches\n            return;\n        Reporter::warning() << \"TIFF error: \" << module << \": \" << str.get() << Reporter::end();\n    });\n    TIFFSetWarningHandler([](const char* module, const char* fmt, va_list ap) {\n        auto str = make_uninitialized_unique<char[]>(512);\n        sprintf(str.get(), fmt, ap);\n        Reporter::warning() << \"TIFF warning: \" << module << \": \" << str.get() << Reporter::end();\n    });\n    m_tiffHandle = TIFFOpen(m_tiffPath.c_str(), \"w8\"); // 8 == Bigtiff (64 bit)\n    auto tiff = m_tiffHandle;\n    m_counter += 1;\n\n    uint photometric;\n    uint bitsPerSample = getSizeOfDataType(dataType, 1) * 8;\n    m_dataType = dataType;\n    uint samplesPerPixel;\n    if(channels == 1) {\n        photometric = PHOTOMETRIC_MINISBLACK; // Photometric mask causes crash..\n        samplesPerPixel = 1;\n        if(compression == ImageCompression::UNSPECIFIED)\n            compression = ImageCompression::LZW;\n    } else {\n        if(compression == ImageCompression::UNSPECIFIED)\n            compression = ImageCompression::JPEG;\n        if(compression == ImageCompression::JPEG) {\n            photometric = PHOTOMETRIC_YCBCR; // JPEG is stored using YCBCR internally.\n            // If this is not set to YCBCR for JPEG, OpenSlide will not display FAST created WSI tiffs correctly.\n        } else {\n            photometric = PHOTOMETRIC_RGB;\n        }\n        samplesPerPixel = 3; // RGBA image pyramid is converted to RGB with getPatchAsImage\n    }\n    m_compressionFormat = compression;\n    m_compressionQuality = compressionQuality;\n\n    while(true) {\n\t\tcurrentWidth = width / std::pow(2, currentLevel);\n\t\tcurrentHeight = height / std::pow(2, currentLevel);\n\n        if(currentLevel > 0 && (currentWidth < 4096 && currentHeight < 4096)) // IMPORTANT: This should be the same as in PatchStitcher.\n            break;\n\n        reportInfo() << \"Processing level \" << currentLevel << reportEnd();\n        std::size_t bytes = (std::size_t)currentWidth * currentHeight * m_channels * sizeof(char);\n\n        // Get total size of image\n        float sizeInMB = (float)bytes / (1024 * 1024);\n        reportInfo() << \"WSI level size: \" << currentWidth << \", \" << currentHeight << \", \" << m_channels << reportEnd();\n        reportInfo() << \"WSI level size: \" << sizeInMB << \" MBs\" << reportEnd();\n\n\t\tImagePyramidLevel levelData;\n\t\tlevelData.width = currentWidth;\n\t\tlevelData.height = currentHeight;\n\t\tlevelData.tileWidth = patchWidth;\n        levelData.tileHeight = patchHeight;\n        levelData.tilesX = std::ceil((float)levelData.width / levelData.tileWidth);\n        levelData.tilesY = std::ceil((float)levelData.height / levelData.tileHeight);\n\n        // Write base tags\n        TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric);\n        TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, bitsPerSample);\n        TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n        TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, samplesPerPixel);\n        TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n        if(currentLevel > 0) {\n            // All levels except highest res level should have this tag?\n            TIFFSetField(tiff, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE);\n        }\n        switch(compression) {\n            case ImageCompression::RAW:\n                TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n                break;\n            case ImageCompression::LZW:\n                TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n                break;\n            case ImageCompression::JPEG:\n                TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n                /*\n                TIFFSetField(tiff, TIFFTAG_JPEGQUALITY, m_compressionQuality); // Must be set after previous line // FIXME not working, only 75 gives ok results\n                TIFFSetField(tiff, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n                TIFFSetField(tiff, TIFFTAG_JPEGTABLESMODE, JPEGTABLESMODE_QUANT);\n                 */\n                break;\n            case ImageCompression::JPEGXL:\n                TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_JXL);\n                break;\n            case ImageCompression::JPEG2000:\n                // TODO NOT IMPLEMENTED\n                throw NotImplementedException();\n                TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_JP2000);\n                break;\n            case ImageCompression::NEURAL_NETWORK:\n                TIFFSetField(tiff, TIFFTAG_COMPRESSION, 34666); // TODO What should the value be?\n                break;\n        }\n\n        TIFFSetField(tiff, TIFFTAG_TILEWIDTH, levelData.tileWidth);\n        TIFFSetField(tiff, TIFFTAG_TILELENGTH, levelData.tileHeight);\n        TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, levelData.width);\n        TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, levelData.height);\n\n\t\tm_levels.push_back(levelData);\n\n        // TODO need to initialize somehow?\n        // We need to write the first tile for some reason... or we will get an error saying it is missing required\n        // TileOffsets\n        TIFFCheckpointDirectory(m_tiffHandle); // Need to check in the tile width and length tags, before writing a tile\n        if(m_compressionFormat == ImageCompression::JPEGXL || m_compressionFormat == ImageCompression::JPEG) {\n            // TODO Not needed?\n            //auto data = std::make_unique<uchar[]>(samplesPerPixel); // Is initialized to zeros\n            //auto tileID = TIFFComputeTile(tiff, 0, 0, 0, 0);\n            //TIFFSetWriteOffset(tiff, 0); // Set write offset to 0, so that we dont appen data\n            //TIFFWriteRawTile(tiff, tileID, data.get(), samplesPerPixel);\n        } else {\n            auto data = std::make_unique<uchar[]>(levelData.tileWidth*levelData.tileHeight*samplesPerPixel); // Is initialized to zeros\n            TIFFWriteTile(tiff, data.get(), 0, 0, 0, 0);\n        }\n        /*\n        // TODO Do we really need to inititalize all tiles? This takes time..\n        for(int y = 0; y < levelData.tilesY; ++y) {\n            for(int x = 0; x < levelData.tilesX; ++x) {\n                TIFFWriteTile(tiff, data.get(), x*levelData.tileWidth, y*levelData.tileHeight, 0, 0);\n            }\n\t\t}*/\n        // END\n\n        TIFFWriteDirectory(m_tiffHandle);\n\t\treportInfo() << \"Done creating level \" << currentLevel << reportEnd();\n\t\t++currentLevel;\n    }\n\n    mBoundingBox = DataBoundingBox(Vector3f(getFullWidth(), getFullHeight(), 0));\n    m_initialized = true;\n    m_pyramidFullyInitialized = false;\n\tm_counter += 1;\n}",
    "void TIFFImagePyramidExporter::execute() {\n    if(m_filename.empty())\n        throw Exception(\"Must set filename in TIFFImagePyramidExporter\");\n\n    auto input = getInputData<DataObject>();\n    auto imagePyramid = std::dynamic_pointer_cast<ImagePyramid>(input);\n    if(imagePyramid == nullptr) {\n        reportInfo() << \"Data given to TIFFImagePyramidExporter was an Image, not an ImagePyramid, converting ...\" << reportEnd();\n        auto image = std::dynamic_pointer_cast<Image>(input);\n        imagePyramid = ImagePyramid::create(image->getWidth(), image->getHeight(), image->getNrOfChannels(), 256, 256);\n        imagePyramid->setSpacing(image->getSpacing());\n        SceneGraph::setParentNode(imagePyramid, image);\n        auto access = imagePyramid->getAccess(ACCESS_READ_WRITE);\n        for(int y = 0; y < image->getHeight(); y += 256) {\n            for(int x = 0; x < image->getWidth(); x += 256) {\n                auto width = std::min(image->getWidth() - x - 1, 256);\n                auto height = std::min(image->getHeight() - y - 1, 256);\n                access->setPatch(0, x, y, image->crop(Vector2i(x, y), Vector2i(width, height)));\n            }\n        }\n    }\n\n    if(imagePyramid->usesTIFF()) {\n        // If image pyramid is using TIFF backend. It is already stored on disk, we just need to copy it..\n        if(fileExists(m_filename)) {\n            // If destination file already exists, we have to remove the existing file, or copy will not run.\n            QFile::remove(m_filename.c_str());\n        }\n        QFile::copy(imagePyramid->getTIFFPath().c_str(), m_filename.c_str());\n        return;\n    }\n    // If not, we need to do a patch based copy\n\n    const Vector3f spacing = imagePyramid->getSpacing();\n\n    ImageCompression compression = m_compression;\n    if(!m_compressionSet || m_compression == ImageCompression::UNSPECIFIED) {\n        // Default compression\n        if(imagePyramid->getNrOfChannels() == 1) {\n            compression = ImageCompression::LZW;\n        } else if(imagePyramid->getNrOfChannels() == 3 || imagePyramid->getNrOfChannels() == 4) {\n            compression = ImageCompression::JPEG;\n        } else {\n            throw Exception(\"Unexpected nr of channels in ImagePyramid: \" + std::to_string(imagePyramid->getNrOfChannels()));\n        }\n    }\n\n    uint photometric = PHOTOMETRIC_RGB;\n    uint bitsPerSample = 8;\n    uint samplesPerPixel = 3; // RGBA image pyramid is converted to RGB with getPatchAsImage\n    if(imagePyramid->getNrOfChannels() == 1) {\n        photometric = PHOTOMETRIC_MINISBLACK; // Photometric mask causes crash..\n        samplesPerPixel = 1;\n    }\n\n    auto tiff = TIFFOpen(m_filename.c_str(), \"w8\");\n    if(tiff == nullptr) {\n        throw Exception(\"Unable to open file \" + m_filename + \" in TIFFImagePyramidExporter\");\n    }\n\n    // For each level, we need to 1) write fields, 2) write tiles\n    // We have to go from highest res level first\n    for(int level = 0; level < imagePyramid->getNrOfLevels(); ++level) {\n        reportInfo() << \"Writing level \" << level << reportEnd();\n\n        // Write base tags\n        TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric);\n        TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, bitsPerSample);\n        TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n        TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, (uint16_t)samplesPerPixel);\n        TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n        if(level > 0) {\n            // All levels except highest res level should have this tag?\n            TIFFSetField(tiff, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE);\n        }\n        switch(compression) {\n            case ImageCompression::RAW:\n                TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n                break;\n            case ImageCompression::LZW:\n                TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n                break;\n            case ImageCompression::JPEG:\n                TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n                break;\n            case ImageCompression::JPEG2000:\n                // TODO NOT IMPLEMENTED\n                throw NotImplementedException();\n                TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_JP2000);\n                break;\n            case ImageCompression::NEURAL_NETWORK:\n                TIFFSetField(tiff, TIFFTAG_COMPRESSION, 34666); // TODO What should the value be?\n                break;\n        }\n\n        TIFFSetField(tiff, TIFFTAG_TILEWIDTH, imagePyramid->getLevelTileWidth(level));\n        TIFFSetField(tiff, TIFFTAG_TILELENGTH, imagePyramid->getLevelTileHeight(level));\n        TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, imagePyramid->getLevelWidth(level));\n        TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, imagePyramid->getLevelHeight(level));\n        if(spacing.x() != 1 && spacing.y() != 1) { // Spacing == 1 means not set.\n            TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER);\n            float scaleX = (float) imagePyramid->getFullWidth() / imagePyramid->getLevelWidth(level);\n            float scaleY = (float) imagePyramid->getFullHeight() / imagePyramid->getLevelHeight(level);\n            TIFFSetField(tiff, TIFFTAG_XRESOLUTION,\n                         1.0f / (spacing.x() / 10) * scaleX); // Convert to cm, and adjust for level\n            TIFFSetField(tiff, TIFFTAG_YRESOLUTION,\n                         1.0f / (spacing.y() / 10) * scaleY); // Convert to cm, and adjust for level\n        }\n\n        std::cout << \"starting patch gen\" << std::endl;\n        auto generator = PatchGenerator::New();\n        generator->setInputData(imagePyramid);\n        generator->setPatchLevel(level);\n        generator->setPatchSize(imagePyramid->getLevelTileWidth(level), imagePyramid->getLevelTileHeight(level));\n        auto stream = DataStream(generator);\n\n        Image::pointer image;\n        int counter = 0;\n        while(!stream.isDone()) {\n            image = stream.getNextFrame<Image>();\n\n            // Write tile to tiff level\n            if(image->getWidth() != imagePyramid->getLevelTileWidth(level) || image->getHeight() != imagePyramid->getLevelTileHeight(level)) {\n                // Have to pad the image, TIFF expects all tiles to be equal\n                // TODO improve\n                auto paddedImage = Image::create(imagePyramid->getLevelTileWidth(level), imagePyramid->getLevelTileHeight(level), image->getDataType(), image->getNrOfChannels());\n                if(imagePyramid->getNrOfChannels() >= 3) {\n                    paddedImage->fill(255);\n                } else {\n                    paddedImage->fill(0);\n                }\n                auto device = std::dynamic_pointer_cast<OpenCLDevice>(getMainDevice());\n                {\n                    auto dest = paddedImage->getOpenCLImageAccess(ACCESS_READ_WRITE, device);\n                    auto src = image->getOpenCLImageAccess(ACCESS_READ, device);\n                    device->getCommandQueue().enqueueCopyImage(*src->get2DImage(), *dest->get2DImage(),\n                                                               createOrigoRegion(), createOrigoRegion(),\n                                                               createRegion(image->getSize()));\n                    device->getCommandQueue().finish();\n                }\n                if(image->isLastFrame())\n                    paddedImage->setLastFrame(\"PatchGenerator\");\n                image = paddedImage;\n            }\n            auto data = image->getImageAccess(ACCESS_READ)->get();\n            std::size_t byteSize = getSizeOfDataType(image->getDataType(), image->getNrOfChannels())*image->getNrOfVoxels();\n            mRuntimeManager->startRegularTimer(\"TIFF write\");\n            TIFFWriteEncodedTile(tiff, counter, data, byteSize);\n            mRuntimeManager->stopRegularTimer(\"TIFF write\");\n            ++counter;\n            mRuntimeManager->printAll();\n        } while(!image->isLastFrame());\n\n        TIFFWriteDirectory(tiff);\n    }\n\n    TIFFClose(tiff);\n}",
    "toff_t GTIFFWriteDirectory(TIFF *hTIFF, int nSubfileType, int nXSize,\n                           int nYSize, int nBitsPerPixel, int nPlanarConfig,\n                           int nSamples, int nBlockXSize, int nBlockYSize,\n                           int bTiled, int nCompressFlag, int nPhotometric,\n                           int nSampleFormat, int nPredictor,\n                           unsigned short *panRed, unsigned short *panGreen,\n                           unsigned short *panBlue, int nExtraSamples,\n                           unsigned short *panExtraSampleValues,\n                           const char *pszMetadata, const char *pszJPEGQuality,\n                           const char *pszJPEGTablesMode, const char *pszNoData,\n                           const uint32_t *panLercAddCompressionAndVersion,\n                           bool bDeferStrileArrayWriting)\n\n{\n    const toff_t nBaseDirOffset = TIFFCurrentDirOffset(hTIFF);\n\n    // This is a bit of a hack to cause (*tif->tif_cleanup)(tif); to be called.\n    // See https://trac.osgeo.org/gdal/ticket/2055\n    TIFFSetField(hTIFF, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    TIFFFreeDirectory(hTIFF);\n\n    TIFFCreateDirectory(hTIFF);\n\n    /* -------------------------------------------------------------------- */\n    /*      Setup TIFF fields.                                              */\n    /* -------------------------------------------------------------------- */\n    TIFFSetField(hTIFF, TIFFTAG_IMAGEWIDTH, nXSize);\n    TIFFSetField(hTIFF, TIFFTAG_IMAGELENGTH, nYSize);\n    if (nSamples == 1)\n        TIFFSetField(hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    else\n        TIFFSetField(hTIFF, TIFFTAG_PLANARCONFIG, nPlanarConfig);\n\n    TIFFSetField(hTIFF, TIFFTAG_BITSPERSAMPLE, nBitsPerPixel);\n    TIFFSetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, nSamples);\n    TIFFSetField(hTIFF, TIFFTAG_COMPRESSION, nCompressFlag);\n    TIFFSetField(hTIFF, TIFFTAG_PHOTOMETRIC, nPhotometric);\n    TIFFSetField(hTIFF, TIFFTAG_SAMPLEFORMAT, nSampleFormat);\n\n    if (bTiled)\n    {\n        TIFFSetField(hTIFF, TIFFTAG_TILEWIDTH, nBlockXSize);\n        TIFFSetField(hTIFF, TIFFTAG_TILELENGTH, nBlockYSize);\n    }\n    else\n    {\n        TIFFSetField(hTIFF, TIFFTAG_ROWSPERSTRIP, nBlockYSize);\n    }\n\n    TIFFSetField(hTIFF, TIFFTAG_SUBFILETYPE, nSubfileType);\n\n    if (panExtraSampleValues != nullptr)\n    {\n        TIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, nExtraSamples,\n                     panExtraSampleValues);\n    }\n\n    if (GTIFFSupportsPredictor(nCompressFlag))\n        TIFFSetField(hTIFF, TIFFTAG_PREDICTOR, nPredictor);\n\n    /* -------------------------------------------------------------------- */\n    /*      Write color table if one is present.                            */\n    /* -------------------------------------------------------------------- */\n    if (panRed != nullptr)\n    {\n        TIFFSetField(hTIFF, TIFFTAG_COLORMAP, panRed, panGreen, panBlue);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write metadata if we have some.                                 */\n    /* -------------------------------------------------------------------- */\n    if (pszMetadata && strlen(pszMetadata) > 0)\n        TIFFSetField(hTIFF, TIFFTAG_GDAL_METADATA, pszMetadata);\n\n    /* -------------------------------------------------------------------- */\n    /*      Write JPEG tables if needed.                                    */\n    /* -------------------------------------------------------------------- */\n    if (nCompressFlag == COMPRESSION_JPEG)\n    {\n        GTiffWriteJPEGTables(hTIFF,\n                             (nPhotometric == PHOTOMETRIC_RGB) ? \"RGB\"\n                             : (nPhotometric == PHOTOMETRIC_YCBCR)\n                                 ? \"YCBCR\"\n                                 : \"MINISBLACK\",\n                             pszJPEGQuality, pszJPEGTablesMode);\n\n        if (nPhotometric == PHOTOMETRIC_YCBCR)\n        {\n            // Explicitly register the subsampling so that JPEGFixupTags\n            // is a no-op (helps for cloud optimized geotiffs)\n            TIFFSetField(hTIFF, TIFFTAG_YCBCRSUBSAMPLING, 2, 2);\n        }\n    }\n\n    if (nCompressFlag == COMPRESSION_LERC && panLercAddCompressionAndVersion)\n    {\n        TIFFSetField(hTIFF, TIFFTAG_LERC_PARAMETERS, 2,\n                     panLercAddCompressionAndVersion);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write no data value if we have one.                             */\n    /* -------------------------------------------------------------------- */\n    if (pszNoData != nullptr)\n    {\n        TIFFSetField(hTIFF, TIFFTAG_GDAL_NODATA, pszNoData);\n    }\n\n    if (bDeferStrileArrayWriting)\n    {\n        TIFFDeferStrileArrayWriting(hTIFF);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write directory, and return byte offset.                        */\n    /* -------------------------------------------------------------------- */\n    if (TIFFWriteCheck(hTIFF, bTiled, \"GTIFFWriteDirectory\") == 0)\n    {\n        TIFFSetSubDirectory(hTIFF, nBaseDirOffset);\n        return 0;\n    }\n\n    TIFFWriteDirectory(hTIFF);\n    const tdir_t nNumberOfDirs = TIFFNumberOfDirectories(hTIFF);\n    if (nNumberOfDirs > 0)  // always true, but to please Coverity\n    {\n        TIFFSetDirectory(hTIFF, static_cast<tdir_t>(nNumberOfDirs - 1));\n    }\n\n    const toff_t nOffset = TIFFCurrentDirOffset(hTIFF);\n\n    TIFFSetSubDirectory(hTIFF, nBaseDirOffset);\n\n    return nOffset;\n}",
    "void GTiffWriteJPEGTables(TIFF *hTIFF, const char *pszPhotometric,\n                          const char *pszJPEGQuality,\n                          const char *pszJPEGTablesMode)\n{\n    // This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n    uint16_t nBands = 0;\n    if (!TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nBands))\n        nBands = 1;\n\n    uint16_t l_nBitsPerSample = 0;\n    if (!TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &(l_nBitsPerSample)))\n        l_nBitsPerSample = 1;\n\n    const CPLString osTmpFilenameIn(\n        VSIMemGenerateHiddenFilename(\"gtiffdataset_jpg_tmp\"));\n    VSILFILE *fpTmp = nullptr;\n    CPLString osTmp;\n    char **papszLocalParameters = nullptr;\n    const int nInMemImageWidth = 16;\n    const int nInMemImageHeight = 16;\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"COMPRESS\", \"JPEG\");\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"JPEG_QUALITY\", pszJPEGQuality);\n    if (nBands <= 4)\n    {\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                               \"PHOTOMETRIC\", pszPhotometric);\n    }\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters, \"BLOCKYSIZE\",\n                                           CPLSPrintf(\"%u\", nInMemImageHeight));\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters, \"NBITS\",\n                                           CPLSPrintf(\"%u\", l_nBitsPerSample));\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                           \"JPEGTABLESMODE\", pszJPEGTablesMode);\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"WRITE_JPEGTABLE_TAG\", \"NO\");\n\n    bool bTileInterleaving;\n    TIFF *hTIFFTmp =\n        GTiffDataset::CreateLL(osTmpFilenameIn, nInMemImageWidth,\n                               nInMemImageHeight, (nBands <= 4) ? nBands : 1,\n                               (l_nBitsPerSample <= 8) ? GDT_Byte : GDT_UInt16,\n                               0.0, 0, papszLocalParameters, &fpTmp, osTmp,\n                               /* bCreateCopy=*/false, bTileInterleaving);\n    CSLDestroy(papszLocalParameters);\n    if (hTIFFTmp)\n    {\n        uint16_t l_nPhotometric = 0;\n        int nJpegTablesModeIn = 0;\n        TIFFGetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, &(l_nPhotometric));\n        TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLESMODE, &nJpegTablesModeIn);\n        TIFFWriteCheck(hTIFFTmp, FALSE, \"CreateLL\");\n        TIFFWriteDirectory(hTIFFTmp);\n        TIFFSetDirectory(hTIFFTmp, 0);\n        // Now, reset quality and jpegcolormode.\n        const int l_nJpegQuality = pszJPEGQuality ? atoi(pszJPEGQuality) : 0;\n        if (l_nJpegQuality > 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGQUALITY, l_nJpegQuality);\n        if (l_nPhotometric == PHOTOMETRIC_YCBCR &&\n            CPLTestBool(CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\")))\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n        if (nJpegTablesModeIn >= 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGTABLESMODE, nJpegTablesModeIn);\n\n        GPtrDiff_t nBlockSize = static_cast<GPtrDiff_t>(nInMemImageWidth) *\n                                nInMemImageHeight *\n                                ((nBands <= 4) ? nBands : 1);\n        if (l_nBitsPerSample == 12)\n            nBlockSize = (nBlockSize * 3) / 2;\n        std::vector<GByte> abyZeroData(nBlockSize, 0);\n        TIFFWriteEncodedStrip(hTIFFTmp, 0, &abyZeroData[0], nBlockSize);\n\n        uint32_t nJPEGTableSize = 0;\n        void *pJPEGTable = nullptr;\n        if (TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSize,\n                         &pJPEGTable))\n            TIFFSetField(hTIFF, TIFFTAG_JPEGTABLES, nJPEGTableSize, pJPEGTable);\n\n        float *ref = nullptr;\n        if (TIFFGetField(hTIFFTmp, TIFFTAG_REFERENCEBLACKWHITE, &ref))\n            TIFFSetField(hTIFF, TIFFTAG_REFERENCEBLACKWHITE, ref);\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n    VSIUnlink(osTmpFilenameIn);\n}",
    "void VICARDataset::ReadProjectionFromGeoTIFFGroup()\n{\n    m_bGeoRefFormatIsMIPL = true;\n\n    // We will build a in-memory temporary GeoTIFF file from the VICAR GEOTIFF\n    // metadata items.\n\n    const std::string osTmpFilename(\n        VSIMemGenerateHiddenFilename(\"vicar_tmp.tif\"));\n\n    /* -------------------------------------------------------------------- */\n    /*      Initialization of libtiff and libgeotiff.                       */\n    /* -------------------------------------------------------------------- */\n    GTiffOneTimeInit();\n    LibgeotiffOneTimeInit();\n\n    /* -------------------------------------------------------------------- */\n    /*      Initialize access to the memory geotiff structure.              */\n    /* -------------------------------------------------------------------- */\n    VSILFILE *fpL = VSIFOpenL(osTmpFilename.c_str(), \"w\");\n    if (fpL == nullptr)\n        return;\n\n    TIFF *hTIFF = VSI_TIFFOpen(osTmpFilename.c_str(), \"w\", fpL);\n\n    if (hTIFF == nullptr)\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"TIFF/GeoTIFF structure is corrupt.\");\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n        return;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write some minimal set of image parameters.                     */\n    /* -------------------------------------------------------------------- */\n    TIFFSetField(hTIFF, TIFFTAG_IMAGEWIDTH, 1);\n    TIFFSetField(hTIFF, TIFFTAG_IMAGELENGTH, 1);\n    TIFFSetField(hTIFF, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(hTIFF, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\n    /* -------------------------------------------------------------------- */\n    /*      Write geotiff keys from VICAR metadata                          */\n    /* -------------------------------------------------------------------- */\n    GTIF *hGTIF = GTIFNew(hTIFF);\n    CPLAssert(hGTIF);\n\n    for (const auto &gkey : GTiffAsciiKeys)\n    {\n        const char *pszValue = GetKeyword(\n            (\"GEOTIFF.\" + CPLString(GTIFKeyName(gkey)).toupper()).c_str(),\n            nullptr);\n        if (pszValue)\n        {\n            GTIFKeySet(hGTIF, gkey, TYPE_ASCII,\n                       static_cast<int>(strlen(pszValue)), pszValue);\n        }\n    }\n\n    for (const auto &gkey : GTiffDoubleKeys)\n    {\n        const char *pszValue = GetKeyword(\n            (\"GEOTIFF.\" + CPLString(GTIFKeyName(gkey)).toupper()).c_str(),\n            nullptr);\n        if (pszValue)\n        {\n            GTIFKeySet(hGTIF, gkey, TYPE_DOUBLE, 1, CPLAtof(pszValue));\n        }\n    }\n\n    for (const auto &gkey : GTiffShortKeys)\n    {\n        const char *pszValue = GetKeyword(\n            (\"GEOTIFF.\" + CPLString(GTIFKeyName(gkey)).toupper()).c_str(),\n            nullptr);\n        if (pszValue)\n        {\n            GTIFKeySet(hGTIF, gkey, TYPE_SHORT, 1, atoi(pszValue));\n        }\n    }\n\n    GTIFWriteKeys(hGTIF);\n    GTIFFree(hGTIF);\n\n    /* -------------------------------------------------------------------- */\n    /*      Write geotiff tags from VICAR metadata                          */\n    /* -------------------------------------------------------------------- */\n\n    const std::map<const char *, int> oMapTagNameToCode = {\n        {\"MODELPIXELSCALETAG\", TIFFTAG_GEOPIXELSCALE},\n        {\"MODELTIEPOINTTAG\", TIFFTAG_GEOTIEPOINTS},\n        {\"MODELTRANSFORMATIONTAG\", TIFFTAG_GEOTRANSMATRIX},\n    };\n\n    for (const auto &kv : oMapTagNameToCode)\n    {\n        const char *pszValue =\n            GetKeyword((std::string(\"GEOTIFF.\") + kv.first).c_str(), nullptr);\n        if (pszValue)\n        {\n            // Remove leading ( and trailing ), and replace comma by space\n            // to separate on it.\n            const CPLStringList aosTokens(\n                CSLTokenizeString2(CPLString(pszValue)\n                                       .replaceAll('(', \"\")\n                                       .replaceAll(')', \"\")\n                                       .replaceAll(',', ' ')\n                                       .c_str(),\n                                   \" \", 0));\n            if (!aosTokens.empty())\n            {\n                std::vector<double> adfValues;\n                for (int i = 0; i < aosTokens.size(); ++i)\n                    adfValues.push_back(CPLAtof(aosTokens[i]));\n                TIFFSetField(hTIFF, kv.second, aosTokens.size(), &adfValues[0]);\n            }\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Finalize the geotiff file.                                      */\n    /* -------------------------------------------------------------------- */\n\n    char bySmallImage = 0;\n\n    TIFFWriteEncodedStrip(hTIFF, 0, &bySmallImage, 1);\n    TIFFWriteDirectory(hTIFF);\n\n    XTIFFClose(hTIFF);\n    CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n\n    /* -------------------------------------------------------------------- */\n    /*      Get georeferencing from file.                                   */\n    /* -------------------------------------------------------------------- */\n    auto poGTiffDS =\n        std::unique_ptr<GDALDataset>(GDALDataset::Open(osTmpFilename.c_str()));\n    if (poGTiffDS)\n    {\n        auto poSRS = poGTiffDS->GetSpatialRef();\n        if (poSRS)\n            m_oSRS = *poSRS;\n\n        if (poGTiffDS->GetGeoTransform(&m_adfGeoTransform[0]) == CE_None)\n        {\n            m_bGotTransform = true;\n        }\n\n        const char *pszAreaOrPoint =\n            poGTiffDS->GetMetadataItem(GDALMD_AREA_OR_POINT);\n        if (pszAreaOrPoint)\n            GDALDataset::SetMetadataItem(GDALMD_AREA_OR_POINT, pszAreaOrPoint);\n    }\n\n    VSIUnlink(osTmpFilename.c_str());\n}",
    "CPLErr GTIFMemBufFromSRS(OGRSpatialReferenceH hSRS,\n                         const double *padfGeoTransform, int nGCPCount,\n                         const GDAL_GCP *pasGCPList, int *pnSize,\n                         unsigned char **ppabyBuffer, int bPixelIsPoint,\n                         char **papszRPCMD)\n\n{\n    const std::string osFilename(\n        VSIMemGenerateHiddenFilename(\"wkt_from_mem_buf.tif\"));\n\n    /* -------------------------------------------------------------------- */\n    /*      Initialization of libtiff and libgeotiff.                       */\n    /* -------------------------------------------------------------------- */\n    GTiffOneTimeInit();  // For RPC tag.\n    LibgeotiffOneTimeInit();\n\n    /* -------------------------------------------------------------------- */\n    /*      Initialize access to the memory geotiff structure.              */\n    /* -------------------------------------------------------------------- */\n    VSILFILE *fpL = VSIFOpenL(osFilename.c_str(), \"w\");\n    if (fpL == nullptr)\n        return CE_Failure;\n\n    TIFF *hTIFF = VSI_TIFFOpen(osFilename.c_str(), \"w\", fpL);\n\n    if (hTIFF == nullptr)\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"TIFF/GeoTIFF structure is corrupt.\");\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n        VSIUnlink(osFilename.c_str());\n        return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write some minimal set of image parameters.                     */\n    /* -------------------------------------------------------------------- */\n    TIFFSetField(hTIFF, TIFFTAG_IMAGEWIDTH, 1);\n    TIFFSetField(hTIFF, TIFFTAG_IMAGELENGTH, 1);\n    TIFFSetField(hTIFF, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(hTIFF, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\n    /* -------------------------------------------------------------------- */\n    /*      Get the projection definition.                                  */\n    /* -------------------------------------------------------------------- */\n\n    bool bPointGeoIgnore = false;\n    if (bPixelIsPoint)\n    {\n        bPointGeoIgnore =\n            CPLTestBool(CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\", \"FALSE\"));\n    }\n\n    GTIF *hGTIF = nullptr;\n    if (hSRS != nullptr || bPixelIsPoint)\n    {\n        hGTIF = GTIFNew(hTIFF);\n        if (hGTIF)\n        {\n            GTIFAttachPROJContext(hGTIF, OSRGetProjTLSContext());\n\n            if (hSRS != nullptr)\n                GTIFSetFromOGISDefnEx(hGTIF, hSRS, GEOTIFF_KEYS_STANDARD,\n                                      GEOTIFF_VERSION_1_0);\n\n            if (bPixelIsPoint)\n            {\n                GTIFKeySet(hGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                           RasterPixelIsPoint);\n            }\n\n            GTIFWriteKeys(hGTIF);\n            GTIFFree(hGTIF);\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Set the geotransform, or GCPs.                                  */\n    /* -------------------------------------------------------------------- */\n\n    if (padfGeoTransform[0] != 0.0 || padfGeoTransform[1] != 1.0 ||\n        padfGeoTransform[2] != 0.0 || padfGeoTransform[3] != 0.0 ||\n        padfGeoTransform[4] != 0.0 || std::abs(padfGeoTransform[5]) != 1.0)\n    {\n\n        if (padfGeoTransform[2] == 0.0 && padfGeoTransform[4] == 0.0)\n        {\n            double adfPixelScale[3] = {padfGeoTransform[1],\n                                       fabs(padfGeoTransform[5]), 0.0};\n\n            TIFFSetField(hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale);\n\n            double adfTiePoints[6] = {\n                0.0, 0.0, 0.0, padfGeoTransform[0], padfGeoTransform[3], 0.0};\n\n            if (bPixelIsPoint && !bPointGeoIgnore)\n            {\n                adfTiePoints[3] +=\n                    padfGeoTransform[1] * 0.5 + padfGeoTransform[2] * 0.5;\n                adfTiePoints[4] +=\n                    padfGeoTransform[4] * 0.5 + padfGeoTransform[5] * 0.5;\n            }\n\n            TIFFSetField(hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints);\n        }\n        else\n        {\n            double adfMatrix[16] = {0.0};\n\n            adfMatrix[0] = padfGeoTransform[1];\n            adfMatrix[1] = padfGeoTransform[2];\n            adfMatrix[3] = padfGeoTransform[0];\n            adfMatrix[4] = padfGeoTransform[4];\n            adfMatrix[5] = padfGeoTransform[5];\n            adfMatrix[7] = padfGeoTransform[3];\n            adfMatrix[15] = 1.0;\n\n            if (bPixelIsPoint && !bPointGeoIgnore)\n            {\n                adfMatrix[3] +=\n                    padfGeoTransform[1] * 0.5 + padfGeoTransform[2] * 0.5;\n                adfMatrix[7] +=\n                    padfGeoTransform[4] * 0.5 + padfGeoTransform[5] * 0.5;\n            }\n\n            TIFFSetField(hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix);\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Otherwise write tiepoints if they are available.                */\n    /* -------------------------------------------------------------------- */\n    else if (nGCPCount > 0)\n    {\n        double *padfTiePoints =\n            static_cast<double *>(CPLMalloc(6 * sizeof(double) * nGCPCount));\n\n        for (int iGCP = 0; iGCP < nGCPCount; iGCP++)\n        {\n\n            padfTiePoints[iGCP * 6 + 0] = pasGCPList[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP * 6 + 1] = pasGCPList[iGCP].dfGCPLine;\n            padfTiePoints[iGCP * 6 + 2] = 0;\n            padfTiePoints[iGCP * 6 + 3] = pasGCPList[iGCP].dfGCPX;\n            padfTiePoints[iGCP * 6 + 4] = pasGCPList[iGCP].dfGCPY;\n            padfTiePoints[iGCP * 6 + 5] = pasGCPList[iGCP].dfGCPZ;\n        }\n\n        TIFFSetField(hTIFF, TIFFTAG_GEOTIEPOINTS, 6 * nGCPCount, padfTiePoints);\n        CPLFree(padfTiePoints);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write RPC                                                       */\n    /* -------------------------------------------------------------------- */\n    if (papszRPCMD != nullptr)\n    {\n        GTiffDatasetWriteRPCTag(hTIFF, papszRPCMD);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup and return the created memory buffer.                   */\n    /* -------------------------------------------------------------------- */\n    GByte bySmallImage = 0;\n\n    TIFFWriteEncodedStrip(hTIFF, 0, reinterpret_cast<char *>(&bySmallImage), 1);\n    TIFFWriteCheck(hTIFF, TIFFIsTiled(hTIFF), \"GTIFMemBufFromWkt\");\n    TIFFWriteDirectory(hTIFF);\n\n    XTIFFClose(hTIFF);\n    CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n\n    /* -------------------------------------------------------------------- */\n    /*      Read back from the memory buffer.  It would be preferable       */\n    /*      to be able to \"steal\" the memory buffer, but there isn't        */\n    /*      currently any support for this.                                 */\n    /* -------------------------------------------------------------------- */\n    GUIntBig nBigLength = 0;\n\n    *ppabyBuffer = VSIGetMemFileBuffer(osFilename.c_str(), &nBigLength, TRUE);\n    *pnSize = static_cast<int>(nBigLength);\n\n    return CE_None;\n}",
    "int NITFUncompressBILEVEL(NITFImage *psImage, GByte *pabyInputData,\n                          int nInputBytes, GByte *pabyOutputImage)\n\n{\n    /* -------------------------------------------------------------------- */\n    /*      Write memory TIFF with the bilevel data.                        */\n    /* -------------------------------------------------------------------- */\n    const int nOutputBytes =\n        (psImage->nBlockWidth * psImage->nBlockHeight + 7) / 8;\n\n    const CPLString osFilename(\n        VSIMemGenerateHiddenFilename(\"nitf_bilevel.tif\"));\n    VSILFILE *fpL = VSIFOpenL(osFilename, \"w+\");\n    if (fpL == nullptr)\n        return FALSE;\n    TIFF *hTIFF = VSI_TIFFOpen(osFilename, \"w+\", fpL);\n    if (hTIFF == nullptr)\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n        return FALSE;\n    }\n\n    TIFFSetField(hTIFF, TIFFTAG_IMAGEWIDTH, psImage->nBlockWidth);\n    TIFFSetField(hTIFF, TIFFTAG_IMAGELENGTH, psImage->nBlockHeight);\n    TIFFSetField(hTIFF, TIFFTAG_BITSPERSAMPLE, 1);\n    TIFFSetField(hTIFF, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n    TIFFSetField(hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(hTIFF, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n    TIFFSetField(hTIFF, TIFFTAG_ROWSPERSTRIP, psImage->nBlockHeight);\n    TIFFSetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(hTIFF, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX3);\n\n    if (psImage->szCOMRAT[0] == '2')\n        TIFFSetField(hTIFF, TIFFTAG_GROUP3OPTIONS, GROUP3OPT_2DENCODING);\n\n    TIFFWriteRawStrip(hTIFF, 0, pabyInputData, nInputBytes);\n    TIFFWriteDirectory(hTIFF);\n\n    TIFFClose(hTIFF);\n\n    /* -------------------------------------------------------------------- */\n    /*      Now open and read it back.                                      */\n    /* -------------------------------------------------------------------- */\n    bool bResult = true;\n\n    hTIFF = VSI_TIFFOpen(osFilename, \"r\", fpL);\n    if (hTIFF == nullptr)\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n        return FALSE;\n    }\n\n    if (TIFFReadEncodedStrip(hTIFF, 0, pabyOutputImage, nOutputBytes) == -1)\n    {\n        memset(pabyOutputImage, 0, nOutputBytes);\n        bResult = false;\n    }\n\n    TIFFClose(hTIFF);\n    CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n\n    VSIUnlink(osFilename);\n\n    return bResult;\n}",
    "void GTiffDataset::ThreadDecompressionFunc(void *pData)\n{\n    const auto psJob = static_cast<const GTiffDecompressJob *>(pData);\n    auto psContext = psJob->psContext;\n    auto poDS = psContext->poDS;\n\n    auto oAccumulator = psContext->oErrorAccumulator.InstallForCurrentScope();\n\n    const int nBandsPerStrile =\n        poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG ? poDS->nBands : 1;\n    const int nBandsToWrite = poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG\n                                  ? psContext->nBandCount\n                                  : 1;\n\n    const int nXOffsetInBlock = psJob->nXBlock == psContext->nBlockXStart\n                                    ? psContext->nXOff % poDS->m_nBlockXSize\n                                    : 0;\n    const int nXOffsetInData =\n        psJob->nXBlock == psContext->nBlockXStart\n            ? 0\n            : (psJob->nXBlock - psContext->nBlockXStart) * poDS->m_nBlockXSize -\n                  (psContext->nXOff % poDS->m_nBlockXSize);\n    const int nXSize =\n        psJob->nXBlock == psContext->nBlockXStart\n            ? (psJob->nXBlock == psContext->nBlockXEnd\n                   ? psContext->nXSize\n                   : poDS->m_nBlockXSize -\n                         (psContext->nXOff % poDS->m_nBlockXSize))\n        : psJob->nXBlock == psContext->nBlockXEnd\n            ? (((psContext->nXOff + psContext->nXSize) % poDS->m_nBlockXSize) ==\n                       0\n                   ? poDS->m_nBlockXSize\n                   : ((psContext->nXOff + psContext->nXSize) %\n                      poDS->m_nBlockXSize))\n            : poDS->m_nBlockXSize;\n\n    const int nYOffsetInBlock = psJob->nYBlock == psContext->nBlockYStart\n                                    ? psContext->nYOff % poDS->m_nBlockYSize\n                                    : 0;\n    const int nYOffsetInData =\n        psJob->nYBlock == psContext->nBlockYStart\n            ? 0\n            : (psJob->nYBlock - psContext->nBlockYStart) * poDS->m_nBlockYSize -\n                  (psContext->nYOff % poDS->m_nBlockYSize);\n    const int nYSize =\n        psJob->nYBlock == psContext->nBlockYStart\n            ? (psJob->nYBlock == psContext->nBlockYEnd\n                   ? psContext->nYSize\n                   : poDS->m_nBlockYSize -\n                         (psContext->nYOff % poDS->m_nBlockYSize))\n        : psJob->nYBlock == psContext->nBlockYEnd\n            ? (((psContext->nYOff + psContext->nYSize) % poDS->m_nBlockYSize) ==\n                       0\n                   ? poDS->m_nBlockYSize\n                   : ((psContext->nYOff + psContext->nYSize) %\n                      poDS->m_nBlockYSize))\n            : poDS->m_nBlockYSize;\n#if 0\n    CPLDebug(\"GTiff\",\n             \"nXBlock = %d, nYBlock = %d, \"\n             \"nXOffsetInBlock = %d, nXOffsetInData = %d, nXSize = %d, \"\n             \"nYOffsetInBlock = %d, nYOffsetInData = %d, nYSize = %d\\n\",\n             psJob->nXBlock, psJob->nYBlock,\n             nXOffsetInBlock, nXOffsetInData, nXSize,\n             nYOffsetInBlock, nYOffsetInData, nYSize);\n#endif\n\n    if (psJob->nSize == 0)\n    {\n        {\n            std::lock_guard<std::recursive_mutex> oLock(psContext->oMutex);\n            if (!psContext->bSuccess)\n                return;\n        }\n        const double dfNoDataValue =\n            poDS->m_bNoDataSet ? poDS->m_dfNoDataValue : 0;\n        for (int y = 0; y < nYSize; ++y)\n        {\n            for (int i = 0; i < nBandsToWrite; ++i)\n            {\n                const int iDstBandIdx =\n                    poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG\n                        ? i\n                        : psJob->iDstBandIdxSeparate;\n                GDALCopyWords64(\n                    &dfNoDataValue, GDT_Float64, 0,\n                    psContext->pabyData + iDstBandIdx * psContext->nBandSpace +\n                        (y + nYOffsetInData) * psContext->nLineSpace +\n                        nXOffsetInData * psContext->nPixelSpace,\n                    psContext->eBufType,\n                    static_cast<int>(psContext->nPixelSpace), nXSize);\n            }\n        }\n        return;\n    }\n\n    const int nBandsToCache =\n        psContext->bCacheAllBands ? poDS->nBands : nBandsToWrite;\n    std::vector<GDALRasterBlock *> apoBlocks(nBandsToCache);\n    std::vector<bool> abAlreadyLoadedBlocks(nBandsToCache);\n    int nAlreadyLoadedBlocks = 0;\n    std::vector<GByte> abyInput;\n\n    struct FreeBlocks\n    {\n        std::vector<GDALRasterBlock *> &m_apoBlocks;\n\n        explicit FreeBlocks(std::vector<GDALRasterBlock *> &apoBlocksIn)\n            : m_apoBlocks(apoBlocksIn)\n        {\n        }\n\n        ~FreeBlocks()\n        {\n            for (auto *poBlock : m_apoBlocks)\n            {\n                if (poBlock)\n                    poBlock->DropLock();\n            }\n        }\n    };\n\n    FreeBlocks oFreeBlocks(apoBlocks);\n\n    const auto LoadBlocks = [&]()\n    {\n        for (int i = 0; i < nBandsToCache; ++i)\n        {\n            const int iBand = psContext->bCacheAllBands ? i + 1\n                              : poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG\n                                  ? psContext->panBandMap[i]\n                                  : psJob->iSrcBandIdxSeparate + 1;\n            apoBlocks[i] = poDS->GetRasterBand(iBand)->TryGetLockedBlockRef(\n                psJob->nXBlock, psJob->nYBlock);\n            if (apoBlocks[i] == nullptr)\n            {\n                // Temporary disabling of dirty block flushing, otherwise\n                // we can be in a deadlock situation, where the\n                // GTiffDataset::SubmitCompressionJob() method waits for jobs\n                // to be finished, that can't finish (actually be started)\n                // because this task and its siblings are taking all the\n                // available workers allowed by the global thread pool.\n                GDALRasterBlock::EnterDisableDirtyBlockFlush();\n                apoBlocks[i] = poDS->GetRasterBand(iBand)->GetLockedBlockRef(\n                    psJob->nXBlock, psJob->nYBlock, TRUE);\n                GDALRasterBlock::LeaveDisableDirtyBlockFlush();\n                if (apoBlocks[i] == nullptr)\n                    return false;\n            }\n            else\n            {\n                abAlreadyLoadedBlocks[i] = true;\n                nAlreadyLoadedBlocks++;\n            }\n        }\n        return true;\n    };\n\n    const auto AllocInputBuffer = [&]()\n    {\n        bool bError = false;\n#if SIZEOF_VOIDP == 4\n        if (psJob->nSize != static_cast<size_t>(psJob->nSize))\n        {\n            bError = true;\n        }\n        else\n#endif\n        {\n            try\n            {\n                abyInput.resize(static_cast<size_t>(psJob->nSize));\n            }\n            catch (const std::exception &)\n            {\n                bError = true;\n            }\n        }\n        if (bError)\n        {\n            CPLError(CE_Failure, CPLE_OutOfMemory,\n                     \"Cannot allocate working buffer of size \" CPL_FRMT_GUIB,\n                     static_cast<GUIntBig>(psJob->nSize));\n            return false;\n        }\n        return true;\n    };\n\n    if (psContext->bHasPRead)\n    {\n        {\n            std::lock_guard<std::recursive_mutex> oLock(psContext->oMutex);\n            if (!psContext->bSuccess)\n                return;\n\n            // Coverity Scan notices that GDALRasterBlock::Internalize() calls\n            // CPLSleep() in a debug code path, and warns about that while\n            // holding the above mutex.\n            // coverity[sleep]\n            if (!psContext->bSkipBlockCache && !LoadBlocks())\n            {\n                psContext->bSuccess = false;\n                return;\n            }\n        }\n        if (nAlreadyLoadedBlocks != nBandsToCache)\n        {\n            if (!AllocInputBuffer())\n            {\n                std::lock_guard<std::recursive_mutex> oLock(psContext->oMutex);\n                psContext->bSuccess = false;\n                return;\n            }\n            if (psContext->poHandle->PRead(abyInput.data(), abyInput.size(),\n                                           psJob->nOffset) != abyInput.size())\n            {\n                CPLError(CE_Failure, CPLE_AppDefined,\n                         \"Cannot read \" CPL_FRMT_GUIB\n                         \" bytes at offset \" CPL_FRMT_GUIB,\n                         static_cast<GUIntBig>(psJob->nSize),\n                         static_cast<GUIntBig>(psJob->nOffset));\n\n                std::lock_guard<std::recursive_mutex> oLock(psContext->oMutex);\n                psContext->bSuccess = false;\n                return;\n            }\n        }\n    }\n    else\n    {\n        std::lock_guard<std::recursive_mutex> oLock(psContext->oMutex);\n        if (!psContext->bSuccess)\n            return;\n\n        // Coverity Scan notices that GDALRasterBlock::Internalize() calls\n        // CPLSleep() in a debug code path, and warns about that while\n        // holding the above mutex.\n        // coverity[sleep]\n        if (!psContext->bSkipBlockCache && !LoadBlocks())\n        {\n            psContext->bSuccess = false;\n            return;\n        }\n\n        if (nAlreadyLoadedBlocks != nBandsToCache)\n        {\n            if (!AllocInputBuffer())\n            {\n                psContext->bSuccess = false;\n                return;\n            }\n            if (psContext->poHandle->Seek(psJob->nOffset, SEEK_SET) != 0 ||\n                psContext->poHandle->Read(abyInput.data(), abyInput.size(),\n                                          1) != 1)\n            {\n                CPLError(CE_Failure, CPLE_AppDefined,\n                         \"Cannot read \" CPL_FRMT_GUIB\n                         \" bytes at offset \" CPL_FRMT_GUIB,\n                         static_cast<GUIntBig>(psJob->nSize),\n                         static_cast<GUIntBig>(psJob->nOffset));\n                psContext->bSuccess = false;\n                return;\n            }\n        }\n    }\n\n    const int nDTSize = GDALGetDataTypeSizeBytes(psContext->eDT);\n    GByte *pDstPtr = psContext->pabyData +\n                     nYOffsetInData * psContext->nLineSpace +\n                     nXOffsetInData * psContext->nPixelSpace;\n\n    if (nAlreadyLoadedBlocks != nBandsToCache)\n    {\n        // Generate a dummy in-memory TIFF file that has all the needed tags\n        // from the original file\n        const CPLString osTmpFilename(\n            VSIMemGenerateHiddenFilename(\"decompress.tif\"));\n        VSILFILE *fpTmp = VSIFOpenL(osTmpFilename.c_str(), \"wb+\");\n        TIFF *hTIFFTmp =\n            VSI_TIFFOpen(osTmpFilename.c_str(),\n                         psContext->bTIFFIsBigEndian ? \"wb+\" : \"wl+\", fpTmp);\n        CPLAssert(hTIFFTmp != nullptr);\n        const int nBlockYSize =\n            (psContext->bIsTiled ||\n             psJob->nYBlock < poDS->m_nBlocksPerColumn - 1)\n                ? poDS->m_nBlockYSize\n            : (poDS->nRasterYSize % poDS->m_nBlockYSize) == 0\n                ? poDS->m_nBlockYSize\n                : poDS->nRasterYSize % poDS->m_nBlockYSize;\n        TIFFSetField(hTIFFTmp, TIFFTAG_IMAGEWIDTH, poDS->m_nBlockXSize);\n        TIFFSetField(hTIFFTmp, TIFFTAG_IMAGELENGTH, nBlockYSize);\n        TIFFSetField(hTIFFTmp, TIFFTAG_BITSPERSAMPLE, poDS->m_nBitsPerSample);\n        TIFFSetField(hTIFFTmp, TIFFTAG_COMPRESSION, poDS->m_nCompression);\n        TIFFSetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, poDS->m_nPhotometric);\n        TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLEFORMAT, poDS->m_nSampleFormat);\n        TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLESPERPIXEL,\n                     poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG\n                         ? poDS->m_nSamplesPerPixel\n                         : 1);\n        TIFFSetField(hTIFFTmp, TIFFTAG_ROWSPERSTRIP, nBlockYSize);\n        TIFFSetField(hTIFFTmp, TIFFTAG_PLANARCONFIG, poDS->m_nPlanarConfig);\n        if (psContext->nPredictor != PREDICTOR_NONE)\n            TIFFSetField(hTIFFTmp, TIFFTAG_PREDICTOR, psContext->nPredictor);\n        if (poDS->m_nCompression == COMPRESSION_LERC)\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_LERC_PARAMETERS, 2,\n                         poDS->m_anLercAddCompressionAndVersion);\n        }\n        else if (poDS->m_nCompression == COMPRESSION_JPEG)\n        {\n            if (psContext->pJPEGTable)\n            {\n                TIFFSetField(hTIFFTmp, TIFFTAG_JPEGTABLES,\n                             psContext->nJPEGTableSize, psContext->pJPEGTable);\n            }\n            if (poDS->m_nPhotometric == PHOTOMETRIC_YCBCR)\n            {\n                TIFFSetField(hTIFFTmp, TIFFTAG_YCBCRSUBSAMPLING,\n                             psContext->nYCrbCrSubSampling0,\n                             psContext->nYCrbCrSubSampling1);\n            }\n        }\n        if (poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG)\n        {\n            if (psContext->pExtraSamples)\n            {\n                TIFFSetField(hTIFFTmp, TIFFTAG_EXTRASAMPLES,\n                             psContext->nExtraSampleCount,\n                             psContext->pExtraSamples);\n            }\n            else\n            {\n                const int nSamplesAccountedFor =\n                    poDS->m_nPhotometric == PHOTOMETRIC_RGB          ? 3\n                    : poDS->m_nPhotometric == PHOTOMETRIC_MINISBLACK ? 1\n                                                                     : 0;\n                if (nSamplesAccountedFor > 0 &&\n                    poDS->m_nSamplesPerPixel > nSamplesAccountedFor)\n                {\n                    // If the input image is not compliant regarndig ExtraSamples,\n                    // generate a synthetic one to avoid gazillons of warnings\n                    const auto nExtraSampleCount = static_cast<uint16_t>(\n                        poDS->m_nSamplesPerPixel - nSamplesAccountedFor);\n                    std::vector<uint16_t> anExtraSamples(\n                        nExtraSampleCount, EXTRASAMPLE_UNSPECIFIED);\n                    TIFFSetField(hTIFFTmp, TIFFTAG_EXTRASAMPLES,\n                                 nExtraSampleCount, anExtraSamples.data());\n                }\n            }\n        }\n        TIFFWriteCheck(hTIFFTmp, FALSE, \"ThreadDecompressionFunc\");\n        TIFFWriteDirectory(hTIFFTmp);\n        XTIFFClose(hTIFFTmp);\n\n        // Re-open file\n        hTIFFTmp = VSI_TIFFOpen(osTmpFilename.c_str(), \"r\", fpTmp);\n        CPLAssert(hTIFFTmp != nullptr);\n        poDS->RestoreVolatileParameters(hTIFFTmp);\n\n        bool bRet = true;\n        // Request m_nBlockYSize line in the block, except on the bottom-most\n        // tile/strip.\n        const int nBlockReqYSize =\n            (psJob->nYBlock < poDS->m_nBlocksPerColumn - 1)\n                ? poDS->m_nBlockYSize\n            : (poDS->nRasterYSize % poDS->m_nBlockYSize) == 0\n                ? poDS->m_nBlockYSize\n                : poDS->nRasterYSize % poDS->m_nBlockYSize;\n\n        const size_t nReqSize = static_cast<size_t>(poDS->m_nBlockXSize) *\n                                nBlockReqYSize * nBandsPerStrile * nDTSize;\n\n        GByte *pabyOutput;\n        std::vector<GByte> abyOutput;\n        if (poDS->m_nCompression == COMPRESSION_NONE &&\n            !TIFFIsByteSwapped(poDS->m_hTIFF) && abyInput.size() >= nReqSize &&\n            (psContext->bSkipBlockCache || nBandsPerStrile > 1))\n        {\n            pabyOutput = abyInput.data();\n        }\n        else\n        {\n            if (psContext->bSkipBlockCache || nBandsPerStrile > 1)\n            {\n                abyOutput.resize(nReqSize);\n                pabyOutput = abyOutput.data();\n            }\n            else\n            {\n                pabyOutput = static_cast<GByte *>(apoBlocks[0]->GetDataRef());\n            }\n            if (!TIFFReadFromUserBuffer(hTIFFTmp, 0, abyInput.data(),\n                                        abyInput.size(), pabyOutput,\n                                        nReqSize) &&\n                !poDS->m_bIgnoreReadErrors)\n            {\n                bRet = false;\n            }\n        }\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n        VSIUnlink(osTmpFilename.c_str());\n\n        if (!bRet)\n        {\n            std::lock_guard<std::recursive_mutex> oLock(psContext->oMutex);\n            psContext->bSuccess = false;\n            return;\n        }\n\n        if (!psContext->bSkipBlockCache && nBandsPerStrile > 1)\n        {\n            // Copy pixel-interleaved all-band buffer to cached blocks\n\n            if (psContext->bUseDeinterleaveOptimBlockCache)\n            {\n                // Optimization\n                std::vector<void *> ppDestBuffers(poDS->nBands);\n                for (int i = 0; i < poDS->nBands; ++i)\n                {\n                    ppDestBuffers[i] = apoBlocks[i]->GetDataRef();\n                }\n                GDALDeinterleave(pabyOutput, psContext->eDT, poDS->nBands,\n                                 ppDestBuffers.data(), psContext->eDT,\n                                 static_cast<size_t>(nBlockReqYSize) *\n                                     poDS->m_nBlockXSize);\n            }\n            else\n            {\n                // General case\n                for (int i = 0; i < nBandsToCache; ++i)\n                {\n                    if (!abAlreadyLoadedBlocks[i])\n                    {\n                        const int iBand = psContext->bCacheAllBands\n                                              ? i\n                                              : psContext->panBandMap[i] - 1;\n                        GDALCopyWords64(pabyOutput + iBand * nDTSize,\n                                        psContext->eDT, nDTSize * poDS->nBands,\n                                        apoBlocks[i]->GetDataRef(),\n                                        psContext->eDT, nDTSize,\n                                        static_cast<size_t>(nBlockReqYSize) *\n                                            poDS->m_nBlockXSize);\n                    }\n                }\n            }\n        }\n\n        const GByte *pSrcPtr =\n            pabyOutput +\n            (static_cast<size_t>(nYOffsetInBlock) * poDS->m_nBlockXSize +\n             nXOffsetInBlock) *\n                nDTSize * nBandsPerStrile;\n        const size_t nSrcLineInc = static_cast<size_t>(poDS->m_nBlockXSize) *\n                                   nDTSize * nBandsPerStrile;\n\n        // Optimization when writing to BIP buffer.\n        if (psContext->bUseBIPOptim)\n        {\n            for (int y = 0; y < nYSize; ++y)\n            {\n                GDALCopyWords64(pSrcPtr, psContext->eDT, nDTSize, pDstPtr,\n                                psContext->eBufType, psContext->nBufDTSize,\n                                static_cast<size_t>(nXSize) * poDS->nBands);\n                pSrcPtr += nSrcLineInc;\n                pDstPtr += psContext->nLineSpace;\n            }\n            return;\n        }\n\n        if (psContext->bSkipBlockCache)\n        {\n            // Copy from pixel-interleaved all-band buffer (or temporary buffer\n            // for single-band/separate case) into final buffer\n            if (psContext->bUseDeinterleaveOptimNoBlockCache)\n            {\n                // Optimization\n                std::vector<void *> ppDestBuffers(psContext->nBandCount);\n                for (int i = 0; i < psContext->nBandCount; ++i)\n                {\n                    ppDestBuffers[i] =\n                        pDstPtr +\n                        (psContext->panBandMap[i] - 1) * psContext->nBandSpace;\n                }\n                for (int y = 0; y < nYSize; ++y)\n                {\n                    GDALDeinterleave(\n                        pSrcPtr, psContext->eDT, psContext->nBandCount,\n                        ppDestBuffers.data(), psContext->eDT, nXSize);\n                    pSrcPtr += nSrcLineInc;\n                    for (int i = 0; i < psContext->nBandCount; ++i)\n                    {\n                        ppDestBuffers[i] =\n                            static_cast<GByte *>(ppDestBuffers[i]) +\n                            psContext->nLineSpace;\n                    }\n                }\n                return;\n            }\n\n            // General case\n            for (int y = 0; y < nYSize; ++y)\n            {\n                for (int i = 0; i < nBandsToWrite; ++i)\n                {\n                    const int iSrcBandIdx =\n                        poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG\n                            ? psContext->panBandMap[i] - 1\n                            : 0;\n                    const int iDstBandIdx =\n                        poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG\n                            ? i\n                            : psJob->iDstBandIdxSeparate;\n                    GDALCopyWords64(\n                        pSrcPtr + iSrcBandIdx * nDTSize + y * nSrcLineInc,\n                        psContext->eDT, nDTSize * nBandsPerStrile,\n                        pDstPtr + iDstBandIdx * psContext->nBandSpace +\n                            y * psContext->nLineSpace,\n                        psContext->eBufType,\n                        static_cast<int>(psContext->nPixelSpace), nXSize);\n                }\n            }\n            return;\n        }\n    }\n\n    CPLAssert(!psContext->bSkipBlockCache);\n\n    // Compose cached blocks into final buffer\n    for (int i = 0; i < nBandsToWrite; ++i)\n    {\n        const int iSrcBandIdx =\n            psContext->bCacheAllBands ? psContext->panBandMap[i] - 1\n            : poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG ? i\n                                                           : 0;\n        assert(iSrcBandIdx >= 0);\n        const int iDstBandIdx = poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG\n                                    ? i\n                                    : psJob->iDstBandIdxSeparate;\n        const GByte *pSrcPtr =\n            static_cast<GByte *>(apoBlocks[iSrcBandIdx]->GetDataRef()) +\n            (static_cast<size_t>(nYOffsetInBlock) * poDS->m_nBlockXSize +\n             nXOffsetInBlock) *\n                nDTSize;\n        for (int y = 0; y < nYSize; ++y)\n        {\n            GDALCopyWords64(pSrcPtr + static_cast<size_t>(y) *\n                                          poDS->m_nBlockXSize * nDTSize,\n                            psContext->eDT, nDTSize,\n                            pDstPtr + iDstBandIdx * psContext->nBandSpace +\n                                y * psContext->nLineSpace,\n                            psContext->eBufType,\n                            static_cast<int>(psContext->nPixelSpace), nXSize);\n        }\n    }\n}",
    "void GTiffDataset::Crystalize()\n\n{\n    if (m_bCrystalized)\n        return;\n\n    // TODO: libtiff writes extended tags in the order they are specified\n    // and not in increasing order.\n    WriteMetadata(this, m_hTIFF, true, m_eProfile, m_pszFilename,\n                  m_papszCreationOptions);\n    WriteGeoTIFFInfo();\n    if (m_bNoDataSet)\n        WriteNoDataValue(m_hTIFF, m_dfNoDataValue);\n    else if (m_bNoDataSetAsInt64)\n        WriteNoDataValue(m_hTIFF, m_nNoDataValueInt64);\n    else if (m_bNoDataSetAsUInt64)\n        WriteNoDataValue(m_hTIFF, m_nNoDataValueUInt64);\n\n    m_bMetadataChanged = false;\n    m_bGeoTIFFInfoChanged = false;\n    m_bNoDataChanged = false;\n    m_bNeedsRewrite = false;\n\n    m_bCrystalized = true;\n\n    TIFFWriteCheck(m_hTIFF, TIFFIsTiled(m_hTIFF), \"GTiffDataset::Crystalize\");\n\n    TIFFWriteDirectory(m_hTIFF);\n    if (m_bStreamingOut)\n    {\n        // We need to write twice the directory to be sure that custom\n        // TIFF tags are correctly sorted and that padding bytes have been\n        // added.\n        TIFFSetDirectory(m_hTIFF, 0);\n        TIFFWriteDirectory(m_hTIFF);\n\n        if (VSIFSeekL(m_fpL, 0, SEEK_END) != 0)\n        {\n            ReportError(CE_Failure, CPLE_FileIO, \"Could not seek\");\n        }\n        const int nSize = static_cast<int>(VSIFTellL(m_fpL));\n\n        TIFFSetDirectory(m_hTIFF, 0);\n        GTiffFillStreamableOffsetAndCount(m_hTIFF, nSize);\n        TIFFWriteDirectory(m_hTIFF);\n\n        vsi_l_offset nDataLength = 0;\n        void *pabyBuffer =\n            VSIGetMemFileBuffer(m_pszTmpFilename, &nDataLength, FALSE);\n        if (static_cast<int>(VSIFWriteL(\n                pabyBuffer, 1, static_cast<int>(nDataLength), m_fpToWrite)) !=\n            static_cast<int>(nDataLength))\n        {\n            ReportError(CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                        static_cast<int>(nDataLength));\n        }\n        // In case of single strip file, there's a libtiff check that would\n        // issue a warning since the file hasn't the required size.\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        TIFFSetDirectory(m_hTIFF, 0);\n        CPLPopErrorHandler();\n    }\n    else\n    {\n        const tdir_t nNumberOfDirs = TIFFNumberOfDirectories(m_hTIFF);\n        if (nNumberOfDirs > 0)\n        {\n            TIFFSetDirectory(m_hTIFF, static_cast<tdir_t>(nNumberOfDirs - 1));\n        }\n    }\n\n    RestoreVolatileParameters(m_hTIFF);\n\n    m_nDirOffset = TIFFCurrentDirOffset(m_hTIFF);\n}",
    "int GTiffDataset::GuessJPEGQuality(bool &bOutHasQuantizationTable,\n                                   bool &bOutHasHuffmanTable)\n{\n    CPLAssert(m_nCompression == COMPRESSION_JPEG);\n    uint32_t nJPEGTableSize = 0;\n    void *pJPEGTable = nullptr;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize,\n                      &pJPEGTable))\n    {\n        bOutHasQuantizationTable = false;\n        bOutHasHuffmanTable = false;\n        return -1;\n    }\n\n    bOutHasQuantizationTable =\n        GTIFFFindNextTable(static_cast<const GByte *>(pJPEGTable),\n                           MARKER_QUANT_TABLE, nJPEGTableSize,\n                           nullptr) != nullptr;\n    bOutHasHuffmanTable =\n        GTIFFFindNextTable(static_cast<const GByte *>(pJPEGTable),\n                           MARKER_HUFFMAN_TABLE, nJPEGTableSize,\n                           nullptr) != nullptr;\n    if (!bOutHasQuantizationTable)\n        return -1;\n\n    if ((nBands == 1 && m_nBitsPerSample == 8) ||\n        (nBands == 3 && m_nBitsPerSample == 8 &&\n         m_nPhotometric == PHOTOMETRIC_RGB) ||\n        (nBands == 4 && m_nBitsPerSample == 8 &&\n         m_nPhotometric == PHOTOMETRIC_SEPARATED))\n    {\n        return GuessJPEGQualityFromMD5(md5JPEGQuantTable_generic_8bit,\n                                       static_cast<const GByte *>(pJPEGTable),\n                                       static_cast<int>(nJPEGTableSize));\n    }\n\n    if (nBands == 3 && m_nBitsPerSample == 8 &&\n        m_nPhotometric == PHOTOMETRIC_YCBCR)\n    {\n        int nRet =\n            GuessJPEGQualityFromMD5(md5JPEGQuantTable_3_YCBCR_8bit,\n                                    static_cast<const GByte *>(pJPEGTable),\n                                    static_cast<int>(nJPEGTableSize));\n        if (nRet < 0)\n        {\n            // libjpeg 9e has modified the YCbCr quantization tables.\n            nRet =\n                GuessJPEGQualityFromMD5(md5JPEGQuantTable_3_YCBCR_8bit_jpeg9e,\n                                        static_cast<const GByte *>(pJPEGTable),\n                                        static_cast<int>(nJPEGTableSize));\n        }\n        return nRet;\n    }\n\n    char **papszLocalParameters = nullptr;\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"COMPRESS\", \"JPEG\");\n    if (m_nPhotometric == PHOTOMETRIC_YCBCR)\n        papszLocalParameters =\n            CSLSetNameValue(papszLocalParameters, \"PHOTOMETRIC\", \"YCBCR\");\n    else if (m_nPhotometric == PHOTOMETRIC_SEPARATED)\n        papszLocalParameters =\n            CSLSetNameValue(papszLocalParameters, \"PHOTOMETRIC\", \"CMYK\");\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"BLOCKYSIZE\", \"16\");\n    if (m_nBitsPerSample == 12)\n        papszLocalParameters =\n            CSLSetNameValue(papszLocalParameters, \"NBITS\", \"12\");\n\n    const CPLString osTmpFilenameIn(\n        VSIMemGenerateHiddenFilename(\"gtiffdataset_guess_jpeg_quality_tmp\"));\n\n    int nRet = -1;\n    for (int nQuality = 0; nQuality <= 100 && nRet < 0; ++nQuality)\n    {\n        VSILFILE *fpTmp = nullptr;\n        if (nQuality == 0)\n            papszLocalParameters =\n                CSLSetNameValue(papszLocalParameters, \"JPEG_QUALITY\", \"75\");\n        else\n            papszLocalParameters =\n                CSLSetNameValue(papszLocalParameters, \"JPEG_QUALITY\",\n                                CPLSPrintf(\"%d\", nQuality));\n\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        CPLString osTmp;\n        bool bTileInterleaving;\n        TIFF *hTIFFTmp = CreateLL(\n            osTmpFilenameIn, 16, 16, (nBands <= 4) ? nBands : 1,\n            GetRasterBand(1)->GetRasterDataType(), 0.0, 0, papszLocalParameters,\n            &fpTmp, osTmp, /* bCreateCopy=*/false, bTileInterleaving);\n        CPLPopErrorHandler();\n        if (!hTIFFTmp)\n        {\n            break;\n        }\n\n        TIFFWriteCheck(hTIFFTmp, FALSE, \"CreateLL\");\n        TIFFWriteDirectory(hTIFFTmp);\n        TIFFSetDirectory(hTIFFTmp, 0);\n        // Now reset jpegcolormode.\n        if (m_nPhotometric == PHOTOMETRIC_YCBCR &&\n            CPLTestBool(CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\")))\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n\n        GByte abyZeroData[(16 * 16 * 4 * 3) / 2] = {};\n        const int nBlockSize =\n            (16 * 16 * ((nBands <= 4) ? nBands : 1) * m_nBitsPerSample) / 8;\n        TIFFWriteEncodedStrip(hTIFFTmp, 0, abyZeroData, nBlockSize);\n\n        uint32_t nJPEGTableSizeTry = 0;\n        void *pJPEGTableTry = nullptr;\n        if (TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSizeTry,\n                         &pJPEGTableTry))\n        {\n            if (GTIFFQuantizationTablesEqual(\n                    static_cast<GByte *>(pJPEGTable), nJPEGTableSize,\n                    static_cast<GByte *>(pJPEGTableTry), nJPEGTableSizeTry))\n            {\n                nRet = (nQuality == 0) ? 75 : nQuality;\n            }\n        }\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n\n    CSLDestroy(papszLocalParameters);\n    VSIUnlink(osTmpFilenameIn);\n\n    return nRet;\n}",
    "bool\nTiffWriter::writeBitonalOrIndexed8Image(\n    TiffHandle const& tif, QImage const& image, bool multipage, int compression)\n{\n    TIFFSetField(tif.handle(), TIFFTAG_SAMPLESPERPIXEL, uint16(1));\n\n    uint16 bits_per_sample = 8;\n    uint16 photometric = PHOTOMETRIC_PALETTE;\n    if (image.isGrayscale()) {\n        photometric = PHOTOMETRIC_MINISBLACK;\n    }\n\n    switch (image.format()) {\n    case QImage::Format_Mono:\n    case QImage::Format_MonoLSB:\n        bits_per_sample = 1;\n        if (image.colorCount() < 2) {\n            photometric = PHOTOMETRIC_MINISWHITE;\n        } else {\n            // Some programs don't understand\n            // palettized binary images, so don't\n            // use a palette for black and white images.\n            uint32_t const c0 = image.color(0);\n            uint32_t const c1 = image.color(1);\n            if (c0 == 0xffffffff && c1 == 0xff000000) {\n                photometric = PHOTOMETRIC_MINISWHITE;\n            } else if (c0 == 0xff000000 && c1 == 0xffffffff) {\n                photometric = PHOTOMETRIC_MINISBLACK;\n            }\n        }\n        break;\n    default:;\n    }\n\n    TIFFSetField(tif.handle(), TIFFTAG_COMPRESSION, uint16(compression));\n    TIFFSetField(tif.handle(), TIFFTAG_BITSPERSAMPLE, bits_per_sample);\n    TIFFSetField(tif.handle(), TIFFTAG_PHOTOMETRIC, photometric);\n    TIFFSetField(tif.handle(), TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n    if (GlobalStaticSettings::m_use_horizontal_predictor && bits_per_sample == 8) {\n        TIFFSetField(tif.handle(), TIFFTAG_PREDICTOR, PREDICTOR_HORIZONTAL);\n    }\n\n    if (photometric == PHOTOMETRIC_PALETTE) {\n        int const num_colors = 1 << bits_per_sample;\n        QVector<QRgb> color_table(image.colorTable());\n        if (color_table.size() > num_colors) {\n            color_table.resize(num_colors);\n        }\n        std::vector<uint16> pr(num_colors, 0);\n        std::vector<uint16> pg(num_colors, 0);\n        std::vector<uint16> pb(num_colors, 0);\n        for (int i = 0; i < color_table.size(); ++i) {\n            QRgb const rgb = color_table[i];\n            pr[i] = (0xFFFF * qRed(rgb) + 128) / 255;\n            pg[i] = (0xFFFF * qGreen(rgb) + 128) / 255;\n            pb[i] = (0xFFFF * qBlue(rgb) + 128) / 255;\n        }\n        TIFFSetField(tif.handle(), TIFFTAG_COLORMAP, &pr[0], &pg[0], &pb[0]);\n    }\n\n    if (image.format() == QImage::Format_Indexed8) {\n        if (!write8bitLines(tif, image)) {\n            return false;\n        }\n    } else {\n        if (image.format() == QImage::Format_MonoLSB) {\n            if (!writeBinaryLinesReversed(tif, image)) {\n                return false;\n            }\n        } else {\n            if (!writeBinaryLinesAsIs(tif, image)) {\n                return false;\n            }\n        }\n    }\n\n    if (multipage && (TIFFWriteDirectory(tif.handle()) == -1)) {\n        return false;\n    }\n    return true;\n}",
    "bool\nTiffWriter::writeRGB32Image(\n    TiffHandle const& tif, QImage const& image, bool multipage, int compression)\n{\n    assert(image.format() == QImage::Format_RGB32);\n\n    TIFFSetField(tif.handle(), TIFFTAG_SAMPLESPERPIXEL, uint16(3));\n    TIFFSetField(tif.handle(), TIFFTAG_COMPRESSION, uint16(compression));\n    TIFFSetField(tif.handle(), TIFFTAG_BITSPERSAMPLE, uint16(8));\n    TIFFSetField(tif.handle(), TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    if (GlobalStaticSettings::m_use_horizontal_predictor) {\n        TIFFSetField(tif.handle(), TIFFTAG_PREDICTOR, PREDICTOR_HORIZONTAL);\n    }\n\n    int const width = image.width();\n    int const height = image.height();\n\n    std::vector<uint8_t> tmp_line(width * 3);\n\n    // Libtiff expects \"RR GG BB\" sequences regardless of CPU byte order.\n\n    for (int y = 0; y < height; ++y) {\n        uint32_t const* p_src = (uint32_t const*)image.scanLine(y);\n        uint8_t* p_dst = &tmp_line[0];\n        for (int x = 0; x < width; ++x) {\n            uint32_t const ARGB = *p_src;\n            p_dst[0] = static_cast<uint8_t>(ARGB >> 16);\n            p_dst[1] = static_cast<uint8_t>(ARGB >> 8);\n            p_dst[2] = static_cast<uint8_t>(ARGB);\n            ++p_src;\n            p_dst += 3;\n        }\n        if (TIFFWriteScanline(tif.handle(), &tmp_line[0], y) == -1) {\n            return false;\n        }\n    }\n\n    if (multipage && (TIFFWriteDirectory(tif.handle()) == -1)) {\n        return false;\n    }\n\n    return true;\n}",
    "bool\nTiffWriter::writeARGB32Image(\n    TiffHandle const& tif, QImage const& image, bool multipage, int compression)\n{\n    assert(image.format() == QImage::Format_ARGB32);\n\n    TIFFSetField(tif.handle(), TIFFTAG_SAMPLESPERPIXEL, uint16(4));\n    TIFFSetField(tif.handle(), TIFFTAG_COMPRESSION, uint16(compression));\n    TIFFSetField(tif.handle(), TIFFTAG_BITSPERSAMPLE, uint16(8));\n    TIFFSetField(tif.handle(), TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    if (GlobalStaticSettings::m_use_horizontal_predictor) {\n        TIFFSetField(tif.handle(), TIFFTAG_PREDICTOR, PREDICTOR_HORIZONTAL);\n    }\n\n    int const width = image.width();\n    int const height = image.height();\n\n    std::vector<uint8_t> tmp_line(width * 4);\n\n    // Libtiff expects \"RR GG BB AA\" sequences regardless of CPU byte order.\n\n    for (int y = 0; y < height; ++y) {\n        uint32_t const* p_src = (uint32_t const*)image.scanLine(y);\n        uint8_t* p_dst = &tmp_line[0];\n        for (int x = 0; x < width; ++x) {\n            uint32_t const ARGB = *p_src;\n            p_dst[0] = static_cast<uint8_t>(ARGB >> 16);\n            p_dst[1] = static_cast<uint8_t>(ARGB >> 8);\n            p_dst[2] = static_cast<uint8_t>(ARGB);\n            p_dst[3] = static_cast<uint8_t>(ARGB >> 24);\n            ++p_src;\n            p_dst += 4;\n        }\n        if (TIFFWriteScanline(tif.handle(), &tmp_line[0], y) == -1) {\n            return false;\n        }\n    }\n\n    if (multipage && (TIFFWriteDirectory(tif.handle()) == -1)) {\n        return false;\n    }\n\n    return true;\n}",
    "bool MainWindow::SaveTiffMulti(std::string filename)\n{\n    char *file = &filename[0u];\n    TIFF *out = TIFFOpen(file,\"w\") ;\n\n    if (out) {\n        int NPAGES = ui->listWidget_labels->count() +1; // number of page = nb labels + image\n\n        //// image\n        uint32 imagelength = image.rows;\n        uint32 imagewidth = image.cols;\n        uint8 * buf;\n        uint32 row, col;\n        uint16 nsamples = 3;\n\n        TIFFSetField(out, TIFFTAG_IMAGELENGTH, imagelength); // image length\n        TIFFSetField(out, TIFFTAG_IMAGEWIDTH, imagewidth); // image width\n        TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); // organized by RGB instead of channel\n        TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, nsamples); // number of channels per pixel\n        TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_LZW); // compression\n        TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8) ; // size of the channels\n        TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(out, imagewidth*nsamples)); // strip size of the file to be size of one row of pixels\n        TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT); // set the origin of the image\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB); // RGB image\n        TIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, \"background\"); // label name\n        TIFFSetField(out, TIFFTAG_SOFTWARE, \"Superpixels Segmentation GUI with openCV by AbsurdePhoton www.absurdephoton.fr\"); // software used\n\n        /* We are writing single page of the multipage file */\n        TIFFSetField(out, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE); // new page\n        TIFFSetField(out, TIFFTAG_PAGENUMBER, 0, NPAGES); // page number\n\n        buf = new uint8 [imagewidth*nsamples] ;\n\n        for (row = 0; row < imagelength; row++) {\n            for(col=0; col < imagewidth; col++) {\n                //writing data - order = RGB\n                Vec3b c = image.at<Vec3b>(row, col);\n                buf[col*nsamples+0] = c[2];\n                buf[col*nsamples+1] = c[1];\n                buf[col*nsamples+2] = c[0];\n            }\n            if (TIFFWriteScanline(out, buf, row) != 1 ) {\n                return false;\n            }\n        }\n        TIFFWriteDirectory(out);\n        _TIFFfree(buf);\n\n        //// Layers\n        int page;\n        for (page = 0; page < (NPAGES - 1); page++){\n            QListWidgetItem *item = ui->listWidget_labels->item(page);\n            QColor c = item->background().color();\n            int nLabel = item->data(Qt::UserRole).toInt();\n            std::string name = item->text().toUtf8().constData();\n\n            uint32 imagelength = image.rows;\n            uint32 imagewidth = image.cols;\n            uint8 * buf;\n            uint32 row, col;\n            uint16 nsamples = 4;\n\n            TIFFSetField(out, TIFFTAG_IMAGELENGTH, imagelength); // image length\n            TIFFSetField(out, TIFFTAG_IMAGEWIDTH, imagewidth); // image width\n            TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); // organized by RGB instead of channel\n            TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, nsamples); // number of channels per pixel\n            TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_LZW); // compression\n            TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8) ; // size of the channels\n            TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(out, imagewidth*nsamples)); // strip size of the file to be size of one row of pixels\n            TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT); // set the origin of the image\n            TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB); // RGB image\n            TIFFSetField(out, TIFFTAG_EXTRASAMPLES, EXTRASAMPLE_ASSOCALPHA); // extra byte is alpha value\n            TIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, name); // label name\n            TIFFSetField(out, TIFFTAG_PAGENAME, name); // label name\n            TIFFSetField(out, TIFFTAG_SOFTWARE, \"Superpixels Segmentation GUI with openCV by AbsurdePhoton www.absurdephoton.fr\"); // software used\n\n            /* We are writing single page of the multipage file */\n            TIFFSetField(out, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE); // new page\n            TIFFSetField(out, TIFFTAG_PAGENUMBER, page + 1, NPAGES); // page number\n\n            buf = new uint8 [imagewidth*nsamples] ;\n\n            for (row = 0; row < imagelength; row++) {\n                for(col=0; col < imagewidth; col++) {\n                    //writing data - order = RGB\n                    int currentLabel = labels_mask.at<int>(row,col);\n                    if (currentLabel == nLabel) {\n                        buf[col*nsamples+0] = c.red();\n                        buf[col*nsamples+1] = c.green();\n                        buf[col*nsamples+2] = c.blue();\n                        buf[col*nsamples+3] = 255;\n                    }\n                    else {\n                        buf[col*nsamples+0] = 0;\n                        buf[col*nsamples+1] = 0;\n                        buf[col*nsamples+2] = 0;\n                        buf[col*nsamples+3] = 0;\n                    }\n                }\n                if (TIFFWriteScanline(out, buf, row) != 1 ) {\n                    return false;\n                }\n            }\n            TIFFWriteDirectory(out);\n            _TIFFfree(buf);\n        }\n        TIFFClose(out);\n    }\n    return true;\n}",
    "void ImageWriteTIFF(\n      Image const& image,\n      String const& filename,\n      String const& compression,\n      dip::uint jpegLevel\n) {\n   DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED );\n   DIP_THROW_IF( image.Dimensionality() != 2 && image.Dimensionality() != 3, E::DIMENSIONALITY_NOT_SUPPORTED );\n\n   dip::uint nSlices = image.Dimensionality() == 3 ? image.Size( 2 ) : 1;\n   // Get image info and quit if we can't write\n   DIP_THROW_IF(( image.Size( 0 ) > std::numeric_limits< uint32 >::max() ) ||\n                ( image.Size( 1 ) > std::numeric_limits< uint32 >::max() ) ||\n                ( nSlices > std::numeric_limits< uint32 >::max()), \"Image size too large for TIFF file\" );\n   uint32 imageWidth = static_cast< uint32 >( image.Size( 0 ));\n   uint32 imageLength = static_cast< uint32 >( image.Size( 1 ));\n   dip::uint sizeOf = image.DataType().SizeOf();\n   uint16 bitsPerSample = 0;\n   uint16 sampleFormat = 0;\n   if( image.DataType().IsBinary() ) {\n      DIP_THROW_IF( !image.IsScalar(), E::IMAGE_NOT_SCALAR ); // Binary images should not have multiple samples per pixel\n   } else {\n      bitsPerSample = static_cast< uint16 >( sizeOf * 8 );\n      switch( image.DataType() ) {\n         case DT_UINT8:\n         case DT_UINT16:\n         case DT_UINT32:\n         case DT_UINT64:\n            sampleFormat = SAMPLEFORMAT_UINT;\n            break;\n         case DT_SINT8:\n         case DT_SINT16:\n         case DT_SINT32:\n         case DT_SINT64:\n            sampleFormat = SAMPLEFORMAT_INT;\n            break;\n         case DT_SFLOAT:\n         case DT_DFLOAT:\n            sampleFormat = SAMPLEFORMAT_IEEEFP;\n            break;\n         default:\n            DIP_THROW( \"Data type of image is not compatible with TIFF\" );\n            break;\n      }\n   }\n   uint16 compmode = CompressionTranslate( compression );\n\n   // Create the TIFF file and set the tags\n   TiffFile tiff( filename );\n\n   for( dip::uint slice = 0; slice < nSlices; slice++ ) {\n      if( slice > 0 ) {\n         TIFFWriteDirectory( tiff );\n      }\n\n      if( image.DataType().IsBinary() ) {\n         WRITE_TIFF_TAG( tiff, TIFFTAG_PHOTOMETRIC, uint16( PHOTOMETRIC_MINISBLACK ));\n      } else if(( image.ColorSpace() == \"RGB\" ) || ( image.ColorSpace() == \"sRGB\" )){\n         WRITE_TIFF_TAG( tiff, TIFFTAG_PHOTOMETRIC, uint16( PHOTOMETRIC_RGB )); // TODO: Both linear RGB and non-linear sRGB are mapped to 'RGB' photometric interpretation, not ideal.\n      } else if( image.ColorSpace() == \"Lab\" ) {\n         WRITE_TIFF_TAG( tiff, TIFFTAG_PHOTOMETRIC, uint16( PHOTOMETRIC_CIELAB ));\n      } else if(( image.ColorSpace() == \"CMY\" ) || ( image.ColorSpace() == \"CMYK\" )) {\n         WRITE_TIFF_TAG( tiff, TIFFTAG_PHOTOMETRIC, uint16( PHOTOMETRIC_SEPARATED ));\n      } else {\n         WRITE_TIFF_TAG( tiff, TIFFTAG_PHOTOMETRIC, uint16( PHOTOMETRIC_MINISBLACK ));\n      }\n\n      WRITE_TIFF_TAG( tiff, TIFFTAG_IMAGEWIDTH, imageWidth );\n      WRITE_TIFF_TAG( tiff, TIFFTAG_IMAGELENGTH, imageLength );\n\n      if( !image.DataType().IsBinary() ) {\n         WRITE_TIFF_TAG( tiff, TIFFTAG_BITSPERSAMPLE, bitsPerSample );\n         WRITE_TIFF_TAG( tiff, TIFFTAG_SAMPLEFORMAT, sampleFormat );\n         WRITE_TIFF_TAG( tiff, TIFFTAG_SAMPLESPERPIXEL, static_cast< uint16 >( image.TensorElements() ));\n         if( image.TensorElements() > 1 ) {\n            WRITE_TIFF_TAG( tiff, TIFFTAG_PLANARCONFIG, uint16( PLANARCONFIG_CONTIG ));\n            // This is the standard way of writing channels (planes), PLANARCONFIG_SEPARATE is not required to be\n            // supported by all readers.\n         }\n      }\n\n      WRITE_TIFF_TAG( tiff, TIFFTAG_COMPRESSION, compmode );\n      if( compmode == COMPRESSION_JPEG ) {\n         jpegLevel = clamp< dip::uint >( jpegLevel, 1, 100 );\n         WRITE_TIFF_TAG( tiff, TIFFTAG_JPEGQUALITY, static_cast< int >( jpegLevel ));\n         WRITE_TIFF_TAG( tiff, TIFFTAG_JPEGCOLORMODE, int( JPEGCOLORMODE_RGB ));\n      }\n\n      DIP_STACK_TRACE_THIS( WriteTIFFStrips( image, tiff, slice ));\n\n      TIFFSetField( tiff, TIFFTAG_SOFTWARE, \"DIPlib \" DIP_VERSION_STRING );\n\n      auto ps = image.PixelSize( 0 );\n      if( ps.units.HasSameDimensions( Units::Meter() )) {\n         ps.RemovePrefix();\n         TIFFSetField( tiff, TIFFTAG_XRESOLUTION, static_cast< float >( 0.01 / ps.magnitude ));\n      }\n      ps = image.PixelSize( 1 );\n      if( ps.units.HasSameDimensions( Units::Meter() )) {\n         ps.RemovePrefix();\n         TIFFSetField( tiff, TIFFTAG_YRESOLUTION, static_cast< float >( 0.01 / ps.magnitude ));\n      }\n      TIFFSetField( tiff, TIFFTAG_RESOLUTIONUNIT, uint16( RESUNIT_CENTIMETER ));\n   }\n}",
    "bool\nTIFFOutput::write_exif_data()\n{\n#if defined(TIFF_VERSION_BIG) && OIIO_TIFFLIB_VERSION >= 40003\n    // Older versions of libtiff do not support writing Exif directories\n\n    if (m_spec.get_int_attribute(\"tiff:write_exif\", 1) == 0) {\n        // The special metadata \"tiff:write_exif\", if present and set to 0\n        // (the default is 1), will cause us to skip outputting Exif data.\n        // This is useful in cases where we think the TIFF file will need to\n        // be read by an app that links against an old version of libtiff\n        // that will have trouble reading the Exif directory.\n        return true;\n    }\n\n    // First, see if we have any Exif data at all\n    bool any_exif = false;\n    for (size_t i = 0, e = m_spec.extra_attribs.size(); i < e; ++i) {\n        const ParamValue& p(m_spec.extra_attribs[i]);\n        int tag, tifftype, count;\n        if (exif_tag_lookup(p.name(), tag, tifftype, count)\n            && tifftype != TIFF_NOTYPE) {\n            if (tag == EXIF_SECURITYCLASSIFICATION || tag == EXIF_IMAGEHISTORY\n                || tag == EXIF_PHOTOGRAPHICSENSITIVITY)\n                continue;  // libtiff doesn't understand these\n            any_exif = true;\n            break;\n        }\n    }\n    if (!any_exif)\n        return true;\n\n#    if ENABLE_JPEG_COMPRESSION\n    if (m_compression == COMPRESSION_JPEG) {\n        // For reasons we don't understand, JPEG-compressed TIFF seems\n        // to not output properly without a directory checkpoint here.\n        TIFFCheckpointDirectory(m_tif);\n    }\n#    endif\n\n    // First, finish writing the current directory\n    if (!TIFFWriteDirectory(m_tif)) {\n        errorfmt(\"failed TIFFWriteDirectory()\");\n        return false;\n    }\n\n    // Create an Exif directory\n    if (TIFFCreateEXIFDirectory(m_tif) != 0) {\n        errorfmt(\"failed TIFFCreateEXIFDirectory()\");\n        return false;\n    }\n\n    for (size_t i = 0, e = m_spec.extra_attribs.size(); i < e; ++i) {\n        const ParamValue& p(m_spec.extra_attribs[i]);\n        int tag, tifftype, count;\n        if (exif_tag_lookup(p.name(), tag, tifftype, count)\n            && tifftype != TIFF_NOTYPE) {\n            if (tag == EXIF_SECURITYCLASSIFICATION || tag == EXIF_IMAGEHISTORY\n                || tag == EXIF_PHOTOGRAPHICSENSITIVITY)\n                continue;  // libtiff doesn't understand these\n            bool ok = false;\n            if (tifftype == TIFF_ASCII) {\n                ok = TIFFSetField(m_tif, tag, *(char**)p.data());\n            } else if ((tifftype == TIFF_SHORT || tifftype == TIFF_LONG)\n                       && p.type() == TypeDesc::SHORT) {\n                ok = TIFFSetField(m_tif, tag, (int)*(short*)p.data());\n            } else if ((tifftype == TIFF_SHORT || tifftype == TIFF_LONG)\n                       && p.type() == TypeDesc::INT) {\n                ok = TIFFSetField(m_tif, tag, *(int*)p.data());\n            } else if ((tifftype == TIFF_RATIONAL || tifftype == TIFF_SRATIONAL)\n                       && p.type() == TypeDesc::FLOAT) {\n                ok = TIFFSetField(m_tif, tag, *(float*)p.data());\n            } else if ((tifftype == TIFF_RATIONAL || tifftype == TIFF_SRATIONAL)\n                       && p.type() == TypeDesc::DOUBLE) {\n                ok = TIFFSetField(m_tif, tag, *(double*)p.data());\n            }\n            if (!ok) {\n                // std::cout << \"Unhandled EXIF \" << p.name() << \" \" << p.type() << \"\\n\";\n            }\n        }\n    }\n\n    // Now write the directory of Exif data\n#    ifndef TIFF_GCC_DEPRECATED\n    uint64 dir_offset = 0;  // old type\n#    else\n    uint64_t dir_offset = 0;\n#    endif\n    if (!TIFFWriteCustomDirectory(m_tif, &dir_offset)) {\n        errorfmt(\"failed TIFFWriteCustomDirectory() of the Exif data\");\n        return false;\n    }\n    // Go back to the first directory, and add the EXIFIFD pointer.\n    // std::cout << \"diffdir = \" << tiffdir << \"\\n\";\n    TIFFSetDirectory(m_tif, 0);\n    TIFFSetField(m_tif, TIFFTAG_EXIFIFD, dir_offset);\n#endif\n\n    return true;  // all is ok\n}",
    "char *initTiff3DFile ( char *filename, unsigned int sz0, unsigned int sz1, unsigned int sz2, unsigned int sz3, int datatype ) {\r\n//int initTiff3DFile ( char *filename, uint32 XSIZE, uint32 YSIZE, uint16 spp, uint16 Npages, int datatype){\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffInitData)\r\n    #endif\r\n\r\n\tuint32 XSIZE  = sz0;\r\n\tuint32 YSIZE  = sz1;\r\n\tuint16 Npages = sz2;\r\n\tuint16 spp    = sz3;\r\n\r\n\tuint16 bpp=8 * datatype;\r\n\tunsigned char *fakeData=new unsigned char[XSIZE * YSIZE];\r\n\t\r\n\tint check;\r\n\r\n\tif ( sz3 == 1 )\r\n\t\tspp = sz3; \r\n\telse if ( sz3 < 4 )\r\n\t\tspp = 3;\r\n\telse\r\n\t\treturn ((char *) \"More than 3 channels in Tiff files.\");\r\n\r\n\tchar *completeFilename = (char *) 0;\r\n\tint fname_len = (int) strlen(filename);\r\n\tchar *suffix = strstr(filename,\".tif\");\r\n\twhile ( suffix && (fname_len - (suffix-filename) > 5) )\r\n\t\tsuffix = strstr(suffix+4,\".tif\");\r\n\t//if ( (suffix != 0) && (fname_len - (suffix-filename) <= 5) ) { // a substring \".tif is already at the end of the filename\r\n\tif ( suffix ) { // a substring \".tif is already at the very end of the filename\r\n\t\tcompleteFilename = new char[fname_len+1];\r\n\t\tstrcpy(completeFilename,filename);\r\n\t}\r\n\telse {\t\r\n\t\tcompleteFilename = new char[fname_len+4+1];\r\n\t\tstrcpy(completeFilename,filename);\r\n\t\tstrcat(completeFilename,\".\");\r\n\t\tstrcat(completeFilename,TIFF3D_SUFFIX);\r\n\t}\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffInitData, itm::CPU, itm::strprintf(\"generated fake data for 3D tiff \\\"%s\\\"\", completeFilename))\r\n    TERAFLY_TIME_RESTART(TiffInitData)\r\n    #endif\r\n\r\n\tTIFF *output;\r\n\toutput = TIFFOpen(completeFilename,\"w\");\r\n\tif (!output) {\r\n\t\treturn ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_IMAGEWIDTH, XSIZE);\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the image width.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_IMAGELENGTH, YSIZE);\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the image width.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, bpp); \r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the image width.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, spp);\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the image width.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, YSIZE); // one page per strip\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the image height.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the compression tag.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the planarconfig tag.\");\r\n    }\r\n\r\n\tif ( spp == 1 )\r\n\t\tcheck = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\t\r\n\telse // spp == 3\r\n\t\tcheck = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\t\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the photometric tag.\");\r\n    }\r\n\r\n\t/* We are writing single page of the multipage file */\r\n\tcheck = TIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the subfiletype tag.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_PAGENUMBER, 0, Npages); \r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the page number.\");\r\n    }\r\n\r\n\r\n\tcheck = (int)TIFFWriteEncodedStrip(output, 0, fakeData, XSIZE * YSIZE);\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot write encoded strip to file.\");\r\n    }\r\n\r\n\tdelete[] fakeData;\r\n\tdelete []completeFilename;\r\n\r\n\tcheck = TIFFWriteDirectory(output);\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot write a new directory.\");\r\n    }\r\n\r\n\tTIFFClose(output);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffInitData, itm::IO, itm::strprintf(\"written initialized 3D tiff \\\"%s\\\"\", completeFilename))\r\n    #endif\r\n\r\n\treturn (char *) 0;\r\n}",
    "char *appendSlice2Tiff3DFile ( char *filename, int slice, unsigned char *img, unsigned int img_width, unsigned int img_height ) {\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffAppendData)\r\n    #endif\r\n\r\n\tTIFF *output;\r\n\tuint16 spp, bpp, NPages, pg0;\r\n\r\n\toutput=TIFFOpen(filename,\"r\");\r\n\tTIFFGetField(output, TIFFTAG_BITSPERSAMPLE, &bpp); \r\n\tTIFFGetField(output, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tTIFFGetField(output, TIFFTAG_PAGENUMBER, &pg0, &NPages);\r\n\tTIFFClose(output);\r\n\t// since we are \r\n\toutput = (slice==0)? TIFFOpen(filename,\"w\") : TIFFOpen(filename,\"a\");\r\n\r\n\tTIFFSetDirectory(output,slice); // WARNING: slice must be the first page after the last, otherwise the file can be corrupted\r\n\r\n\tTIFFSetField(output, TIFFTAG_IMAGEWIDTH, img_width);\r\n\tTIFFSetField(output, TIFFTAG_IMAGELENGTH, img_height);\r\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, bpp); \r\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, spp);\r\n\tTIFFSetField(output, TIFFTAG_ROWSPERSTRIP, img_height);\r\n\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\t//TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\r\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\t\r\n\t//TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\t\r\n\t// We are writing single page of the multipage file \r\n\tTIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n\tTIFFSetField(output, TIFFTAG_PAGENUMBER, (uint16)slice, NPages); \r\n\r\n\tTIFFWriteEncodedStrip(output, 0, img, img_width * img_height * spp * (bpp/8));\r\n\t//img +=  img_width * img_height;\r\n\r\n\tTIFFWriteDirectory(output);\r\n\r\n\tTIFFClose(output);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffAppendData, itm::IO, itm::strprintf(\"appended slice %d x %d to 3D tiff \\\"%s\\\"\", img_width, img_height, filename))\r\n    #endif\r\n\r\n\treturn (char *) 0;\r\n}",
    "char *appendSlice2Tiff3DFile ( void *fhandler, int slice, unsigned char *img, unsigned int  img_width, unsigned int  img_height, int spp, int bpp, int NPages ) {\r\n\tTIFF *output = (TIFF *) fhandler;\r\n\r\n\tTIFFSetDirectory(output,slice); // WARNING: slice must be the first page after the last, otherwise the file can be corrupted\r\n\r\n\tTIFFSetField(output, TIFFTAG_IMAGEWIDTH, img_width);\r\n\tTIFFSetField(output, TIFFTAG_IMAGELENGTH, img_height);\r\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, (uint16)bpp); \r\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, (uint16)spp);\r\n\tTIFFSetField(output, TIFFTAG_ROWSPERSTRIP, img_height);\r\n\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\t//TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\r\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\t\r\n\t//TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\t\r\n\t// We are writing single page of the multipage file \r\n\tTIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n\tTIFFSetField(output, TIFFTAG_PAGENUMBER, (uint16)slice, (uint16)NPages); \r\n\r\n\tTIFFWriteEncodedStrip(output, 0, img, img_width * img_height * spp * (bpp/8));\r\n\t//img +=  img_width * img_height;\r\n\r\n\tTIFFWriteDirectory(output);\r\n\r\n\treturn (char *) 0;\r\n}",
    "void writetiff( char *myfile, unsigned char *img, int channels, int width, int height, int depth )\n//===================================================================================================\n{\n    TIFF* tif = TIFFOpen(myfile, \"w\");\n    if (tif)\n    {\n\t\tfor(int layerIndex = 0; layerIndex < depth ; layerIndex++)\n\t\t{\n\t\t\t//set tiff tags to generate an uncompressed TIFF image\n\t\t\t//SETTAGS( tif, width, height, channels );\n\t\t\t//dimensions of the image\n\t\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH,  width);\n\t\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n\t\t\t\n\t\t\t//starting from top-left corner\n\t\t\tTIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\t\t\n\t\t\t//grayscale or color image\n\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels);\n\t\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n\t\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\t\tif (channels == 1)\n\t\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\t\t\telse\n\t\t\t\tif (channels == 3)\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t\t\t\n\t\t\t//Miscalleneous Tags\n\t\t\tTIFFSetField( tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\t\tTIFFSetField( tif, TIFFTAG_COMPRESSION , COMPRESSION_NONE );\n\t\t\tTIFFSetField( tif, TIFFTAG_ROWSPERSTRIP,\n\t\t\t\t\t\t TIFFDefaultStripSize(tif , (uint32) -1) );\n\t\t\tTIFFSetField(tif, TIFFTAG_XRESOLUTION, 72);\n\t\t\tTIFFSetField(tif, TIFFTAG_YRESOLUTION, 72);\n\t\t\tTIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\t\t\t\n\t\t\t//create a dummy array\n\t\t\tint linebytes = channels*width;\n\t\t\tunsigned char *buf = new unsigned char[linebytes];\n\t\t\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tif, linebytes));\n\t\t\t\n\t\t\t//start writing the data into the TIFF file in scanlines\n\t\t\tfor ( int row = 0; row < height; row++)\n\t\t\t{\n\t\t\t\t//check if a grayscale or color image is being written\n\t\t\t\tmemcpy(buf, &img[layerIndex*width*height*channels+row*linebytes], linebytes);\n\t\t\t\t\n\t\t\t\tif (TIFFWriteScanline(tif, buf, row, 0) < 0)\n\t\t\t\t{\n\t\t\t\t\tcerr<<\"Error in scanline while writing !\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete(buf);\n\t\t\tTIFFWriteDirectory(tif);\n\t\t}\n        TIFFClose(tif);\n    }\n    else\n    {\n        cerr<<\"Unable to open file for writing !\\n\";\n    }\n}",
    "char *initTiff3DFile(char *filename, int sz0, int sz1, int sz2, int sz3, int datatype)\n{   \n    //\n    uint32 XSIZE  = sz0;\n    uint32 YSIZE  = sz1;\n    uint16 Npages = sz2;\n    uint16 spp    = sz3;\n\n    uint16 bpp=8 * datatype;\n\n    int rowsPerStrip = -1;\n\n    int check;\n\n    if ( sz3 == 1 )\n        spp = sz3;\n    else if ( sz3 < 4 )\n        spp = 3;\n    else\n        return ((char *) \"More than 3 channels in Tiff files.\");\n\n    //\n    long szSlice = (long)XSIZE * (long)YSIZE * (long)spp * (long)datatype;\n    unsigned char *fakeData=NULL;\n    try\n    {\n        fakeData = new unsigned char[ szSlice ];\n        memset(fakeData,0,szSlice);\n    }\n    catch(...)\n    {\n        return ((char *)\"Fail to alloc memory\\n\");\n    }\n\n    //disable warning and error handlers to avoid messages on unrecognized tags\n    TIFFSetWarningHandler(0);\n    TIFFSetErrorHandler(0);\n\n    TIFF *output;\n\n    long expectedSize = ((long) sz0) * ((long) sz1) * ((long) sz2) * ((long) sz3) * ((long) datatype);\n    long fourGBSize = 4;\n    fourGBSize *= 1024;\n    fourGBSize *= 1024;\n    fourGBSize *= 1024;\n\n    if ( expectedSize > (fourGBSize) )\n    {\n        if ( (rowsPerStrip == -1 && (((long) sz0) * ((long) sz1)) > (fourGBSize)) || ((rowsPerStrip * ((long) sz0)) > (fourGBSize)) )\n            return ((char *) \"Too many rows per strip for this image width.\");\n        else\n            output = TIFFOpen(filename,\"w8\");\n    }\n    else\n    {\n        output = TIFFOpen(filename,\"w\");\n    }\n\n    if (!output)\n    {\n        return ((char *) \"Cannot open the file.\");\n    }\n\n    //\n    if ( rowsPerStrip == -1 )\n    {\n        for(long slice=0; slice<Npages; slice++)\n        {\n            //\n            TIFFSetDirectory(output, slice);\n\n            //\n            check = TIFFSetField(output, TIFFTAG_IMAGEWIDTH, XSIZE);\n            if (!check) {\n                return ((char *) \"Cannot set the image width.\");\n            }\n\n            check = TIFFSetField(output, TIFFTAG_IMAGELENGTH, YSIZE);\n            if (!check) {\n                return ((char *) \"Cannot set the image height.\");\n            }\n\n            check = TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, bpp);\n            if (!check) {\n                return ((char *) \"Cannot set the image bit per sample.\");\n            }\n\n            check = TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, spp);\n            if (!check) {\n                return ((char *) \"Cannot set the image sample per pixel.\");\n            }\n\n            check = TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, (rowsPerStrip == -1) ? YSIZE : (uint32)rowsPerStrip);\n            if (!check) {\n                return ((char *) \"Cannot set the image rows per strip.\");\n            }\n\n            check = TIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n            if (!check) {\n                return ((char *) \"Cannot set the image orientation.\");\n            }\n\n            check = TIFFSetField(output, TIFFTAG_COMPRESSION, COMPPRESSION_METHOD);\n            if (!check) {\n                return ((char *) \"Cannot set the compression tag.\");\n            }\n\n            check = TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n            if (!check) {\n                return ((char *) \"Cannot set the planarconfig tag.\");\n            }\n\n            if ( spp == 1 )\n                check = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n            else // spp == 3\n                check = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n            if (!check) {\n                return ((char *) \"Cannot set the photometric tag.\");\n            }\n\n            /* We are writing single page of the multipage file */\n            check = TIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n            if (!check) {\n                return ((char *) \"Cannot set the subfiletype tag.\");\n            }\n\n            check = TIFFSetField(output, TIFFTAG_PAGENUMBER, slice, Npages);\n            if (!check) {\n                return ((char *) \"Cannot set the page number.\");\n            }\n\n            if(!TIFFWriteEncodedStrip(output, 0, fakeData, szSlice))\n            {\n                return ((char *) \"Cannot write encoded strip to file.\");\n            }\n\n            //\n            if (!TIFFWriteDirectory(output))\n            {\n                return ((char *) \"Cannot write a new directory.\");\n            }\n        }\n    }\n    else\n    {\n        // TODO: modify codes to save 3D image stack later\n\n        //\n        // save one slice\n        //\n        int check,StripsPerImage,LastStripSize;\n        uint32 rps = (uint32)rowsPerStrip;\n        unsigned char *buf = fakeData;\n\n        StripsPerImage =  (YSIZE + rps - 1) / rps;\n        LastStripSize = YSIZE % rps;\n        if (LastStripSize==0)\n            LastStripSize=rps;\n\n        for (int i=0; i < StripsPerImage-1; i++){\n            check = TIFFWriteEncodedStrip(output, i, buf, spp * rps * XSIZE * (bpp/8));\n            if (!check) {\n                return ((char *) \"Cannot write encoded strip to file.\");\n            }\n            buf = buf + spp * rps * XSIZE * (bpp/8);\n        }\n\n        check = TIFFWriteEncodedStrip(output, StripsPerImage-1, buf, spp * LastStripSize * XSIZE * (bpp/8));\n        if (!check) {\n            return ((char *) \"Cannot write encoded strip to file.\");\n        }\n        buf = buf + spp * LastStripSize * XSIZE * (bpp/8);\n    }\n\n    //\n    if(fakeData)\n    {\n        delete[] fakeData;\n    }\n\n    //\n    TIFFClose(output);\n\n    //\n    return (char *) 0;\n}",
    "char *appendSlice2Tiff3DFile(void *fhandler, int slice, unsigned char *img, unsigned int img_width, unsigned int img_height, int spp, int bpp, int NPages)\n{\n    //\n    int rowsPerStrip = -1;\n\n    //\n    TIFF *output = (TIFF *) fhandler;\n\n    // WARNING: slice must be the first page after the last, otherwise the file can be corrupted\n    TIFFSetDirectory(output,slice);\n\n    TIFFSetField(output, TIFFTAG_IMAGEWIDTH, img_width);\n    TIFFSetField(output, TIFFTAG_IMAGELENGTH, img_height);\n    TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, (uint16)bpp);\n    TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, (uint16)spp);\n    TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, (rowsPerStrip == -1) ? img_height : (uint32)rowsPerStrip);\n    TIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(output, TIFFTAG_COMPRESSION, COMPPRESSION_METHOD);\n    TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n    if ( spp == 1 )\n        TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    else // spp == 3\n        TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    // We are writing single page of the multipage file\n    TIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n    TIFFSetField(output, TIFFTAG_PAGENUMBER, (uint16)slice, (uint16)NPages);\n\n    // the file has been already opened: rowsPerStrip it is not too large for this image width\n    if ( rowsPerStrip == -1 )\n    {\n        TIFFWriteEncodedStrip(output, 0, img, img_width * img_height * spp * (bpp/8));\n    }\n    else\n    {\n        int StripsPerImage,LastStripSize;\n        uint32 rps = (uint32)rowsPerStrip;\n        unsigned char *buf = img;\n\n        StripsPerImage =  (img_height + rps - 1) / rps;\n        LastStripSize = img_height % rps;\n        if (LastStripSize==0)\n            LastStripSize=rps;\n\n        for (int i=0; i < StripsPerImage-1; i++){\n            TIFFWriteEncodedStrip(output, i, buf, spp * rps * img_width * (bpp/8));\n            buf = buf + spp * rps * img_width * (bpp/8);\n        }\n\n        TIFFWriteEncodedStrip(output, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\n        buf = buf + spp * LastStripSize * img_width * (bpp/8);\n    }\n\n    TIFFWriteDirectory(output);\n\n    //\n    return (char *) 0;\n}",
    "char *tiffwrite(char* filename, unsigned char *p, uint32 sz0, uint32  sz1, uint32  sz2, uint16 datatype, uint16 comp)\n{\n\n    TIFF *output = TIFFOpen(filename,\"w\");\n\n    //\n    if(sz2>1)\n    {\n        // 3D TIFF\n        for(long slice=0; slice<sz2; slice++)\n        {\n            TIFFSetDirectory(output,slice);\n\n            TIFFSetField(output, TIFFTAG_IMAGEWIDTH, sz0);\n            TIFFSetField(output, TIFFTAG_IMAGELENGTH, sz1);\n            TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, (uint16)(datatype*8));\n            TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, 1);\n            TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, sz1);\n            TIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n            TIFFSetField(output, TIFFTAG_COMPRESSION, comp);\n            TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n            //TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n            TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\n            // We are writing single page of the multipage file\n            TIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n            TIFFSetField(output, TIFFTAG_PAGENUMBER, (uint16)slice, (uint16)sz2);\n\n            // the file has been already opened: rowsPerStrip it is not too large for this image width\n            TIFFWriteEncodedStrip(output, 0, p, sz0 * sz1 * datatype);\n\n            TIFFWriteDirectory(output);\n        }\n    }\n    else\n    {\n        // 2D TIFF\n        TIFFSetField(output, TIFFTAG_IMAGEWIDTH, sz0);\n        TIFFSetField(output, TIFFTAG_IMAGELENGTH, sz1);\n        TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, (uint16)(datatype*8));\n        TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, 1);\n        TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, sz1);\n        TIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n        TIFFSetField(output, TIFFTAG_COMPRESSION, comp);\n        TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n        TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\n        // the file has been already opened: rowsPerStrip it is not too large for this image width\n        TIFFWriteEncodedStrip(output, 0, p, sz0 * sz1 * datatype);\n\n        //\n        TIFFWriteDirectory(output);\n    }\n\n    //\n    TIFFClose(output);\n\n    //\n    return ((char *) 0);\n}",
    "char *initTiff3DFile ( char *filename, unsigned int sz0, unsigned int sz1, unsigned int sz2, unsigned int sz3, int datatype ) {\r\n    //int initTiff3DFile ( char *filename, uint32 XSIZE, uint32 YSIZE, uint16 spp, uint16 Npages, int datatype){\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffInitData);\r\n    #endif\r\n\r\n    uint32 XSIZE  = sz0;\r\n    uint32 YSIZE  = sz1;\r\n    uint16 Npages = sz2;\r\n    uint16 spp    = sz3;\r\n\r\n    uint16 bpp=8 * datatype;\r\n\r\n    int check;\r\n\r\n    if ( sz3 == 1 )\r\n        spp = sz3;\r\n    else if ( sz3 < 4 )\r\n        spp = 3;\r\n    else\r\n        return ((char *) \"More than 3 channels in Tiff files.\");\r\n\r\n    //\r\n    long szSlice = ((iim::sint64) XSIZE) * ((iim::sint64) YSIZE) * spp * (bpp/8);\r\n    unsigned char *fakeData=NULL;\r\n    try\r\n    {\r\n        fakeData = new unsigned char[ szSlice ];\r\n        memset(fakeData,0,szSlice);\r\n    }\r\n    catch(...)\r\n    {\r\n        return ((char *)\"Fail to alloc memory\\n\");\r\n    }\r\n\r\n    char *completeFilename = (char *) 0;\r\n    int fname_len = (int) strlen(filename);\r\n    char *suffix = strstr(filename,\".tif\");\r\n    while ( suffix && (fname_len - (suffix-filename) > 5) )\r\n        suffix = strstr(suffix+4,\".tif\");\r\n    //if ( (suffix != 0) && (fname_len - (suffix-filename) <= 5) ) { // a substring \".tif is already at the end of the filename\r\n    if ( suffix ) { // a substring \".tif is already at the very end of the filename\r\n        completeFilename = new char[fname_len+1];\r\n        strcpy(completeFilename,filename);\r\n    }\r\n    else {\r\n        completeFilename = new char[fname_len+4+1];\r\n        strcpy(completeFilename,filename);\r\n        strcat(completeFilename,\".\");\r\n        strcat(completeFilename,TIFF3D_SUFFIX);\r\n    }\r\n\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffInitData, tf::CPU, tf::strprintf(\"generated fake data for 3D tiff \\\"%s\\\"\", completeFilename));\r\n    TERAFLY_TIME_RESTART(TiffInitData);\r\n    #endif\r\n\r\n    //disable warning and error handlers to avoid messages on unrecognized tags\r\n    TIFFSetWarningHandler(0);\r\n    TIFFSetErrorHandler(0);\r\n\r\n    TIFF *output;\r\n\r\n    iim::sint64 expectedSize = ((iim::sint64) sz0) * ((iim::sint64) sz1) * ((iim::sint64) sz2) * ((iim::sint64) sz3) * ((iim::sint64) datatype);\r\n\r\n    if ( bigtiff || expectedSize > (4*GBSIZE) ) {\r\n        if ( (rowsPerStrip == -1 && (((iim::sint64) sz0) * ((iim::sint64) sz1)) > (4*GBSIZE)) || ((rowsPerStrip * ((iim::sint64) sz0)) > (4*GBSIZE)) )\r\n            // one strip is larger than 4GB\r\n            return ((char *) \"Too many rows per strip for this image width.\");\r\n        else\r\n            output = TIFFOpen(completeFilename,\"w8\");\r\n    }\r\n    else\r\n        output = TIFFOpen(completeFilename,\"w\");\r\n\r\n\r\n    if (!output) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_IMAGEWIDTH, XSIZE);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image width.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_IMAGELENGTH, YSIZE);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image height.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, bpp);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image bit per sample.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, spp);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image sample per pixel.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, (rowsPerStrip == -1) ? YSIZE : (uint32)rowsPerStrip);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image rows per strip.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image orientation.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_COMPRESSION, compressed ? COMPRESSION_LZW : COMPRESSION_NONE);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the compression tag.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the planarconfig tag.\");\r\n    }\r\n\r\n    if ( spp == 1 )\r\n        check = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\r\n    else // spp == 3\r\n        check = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the photometric tag.\");\r\n    }\r\n\r\n    /* We are writing single page of the multipage file */\r\n    check = TIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the subfiletype tag.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_PAGENUMBER, 0, Npages);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the page number.\");\r\n    }\r\n\r\n    //check = (int)TIFFWriteEncodedStrip(output, 0, fakeData, XSIZE * YSIZE);\r\n    //if (!check) {\r\n    //\tdelete completeFilename;\r\n    //\treturn ((char *) \"Cannot write encoded strip to file.\");\r\n    //   }\r\n\r\n    if ( rowsPerStrip == -1 ) {\r\n        TIFFSetDirectory(output,0);\r\n        check = TIFFWriteEncodedStrip(output, 0, fakeData, szSlice);\r\n        if (!check) {\r\n            delete completeFilename;\r\n            return ((char *) \"Cannot write encoded strip to file.\");\r\n        }\r\n    }\r\n    else {\r\n        int check,StripsPerImage,LastStripSize;\r\n        uint32 rps = (uint32)rowsPerStrip;\r\n        unsigned char *buf = fakeData;\r\n\r\n        StripsPerImage =  (YSIZE + rps - 1) / rps;\r\n        LastStripSize = YSIZE % rps;\r\n        if (LastStripSize==0)\r\n            LastStripSize=rps;\r\n\r\n        for (int i=0; i < StripsPerImage-1; i++){\r\n            check = TIFFWriteEncodedStrip(output, i, buf, spp * rps * XSIZE * (bpp/8));\r\n            if (!check) {\r\n                delete completeFilename;\r\n                return ((char *) \"Cannot write encoded strip to file.\");\r\n            }\r\n            buf = buf + spp * rps * XSIZE * (bpp/8);\r\n        }\r\n\r\n        check = TIFFWriteEncodedStrip(output, StripsPerImage-1, buf, spp * LastStripSize * XSIZE * (bpp/8));\r\n        if (!check) {\r\n            delete completeFilename;\r\n            return ((char *) \"Cannot write encoded strip to file.\");\r\n        }\r\n        //}\r\n        buf = buf + spp * LastStripSize * XSIZE * (bpp/8);\r\n    }\r\n\r\n    if(fakeData)\r\n        delete[] fakeData;\r\n\r\n    check = TIFFWriteDirectory(output);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot write a new directory.\");\r\n    }\r\n\r\n    TIFFClose(output);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffInitData, tf::IO, tf::strprintf(\"written initialized 3D tiff \\\"%s\\\"\", completeFilename));\r\n    #endif\r\n\r\n    delete completeFilename;\r\n\r\n    return (char *) 0;\r\n}",
    "char *initTiffFile(char *filename, unsigned int sz0, unsigned int  sz1, unsigned int  sz2, unsigned int  sz3, int datatype)\r\n{\r\n    //\r\n    uint32 XSIZE  = sz0;\r\n    uint32 YSIZE  = sz1;\r\n    uint16 Npages = sz2;\r\n    uint16 spp    = sz3;\r\n\r\n    uint16 bpp=8 * datatype;\r\n\r\n    if ( sz3 == 1 )\r\n        spp = sz3;\r\n    else if ( sz3 < 4 )\r\n        spp = 3;\r\n    else\r\n        return ((char *) \"More than 3 channels in Tiff files.\");\r\n\r\n    //\r\n    TIFF *output = NULL;\r\n\r\n    iim::sint64 expectedSize = ((iim::sint64) sz0) * ((iim::sint64) sz1) * ((iim::sint64) sz2) * ((iim::sint64) sz3) * ((iim::sint64) datatype);\r\n\r\n    if ( bigtiff || expectedSize > (4*GBSIZE) ) {\r\n        if ( (rowsPerStrip == -1 && (((iim::sint64) sz0) * ((iim::sint64) sz1)) > (4*GBSIZE)) || ((rowsPerStrip * ((iim::sint64) sz0)) > (4*GBSIZE)) )\r\n            return ((char *) \"Too many rows per strip for this image width.\");\r\n        else\r\n            output = TIFFOpen(filename,\"w8\");\r\n    }\r\n    else\r\n    {\r\n        output = TIFFOpen(filename,\"w\");\r\n    }\r\n\r\n    if (!output)\r\n    {\r\n        return ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n    //\r\n    uint32 szPage = XSIZE * YSIZE * spp * datatype;\r\n\r\n    unsigned char *img = NULL;\r\n    try\r\n    {\r\n        img = new unsigned char [szPage];\r\n        memset(img, 0, szPage);\r\n    }\r\n    catch(...)\r\n    {\r\n        return ((char *)\"fail to alloc memory\");\r\n    }\r\n\r\n    // the file has been already opened: rowsPerStrip it is not too large for this image width\r\n    if ( rowsPerStrip == -1 )\r\n    {\r\n        //\r\n        for(int slice=0; slice<Npages; slice++)\r\n        {\r\n            TIFFSetDirectory(output,slice);\r\n\r\n            TIFFSetField(output, TIFFTAG_IMAGEWIDTH, XSIZE);\r\n            TIFFSetField(output, TIFFTAG_IMAGELENGTH, YSIZE);\r\n            TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, (uint16)bpp);\r\n            TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, (uint16)spp);\r\n            TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, (rowsPerStrip == -1) ? YSIZE : (uint32)rowsPerStrip);\r\n            TIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n            TIFFSetField(output, TIFFTAG_COMPRESSION, compressed ? COMPRESSION_LZW : COMPRESSION_NONE);\r\n            TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n            if ( spp == 1 )\r\n                TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\r\n            else // spp == 3\r\n                TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\r\n\r\n            // We are writing single page of the multipage file\r\n            TIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n            TIFFSetField(output, TIFFTAG_PAGENUMBER, (uint16)slice, (uint16)Npages);\r\n\r\n            //\r\n            TIFFWriteEncodedStrip(output, 0, img, szPage);\r\n\r\n            //\r\n            TIFFWriteDirectory(output);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        int StripsPerImage,LastStripSize;\r\n        uint32 rps = (uint32)rowsPerStrip;\r\n        unsigned char *buf = img;\r\n\r\n        StripsPerImage =  (YSIZE + rps - 1) / rps;\r\n        LastStripSize = YSIZE % rps;\r\n        if (LastStripSize==0)\r\n            LastStripSize=rps;\r\n\r\n        for (int i=0; i < StripsPerImage-1; i++){\r\n            TIFFWriteEncodedStrip(output, i, buf, spp * rps * XSIZE * (bpp/8));\r\n            buf = buf + spp * rps * XSIZE * (bpp/8);\r\n        }\r\n\r\n        TIFFWriteEncodedStrip(output, StripsPerImage-1, buf, spp * LastStripSize * XSIZE * (bpp/8));\r\n        buf = buf + spp * LastStripSize * XSIZE * (bpp/8);\r\n    }\r\n\r\n    //\r\n    TIFFClose(output);\r\n\r\n////    std::ifstream in(filename, std::ifstream::ate | std::ifstream::binary);\r\n////    cout<<\"save \"<<filename<<\" with the size \"<<in.tellg()<<endl;\r\n\r\n    //\r\n//    long szStack = sz0*sz1*sz2*sz3*datatype;\r\n//    unsigned char *img = NULL;\r\n//    try\r\n//    {\r\n//        img = new unsigned char [szStack];\r\n//        memset(img, 0, szStack);\r\n//    }\r\n//    catch(...)\r\n//    {\r\n//        return ((char *)\"fail to alloc memory\");\r\n//    }\r\n\r\n//    //\r\n//    writeTiff3DFile(filename, sz0, sz1, sz2, sz3, datatype, img);\r\n\r\n    //\r\n    if(img)\r\n        delete [] img;\r\n\r\n    //\r\n    return (char *) 0;\r\n}",
    "char *writeTiff3DFile(char *filename, unsigned int sz0, unsigned int  sz1, unsigned int  sz2, unsigned int  sz3, int datatype, unsigned char *img)\r\n{\r\n    //\r\n#ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffInitData);\r\n#endif\r\n\r\n    uint32 XSIZE  = sz0;\r\n    uint32 YSIZE  = sz1;\r\n    uint16 Npages = sz2;\r\n    uint16 spp    = sz3;\r\n\r\n    uint16 bpp=8 * datatype;\r\n\r\n    int check;\r\n\r\n    if ( sz3 == 1 )\r\n        spp = sz3;\r\n    else if ( sz3 < 4 )\r\n        spp = 3;\r\n    else\r\n        return ((char *) \"More than 3 channels in Tiff files.\");\r\n\r\n    char *completeFilename = (char *) 0;\r\n    int fname_len = (int) strlen(filename);\r\n    char *suffix = strstr(filename,\".tif\");\r\n    while ( suffix && (fname_len - (suffix-filename) > 5) )\r\n        suffix = strstr(suffix+4,\".tif\");\r\n    //if ( (suffix != 0) && (fname_len - (suffix-filename) <= 5) ) { // a substring \".tif is already at the end of the filename\r\n    if ( suffix ) { // a substring \".tif is already at the very end of the filename\r\n        completeFilename = new char[fname_len+1];\r\n        strcpy(completeFilename,filename);\r\n    }\r\n    else {\r\n        completeFilename = new char[fname_len+4+1];\r\n        strcpy(completeFilename,filename);\r\n        strcat(completeFilename,\".\");\r\n        strcat(completeFilename,TIFF3D_SUFFIX);\r\n    }\r\n\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n#ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffInitData, tf::CPU, tf::strprintf(\"generated fake data for 3D tiff \\\"%s\\\"\", completeFilename));\r\n    TERAFLY_TIME_RESTART(TiffInitData);\r\n#endif\r\n\r\n    //disable warning and error handlers to avoid messages on unrecognized tags\r\n    TIFFSetWarningHandler(0);\r\n    TIFFSetErrorHandler(0);\r\n\r\n    TIFF *output = NULL;\r\n\r\n    iim::sint64 expectedSize = ((iim::sint64) sz0) * ((iim::sint64) sz1) * ((iim::sint64) sz2) * ((iim::sint64) sz3) * ((iim::sint64) datatype);\r\n\r\n    if ( bigtiff || expectedSize > (4*GBSIZE) ) {\r\n        if ( (rowsPerStrip == -1 && (((iim::sint64) sz0) * ((iim::sint64) sz1)) > (4*GBSIZE)) || ((rowsPerStrip * ((iim::sint64) sz0)) > (4*GBSIZE)) )\r\n            // one strip is larger than 4GB\r\n            return ((char *) \"Too many rows per strip for this image width.\");\r\n        else\r\n            output = TIFFOpen(completeFilename,\"w8\");\r\n    }\r\n    else\r\n        output = TIFFOpen(completeFilename,\"w\");\r\n\r\n\r\n    if (!output) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_IMAGEWIDTH, XSIZE);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image width.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_IMAGELENGTH, YSIZE);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image height.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, bpp);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image bit per sample.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, spp);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image sample per pixel.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, (rowsPerStrip == -1) ? YSIZE : (uint32)rowsPerStrip);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image rows per strip.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image orientation.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_COMPRESSION, compressed ? COMPRESSION_LZW : COMPRESSION_NONE);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the compression tag.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the planarconfig tTIFFSetDirectoryag.\");\r\n    }\r\n\r\n    if ( spp == 1 )\r\n        check = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\r\n    else // spp == 3\r\n        check = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the photometric tag.\");\r\n    }\r\n\r\n    /* We are writing single page of the multipage file */\r\n    check = TIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the subfiletype tag.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_PAGENUMBER, 0, Npages);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the page number.\");\r\n    }\r\n\r\n    //\r\n    uint32 szPage = XSIZE * YSIZE * spp * datatype;\r\n\r\n    for(int slice=0; slice<Npages; slice++)\r\n    {\r\n        TIFFSetDirectory(output,slice);\r\n\r\n        TIFFSetField(output, TIFFTAG_IMAGEWIDTH, XSIZE);\r\n        TIFFSetField(output, TIFFTAG_IMAGELENGTH, YSIZE);\r\n        TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, (uint16)bpp);\r\n        TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, (uint16)spp);\r\n        TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, (rowsPerStrip == -1) ? YSIZE : (uint32)rowsPerStrip);\r\n        TIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n        TIFFSetField(output, TIFFTAG_COMPRESSION, compressed ? COMPRESSION_LZW : COMPRESSION_NONE);\r\n        TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n        if ( spp == 1 )\r\n            TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\r\n        else // spp == 3\r\n            TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\r\n        // We are writing single page of the multipage file\r\n        TIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n        TIFFSetField(output, TIFFTAG_PAGENUMBER, (uint16)slice, (uint16)Npages);\r\n\r\n        // the file has been already opened: rowsPerStrip it is not too large for this image width\r\n        if ( rowsPerStrip == -1 )\r\n        {\r\n            //printf(\"offset ... %ld\\n\",  slice*szPage);\r\n            TIFFWriteEncodedStrip(output, 0, img + slice*szPage, szPage);\r\n\r\n//            for ( unsigned int ih = 0; ih < YSIZE; ih++ )\r\n//            {\r\n//                if ( TIFFWriteScanline(output, img, ih, 0) < 0 )\r\n//                {\r\n//                    printf(\"Error out of disk space.\\n\");\r\n//                    break;\r\n//                }\r\n//                img += XSIZE*datatype;\r\n//            }\r\n        }\r\n        else\r\n        {\r\n            int StripsPerImage,LastStripSize;\r\n            uint32 rps = (uint32)rowsPerStrip;\r\n            unsigned char *buf = img;\r\n\r\n            StripsPerImage =  (YSIZE + rps - 1) / rps;\r\n            LastStripSize = YSIZE % rps;\r\n            if (LastStripSize==0)\r\n                LastStripSize=rps;\r\n\r\n            for (int i=0; i < StripsPerImage-1; i++){\r\n                TIFFWriteEncodedStrip(output, i, buf, spp * rps * XSIZE * (bpp/8));\r\n                buf = buf + spp * rps * XSIZE * (bpp/8);\r\n            }\r\n\r\n            TIFFWriteEncodedStrip(output, StripsPerImage-1, buf, spp * LastStripSize * XSIZE * (bpp/8));\r\n            buf = buf + spp * LastStripSize * XSIZE * (bpp/8);\r\n        }\r\n\r\n        //\r\n        TIFFWriteDirectory(output);\r\n    }\r\n\r\n    //\r\n    TIFFClose(output);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n#ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffInitData, tf::IO, tf::strprintf(\"written initialized 3D tiff \\\"%s\\\"\", completeFilename));\r\n#endif\r\n\r\n    delete completeFilename;\r\n\r\n    //\r\n    return (char *) 0;\r\n}",
    "void Write_Tiff(TIFF *tif, Image *a_image)\n{ int   n;\n\n  if (a_image->kind == COLOR)\n    TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,(uint16)  2);\n  else     // ->kind == GREY or GREY16\n    TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,(uint16)  1);\n  TIFFSetField(tif,TIFFTAG_ROWSPERSTRIP,(uint32) 0xFFFFFFFF);\n  TIFFSetField(tif,TIFFTAG_XRESOLUTION,(float) 72.);\n  TIFFSetField(tif,TIFFTAG_YRESOLUTION,(float) 72.);\n  TIFFSetField(tif,TIFFTAG_RESOLUTIONUNIT,(uint16) 2);\n  TIFFSetField(tif,TIFFTAG_PLANARCONFIG,(uint16) 1);\n  TIFFSetField(tif,TIFFTAG_ORIENTATION,(uint16) 4);\n\n  if (a_image->kind == GREY16)\n    { TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,(uint16) 16);\n      TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,(uint16) 1);\n    }\n  else\n    { TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,(uint16) 8);\n      TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,(uint16) (a_image->kind));\n    }\n  TIFFSetField(tif,TIFFTAG_IMAGEWIDTH,(uint32) (a_image->width));\n  TIFFSetField(tif,TIFFTAG_IMAGELENGTH,(uint32) (a_image->height));\n\n  n = TIFFWriteEncodedStrip(tif,0,a_image->array,image_asize(a_image));\n  if (n < 0)\n    error(\"error writing TIFF file\",NULL);\n\n  TIFFWriteDirectory(tif);\n}",
    "int main(int argc, char *argv[])\n{\n    uint16_t             defconfig = (uint16_t)-1;\n    uint16_t             deffillorder = 0;\n    uint32_t             deftilewidth = (uint32_t)-1;\n    uint32_t             deftilelength = (uint32_t)-1;\n    uint32_t             defrowsperstrip = (uint32_t)-1;\n    uint32_t             diroff = 0;\n    TIFF *             in;\n    TIFF *             out;\n    const char *       mode = \"w\";\n    int                c;\n    extern int         optind;\n    extern const char *myoptarg;\n\n    while ((c = getopt(argc, argv, \"c:f:l:m:M:n:o:p:r:w:e:g:4:aistd\")) != -1) switch (c) {\n        case 'a': /* append to output */ mode = \"a\"; break;\n        case 'd': /* down cast 8bit to 4bit */ convert_8_to_4 = 1; break;\n        case 'c': /* compression scheme */\n            if (!processCompressOptions(myoptarg)) usage();\n            break;\n        case 'e': worldfile = myoptarg; break;\n        case 'f': /* fill order */\n            if (streq(myoptarg, \"lsb2msb\"))\n                deffillorder = FILLORDER_LSB2MSB;\n            else if (streq(myoptarg, \"msb2lsb\"))\n                deffillorder = FILLORDER_MSB2LSB;\n            else\n                usage();\n            break;\n        case 'i': /* ignore errors */ ignore = TRUE; break;\n        case 'g': /* GeoTIFF metadata file */ geofile = myoptarg; break;\n        case 'm': /*multiple times and latlon extents file */\n            timeLonLatName = myoptarg;\n            timeLonLatFile = fopen(timeLonLatName, \"r\");\n            if (!timeLonLatFile) {\n                fprintf(stderr, \"Failure to open %s\\n\", timeLonLatName);\n                exit(-1);\n            }\n            break;\n        case 'M': /*multiple timestamps file */\n            timeName = myoptarg;\n            timeFile = fopen(timeName, \"r\");\n            if (!timeFile) {\n                fprintf(stderr, \"Failure to open %s\\n\", timeName);\n                exit(-1);\n            }\n            break;\n        case 'n': /* single latlong extents, requires option 4 */\n        {\n            int retval = sscanf(myoptarg, \"%f %f %f %f\", lonLatExts, lonLatExts + 1, lonLatExts + 2, lonLatExts + 3);\n            if (retval != 4) {\n                fprintf(stderr, \"Four lon/lat extent values required\\n\");\n                exit(-1);\n            }\n        } break;\n\n        case '4': proj4_string = myoptarg; break;\n        case 'l': /* tile length */\n            outtiled = TRUE;\n            deftilelength = atoi(myoptarg);\n            break;\n        case 'o': /* initial directory offset */ diroff = strtoul(myoptarg, NULL, 0); break;\n        case 'p': /* planar configuration */\n            if (streq(myoptarg, \"separate\"))\n                defconfig = PLANARCONFIG_SEPARATE;\n            else if (streq(myoptarg, \"contig\"))\n                defconfig = PLANARCONFIG_CONTIG;\n            else\n                usage();\n            break;\n        case 'r': /* rows/strip */ defrowsperstrip = atoi(myoptarg); break;\n        case 's': /* generate stripped output */ outtiled = FALSE; break;\n        case 't': /* generate tiled output */ outtiled = TRUE; break;\n        case 'w': /* tile width */\n            outtiled = TRUE;\n            deftilewidth = atoi(myoptarg);\n            break;\n        case '?':\n            usage();\n            /*NOTREACHED*/\n        }\n    if (argc - optind < 2) usage();\n    out = TIFFOpen(argv[argc - 1], mode);\n    if (out == NULL) return (-2);\n    for (; optind < argc - 1; optind++) {\n        in = TIFFOpen(argv[optind], \"r\");\n        if (in == NULL) return (-3);\n        if (diroff != 0 && !TIFFSetSubDirectory(in, diroff)) {\n            TIFFError(TIFFFileName(in), \"Error, setting subdirectory at %#x\", diroff);\n            (void)TIFFClose(out);\n            return (1);\n        }\n        do {\n            config = defconfig;\n            compression = defcompression;\n            predictor = defpredictor;\n            fillorder = deffillorder;\n            rowsperstrip = defrowsperstrip;\n            tilewidth = deftilewidth;\n            tilelength = deftilelength;\n            g3opts = defg3opts;\n            if (!tiffcp(in, out) || !TIFFWriteDirectory(out)) {\n                (void)TIFFClose(out);\n                return (1);\n            }\n        } while (TIFFReadDirectory(in));\n        (void)TIFFClose(in);\n    }\n    (void)TIFFClose(out);\n    return (0);\n}",
    "bool _writeTIFF(const char *filename, char *imagedata, unsigned width, unsigned height, unsigned numcolors, unsigned numbits, std::map<std::string,std::string> info, char *iccprofile, unsigned iccprofilelength)\n{\n\tchar *img;\n\tunsigned char *buf;\n\tuint32_t w, h;\n\tuint16_t c, b;\n\t\n\tTIFFSetErrorHandler(0);\n\n\tTIFF* tif = TIFFOpen(filename, \"w\");\n\tif (tif) {\n\n\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);  \n\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);    \n\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, numcolors);   \n\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, numbits);\n\t\tif (numbits == 8 | numbits == 16)\n\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\t\telse if (numbits == 32)\n\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n\t\telse\n\t\t\treturn false;\n\t\tTIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);   \n\n\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE); //todo: COMPRESSION_ADOBE_DEFLATE);\n\t\t// We set the strip size of the file to be size of one row of pixels\n\t\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tif, width*numcolors));\n\n\t\t//if (info.find(\"Artist\") != info.end())  TIFFSetField(tif, TIFFTAG_ARTIST, info[\"Artist\"].c_str());\n\t\t//if (info.find(\"Make\") != info.end())  TIFFSetField(tif, TIFFTAG_MAKE, info[\"Make\"].c_str());\n\t\t//if (info.find(\"Model\") != info.end())  TIFFSetField(tif, TIFFTAG_MODEL, info[\"Model\"].c_str());\n\t\t//if (info.find(\"Software\") != info.end())  TIFFSetField(tif, TIFFTAG_SOFTWARE, info[\"Software\"].c_str());\n\t\t//if (info.find(\"Copyright\") != info.end())  TIFFSetField(tif, TIFFTAG_COPYRIGHT, info[\"Copyright\"].c_str());\n\t\t//if (info.find(\"LensInfo\") != info.end())  TIFFSetField(tif, TIFFTAG_LENSINFO, info[\"LensInfo\"].c_str());\n\t\t//if (info.find(\"DateTime\") != info.end()) TIFFSetField(tif, TIFFTAG_DATETIME, info[\"DateTime\"].c_str());\n\t\t//if (info.find(\"ImageDescription\") != info.end())  TIFFSetField(tif, TIFFTAG_IMAGEDESCRIPTION, info[\"ImageDescription\"].c_str());\n\t\t//if (info.find(\"Orientation\") != info.end()) {\n\t\t//\tuint16_t orient = (uint16_t) atoi(info[\"Orientation\"].c_str());\n\t\t//\tTIFFSetField(tif, TIFFTAG_ORIENTATION, 1, &orient);\n\t\t//}\n\n\t\t//if (iccprofile) TIFFSetField(tif, TIFFTAG_ICCPROFILE, iccprofilelength, iccprofile);\n\t\t\t\t\n\t\tunsigned scanlinesize = TIFFScanlineSize(tif);\n\t\tbuf = (unsigned char *) _TIFFmalloc(scanlinesize);\n\t\timg = imagedata;\n\n\t\tfor (unsigned row = 0; row < height; row++)\n\t\t{\n\t\t\tmemcpy(buf, img, scanlinesize);\n\t\t\tif (TIFFWriteScanline(tif, buf, row, 0) < 0) {\n\t\t\t\tprintf(\"TIFFWriteScanline got an error...\\n\");\n\t\t\t\tTIFFError(NULL,NULL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\timg+=scanlinesize;\n\t\t}\n\n\t\tTIFFWriteDirectory( tif );\n\n\t\t(void) TIFFClose(tif);\n\t\tif (buf) _TIFFfree(buf);\n\t\treturn true;\n\t}\n\telse return true;\n\n}",
    "toff_t GTIFFWriteDirectory(TIFF *hTIFF, int nSubfileType, int nXSize,\n                           int nYSize, int nBitsPerPixel, int nPlanarConfig,\n                           int nSamples, int nBlockXSize, int nBlockYSize,\n                           int bTiled, int nCompressFlag, int nPhotometric,\n                           int nSampleFormat, int nPredictor,\n                           unsigned short *panRed, unsigned short *panGreen,\n                           unsigned short *panBlue, int nExtraSamples,\n                           unsigned short *panExtraSampleValues,\n                           const char *pszMetadata, const char *pszJPEGQuality,\n                           const char *pszJPEGTablesMode, const char *pszNoData,\n                           const uint32_t *panLercAddCompressionAndVersion,\n                           bool bDeferStrileArrayWriting)\n\n{\n    const toff_t nBaseDirOffset = TIFFCurrentDirOffset(hTIFF);\n\n    // This is a bit of a hack to cause (*tif->tif_cleanup)(tif); to be called.\n    // See https://trac.osgeo.org/gdal/ticket/2055\n    TIFFSetField(hTIFF, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    TIFFFreeDirectory(hTIFF);\n\n    TIFFCreateDirectory(hTIFF);\n\n    /* -------------------------------------------------------------------- */\n    /*      Setup TIFF fields.                                              */\n    /* -------------------------------------------------------------------- */\n    TIFFSetField(hTIFF, TIFFTAG_IMAGEWIDTH, nXSize);\n    TIFFSetField(hTIFF, TIFFTAG_IMAGELENGTH, nYSize);\n    if (nSamples == 1)\n        TIFFSetField(hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    else\n        TIFFSetField(hTIFF, TIFFTAG_PLANARCONFIG, nPlanarConfig);\n\n    TIFFSetField(hTIFF, TIFFTAG_BITSPERSAMPLE, nBitsPerPixel);\n    TIFFSetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, nSamples);\n    TIFFSetField(hTIFF, TIFFTAG_COMPRESSION, nCompressFlag);\n    TIFFSetField(hTIFF, TIFFTAG_PHOTOMETRIC, nPhotometric);\n    TIFFSetField(hTIFF, TIFFTAG_SAMPLEFORMAT, nSampleFormat);\n\n    if (bTiled)\n    {\n        TIFFSetField(hTIFF, TIFFTAG_TILEWIDTH, nBlockXSize);\n        TIFFSetField(hTIFF, TIFFTAG_TILELENGTH, nBlockYSize);\n    }\n    else\n    {\n        TIFFSetField(hTIFF, TIFFTAG_ROWSPERSTRIP, nBlockYSize);\n    }\n\n    TIFFSetField(hTIFF, TIFFTAG_SUBFILETYPE, nSubfileType);\n\n    if (panExtraSampleValues != nullptr)\n    {\n        TIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, nExtraSamples,\n                     panExtraSampleValues);\n    }\n\n    if (GTIFFSupportsPredictor(nCompressFlag))\n        TIFFSetField(hTIFF, TIFFTAG_PREDICTOR, nPredictor);\n\n    /* -------------------------------------------------------------------- */\n    /*      Write color table if one is present.                            */\n    /* -------------------------------------------------------------------- */\n    if (panRed != nullptr)\n    {\n        TIFFSetField(hTIFF, TIFFTAG_COLORMAP, panRed, panGreen, panBlue);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write metadata if we have some.                                 */\n    /* -------------------------------------------------------------------- */\n    if (pszMetadata && strlen(pszMetadata) > 0)\n        TIFFSetField(hTIFF, TIFFTAG_GDAL_METADATA, pszMetadata);\n\n    /* -------------------------------------------------------------------- */\n    /*      Write JPEG tables if needed.                                    */\n    /* -------------------------------------------------------------------- */\n    if (nCompressFlag == COMPRESSION_JPEG)\n    {\n        GTiffWriteJPEGTables(hTIFF,\n                             (nPhotometric == PHOTOMETRIC_RGB) ? \"RGB\"\n                             : (nPhotometric == PHOTOMETRIC_YCBCR)\n                                 ? \"YCBCR\"\n                                 : \"MINISBLACK\",\n                             pszJPEGQuality, pszJPEGTablesMode);\n\n        if (nPhotometric == PHOTOMETRIC_YCBCR)\n        {\n            // Explicitly register the subsampling so that JPEGFixupTags\n            // is a no-op (helps for cloud optimized geotiffs)\n            TIFFSetField(hTIFF, TIFFTAG_YCBCRSUBSAMPLING, 2, 2);\n        }\n    }\n\n    if (nCompressFlag == COMPRESSION_LERC && panLercAddCompressionAndVersion)\n    {\n        TIFFSetField(hTIFF, TIFFTAG_LERC_PARAMETERS, 2,\n                     panLercAddCompressionAndVersion);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write no data value if we have one.                             */\n    /* -------------------------------------------------------------------- */\n    if (pszNoData != nullptr)\n    {\n        TIFFSetField(hTIFF, TIFFTAG_GDAL_NODATA, pszNoData);\n    }\n\n    if (bDeferStrileArrayWriting)\n    {\n        TIFFDeferStrileArrayWriting(hTIFF);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write directory, and return byte offset.                        */\n    /* -------------------------------------------------------------------- */\n    if (TIFFWriteCheck(hTIFF, bTiled, \"GTIFFWriteDirectory\") == 0)\n    {\n        TIFFSetSubDirectory(hTIFF, nBaseDirOffset);\n        return 0;\n    }\n\n    TIFFWriteDirectory(hTIFF);\n    TIFFSetDirectory(hTIFF,\n                     static_cast<tdir_t>(TIFFNumberOfDirectories(hTIFF) - 1));\n\n    const toff_t nOffset = TIFFCurrentDirOffset(hTIFF);\n\n    TIFFSetSubDirectory(hTIFF, nBaseDirOffset);\n\n    return nOffset;\n}",
    "void GTiffWriteJPEGTables(TIFF *hTIFF, const char *pszPhotometric,\n                          const char *pszJPEGQuality,\n                          const char *pszJPEGTablesMode)\n{\n    // This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n    uint16_t nBands = 0;\n    if (!TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nBands))\n        nBands = 1;\n\n    uint16_t l_nBitsPerSample = 0;\n    if (!TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &(l_nBitsPerSample)))\n        l_nBitsPerSample = 1;\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf(\"%s%p\", szJPEGGTiffDatasetTmpPrefix, hTIFF);\n    VSILFILE *fpTmp = nullptr;\n    CPLString osTmp;\n    char **papszLocalParameters = nullptr;\n    const int nInMemImageWidth = 16;\n    const int nInMemImageHeight = 16;\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"COMPRESS\", \"JPEG\");\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"JPEG_QUALITY\", pszJPEGQuality);\n    if (nBands <= 4)\n    {\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                               \"PHOTOMETRIC\", pszPhotometric);\n    }\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters, \"BLOCKYSIZE\",\n                                           CPLSPrintf(\"%u\", nInMemImageHeight));\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters, \"NBITS\",\n                                           CPLSPrintf(\"%u\", l_nBitsPerSample));\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                           \"JPEGTABLESMODE\", pszJPEGTablesMode);\n\n    TIFF *hTIFFTmp =\n        GTiffDataset::CreateLL(osTmpFilenameIn, nInMemImageWidth,\n                               nInMemImageHeight, (nBands <= 4) ? nBands : 1,\n                               (l_nBitsPerSample <= 8) ? GDT_Byte : GDT_UInt16,\n                               0.0, papszLocalParameters, &fpTmp, osTmp);\n    CSLDestroy(papszLocalParameters);\n    if (hTIFFTmp)\n    {\n        uint16_t l_nPhotometric = 0;\n        int nJpegTablesModeIn = 0;\n        TIFFGetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, &(l_nPhotometric));\n        TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLESMODE, &nJpegTablesModeIn);\n        TIFFWriteCheck(hTIFFTmp, FALSE, \"CreateLL\");\n        TIFFWriteDirectory(hTIFFTmp);\n        TIFFSetDirectory(hTIFFTmp, 0);\n        // Now, reset quality and jpegcolormode.\n        const int l_nJpegQuality = pszJPEGQuality ? atoi(pszJPEGQuality) : 0;\n        if (l_nJpegQuality > 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGQUALITY, l_nJpegQuality);\n        if (l_nPhotometric == PHOTOMETRIC_YCBCR &&\n            CPLTestBool(CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\")))\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n        if (nJpegTablesModeIn >= 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGTABLESMODE, nJpegTablesModeIn);\n\n        GPtrDiff_t nBlockSize = static_cast<GPtrDiff_t>(nInMemImageWidth) *\n                                nInMemImageHeight *\n                                ((nBands <= 4) ? nBands : 1);\n        if (l_nBitsPerSample == 12)\n            nBlockSize = (nBlockSize * 3) / 2;\n        std::vector<GByte> abyZeroData(nBlockSize, 0);\n        TIFFWriteEncodedStrip(hTIFFTmp, 0, &abyZeroData[0], nBlockSize);\n\n        uint32_t nJPEGTableSize = 0;\n        void *pJPEGTable = nullptr;\n        if (TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSize,\n                         &pJPEGTable))\n            TIFFSetField(hTIFF, TIFFTAG_JPEGTABLES, nJPEGTableSize, pJPEGTable);\n\n        float *ref = nullptr;\n        if (TIFFGetField(hTIFFTmp, TIFFTAG_REFERENCEBLACKWHITE, &ref))\n            TIFFSetField(hTIFF, TIFFTAG_REFERENCEBLACKWHITE, ref);\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n    VSIUnlink(osTmpFilenameIn);\n}",
    "void VICARDataset::ReadProjectionFromGeoTIFFGroup()\n{\n    m_bGeoRefFormatIsMIPL = true;\n\n    // We will build a in-memory temporary GeoTIFF file from the VICAR GEOTIFF\n    // metadata items.\n\n    char szFilename[100] = {};\n    snprintf(szFilename, sizeof(szFilename), \"/vsimem/vicar_tmp_%p.tif\", this);\n\n    /* -------------------------------------------------------------------- */\n    /*      Initialization of libtiff and libgeotiff.                       */\n    /* -------------------------------------------------------------------- */\n    GTiffOneTimeInit();\n    LibgeotiffOneTimeInit();\n\n    /* -------------------------------------------------------------------- */\n    /*      Initialize access to the memory geotiff structure.              */\n    /* -------------------------------------------------------------------- */\n    VSILFILE *fpL = VSIFOpenL(szFilename, \"w\");\n    if (fpL == nullptr)\n        return;\n\n    TIFF *hTIFF = VSI_TIFFOpen(szFilename, \"w\", fpL);\n\n    if (hTIFF == nullptr)\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"TIFF/GeoTIFF structure is corrupt.\");\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n        return;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write some minimal set of image parameters.                     */\n    /* -------------------------------------------------------------------- */\n    TIFFSetField(hTIFF, TIFFTAG_IMAGEWIDTH, 1);\n    TIFFSetField(hTIFF, TIFFTAG_IMAGELENGTH, 1);\n    TIFFSetField(hTIFF, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(hTIFF, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\n    /* -------------------------------------------------------------------- */\n    /*      Write geotiff keys from VICAR metadata                          */\n    /* -------------------------------------------------------------------- */\n    GTIF *hGTIF = GTIFNew(hTIFF);\n    CPLAssert(hGTIF);\n\n    for (const auto &gkey : GTiffAsciiKeys)\n    {\n        const char *pszValue = GetKeyword(\n            (\"GEOTIFF.\" + CPLString(GTIFKeyName(gkey)).toupper()).c_str(),\n            nullptr);\n        if (pszValue)\n        {\n            GTIFKeySet(hGTIF, gkey, TYPE_ASCII,\n                       static_cast<int>(strlen(pszValue)), pszValue);\n        }\n    }\n\n    for (const auto &gkey : GTiffDoubleKeys)\n    {\n        const char *pszValue = GetKeyword(\n            (\"GEOTIFF.\" + CPLString(GTIFKeyName(gkey)).toupper()).c_str(),\n            nullptr);\n        if (pszValue)\n        {\n            GTIFKeySet(hGTIF, gkey, TYPE_DOUBLE, 1, CPLAtof(pszValue));\n        }\n    }\n\n    for (const auto &gkey : GTiffShortKeys)\n    {\n        const char *pszValue = GetKeyword(\n            (\"GEOTIFF.\" + CPLString(GTIFKeyName(gkey)).toupper()).c_str(),\n            nullptr);\n        if (pszValue)\n        {\n            GTIFKeySet(hGTIF, gkey, TYPE_SHORT, 1, atoi(pszValue));\n        }\n    }\n\n    GTIFWriteKeys(hGTIF);\n    GTIFFree(hGTIF);\n\n    /* -------------------------------------------------------------------- */\n    /*      Write geotiff tags from VICAR metadata                          */\n    /* -------------------------------------------------------------------- */\n\n    const std::map<const char *, int> oMapTagNameToCode = {\n        {\"MODELPIXELSCALETAG\", TIFFTAG_GEOPIXELSCALE},\n        {\"MODELTIEPOINTTAG\", TIFFTAG_GEOTIEPOINTS},\n        {\"MODELTRANSFORMATIONTAG\", TIFFTAG_GEOTRANSMATRIX},\n    };\n\n    for (const auto &kv : oMapTagNameToCode)\n    {\n        const char *pszValue =\n            GetKeyword((std::string(\"GEOTIFF.\") + kv.first).c_str(), nullptr);\n        if (pszValue)\n        {\n            // Remove leading ( and trailing ), and replace comma by space\n            // to separate on it.\n            const CPLStringList aosTokens(\n                CSLTokenizeString2(CPLString(pszValue)\n                                       .replaceAll('(', \"\")\n                                       .replaceAll(')', \"\")\n                                       .replaceAll(',', ' ')\n                                       .c_str(),\n                                   \" \", 0));\n            if (!aosTokens.empty())\n            {\n                std::vector<double> adfValues;\n                for (int i = 0; i < aosTokens.size(); ++i)\n                    adfValues.push_back(CPLAtof(aosTokens[i]));\n                TIFFSetField(hTIFF, kv.second, aosTokens.size(), &adfValues[0]);\n            }\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Finalize the geotiff file.                                      */\n    /* -------------------------------------------------------------------- */\n\n    char bySmallImage = 0;\n\n    TIFFWriteEncodedStrip(hTIFF, 0, &bySmallImage, 1);\n    TIFFWriteDirectory(hTIFF);\n\n    XTIFFClose(hTIFF);\n    CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n\n    /* -------------------------------------------------------------------- */\n    /*      Get georeferencing from file.                                   */\n    /* -------------------------------------------------------------------- */\n    auto poGTiffDS =\n        std::unique_ptr<GDALDataset>(GDALDataset::Open(szFilename));\n    if (poGTiffDS)\n    {\n        auto poSRS = poGTiffDS->GetSpatialRef();\n        if (poSRS)\n            m_oSRS = *poSRS;\n\n        if (poGTiffDS->GetGeoTransform(&m_adfGeoTransform[0]) == CE_None)\n        {\n            m_bGotTransform = true;\n        }\n\n        const char *pszAreaOrPoint =\n            poGTiffDS->GetMetadataItem(GDALMD_AREA_OR_POINT);\n        if (pszAreaOrPoint)\n            GDALDataset::SetMetadataItem(GDALMD_AREA_OR_POINT, pszAreaOrPoint);\n    }\n\n    VSIUnlink(szFilename);\n}",
    "CPLErr GTIFMemBufFromSRS(OGRSpatialReferenceH hSRS,\n                         const double *padfGeoTransform, int nGCPCount,\n                         const GDAL_GCP *pasGCPList, int *pnSize,\n                         unsigned char **ppabyBuffer, int bPixelIsPoint,\n                         char **papszRPCMD)\n\n{\n    char szFilename[100] = {};\n\n    snprintf(szFilename, sizeof(szFilename), \"/vsimem/wkt_from_mem_buf_%ld.tif\",\n             static_cast<long>(CPLGetPID()));\n\n    /* -------------------------------------------------------------------- */\n    /*      Initialization of libtiff and libgeotiff.                       */\n    /* -------------------------------------------------------------------- */\n    GTiffOneTimeInit();  // For RPC tag.\n    LibgeotiffOneTimeInit();\n\n    /* -------------------------------------------------------------------- */\n    /*      Initialize access to the memory geotiff structure.              */\n    /* -------------------------------------------------------------------- */\n    VSILFILE *fpL = VSIFOpenL(szFilename, \"w\");\n    if (fpL == nullptr)\n        return CE_Failure;\n\n    TIFF *hTIFF = VSI_TIFFOpen(szFilename, \"w\", fpL);\n\n    if (hTIFF == nullptr)\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"TIFF/GeoTIFF structure is corrupt.\");\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n        return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write some minimal set of image parameters.                     */\n    /* -------------------------------------------------------------------- */\n    TIFFSetField(hTIFF, TIFFTAG_IMAGEWIDTH, 1);\n    TIFFSetField(hTIFF, TIFFTAG_IMAGELENGTH, 1);\n    TIFFSetField(hTIFF, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(hTIFF, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\n    /* -------------------------------------------------------------------- */\n    /*      Get the projection definition.                                  */\n    /* -------------------------------------------------------------------- */\n\n    bool bPointGeoIgnore = false;\n    if (bPixelIsPoint)\n    {\n        bPointGeoIgnore =\n            CPLTestBool(CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\", \"FALSE\"));\n    }\n\n    GTIF *hGTIF = nullptr;\n    if (hSRS != nullptr || bPixelIsPoint)\n    {\n        hGTIF = GTIFNew(hTIFF);\n        if (hGTIF)\n        {\n            GTIFAttachPROJContext(hGTIF, OSRGetProjTLSContext());\n\n            if (hSRS != nullptr)\n                GTIFSetFromOGISDefnEx(hGTIF, hSRS, GEOTIFF_KEYS_STANDARD,\n                                      GEOTIFF_VERSION_1_0);\n\n            if (bPixelIsPoint)\n            {\n                GTIFKeySet(hGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                           RasterPixelIsPoint);\n            }\n\n            GTIFWriteKeys(hGTIF);\n            GTIFFree(hGTIF);\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Set the geotransform, or GCPs.                                  */\n    /* -------------------------------------------------------------------- */\n\n    if (padfGeoTransform[0] != 0.0 || padfGeoTransform[1] != 1.0 ||\n        padfGeoTransform[2] != 0.0 || padfGeoTransform[3] != 0.0 ||\n        padfGeoTransform[4] != 0.0 || std::abs(padfGeoTransform[5]) != 1.0)\n    {\n\n        if (padfGeoTransform[2] == 0.0 && padfGeoTransform[4] == 0.0)\n        {\n            double adfPixelScale[3] = {padfGeoTransform[1],\n                                       fabs(padfGeoTransform[5]), 0.0};\n\n            TIFFSetField(hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale);\n\n            double adfTiePoints[6] = {\n                0.0, 0.0, 0.0, padfGeoTransform[0], padfGeoTransform[3], 0.0};\n\n            if (bPixelIsPoint && !bPointGeoIgnore)\n            {\n                adfTiePoints[3] +=\n                    padfGeoTransform[1] * 0.5 + padfGeoTransform[2] * 0.5;\n                adfTiePoints[4] +=\n                    padfGeoTransform[4] * 0.5 + padfGeoTransform[5] * 0.5;\n            }\n\n            TIFFSetField(hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints);\n        }\n        else\n        {\n            double adfMatrix[16] = {0.0};\n\n            adfMatrix[0] = padfGeoTransform[1];\n            adfMatrix[1] = padfGeoTransform[2];\n            adfMatrix[3] = padfGeoTransform[0];\n            adfMatrix[4] = padfGeoTransform[4];\n            adfMatrix[5] = padfGeoTransform[5];\n            adfMatrix[7] = padfGeoTransform[3];\n            adfMatrix[15] = 1.0;\n\n            if (bPixelIsPoint && !bPointGeoIgnore)\n            {\n                adfMatrix[3] +=\n                    padfGeoTransform[1] * 0.5 + padfGeoTransform[2] * 0.5;\n                adfMatrix[7] +=\n                    padfGeoTransform[4] * 0.5 + padfGeoTransform[5] * 0.5;\n            }\n\n            TIFFSetField(hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix);\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Otherwise write tiepoints if they are available.                */\n    /* -------------------------------------------------------------------- */\n    else if (nGCPCount > 0)\n    {\n        double *padfTiePoints =\n            static_cast<double *>(CPLMalloc(6 * sizeof(double) * nGCPCount));\n\n        for (int iGCP = 0; iGCP < nGCPCount; iGCP++)\n        {\n\n            padfTiePoints[iGCP * 6 + 0] = pasGCPList[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP * 6 + 1] = pasGCPList[iGCP].dfGCPLine;\n            padfTiePoints[iGCP * 6 + 2] = 0;\n            padfTiePoints[iGCP * 6 + 3] = pasGCPList[iGCP].dfGCPX;\n            padfTiePoints[iGCP * 6 + 4] = pasGCPList[iGCP].dfGCPY;\n            padfTiePoints[iGCP * 6 + 5] = pasGCPList[iGCP].dfGCPZ;\n        }\n\n        TIFFSetField(hTIFF, TIFFTAG_GEOTIEPOINTS, 6 * nGCPCount, padfTiePoints);\n        CPLFree(padfTiePoints);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write RPC                                                       */\n    /* -------------------------------------------------------------------- */\n    if (papszRPCMD != nullptr)\n    {\n        GTiffDatasetWriteRPCTag(hTIFF, papszRPCMD);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup and return the created memory buffer.                   */\n    /* -------------------------------------------------------------------- */\n    GByte bySmallImage = 0;\n\n    TIFFWriteEncodedStrip(hTIFF, 0, reinterpret_cast<char *>(&bySmallImage), 1);\n    TIFFWriteCheck(hTIFF, TIFFIsTiled(hTIFF), \"GTIFMemBufFromWkt\");\n    TIFFWriteDirectory(hTIFF);\n\n    XTIFFClose(hTIFF);\n    CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n\n    /* -------------------------------------------------------------------- */\n    /*      Read back from the memory buffer.  It would be preferable       */\n    /*      to be able to \"steal\" the memory buffer, but there isn't        */\n    /*      currently any support for this.                                 */\n    /* -------------------------------------------------------------------- */\n    GUIntBig nBigLength = 0;\n\n    *ppabyBuffer = VSIGetMemFileBuffer(szFilename, &nBigLength, TRUE);\n    *pnSize = static_cast<int>(nBigLength);\n\n    return CE_None;\n}",
    "void GTiffDataset::Crystalize()\n\n{\n    if (m_bCrystalized)\n        return;\n\n    // TODO: libtiff writes extended tags in the order they are specified\n    // and not in increasing order.\n    WriteMetadata(this, m_hTIFF, true, m_eProfile, m_pszFilename,\n                  m_papszCreationOptions);\n    WriteGeoTIFFInfo();\n    if (m_bNoDataSet)\n        WriteNoDataValue(m_hTIFF, m_dfNoDataValue);\n    else if (m_bNoDataSetAsInt64)\n        WriteNoDataValue(m_hTIFF, m_nNoDataValueInt64);\n    else if (m_bNoDataSetAsUInt64)\n        WriteNoDataValue(m_hTIFF, m_nNoDataValueUInt64);\n\n    m_bMetadataChanged = false;\n    m_bGeoTIFFInfoChanged = false;\n    m_bNoDataChanged = false;\n    m_bNeedsRewrite = false;\n\n    m_bCrystalized = true;\n\n    TIFFWriteCheck(m_hTIFF, TIFFIsTiled(m_hTIFF), \"GTiffDataset::Crystalize\");\n\n    TIFFWriteDirectory(m_hTIFF);\n    if (m_bStreamingOut)\n    {\n        // We need to write twice the directory to be sure that custom\n        // TIFF tags are correctly sorted and that padding bytes have been\n        // added.\n        TIFFSetDirectory(m_hTIFF, 0);\n        TIFFWriteDirectory(m_hTIFF);\n\n        if (VSIFSeekL(m_fpL, 0, SEEK_END) != 0)\n        {\n            ReportError(CE_Failure, CPLE_FileIO, \"Could not seek\");\n        }\n        const int nSize = static_cast<int>(VSIFTellL(m_fpL));\n\n        TIFFSetDirectory(m_hTIFF, 0);\n        GTiffFillStreamableOffsetAndCount(m_hTIFF, nSize);\n        TIFFWriteDirectory(m_hTIFF);\n\n        vsi_l_offset nDataLength = 0;\n        void *pabyBuffer =\n            VSIGetMemFileBuffer(m_pszTmpFilename, &nDataLength, FALSE);\n        if (static_cast<int>(VSIFWriteL(\n                pabyBuffer, 1, static_cast<int>(nDataLength), m_fpToWrite)) !=\n            static_cast<int>(nDataLength))\n        {\n            ReportError(CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                        static_cast<int>(nDataLength));\n        }\n        // In case of single strip file, there's a libtiff check that would\n        // issue a warning since the file hasn't the required size.\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        TIFFSetDirectory(m_hTIFF, 0);\n        CPLPopErrorHandler();\n    }\n    else\n    {\n        TIFFSetDirectory(\n            m_hTIFF, static_cast<tdir_t>(TIFFNumberOfDirectories(m_hTIFF) - 1));\n    }\n\n    RestoreVolatileParameters(m_hTIFF);\n\n    m_nDirOffset = TIFFCurrentDirOffset(m_hTIFF);\n}",
    "int GTiffDataset::GuessJPEGQuality(bool &bOutHasQuantizationTable,\n                                   bool &bOutHasHuffmanTable)\n{\n    CPLAssert(m_nCompression == COMPRESSION_JPEG);\n    uint32_t nJPEGTableSize = 0;\n    void *pJPEGTable = nullptr;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize,\n                      &pJPEGTable))\n    {\n        bOutHasQuantizationTable = false;\n        bOutHasHuffmanTable = false;\n        return -1;\n    }\n\n    bOutHasQuantizationTable =\n        GTIFFFindNextTable(static_cast<const GByte *>(pJPEGTable),\n                           MARKER_QUANT_TABLE, nJPEGTableSize,\n                           nullptr) != nullptr;\n    bOutHasHuffmanTable =\n        GTIFFFindNextTable(static_cast<const GByte *>(pJPEGTable),\n                           MARKER_HUFFMAN_TABLE, nJPEGTableSize,\n                           nullptr) != nullptr;\n    if (!bOutHasQuantizationTable)\n        return -1;\n\n    if ((nBands == 1 && m_nBitsPerSample == 8) ||\n        (nBands == 3 && m_nBitsPerSample == 8 &&\n         m_nPhotometric == PHOTOMETRIC_RGB) ||\n        (nBands == 4 && m_nBitsPerSample == 8 &&\n         m_nPhotometric == PHOTOMETRIC_SEPARATED))\n    {\n        return GuessJPEGQualityFromMD5(md5JPEGQuantTable_generic_8bit,\n                                       static_cast<const GByte *>(pJPEGTable),\n                                       static_cast<int>(nJPEGTableSize));\n    }\n\n    if (nBands == 3 && m_nBitsPerSample == 8 &&\n        m_nPhotometric == PHOTOMETRIC_YCBCR)\n    {\n        int nRet =\n            GuessJPEGQualityFromMD5(md5JPEGQuantTable_3_YCBCR_8bit,\n                                    static_cast<const GByte *>(pJPEGTable),\n                                    static_cast<int>(nJPEGTableSize));\n        if (nRet < 0)\n        {\n            // libjpeg 9e has modified the YCbCr quantization tables.\n            nRet =\n                GuessJPEGQualityFromMD5(md5JPEGQuantTable_3_YCBCR_8bit_jpeg9e,\n                                        static_cast<const GByte *>(pJPEGTable),\n                                        static_cast<int>(nJPEGTableSize));\n        }\n        return nRet;\n    }\n\n    char **papszLocalParameters = nullptr;\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"COMPRESS\", \"JPEG\");\n    if (m_nPhotometric == PHOTOMETRIC_YCBCR)\n        papszLocalParameters =\n            CSLSetNameValue(papszLocalParameters, \"PHOTOMETRIC\", \"YCBCR\");\n    else if (m_nPhotometric == PHOTOMETRIC_SEPARATED)\n        papszLocalParameters =\n            CSLSetNameValue(papszLocalParameters, \"PHOTOMETRIC\", \"CMYK\");\n    papszLocalParameters =\n        CSLSetNameValue(papszLocalParameters, \"BLOCKYSIZE\", \"16\");\n    if (m_nBitsPerSample == 12)\n        papszLocalParameters =\n            CSLSetNameValue(papszLocalParameters, \"NBITS\", \"12\");\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf(\"/vsimem/gtiffdataset_guess_jpeg_quality_tmp_%p\",\n                           this);\n\n    int nRet = -1;\n    for (int nQuality = 0; nQuality <= 100 && nRet < 0; ++nQuality)\n    {\n        VSILFILE *fpTmp = nullptr;\n        if (nQuality == 0)\n            papszLocalParameters =\n                CSLSetNameValue(papszLocalParameters, \"JPEG_QUALITY\", \"75\");\n        else\n            papszLocalParameters =\n                CSLSetNameValue(papszLocalParameters, \"JPEG_QUALITY\",\n                                CPLSPrintf(\"%d\", nQuality));\n\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        CPLString osTmp;\n        TIFF *hTIFFTmp =\n            CreateLL(osTmpFilenameIn, 16, 16, (nBands <= 4) ? nBands : 1,\n                     GetRasterBand(1)->GetRasterDataType(), 0.0,\n                     papszLocalParameters, &fpTmp, osTmp);\n        CPLPopErrorHandler();\n        if (!hTIFFTmp)\n        {\n            break;\n        }\n\n        TIFFWriteCheck(hTIFFTmp, FALSE, \"CreateLL\");\n        TIFFWriteDirectory(hTIFFTmp);\n        TIFFSetDirectory(hTIFFTmp, 0);\n        // Now reset jpegcolormode.\n        if (m_nPhotometric == PHOTOMETRIC_YCBCR &&\n            CPLTestBool(CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\")))\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n\n        GByte abyZeroData[(16 * 16 * 4 * 3) / 2] = {};\n        const int nBlockSize =\n            (16 * 16 * ((nBands <= 4) ? nBands : 1) * m_nBitsPerSample) / 8;\n        TIFFWriteEncodedStrip(hTIFFTmp, 0, abyZeroData, nBlockSize);\n\n        uint32_t nJPEGTableSizeTry = 0;\n        void *pJPEGTableTry = nullptr;\n        if (TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSizeTry,\n                         &pJPEGTableTry))\n        {\n            if (GTIFFQuantizationTablesEqual(\n                    static_cast<GByte *>(pJPEGTable), nJPEGTableSize,\n                    static_cast<GByte *>(pJPEGTableTry), nJPEGTableSizeTry))\n            {\n                nRet = (nQuality == 0) ? 75 : nQuality;\n            }\n        }\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n\n    CSLDestroy(papszLocalParameters);\n    VSIUnlink(osTmpFilenameIn);\n\n    return nRet;\n}",
    "void SavePointCloudToTiff(float *src_pc, INT32 width, INT32 height, char *fileName)\n{\n\tINT32  x, y, pos_src, pos_dst, y_offset, z_offset;\n\tTIFF   *imageTiff = NULL;\n\tfloat  *point_cloud = (float*)malloc(width * height * 3 * sizeof(float));\n\tint    bitSize = 32;\n\tfloat  *ptrPageImage;\n\n\t// re-arrange point cloud data\n\ty_offset = width * height;\n\tz_offset = y_offset * 2;\n#pragma omp parallel for firstprivate(x, pos_src, pos_dst)\n\tfor (y = 0; y < height; y++) {\n\t\tpos_src = y * width * 3;\n\t\tpos_dst = y * width;\n\t\tfor (x = 0; x < width; x++) {\n\t\t\tif (src_pc[pos_src+2] < 1e+6f) {\n\t\t\t\tpoint_cloud[pos_dst         ] = src_pc[pos_src  ];\n\t\t\t\tpoint_cloud[pos_dst+y_offset] = src_pc[pos_src+1];\n\t\t\t\tpoint_cloud[pos_dst+z_offset] = src_pc[pos_src+2];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpoint_cloud[pos_dst         ] = NAN;\n\t\t\t\tpoint_cloud[pos_dst+y_offset] = NAN;\n\t\t\t\tpoint_cloud[pos_dst+z_offset] = NAN;\n\t\t\t}\n\t\t\tpos_src += 3;\n\t\t\tpos_dst++;\n\t\t}\n\t}\n\n\timageTiff = TIFFOpen(fileName, \"w\");\n\tif (imageTiff == NULL)   return;\n\tfor (int page = 0; page < 3; page++) {\n\t\tptrPageImage = point_cloud + (width * height) * page;\n\n\t\tTIFFSetField(imageTiff, TIFFTAG_IMAGEWIDTH, width);\n\t\tTIFFSetField(imageTiff, TIFFTAG_IMAGELENGTH, height);\n\t\tTIFFSetField(imageTiff, TIFFTAG_BITSPERSAMPLE, bitSize);\n\t\tTIFFSetField(imageTiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n\t\tTIFFSetField(imageTiff, TIFFTAG_SAMPLESPERPIXEL, 1);\n\t\tTIFFSetField(imageTiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tTIFFSetField(imageTiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\t\tTIFFSetField(imageTiff, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\t\tTIFFSetField(imageTiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(imageTiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\tTIFFSetField(imageTiff, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n\t\tTIFFSetField(imageTiff, TIFFTAG_PAGENUMBER, page, 3);\n\n\t\tsize_t stride = width;\n\t\tfor (int i = 0; i < height; i++) {\n\t\t\tTIFFWriteScanline(imageTiff, ptrPageImage + i * stride, i, 0);\n\t\t}\n\t\tTIFFWriteDirectory(imageTiff);\n\n\t}\n\tTIFFClose(imageTiff);\n\tif (point_cloud != NULL) free(point_cloud);\n}",
    "toff_t GTIFFWriteDirectory(TIFF *hTIFF, int nSubfileType, int nXSize, int nYSize,\n                           int nBitsPerPixel, int nPlanarConfig, int nSamples, \n                           int nBlockXSize, int nBlockYSize,\n                           int bTiled, int nCompressFlag, int nPhotometric,\n                           int nSampleFormat, \n                           int nPredictor,\n                           unsigned short *panRed,\n                           unsigned short *panGreen,\n                           unsigned short *panBlue,\n                           int nExtraSamples,\n                           unsigned short *panExtraSampleValues,\n                           const char *pszMetadata )\n\n{\n    toff_t\tnBaseDirOffset;\n    toff_t\tnOffset;\n\n    nBaseDirOffset = TIFFCurrentDirOffset( hTIFF );\n\n#if defined(TIFFLIB_VERSION) && TIFFLIB_VERSION >= 20051201 /* 3.8.0 */\n    TIFFFreeDirectory( hTIFF );\n#endif\n\n    TIFFCreateDirectory( hTIFF );\n    \n/* -------------------------------------------------------------------- */\n/*      Setup TIFF fields.                                              */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, nXSize );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, nYSize );\n    if( nSamples == 1 )\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n    else\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, nPlanarConfig );\n\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, nBitsPerPixel );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, nSamples );\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, nCompressFlag );\n    TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, nPhotometric );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT, nSampleFormat );\n\n    if( bTiled )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_TILEWIDTH, nBlockXSize );\n        TIFFSetField( hTIFF, TIFFTAG_TILELENGTH, nBlockYSize );\n    }\n    else\n        TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, nBlockYSize );\n\n    TIFFSetField( hTIFF, TIFFTAG_SUBFILETYPE, nSubfileType );\n\n    if (panExtraSampleValues != NULL)\n    {\n        TIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, nExtraSamples, panExtraSampleValues );\n    }\n\n    if ( nCompressFlag == COMPRESSION_LZW ||\n         nCompressFlag == COMPRESSION_ADOBE_DEFLATE )\n        TIFFSetField( hTIFF, TIFFTAG_PREDICTOR, nPredictor );\n\n/* -------------------------------------------------------------------- */\n/*\tWrite color table if one is present.\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    if( panRed != NULL )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panRed, panGreen, panBlue );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write metadata if we have some.                                 */\n/* -------------------------------------------------------------------- */\n    if( pszMetadata && strlen(pszMetadata) > 0 )\n        TIFFSetField( hTIFF, TIFFTAG_GDAL_METADATA, pszMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Write directory, and return byte offset.                        */\n/* -------------------------------------------------------------------- */\n    if( TIFFWriteCheck( hTIFF, bTiled, \"GTIFFWriteDirectory\" ) == 0 )\n    {\n        TIFFSetSubDirectory( hTIFF, nBaseDirOffset );\n        return 0;\n    }\n\n    TIFFWriteDirectory( hTIFF );\n    TIFFSetDirectory( hTIFF, (tdir_t) (TIFFNumberOfDirectories(hTIFF)-1) );\n\n    nOffset = TIFFCurrentDirOffset( hTIFF );\n\n    TIFFSetSubDirectory( hTIFF, nBaseDirOffset );\n\n    return nOffset;\n}",
    "GDALDataset *\nGTiffDataset::CreateCopy( const char * pszFilename, GDALDataset *poSrcDS, \n                          int bStrict, char ** papszOptions, \n                          GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    TIFF\t*hTIFF;\n    int\t\tnXSize = poSrcDS->GetRasterXSize();\n    int\t\tnYSize = poSrcDS->GetRasterYSize();\n    int\t\tnBands = poSrcDS->GetRasterCount();\n    int         iBand;\n    CPLErr      eErr = CE_None;\n    uint16\tnPlanarConfig;\n    uint16\tnBitsPerSample;\n    GDALRasterBand *poPBand;\n\n    if( poSrcDS->GetRasterCount() == 0 )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Unable to export GeoTIFF files with zero bands.\" );\n        return NULL;\n    }\n        \n    poPBand = poSrcDS->GetRasterBand(1);\n    GDALDataType eType = poPBand->GetRasterDataType();\n\n/* -------------------------------------------------------------------- */\n/*      Check, whether all bands in input dataset has the same type.    */\n/* -------------------------------------------------------------------- */\n    for ( iBand = 2; iBand <= nBands; iBand++ )\n    {\n        if ( eType != poSrcDS->GetRasterBand(iBand)->GetRasterDataType() )\n        {\n            if ( bStrict )\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"Unable to export GeoTIFF file with different datatypes per\\n\"\n                          \"different bands. All bands should have the same types in TIFF.\" );\n                return NULL;\n            }\n            else\n            {\n                CPLError( CE_Warning, CPLE_AppDefined,\n                          \"Unable to export GeoTIFF file with different datatypes per\\n\"\n                          \"different bands. All bands should have the same types in TIFF.\" );\n            }\n        }\n    }\n\n    if( !pfnProgress( 0.0, NULL, pProgressData ) )\n        return NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the profile.                                            */\n/* -------------------------------------------------------------------- */\n    const char          *pszProfile;\n    int                 bGeoTIFF;\n\n    pszProfile = CSLFetchNameValue(papszOptions,\"PROFILE\");\n    if( pszProfile == NULL )\n        pszProfile = \"GDALGeoTIFF\";\n\n    if( !EQUAL(pszProfile,\"BASELINE\") \n        && !EQUAL(pszProfile,\"GeoTIFF\") \n        && !EQUAL(pszProfile,\"GDALGeoTIFF\") )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined, \n                  \"PROFILE=%s not supported in GTIFF driver.\", \n                  pszProfile );\n        return NULL;\n    }\n    \n    if( EQUAL(pszProfile,\"BASELINE\") )\n        bGeoTIFF = FALSE;\n    else\n        bGeoTIFF = TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      Special handling for NBITS.  Copy from band metadata if found.  */\n/* -------------------------------------------------------------------- */\n    char     **papszCreateOptions = CSLDuplicate( papszOptions );\n\n    if( poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" ) != NULL \n        && atoi(poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" )) > 0\n        && CSLFetchNameValue( papszCreateOptions, \"NBITS\") == NULL )\n    {\n        papszCreateOptions = \n            CSLSetNameValue( papszCreateOptions, \"NBITS\",\n                             poPBand->GetMetadataItem( \"NBITS\", \n                                                       \"IMAGE_STRUCTURE\" ) );\n    }\n\n    if( CSLFetchNameValue( papszOptions, \"PIXELTYPE\" ) == NULL\n        && eType == GDT_Byte\n        && poPBand->GetMetadataItem( \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) )\n    {\n        papszCreateOptions = \n            CSLSetNameValue( papszCreateOptions, \"PIXELTYPE\", \n                             poPBand->GetMetadataItem( \n                                 \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) );\n    }\n    \n    int nSrcOverviews = poSrcDS->GetRasterBand(1)->GetOverviewCount();\n    double dfExtraSpaceForOverviews = 0;\n    if (nSrcOverviews != 0 &&\n        CSLFetchBoolean(papszOptions, \"COPY_SRC_OVERVIEWS\", FALSE))\n    {\n        int i;\n        for(i=0;i<nSrcOverviews;i++)\n        {\n            dfExtraSpaceForOverviews += ((double)poSrcDS->GetRasterBand(1)->GetOverview(i)->GetXSize()) *\n                                        poSrcDS->GetRasterBand(1)->GetOverview(i)->GetYSize();\n        }\n        dfExtraSpaceForOverviews *= nBands * (GDALGetDataTypeSize(eType) / 8);\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Create the file.                                                */\n/* -------------------------------------------------------------------- */\n    hTIFF = CreateLL( pszFilename, nXSize, nYSize, nBands, \n                      eType, dfExtraSpaceForOverviews, papszCreateOptions );\n\n    CSLDestroy( papszCreateOptions );\n\n    if( hTIFF == NULL )\n        return NULL;\n\n    TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &nPlanarConfig );\n    TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &nBitsPerSample );\n\n/* -------------------------------------------------------------------- */\n/*      Are we really producing an RGBA image?  If so, set the          */\n/*      associated alpha information.                                   */\n/* -------------------------------------------------------------------- */\n    int bForcePhotometric = \n        CSLFetchNameValue(papszOptions,\"PHOTOMETRIC\") != NULL;\n\n    if( nBands == 4 && !bForcePhotometric\n        && poSrcDS->GetRasterBand(4)->GetColorInterpretation()==GCI_AlphaBand)\n    {\n        uint16 v[1];\n\n        v[0] = EXTRASAMPLE_ASSOCALPHA;\n\tTIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n        TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the output is jpeg compressed, and the input is RGB make     */\n/*      sure we note that.                                              */\n/* -------------------------------------------------------------------- */\n    uint16      nCompression;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n\n    if( nCompression == COMPRESSION_JPEG )\n    {\n        if( nBands >= 3 \n            && (poSrcDS->GetRasterBand(1)->GetColorInterpretation() \n                == GCI_YCbCr_YBand)\n            && (poSrcDS->GetRasterBand(2)->GetColorInterpretation() \n                == GCI_YCbCr_CbBand)\n            && (poSrcDS->GetRasterBand(3)->GetColorInterpretation() \n                == GCI_YCbCr_CrBand) )\n        {\n            /* do nothing ... */\n        }\n        else\n        {\n            /* we assume RGB if it isn't explicitly YCbCr */\n            CPLDebug( \"GTiff\", \"Setting JPEGCOLORMODE_RGB\" );\n            TIFFSetField( hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );\n        }\n    }\n        \n/* -------------------------------------------------------------------- */\n/*      Does the source image consist of one band, with a palette?      */\n/*      If so, copy over.                                               */\n/* -------------------------------------------------------------------- */\n    if( (nBands == 1 || nBands == 2) && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n        && eType == GDT_Byte )\n    {\n        unsigned short\tanTRed[256], anTGreen[256], anTBlue[256];\n        GDALColorTable *poCT;\n\n        poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n        \n        for( int iColor = 0; iColor < 256; iColor++ )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = (unsigned short) (257 * sRGB.c1);\n                anTGreen[iColor] = (unsigned short) (257 * sRGB.c2);\n                anTBlue[iColor] = (unsigned short) (257 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = anTGreen[iColor] = anTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, anTRed, anTGreen, anTBlue );\n    }\n    else if( (nBands == 1 || nBands == 2) \n             && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n             && eType == GDT_UInt16 )\n    {\n        unsigned short\t*panTRed, *panTGreen, *panTBlue;\n        GDALColorTable *poCT;\n\n        panTRed   = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n        panTGreen = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n        panTBlue  = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n\n        poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n        \n        for( int iColor = 0; iColor < 65536; iColor++ )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                panTRed[iColor] = (unsigned short) (256 * sRGB.c1);\n                panTGreen[iColor] = (unsigned short) (256 * sRGB.c2);\n                panTBlue[iColor] = (unsigned short) (256 * sRGB.c3);\n            }\n            else\n            {\n                panTRed[iColor] = panTGreen[iColor] = panTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n    else if( poSrcDS->GetRasterBand(1)->GetColorTable() != NULL )\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"Unable to export color table to GeoTIFF file.  Color tables\\n\"\n                  \"can only be written to 1 band or 2 bands Byte or UInt16 GeoTIFF files.\" );\n\n    if( nBands == 2\n        && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n        && (eType == GDT_Byte || eType == GDT_UInt16) )\n    {\n        uint16 v[1] = { EXTRASAMPLE_UNASSALPHA };\n\n        TIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, 1, v );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Transfer some TIFF specific metadata, if available.             */\n/*      The return value will tell us if we need to try again later with*/\n/*      PAM because the profile doesn't allow to write some metadata    */\n/*      as TIFF tag                                                     */\n/* -------------------------------------------------------------------- */\n    int bHasWrittenMDInGeotiffTAG =\n            GTiffDataset::WriteMetadata( poSrcDS, hTIFF, FALSE, pszProfile,\n                                 pszFilename, papszOptions );\n\n/* -------------------------------------------------------------------- */\n/* \tWrite NoData value, if exist.                                   */\n/* -------------------------------------------------------------------- */\n    if( EQUAL(pszProfile,\"GDALGeoTIFF\") )\n    {\n        int\t\tbSuccess;\n        double\tdfNoData;\n    \n        dfNoData = poSrcDS->GetRasterBand(1)->GetNoDataValue( &bSuccess );\n        if ( bSuccess )\n            GTiffDataset::WriteNoDataValue( hTIFF, dfNoData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Are we addressing PixelIsPoint mode?                            */\n/* -------------------------------------------------------------------- */\n    bool bPixelIsPoint = false;\n    int  bPointGeoIgnore = FALSE;\n\n    if( poSrcDS->GetMetadataItem( GDALMD_AREA_OR_POINT ) \n        && EQUAL(poSrcDS->GetMetadataItem(GDALMD_AREA_OR_POINT),\n                 GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore = \n            CSLTestBoolean( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                               \"FALSE\") );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write affine transform if it is meaningful.                     */\n/* -------------------------------------------------------------------- */\n    const char *pszProjection = NULL;\n    double      adfGeoTransform[6];\n    \n    if( poSrcDS->GetGeoTransform( adfGeoTransform ) == CE_None\n        && (adfGeoTransform[0] != 0.0 || adfGeoTransform[1] != 1.0\n            || adfGeoTransform[2] != 0.0 || adfGeoTransform[3] != 0.0\n            || adfGeoTransform[4] != 0.0 || adfGeoTransform[5] != 1.0 ))\n    {\n        if( bGeoTIFF )\n        {\n            if( adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0 \n                && adfGeoTransform[5] < 0.0 )\n            {\n\n                double\tadfPixelScale[3], adfTiePoints[6];\n\n                adfPixelScale[0] = adfGeoTransform[1];\n                adfPixelScale[1] = fabs(adfGeoTransform[5]);\n                adfPixelScale[2] = 0.0;\n\n                TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n            \n                adfTiePoints[0] = 0.0;\n                adfTiePoints[1] = 0.0;\n                adfTiePoints[2] = 0.0;\n                adfTiePoints[3] = adfGeoTransform[0];\n                adfTiePoints[4] = adfGeoTransform[3];\n                adfTiePoints[5] = 0.0;\n                \n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfTiePoints[3] += adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                    adfTiePoints[4] += adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n                }\n\t    \n                TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n            }\n            else\n            {\n                double\tadfMatrix[16];\n\n                memset(adfMatrix,0,sizeof(double) * 16);\n\n                adfMatrix[0] = adfGeoTransform[1];\n                adfMatrix[1] = adfGeoTransform[2];\n                adfMatrix[3] = adfGeoTransform[0];\n                adfMatrix[4] = adfGeoTransform[4];\n                adfMatrix[5] = adfGeoTransform[5];\n                adfMatrix[7] = adfGeoTransform[3];\n                adfMatrix[15] = 1.0;\n                \n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfMatrix[3] += adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                    adfMatrix[7] += adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n                }\n\n                TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n            }\n            \n            pszProjection = poSrcDS->GetProjectionRef();\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need a TFW file?                                          */\n/* -------------------------------------------------------------------- */\n        if( CSLFetchBoolean( papszOptions, \"TFW\", FALSE ) )\n            GDALWriteWorldFile( pszFilename, \"tfw\", adfGeoTransform );\n        else if( CSLFetchBoolean( papszOptions, \"WORLDFILE\", FALSE ) )\n            GDALWriteWorldFile( pszFilename, \"wld\", adfGeoTransform );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise write tiepoints if they are available.                */\n/* -------------------------------------------------------------------- */\n    else if( poSrcDS->GetGCPCount() > 0 && bGeoTIFF )\n    {\n        const GDAL_GCP *pasGCPs = poSrcDS->GetGCPs();\n        double\t*padfTiePoints;\n\n        padfTiePoints = (double *) \n            CPLMalloc(6*sizeof(double)*poSrcDS->GetGCPCount());\n\n        for( int iGCP = 0; iGCP < poSrcDS->GetGCPCount(); iGCP++ )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPs[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPs[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPs[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPs[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPs[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] += 0.5;\n                padfTiePoints[iGCP*6+1] += 0.5;\n            }\n        }\n\n        TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, \n                      6*poSrcDS->GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n        \n        pszProjection = poSrcDS->GetGCPProjection();\n        \n        if( CSLFetchBoolean( papszOptions, \"TFW\", FALSE ) \n            || CSLFetchBoolean( papszOptions, \"WORLDFILE\", FALSE ) )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"TFW=ON or WORLDFILE=ON creation options are ignored when GCPs are available\");\n        }\n    }\n\n    else\n        pszProjection = poSrcDS->GetProjectionRef();\n\n/* -------------------------------------------------------------------- */\n/*      Write the projection information, if possible.                  */\n/* -------------------------------------------------------------------- */\n    if( pszProjection != NULL && strlen(pszProjection) > 0 && bGeoTIFF )\n    {\n        GTIF\t*psGTIF;\n\n        psGTIF = GTIFNew( hTIFF );\n        GTIFSetFromOGISDefn( psGTIF, pszProjection );\n\n        if( poSrcDS->GetMetadataItem( GDALMD_AREA_OR_POINT ) \n            && EQUAL(poSrcDS->GetMetadataItem(GDALMD_AREA_OR_POINT),\n                     GDALMD_AOP_POINT) )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we are writing jpeg compression we need to write some        */\n/*      imagery to force the jpegtables to get created.  This is,       */\n/*      likely only needed with libtiff >= 3.9.3 (#3633)                */\n/* -------------------------------------------------------------------- */\n    int bDontReloadFirstBlock = FALSE;\n    if( nCompression == COMPRESSION_JPEG\n        && strstr(TIFFLIB_VERSION_STR, \"Version 3.9\") != NULL )\n    {\n        CPLDebug( \"GDAL\", \n                  \"Writing zero block to force creation of JPEG tables.\" );\n        if( TIFFIsTiled( hTIFF ) )\n        {\n            int cc = TIFFTileSize( hTIFF );\n            unsigned char *pabyZeros = (unsigned char *) CPLCalloc(cc,1);\n            TIFFWriteEncodedTile(hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        else\n        {\n            int cc = TIFFStripSize( hTIFF );\n            unsigned char *pabyZeros = (unsigned char *) CPLCalloc(cc,1);\n            TIFFWriteEncodedStrip(hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        bDontReloadFirstBlock = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup                                                         */\n/* -------------------------------------------------------------------- */\n    \n    TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTiffCreateCopy()\");\n    TIFFWriteDirectory( hTIFF );\n    TIFFFlush( hTIFF );\n    XTIFFClose( hTIFF );\n    hTIFF = NULL;\n\n    if( eErr != CE_None )\n    {\n        VSIUnlink( pszFilename );\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Re-open as a dataset and copy over missing metadata using       */\n/*      PAM facilities.                                                 */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS;\n    CPLString osFileName(\"GTIFF_RAW:\");\n\n    osFileName += pszFilename;\n\n    poDS = (GTiffDataset *) GDALOpen( osFileName, GA_Update );\n    if( poDS == NULL )\n        poDS = (GTiffDataset *) GDALOpen( osFileName, GA_ReadOnly );\n\n    if ( poDS == NULL )\n    {\n        VSIUnlink( pszFilename );\n        return NULL;\n    }\n\n    poDS->osProfile = pszProfile;\n    poDS->CloneInfo( poSrcDS, GCIF_PAM_DEFAULT & ~GCIF_MASK );\n    poDS->papszCreationOptions = CSLDuplicate( papszOptions );\n    poDS->bDontReloadFirstBlock = bDontReloadFirstBlock;\n\n/* -------------------------------------------------------------------- */\n/*      CloneInfo() doesn't merge metadata, it just replaces it totally */\n/*      So we have to merge it                                          */\n/* -------------------------------------------------------------------- */\n\n    char **papszSRC_MD = poSrcDS->GetMetadata();\n    char **papszDST_MD = CSLDuplicate(poDS->GetMetadata());\n\n    papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n    poDS->SetMetadata( papszDST_MD );\n    CSLDestroy( papszDST_MD );\n\n    /* Depending on the PHOTOMETRIC tag, the TIFF file may not have */\n    /* the same band count as the source. Will fail later in GDALDatasetCopyWholeRaster anyway... */\n    for( int nBand = 1;\n         nBand <= MIN(poDS->GetRasterCount(), poSrcDS->GetRasterCount()) ;\n         nBand++ )\n    {\n        char **papszSRC_MD = poSrcDS->GetRasterBand(nBand)->GetMetadata();\n        char **papszDST_MD = CSLDuplicate(poDS->GetRasterBand(nBand)->GetMetadata());\n\n        papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n        poDS->GetRasterBand(nBand)->SetMetadata( papszDST_MD );\n        CSLDestroy( papszDST_MD );\n    }\n\n    hTIFF = (TIFF*) poDS->GetInternalHandle(NULL);\n\n/* -------------------------------------------------------------------- */\n/*      Handle forcing xml:ESRI data to be written to PAM.              */\n/* -------------------------------------------------------------------- */\n    if( CSLTestBoolean(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n    {\n        char **papszESRIMD = poSrcDS->GetMetadata(\"xml:ESRI\");\n        if( papszESRIMD )\n        {\n            poDS->SetMetadata( papszESRIMD, \"xml:ESRI\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Second chance : now that we have a PAM dataset, it is possible  */\n/*      to write metadata that we couldn't be writen as TIFF tag        */\n/* -------------------------------------------------------------------- */\n    if (!bHasWrittenMDInGeotiffTAG)\n        GTiffDataset::WriteMetadata( poDS, hTIFF, TRUE, pszProfile,\n                                     pszFilename, papszOptions, TRUE /* don't write RPC and IMD file again */);\n\n    /* To avoid unnecessary directory rewriting */\n    poDS->bMetadataChanged = FALSE;\n    poDS->bGeoTIFFInfoChanged = FALSE;\n\n    /* We must re-set the compression level at this point, since it has */\n    /* been lost a few lines above when closing the newly create TIFF file */\n    /* The TIFFTAG_ZIPQUALITY & TIFFTAG_JPEGQUALITY are not store in the TIFF file. */\n    /* They are just TIFF session parameters */\n\n    poDS->nZLevel = GTiffGetZLevel(papszOptions);\n    poDS->nLZMAPreset = GTiffGetLZMAPreset(papszOptions);\n    poDS->nJpegQuality = GTiffGetJpegQuality(papszOptions);\n\n    if (nCompression == COMPRESSION_ADOBE_DEFLATE)\n    {\n        if (poDS->nZLevel != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_ZIPQUALITY, poDS->nZLevel );\n        }\n    }\n    else if( nCompression == COMPRESSION_JPEG)\n    {\n        if (poDS->nJpegQuality != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_JPEGQUALITY, poDS->nJpegQuality );\n        }\n    }\n    else if( nCompression == COMPRESSION_LZMA)\n    {\n        if (poDS->nLZMAPreset != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_LZMAPRESET, poDS->nLZMAPreset );\n        }\n    }\n\n    /* Precreate (internal) mask, so that the IBuildOverviews() below */\n    /* has a chance to create also the overviews of the mask */\n    int nMaskFlags = poSrcDS->GetRasterBand(1)->GetMaskFlags();\n    if( eErr == CE_None\n        && !(nMaskFlags & (GMF_ALL_VALID|GMF_ALPHA|GMF_NODATA) )\n        && (nMaskFlags & GMF_PER_DATASET) )\n    {\n        eErr = poDS->CreateMaskBand( nMaskFlags );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create and then copy existing overviews if requested            */\n/*  We do it such that all the IFDs are at the beginning of the file,   */\n/*  and that the imagery data for the smallest overview is written      */\n/*  first, that way the file is more usable when embedded in a          */\n/*  compressed stream.                                                  */\n/* -------------------------------------------------------------------- */\n\n    /* For scaled progress due to overview copying */\n    double dfTotalPixels = ((double)nXSize) * nYSize;\n    double dfCurPixels = 0;\n\n    if (eErr == CE_None &&\n        nSrcOverviews != 0 &&\n        CSLFetchBoolean(papszOptions, \"COPY_SRC_OVERVIEWS\", FALSE))\n    {\n        eErr = poDS->CreateOverviewsFromSrcOverviews(poSrcDS);\n\n        if (poDS->nOverviewCount != nSrcOverviews)\n        {\n            CPLError(CE_Failure, CPLE_AppDefined,\n                     \"Did only manage to instanciate %d overview levels, whereas source contains %d\",\n                     poDS->nOverviewCount, nSrcOverviews);\n            eErr = CE_Failure;\n        }\n\n        int i;\n        for(i=0;i<nSrcOverviews;i++)\n        {\n            GDALRasterBand* poOvrBand = poSrcDS->GetRasterBand(1)->GetOverview(i);\n            dfTotalPixels += ((double)poOvrBand->GetXSize()) *\n                                      poOvrBand->GetYSize();\n        }\n\n        char* papszCopyWholeRasterOptions[2] = { NULL, NULL };\n        if (nCompression != COMPRESSION_NONE)\n            papszCopyWholeRasterOptions[0] = (char*) \"COMPRESSED=YES\";\n        /* Now copy the imagery */\n        for(i=0;eErr == CE_None && i<nSrcOverviews;i++)\n        {\n            /* Begin with the smallest overview */\n            int iOvrLevel = nSrcOverviews-1-i;\n            \n            /* Create a fake dataset with the source overview level so that */\n            /* GDALDatasetCopyWholeRaster can cope with it */\n            GDALDataset* poSrcOvrDS = new GDALOverviewDS(poSrcDS, iOvrLevel);\n            \n            GDALRasterBand* poOvrBand =\n                    poSrcDS->GetRasterBand(1)->GetOverview(iOvrLevel);\n            double dfNextCurPixels = dfCurPixels +\n                    ((double)poOvrBand->GetXSize()) * poOvrBand->GetYSize();\n\n            void* pScaledData = GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                      dfNextCurPixels / dfTotalPixels,\n                                      pfnProgress, pProgressData);\n                                \n            eErr = GDALDatasetCopyWholeRaster( (GDALDatasetH) poSrcOvrDS,\n                                                (GDALDatasetH) poDS->papoOverviewDS[iOvrLevel],\n                                                papszCopyWholeRasterOptions,\n                                                GDALScaledProgress, pScaledData );\n                                                \n            dfCurPixels = dfNextCurPixels;\n            GDALDestroyScaledProgress(pScaledData);\n\n            delete poSrcOvrDS;\n            poDS->papoOverviewDS[iOvrLevel]->FlushCache();\n\n            /* Copy mask of the overview */\n            if (eErr == CE_None && poDS->poMaskDS != NULL)\n            {\n                eErr = GDALRasterBandCopyWholeRaster( poOvrBand->GetMaskBand(),\n                                                    poDS->papoOverviewDS[iOvrLevel]->poMaskDS->GetRasterBand(1),\n                                                    papszCopyWholeRasterOptions,\n                                                    GDALDummyProgress, NULL);\n                poDS->papoOverviewDS[iOvrLevel]->poMaskDS->FlushCache();\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy actual imagery.                                            */\n/* -------------------------------------------------------------------- */\n    void* pScaledData = GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                                  1.0,\n                                                  pfnProgress, pProgressData);\n\n    if (poDS->bTreatAsSplit || poDS->bTreatAsSplitBitmap)\n    {\n        /* For split bands, we use TIFFWriteScanline() interface */\n        CPLAssert(poDS->nBitsPerSample == 8 || poDS->nBitsPerSample == 1);\n        \n        if (poDS->nPlanarConfig == PLANARCONFIG_CONTIG && poDS->nBands > 1)\n        {\n            int j;\n            GByte* pabyScanline = (GByte *) CPLMalloc(TIFFScanlineSize(hTIFF));\n            for(j=0;j<nYSize && eErr == CE_None;j++)\n            {\n                eErr = poSrcDS->RasterIO(GF_Read, 0, j, nXSize, 1,\n                                         pabyScanline, nXSize, 1,\n                                         GDT_Byte, nBands, NULL, poDS->nBands, 0, 1);\n                if (eErr == CE_None &&\n                    TIFFWriteScanline( hTIFF, pabyScanline, j, 0) == -1)\n                {\n                    CPLError( CE_Failure, CPLE_AppDefined,\n                              \"TIFFWriteScanline() failed.\" );\n                    eErr = CE_Failure;\n                }\n                if( !GDALScaledProgress( (j+1) * 1.0 / nYSize, NULL, pScaledData ) )\n                    eErr = CE_Failure;\n            }\n            CPLFree(pabyScanline);\n        }\n        else\n        {\n            int iBand, j;\n            GByte* pabyScanline = (GByte *) CPLMalloc(TIFFScanlineSize(hTIFF));\n            eErr = CE_None;\n            for(iBand=1;iBand<=nBands && eErr == CE_None;iBand++)\n            {\n                for(j=0;j<nYSize && eErr == CE_None;j++)\n                {\n                    eErr = poSrcDS->GetRasterBand(iBand)->RasterIO(\n                                                    GF_Read, 0, j, nXSize, 1,\n                                                    pabyScanline, nXSize, 1,\n                                                    GDT_Byte, 0, 0);\n                    if (poDS->bTreatAsSplitBitmap)\n                    {\n                        for(int i=0;i<nXSize;i++)\n                        {\n                            GByte byVal = pabyScanline[i];\n                            if ((i & 0x7) == 0)\n                                pabyScanline[i >> 3] = 0;\n                            if (byVal)\n                                pabyScanline[i >> 3] |= (0x80 >> (i & 0x7));\n                        }\n                    }\n                    if (eErr == CE_None &&\n                        TIFFWriteScanline( hTIFF, pabyScanline, j, (uint16) (iBand-1)) == -1)\n                    {\n                        CPLError( CE_Failure, CPLE_AppDefined,\n                                  \"TIFFWriteScanline() failed.\" );\n                        eErr = CE_Failure;\n                    }\n                    if( !GDALScaledProgress( (j+1 + (iBand - 1) * nYSize) * 1.0 /\n                                      (nBands * nYSize), NULL, pScaledData ) )\n                        eErr = CE_Failure;\n                }\n            }\n            CPLFree(pabyScanline);\n        }\n        \n        /* Necessary to be able to read the file without re-opening */\n#if defined(HAVE_TIFFGETSIZEPROC)\n        TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( hTIFF );\n\n        TIFFFlushData( hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            nNewDirOffset++;\n#endif\n\n        TIFFFlush( hTIFF );\n\n#if defined(HAVE_TIFFGETSIZEPROC)\n        if( poDS->nDirOffset != TIFFCurrentDirOffset( hTIFF ) )\n        {\n            poDS->nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\", \"directory moved during flush.\" );\n        }\n#endif\n    }\n    else if (eErr == CE_None)\n    {\n        char* papszCopyWholeRasterOptions[2] = { NULL, NULL };\n        if (nCompression != COMPRESSION_NONE)\n            papszCopyWholeRasterOptions[0] = (char*) \"COMPRESSED=YES\";\n        eErr = GDALDatasetCopyWholeRaster( (GDALDatasetH) poSrcDS, \n                                            (GDALDatasetH) poDS,\n                                            papszCopyWholeRasterOptions,\n                                            GDALScaledProgress, pScaledData );\n    }\n    \n    GDALDestroyScaledProgress(pScaledData);\n\n    if (eErr == CE_None)\n    {\n        if (poDS->poMaskDS)\n        {\n            const char* papszOptions[2] = { \"COMPRESSED=YES\", NULL };\n            eErr = GDALRasterBandCopyWholeRaster(\n                                    poSrcDS->GetRasterBand(1)->GetMaskBand(),\n                                    poDS->GetRasterBand(1)->GetMaskBand(),\n                                    (char**)papszOptions,\n                                    GDALDummyProgress, NULL);\n        }\n        else\n            eErr = GDALDriver::DefaultCopyMasks( poSrcDS, poDS, bStrict );\n    }\n\n    if( eErr == CE_Failure )\n    {\n        delete poDS;\n        poDS = NULL;\n\n        if (CSLTestBoolean(CPLGetConfigOption(\"GTIFF_DELETE_ON_ERROR\", \"YES\")))\n            VSIUnlink( pszFilename ); // should really delete more carefully.\n    }\n\n    return poDS;\n}",
    "uint8_t writeTiffSingle(const uint64_t x, const uint64_t y, const uint64_t z, const char* fileName, const void* tiff, const void* tiffOld, const uint64_t bits, const uint64_t startSlice, const uint64_t stripSize, const char* mode, const bool transpose, const std::string &compression){\n    TIFF* tif = NULL;\n    if(!strcmp(mode,\"w\")){\n        tif = TIFFOpen(fileName, \"w8\");\n        if(!tif){\n            printf(\"Error: File \\\"%s\\\" cannot be opened\",fileName);\n\t\t\treturn 1;\n        }\n    }\n    else if(!strcmp(mode,\"a\")){\n        tif = TIFFOpen(fileName, \"a8\");\n        if(!tif){\n            printf(\"Error: File \\\"%s\\\" cannot be opened\",fileName);\n\t\t\treturn 1;\n        }\n    }\n    else{\n        printf(\"Error: mode \\\"%s\\\" is not supported. Use w or a for mode type\", mode);\n        return 1;\n    }\n\n    uint64_t len = 0;\n    int compressionType = COMPRESSION_NONE;\n    if(compression != \"none\"){\n        compressionType = COMPRESSION_LZW;\n    }\n    for(uint64_t dir = startSlice; dir < z; dir++){\n        if(dir>=z+startSlice) break;\n        TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, x);\n        TIFFSetField(tif, TIFFTAG_IMAGELENGTH, y);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bits);\n        TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, stripSize);\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, compressionType);\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, 1);\n        TIFFSetField(tif, TIFFTAG_PLANARCONFIG, 1);\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n\n        if(bits >= 32){\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n        }\n\n        for (int64_t i = 0; i*stripSize < y; i++)\n        {   \n                if (stripSize*(i+1) > y){\n                    len = (y-(stripSize*i))*x*(bits/8);\n                }\n                else{\n                    len = stripSize*x*(bits/8);\n                }\n                TIFFWriteEncodedStrip(tif, i, (uint8_t*)tiff+((((i*stripSize)*x)+((dir-startSlice)*(x*y)))*(bits/8)), len);\n                //if(transpose) TIFFWriteEncodedStrip(tif, i, (uint8_t*)tiff+((((i*stripSize)*x)+((dir-startSlice)*(x*y)))*(bits/8)), len);\n                //else TIFFWriteEncodedStrip(tif,i,(uint8_t*)tiffOld+((((i*stripSize)*x)+((dir-startSlice)*(x*y)))*(bits/8)), len);\n                //TIFFWriteRawStrip(tif,i,(uint8_t*)tiff+((((i*stripSize)*x)+((dir-startSlice)*(x*y)))*(bits/8)), len);\n        }\n        TIFFWriteDirectory(tif);\n    }\n    TIFFClose(tif);\n    return 0;\n}",
    "uint8_t writeTiffThread(const uint64_t x, const uint64_t y, const uint64_t z, const char* fileName, const void* tiff, const uint64_t bits, const uint64_t startSlice, const uint64_t stripSize, const char* mode, const uint64_t stripsPerDir, uint8_t** &comprA, uint64_t* cSizes, const std::string &compression){\n    TIFF* tif = NULL;\n    if(!strcmp(mode,\"w\")){\n        tif = TIFFOpen(fileName, \"w8\");\n        if(!tif){\n            printf(\"Error: File \\\"%s\\\" cannot be opened\",fileName);\n            return 1;\n        }\n    }\n    else if(!strcmp(mode,\"a\")){\n        tif = TIFFOpen(fileName, \"a8\");\n        if(!tif){\n            printf(\"Error: File \\\"%s\\\" cannot be opened\",fileName);\n            return 1;\n        }\n    }\n    else{\n        printf(\"Error: mode \\\"%s\\\" is not supported. Use w or a for mode type\", mode);\n        return 1;\n    }\n\n    uint64_t len = 0;\n    int compressionType = COMPRESSION_NONE;\n    bool compress = false;\n    if(compression != \"none\"){\n        compress = true;\n        compressionType = COMPRESSION_LZW;\n    }\n    for(uint64_t dir = startSlice; dir < z; dir++){\n        TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, x);\n        TIFFSetField(tif, TIFFTAG_IMAGELENGTH, y);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bits);\n        TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, stripSize);\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, compressionType);\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, 1);\n        TIFFSetField(tif, TIFFTAG_PLANARCONFIG, 1);\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n\n        if(bits >= 32){\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n        }\n\n        for (int64_t i = 0; i*stripSize < y; i++)\n        {\n            if(compress){\n                while(!cSizes[i+(dir*stripsPerDir)]){\n                    std::this_thread::sleep_for(std::chrono::microseconds(1));\n                }\n                TIFFWriteRawStrip(tif,i,comprA[i+(dir*stripsPerDir)], cSizes[i+(dir*stripsPerDir)]);\n                free(comprA[i+(dir*stripsPerDir)]);\n            }\n            else{\n                if (stripSize*(i+1) > y){\n                    len = (y-(stripSize*i))*x*(bits/8);\n                }\n                else{\n                    len = stripSize*x*(bits/8);\n                }\n                TIFFWriteRawStrip(tif,i,(uint8_t*)tiff+((((i*stripSize)*x)+((dir-startSlice)*(x*y)))*(bits/8)), len);\n            }\n        }\n        TIFFWriteDirectory(tif);\n    }\n\tfree(comprA);\n\tfree(cSizes);\n    TIFFClose(tif);\n    return 0;\n}",
    "void QFECamTestCamera::seriesStep1() {\r\n    int camera=0;\r\n\r\n    uint16 frame_samplesperpixel=1;\r\n    uint16 frame_bitspersample=8;\r\n    uint16 frame_sampleformat = SAMPLEFORMAT_UINT;\r\n    uint32 frame_width=getCameraImageWidth(camera);\r\n    uint32 frame_height=getCameraImageHeight(camera);\r\n    uint32 rowsperstrip = (uint32)-1;\r\n\r\n    uint32* frame32 = (uint32*)qfCalloc(frame_width*frame_height, sizeof(uint32));\r\n    uint32 frame_min=0xFFFFFFFF;\r\n    uint32 frame_max=0;\r\n    acquireOnCamera(camera, frame32);\r\n    for (register unsigned int i=0; i<frame_width*frame_height; i++) {\r\n        register uint32 v=frame32[i];\r\n        if (v<frame_min) frame_min=v;\r\n        if (v>frame_max) frame_max=v;\r\n    }\r\n    uint8* frame = (uint8*)qfMalloc(frame_width*frame_height*sizeof(uint8));\r\n    for (register unsigned int i=0; i<frame_width*frame_height; i++) {\r\n        register uint64_t v=255;\r\n        if (frame_max-frame_min!=0) v=(frame32[i]-frame_min)*255/(frame_max-frame_min);\r\n        if (v>255) v=255;\r\n        frame[i]=v;\r\n    }\r\n\r\n\r\n    TIFFSetField(tif[camera], TIFFTAG_IMAGEWIDTH, frame_width);\r\n    TIFFSetField(tif[camera], TIFFTAG_IMAGELENGTH, frame_height);\r\n    TIFFSetField(tif[camera], TIFFTAG_COMPRESSION, COMPRESSION_NONE);\r\n    TIFFSetField(tif[camera], TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n    TIFFSetField(tif[camera], TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\r\n    TIFFSetField(tif[camera], TIFFTAG_BITSPERSAMPLE, frame_bitspersample);\r\n    TIFFSetField(tif[camera], TIFFTAG_SAMPLESPERPIXEL, frame_samplesperpixel);\r\n    rowsperstrip = TIFFDefaultStripSize(tif[camera], rowsperstrip);\r\n    TIFFSetField(tif[camera], TIFFTAG_ROWSPERSTRIP, rowsperstrip);\r\n    TIFFSetField(tif[camera], TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\r\n    TIFFSetField(tif[camera],TIFFTAG_SAMPLEFORMAT,frame_sampleformat);\r\n    TIFFSetField(tif[camera],TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\r\n\r\n    // write frame data\r\n    // data is broken up into strips where each strip contains rowsperstrip complete rows of data\r\n    // each stript then has a size of rowsperstrip*frame_width pixels. the last strip is possibly\r\n    // smaller, so it is NOT padded with dummy data.\r\n    uint8* const buf = (uint8*)_TIFFmalloc(TIFFStripSize(tif[camera])); // data buffer for a strip of the image\r\n    for (unsigned int row = 0; (row<frame_height); row+=rowsperstrip) {\r\n        // compute rows in this strip:\r\n        uint32 nrow = rowsperstrip;\r\n        if ((row + rowsperstrip)>frame_height) {\r\n            nrow=frame_height-row; // this is the last strip ... and it is a bit smaller! ... it only contains the last rows of the image\r\n        }\r\n        tstrip_t strip = TIFFComputeStrip(tif[camera],row,0);\r\n        tsize_t bi = 0;\r\n        // go through the fraem row-wise\r\n        for (unsigned int rr = 0; rr<nrow; ++rr) {\r\n            for (unsigned int cc = 0; cc<frame_width; ++cc) { // go through all pixels in the current row\r\n                buf[bi++] = (uint8)frame[cc+(row + rr)*frame_width];\r\n            }\r\n        }\r\n        TIFFWriteEncodedStrip(tif[camera],strip,buf,bi*sizeof(uint8));\r\n    }\r\n    _TIFFfree(buf);\r\n    // write current directory, i.e. start new image\r\n    TIFFWriteDirectory(tif[camera]);\r\n\r\n\r\n    qfFree(frame);\r\n    qfFree(frame32);\r\n\r\n    seriesCount[camera]++;\r\n    seriesRunning[camera] = seriesRunning[camera] && (seriesCount[camera]<seriesAcquisitions);\r\n\r\n    if (seriesRunning[camera]) {\r\n        QTimer::singleShot(seriesDelay, this, SLOT(seriesStep1()));\r\n        //QApplication::processEvents();\r\n        //seriesStep1();\r\n    } else {\r\n        TIFFClose(tif[camera]);\r\n    }\r\n}",
    "void QFECamTestCamera::seriesStep2() {\r\n    int camera=1;\r\n\r\n    uint16 frame_samplesperpixel=1;\r\n    uint16 frame_bitspersample=8;\r\n    uint16 frame_sampleformat = SAMPLEFORMAT_UINT;\r\n    uint32 frame_width=getCameraImageWidth(camera);\r\n    uint32 frame_height=getCameraImageHeight(camera);\r\n    uint32 rowsperstrip = (uint32)-1;\r\n\r\n    uint32* frame32 = (uint32*)qfCalloc(frame_width*frame_height, sizeof(uint32));\r\n    uint32 frame_min=0xFFFFFFFF;\r\n    uint32 frame_max=0;\r\n    acquireOnCamera(camera, frame32);\r\n    for (register unsigned int i=0; i<frame_width*frame_height; i++) {\r\n        register uint32 v=frame32[i];\r\n        if (v<frame_min) frame_min=v;\r\n        if (v>frame_max) frame_max=v;\r\n    }\r\n    //std::cout<<\"frame_min=\"<<frame_min<<\"   frame_max=\"<<frame_max<<std::endl;\r\n    uint8* frame = (uint8*)qfMalloc(frame_width*frame_height*sizeof(uint8));\r\n    for (register unsigned int i=0; i<frame_width*frame_height; i++) {\r\n        register uint64_t v=(frame32[i]-frame_min)*255/(frame_max-frame_min);\r\n        if (v>255) v=255;\r\n        frame[i]=v;\r\n    }\r\n\r\n\r\n    TIFFSetField(tif[camera], TIFFTAG_IMAGEWIDTH, frame_width);\r\n    TIFFSetField(tif[camera], TIFFTAG_IMAGELENGTH, frame_height);\r\n    TIFFSetField(tif[camera], TIFFTAG_COMPRESSION, COMPRESSION_NONE);\r\n    TIFFSetField(tif[camera], TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n    TIFFSetField(tif[camera], TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\r\n    TIFFSetField(tif[camera], TIFFTAG_BITSPERSAMPLE, frame_bitspersample);\r\n    TIFFSetField(tif[camera], TIFFTAG_SAMPLESPERPIXEL, frame_samplesperpixel);\r\n    rowsperstrip = TIFFDefaultStripSize(tif[camera], rowsperstrip);\r\n    TIFFSetField(tif[camera], TIFFTAG_ROWSPERSTRIP, rowsperstrip);\r\n    TIFFSetField(tif[camera], TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\r\n    TIFFSetField(tif[camera],TIFFTAG_SAMPLEFORMAT,frame_sampleformat);\r\n    TIFFSetField(tif[camera],TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\r\n\r\n    // write frame data\r\n    // data is broken up into strips where each strip contains rowsperstrip complete rows of data\r\n    // each stript then has a size of rowsperstrip*frame_width pixels. the last strip is possibly\r\n    // smaller, so it is NOT padded with dummy data.\r\n    uint8* const buf = (uint8*)_TIFFmalloc(TIFFStripSize(tif[camera])); // data buffer for a strip of the image\r\n    for (unsigned int row = 0; (row<frame_height); row+=rowsperstrip) {\r\n        // compute rows in this strip:\r\n        uint32 nrow = rowsperstrip;\r\n        if ((row + rowsperstrip)>frame_height) {\r\n            nrow=frame_height-row; // this is the last strip ... and it is a bit smaller! ... it only contains the last rows of the image\r\n        }\r\n        tstrip_t strip = TIFFComputeStrip(tif[camera],row,0);\r\n        tsize_t bi = 0;\r\n        // go through the fraem row-wise\r\n        for (unsigned int rr = 0; rr<nrow; ++rr) {\r\n            for (unsigned int cc = 0; cc<frame_width; ++cc) { // go through all pixels in the current row\r\n                buf[bi++] = (uint8)frame[cc+(row + rr)*frame_width];\r\n            }\r\n        }\r\n        TIFFWriteEncodedStrip(tif[camera],strip,buf,bi*sizeof(uint8));\r\n    }\r\n    _TIFFfree(buf);\r\n    // write current directory, i.e. start new image\r\n    TIFFWriteDirectory(tif[camera]);\r\n\r\n\r\n    qfFree(frame);\r\n    qfFree(frame32);\r\n\r\n    seriesCount[camera]++;\r\n    seriesRunning[camera] = seriesRunning[camera] && (seriesCount[camera]<seriesAcquisitions);\r\n\r\n    if (seriesRunning[camera]) {\r\n        QTimer::singleShot(seriesDelay, this,SLOT(seriesStep2()));\r\n    } else {\r\n        TIFFClose(tif[camera]);\r\n    }\r\n}",
    "bool QFESPIMB040MainWindow2::savePreview(QFExtension* /*extension*/, QFExtensionCamera* ecamera, int camera, const QString& previewSettingsFilename, const QString& filename, QString* filename32, QMap<QString, QVariant>* acquisitionDescription, const QString& acquisitionDescriptionPrefix, bool mainShutterOpenOnlyForAcquisition, int frames, bool getMeasurements) {\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // INIT variables\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    bool ok=true;\r\n    QString TIFFFIlename=filename;\r\n    QString TIFFFIlename32=filename.left(filename.size()-(QFileInfo(filename).suffix().size()+1))+\".32.\"+QFileInfo(filename).suffix();\r\n    TIFF* tiff=NULL;\r\n\r\n    if (filename32) *filename32=\"\";\r\n\r\n\r\n    bool oldShutterState=false;\r\n    if (mainShutterOpenOnlyForAcquisition && optSetup->isMainIlluminationShutterAvailable()) oldShutterState=optSetup->getMainIlluminationShutter();\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // Close Main shutter\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    if (mainShutterOpenOnlyForAcquisition && oldShutterState && optSetup->isMainIlluminationShutterAvailable()) {\r\n        optSetup->setMainIlluminationShutter(false, true);\r\n    }\r\n\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // PREPARE CAMERA\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    int width=0, height=0;\r\n    uint32_t* buffer=NULL;\r\n    if (ok) {\r\n        if (!previewSettingsFilename.isEmpty())  {\r\n            QSettings settings(previewSettingsFilename, QSettings::IniFormat);\r\n            ecamera->useCameraSettings(camera, settings);\r\n        }\r\n        width=ecamera->getCameraImageWidth(camera);\r\n        height=ecamera->getCameraImageHeight(camera);\r\n        buffer=(uint32_t*)qfCalloc(width*height, sizeof(uint32_t));\r\n        if (!buffer) {\r\n            ok=false;\r\n        }\r\n    }\r\n\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // Open Main shutter\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    if (mainShutterOpenOnlyForAcquisition && optSetup->isMainIlluminationShutterAvailable()) {\r\n        optSetup->setMainIlluminationShutter(true, true);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // OPEN OUTPUT TIFF FILES\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    if (ok) {\r\n        QMap<QString, QVariant> acqD;\r\n        if (frames<=1) {\r\n\r\n            QTime time=QTime::currentTime();\r\n            if (ecamera->acquireOnCamera(camera, buffer, NULL, &acqD)) {\r\n                //////////////////////////////////////////////////////////////////////////////////////\r\n                // Close Main shutter\r\n                //////////////////////////////////////////////////////////////////////////////////////\r\n                if (mainShutterOpenOnlyForAcquisition && optSetup->isMainIlluminationShutterAvailable()) {\r\n                    optSetup->setMainIlluminationShutter(false, true);\r\n                }\r\n                if (acquisitionDescription) {\r\n                    QMapIterator<QString, QVariant> it(acqD);\r\n                    while (it.hasNext()) {\r\n                        it.next();\r\n                        (*acquisitionDescription)[acquisitionDescriptionPrefix+it.key()]=it.value();\r\n                    }\r\n                    (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/dualview_mode\"]=optSetup->dualViewMode(ecamera, camera);\r\n                    (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/image_width\"]=width;\r\n                    (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/image_height\"]=height;\r\n                    (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/exposure_time\"]=ecamera->getCameraExposureTime(camera);\r\n                    optSetup->saveLightpathConfig((*acquisitionDescription), optSetup->getCurrentLightpath(), acquisitionDescriptionPrefix+\"/lightpath/\", QList<bool>(), true);\r\n                    (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/timestamp\"]=time;\r\n                    getAdditionalCameraSettings(ecamera, camera, acquisitionDescriptionPrefix, (*acquisitionDescription), getMeasurements);\r\n\r\n                }\r\n                QDir().mkpath(QFileInfo(TIFFFIlename.toLatin1().data()).absolutePath());\r\n                tiff=TIFFOpen(TIFFFIlename.toLatin1().data(), \"w\");\r\n                if (!tiff) {\r\n                    ok=false;\r\n                } else {\r\n                    TIFFTWriteUint16from32(tiff, buffer, width, height, false);\r\n                    TIFFClose(tiff);\r\n                }\r\n                bool is32bit=false;\r\n                for (int i=0; i<width*height; i++) {\r\n                    if ((buffer[i]&0xFFFF0000) != 0) {\r\n                        is32bit=true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (ok && is32bit) {\r\n                    tiff=TIFFOpen(TIFFFIlename32.toLatin1().data(), \"w\");\r\n                    if (!tiff) {\r\n                        ok=false;\r\n                    } else {\r\n                        if (filename32) {\r\n                            *filename32=TIFFFIlename32;\r\n                        }\r\n                        TIFFTWriteUint32(tiff, buffer, width, height);\r\n                        TIFFClose(tiff);\r\n                    }\r\n                }\r\n            } else {\r\n                ok=false;\r\n            }\r\n        } else if (frames>=2) {\r\n\r\n            QDir().mkpath(QFileInfo(TIFFFIlename.toLatin1().data()).absolutePath());\r\n            tiff=TIFFOpen(TIFFFIlename.toLatin1().data(), \"w\");\r\n            if (tiff) {\r\n                ok=true;\r\n                bool is32bit=false;\r\n                for (int f=0; f<frames; f++) {\r\n                    QTime time=QTime::currentTime();\r\n                    if (ecamera->acquireOnCamera(camera, buffer, NULL, &acqD)) {\r\n\r\n                        if (acquisitionDescription) {\r\n                            if (f==0) {\r\n                                QMapIterator<QString, QVariant> it(acqD);\r\n                                while (it.hasNext()) {\r\n                                    it.next();\r\n                                    (*acquisitionDescription)[acquisitionDescriptionPrefix+it.key()]=it.value();\r\n                                }\r\n                                (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/dualview_mode\"]=optSetup->dualViewMode(ecamera, camera);\r\n                                (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/image_width\"]=width;\r\n                                (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/image_height\"]=height;\r\n                                (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/exposure_time\"]=ecamera->getCameraExposureTime(camera);\r\n                                optSetup->saveLightpathConfig((*acquisitionDescription), optSetup->getCurrentLightpath(), acquisitionDescriptionPrefix+\"/lightpath/\", QList<bool>(), true);\r\n                                getAdditionalCameraSettings(ecamera, camera, acquisitionDescriptionPrefix, (*acquisitionDescription), getMeasurements);\r\n                            }\r\n                            (*acquisitionDescription)[acquisitionDescriptionPrefix+QString(\"/timestamp%1\").arg(f+1)]=time;\r\n\r\n                        }\r\n                        if (f==0) {\r\n                            for (int i=0; i<width*height; i++) {\r\n                                if ((buffer[i]&0xFFFF0000) != 0) {\r\n                                    is32bit=true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (!tiff) {\r\n                            ok=false;\r\n                        } else {\r\n                            if (ok && is32bit) {\r\n                                TIFFTWriteUint32(tiff, buffer, width, height);\r\n                            } else if (ok) {\r\n                                TIFFTWriteUint16from32(tiff, buffer, width, height, false);\r\n                            }\r\n                            TIFFWriteDirectory(tiff);\r\n                        }\r\n                    } else {\r\n                        ok=false;\r\n                    }\r\n                    if (!ok) break;\r\n                }\r\n                //////////////////////////////////////////////////////////////////////////////////////\r\n                // Close Main shutter\r\n                //////////////////////////////////////////////////////////////////////////////////////\r\n                if (mainShutterOpenOnlyForAcquisition && optSetup->isMainIlluminationShutterAvailable()) {\r\n                    optSetup->setMainIlluminationShutter(false, true);\r\n                }\r\n                TIFFClose(tiff);\r\n            } else {\r\n                ok=false;\r\n            }\r\n        }\r\n\r\n        if (buffer) qfFree(buffer);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // Reset Main shutter\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    if (mainShutterOpenOnlyForAcquisition && optSetup->isMainIlluminationShutterAvailable()) {\r\n        optSetup->setMainIlluminationShutter(oldShutterState, true);\r\n    }\r\n\r\n\r\n    return ok;\r\n}",
    "void QFESPIMB040MainWindow2::savePreviewMovie(int camera, int frames, const QString &fileName, const QMap<QString, QVariant> &cam_params)\r\n{\r\n    //if (m_stopresume) m_stopresume->stop();\r\n    //saveJKImage(rawImage, tr(\"Save Raw Image ...\"));\r\n    QFExtension* extension;\r\n    QFExtensionCamera* camExt;\r\n    int camID;\r\n    QString previewSettingsFilename;\r\n\r\n    if (optSetup->lockCamera(camera, &extension, &camExt, &camID, &previewSettingsFilename) && (QDir().mkpath(QFileInfo(fileName).absolutePath()))) {\r\n\r\n        JKImage<uint32_t> rawImage;\r\n        int w=camExt->getCameraImageWidth(camID);\r\n        int h=camExt->getCameraImageHeight(camID);\r\n        QFESPIMB040AcquisitionTools* acqTools;\r\n        if (optSetup==optSetup1) acqTools=optSetup1->getAcquisitionTools();\r\n        if (optSetup==optSetup2) acqTools=optSetup2->getAcquisitionTools();\r\n        rawImage.resize(w, h);\r\n\r\n\r\n\r\n        QProgressDialog progress(tr(\"Acquiring image series ...\"), tr(\"&Cancel\"), 0, frames, this);\r\n        QString tmpName1=QDir::temp().absoluteFilePath(\"qf3spimb040_preview_camtmpsettings.ini\");\r\n        QFTemporaryFile file1;\r\n        if (file1.open()) {\r\n             tmpName1=file1.fileName();\r\n        }\r\n        if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n\r\n        QFile::copy(previewSettingsFilename, tmpName1);\r\n\r\n        QSettings settingPrev(tmpName1, QSettings::IniFormat);\r\n        QMapIterator<QString, QVariant> it(cam_params);\r\n        while (it.hasNext()) {\r\n            it.next();\r\n            settingPrev.setValue(it.key(), it.value());\r\n        }\r\n        //QSettings settingPrev(previewSettingsFilename, QSettings::IniFormat);\r\n        camExt->useCameraSettings(camID, settingPrev);\r\n\r\n        QFileInfo fi(fileName);\r\n        QString fn=fi.absolutePath()+\"/\"+fi.completeBaseName();\r\n        TIFF* tiff1=TIFFOpen(QString(fn+\".tif\").toLatin1().data(), \"w\");\r\n        TIFF* tiff2=TIFFOpen(QString(fn+\"_uint32.tif\").toLatin1().data(), \"w\");\r\n        TIFF* tiff3=TIFFOpen(QString(fn+\"_float.tif\").toLatin1().data(), \"w\");\r\n        uint64_t timestamp=0;\r\n        QMap<QString, QVariant> camConfig;\r\n        QList<double> times;\r\n        QElapsedTimer timer;\r\n        timer.start();\r\n        QList<QFESPIMB040OpticsSetup::measuredValues> measvec;\r\n        QList<QList<QVariant> > measdat;\r\n        QStringList measdat_cols;\r\n        if (tiff1&&tiff2&&tiff3) {\r\n            for (int i=0; i<frames; i++) {\r\n                if (camExt->acquireOnCamera(camID, rawImage.data(), &timestamp, &camConfig)) {\r\n                    times.append(double(timer.elapsed())/1000.0);\r\n                    QFESPIMB040OpticsSetup::measuredValues meas;\r\n                    if (optSetup) {\r\n                        meas=optSetup->getMeasuredValues();\r\n                    }\r\n                    measvec.append(meas);\r\n                    TIFFTWriteUint16from32(tiff1, rawImage.data(), w, h, false);\r\n                    TIFFWriteDirectory(tiff1);\r\n                    TIFFTWriteUint32(tiff2, rawImage.data(), w, h);\r\n                    TIFFWriteDirectory(tiff2);\r\n                    TIFFTWriteFloatfrom32(tiff3, rawImage.data(), w, h);\r\n                    TIFFWriteDirectory(tiff3);\r\n                }\r\n                if (progress.wasCanceled()) break;\r\n                progress.setValue(i);\r\n                QApplication::processEvents();\r\n            }\r\n        }\r\n        /*QFile f(QString(fn+\"_measurements.dat\"));\r\n        if (f.open(QFile::WriteOnly|QFile::Text)&&times.size()>0) {\r\n            QTextStream str(&f);\r\n            str<<\"timeindex [s], measurement_time [s]\";\r\n            QMapIterator<QString, QVariant> it(measvec.first());\r\n            while (it.hasNext()) {\r\n                it.next();\r\n                str<<\", \"<<it.key();\r\n            }\r\n            str<<\"\\n\";\r\n\r\n            for (int i=0; i<times.size(); i++) {\r\n                str<<CDoubleToQString(times[i])<<\", \"<<double(measvec.first().time.msecsTo(measvec[i].time))/1000.0;\r\n                QMapIterator<QString, QVariant> it(measvec[i]);\r\n                while (it.hasNext()) {\r\n                    it.next();\r\n                    str<<\", \"<< getQVariantData(it.value());\r\n\r\n                }\r\n                str<<\"\\n\";\r\n            }\r\n            f.close();\r\n        }*/\r\n\r\n\r\n        if (times.size()>0) {\r\n            measdat_cols<<\"timeindex [s]\"<<\"measurement_time [s]\";\r\n            QMapIterator<QString, QVariant> it(measvec.first().data);\r\n            while (it.hasNext()) {\r\n                it.next();\r\n                measdat_cols<<it.key();\r\n            }\r\n\r\n\r\n            for (int i=0; i<times.size(); i++) {\r\n                QList<QVariant> d;\r\n                d<<times[i]<<double(measvec.first().time.msecsTo(measvec[i].time))/1000.0;\r\n                QMapIterator<QString, QVariant> it(measvec[i].data);\r\n                while (it.hasNext()) {\r\n                    it.next();\r\n                    d<<it.value();\r\n                }\r\n                measdat<<d;\r\n            }\r\n            QFDataExportHandler::save(dataRotate(measdat), 0, QString(fn+\"_measurements.dat\"), measdat_cols);\r\n        }\r\n\r\n        QSettings setting(QString(fn+\".configuration.ini\"), QSettings::IniFormat);\r\n        //storeCameraConfig(setting);\r\n        storeCameaConfig(setting, camExt, camID);\r\n        QString acquisitionDescriptionPrefix=\"acquisition/\";\r\n        setting.setValue(acquisitionDescriptionPrefix+\"exposure\", camExt->getCameraExposureTime(camID));\r\n        setting.setValue(acquisitionDescriptionPrefix+\"image_width\", rawImage.width());\r\n        setting.setValue(acquisitionDescriptionPrefix+\"image_height\", rawImage.height());\r\n        setting.setValue(acquisitionDescriptionPrefix+\"image_frames\", frames);\r\n\r\n        if (camConfig.size()>0) {\r\n            QMapIterator<QString, QVariant> it(camConfig);\r\n            while (it.hasNext()) {\r\n                it.next();\r\n                setting.setValue(acquisitionDescriptionPrefix+it.key(), it.value());\r\n            }\r\n        }\r\n\r\n        widExperimentDescription->storeSettings(setting, \"experiment\");\r\n\r\n        setting.setValue(\"files/count\", 4);\r\n        setting.setValue(\"files/name0\", QFileInfo(fn+\".configuration.ini\").absoluteDir().relativeFilePath(fn+\".tif\"));\r\n        setting.setValue(\"files/type0\", \"TIFF16\");\r\n        setting.setValue(\"files/description0\", \"image stack\");\r\n        setting.setValue(\"files/name1\", QFileInfo(fn+\".configuration.ini\").absoluteDir().relativeFilePath(fn+\"_uint32.tif\"));\r\n        setting.setValue(\"files/type1\", \"TIFF32\");\r\n        setting.setValue(\"files/description1\", \"image stack\");\r\n        setting.setValue(\"files/name2\", QFileInfo(fn+\".configuration.ini\").absoluteDir().relativeFilePath(fn+\"_float.tif\"));\r\n        setting.setValue(\"files/type2\", \"TIFF_FLOAT\");\r\n        setting.setValue(\"files/description2\", \"image stack\");\r\n        setting.setValue(\"files/name3\", QFileInfo(fn+\".configuration.ini\").absoluteDir().relativeFilePath(fn+\"_measurements.dat\"));\r\n        setting.setValue(\"files/type3\", \"CSV\");\r\n        setting.setValue(\"files/description3\", \"measureable properties of setup\");\r\n\r\n        optSetup->releaseCamera(camera);\r\n    }\r\n}",
    "void QFESPIMB040ImageStackConfigWidget2::performStack()\r\n{\r\n    if (!(use1() || use2())) {\r\n        QMessageBox::critical(this, tr(\"B040SPIM: Image Stack Acquisition\"), tr(\"Cannot start image acquisition: No camera selected!\"));\r\n        return;\r\n    }\r\n\r\n    QDateTime startDateTime=QDateTime::currentDateTime();\r\n    QList<QFESPIMB040OpticsSetupBase::measuredValues> measured;\r\n\r\n\r\n    QProgressListDialog progress(tr(\"Image Stack Acquisition\"), tr(\"&Cancel\"), 0, 100, this);\r\n    progress.setWindowModality(Qt::WindowModal);\r\n    //progress.setMinimumDuration(0);\r\n    progress.setValue(0);\r\n    progress.addItem(tr(\"initializing stages\"));\r\n    progress.addItem(tr(\"preparing cameras\"));\r\n    progress.addItem(tr(\"performing acquisition\"));\r\n    progress.addItem(tr(\"storing data to disk\"));\r\n    progress.addItem(tr(\"clean up\"));\r\n    progress.setHasProgressBar(true);\r\n    progress.show();\r\n\r\n\r\n    log->log_text(tr(\"starting image stack acquisition:\\n\"));\r\n    log->log_text(tr(\"  - locking stages\\n\"));\r\n    progress.start();\r\n    opticsSetup->lockStages();\r\n    opticsSetup->lockLightpath();\r\n\r\n    bool ok=true;\r\n    int axisCount=1; // number of axes to use for scan\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // CHECK/CONNECT SELECTED STAGE 1\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    QFExtensionLinearStage* stage=this->stage();\r\n    int stageAxis=currentAxisID();\r\n    double stageInitialPos=0;\r\n    progress.setProgressText(tr(\"locking stage 1 ...\"));\r\n    ok=acqTools->connectStageForAcquisition(stage, stageAxis, stageInitialPos, tr(\"B040SPIM: Image Stack Acquisition\"),1);\r\n\r\n\r\n    if (ok) {\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // CHECK/CONNECT SELECTED STAGE 2 (if selected)\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        QFExtensionLinearStage* stage2=this->stage2();\r\n        int stageAxis2=currentAxisID2();\r\n        double stageInitialPos2=0;\r\n        if (useStage2()) {\r\n            progress.setProgressText(tr(\"locking stage 2 ...\"));\r\n            ok=acqTools->connectStageForAcquisition(stage2, stageAxis2, stageInitialPos2, tr(\"B040SPIM: Image Stack Acquisition\"),2);\r\n            if (ok) axisCount++;\r\n\r\n        }\r\n\r\n        if (!ok) {\r\n            opticsSetup->unlockStages();\r\n            opticsSetup->unlockLightpath();\r\n            return;\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // CHECK/CONNECT SELECTED STAGE 3 (if selected)\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        QFExtensionLinearStage* stage3=this->stage3();\r\n        int stageAxis3=currentAxisID3();\r\n        double stageInitialPos3=0;\r\n        if (useStage3()) {\r\n            progress.setProgressText(tr(\"locking stage 3 ...\"));\r\n            ok=acqTools->connectStageForAcquisition(stage3, stageAxis3, stageInitialPos3, tr(\"B040SPIM: Image Stack Acquisition\"),3);\r\n            if (ok) axisCount++;\r\n\r\n        }\r\n\r\n        if (!ok) {\r\n            opticsSetup->unlockStages();\r\n            opticsSetup->unlockLightpath();\r\n            return;\r\n        }\r\n\r\n\r\n        progress.nextItem();\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // LOCK/INIT CAMERA 1\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        bool useCam1=false;\r\n        QFExtension* extension1=NULL;\r\n        QFExtensionCamera* ecamera1=NULL;\r\n        int camera1=0;\r\n        QString acquisitionSettingsFilename1=\"\", previewSettingsFilename1=\"\";\r\n        QString acquisitionPrefix1=prefix1();\r\n        QStringList TIFFFIlename1;;\r\n        QList<TIFF*> tiff1;\r\n        TIFF* tiff1_background=NULL;\r\n        QString TIFFFIlenameBackground1;\r\n        if (use1()) {\r\n            progress.setProgressText(tr(\"locking camera 1 ...\"));\r\n            if (!(useCam1=opticsSetup->lockCamera(0, &extension1, &ecamera1, &camera1, &previewSettingsFilename1))) {\r\n                IMAGESTACK_ERROR(tr(\"error locking camera 1!\\n\"));\r\n            }\r\n        }\r\n        if (QFile::exists(currentConfigFilename(0))) acquisitionSettingsFilename1=currentConfigFilename(0);\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // LOCK/INIT CAMERA 2\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        bool useCam2=false;\r\n        QFExtension* extension2=NULL;\r\n        QFExtensionCamera* ecamera2=NULL;\r\n        QString acquisitionSettingsFilename2=\"\", previewSettingsFilename2=\"\";\r\n        QString acquisitionPrefix2=prefix2();\r\n        QStringList TIFFFIlename2;\r\n        QList<TIFF*> tiff2;\r\n        TIFF* tiff2_background=NULL;\r\n        QString TIFFFIlenameBackground2;\r\n\r\n        int camera2=0;\r\n        if (use2()) {\r\n            progress.setProgressText(tr(\"locking camera 2 ...\"));\r\n            if(!(useCam2=opticsSetup->lockCamera(1, &extension2, &ecamera2, &camera2, &previewSettingsFilename2))) {\r\n                IMAGESTACK_ERROR(tr(\"error locking camer 2!\\n\"));\r\n            }\r\n        }\r\n        if (QFile::exists(currentConfigFilename(1))) acquisitionSettingsFilename2=currentConfigFilename(1);\r\n\r\n        if (ok && !useCam1 && !useCam2) {\r\n            IMAGESTACK_ERROR(tr(\"Cannot start image acquisition: No camera selected, or both cameras not usable!\"));\r\n            ok=false;\r\n        }\r\n\r\n        if (ok && useCam1) log->log_text(tr(\"  - storing files with prefix 1: '%1'\\n\").arg(acquisitionPrefix1));\r\n        if (ok && useCam2) log->log_text(tr(\"  - storing files with prefix 2: '%1'\\n\").arg(acquisitionPrefix2));\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // PREPARE CAMERA 1\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        int width1=0, height1=0;\r\n        uint32_t* buffer1=NULL;\r\n        if (ok && useCam1) {\r\n            progress.setLabelText(tr(\"preparing camera 1 ...\"));\r\n            ok=acqTools->prepareCamera(1, camera1, ecamera1, acquisitionSettingsFilename1, width1, height1, &buffer1);\r\n\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // PREPARE CAMERA 2\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        int width2=0, height2=0;\r\n        uint32_t* buffer2=NULL;\r\n        if (ok && useCam2) {\r\n            progress.setLabelText(tr(\"preparing camera 2 ...\"));\r\n            ok=acqTools->prepareCamera(2, camera2, ecamera2, acquisitionSettingsFilename2, width2, height2, &buffer2);\r\n\r\n\r\n        }\r\n\r\n\r\n        progress.setLabelText(tr(\"preparing lightpathes ...\"));\r\n\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // COUNT LIGHTPATHS\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        QStringList lightpathList;\r\n        QStringList lightpathNames;\r\n        TIFFFIlenameBackground1=acquisitionPrefix1+\".background.tif\";\r\n        TIFFFIlenameBackground2=acquisitionPrefix2+\".background.tif\";\r\n        if (lightpath1Activated()) {\r\n            if (QFile::exists(lightpath1Filename())) {\r\n                lightpathList.append(lightpath1Filename());\r\n                lightpathNames.append(lightpath1());\r\n                TIFFFIlename1.append(acquisitionPrefix1+\".lightpath1.tif\");\r\n                tiff1.append(NULL);\r\n                TIFFFIlename2.append(acquisitionPrefix2+\".lightpath1.tif\");\r\n                tiff2.append(NULL);\r\n            } else {\r\n                ok=false;\r\n                IMAGESTACK_ERROR(tr(\"acquisition lightpath 1 '%1' configuration not found!\").arg(lightpath1()));\r\n            }\r\n        }\r\n        if (lightpath2Activated()) {\r\n            if (QFile::exists(lightpath2Filename())) {\r\n                lightpathList.append(lightpath2Filename());\r\n                lightpathNames.append(lightpath2());\r\n                TIFFFIlename1.append(acquisitionPrefix1+\".lightpath2.tif\");\r\n                tiff1.append(NULL);\r\n                TIFFFIlename2.append(acquisitionPrefix2+\".lightpath2.tif\");\r\n                tiff2.append(NULL);\r\n            } else {\r\n                ok=false;\r\n                IMAGESTACK_ERROR(tr(\"acquisition lightpath 2 '%1' configuration not found!\").arg(lightpath2()));\r\n            }\r\n        }\r\n        if (lightpath3Activated()) {\r\n            if (QFile::exists(lightpath3Filename())) {\r\n                lightpathList.append(lightpath3Filename());\r\n                lightpathNames.append(lightpath3());\r\n                TIFFFIlename1.append(acquisitionPrefix1+\".lightpath3.tif\");\r\n                tiff1.append(NULL);\r\n                TIFFFIlename2.append(acquisitionPrefix2+\".lightpath3.tif\");\r\n                tiff2.append(NULL);\r\n            } else {\r\n                ok=false;\r\n                IMAGESTACK_ERROR(tr(\"acquisition lightpath 3 '%1' configuration not found!\").arg(lightpath3()));\r\n            }\r\n        }\r\n        if (ok && lightpathList.isEmpty()) {\r\n            lightpathList.append(\"\");\r\n            lightpathNames.append(\"default\");\r\n            TIFFFIlename1.append(acquisitionPrefix1+\".tif\");\r\n            tiff1.append(NULL);\r\n            TIFFFIlename2.append(acquisitionPrefix2+\".tif\");\r\n            tiff2.append(NULL);\r\n        }\r\n\r\n        progress.setLabelText(tr(\"opening/creating output files ...\"));\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // OPEN OUTPUT TIFF FILES\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        progress.setLabelText(tr(\"opening output files ...\"));\r\n        QApplication::processEvents();\r\n        if (ok && useCam1) {\r\n            QDir().mkpath(QFileInfo(TIFFFIlenameBackground1.toLatin1().data()).absolutePath());\r\n            tiff1_background=TIFFOpen(TIFFFIlenameBackground1.toLatin1().data(), \"w\");;\r\n            if (!tiff1_background) {\r\n                ok=false;\r\n                IMAGESTACK_ERROR(tr(\"error opening TIFF file (camera 1) '%1'!\").arg(TIFFFIlenameBackground1));\r\n            }\r\n\r\n            for (int i=0; i<TIFFFIlename1.size(); i++) {\r\n                QDir().mkpath(QFileInfo(TIFFFIlename1[i].toLatin1().data()).absolutePath());\r\n                tiff1[i]=TIFFOpen(TIFFFIlename1[i].toLatin1().data(), \"w\");\r\n                if (!tiff1[i]) {\r\n                    ok=false;\r\n                    IMAGESTACK_ERROR(tr(\"error opening TIFF file (camera 1) '%1'!\").arg(TIFFFIlename1[i]));\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (ok && useCam2) {\r\n            QDir().mkpath(QFileInfo(TIFFFIlenameBackground2.toLatin1().data()).absolutePath());\r\n            tiff2_background=TIFFOpen(TIFFFIlenameBackground2.toLatin1().data(), \"w\");;\r\n            if (!tiff2_background) {\r\n                ok=false;\r\n                IMAGESTACK_ERROR(tr(\"error opening TIFF file (camera 2) '%1'!\").arg(TIFFFIlenameBackground2));\r\n            }\r\n            for (int i=0; i<TIFFFIlename2.size(); i++) {\r\n                QDir().mkpath(QFileInfo(TIFFFIlename2[i].toLatin1().data()).absolutePath());\r\n                tiff2[i]=TIFFOpen(TIFFFIlename2[i].toLatin1().data(), \"w\");\r\n                if (!tiff2[i]) {\r\n                    ok=false;\r\n                    IMAGESTACK_ERROR(tr(\"error opening TIFF file (camera 2) '%1'!\").arg(TIFFFIlename2[i]));\r\n                }\r\n            }\r\n        }\r\n\r\n        progress.setLabelText(tr(\"switching main shutter on ...\"));\r\n\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // switch off light\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        bool formerMainShutterState=opticsSetup->getMainIlluminationShutter();\r\n        if (opticsSetup->isMainIlluminationShutterAvailable()){\r\n            log->log_text(tr(\"  - switch main shutter off for background frames!\\n\"));\r\n            opticsSetup->setMainIlluminationShutter(false, true);\r\n        }\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // acquire backrgound images\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n            log->log_text(tr(\"  - acquiring background images ...\\n\"));\r\n\r\n            if (useCam1) {\r\n                if (ecamera1->acquireOnCamera(camera1, buffer1, NULL)) {\r\n                    TIFFTWriteUint16from32(tiff1_background, buffer1, width1, height1, false);\r\n                    log->log_text(tr(\"  - acquired overview image background from camera 1!\\n\"));\r\n                } else {\r\n                    ok=false;\r\n                    IMAGESTACK_ERROR(tr(\"error acquiring background image on camera 1!\\n\"));\r\n                }\r\n            }\r\n            //QApplication::processEvents();\r\n            if (useCam2) {\r\n                if (ecamera2->acquireOnCamera(camera2, buffer2, NULL)) {\r\n                    TIFFTWriteUint16from32(tiff2_background, buffer2, width2, height2, false);\r\n                    log->log_text(tr(\"  - acquired overview image background from camera 2!\\n\"));\r\n                } else {\r\n                    ok=false;\r\n                    IMAGESTACK_ERROR(tr(\"error acquiring background image on camera 2!\\n\"));\r\n                }\r\n            }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // switch on light\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (opticsSetup->isMainIlluminationShutterAvailable()){\r\n            log->log_text(tr(\"  - switch main shutter on!\\n\"));\r\n            opticsSetup->setMainIlluminationShutter(true, true);\r\n        }\r\n\r\n\r\n        if (progress.wasCanceled()) {\r\n            log->log_warning(tr(\"canceled by user!\\n\"));\r\n            ok=false;\r\n        }\r\n\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // CALCULATE A LIST WITH ALL POSITIONS TO MOVE TO\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        progress.setLabelText(tr(\"preparing list of stage positions ...\"));\r\n        double stageStart=stackStart();\r\n        double stageDelta=stackDelta();\r\n        int stageCount=stackCount();\r\n\r\n        double stageStart2=stackStart2();\r\n        double stageDelta2=stackDelta2();\r\n        int stageCount2=stackCount2();\r\n        bool stageReturn2=stage2Cycling();\r\n\r\n        double stageStart3=stackStart3();\r\n        double stageDelta3=stackDelta3();\r\n        int stageCount3=stackCount3();\r\n        bool stageReturn3=stage3Cycling();\r\n\r\n        QList<QTriple<double, double, double> > moveTo;\r\n\r\n        if (axisCount==1) {\r\n            double pos=stageStart;\r\n            for (int x=0; x<stageCount; x++) {\r\n                moveTo.append(qMakeTriple(pos, 0.0, 0.0));\r\n                pos=pos+stageDelta;\r\n            }\r\n        } else if (axisCount==2) {\r\n            double pos=stageStart;\r\n            double pos2=stageStart2;\r\n            for (int x=0; x<stageCount; x++) {\r\n                if (stageReturn2) pos2=stageStart2;\r\n                for (int y=0; y<stageCount2; y++) {\r\n                    moveTo.append(qMakeTriple(pos, pos2, 0.0));\r\n                    pos2=pos2+stageDelta2;\r\n                }\r\n                pos=pos+stageDelta;\r\n            }\r\n        } else if (axisCount==3) {\r\n            double pos=stageStart;\r\n            double pos2=stageStart2;\r\n            double pos3=stageStart3;\r\n            for (int x=0; x<stageCount; x++) {\r\n                if (stageReturn2) pos2=stageStart2;\r\n                for (int y=0; y<stageCount2; y++) {\r\n                    if (stageReturn3) pos3=stageStart3;\r\n                    for (int z=0; z<stageCount3; z++) {\r\n                        moveTo.append(qMakeTriple(pos, pos2, pos3));\r\n                        pos3=pos3+stageDelta3;\r\n                    }\r\n                    pos2=pos2+stageDelta2;\r\n                }\r\n                pos=pos+stageDelta;\r\n            }\r\n        }\r\n\r\n\r\n        int images=moveTo.size()*this->images()*lightpathList.size();\r\n\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // ACQUIRE IMAGE, MOVE, ACQUIRE IMAGE, MOVE, ...\r\n        //    images are stored in TIFF files using libtiff and they are (possibly) downscaled to 16-bit\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        progress.nextItem();\r\n\r\n        QMap<QString, QVariant> acquisitionDescription, acquisitionDescription1, acquisitionDescription2;\r\n        QList<QVariant> positions, positions2, positions3;\r\n        QTime timAcquisition=QTime::currentTime();\r\n        QDateTime timStart;\r\n        QString estimation=\"\";\r\n        QString fps=\"\";\r\n        double duration=0;\r\n        if (ok) {\r\n            progress.setLabelText(tr(\"acquiring images ...\"));\r\n            bool running=ok;\r\n            //double newPos=stageStart;\r\n            int posIdx=0;\r\n            int imageIdx=0;\r\n            measured.append(opticsSetup->getMeasuredValues());\r\n            while (running && (posIdx<=moveTo.size())) {\r\n                double newPos=stageInitialPos;\r\n                double newPos2=stageInitialPos2;\r\n                double newPos3=stageInitialPos3;\r\n                if (posIdx<moveTo.size()) {\r\n                    newPos=moveTo[posIdx].first;\r\n                    newPos2=moveTo[posIdx].second;\r\n                    newPos3=moveTo[posIdx].third;\r\n                }\r\n                if (axisCount==1) {\r\n                    log->log_text(tr(\"  - moving to position %1 micron ...\").arg(newPos));\r\n                    stage->move(stageAxis, newPos);\r\n                    QTime t1;\r\n                    t1.start();\r\n                    while (stage->getAxisState(stageAxis)==QFExtensionLinearStage::Moving) {\r\n                        if (t1.elapsed()>PROCESS_EVENTS_TIMEOUT_MS) {\r\n                            progress.setLabelText(tr(\"moving stage to %1 microns (distance: %2) ...%3%4\").arg(newPos).arg(fabs(stage->getPosition(stageAxis)-newPos)).arg(estimation).arg(fps));\r\n                            QApplication::processEvents(QEventLoop::AllEvents, 2);\r\n                            if (progress.wasCanceled()) break;\r\n                            t1.start();\r\n                        }\r\n                    }\r\n\r\n                    // wait additional time-span after moving stages!\r\n                    QTime t;\r\n                    int DeltaT=qMin(5000,qMax(1,delay()));\r\n                    t.start();\r\n                    t1.start();\r\n                    while (t.elapsed()<DeltaT) {\r\n                        if (t1.elapsed()>PROCESS_EVENTS_TIMEOUT_MS)  {\r\n                            progress.setLabelText(tr(\"moving stage to %1 microns (distance: %2) ... waiting%3%4\").arg(newPos).arg(fabs(stage->getPosition(stageAxis)-newPos)).arg(estimation).arg(fps));\r\n                            QApplication::processEvents(QEventLoop::AllEvents, 2);\r\n                            if (progress.wasCanceled()) break;\r\n                            t1.start();\r\n                        }\r\n                    }\r\n                    if (ok) {\r\n                        if (stage->getAxisState(stageAxis)==QFExtensionLinearStage::Ready) {\r\n                            log->log_text(tr(\" OK\\n\"));\r\n                            positions.append(stage->getPosition(stageAxis));\r\n                        } else {\r\n                            IMAGESTACK_ERROR(tr(\"error moving to position %1 micron!\\n\").arg(newPos));\r\n                            ok=false;\r\n                        }\r\n                    }\r\n\r\n                } else if (axisCount==2) {\r\n                    log->log_text(tr(\"  - moving to position (%1, %2) micron ...\").arg(newPos).arg(newPos2));\r\n                    stage->move(stageAxis, newPos);\r\n                    stage2->move(stageAxis2, newPos2);\r\n                    QTime t1;\r\n                    t1.start();\r\n                    while (stage->getAxisState(stageAxis)==QFExtensionLinearStage::Moving || stage2->getAxisState(stageAxis2)==QFExtensionLinearStage::Moving) {\r\n                        if (t1.elapsed()>PROCESS_EVENTS_TIMEOUT_MS) {\r\n                            double dist=sqrt(qfSqr(stage->getPosition(stageAxis)-newPos)+qfSqr(stage2->getPosition(stageAxis2)-newPos2));\r\n                            progress.setLabelText(tr(\"moving stage to (%1, %2) microns (distance: %3) ...%4%5\").arg(newPos).arg(newPos2).arg(dist).arg(estimation).arg(fps));\r\n                            QApplication::processEvents(QEventLoop::AllEvents, 2);\r\n                            if (progress.wasCanceled()) break;\r\n                            t1.start();\r\n                        }\r\n                    }\r\n\r\n                    // wait additional time-span after moving stages!\r\n                    QTime t;\r\n                    int DeltaT=qMin(5000,qMax(1,delay()));\r\n                    t.start();\r\n                    t1.start();\r\n                    while (t.elapsed()<DeltaT) {\r\n                        if (t1.elapsed()>PROCESS_EVENTS_TIMEOUT_MS) {\r\n                            double dist=sqrt(qfSqr(stage->getPosition(stageAxis)-newPos)+qfSqr(stage2->getPosition(stageAxis2)-newPos2));\r\n                            progress.setLabelText(tr(\"moving stage to (%1, %2) microns (distance: %3) ... waiting%4%5\").arg(newPos).arg(newPos2).arg(dist).arg(estimation).arg(fps));\r\n                            QApplication::processEvents(QEventLoop::AllEvents, 2);\r\n                            if (progress.wasCanceled()) break;\r\n                            t1.start();\r\n                        }\r\n                    }\r\n                    if (ok) {\r\n                        if (stage->getAxisState(stageAxis)==QFExtensionLinearStage::Ready && stage2->getAxisState(stageAxis2)==QFExtensionLinearStage::Ready) {\r\n                            log->log_text(tr(\" OK\\n\"));\r\n                            positions.append(stage->getPosition(stageAxis));\r\n                            positions2.append(stage2->getPosition(stageAxis2));\r\n                        } else {\r\n                            IMAGESTACK_ERROR(tr(\"error moving to position (%1, %2) micron!\\n\").arg(newPos).arg(newPos2));\r\n                            ok=false;\r\n                        }\r\n                    }\r\n                } else if (axisCount==3) {\r\n                    log->log_text(tr(\"  - moving to position (%1, %2, %3) micron ...\").arg(newPos).arg(newPos2).arg(newPos3));\r\n                    stage->move(stageAxis, newPos);\r\n                    stage2->move(stageAxis2, newPos2);\r\n                    stage3->move(stageAxis3, newPos3);\r\n                    QTime t1;\r\n                    t1.start();\r\n                    while (stage->getAxisState(stageAxis)==QFExtensionLinearStage::Moving || stage2->getAxisState(stageAxis2)==QFExtensionLinearStage::Moving || stage3->getAxisState(stageAxis3)==QFExtensionLinearStage::Moving) {\r\n                        if (t1.elapsed()>PROCESS_EVENTS_TIMEOUT_MS) {\r\n                            double dist=sqrt(qfSqr(stage->getPosition(stageAxis)-newPos) + qfSqr(stage2->getPosition(stageAxis2)-newPos2) + qfSqr(stage3->getPosition(stageAxis3)-newPos3));\r\n                            progress.setLabelText(tr(\"moving stage to (%1, %2, %3) microns (distance: %4) ...%5%6\").arg(newPos).arg(newPos2).arg(newPos3).arg(dist).arg(estimation).arg(fps));\r\n                            QApplication::processEvents(QEventLoop::AllEvents, 2);\r\n                            if (progress.wasCanceled()) break;\r\n                            t1.start();\r\n                        }\r\n                    }\r\n\r\n                    // wait additional time-span after moving stages!\r\n                    QTime t;\r\n                    int DeltaT=qMin(5000,qMax(1,delay()));\r\n                    t.start();\r\n                    t1.start();\r\n                    while (t.elapsed()<DeltaT) {\r\n                        if (t1.elapsed()>PROCESS_EVENTS_TIMEOUT_MS) {\r\n                            double dist=sqrt(qfSqr(stage->getPosition(stageAxis)-newPos) + qfSqr(stage2->getPosition(stageAxis2)-newPos2) + qfSqr(stage3->getPosition(stageAxis3)-newPos3));\r\n                            progress.setLabelText(tr(\"moving stage to (%1, %2, %3) microns (distance: %4) ... waiting%5%6\").arg(newPos).arg(newPos2).arg(newPos3).arg(dist).arg(estimation).arg(fps));\r\n                            QApplication::processEvents(QEventLoop::AllEvents, 2);\r\n                            if (progress.wasCanceled()) break;\r\n                            t1.start();\r\n                        }\r\n                    }\r\n                    if (ok) {\r\n                        if (stage->getAxisState(stageAxis)==QFExtensionLinearStage::Ready && stage2->getAxisState(stageAxis2)==QFExtensionLinearStage::Ready && stage3->getAxisState(stageAxis3)==QFExtensionLinearStage::Ready) {\r\n                            log->log_text(tr(\" OK\\n\"));\r\n                            positions.append(stage->getPosition(stageAxis));\r\n                            positions2.append(stage2->getPosition(stageAxis2));\r\n                            positions3.append(stage3->getPosition(stageAxis3));\r\n                        } else {\r\n                            IMAGESTACK_ERROR(tr(\"error moving to position (%1, %2, %3) micron!\\n\").arg(newPos).arg(newPos2).arg(newPos3));\r\n                            ok=false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                QApplication::processEvents(QEventLoop::AllEvents, 2);\r\n                if (posIdx<moveTo.size()) {\r\n                    if (progress.wasCanceled()) {\r\n                        running=false;\r\n                        log->log_warning(tr(\"  - acquisition canceled by user!\\n\"));\r\n                    } else {\r\n                        if (saveMeasurements()) measured.append(opticsSetup->getMeasuredValues());\r\n                        for (int lp=0; lp<lightpathList.size(); lp++) {\r\n                            if (lightpathList.size()>1 || lp==0) {\r\n                                if (!lightpathList[lp].isEmpty() && QFile::exists(lightpathList[lp])) {\r\n                                    log->log_text(tr(\"  - setting lightpath '%1' (%2) ...\").arg(lightpathNames[lp]).arg(lp));\r\n                                    opticsSetup->loadLightpathConfig(lightpathList[lp], true);\r\n                                    log->log_text(tr(\" DONE\\n\"));\r\n                                }\r\n                                if (posIdx<=0) {\r\n                                    opticsSetup->saveLightpathConfig(acquisitionDescription, lightpathNames[lp], QString(\"lightpath%1/\").arg(lp+1), QList<bool>(), true);\r\n                                }\r\n                            }\r\n                            for (int img=0; img<this->images(); img++) {\r\n                                            log->log_text(tr(\"  - acquiring images (%1/%2) ...\\n\").arg(imageIdx+1).arg(images));\r\n                                            if (posIdx>3) {\r\n                                                double duration=double(timAcquisition.elapsed())/1000.0;\r\n                                                double eta=duration/double(posIdx+1.0)*double(moveTo.size());\r\n                                                double etc=eta-duration;\r\n                                    uint mini=floor(etc/60.0);\r\n                                    uint secs=round(etc-double(mini)*60.0);\r\n                                    estimation=tr(\"\\nest. remaining duration (min:secs): %1:%2 \").arg(mini, 2, 10, QChar('0')).arg(secs, 2, 10, QChar('0'));\r\n\r\n                                    fps=tr(\"\\nacquisition rate: %1fps\").arg(double(imageIdx+1)/duration, 0, 'f', 2);\r\n                                }\r\n                                progress.setLabelText(tr(\"acquiring images (%1/%2) ...%3%4\").arg(imageIdx+1).arg(images).arg(estimation).arg(fps));\r\n                                QApplication::processEvents(QEventLoop::AllEvents, 2);\r\n                                if (progress.wasCanceled()) {\r\n                                    running=false;\r\n                                    log->log_warning(tr(\"  - acquisition canceled by user!\\n\"));\r\n                                    break;\r\n                                }\r\n                                if (posIdx==0) {\r\n                                    timAcquisition.start();\r\n                                    timStart=QDateTime::currentDateTime();\r\n                                }\r\n                                uint64_t timestampDummy=0;\r\n                                if (useCam1) {\r\n                                    if (ecamera1->acquireOnCamera(camera1, buffer1, NULL, &acquisitionDescription1)) {\r\n                                        TIFFTWriteUint16from32(tiff1[lp], buffer1, width1, height1, false);\r\n                                        TIFFWriteDirectory(tiff1[lp]);\r\n                                    } else {\r\n                                        ok=false;\r\n                                        IMAGESTACK_ERROR(tr(\"error acquiring image %1/%2 on camera 1!\\n\").arg(imageIdx+1).arg(images));\r\n                                    }\r\n                                }\r\n                                //QApplication::processEvents();\r\n                                if (useCam2) {\r\n                                    if (ecamera2->acquireOnCamera(camera2, buffer2, NULL, &acquisitionDescription2)) {\r\n                                        TIFFTWriteUint16from32(tiff2[lp], buffer2, width2, height2, false);\r\n                                        TIFFWriteDirectory(tiff2[lp]);\r\n                                    } else {\r\n                                        ok=false;\r\n                                        IMAGESTACK_ERROR(tr(\"error acquiring image %1/%2 on camera 2!\\n\").arg(imageIdx+1).arg(images));\r\n                                    }\r\n                                }\r\n                                imageIdx++;\r\n\r\n                            }\r\n                        }\r\n\r\n                        //QApplication::processEvents();\r\n                    }\r\n                }\r\n                if (!ok) running=false;\r\n\r\n                posIdx++;\r\n                newPos+=stageDelta;\r\n                progress.setValue((int)round((double)posIdx/(double)moveTo.size()*100.0));\r\n                QApplication::processEvents(QEventLoop::AllEvents, 10);\r\n                if (progress.wasCanceled()) {\r\n                    break;\r\n                }\r\n            }\r\n            duration=timAcquisition.elapsed()/1000.0;\r\n        }\r\n        progress.setValue(100);\r\n        if (saveMeasurements()) measured.append(opticsSetup->getMeasuredValues());\r\n\r\n        progress.nextItem();\r\n        progress.setProgressText(tr(\"switching main shutter off ...\"));\r\n\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // switch on/off light\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (opticsSetup->isMainIlluminationShutterAvailable()){\r\n            log->log_text(tr(\"  - switch main shutter %1!\\n\").arg((formerMainShutterState)?tr(\"on\"):tr(\"off\")));\r\n            opticsSetup->setMainIlluminationShutter(formerMainShutterState, true);\r\n        }\r\n\r\n\r\n        progress.setProgressText(tr(\"closing TIF files ...\"));\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // close tiff files and free buffers\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        progress.setLabelText(tr(\"closing output files ...\"));\r\n        QApplication::processEvents();\r\n        if (tiff1_background) TIFFClose(tiff1_background);\r\n        if (tiff2_background) TIFFClose(tiff2_background);\r\n\r\n        for (int lp=0; lp<tiff1.size(); lp++) if (tiff1[lp]) TIFFClose(tiff1[lp]);\r\n        for (int lp=0; lp<tiff2.size(); lp++) if (tiff2[lp]) TIFFClose(tiff2[lp]);\r\n        tiff1.clear();\r\n        tiff2.clear();\r\n        if (buffer1) qfFree(buffer1);\r\n        if (buffer2) qfFree(buffer2);\r\n        buffer1=buffer2=NULL;\r\n\r\n        progress.setProgressText(tr(\"collecting acquisition data ...\"));\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // collect acquisition data common to all cameras\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        QString positionsCSV;\r\n        if (ok) {\r\n            acquisitionDescription[\"type\"]=\"stack 1 axis\";\r\n            acquisitionDescription[\"axis1/type\"]=\"other\";\r\n            if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageX)==stage && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageX)==stageAxis) acquisitionDescription[\"axis1/type\"]=\"x\";\r\n            if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageY)==stage && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageY)==stageAxis) acquisitionDescription[\"axis1/type\"]=\"y\";\r\n            if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageZ)==stage && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageZ)==stageAxis) acquisitionDescription[\"axis1/type\"]=\"z\";\r\n            acquisitionDescription[\"axis1/stage_name\"]=stageExtension()->getName();\r\n            acquisitionDescription[\"axis1/stage_axis\"]=stageAxis;\r\n            acquisitionDescription[\"axis1/stack_start\"]=stageStart;\r\n            acquisitionDescription[\"axis1/stack_delta\"]=stageDelta;\r\n            acquisitionDescription[\"axis1/stack_count\"]=stageCount;\r\n            acquisitionDescription[\"sequence_overall_length\"]=images;\r\n            acquisitionDescription[\"images_per_position\"]=this->images();\r\n            acquisitionDescription[\"lightpath_count\"]=lightpathList.count();\r\n            acquisitionDescription[\"lightpaths\"]=lightpathNames;\r\n            acquisitionDescription[\"start_time\"]=timStart;\r\n            acquisitionDescription[\"duration\"]=duration;\r\n            acquisitionDescription[\"stack_positions\"]=positions;\r\n            if (useStage2() && useStage3()) {\r\n                acquisitionDescription[\"type\"]=\"stack 3 axis\";\r\n                acquisitionDescription[\"axis2/stack_positions\"]=positions2;\r\n                acquisitionDescription[\"axis3/stack_positions\"]=positions3;\r\n            } else if (useStage2() && !useStage3()) {\r\n                acquisitionDescription[\"type\"]=\"stack 2 axis\";\r\n                acquisitionDescription[\"axis1/stack_positions\"]=positions2;\r\n            }\r\n\r\n            if (useStage2()) {\r\n                acquisitionDescription[\"axis2/type\"]=\"other\";\r\n                if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageX)==stage2 && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageX)==stageAxis2) acquisitionDescription[\"axis2/type\"]=\"x\";\r\n                if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageY)==stage2 && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageY)==stageAxis2) acquisitionDescription[\"axis2/type\"]=\"y\";\r\n                if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageZ)==stage2 && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageZ)==stageAxis2) acquisitionDescription[\"axis2/type\"]=\"z\";\r\n                acquisitionDescription[\"axis2/stage_name\"]=stageExtension2()->getName();\r\n                acquisitionDescription[\"axis2/stage_axis\"]=stageAxis2;\r\n                acquisitionDescription[\"axis2/stack_start\"]=stageStart2;\r\n                acquisitionDescription[\"axis2/stack_delta\"]=stageDelta2;\r\n                acquisitionDescription[\"axis2/stack_count\"]=stageCount2;\r\n            }\r\n\r\n            if (useStage3()) {\r\n                acquisitionDescription[\"axis3/type\"]=\"other\";\r\n                if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageX)==stage3 && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageX)==stageAxis3) acquisitionDescription[\"axis3/type\"]=\"x\";\r\n                if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageY)==stage3 && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageY)==stageAxis3) acquisitionDescription[\"axis3/type\"]=\"y\";\r\n                if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageZ)==stage3 && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageZ)==stageAxis3) acquisitionDescription[\"axis3/type\"]=\"z\";\r\n                acquisitionDescription[\"axis3/stage_name\"]=stageExtension3()->getName();\r\n                acquisitionDescription[\"axis3/stage_axis\"]=stageAxis3;\r\n                acquisitionDescription[\"axis3/stack_start\"]=stageStart3;\r\n                acquisitionDescription[\"axis3/stack_delta\"]=stageDelta3;\r\n                acquisitionDescription[\"axis3/stack_count\"]=stageCount3;\r\n            }\r\n\r\n\r\n            QTextStream pf(&positionsCSV);\r\n            if (axisCount==3) {\r\n                pf<<\"# number, position 1[micrometer], position 2 [micrometer], position 3 [micrometer], ideal position 1 [micrometer], ideal position 2 [micrometer], ideal position 3 [micrometer] \\n\";\r\n                for (int i=0; i<qMin(positions.size(), moveTo.size()); i++) {\r\n                    pf<<i<<\", \"<<CDoubleToQString(positions[i].toDouble())<<\", \"<<CDoubleToQString(positions2[i].toDouble())<<\", \"<<CDoubleToQString(positions3[i].toDouble())<<\", \"<<CDoubleToQString(moveTo[i].first)<<\", \"<<CDoubleToQString(moveTo[i].second)<<\", \"<<CDoubleToQString(moveTo[i].third)<<\"\\n\";\r\n                }\r\n            } else if (axisCount==2) {\r\n                pf<<\"# number, position 1[micrometer], position 2 [micrometer], ideal position 1 [micrometer], ideal position 2 [micrometer] \\n\";\r\n                for (int i=0; i<qMin(positions.size(), moveTo.size()); i++) {\r\n                    pf<<i<<\", \"<<CDoubleToQString(positions[i].toDouble())<<\", \"<<CDoubleToQString(positions2[i].toDouble())<<\", \"<<CDoubleToQString(moveTo[i].first)<<\", \"<<CDoubleToQString(moveTo[i].second)<<\"\\n\";\r\n                }\r\n            } else if (axisCount==1) {\r\n                pf<<\"# number, position 1[micrometer], ideal position 1 [micrometer] \\n\";\r\n                for (int i=0; i<qMin(positions.size(), moveTo.size()); i++) {\r\n                    pf<<i<<\", \"<<CDoubleToQString(positions[i].toDouble())<<\", \"<<CDoubleToQString(moveTo[i].first)<<\"\\n\";\r\n                }\r\n            }\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // write image stack properties to files, also collects camera specific information\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (ok && useCam1) {\r\n            QMap<QString, QVariant> acquisitionDescription11=acquisitionDescription;\r\n            acquisitionDescription11=acquisitionDescription11.unite(acquisitionDescription1);\r\n            QList<QFExtensionCamera::CameraAcquititonFileDescription> files;\r\n            for (int lp=0; lp<TIFFFIlename1.size(); lp++) {\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=TIFFFIlename1[lp];\r\n                d.description=\"image stack from camera 1, lightpath \"+QString(lp+1)+\" '\"+lightpathNames[lp]+\"'\";\r\n                d.type=\"TIFF16\";\r\n                files.append(d);\r\n            }\r\n\r\n\r\n            QString PositionsFilename=acquisitionPrefix1+\".positions.dat\";\r\n            QFile posFile(PositionsFilename);\r\n            if (posFile.open(QIODevice::WriteOnly)) {\r\n                posFile.write(positionsCSV.toLatin1().data());\r\n                posFile.close();\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=PositionsFilename;\r\n                d.description=\"positions of image stack from camera 1\";\r\n                d.type=\"CSV\";\r\n                files.append(d);\r\n            } else {\r\n                log->log_error(tr(\"  - could not write positions file '%1' for camera 1: %2 ...\").arg(PositionsFilename).arg(posFile.errorString()));\r\n            }\r\n\r\n            QString MeasurementsFilename=acqTools->saveMeasuredData(acquisitionPrefix1, measured);\r\n            if (!MeasurementsFilename.isEmpty() && QFile::exists(MeasurementsFilename)) {\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=MeasurementsFilename;\r\n                d.description=\"measureable properties of setup\";\r\n                d.type=\"CSV\";\r\n                files.append(d);\r\n            }\r\n\r\n            if (useCam1){\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=TIFFFIlenameBackground1;\r\n                d.description=\"background frame from camera 1\";\r\n                d.type=\"TIFF16\";\r\n                files.append(d);\r\n            }\r\n            if (useCam2){\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=TIFFFIlenameBackground2;\r\n                d.description=\"background frame from camera 2\";\r\n                d.type=\"TIFF16\";\r\n                files.append(d);\r\n            }\r\n            log->log_text(tr(\"  - writing acquisition description 1 ...\"));\r\n            acqTools->savePreviewDescription(0, extension1, ecamera1, camera1, acquisitionPrefix1, acquisitionDescription11, files, startDateTime);\r\n            log->log_text(tr(\" DONE!\\n\"));\r\n        }\r\n        if (ok && useCam2) {\r\n            QMap<QString, QVariant> acquisitionDescription22=acquisitionDescription;\r\n            acquisitionDescription22=acquisitionDescription22.unite(acquisitionDescription2);\r\n            QList<QFExtensionCamera::CameraAcquititonFileDescription> files;\r\n            for (int lp=0; lp<TIFFFIlename1.size(); lp++) {\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=TIFFFIlename2[lp];\r\n                d.description=\"image stack from camera 2, lightpath \"+QString(lp+1)+\" '\"+lightpathNames[lp]+\"'\";\r\n                d.type=\"TIFF16\";\r\n                files.append(d);\r\n            }\r\n\r\n\r\n            QString PositionsFilename=acquisitionPrefix2+\".positions.dat\";\r\n            QFile posFile(PositionsFilename);\r\n            if (posFile.open(QIODevice::WriteOnly)) {\r\n                posFile.write(positionsCSV.toLatin1().data());\r\n                posFile.close();\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=PositionsFilename;\r\n                d.description=\"positions of image stack from camera 1\";\r\n                d.type=\"CSV\";\r\n                files.append(d);\r\n            } else {\r\n                log->log_error(tr(\"  - could not write positions file '%1' for camera 2: %2 ...\").arg(PositionsFilename).arg(posFile.errorString()));\r\n            }\r\n\r\n            QString MeasurementsFilename=acqTools->saveMeasuredData(acquisitionPrefix2, measured);\r\n            if (!MeasurementsFilename.isEmpty() && QFile::exists(MeasurementsFilename)) {\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=MeasurementsFilename;\r\n                d.description=\"measureable properties of setup\";\r\n                d.type=\"CSV\";\r\n                files.append(d);\r\n            }\r\n\r\n            log->log_text(tr(\"  - writing acquisition description 2 ...\"));\r\n            acqTools->savePreviewDescription(1, extension2, ecamera2, camera2, acquisitionPrefix2, acquisitionDescription22, files, startDateTime);\r\n            log->log_text(tr(\" DONE!\\n\"));\r\n        }\r\n\r\n        progress.nextItem();\r\n        progress.setProgressText(tr(\"releasing cameras ...\"));\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // release cameras\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (useCam1) {\r\n            opticsSetup->releaseCamera(0);\r\n            log->log_text(tr(\"  - released camera 1!\\n\"));\r\n        }\r\n        if (useCam2) {\r\n            opticsSetup->releaseCamera(1);\r\n            log->log_text(tr(\"  - released camera 2!\\n\"));\r\n        }\r\n\r\n        if (ok && useCam1) log->log_text(tr(\"  - stored files with prefix 1: '%1'\\n\").arg(acquisitionPrefix1));\r\n        if (ok && useCam2) log->log_text(tr(\"  - stored files with prefix 2: '%1'\\n\").arg(acquisitionPrefix2));\r\n\r\n        if (ok) log->log_text(tr(\"image stack acquisition DONE!\\n\"));\r\n    }\r\n    progress.setProgressText(tr(\"releasing stages and lightpath ...\"));\r\n    opticsSetup->unlockStages();\r\n    opticsSetup->unlockLightpath();\r\n    opticsSetup->ensureLightpath();\r\n    progress.close();\r\n}",
    "void QFRDRImagingFCSCorrelationJobThread::run() {\r\n    QTime ptime;\r\n\r\n    ptime.start();\r\n\r\n    emit messageChanged(tr(\"loading data ...\"));\r\n    if ((job.fileFormat<0)||(job.fileFormat>=getImageReaderCount(pluginservices))) {\r\n        m_status=-1;\r\n        emit statusChanged(m_status);\r\n        emit messageChanged(tr(\"file format not supported or given ... format given was: %1\").arg(job.fileFormat));\r\n        emit rangeChanged(0,100);\r\n        emit progressChanged(0);\r\n    } else if (!QFile::exists(job.filename)) {\r\n        m_status=-1;\r\n        emit statusChanged(m_status);\r\n        emit messageChanged(tr(\"file does not exist ...\"));\r\n        emit rangeChanged(0,100);\r\n        emit progressChanged(0);\r\n    } else {\r\n        m_status=1;\r\n        emit statusChanged(m_status);\r\n        emit rangeChanged(0,3780+1000*job.DCCFDeltaX.size());\r\n\r\n\r\n        reader=NULL;\r\n        bool OK=false;\r\n        if (job.fileFormat>=0 && job.fileFormat<getImageReaderCount(pluginservices)) {\r\n            reader=getImageReader(job.fileFormat, pluginservices);\r\n        }\r\n        if (reader) {\r\n            emit messageChanged(tr(\"opening %1 file ...\").arg(reader->formatName()));\r\n            OK=reader->open(job.filename);\r\n            if (!OK) {\r\n                m_status=-1; emit statusChanged(m_status);\r\n                if (reader) messageChanged(tr(\"error opening file '%1': %2\").arg(job.filename).arg(reader->lastError()));\r\n                else emit messageChanged(tr(\"error opening file '%1'\").arg(job.filename));\r\n            } else {\r\n                emit progressIncrement(10);\r\n                emit messageChanged(tr(\"counting frames ...\"));\r\n                props=reader->getFileInfo().properties;\r\n                comment=reader->getFileInfo().comment;\r\n                reader->setBinning(job.binning);\r\n                reader->setInterleavedBinning(job.interleaved_binning);\r\n                reader->setAverageBinning(job.binAverage);\r\n                if (job.use_cropping) {\r\n                    reader->setCropping(job.crop_x0, job.crop_x1, job.crop_y0, job.crop_y1);\r\n                } else {\r\n                    reader->unsetCropping();\r\n                }\r\n                first_frame=0;\r\n                int32_t frame_count=reader->countFrames();\r\n                if (job.range_min>0 && job.range_min<frame_count) first_frame=job.range_min;\r\n                frames=frame_count-first_frame;\r\n                if (job.range_max>(int64_t)first_frame && job.range_max<frame_count) frames=job.range_max-first_frame;\r\n                double input_length=frames*job.frameTime;\r\n                if (frames>0) {\r\n                    frame_width=reader->frameWidth();\r\n                    frame_height=reader->frameHeight();\r\n                    average_frame=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    sqrsum_frame=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    average_uncorrected_frame=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    sqrsum_uncorrected_frame=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n\r\n                    baseline=job.backgroundOffset;\r\n\r\n                    acf_tau=NULL;\r\n                    acf=NULL;\r\n                    acf_std=NULL;\r\n                    acf_segments=NULL;\r\n                    acf_blocklevel=NULL;\r\n                    acf_blocksuccess=NULL;\r\n                    acf_N=0;\r\n                    dccf.clear();\r\n                    for (int id=0; id<job.DCCFDeltaX.size(); id++) {\r\n                        DCCFRecord rec;\r\n                        rec.dccf_tau=NULL;\r\n                        rec.dccf=NULL;\r\n                        rec.dccf_segments=NULL;\r\n                        rec.dccf_std=NULL;\r\n                        rec.dccf_N=0;\r\n                        rec.dccfframe_width=0;\r\n                        rec.dccfframe_height=0;\r\n                        rec.dccf_blocklevel=NULL;\r\n                        rec.dccf_blocksuccess=NULL;\r\n                        dccf.append(rec);\r\n                    }\r\n                    lastFrames=NULL;\r\n                    firstFrames=NULL;\r\n                    bleachAmplitude=NULL;\r\n                    bleachTime=NULL;\r\n                    bleachPoly2=NULL;\r\n                    bleachPoly3=NULL;\r\n                    fit_frames=NULL;\r\n                    fit_t=NULL;\r\n                    NFitFrames=0;\r\n\r\n                    video_count=floor(frames/job.video_frames);\r\n                    real_video_count=video_count;\r\n                    video=(float*)qfCalloc(frame_width*frame_height*video_count, sizeof(float));\r\n                    video_uncorrected=(float*)qfCalloc(frame_width*frame_height*video_count, sizeof(float));\r\n                    bleachAmplitude=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachTime=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachAmplitude2=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachTime2=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachPoly2=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachPoly3=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachPoly4=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachPoly5=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachFitOK=(uint8_t*)qfCalloc(frame_width*frame_height, sizeof(uint8_t));\r\n                    bleachPercentage=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    firstFrames=(float*)qfCalloc(frame_width*frame_height,sizeof(float));\r\n                    //firstFrames=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    //lastFrames=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n\r\n                    ////////////////////////////////////////////////////////////////////////////////////////////\r\n                    // CREATE FILENAMES FOR RESULTS AND MAKE SURE THE DIRECTORY FOR THE FILES EXISTS (mkpath() )\r\n                    ////////////////////////////////////////////////////////////////////////////////////////////\r\n                    QDir d=QFileInfo(job.filename).dir();\r\n\r\n                    if (mutexFilename) mutexFilename->lock();\r\n                    int counter=-1;\r\n                    do {\r\n                        outputFilenameBase=d.absoluteFilePath(replacePostfixSpecials(job.prefix)+QFileInfo(job.filename).completeBaseName()+replacePostfixSpecials(job.postfix, counter));\r\n                        counter++;\r\n                    } while (QFile::exists(outputFilenameBase+\".evalsettings.txt\"));\r\n                    //qDebug()<<outputFilenameBase;\r\n                    QString configFilename=outputFilenameBase+\".evalsettings.txt\";\r\n                    QString averageFilename=\"\";\r\n                    QString stdFilename=\"\";\r\n                    QString averageUncorrectedFilename=\"\";\r\n                    QString stdUncorrectedFilename=\"\";\r\n                    QString backstdFilename=\"\";\r\n                    QString averageFilenameF=\"\";\r\n                    QString backgroundFilename=\"\";\r\n                    QString videoFilename=\"\";\r\n                    QString videoUncorrectedFilename=\"\";\r\n                    QString statisticsFilename=\"\";\r\n                    QString statisticsFilename_dv1=\"\";\r\n                    QString statisticsFilename_dv2=\"\";\r\n                    QString uncorrectedStatisticsFilename=\"\";\r\n                    QString uncorrectedStatisticsFilename_dv1=\"\";\r\n                    QString uncorrectedStatisticsFilename_dv2=\"\";\r\n                    QString backstatisticsFilename=\"\";\r\n                    QString backstatisticsFilename_dv1=\"\";\r\n                    QString backstatisticsFilename_dv2=\"\";\r\n                    QString acfFilename=\"\";\r\n                    QStringList dccfFilename;\r\n                    QString acfFilenameBin=\"\";\r\n                    QStringList dccfFilenameBin;\r\n                    QString bleachAmplitudeFilename=\"\";\r\n                    QString bleachPercentageFilename=\"\";\r\n                    QString bleachTimeFilename=\"\";\r\n                    QString bleachAmplitude2Filename=\"\";\r\n                    QString bleachTime2Filename=\"\";\r\n                    QString bleachFitSuccessFilename=\"\";\r\n                    QString bleachPoly2Filename=\"\";\r\n                    QString bleachPoly3Filename=\"\";\r\n                    QString bleachPoly4Filename=\"\";\r\n                    QString bleachPoly5Filename=\"\";\r\n                    QString firstFramesFilename=\"\";\r\n                    QString lastFramesFilename=\"\";\r\n                    QString bleachtimesFilename=\"\";\r\n                    QString bleachframesFilename=\"\";\r\n                    QString acfBlockLevelFilename;\r\n                    QString acfBlockSuccessFilename;\r\n                    QStringList dccfBlockLevelFilename;\r\n                    QStringList dccfBlockSuccessFilename;\r\n                    QString localFileDirectory=QFileInfo(d.absoluteFilePath(configFilename)).dir().absolutePath();\r\n\r\n                    if (d.mkpath(localFileDirectory)) {\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n                        // TOUCH OUTPUT FILE (.evalsettings.txt)\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n                        touchFile(configFilename);\r\n\r\n                        if (mutexFilename) mutexFilename->unlock();\r\n\r\n\r\n\r\n\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n                        // RUN THE CORRELATION\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n                        if (job.correlator==CORRELATOR_MTAUALLMON || job.correlator==CORRELATOR_MTAUONEMON) {\r\n                            correlate_loadsingle();\r\n                        } else {\r\n                            correlate_loadall();\r\n                        }\r\n                        reader->close();\r\n\r\n\r\n\r\n\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n                        // SAVE THE RESULTS\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n                        //************** SAVE OVERVIEW IMAGE\r\n                        if ((m_status==1) && !was_canceled && average_frame) {\r\n                            emit messageChanged(tr(\"saving overview image ...\"));\r\n                            QString localFilename=averageFilename=outputFilenameBase+\".overview.tif\";\r\n                            QString error=\"\";\r\n                            if (!SaveTIFFUInt16_scaled(localFilename, average_frame, frame_width, frame_height, tr(\"UInt16 overview image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                averageFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n\r\n                            localFilename=averageFilenameF=outputFilenameBase+\".overview_float.tif\";\r\n                            if (!SaveTIFFFloat(localFilename, average_frame, frame_width, frame_height, tr(\"float overview image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                averageFilenameF=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(5);\r\n\r\n                        //************** SAVE OVERVIEWSTD IMAGE\r\n                        if ((m_status==1) && !was_canceled && sqrsum_frame) {\r\n                            emit messageChanged(tr(\"saving overview stddev image ...\"));\r\n                            QString localFilename=stdFilename=outputFilenameBase+\".overviewstd.tif\";\r\n\r\n                            QString error=\"\";\r\n                            if (!SaveSDTIFF(localFilename, average_frame, sqrsum_frame, frame_width, frame_height, frames, tr(\"stddev overview image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                stdFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n                        }\r\n                        emit progressIncrement(5);\r\n\r\n                        //************** SAVE UNCORRECTED OVERVIEW IMAGE\r\n                        if ((m_status==1) && !was_canceled && average_uncorrected_frame) {\r\n                            emit messageChanged(tr(\"saving uncorrected overview image ...\"));\r\n                            QString localFilename=averageUncorrectedFilename=outputFilenameBase+\".overview_uncorrected.tif\";\r\n\r\n                            QString error=\"\";\r\n                            if (!SaveTIFFFloat(localFilename, average_uncorrected_frame, frame_width, frame_height, tr(\"uncorrected overview image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                averageUncorrectedFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(5);\r\n\r\n                        //************** SAVE UNCORRECTED OVERVIEWSTD IMAGE\r\n                        if ((m_status==1) && !was_canceled && sqrsum_uncorrected_frame && average_uncorrected_frame) {\r\n                            emit messageChanged(tr(\"saving uncorrected overview stddev image ...\"));\r\n                            QString localFilename=stdUncorrectedFilename=outputFilenameBase+\".overviewstd_uncorrected.tif\";\r\n\r\n                            QString error=\"\";\r\n                            if (!SaveSDTIFF(localFilename, average_uncorrected_frame, sqrsum_uncorrected_frame, frame_width, frame_height, frames, tr(\"uncorrected overview stddev image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                stdUncorrectedFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n                        }\r\n                        emit progressIncrement(5);\r\n\r\n                        //************** SAVE BACKGROUND IMAGE\r\n                        if ((m_status==1) && !was_canceled && backgroundImage) {\r\n                            bool doSave=false;\r\n                            for (uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                if (backgroundImage[i]!=0) {\r\n                                    doSave=true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (doSave) {\r\n                                emit messageChanged(tr(\"saving background image ...\"));\r\n                                QString localFilename=backgroundFilename=outputFilenameBase+\".background.tif\";\r\n\r\n                                QString error=\"\";\r\n                                if (!SaveTIFFFloat(localFilename, backgroundImage, frame_width, frame_height, tr(\"background image\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    backgroundFilename=\"\";\r\n                                    emit messageChanged(error);\r\n                                }\r\n\r\n                            }\r\n\r\n                        }\r\n                        //************** SAVE BACKGROUND STDDEV IMAGE\r\n                        if ((m_status==1) && !was_canceled && backgroundImageStd) {\r\n                            bool doSave=false;\r\n                            for (uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                if (backgroundImageStd[i]!=0) {\r\n                                    doSave=true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (doSave) {\r\n                                emit messageChanged(tr(\"saving background S.D. image ...\"));\r\n                                QString localFilename=backstdFilename=outputFilenameBase+\".backgroundstd.tif\";\r\n\r\n                                QString error=\"\";\r\n                                if (!SaveTIFFFloat(localFilename, backgroundImageStd, frame_width, frame_height, tr(\"background S.D. image\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    backstdFilename=\"\";\r\n                                    emit messageChanged(error);\r\n                                }\r\n                            }\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n                        if ((m_status==1) && !was_canceled && firstFrames && lastFrames) {\r\n                            QString localFilename=bleachPercentageFilename=outputFilenameBase+\".bleachpercentage.tif\";\r\n                            QString error=\"\";\r\n                            for (uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                bleachPercentage[i]=(firstFrames[i]-lastFrames[i])/(firstFrames[i])*100.0;\r\n                            }\r\n                            if (!SaveTIFFFloat(localFilename, bleachPercentage, frame_width, frame_height, tr(\"bleach percentage image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                bleachPercentageFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n                        }\r\n\r\n                        //************** SAVE BLEACHING PARAMETERS IMAGE\r\n                        if ((m_status==1) && !was_canceled ) {\r\n                            if (job.bleach==BLEACH_EXP || job.bleach==BLEACH_EXP_POLY2 || job.bleach==BLEACH_EXP_POLY3  || job.bleach==BLEACH_EXP_POLY4 || job.bleach==BLEACH_EXP_POLY5  || job.bleach==BLEACH_DBL_EXP || job.bleach==BLEACH_EXPREG) {\r\n                                emit messageChanged(tr(\"saving bleach parameter images ...\"));\r\n                                QString localFilename;\r\n                                TIFF* tif;\r\n                                bool error=false;\r\n\r\n                                localFilename=bleachAmplitudeFilename=outputFilenameBase+\".bleachamplitude.tif\";\r\n                                tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteFloat(tif, bleachAmplitude, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                localFilename=bleachTimeFilename=outputFilenameBase+\".bleachtime.tif\";\r\n                                tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteFloat(tif, bleachTime, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                if (job.bleach==BLEACH_DBL_EXP) {\r\n                                    localFilename=bleachAmplitude2Filename=outputFilenameBase+\".bleachamplitude2.tif\";\r\n                                    tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachAmplitude2, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n\r\n                                    localFilename=bleachTime2Filename=outputFilenameBase+\".bleachtime2.tif\";\r\n                                    tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachTime2, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n\r\n                                }\r\n\r\n                                if (job.bleach==BLEACH_EXP_POLY2||job.bleach==BLEACH_EXP_POLY3||job.bleach==BLEACH_EXP_POLY4||job.bleach==BLEACH_EXP_POLY5 ) {\r\n                                    localFilename=bleachPoly2Filename=outputFilenameBase+\".bleachpoly2.tif\";\r\n                                    tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachPoly2, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n\r\n                                }\r\n                                if (job.bleach==BLEACH_EXP_POLY3||job.bleach==BLEACH_EXP_POLY4||job.bleach==BLEACH_EXP_POLY5 ) {\r\n                                    localFilename=bleachPoly3Filename=outputFilenameBase+\".bleachpoly3.tif\";\r\n                                    tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachPoly3, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n                                }\r\n                                if (job.bleach==BLEACH_EXP_POLY4||job.bleach==BLEACH_EXP_POLY5 ) {\r\n                                    localFilename=bleachPoly4Filename=outputFilenameBase+\".bleachpoly4.tif\";\r\n                                    tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachPoly4, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n                                }\r\n                                if (job.bleach==BLEACH_EXP_POLY5 ) {\r\n                                    localFilename=bleachPoly5Filename=outputFilenameBase+\".bleachpoly5.tif\";\r\n                                    tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachPoly5, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n                                }\r\n                                localFilename=bleachFitSuccessFilename=outputFilenameBase+\".bleachfitok.tif\";\r\n                                tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteUint8(tif, bleachFitOK, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                localFilename=firstFramesFilename=outputFilenameBase+\".firstframes.tif\";\r\n                                tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteFloat(tif, firstFrames, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                localFilename=lastFramesFilename=outputFilenameBase+\".lastframes.tif\";\r\n                                tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteFloat(tif, lastFrames, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                if (NFitFrames>0 && fit_t) {\r\n                                    localFilename=bleachtimesFilename=outputFilenameBase+\".bleachfittimes.txt\";\r\n                                    {\r\n                                        QFile f(localFilename);\r\n                                        if (f.open(QIODevice::WriteOnly|QIODevice::Text)) {\r\n                                            QTextStream text(&f);\r\n                                            text.setLocale(outLocale);\r\n                                            for (int i=0; i<NFitFrames; i++) {\r\n                                                text<<fit_t[i]<<\"\\n\";\r\n                                            }\r\n                                            f.close();\r\n                                        } else {\r\n                                            error=true;\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                if (NFitFrames>0 && fit_frames) {\r\n                                    localFilename=bleachframesFilename=outputFilenameBase+\".bleachfitframes.tif\";\r\n                                    tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                    if (tif) {\r\n                                        for (int i=0; i<NFitFrames; i++) {\r\n                                            TIFFTWriteFloat(tif, &(fit_frames[i*frame_width*frame_height]), frame_width, frame_height);\r\n                                            TIFFWriteDirectory(tif);\r\n                                        }\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n                                }\r\n\r\n\r\n                                if (error) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    backgroundFilename=\"\";\r\n                                    emit messageChanged(tr(\"could not create background image '%1'!\").arg(localFilename));\r\n                                }\r\n                            }\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n                        //************** SAVE ACF blocking results\r\n                        if ((m_status==1) && !was_canceled ) {\r\n                            if (job.useBlockingErrorEstimate && acf_blocklevel) {\r\n                                emit messageChanged(tr(\"saving ACF block level image ...\"));\r\n                                QString localFilename;\r\n                                TIFF* tif;\r\n                                bool error=false;\r\n\r\n                                localFilename=acfBlockLevelFilename=outputFilenameBase+\".acfblocklevels.tif\";\r\n                                tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteUint16from32(tif, acf_blocklevel, frame_width, frame_height, false);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n                            }\r\n                            if (job.useBlockingErrorEstimate && acf_blocksuccess) {\r\n                                emit messageChanged(tr(\"saving ACF block success image ...\"));\r\n                                QString localFilename;\r\n                                TIFF* tif;\r\n                                bool error=false;\r\n\r\n                                localFilename=acfBlockSuccessFilename=outputFilenameBase+\".acfblocksuccess.tif\";\r\n                                tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteBoolAsUint8(tif, acf_blocksuccess, frame_width, frame_height, false);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n                            }\r\n\r\n                            if (job.distanceCCF) {\r\n                                TIFF* tif;\r\n                                for (int id=0; id<job.DCCFDeltaX.size(); id++) {\r\n                                    if (dccf[id].dccf_blocklevel) {\r\n                                        emit messageChanged(tr(\"saving DCCF block level image ...\"));\r\n                                        QString localFilename=outputFilenameBase+QString(\".dccf%1_blocklevels.tif\").arg(id,3,10,QLatin1Char('0'));\r\n                                        dccfBlockLevelFilename.append(localFilename);\r\n                                        tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                        if (tif) {\r\n                                            TIFFTWriteUint16from32(tif, dccf[id].dccf_blocklevel, frame_width, frame_height, false);\r\n                                            TIFFClose(tif);\r\n                                        }\r\n\r\n                                        localFilename=outputFilenameBase+QString(\".dccf%1_blocksuccess.tif\").arg(id,3,10,QLatin1Char('0'));\r\n                                        dccfBlockSuccessFilename.append(localFilename);\r\n                                        tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                        if (tif) {\r\n                                            TIFFTWriteBoolAsUint8(tif, dccf[id].dccf_blocksuccess, frame_width, frame_height, false);\r\n                                            TIFFClose(tif);\r\n                                        }\r\n                                    } else {\r\n                                        dccfBlockLevelFilename.append(QString());\r\n                                        dccfBlockSuccessFilename.append(QString());\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        double videoAvgMin=0;\r\n                        double videoAvgMax=(float)0xFFFF;\r\n                        //************** SAVE VIDEO\r\n                        if ((m_status==1) && !was_canceled && video && real_video_count>0 ) {\r\n                            emit messageChanged(tr(\"saving video ...\"));\r\n                            QString localFilename=videoFilename=outputFilenameBase+\".video.tif\";\r\n                            TinyTIFFFile* tif=TinyTIFFWriter_open(localFilename.toLatin1().data(), 16, frame_width, frame_height);\r\n                            //TIFF* tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                            if (tif) {\r\n                                float avgMin=video[0];\r\n                                float avgMax=video[0];\r\n                                for (register uint32_t i=0; i<frame_width*frame_height*video_count; i++) {\r\n                                    avgMin=(video[i]<avgMin)?video[i]:avgMin;\r\n                                    avgMax=(video[i]>avgMax)?video[i]:avgMax;\r\n                                }\r\n                                uint16_t* img=(uint16_t*)qfMalloc(frame_width*frame_height*sizeof(uint16_t));\r\n                                for (register uint32_t c=0; c<real_video_count; c++) {\r\n                                    for (register uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                        img[i]=(uint16_t)round((float)(video[c*frame_width*frame_height+i]-avgMin)*(float)0xFFFF/fabs(avgMax-avgMin));\r\n                                    }\r\n                                    TinyTIFFWriter_writeImage(tif, img);\r\n                                    if (real_video_count/10>0) {\r\n                                        if (c%(real_video_count/10)==0) {\r\n                                            emit messageChanged(tr(\"saving video %1/%2...\").arg(c+1).arg(video_count));\r\n                                            progressIncrement(10);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if (real_video_count/10<=0) progressIncrement(100);\r\n                                qfFree(img);\r\n                                TinyTIFFWriter_close(tif);\r\n                                videoAvgMin = avgMin;\r\n                                videoAvgMax = avgMax;\r\n                            } else {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create video '%1'!\").arg(localFilename));\r\n                            }\r\n\r\n                        } else emit progressIncrement(100);\r\n\r\n                        double videoUncorrectedAvgMin=0;\r\n                        double videoUncorrectedAvgMax=(float)0xFFFF;\r\n                        //************** SAVE VIDEO\r\n                        if ((m_status==1) && !was_canceled && video_uncorrected && real_video_count>0 ) {\r\n                            emit messageChanged(tr(\"saving uncorrected video ...\"));\r\n                            QString localFilename=videoUncorrectedFilename=outputFilenameBase+\".videouncorr.tif\";\r\n                            TinyTIFFFile* tif=TinyTIFFWriter_open(localFilename.toLatin1().data(), 16, frame_width, frame_height);\r\n                            //TIFF* tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                            if (tif) {\r\n                                float avgMin=video_uncorrected[0];\r\n                                float avgMax=video_uncorrected[0];\r\n                                for (register uint32_t i=0; i<frame_width*frame_height*video_count; i++) {\r\n                                    avgMin=(video_uncorrected[i]<avgMin)?video_uncorrected[i]:avgMin;\r\n                                    avgMax=(video_uncorrected[i]>avgMax)?video_uncorrected[i]:avgMax;\r\n                                }\r\n                                uint16_t* img=(uint16_t*)qfMalloc(frame_width*frame_height*sizeof(uint16_t));\r\n                                for (register uint32_t c=0; c<real_video_count; c++) {\r\n                                    for (register uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                        img[i]=(uint16_t)round((float)(video_uncorrected[c*frame_width*frame_height+i]-avgMin)*(float)0xFFFF/fabs(avgMax-avgMin));\r\n                                    }\r\n                                    TinyTIFFWriter_writeImage(tif, img);\r\n                                    if (real_video_count/10>0) {\r\n                                        if (c%(real_video_count/10)==0) {\r\n                                            emit messageChanged(tr(\"saving uncorrected video %1/%2...\").arg(c+1).arg(video_count));\r\n                                            progressIncrement(10);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if (real_video_count/10<=0) progressIncrement(100);\r\n                                qfFree(img);\r\n                                TinyTIFFWriter_close(tif);\r\n                                videoUncorrectedAvgMin = avgMin;\r\n                                videoUncorrectedAvgMax = avgMax;\r\n                            } else {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create uncorrected video '%1'!\").arg(localFilename));\r\n                            }\r\n\r\n                        } else emit progressIncrement(100);\r\n\r\n                        //************** SAVE STATISTICS\r\n                        if ((m_status==1) && !was_canceled && job.statistics) {\r\n                            QString error=\"\";\r\n                            emit messageChanged(tr(\"saving statistics ...\"));\r\n                            if (!saveStatistics(statisticsFilename=outputFilenameBase+\".statistics.dat\", outputFilenameBase+\".statistics.plt\", statistics, tr(\"Corrected Statistics\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create statistics file %1!\").arg(error));\r\n                            }\r\n\r\n                            emit messageChanged(tr(\"saving background statistics ...\"));\r\n                            if (!saveStatistics(backstatisticsFilename=outputFilenameBase+\".backstatistics.dat\", outputFilenameBase+\".backstatistics.plt\", backstatistics, tr(\"Background Statistics\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create backgrond statistics file %1!\").arg(error));\r\n                            }\r\n\r\n                            emit messageChanged(tr(\"saving uncorrected statistics ...\"));\r\n                            if (!saveStatistics(uncorrectedStatisticsFilename=outputFilenameBase+\".uncorrstatistics.dat\", outputFilenameBase+\".uncorrstatistics.plt\", statistics_uncorrected, tr(\"Uncorrected Statistics\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create uncorrected statistics file %1!\").arg(error));\r\n                            }\r\n\r\n                            if (job.dualViewMode!=DUALVIEW_NONE) {\r\n                                emit messageChanged(tr(\"saving DV 1 statistics ...\"));\r\n                                if (!saveStatistics(statisticsFilename_dv1=outputFilenameBase+\".statistics_dv1.dat\", outputFilenameBase+\".statistics_dv1.plt\", dv_statistics[0], tr(\"Corrected Statistics, DV 1\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 1 statistics file %1!\").arg(error));\r\n                                }\r\n                                emit messageChanged(tr(\"saving DV 2 statistics ...\"));\r\n                                if (!saveStatistics(statisticsFilename_dv2=outputFilenameBase+\".statistics_dv2.dat\", outputFilenameBase+\".statistics_dv2.plt\", dv_statistics[1], tr(\"Corrected Statistics, DV 2\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 2 statistics file %1!\").arg(error));\r\n                                }\r\n\r\n\r\n                                emit messageChanged(tr(\"saving DV 1 background statistics ...\"));\r\n                                if (!saveStatistics(backstatisticsFilename_dv1=outputFilenameBase+\".backstatistics_dv1.dat\", outputFilenameBase+\".backstatistics_dv1.plt\", dv_backstatistics[0], tr(\"Background Statistics, DV 1\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 1 background statistics file %1!\").arg(error));\r\n                                }\r\n                                emit messageChanged(tr(\"saving DV 2 background statistics ...\"));\r\n                                if (!saveStatistics(backstatisticsFilename_dv2=outputFilenameBase+\".backstatistics_dv2.dat\", outputFilenameBase+\".backstatistics_dv2.plt\", dv_backstatistics[1], tr(\"Background Statistics, DV 2\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 2 background statistics file %1!\").arg(error));\r\n                                }\r\n\r\n\r\n                                emit messageChanged(tr(\"saving DV 1 uncorrected statistics ...\"));\r\n                                if (!saveStatistics(uncorrectedStatisticsFilename_dv1=outputFilenameBase+\".uncorrstatistics_dv1.dat\", outputFilenameBase+\".uncorrstatistics_dv1.plt\", dv_statistics_uncorrected[0], tr(\"Background Statistics, DV 1\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 1 uncorrected statistics file %1!\").arg(error));\r\n                                }\r\n                                emit messageChanged(tr(\"saving DV 2 uncorrected statistics ...\"));\r\n                                if (!saveStatistics(uncorrectedStatisticsFilename_dv2=outputFilenameBase+\".uncorrstatistics_dv2.dat\", outputFilenameBase+\".uncorrstatistics_dv2.plt\", dv_statistics_uncorrected[1], tr(\"Background Statistics, DV 2\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 2 uncorrected statistics file %1!\").arg(error));\r\n                                }\r\n\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n\r\n\r\n                        //************** SAVE SETTINGS\r\n                        if ((m_status==1) && !was_canceled) {\r\n                            emit messageChanged(tr(\"saving settings ...\"));\r\n                            QString& localFilename=configFilename;\r\n                            QFile f(localFilename);\r\n                            QDir d=QFileInfo(localFilename).absoluteDir();\r\n                            if (f.open(QIODevice::WriteOnly|QIODevice::Text)) {\r\n                                QTextStream text(&f);\r\n                                text.setLocale(outLocale);\r\n\r\n                                text<<\"date/time                   : \"<<QDateTime::currentDateTime().toString(\"yyyy/MM/dd hh:mm:ss\") << \"\\n\";\r\n                                text<<\"input file                  : \"<<d.relativeFilePath(job.filename) << \"\\n\";\r\n                                if (!job.descriptionFilename.isEmpty()) text<<\"input description file      : \" << d.relativeFilePath(job.descriptionFilename) << \"\\n\";\r\n                                if (!averageFilename.isEmpty())         text<<\"overview image file         : \" << d.relativeFilePath(averageFilename) << \"\\n\";\r\n                                if (!averageFilenameF.isEmpty())        text<<\"overview image file real    : \" << d.relativeFilePath(averageFilenameF) << \"\\n\";\r\n                                if (!stdFilename.isEmpty())             text<<\"overview std image          : \" << d.relativeFilePath(stdFilename) << \"\\n\";\r\n                                if (!backgroundFilename.isEmpty())      text<<\"background image file       : \" << d.relativeFilePath(backgroundFilename) << \"\\n\";\r\n                                if (!backstdFilename.isEmpty())         text<<\"background stddev           : \" << d.relativeFilePath(backstdFilename) << \"\\n\";\r\n                                if (!averageUncorrectedFilename.isEmpty())         text<<\"uncorr. overview image file : \" << d.relativeFilePath(averageUncorrectedFilename) << \"\\n\";\r\n                                if (!stdUncorrectedFilename.isEmpty())             text<<\"uncorr. overview std image  : \" << d.relativeFilePath(stdUncorrectedFilename) << \"\\n\";\r\n                                if (!videoFilename.isEmpty())           text<<\"video file                  : \" << d.relativeFilePath(videoFilename) << \"\\n\";\r\n                                if (!videoUncorrectedFilename.isEmpty())text<<\"uncorrected video file      : \" << d.relativeFilePath(videoUncorrectedFilename) << \"\\n\";\r\n                                if (!statisticsFilename.isEmpty())      text<<\"statistics file             : \" << d.relativeFilePath(statisticsFilename) << \"\\n\";\r\n                                if (!backstatisticsFilename.isEmpty())         text<<\"background statistics file  : \" << d.relativeFilePath(backstatisticsFilename) << \"\\n\";\r\n                                if (!uncorrectedStatisticsFilename.isEmpty())  text<<\"uncorrected statistics file : \" << d.relativeFilePath(uncorrectedStatisticsFilename) << \"\\n\";\r\n\r\n                                if (!statisticsFilename_dv1.isEmpty())      text<<\"statistics file DV1         : \" << d.relativeFilePath(statisticsFilename_dv1) << \"\\n\";\r\n                                if (!backstatisticsFilename_dv1.isEmpty())         text<<\"background statistics file DV1 : \" << d.relativeFilePath(backstatisticsFilename_dv1) << \"\\n\";\r\n                                if (!uncorrectedStatisticsFilename_dv1.isEmpty())  text<<\"uncorrected statistics file DV1 : \" << d.relativeFilePath(uncorrectedStatisticsFilename_dv1) << \"\\n\";\r\n                                if (!statisticsFilename_dv2.isEmpty())      text<<\"statistics file DV2         : \" << d.relativeFilePath(statisticsFilename_dv2) << \"\\n\";\r\n                                if (!backstatisticsFilename_dv2.isEmpty())         text<<\"background statistics file DV2 : \" << d.relativeFilePath(backstatisticsFilename_dv2) << \"\\n\";\r\n                                if (!uncorrectedStatisticsFilename_dv2.isEmpty())  text<<\"uncorrected statistics file DV2 : \" << d.relativeFilePath(uncorrectedStatisticsFilename_dv2) << \"\\n\";\r\n\r\n                                if (!acfFilename.isEmpty())             text<<\"autocorrelation file        : \" << d.relativeFilePath(acfFilename) << \"\\n\";\r\n                                if (!acfFilenameBin.isEmpty())          text<<\"bin. autocorrelation file   : \" << d.relativeFilePath(acfFilenameBin) << \"\\n\";\r\n                                for (int id=0; id<qMax(dccfFilename.size(), dccfFilenameBin.size()); id++) {\r\n                                    if (id<dccfFilename.size())            text<<QString(\"distance ccf file %1        : \").arg(id) << d.relativeFilePath(dccfFilename[id]) << \"\\n\";\r\n                                    if (id<dccfFilenameBin.size())         text<<QString(\"bin. distance ccf file %1   : \").arg(id) << d.relativeFilePath(dccfFilenameBin[id]) << \"\\n\";\r\n                                }\r\n                                text<<\"width                       : \"<<outLocale.toString(frame_width) << \"\\n\";\r\n                                text<<\"height                      : \"<<outLocale.toString(frame_height) << \"\\n\";\r\n                                if (job.cameraSettingsGiven) {\r\n                                    text<<\"pixel width                 : \"<<outLocale.toString(job.cameraPixelWidth) << \"\\n\";\r\n                                    text<<\"pixel height                : \"<<outLocale.toString(job.cameraPixelHeight) << \"\\n\";\r\n                                }\r\n                                text<<\"frametime (ms)              : \"<<job.frameTime*1.0e3 << \"\\n\";\r\n                                text<<\"frametime (s)               : \"<<job.frameTime << \"\\n\";\r\n                                text<<\"dualview mode               : \"<<job.dualViewMode << \"\\n\";\r\n                                text<<\"binning                     : \"<<outLocale.toString(reader->getBinning()) << \"\\n\";\r\n                                text<<\"interleaved binning         : \"<< QString((reader->getInterleavedBinning())?\"true\":\"false\") << \"\\n\";\r\n                                text<<\"averaging binning           : \"<< QString((reader->getAverageBinning())?\"true\":\"false\") << \"\\n\";\r\n                                if (reader->getUseCropping()) {\r\n                                    text<<\"crop x0                     : \"<<outLocale.toString(reader->getCropX0()) << \"\\n\";\r\n                                    text<<\"crop x1                     : \"<<outLocale.toString(reader->getCropX1()) << \"\\n\";\r\n                                    text<<\"crop y0                     : \"<<outLocale.toString(reader->getCropY0()) << \"\\n\";\r\n                                    text<<\"crop y1                     : \"<<outLocale.toString(reader->getCropY1()) << \"\\n\";\r\n                                }\r\n                                text<<\"frame count in file         : \"<<outLocale.toString(frame_count) << \"\\n\";\r\n                                text<<\"frame count                 : \"<<outLocale.toString(frames) << \"\\n\";\r\n                                text<<\"first frame                 : \"<<outLocale.toString(first_frame) << \"\\n\";\r\n                                text<<\"last frame                  : \"<<outLocale.toString(first_frame+frames-1) << \"\\n\";\r\n                                text<<\"correlation segments        : \"<<outLocale.toString(job.segments) << \"\\n\";\r\n                                text<<\"correlation use blocking    : \"<<boolToQString(job.useBlockingErrorEstimate) << \"\\n\";\r\n                                text<<\"segments length (s)         : \"<<outLocale.toString(double(frames)/double(job.segments)*job.frameTime) << \"\\n\";\r\n                                text<<\"correlator S                : \"<<outLocale.toString(job.S) << \"\\n\";\r\n                                text<<\"correlator m                : \"<<outLocale.toString(job.m) << \"\\n\";\r\n                                text<<\"correlator P                : \"<<outLocale.toString(job.P) << \"\\n\";\r\n                                text<<\"correlator type             : \"<<outLocale.toString(job.correlator) << \"\\n\";\r\n                                text<<\"correlator type name        : \";\r\n                                switch(job.correlator) {\r\n                                    case CORRELATOR_DIRECT:      text<<\"direct\\n\"; break;\r\n                                    case CORRELATOR_DIRECTAVG:   text<<\"direct with averaging\\n\"; break;\r\n                                    case CORRELATOR_DIRECT_INT:    text<<\"direct, integer\\n\"; break;\r\n                                    case CORRELATOR_DIRECTAVG_INT: text<<\"direct with averaging, integer\\n\"; break;\r\n                                    case CORRELATOR_MTAUALLMON:  text<<\"multi-tau with monitors for all channels\\n\"; break;\r\n                                    case CORRELATOR_MTAUONEMON:  text<<\"multi-tau with a single monitor\\n\"; break;\r\n                                    case CORRELATOR_CORRELATORFROMSHAREDLIB:  text<<\"multi-tau from shared library\\n\"; break;\r\n\r\n                                    default: text<<\"correlator type name        : unknown\\n\"; break;\r\n                                }\r\n                                text<<\"smallest tau [s]            : \"<<outLocale.toString(job.frameTime) << \"\\n\";\r\n                                text<<\"baseline                    : \"<<outLocale.toString(baseline) << \"\\n\";\r\n                                if (video && job.video) {\r\n                                    text<<\"video sum up                : \"<<outLocale.toString(job.video_frames) << \"\\n\";\r\n                                    text<<\"video frames                : \"<<outLocale.toString(real_video_count) << \"\\n\";\r\n                                    text<<\"video avgMin                : \"<<outLocale.toString(videoAvgMin) << \"\\n\";\r\n                                    text<<\"video avgMax                : \"<<outLocale.toString(videoAvgMax) << \"\\n\";\r\n                                    text<<\"video uncorrected avgMin    : \"<<outLocale.toString(videoUncorrectedAvgMin) << \"\\n\";\r\n                                    text<<\"video uncorrected avgMax    : \"<<outLocale.toString(videoUncorrectedAvgMax) << \"\\n\";\r\n                                }\r\n                                if (job.statistics) {\r\n                                    text<<\"statistics over             : \"<<outLocale.toString(job.statistics_frames) << \"\\n\";\r\n                                }\r\n                                if (job.distanceCCF) {\r\n                                    for (int id=0; id<job.DCCFDeltaX.size(); id++) {\r\n                                        text<<QString(\"DCCF %1 role                   : \").arg(id)<<job.DCCFrole[id] << \"\\n\";\r\n                                        text<<QString(\"DCCF %1 Delta x                : \").arg(id)<<outLocale.toString(job.DCCFDeltaX[id]) << \"\\n\";\r\n                                        text<<QString(\"DCCF %1 Delta y                : \").arg(id)<<outLocale.toString(job.DCCFDeltaY[id]) << \"\\n\";\r\n                                        text<<QString(\"DCCF %1 frame width            : \").arg(id)<<outLocale.toString(dccf[id].dccfframe_width) << \"\\n\";\r\n                                        text<<QString(\"DCCF %1 frame height           : \").arg(id)<<outLocale.toString(dccf[id].dccfframe_height) << \"\\n\";\r\n                                    }\r\n\r\n                                }\r\n                                text<<\"bleach percentage file      : \"<<d.relativeFilePath(bleachPercentageFilename) << \"\\n\";\r\n                                text<<\"bleach correction           : \";\r\n                                if (job.bleach==BLEACH_EXP) {\r\n                                    text<<\"remove mono-exponential f(t)=A*exp(-t/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                    text<<\"bleach correction           : \";\r\n                                } else if (job.bleach==BLEACH_EXP_POLY2 ) {\r\n                                    text<<\"remove mono-exponential(polynomial) f(t)=A*exp(-(t+f2*t^2)/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor file : \"<<d.relativeFilePath(bleachPoly2Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 3 file : \"<<d.relativeFilePath(bleachPoly3Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_EXP_POLY3) {\r\n                                    text<<\"remove mono-exponential(polynomial) f(t)=A*exp(-(t+f2*t^2+f3*t^3)/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor file : \"<<d.relativeFilePath(bleachPoly2Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 3 file : \"<<d.relativeFilePath(bleachPoly3Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_EXP_POLY4) {\r\n                                    text<<\"remove mono-exponential(polynomial) f(t)=A*exp(-(t+f*t^2+f3*t^3+f4*t^4)/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor file : \"<<d.relativeFilePath(bleachPoly2Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 3 file : \"<<d.relativeFilePath(bleachPoly3Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 4 file : \"<<d.relativeFilePath(bleachPoly4Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_EXP_POLY5) {\r\n                                    text<<\"remove mono-exponential(polynomial) f(t)=A*exp(-(t+f*t^2+f3*t^3+f4*t^4+f5*t^5)/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor file : \"<<d.relativeFilePath(bleachPoly2Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 3 file : \"<<d.relativeFilePath(bleachPoly3Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 4 file : \"<<d.relativeFilePath(bleachPoly4Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 5 file : \"<<d.relativeFilePath(bleachPoly5Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_DBL_EXP) {\r\n                                    text<<\"remove double-exponential f(t)=A*exp(-t/tau)+A2*exp(-t/tau2) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach amplitude 2 file       : \"<<d.relativeFilePath(bleachAmplitude2Filename) << \"\\n\";\r\n                                    text<<\"bleach time 2 file            : \"<<d.relativeFilePath(bleachTime2Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_EXPREG) {\r\n                                    text<<\"remove mono-exponential f(t)=A*exp(-t/tau) using linear regression\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                }  else if (job.bleach==BLEACH_NONE) {\r\n                                        text<<\"remove frame average\\n\";\r\n                                        text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n\r\n                                } else {\r\n                                    text<<\"none\\n\";\r\n                                }\r\n                                if (acfBlockLevelFilename.size()>0) text<<\"ACF blocking level file     : \"<<d.relativeFilePath(acfBlockLevelFilename) << \"\\n\";\r\n                                if (acfBlockSuccessFilename.size()>0) text<<\"ACF blocking success file   : \"<<d.relativeFilePath(acfBlockSuccessFilename) << \"\\n\";\r\n                                if (job.distanceCCF) {\r\n                                    for (int id=0; id<job.DCCFDeltaX.size(); id++) {\r\n                                        if (dccfBlockLevelFilename.value(id).size()>0) text<<QString(\"DCCF %1 (%2) blocking level file : \").arg(id).arg(job.DCCFrole[id])<<d.relativeFilePath(dccfBlockLevelFilename.value(id)) << \"\\n\";\r\n                                        if (dccfBlockSuccessFilename.value(id).size()>0) text<<QString(\"DCCF %1 (%2) blocking success file : \").arg(id).arg(job.DCCFrole[id])<<d.relativeFilePath(dccfBlockSuccessFilename.value(id)) << \"\\n\";\r\n                                    }\r\n                                }\r\n                                text<<\"duration [s]                : \"<<ptime.elapsed()/1000.0 << \"\\n\";\r\n\r\n                                f.close();\r\n                            } else {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create settings file '%1': %2!\").arg(localFilename).arg(f.errorString()));\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n\r\n                        //************** SAVE ACF\r\n                        if ((m_status==1) && !was_canceled && job.acf && acf && acf_tau && acf_N>0) {\r\n                            QString localFilename=acfFilename=outputFilenameBase+\".autocorrelation.dat\";\r\n                            QString localFilename1=acfFilenameBin=outputFilenameBase+\".autocorrelation.bin\";\r\n\r\n                            emit messageChanged(tr(\"saving autocorrelation ...\"));\r\n                            double* ccf[1]={acf};\r\n                            double* ccferr[1]={acf_std};\r\n                            double* ccfsegments[1]={acf_segments};\r\n                            QString error;\r\n                            //qDebug()<<\"acf = \"<<acf<<\"  acf_std = \"<<acf_std;\r\n                            if (!saveCorrelationCSV(localFilename, acf_tau, ccf, ccferr, 1, acf_N, frame_width, frame_height, input_length, error,125, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create autocorrelation file '%1': %2!\").arg(localFilename).arg(error));\r\n                            }\r\n                            if (!saveCorrelationBIN(localFilename1, acf_tau, ccf, ccferr, 1, acf_N, frame_width, frame_height, ccfsegments, error,125, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create binary autocorrelation file '%1': %2!\").arg(localFilename1).arg(error));\r\n                            }\r\n                            if (job.addFCCSSeparately && job.dualViewMode!=DUALVIEW_NONE) {\r\n                                if (QFile::exists(localFilename1)) {\r\n                                    addFiles.append(getFileInfo(localFilename1, configFilename, \"ACF0\", 0, getGroupName()));\r\n                                    addFiles.append(getFileInfo(localFilename1, configFilename, \"ACF1\", 1, getGroupName()));\r\n                                } else {\r\n                                    addFiles.append(getFileInfo(localFilename, configFilename, \"ACF0\", 0, getGroupName()));\r\n                                    addFiles.append(getFileInfo(localFilename, configFilename, \"ACF1\", 1, getGroupName()));\r\n                                }\r\n                            } else {\r\n                                if (QFile::exists(localFilename1)) addFiles.append(getFileInfo(localFilename1, configFilename, \"ACF\", getGroupName()));\r\n                                else addFiles.append(getFileInfo(localFilename, configFilename, \"ACF\", getGroupName()));\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(250);\r\n\r\n\r\n                        //************** SAVE DCCF\r\n                        if ((m_status==1) && !was_canceled && job.distanceCCF) {\r\n                            for (int id=0; id<job.DCCFDeltaX.size(); id++) {\r\n                                if (dccf[id].dccf && dccf[id].dccf_tau && dccf[id].dccf_N>0) {\r\n                                    QString localFilename=outputFilenameBase+QString(\".dccf%1.dat\").arg(id,3,10,QLatin1Char('0'));\r\n                                    QString localFilename1=outputFilenameBase+QString(\".dccf%1.bin\").arg(id,3,10,QLatin1Char('0'));;\r\n                                    dccfFilename.append(localFilename);\r\n                                    dccfFilenameBin.append(localFilename1);\r\n\r\n                                    emit messageChanged(tr(\"saving distance distance crosscorrelation ...\"));\r\n                                    double* ccf[1]={dccf[id].dccf};\r\n                                    double* ccferr[1]={dccf[id].dccf_std};\r\n                                    double* ccfsegments[1]={dccf[id].dccf_segments};\r\n                                    QString error;\r\n                                    if (!saveCorrelationCSV(localFilename, dccf[id].dccf_tau, ccf, ccferr, 1, dccf[id].dccf_N, frame_width, frame_height, input_length, error,125, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                        m_status=-1; emit statusChanged(m_status);\r\n                                        emit messageChanged(tr(\"could not create distance crosscorrelation file '%1': %2!\").arg(localFilename).arg(error));\r\n                                    }\r\n                                    if (!saveCorrelationBIN(localFilename1, dccf[id].dccf_tau, ccf, ccferr, 1, dccf[id].dccf_N, frame_width, frame_height, ccfsegments, error,125, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                        m_status=-1; emit statusChanged(m_status);\r\n                                        emit messageChanged(tr(\"could not create binary distance crosscorrelation file '%1': %2!\").arg(localFilename1).arg(error));\r\n                                    }\r\n                                    QString role=job.DCCFrole.value(id, \"DCCF\");\r\n                                    if (role.toLower()==\"fccs\") {\r\n                                        if (QFile::exists(localFilename1)) addFiles.append(getFileInfo(localFilename1, configFilename, role, 0, getGroupName()));\r\n                                        else addFiles.append(getFileInfo(localFilename, configFilename, role, 0, getGroupName()));\r\n                                    } else {\r\n                                        if (QFile::exists(localFilename1)) addFiles.append(getFileInfo(localFilename1, configFilename, role, getGroupName()));\r\n                                        else addFiles.append(getFileInfo(localFilename, configFilename, role, getGroupName()));\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        emit progressIncrement(250);\r\n\r\n\r\n\r\n\r\n\r\n                        //qDebug()<<job.addNandB<< QFile::exists(averageFilenameF)<< QFile::exists(stdFilename)<< QFile::exists(backgroundFilename)<< QFile::exists(backstdFilename);\r\n\r\n                        //************** CREATE N&B job\r\n                        if (job.addNandB\r\n                                && QFile::exists(averageFilenameF)\r\n                                && QFile::exists(stdFilename)\r\n                                /*&& QFile::exists(backgroundFilename)\r\n                                && QFile::exists(backstdFilename)*/) {\r\n\r\n                            if (job.addFCCSSeparately && job.dualViewMode!=DUALVIEW_NONE) {\r\n                                addFiles.append(getFileInfoNandB(averageFilenameF, stdFilename, backgroundFilename, backstdFilename, configFilename, \"N&B1\", 0, getGroupName()));\r\n                                addFiles.append(getFileInfoNandB(averageFilenameF, stdFilename, backgroundFilename, backstdFilename, configFilename, \"N&B2\", 1, getGroupName()));\r\n                            } else {\r\n                                addFiles.append(getFileInfoNandB(averageFilenameF, stdFilename, backgroundFilename, backstdFilename, configFilename, \"N&B\", 0, getGroupName()));\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (mutexFilename) mutexFilename->unlock();\r\n                        m_status=-1; emit statusChanged(m_status);\r\n                        emit messageChanged(tr(\"could not create output subdirectory '%1' in '%2'!\").arg(localFileDirectory).arg(d.absolutePath()));\r\n                    }\r\n\r\n                    if (video) qfFree(video);\r\n                    if (video_uncorrected) qfFree(video_uncorrected);\r\n                    if (fit_frames) qfFree(fit_frames);\r\n                    if (fit_t) qfFree(fit_t);\r\n                    if (bleachAmplitude) qfFree(bleachAmplitude);\r\n                    if (bleachTime) qfFree(bleachTime);\r\n                    if (bleachAmplitude2) qfFree(bleachAmplitude2);\r\n                    if (bleachTime2) qfFree(bleachTime2);\r\n                    if (bleachPoly2) qfFree(bleachPoly2);\r\n                    if (bleachPoly3) qfFree(bleachPoly3);\r\n                    if (bleachPoly4) qfFree(bleachPoly4);\r\n                    if (bleachPoly5) qfFree(bleachPoly5);\r\n                    if (bleachFitOK) qfFree(bleachFitOK);\r\n                    if (firstFrames) qfFree(firstFrames);\r\n                    firstFrames=NULL;\r\n                    if (lastFrames) qfFree(lastFrames);\r\n                    lastFrames=NULL;\r\n                    if (average_frame) qfFree(average_frame);\r\n                    if (sqrsum_frame) qfFree(sqrsum_frame);\r\n                    if (acf_tau) qfFree(acf_tau);\r\n                    if (acf) qfFree(acf);\r\n                    if (acf_segments) qfFree(acf_segments);\r\n                    if (acf_std) qfFree(acf_std);\r\n                    if (acf_blocklevel) qfFree(acf_blocklevel);\r\n                    if (acf_blocksuccess) qfFree(acf_blocksuccess);\r\n\r\n                    if (bleachPercentage) qfFree(bleachPercentage);\r\n                    bleachPercentage=NULL;\r\n                    for (int id=0; id<dccf.size(); id++) {\r\n                        if (dccf[id].dccf_tau) qfFree(dccf[id].dccf_tau);\r\n                        if (dccf[id].dccf) qfFree(dccf[id].dccf);\r\n                        if (dccf[id].dccf_std) qfFree(dccf[id].dccf_std);\r\n                        if (dccf[id].dccf_segments) qfFree(dccf[id].dccf_segments);\r\n                        if (dccf[id].dccf_blocklevel) qfFree(dccf[id].dccf_blocklevel);\r\n                        if (dccf[id].dccf_blocksuccess) qfFree(dccf[id].dccf_blocksuccess);\r\n                    }\r\n                    dccf.clear();\r\n                    if (m_status==1) {\r\n                        if (was_canceled) {\r\n                            m_status=-1; emit statusChanged(m_status);\r\n                            duration=ptime.elapsed();\r\n                            emit messageChanged(tr(\"canceled by user\"));\r\n                        } else {\r\n                            m_status=2; emit statusChanged(m_status);\r\n                            duration=ptime.elapsed();\r\n                            emit messageChanged(tr(\"correlation ... done [duration = %1 s]\").arg(duration/1.0e3));\r\n                        }\r\n                        emit statusChanged(m_status);\r\n                    }\r\n                } else {\r\n                    m_status=-1; emit statusChanged(m_status);\r\n                    duration=ptime.elapsed();\r\n                    emit messageChanged(tr(\"no frames in file/selected\"));\r\n                }\r\n\r\n\r\n            }\r\n            delete reader;\r\n        } else {\r\n            m_status=-1; emit statusChanged(m_status);\r\n            duration=ptime.elapsed();\r\n            emit messageChanged(tr(\"could not create image reader object\"));\r\n        }\r\n    }\r\n\r\n\r\n    duration=ptime.elapsed();\r\n}",
    "void QFESPIMB040CamParamStackConfigWidget2::performStack()\r\n{\r\n    if (!(this->use1() || this->use2())) {\r\n        QMessageBox::critical(this, tr(\"B040SPIM: Parameter Stack Acquisition\"), tr(\"Cannot start image acquisition: No camera selected!\"));\r\n        return;\r\n    }\r\n\r\n    QDateTime startDateTime=QDateTime::currentDateTime();\r\n    QList<QFESPIMB040OpticsSetupBase::measuredValues> measured;\r\n\r\n\r\n    bool ok=true;\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // get array of values\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    QList<double> scanVals=this->stack();\r\n    if (scanVals.isEmpty()) {\r\n        QMessageBox::critical(this, tr(\"B040SPIM: Parameter Stack Acquisition\"), tr(\"No values to scan selected!\"));\r\n        return;\r\n    }\r\n    int images=scanVals.size()*this->images();\r\n\r\n\r\n    log->log_text(tr(\"starting parameter stack acquisition:\\n\"));\r\n    log->log_text(tr(\"  - scan parameter: %1\\n\").arg(this->stackParameterName()));\r\n    log->log_text(tr(\"  - scan mode: %1\\n\").arg(this->stackModeName()));\r\n    log->log_text(tr(\"  - scan start: %1\\n\").arg(this->stackStart()));\r\n    log->log_text(tr(\"  - scan end: %1\\n\").arg(this->stackEnd()));\r\n    log->log_text(tr(\"  - scan delta: %1\\n\").arg(this->stackDelta()));\r\n    opticsSetup->lockLightpath();\r\n\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // LOCK/INIT CAMERA 1\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    bool useCam1=false;\r\n    QFExtension* extension1=NULL;\r\n    QFExtensionCamera* ecamera1=NULL;\r\n    int camera1=0;\r\n    QString acquisitionSettingsFilename1=\"\", previewSettingsFilename1=\"\";\r\n    QString acquisitionPrefix1=this->prefix1();\r\n    QString TIFFFIlename1=acquisitionPrefix1+\".tif\";\r\n    TIFF* tiff1=NULL;\r\n    if (this->use1()) {\r\n        if (!(useCam1=opticsSetup->lockCamera(0, &extension1, &ecamera1, &camera1, &previewSettingsFilename1))) {\r\n            CAMPARAMSTACK_ERROR(tr(\"error locking camer 1!\\n\"));\r\n        }\r\n    }\r\n    if (QFile::exists(this->currentConfigFilename(0))) acquisitionSettingsFilename1=this->currentConfigFilename(0);\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // LOCK/INIT CAMERA 2\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    bool useCam2=false;\r\n    QFExtension* extension2=NULL;\r\n    QFExtensionCamera* ecamera2=NULL;\r\n    QString acquisitionSettingsFilename2=\"\", previewSettingsFilename2=\"\";\r\n    QString acquisitionPrefix2=this->prefix2();\r\n    QString TIFFFIlename2=acquisitionPrefix2+\".tif\";\r\n    TIFF* tiff2=NULL;\r\n    int camera2=0;\r\n    if (this->use2()) {\r\n        if(!(useCam2=opticsSetup->lockCamera(1, &extension2, &ecamera2, &camera2, &previewSettingsFilename2))) {\r\n            CAMPARAMSTACK_ERROR(tr(\"error locking camer 2!\\n\"));\r\n        }\r\n    }\r\n    if (QFile::exists(this->currentConfigFilename(1))) acquisitionSettingsFilename2=this->currentConfigFilename(1);\r\n\r\n    if (ok && !useCam1 && !useCam2) {\r\n        CAMPARAMSTACK_ERROR(tr(\"Cannot start image acquisition: No camera selected, or both cameras not usable!\"));\r\n        opticsSetup->unlockLightpath();\r\n        ok=false;\r\n    }\r\n\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // CHECK WHETHER HARDWRAE SUPPORTS CHANGING THE SELECTED PARAMETER\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    int stackParamI=this->stackParameter();\r\n    QFExtensionCamera::CameraSetting stackParam=QFExtensionCamera::CameraSetting(stackParamI);\r\n    if (ok) {\r\n        if (stackParam>=0 && stackParam<=QFExtensionCamera::CamSetMaxParam) {\r\n            if (useCam1 && !ecamera1->isCameraSettingChangable(stackParam)) {\r\n                ok=false;\r\n                CAMPARAMSTACK_ERROR(tr(\"camera 1 does not support changing the %1!\\n\").arg(this->stackParameterName()));\r\n            }\r\n            if (ok && useCam2 && !ecamera2->isCameraSettingChangable(stackParam)) {\r\n                ok=false;\r\n                CAMPARAMSTACK_ERROR(tr(\"camera 2 does not support changing the %1!\\n\").arg(this->stackParameterName()));\r\n            }\r\n        } else {\r\n            ok=false;\r\n            CAMPARAMSTACK_ERROR(tr(\"invalid stack parameter %1 '%2'\\n\").arg(stackParam).arg(this->stackParameterName()));\r\n        }\r\n    }\r\n\r\n\r\n\r\n    if (ok) {\r\n        if (ok && useCam1) log->log_text(tr(\"  - storing files with prefix 1: '%1'\\n\").arg(acquisitionPrefix1));\r\n        if (ok && useCam2) log->log_text(tr(\"  - storing files with prefix 2: '%1'\\n\").arg(acquisitionPrefix2));\r\n\r\n        QProgressListDialog progress(tr(\"Parameter Stack Acquisition\"), tr(\"&Cancel\"), 0, 100, this);\r\n        progress.addItem(tr(\"preparation\"));\r\n        progress.addItem(tr(\"acquisition\"));\r\n        progress.addItem(tr(\"cleanup\"));\r\n        progress.setWindowModality(Qt::WindowModal);\r\n        progress.setValue(0);\r\n        progress.start();\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // SET LIGHTPATH\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        opticsSetup->lockLighpathCombobox();\r\n        QString oldLightpath=opticsSetup->getCurrentLightpathFilename();\r\n        QString oldLightpathName=opticsSetup->getCurrentLightpath();\r\n        QString lightpathName=\"unknown\";\r\n        if (this->lightpathActivated()) {\r\n            if (!QFile::exists(this->lightpathFilename())) {\r\n                CAMPARAMSTACK_ERROR(tr(\"  - acquisition lighpath configuration '%1' does not exist!\\n\").arg(this->lightpath()));\r\n                opticsSetup->unlockLightpath();\r\n                return;\r\n\r\n            } else {\r\n                log->log_text(tr(\"  - setting acquisition lightpath settings '%1' ...\\n\").arg(this->lightpath()));\r\n                opticsSetup->loadLightpathConfig(this->lightpathFilename(), true, &lightpathName);\r\n                log->log_text(tr(\"  - setting acquisition lightpath settings '%1' ... DONE\\n\").arg(this->lightpath()));\r\n            }\r\n        }\r\n\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // switch on light\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        bool formerMainShutterState=opticsSetup->getMainIlluminationShutter();\r\n        if (opticsSetup->isMainIlluminationShutterAvailable()){\r\n            log->log_text(tr(\"  - switch main shutter on!\\n\"));\r\n            opticsSetup->setMainIlluminationShutter(true, true);\r\n        }\r\n\r\n        QList<QVariant> realValues1, realValues2;\r\n        QTime timAcquisition=QTime::currentTime();\r\n        QDateTime timStart;\r\n        double duration=0;\r\n\r\n\r\n        progress.nextItem();\r\n        if (this->previewMode()) {\r\n            log->log_text(tr(\"acquiring stack in PREVIEW MODE ...\\n\"));\r\n\r\n\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            // OPEN OUTPUT TIFF FILES\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            progress.setLabelText(tr(\"opening output files ...\"));\r\n            QApplication::processEvents();\r\n            if (ok && useCam1) {\r\n                QDir().mkpath(QFileInfo(TIFFFIlename1.toLatin1().data()).absolutePath());\r\n                tiff1=TIFFOpen(TIFFFIlename1.toLatin1().data(), \"w\");\r\n                if (!tiff1) {\r\n                    ok=false;\r\n                    CAMPARAMSTACK_ERROR(tr(\"error opening TIFF file (camera 1) '%1'!\").arg(TIFFFIlename1));\r\n                }\r\n            }\r\n            if (ok && useCam2) {\r\n                QDir().mkpath(QFileInfo(TIFFFIlename2.toLatin1().data()).absolutePath());\r\n                tiff2=TIFFOpen(TIFFFIlename2.toLatin1().data(), \"w\");\r\n                if (!tiff2) {\r\n                    ok=false;\r\n                    CAMPARAMSTACK_ERROR(tr(\"error opening TIFF file (camera 2) '%1'!\").arg(TIFFFIlename2));\r\n                }\r\n            }\r\n\r\n\r\n\r\n            if (progress.wasCanceled()) {\r\n                log->log_warning(tr(\"canceled by user!\\n\"));\r\n                ok=false;\r\n            }\r\n\r\n\r\n\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            // CHANGE PARAM, ACQUIRE IMAGE, CHANGE PARAM, ACQUIRE IMAGE, ...\r\n            //    images are stored in TIFF files using libtiff and they are (possibly) downscaled to 16-bit\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            timAcquisition=QTime::currentTime();\r\n            duration=0;\r\n            if (ok) {\r\n                progress.setLabelText(tr(\"acquiring images ...\"));\r\n                bool running=ok;\r\n                //double newPos=stageStart;\r\n                int stackIdx=0;\r\n                int width1=0, height1=0;\r\n                uint32_t* buffer1=NULL;\r\n                int width2=0, height2=0;\r\n                uint32_t* buffer2=NULL;\r\n                int imageCnt=0;\r\n\r\n                measured.append(opticsSetup->getMeasuredValues());\r\n\r\n                while (running && (stackIdx<scanVals.size())) {\r\n\r\n                    if (ok && useCam1) {\r\n\r\n                        //////////////////////////////////////////////////////////////////////////////////////\r\n                        // PREPARE CAMERA 1\r\n                        //////////////////////////////////////////////////////////////////////////////////////\r\n                        if (ok && useCam1) {\r\n                            progress.setLabelText(tr(\"preparing camera 1 ...\"));\r\n                            QApplication::processEvents();\r\n\r\n                            QString tmpName1=QDir::temp().absoluteFilePath(\"qf3spimb040_cam1tmpsettings.ini\");\r\n\r\n                            QFTemporaryFile file1;\r\n                            if (file1.open()) {\r\n                                 tmpName1=file1.fileName();\r\n                            }\r\n                            if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n\r\n                            if (useCam1) QFile::copy(acquisitionSettingsFilename1, tmpName1);\r\n\r\n                            QSettings settings(tmpName1, QSettings::IniFormat);\r\n\r\n                            //QSettings settings(acquisitionSettingsFilename1, QSettings::IniFormat);\r\n\r\n                            ecamera1->changeCameraSetting(settings, stackParam, scanVals[stackIdx]);\r\n                            ecamera1->useCameraSettings(camera1, settings);\r\n                            realValues1.append(ecamera1->getCameraCurrentSetting(camera1, stackParam));\r\n                            //realValues1.append(ecamera1->getExposureTime(camera1));\r\n                            log->log_text(tr(\"  - prepared camer 1!\\n\"));\r\n                            width1=ecamera1->getCameraImageWidth(camera1);\r\n                            height1=ecamera1->getCameraImageHeight(camera1);\r\n                            buffer1=(uint32_t*)qfRealloc(buffer1, width1*height1*sizeof(uint32_t));\r\n                            if (!buffer1) {\r\n                                ok=false;\r\n                                CAMPARAMSTACK_ERROR(tr(\"could not allocate image buffer for camera 1!\\n\"));\r\n                            }\r\n                            if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n                        }\r\n                    }\r\n\r\n                    if (ok && useCam2) {\r\n\r\n                        //////////////////////////////////////////////////////////////////////////////////////\r\n                        // PREPARE CAMERA 1\r\n                        //////////////////////////////////////////////////////////////////////////////////////\r\n                        if (ok && useCam2) {\r\n                            progress.setLabelText(tr(\"preparing camera 2 ...\"));\r\n                            QApplication::processEvents();\r\n                            QString tmpName1=QDir::temp().absoluteFilePath(\"qf3spimb040_cam2tmpsettings.ini\");\r\n\r\n                            QFTemporaryFile file1;\r\n                            if (file1.open()) {\r\n                                 tmpName1=file1.fileName();\r\n                            }\r\n                            if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n\r\n                            if (useCam2) QFile::copy(acquisitionSettingsFilename2, tmpName1);\r\n\r\n                            QSettings settings(tmpName1, QSettings::IniFormat);\r\n\r\n                            ecamera2->changeCameraSetting(settings, stackParam, scanVals[stackIdx]);\r\n                            ecamera2->useCameraSettings(camera2, settings);\r\n                            realValues2.append(ecamera2->getCameraCurrentSetting(camera2, stackParam));\r\n                            //realValues2.append(ecamera2->getExposureTime(camera2));\r\n                            log->log_text(tr(\"  - prepared camer 2!\\n\"));\r\n                            width2=ecamera2->getCameraImageWidth(camera2);\r\n                            height2=ecamera2->getCameraImageHeight(camera2);\r\n                            buffer2=(uint32_t*)qfRealloc(buffer2, width2*height2*sizeof(uint32_t));\r\n                            if (!buffer2) {\r\n                                ok=false;\r\n                                CAMPARAMSTACK_ERROR(tr(\"could not allocate image buffer for camera 2!\\n\"));\r\n                            }\r\n                            if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n                        }\r\n                    }\r\n\r\n                    QApplication::processEvents();\r\n                    if (progress.wasCanceled()) {\r\n                        running=false;\r\n                        log->log_warning(tr(\"  - acquisition canceled by user!\\n\"));\r\n                    } else {\r\n                        for (int img=0; img<this->images(); img++) {\r\n                            log->log_text(tr(\"acquiring images (%1/%2) ...\\n\").arg(imageCnt+1).arg(images));\r\n                            progress.setLabelText(tr(\"acquiring images (%1/%2) ...\").arg(imageCnt+1).arg(images));\r\n                            QApplication::processEvents();\r\n                            if (progress.wasCanceled()) {\r\n                                running=false;\r\n                                log->log_warning(tr(\"  - acquisition canceled by user!\\n\"));\r\n                                break;\r\n                            }\r\n                            if (stackIdx==0) {\r\n                                timAcquisition.start();\r\n                                timStart=QDateTime::currentDateTime();\r\n                            }\r\n                            if (useCam1) {\r\n                                if (ecamera1->acquireOnCamera(camera1, buffer1)) {\r\n                                    TIFFTWriteUint16from32(tiff1, buffer1, width1, height1, false);\r\n                                    TIFFWriteDirectory(tiff1);\r\n                                } else {\r\n                                    ok=false;\r\n                                    CAMPARAMSTACK_ERROR(tr(\"error acquiring image %1/%2 on camera 1!\\n\").arg(imageCnt+1).arg(images));\r\n                                }\r\n                            }\r\n                            //QApplication::processEvents();\r\n                            if (useCam2) {\r\n                                if (ecamera2->acquireOnCamera(camera2, buffer2)) {\r\n                                    TIFFTWriteUint16from32(tiff2, buffer2, width2, height2, false);\r\n                                    TIFFWriteDirectory(tiff2);\r\n                                } else {\r\n                                    ok=false;\r\n                                    CAMPARAMSTACK_ERROR(tr(\"error acquiring image %1/%2 on camera 2!\\n\").arg(imageCnt+1).arg(images));\r\n                                }\r\n                            }\r\n                            imageCnt++;\r\n                        }\r\n                        if (this->saveMeasurements()) measured.append(opticsSetup->getMeasuredValues());\r\n                        //QApplication::processEvents();\r\n                    }\r\n                    if (!ok) running=false;\r\n\r\n                    stackIdx++;\r\n                    progress.setValue((int)round((double)stackIdx/(double)scanVals.size()*100.0));\r\n                    QApplication::processEvents();\r\n                }\r\n                duration=timAcquisition.elapsed()/1000.0;\r\n                if (buffer1) qfFree(buffer1);\r\n                if (buffer2) qfFree(buffer2);\r\n                buffer1=buffer2=NULL;\r\n\r\n            }\r\n        } else {\r\n            log->log_text(tr(\"acquiring stack in ACQUISITION MODE ...\\n\"));\r\n\r\n            if (progress.wasCanceled()) {\r\n                log->log_warning(tr(\"canceled by user!\\n\"));\r\n                ok=false;\r\n            }\r\n            QMap<QString, QVariant> acquisitionDescription1;\r\n            QList<QFExtensionCamera::CameraAcquititonFileDescription> moreFiles1;\r\n            QMap<QString, QVariant> acquisitionDescription2;\r\n            QList<QFExtensionCamera::CameraAcquititonFileDescription> moreFiles2;\r\n\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            // CHANGE PARAM, ACQUIRE IMAGE, CHANGE PARAM, ACQUIRE IMAGE, ...\r\n            //    images are stored in TIFF files using libtiff and they are (possibly) downscaled to 16-bit\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            timAcquisition=QTime::currentTime();\r\n            duration=0;\r\n            if (ok) {\r\n                progress.setLabelText(tr(\"acquiring images ...\"));\r\n                bool running=ok;\r\n                //double newPos=stageStart;\r\n                int stackIdx=0;\r\n                int width1=0, height1=0;\r\n                uint32_t* buffer1=NULL;\r\n                int width2=0, height2=0;\r\n                uint32_t* buffer2=NULL;\r\n                int imageCnt=0;\r\n                int frames=this->images();\r\n\r\n                measured.append(opticsSetup->getMeasuredValues());\r\n\r\n                while (running && (stackIdx<scanVals.size())) {\r\n                    QString tmpName1=QDir::temp().absoluteFilePath(\"qf3spimb040_cam1tmpsettings.ini\");\r\n\r\n                    QFTemporaryFile file1;\r\n                    if (file1.open()) {\r\n                         tmpName1=file1.fileName();\r\n                    }\r\n                    if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n                    if (useCam1) QFile::copy(acquisitionSettingsFilename1, tmpName1);\r\n                    QSettings settings1(tmpName1, QSettings::IniFormat);\r\n                    if (frames>0 && ecamera1->isCameraSettingChangable(QFExtensionCamera::CamSetNumberFrames)) ecamera1->changeCameraSetting(settings1, QFExtensionCamera::CamSetNumberFrames, frames);\r\n                    ecamera1->changeCameraSetting(settings1, stackParam, scanVals[stackIdx]);\r\n\r\n\r\n\r\n\r\n\r\n\r\n                    QString tmpName2=QDir::temp().absoluteFilePath(\"qf3spimb040_cam2tmpsettings.ini\");\r\n\r\n                    QFTemporaryFile file2;\r\n                    if (file2.open()) {\r\n                         tmpName2=file2.fileName();\r\n                    }\r\n                    if (QFile::exists(tmpName2)) QFile::remove(tmpName2);\r\n\r\n                    if (useCam2) QFile::copy(acquisitionSettingsFilename2, tmpName2);\r\n\r\n                    QSettings settings2(tmpName2, QSettings::IniFormat);\r\n\r\n                    if (frames>0 && ecamera2->isCameraSettingChangable(QFExtensionCamera::CamSetNumberFrames)) ecamera2->changeCameraSetting(settings2, QFExtensionCamera::CamSetNumberFrames, frames);\r\n                    ecamera2->changeCameraSetting(settings2, stackParam, scanVals[stackIdx]);\r\n\r\n\r\n\r\n\r\n                    //////////////////////////////////////////////////////////////////////////////////////\r\n                    // acquire image series\r\n                    //////////////////////////////////////////////////////////////////////////////////////\r\n                    ok = acqTools->acquireSeries(lightpathName, QString(\"camstack%1\").arg(stackIdx,4,10,QLatin1Char('0')), tr(\"cam parameter stack\"), useCam1, extension1, ecamera1, camera1, acquisitionPrefix1+QString(\"__sidx%1\").arg(stackIdx,4,10,QLatin1Char('0')), settings1, acquisitionDescription1, moreFiles1, useCam2, extension2, ecamera2, camera2, acquisitionPrefix2+QString(\"__sidx%1\").arg(stackIdx,4,10,QLatin1Char('0')), settings2, acquisitionDescription2, moreFiles2, &measured, &progress, NULL);\r\n                    if (!ok) {\r\n                        if (frames>1) {\r\n                            CAMPARAMSTACK_ERROR(tr(\"error acquiring image (%1...%2)/%3 !\\n\").arg(imageCnt+1).arg(imageCnt+1+frames).arg(images));\r\n                        } else {\r\n                            CAMPARAMSTACK_ERROR(tr(\"error acquiring image %1/%2 !\\n\").arg(imageCnt+1).arg(images));\r\n                        }\r\n                    }\r\n\r\n                    if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n                    if (QFile::exists(tmpName2)) QFile::remove(tmpName2);\r\n\r\n                    if (!ok) running=false;\r\n\r\n                    stackIdx++;\r\n                    imageCnt+=frames;\r\n                    progress.setValue((int)round((double)stackIdx/(double)scanVals.size()*100.0));\r\n                    QApplication::processEvents();\r\n\r\n                    if (progress.wasCanceled()) {\r\n                        running=false;\r\n                        log->log_error(tr(\"CANCELED BY USER!\\n\"));\r\n                    }\r\n                }\r\n                duration=timAcquisition.elapsed()/1000.0;\r\n                if (buffer1) qfFree(buffer1);\r\n                if (buffer2) qfFree(buffer2);\r\n                buffer1=buffer2=NULL;\r\n\r\n            }\r\n        }\r\n        progress.setValue(100);\r\n        measured.append(opticsSetup->getMeasuredValues());\r\n        progress.nextItem();\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // collect lightpath data common to all cameras\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        QMap<QString, QVariant> acquisitionDescription;\r\n        opticsSetup->saveLightpathConfig(acquisitionDescription, \"\", \"lightpath/\");\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // switch on/off light\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (opticsSetup->isMainIlluminationShutterAvailable()){\r\n            log->log_text(tr(\"  - switch main shutter %1!\\n\").arg((formerMainShutterState)?tr(\"on\"):tr(\"off\")));\r\n            opticsSetup->setMainIlluminationShutter(formerMainShutterState, true);\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // RESET LIGHTPATH\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (this->lightpathActivated()) {\r\n            opticsSetup->loadLightpathConfig(oldLightpath, false);\r\n            log->log_text(tr(\"  - resetting to old lightpath settings (%1) ...\\n\").arg(oldLightpath));//Name));\r\n        }\r\n        opticsSetup->unlockLighpathCombobox();\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // close tiff files and free buffers\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        progress.setLabelText(tr(\"closing output files ...\"));\r\n        QApplication::processEvents();\r\n        if (tiff1) TIFFClose(tiff1);\r\n        if (tiff2) TIFFClose(tiff2);\r\n        tiff1=tiff2=NULL;\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // collect acquisition data common to all cameras\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        QString scanCSV;\r\n        if (ok) {\r\n            acquisitionDescription[\"type\"]=\"parameter stack\";\r\n            acquisitionDescription[\"stack_parameter\"]=this->stackParameterName();\r\n            acquisitionDescription[\"stack_mode\"]=this->stackModeName();\r\n            acquisitionDescription[\"stack_start\"]=this->stackStart();\r\n            acquisitionDescription[\"stack_delta\"]=this->stackDelta();\r\n            acquisitionDescription[\"stack_end\"]=this->stackEnd();\r\n            acquisitionDescription[\"sequence_overall_length\"]=images;\r\n            acquisitionDescription[\"images_per_step\"]=this->images();\r\n            acquisitionDescription[\"stack_length\"]=scanVals.size();\r\n            acquisitionDescription[\"start_time\"]=timStart;\r\n            acquisitionDescription[\"duration\"]=duration;\r\n            acquisitionDescription[\"stack_value_count\"]=scanVals.size();\r\n            acquisitionDescription[\"stack_values\"]=CDoubleListToQString(scanVals);\r\n            if (useCam1) acquisitionDescription[\"real_stack_values/camera1\"]=realValues1;\r\n            if (useCam2) acquisitionDescription[\"real_stack_values/camera2\"]=realValues2;\r\n\r\n\r\n\r\n            QTextStream pf(&scanCSV);\r\n            pf<<\"# number,   ideal value\";\r\n            if (useCam1) pf<<\",   real value camera1\";\r\n            if (useCam2) pf<<\",   real value camera2\";\r\n            pf<<\"\\n\";\r\n            for (int i=0; i<qMin(scanVals.size(), qMax(realValues1.size(), realValues2.size())); i++) {\r\n                pf<<i<<\", \"<<CDoubleToQString(scanVals[i]);\r\n                if (useCam1 && i<realValues1.size()) pf<<\", \"<<CDoubleToQString(realValues1[i].toDouble());\r\n                if (useCam2 && i<realValues2.size()) pf<<\", \"<<CDoubleToQString(realValues2[i].toDouble());\r\n                pf<<\"\\n\";\r\n            }\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // write image stack properties to files, also collects camera specific information\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (ok && useCam1) {\r\n            QMap<QString, QVariant> acquisitionDescription1=acquisitionDescription;\r\n            QList<QFExtensionCamera::CameraAcquititonFileDescription> files;\r\n            QFExtensionCamera::CameraAcquititonFileDescription d;\r\n            d.name=TIFFFIlename1;\r\n            d.description=\"image stack from camera 1\";\r\n            d.type=\"TIFF16\";\r\n            files.append(d);\r\n\r\n\r\n            QString ParamValuesFilename=acquisitionPrefix1+\".param.dat\";\r\n            QFile posFile(ParamValuesFilename);\r\n            if (posFile.open(QIODevice::WriteOnly)) {\r\n                posFile.write(scanCSV.toLatin1().data());\r\n                posFile.close();\r\n                d.name=ParamValuesFilename;\r\n                d.description=\"parameter values\";\r\n                d.type=\"CSV\";\r\n                files.append(d);\r\n            } else {\r\n                log->log_error(tr(\"  - could not write parameter values file '%1' for camera 1: %2 ...\").arg(ParamValuesFilename).arg(posFile.errorString()));\r\n            }\r\n\r\n            QString MeasurementsFilename=acqTools->saveMeasuredData(acquisitionPrefix1, measured);\r\n            if (!MeasurementsFilename.isEmpty() && QFile::exists(MeasurementsFilename)) {\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=MeasurementsFilename;\r\n                d.description=\"measureable properties of setup\";\r\n                d.type=\"CSV\";\r\n                files.append(d);\r\n            }\r\n\r\n            log->log_text(tr(\"  - writing acquisition description 1 ...\"));\r\n            acqTools->savePreviewDescription(0, extension1, ecamera1, camera1, acquisitionPrefix1, acquisitionDescription1, files, startDateTime);\r\n            log->log_text(tr(\" DONE!\\n\"));\r\n        }\r\n        if (ok && useCam2) {\r\n            QMap<QString, QVariant> acquisitionDescription2=acquisitionDescription;\r\n            QList<QFExtensionCamera::CameraAcquititonFileDescription> files;\r\n            QFExtensionCamera::CameraAcquititonFileDescription d;\r\n            d.name=TIFFFIlename1;\r\n            d.description=\"image stack from camera 2\";\r\n            d.type=\"TIFF16\";\r\n            files.append(d);\r\n\r\n\r\n            QString ParamValuesFilename=acquisitionPrefix2+\".param.dat\";\r\n            QFile posFile(ParamValuesFilename);\r\n            if (posFile.open(QIODevice::WriteOnly)) {\r\n                posFile.write(scanCSV.toLatin1().data());\r\n                posFile.close();\r\n                d.name=ParamValuesFilename;\r\n                d.description=\"parameter values\";\r\n                d.type=\"CSV\";\r\n                files.append(d);\r\n            } else {\r\n                log->log_error(tr(\"  - could not write parameter values file '%1' for camera 2: %2 ...\").arg(ParamValuesFilename).arg(posFile.errorString()));\r\n            }\r\n\r\n            QString MeasurementsFilename=acqTools->saveMeasuredData(acquisitionPrefix2, measured);\r\n            if (!MeasurementsFilename.isEmpty() && QFile::exists(MeasurementsFilename)) {\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=MeasurementsFilename;\r\n                d.description=\"measureable properties of setup\";\r\n                d.type=\"CSV\";\r\n                files.append(d);\r\n            }\r\n\r\n\r\n            log->log_text(tr(\"  - writing acquisition description 2 ...\"));\r\n            acqTools->savePreviewDescription(1, extension2, ecamera2, camera2, acquisitionPrefix2, acquisitionDescription2, files, startDateTime);\r\n            log->log_text(tr(\" DONE!\\n\"));\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // release cameras\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (useCam1) {\r\n            opticsSetup->releaseCamera(0);\r\n            log->log_text(tr(\"  - released camera 1!\\n\"));\r\n        }\r\n        if (useCam2) {\r\n            opticsSetup->releaseCamera(1);\r\n            log->log_text(tr(\"  - released camera 2!\\n\"));\r\n        }\r\n\r\n        if (ok && useCam1) log->log_text(tr(\"  - stored files with prefix 1: '%1'\\n\").arg(acquisitionPrefix1));\r\n        if (ok && useCam2) log->log_text(tr(\"  - stored files with prefix 2: '%1'\\n\").arg(acquisitionPrefix2));\r\n\r\n        if (ok) log->log_text(tr(\"image stack acquisition DONE!\\n\"));\r\n    }\r\n    opticsSetup->unlockLightpath();\r\n    opticsSetup->ensureLightpath();\r\n}",
    "void QFESPIMB040DeviceParamStackConfigWidget::performStack()\r\n{\r\n\r\n    if (!(use1() || use2())) {\r\n        QMessageBox::critical(this, tr(\"B040SPIM: Parameter Stack Acquisition\"), tr(\"Cannot start image acquisition: No camera selected!\"));\r\n        return;\r\n    }\r\n\r\n    QDateTime startDateTime=QDateTime::currentDateTime();\r\n    QList<QFESPIMB040OpticsSetupBase::measuredValues> measured;\r\n    QList<QFExtensionCamera::CameraAcquititonFileDescription> files1, files2;\r\n    QMap<QString, QVariant> finalAcquisitionDescription1;\r\n    QMap<QString, QVariant> finalAcquisitionDescription2;\r\n\r\n\r\n    bool ok=true;\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // get array of values\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    QList<double> scanVals=stack();\r\n    if (scanVals.isEmpty()) {\r\n        QMessageBox::critical(this, tr(\"B040SPIM: Parameter Stack Acquisition\"), tr(\"No values to scan selected!\"));\r\n        return;\r\n    }\r\n    int images=scanVals.size()*numImages();\r\n\r\n\r\n    log->log_text(tr(\"starting parameter stack acquisition:\\n\"));\r\n    log->log_text(tr(\"  - scan parameter: %1\\n\").arg(stackParameterName()));\r\n    log->log_text(tr(\"  - scan mode: %1\\n\").arg(stackModeName()));\r\n    log->log_text(tr(\"  - scan start: %1\\n\").arg(stackStart()));\r\n    log->log_text(tr(\"  - scan end: %1\\n\").arg(stackEnd()));\r\n    log->log_text(tr(\"  - scan delta: %1\\n\").arg(stackDelta()));\r\n    opticsSetup->lockLightpath();\r\n\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // LOCK/INIT CAMERA 1\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    bool useCam1=false;\r\n    QFExtension* extension1=NULL;\r\n    QFExtensionCamera* ecamera1=NULL;\r\n    int camera1=0;\r\n    QString acquisitionSettingsFilename1=\"\", previewSettingsFilename1=\"\";\r\n    QString acquisitionPrefix1=prefix1();\r\n    QString TIFFFIlename1=acquisitionPrefix1+\".tif\";\r\n    TIFF* tiff1=NULL;\r\n    if (use1()) {\r\n        if (!(useCam1=opticsSetup->lockCamera(0, &extension1, &ecamera1, &camera1, &previewSettingsFilename1))) {\r\n            CAMPARAMSTACK_ERROR(tr(\"error locking camer 1!\\n\"));\r\n        }\r\n    }\r\n    if (QFile::exists(currentConfigFilename(0))) acquisitionSettingsFilename1=currentConfigFilename(0);\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // LOCK/INIT CAMERA 2\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    bool useCam2=false;\r\n    QFExtension* extension2=NULL;\r\n    QFExtensionCamera* ecamera2=NULL;\r\n    QString acquisitionSettingsFilename2=\"\", previewSettingsFilename2=\"\";\r\n    QString acquisitionPrefix2=prefix2();\r\n    QString TIFFFIlename2=acquisitionPrefix2+\".tif\";\r\n    TIFF* tiff2=NULL;\r\n    int camera2=0;\r\n    if (use2()) {\r\n        if(!(useCam2=opticsSetup->lockCamera(1, &extension2, &ecamera2, &camera2, &previewSettingsFilename2))) {\r\n            CAMPARAMSTACK_ERROR(tr(\"error locking camer 2!\\n\"));\r\n        }\r\n    }\r\n    if (QFile::exists(currentConfigFilename(1))) acquisitionSettingsFilename2=currentConfigFilename(1);\r\n\r\n    if (ok && !useCam1 && !useCam2) {\r\n        CAMPARAMSTACK_ERROR(tr(\"Cannot start image acquisition: No camera selected, or both cameras not usable!\"));\r\n        opticsSetup->unlockLightpath();\r\n        ok=false;\r\n    }\r\n\r\n\r\n\r\n\r\n    if (ok) {\r\n        if (ok && useCam1) log->log_text(tr(\"  - storing files with prefix 1: '%1'\\n\").arg(acquisitionPrefix1));\r\n        if (ok && useCam2) log->log_text(tr(\"  - storing files with prefix 2: '%1'\\n\").arg(acquisitionPrefix2));\r\n\r\n        QProgressListDialog progress(tr(\"Parameter Stack Acquisition\"), tr(\"&Cancel\"), 0, 100, this);\r\n        progress.addItem(tr(\"preparation\"));\r\n        progress.addItem(tr(\"acquisition\"));\r\n        progress.addItem(tr(\"cleanup\"));\r\n        progress.setWindowModality(Qt::WindowModal);\r\n        progress.setValue(0);\r\n        progress.start();\r\n        progress.show();\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // SET LIGHTPATH\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        QString oldLightpath=opticsSetup->getCurrentLightpathFilename();\r\n        QString oldLightpathName=opticsSetup->getCurrentLightpath();\r\n        QString lightpathName=\"unknown\";\r\n        if (lightpathActivated()) {\r\n            if (!QFile::exists(lightpathFilename())) {\r\n                CAMPARAMSTACK_ERROR(tr(\"  - acquisition lighpath configuration '%1' does not exist!\\n\").arg(lightpath()));\r\n                opticsSetup->unlockLightpath();\r\n                return;\r\n\r\n            } else {\r\n                log->log_text(tr(\"  - setting acquisition lightpath settings '%1' ...\\n\").arg(lightpath()));\r\n                opticsSetup->loadLightpathConfig(lightpathFilename(), true, &lightpathName);\r\n                log->log_text(tr(\"  - setting acquisition lightpath settings '%1' ... DONE\\n\").arg(lightpath()));\r\n            }\r\n        }\r\n\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // switch on light\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        bool formerMainShutterState=opticsSetup->getMainIlluminationShutter();\r\n        if (opticsSetup->isMainIlluminationShutterAvailable()){\r\n            log->log_text(tr(\"  - switch main shutter on!\\n\"));\r\n            opticsSetup->setMainIlluminationShutter(true, true);\r\n        }\r\n\r\n        QList<QVariant> realValues;\r\n        QTime timAcquisition=QTime::currentTime();\r\n        QDateTime timStart;\r\n        double duration=0;\r\n        int stackParam=ui->cmbParameter->currentIndex();\r\n\r\n\r\n        progress.nextItem();\r\n        if (previewMode()) {\r\n            log->log_text(tr(\"acquiring stack in PREVIEW MODE ...\\n\"));\r\n\r\n\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            // OPEN OUTPUT TIFF FILES\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            progress.setLabelText(tr(\"opening output files ...\"));\r\n            QApplication::processEvents();\r\n            if (ok && useCam1) {\r\n                QDir().mkpath(QFileInfo(TIFFFIlename1.toLatin1().data()).absolutePath());\r\n                tiff1=TIFFOpen(TIFFFIlename1.toLatin1().data(), \"w\");\r\n                if (!tiff1) {\r\n                    ok=false;\r\n                    CAMPARAMSTACK_ERROR(tr(\"error opening TIFF file (camera 1) '%1'!\").arg(TIFFFIlename1));\r\n                }\r\n            }\r\n            if (ok && useCam2) {\r\n                QDir().mkpath(QFileInfo(TIFFFIlename2.toLatin1().data()).absolutePath());\r\n                tiff2=TIFFOpen(TIFFFIlename2.toLatin1().data(), \"w\");\r\n                if (!tiff2) {\r\n                    ok=false;\r\n                    CAMPARAMSTACK_ERROR(tr(\"error opening TIFF file (camera 2) '%1'!\").arg(TIFFFIlename2));\r\n                }\r\n            }\r\n\r\n\r\n\r\n            if (progress.wasCanceled()) {\r\n                log->log_warning(tr(\"canceled by user!\\n\"));\r\n                ok=false;\r\n            }\r\n\r\n\r\n\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            // CHANGE PARAM, ACQUIRE IMAGE, CHANGE PARAM, ACQUIRE IMAGE, ...\r\n            //    images are stored in TIFF files using libtiff and they are (possibly) downscaled to 16-bit\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            timAcquisition=QTime::currentTime();\r\n            duration=0;\r\n            if (ok) {\r\n                progress.setLabelText(tr(\"acquiring images ...\"));\r\n                bool running=ok;\r\n                //double newPos=stageStart;\r\n                int stackIdx=0;\r\n                int width1=0, height1=0;\r\n                uint32_t* buffer1=NULL;\r\n                int width2=0, height2=0;\r\n                uint32_t* buffer2=NULL;\r\n                int imageCnt=0;\r\n\r\n                measured.append(opticsSetup->getMeasuredValues());\r\n\r\n                while (running && (stackIdx<scanVals.size())) {\r\n\r\n                    //////////////////////////////////////////////////////////////////////////////////////\r\n                    // set device parameter and poosibly wait the set delay\r\n                    //////////////////////////////////////////////////////////////////////////////////////\r\n                    if (ok) {\r\n                        setDeviceParameter(stackParam, scanVals[stackIdx]);\r\n                        if (ui->spinDelay->value()>0) {\r\n                            QTime tDelay=QTime::currentTime();\r\n                            while (double(tDelay.elapsed())<ui->spinDelay->value()) {\r\n                                QApplication::processEvents();\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (ok && useCam1) {\r\n\r\n                        //////////////////////////////////////////////////////////////////////////////////////\r\n                        // PREPARE CAMERA 1\r\n                        //////////////////////////////////////////////////////////////////////////////////////\r\n                        if (ok && useCam1) {\r\n                            progress.setLabelText(tr(\"preparing camera 1 ...\"));\r\n                            QApplication::processEvents();\r\n\r\n                            QString tmpName1=QDir::temp().absoluteFilePath(\"qf3spimb040_cam1tmpsettings.ini\");\r\n\r\n                            QFTemporaryFile file1;\r\n                            if (file1.open()) {\r\n                                 tmpName1=file1.fileName();\r\n                            }\r\n                            if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n\r\n                            if (useCam1) QFile::copy(acquisitionSettingsFilename1, tmpName1);\r\n\r\n                            QSettings settings(tmpName1, QSettings::IniFormat);\r\n\r\n                            ecamera1->useCameraSettings(camera1, settings);\r\n                            log->log_text(tr(\"  - prepared camera 1!\\n\"));\r\n                            width1=ecamera1->getCameraImageWidth(camera1);\r\n                            height1=ecamera1->getCameraImageHeight(camera1);\r\n                            buffer1=(uint32_t*)qfRealloc(buffer1, width1*height1*sizeof(uint32_t));\r\n                            if (!buffer1) {\r\n                                ok=false;\r\n                                CAMPARAMSTACK_ERROR(tr(\"could not allocate image buffer for camera 1!\\n\"));\r\n                            }\r\n                            if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n                        }\r\n                    }\r\n\r\n                    if (ok && useCam2) {\r\n\r\n                        //////////////////////////////////////////////////////////////////////////////////////\r\n                        // PREPARE CAMERA 1\r\n                        //////////////////////////////////////////////////////////////////////////////////////\r\n                        if (ok && useCam2) {\r\n                            progress.setLabelText(tr(\"preparing camera 2 ...\"));\r\n                            QApplication::processEvents();\r\n                            QString tmpName1=QDir::temp().absoluteFilePath(\"qf3spimb040_cam2tmpsettings.ini\");\r\n\r\n                            QFTemporaryFile file1;\r\n                            if (file1.open()) {\r\n                                 tmpName1=file1.fileName();\r\n                            }\r\n                            if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n\r\n                            if (useCam2) QFile::copy(acquisitionSettingsFilename2, tmpName1);\r\n\r\n                            QSettings settings(tmpName1, QSettings::IniFormat);\r\n\r\n                            ecamera2->useCameraSettings(camera2, settings);\r\n                            log->log_text(tr(\"  - prepared camera 2!\\n\"));\r\n                            width2=ecamera2->getCameraImageWidth(camera2);\r\n                            height2=ecamera2->getCameraImageHeight(camera2);\r\n                            buffer2=(uint32_t*)qfRealloc(buffer2, width2*height2*sizeof(uint32_t));\r\n                            if (!buffer2) {\r\n                                ok=false;\r\n                                CAMPARAMSTACK_ERROR(tr(\"could not allocate image buffer for camera 2!\\n\"));\r\n                            }\r\n                            if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n                        }\r\n                    }\r\n\r\n                    QApplication::processEvents();\r\n                    if (progress.wasCanceled()) {\r\n                        running=false;\r\n                        log->log_warning(tr(\"  - acquisition canceled by user!\\n\"));\r\n                    } else {\r\n                        for (int img=0; img<numImages(); img++) {\r\n                            log->log_text(tr(\"acquiring images (%1/%2) ...\\n\").arg(imageCnt+1).arg(images));\r\n                            progress.setLabelText(tr(\"acquiring images (%1/%2) ...\").arg(imageCnt+1).arg(images));\r\n                            QApplication::processEvents();\r\n                            if (progress.wasCanceled()) {\r\n                                running=false;\r\n                                log->log_warning(tr(\"  - acquisition canceled by user!\\n\"));\r\n                                break;\r\n                            }\r\n                            if (stackIdx==0) {\r\n                                timAcquisition.start();\r\n                                timStart=QDateTime::currentDateTime();\r\n                            }\r\n                            if (useCam1) {\r\n                                if (ecamera1->acquireOnCamera(camera1, buffer1)) {\r\n                                    TIFFTWriteUint16from32(tiff1, buffer1, width1, height1, false);\r\n                                    TIFFWriteDirectory(tiff1);\r\n                                } else {\r\n                                    ok=false;\r\n                                    CAMPARAMSTACK_ERROR(tr(\"error acquiring image %1/%2 on camera 1!\\n\").arg(imageCnt+1).arg(images));\r\n                                }\r\n                            }\r\n                            //QApplication::processEvents();\r\n                            if (useCam2) {\r\n                                if (ecamera2->acquireOnCamera(camera2, buffer2)) {\r\n                                    TIFFTWriteUint16from32(tiff2, buffer2, width2, height2, false);\r\n                                    TIFFWriteDirectory(tiff2);\r\n                                } else {\r\n                                    ok=false;\r\n                                    CAMPARAMSTACK_ERROR(tr(\"error acquiring image %1/%2 on camera 2!\\n\").arg(imageCnt+1).arg(images));\r\n                                }\r\n                            }\r\n                            realValues.append(getDeviceParameter(stackParam));\r\n                            imageCnt++;\r\n                        }\r\n                        if (saveMeasurements()) measured.append(opticsSetup->getMeasuredValues());\r\n                        //QApplication::processEvents();\r\n                    }\r\n                    if (!ok) running=false;\r\n\r\n                    stackIdx++;\r\n                    progress.setValue((int)round((double)stackIdx/(double)scanVals.size()*100.0));\r\n                    QApplication::processEvents();\r\n                }\r\n                duration=timAcquisition.elapsed()/1000.0;\r\n                if (buffer1) qfFree(buffer1);\r\n                if (buffer2) qfFree(buffer2);\r\n                buffer1=buffer2=NULL;\r\n\r\n            }\r\n\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            // close tiff files and free buffers\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            progress.setLabelText(tr(\"closing output files ...\"));\r\n            QApplication::processEvents();\r\n            if (tiff1) TIFFClose(tiff1);\r\n            if (tiff2) TIFFClose(tiff2);\r\n            tiff1=tiff2=NULL;\r\n        } else {\r\n            log->log_text(tr(\"acquiring stack in ACQUISITION MODE ...\\n\"));\r\n\r\n            if (progress.wasCanceled()) {\r\n                log->log_warning(tr(\"canceled by user!\\n\"));\r\n                ok=false;\r\n            }\r\n            QList<QFExtensionCamera::CameraAcquititonFileDescription> moreFiles1;\r\n            QMap<QString, QVariant> acquisitionDescription1;\r\n            QMap<QString, QVariant> acquisitionDescription2;\r\n            QList<QFExtensionCamera::CameraAcquititonFileDescription> moreFiles2;\r\n\r\n\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            // CHANGE PARAM, ACQUIRE IMAGE, CHANGE PARAM, ACQUIRE IMAGE, ...\r\n            //    images are stored in TIFF files using libtiff and they are (possibly) downscaled to 16-bit\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            timAcquisition=QTime::currentTime();\r\n            duration=0;\r\n            if (ok) {\r\n                progress.setLabelText(tr(\"acquiring images ...\"));\r\n                bool running=ok;\r\n                //double newPos=stageStart;\r\n                int stackIdx=0;\r\n                int width1=0, height1=0;\r\n                uint32_t* buffer1=NULL;\r\n                int width2=0, height2=0;\r\n                uint32_t* buffer2=NULL;\r\n                int imageCnt=0;\r\n                int frames=numImages();\r\n                QMap<QFExtensionCamera::CameraSetting, QVariant> camset1, camset2;\r\n                QMap<QString, QVariant> camsetstr1, camsetstr2;\r\n                camset1[QFExtensionCamera::CamSetNumberFrames]=frames;\r\n                camset2[QFExtensionCamera::CamSetNumberFrames]=frames;\r\n\r\n                measured.append(opticsSetup->getMeasuredValues());\r\n\r\n                while (running && (stackIdx<scanVals.size())) {\r\n                    log->log_text(tr(\"  - setting device parameter to %1 ... \").arg(scanVals[stackIdx]));\r\n                    progress.setLabelText(tr(\"  - setting device parameter to %1 ... \").arg(scanVals[stackIdx]));\r\n                    //qDebug()<<tr(\"  - setting device parameter to %1 ... \").arg(scanVals[stackIdx]);\r\n                    //////////////////////////////////////////////////////////////////////////////////////\r\n                    // set device parameter and poosibly wait the set delay\r\n                    //////////////////////////////////////////////////////////////////////////////////////\r\n                    setDeviceParameter(stackParam, scanVals[stackIdx]);\r\n                    if (ui->spinDelay->value()>0) {\r\n                        log->log_text(tr(\"waiting ... \"));\r\n                        //qDebug()<<tr(\"  - waiting\");\r\n                        QTime tDelay=QTime::currentTime();\r\n                        while (double(tDelay.elapsed())<ui->spinDelay->value()) {\r\n                            QApplication::processEvents();\r\n                        }\r\n                    }\r\n                    log->log_text(tr(\"DONE!\\n\"));\r\n                    log->log_text(tr(\"  - acquiring image series\\n\"));\r\n                    //qDebug()<<tr(\"  - acquiring image series\");\r\n                    progress.setLabelText(tr(\"acquiring image series ...\"));\r\n                    //////////////////////////////////////////////////////////////////////////////////////\r\n                    // acquire image series\r\n                    //////////////////////////////////////////////////////////////////////////////////////\r\n                    if (useCam1) QDir().mkpath(QFileInfo(acquisitionPrefix1+QString(\"__sidx%1.txt\").arg(stackIdx,4,10,QLatin1Char('0'))).absolutePath());\r\n                    if (useCam2) QDir().mkpath(QFileInfo(acquisitionPrefix2+QString(\"__sidx%1.txt\").arg(stackIdx,4,10,QLatin1Char('0'))).absolutePath());\r\n                    ok = acqTools->acquireSeries(lightpathName, QString(\"paramstack%1\").arg(stackIdx,4,10,QLatin1Char('0')), tr(\"device parameter stack\"), useCam1, extension1, ecamera1, camera1, acquisitionPrefix1+QString(\"__sidx%1\").arg(stackIdx,4,10,QLatin1Char('0')), acquisitionSettingsFilename1, acquisitionDescription1, moreFiles1, useCam2, extension2, ecamera2, camera2, acquisitionPrefix2+QString(\"__sidx%1\").arg(stackIdx,4,10,QLatin1Char('0')), acquisitionSettingsFilename2, acquisitionDescription2, moreFiles2, camset1, camset2, camsetstr1, camsetstr2, &measured, &progress, NULL);\r\n                    if (!ok) {\r\n                        if (frames>1) {\r\n                            CAMPARAMSTACK_ERROR(tr(\"error acquiring image (%1...%2)/%3 !\\n\").arg(imageCnt+1).arg(imageCnt+1+frames).arg(images));\r\n                        } else {\r\n                            CAMPARAMSTACK_ERROR(tr(\"error acquiring image %1/%2 !\\n\").arg(imageCnt+1).arg(images));\r\n                        }\r\n                    }\r\n                    realValues.append(getDeviceParameter(stackParam));\r\n\r\n                    if (!ok) running=false;\r\n\r\n                    stackIdx++;\r\n                    imageCnt+=frames;\r\n                    progress.setValue((int)round((double)stackIdx/(double)scanVals.size()*100.0));\r\n                    QApplication::processEvents();\r\n                    if (progress.wasCanceled()) {\r\n                        running=false;\r\n                        log->log_error(tr(\"CANCELED BY USER!\\n\"));\r\n                    }\r\n                }\r\n                duration=timAcquisition.elapsed()/1000.0;\r\n                if (buffer1) qfFree(buffer1);\r\n                if (buffer2) qfFree(buffer2);\r\n                buffer1=buffer2=NULL;\r\n\r\n            }\r\n\r\n            /*QMapIterator<QString, QVariant> it1(acquisitionDescription1), it2(acquisitionDescription2);\r\n            while (it1.hasNext()) {\r\n                it1.next();\r\n                finalAcquisitionDescription1[\"cam1/\"+it1.key()]=it1.value();\r\n                finalAcquisitionDescription1[\"cam1/\"+it1.key()]=it1.value();\r\n            }\r\n            while (it2.hasNext()) {\r\n                it1.next();\r\n                finalAcquisitionDescription2[\"cam2/\"+it1.key()]=it1.value();\r\n                finalAcquisitionDescription2[\"cam2/\"+it1.key()]=it1.value();\r\n            }*/\r\n            finalAcquisitionDescription1.unite(acquisitionDescription1);\r\n            finalAcquisitionDescription2.unite(acquisitionDescription2);\r\n\r\n            files1.append(moreFiles1);\r\n            files2.append(moreFiles2);\r\n        }\r\n        progress.setValue(100);\r\n        measured.append(opticsSetup->getMeasuredValues());\r\n        progress.nextItem();\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // collect lightpath data common to all cameras\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        opticsSetup->saveLightpathConfig(finalAcquisitionDescription1, \"\", \"lightpath/\");\r\n        opticsSetup->saveLightpathConfig(finalAcquisitionDescription2, \"\", \"lightpath/\");\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // switch on/off light\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (opticsSetup->isMainIlluminationShutterAvailable()){\r\n            log->log_text(tr(\"  - switch main shutter %1!\\n\").arg((formerMainShutterState)?tr(\"on\"):tr(\"off\")));\r\n            opticsSetup->setMainIlluminationShutter(formerMainShutterState, true);\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // RESET LIGHTPATH\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (lightpathActivated()) {\r\n            opticsSetup->loadLightpathConfig(oldLightpath, false);\r\n            log->log_text(tr(\"  - resetting to old lightpath settings (%1) ...\\n\").arg(oldLightpath));//Name));\r\n        }\r\n\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // collect acquisition data common to all cameras\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        QString scanCSV;\r\n        if (ok) {\r\n            finalAcquisitionDescription1[\"type\"]=\"parameter stack\";\r\n            finalAcquisitionDescription1[\"stack_parameter\"]=stackParameterName();\r\n            finalAcquisitionDescription1[\"stack_mode\"]=stackModeName();\r\n            finalAcquisitionDescription1[\"stack_start\"]=stackStart();\r\n            finalAcquisitionDescription1[\"stack_delta\"]=stackDelta();\r\n            finalAcquisitionDescription1[\"stack_end\"]=stackEnd();\r\n            finalAcquisitionDescription1[\"sequence_overall_length\"]=images;\r\n            finalAcquisitionDescription1[\"images_per_step\"]=numImages();\r\n            finalAcquisitionDescription1[\"stack_length\"]=scanVals.size();\r\n            finalAcquisitionDescription1[\"start_time\"]=timStart;\r\n            finalAcquisitionDescription1[\"duration\"]=duration;\r\n            finalAcquisitionDescription1[\"stack_value_count\"]=scanVals.size();\r\n            finalAcquisitionDescription1[\"stack_values\"]=CDoubleListToQString(scanVals);\r\n            finalAcquisitionDescription1[\"real_stack_values\"]=realValues;\r\n\r\n\r\n            finalAcquisitionDescription2[\"type\"]=\"parameter stack\";\r\n            finalAcquisitionDescription2[\"stack_parameter\"]=stackParameterName();\r\n            finalAcquisitionDescription2[\"stack_mode\"]=stackModeName();\r\n            finalAcquisitionDescription2[\"stack_start\"]=stackStart();\r\n            finalAcquisitionDescription2[\"stack_delta\"]=stackDelta();\r\n            finalAcquisitionDescription2[\"stack_end\"]=stackEnd();\r\n            finalAcquisitionDescription2[\"sequence_overall_length\"]=images;\r\n            finalAcquisitionDescription2[\"images_per_step\"]=numImages();\r\n            finalAcquisitionDescription2[\"stack_length\"]=scanVals.size();\r\n            finalAcquisitionDescription2[\"start_time\"]=timStart;\r\n            finalAcquisitionDescription2[\"duration\"]=duration;\r\n            finalAcquisitionDescription2[\"stack_value_count\"]=scanVals.size();\r\n            finalAcquisitionDescription2[\"stack_values\"]=CDoubleListToQString(scanVals);\r\n            finalAcquisitionDescription2[\"real_stack_values\"]=realValues;\r\n\r\n\r\n\r\n            QTextStream pf(&scanCSV);\r\n            pf<<\"# number,   ideal value,   real value\\n\";\r\n            for (int i=0; i<qMin(scanVals.size(), realValues.size()); i++) {\r\n                pf<<i<<\", \"<<CDoubleToQString(scanVals[i]);\r\n                if (i<realValues.size()) pf<<\", \"<<CDoubleToQString(realValues[i].toDouble());\r\n                pf<<\"\\n\";\r\n            }\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // write image stack properties to files, also collects camera specific information\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (ok && useCam1) {\r\n            QMap<QString, QVariant> acquisitionDescription1=finalAcquisitionDescription1;\r\n            QFExtensionCamera::CameraAcquititonFileDescription d;\r\n            d.name=TIFFFIlename1;\r\n            d.description=\"image stack from camera 1\";\r\n            d.type=\"TIFF16\";\r\n            files1.append(d);\r\n\r\n\r\n            QString ParamValuesFilename=acquisitionPrefix1+\".param.dat\";\r\n            QFile posFile(ParamValuesFilename);\r\n            if (posFile.open(QIODevice::WriteOnly)) {\r\n                posFile.write(scanCSV.toLatin1().data());\r\n                posFile.close();\r\n                d.name=ParamValuesFilename;\r\n                d.description=\"parameter values\";\r\n                d.type=\"CSV\";\r\n                files1.append(d);\r\n            } else {\r\n                log->log_error(tr(\"  - could not write parameter values file '%1' for camera 1: %2 ...\").arg(ParamValuesFilename).arg(posFile.errorString()));\r\n            }\r\n\r\n            QString MeasurementsFilename=acqTools->saveMeasuredData(acquisitionPrefix1, measured);\r\n            if (!MeasurementsFilename.isEmpty() && QFile::exists(MeasurementsFilename)) {\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=MeasurementsFilename;\r\n                d.description=\"measureable properties of setup\";\r\n                d.type=\"CSV\";\r\n                files1.append(d);\r\n            }\r\n\r\n            log->log_text(tr(\"  - writing acquisition description 1 ...\"));\r\n            acqTools->savePreviewDescription(0, extension1, ecamera1, camera1, acquisitionPrefix1, acquisitionDescription1, files1, startDateTime);\r\n            log->log_text(tr(\" DONE!\\n\"));\r\n        }\r\n        if (ok && useCam2) {\r\n            QMap<QString, QVariant> acquisitionDescription2=finalAcquisitionDescription2;\r\n\r\n            QFExtensionCamera::CameraAcquititonFileDescription d;\r\n            d.name=TIFFFIlename1;\r\n            d.description=\"image stack from camera 2\";\r\n            d.type=\"TIFF16\";\r\n            files2.append(d);\r\n\r\n\r\n            QString ParamValuesFilename=acquisitionPrefix2+\".param.dat\";\r\n            QFile posFile(ParamValuesFilename);\r\n            if (posFile.open(QIODevice::WriteOnly)) {\r\n                posFile.write(scanCSV.toLatin1().data());\r\n                posFile.close();\r\n                d.name=ParamValuesFilename;\r\n                d.description=\"parameter values\";\r\n                d.type=\"CSV\";\r\n                files2.append(d);\r\n            } else {\r\n                log->log_error(tr(\"  - could not write parameter values file '%1' for camera 2: %2 ...\").arg(ParamValuesFilename).arg(posFile.errorString()));\r\n            }\r\n\r\n            QString MeasurementsFilename=acqTools->saveMeasuredData(acquisitionPrefix2, measured);\r\n            if (!MeasurementsFilename.isEmpty() && QFile::exists(MeasurementsFilename)) {\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=MeasurementsFilename;\r\n                d.description=\"measureable properties of setup\";\r\n                d.type=\"CSV\";\r\n                files2.append(d);\r\n            }\r\n\r\n\r\n            log->log_text(tr(\"  - writing acquisition description 2 ...\"));\r\n            acqTools->savePreviewDescription(1, extension2, ecamera2, camera2, acquisitionPrefix2, acquisitionDescription2, files2, startDateTime);\r\n            log->log_text(tr(\" DONE!\\n\"));\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // release cameras\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (useCam1) {\r\n            opticsSetup->releaseCamera(0);\r\n            log->log_text(tr(\"  - released camera 1!\\n\"));\r\n        }\r\n        if (useCam2) {\r\n            opticsSetup->releaseCamera(1);\r\n            log->log_text(tr(\"  - released camera 2!\\n\"));\r\n        }\r\n\r\n        if (ok && useCam1) log->log_text(tr(\"  - stored files with prefix 1: '%1'\\n\").arg(acquisitionPrefix1));\r\n        if (ok && useCam2) log->log_text(tr(\"  - stored files with prefix 2: '%1'\\n\").arg(acquisitionPrefix2));\r\n\r\n        if (ok) log->log_text(tr(\"image stack acquisition DONE!\\n\"));\r\n    }\r\n    opticsSetup->unlockLightpath();\r\n    opticsSetup->ensureLightpath();\r\n}",
    "void QFRDRNumberAndBrightnessProcessingJobThread::run() {\r\n    QTime ptime;\r\n\r\n    ptime.start();\r\n\r\n    emit messageChanged(tr(\"loading data ...\"));\r\n    if ((job.fileFormat<0)||(job.fileFormat>=getImageReaderCount(pluginservices))) {\r\n        m_status=-1;\r\n        emit statusChanged(m_status);\r\n        emit messageChanged(tr(\"file format not supported or given ... format given was: %1\").arg(job.fileFormat));\r\n        emit rangeChanged(0,100);\r\n        emit progressChanged(0);\r\n    } else if (!QFile::exists(job.filename)) {\r\n        m_status=-1;\r\n        emit statusChanged(m_status);\r\n        emit messageChanged(tr(\"file does not exist ...\"));\r\n        emit rangeChanged(0,100);\r\n        emit progressChanged(0);\r\n    } else {\r\n        m_status=1;\r\n        emit statusChanged(m_status);\r\n        emit rangeChanged(0,3780+1000*job.DCCFDeltaX.size());\r\n\r\n\r\n        reader=NULL;\r\n        bool OK=false;\r\n        if (job.fileFormat>=0 && job.fileFormat<getImageReaderCount(pluginservices)) {\r\n            reader=getImageReader(job.fileFormat, pluginservices);\r\n        }\r\n        if (reader) {\r\n            emit messageChanged(tr(\"opening %1 file ...\").arg(reader->formatName()));\r\n            OK=reader->open(job.filename);\r\n            if (!OK) {\r\n                m_status=-1; emit statusChanged(m_status);\r\n                if (reader) messageChanged(tr(\"error opening file '%1': %2\").arg(job.filename).arg(reader->lastError()));\r\n                else emit messageChanged(tr(\"error opening file '%1'\").arg(job.filename));\r\n            } else {\r\n                emit progressIncrement(10);\r\n                emit messageChanged(tr(\"counting frames ...\"));\r\n                props=reader->getFileInfo().properties;\r\n                comment=reader->getFileInfo().comment;\r\n                reader->setBinning(job.binning);\r\n                reader->setInterleavedBinning(job.interleaved_binning);\r\n                reader->setAverageBinning(job.binAverage);\r\n                if (job.use_cropping) {\r\n                    reader->setCropping(job.crop_x0, job.crop_x1, job.crop_y0, job.crop_y1);\r\n                } else {\r\n                    reader->unsetCropping();\r\n                }\r\n                first_frame=0;\r\n                int32_t frame_count=reader->countFrames();\r\n                if (job.range_min>0 && job.range_min<frame_count) first_frame=job.range_min;\r\n                frames=frame_count-first_frame;\r\n                if (job.range_max>(int64_t)first_frame && job.range_max<frame_count) frames=job.range_max-first_frame;\r\n                double input_length=frames*job.frameTime;\r\n                if (frames>0) {\r\n                    frame_width=reader->frameWidth();\r\n                    frame_height=reader->frameHeight();\r\n                    average_frame=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    sqrsum_frame=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    average_uncorrected_frame=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    sqrsum_uncorrected_frame=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n\r\n                    baseline=job.backgroundOffset;\r\n\r\n                    acf_tau=NULL;\r\n                    acf=NULL;\r\n                    acf_std=NULL;\r\n                    acf_segments=NULL;\r\n                    acf_N=0;\r\n                    ccf_tau=NULL;\r\n                    ccf1=NULL;\r\n                    ccf2=NULL;\r\n                    ccf3=NULL;\r\n                    ccf4=NULL;\r\n                    ccf1_std=NULL;\r\n                    ccf2_std=NULL;\r\n                    ccf3_std=NULL;\r\n                    ccf4_std=NULL;\r\n                    ccf1_segments=NULL;\r\n                    ccf2_segments=NULL;\r\n                    ccf3_segments=NULL;\r\n                    ccf4_segments=NULL;\r\n                    ccf_N=0;\r\n                    //dccf_tau=NULL;\r\n                    //dccf=NULL;\r\n                    //dccf_segments=NULL;\r\n                    //dccf_std=NULL;\r\n                    //dccf_N=0;\r\n                    //dccfframe_width=0;\r\n                    //dccfframe_height=0;\r\n                    dccf.clear();\r\n                    for (int id=0; id<job.DCCFDeltaX.size(); id++) {\r\n                        DCCFRecord rec;\r\n                        rec.dccf_tau=NULL;\r\n                        rec.dccf=NULL;\r\n                        rec.dccf_segments=NULL;\r\n                        rec.dccf_std=NULL;\r\n                        rec.dccf_N=0;\r\n                        rec.dccfframe_width=0;\r\n                        rec.dccfframe_height=0;\r\n                        dccf.append(rec);\r\n                    }\r\n                    lastFrames=NULL;\r\n                    firstFrames=NULL;\r\n                    bleachAmplitude=NULL;\r\n                    bleachTime=NULL;\r\n                    bleachPoly2=NULL;\r\n                    bleachPoly3=NULL;\r\n                    fit_frames=NULL;\r\n                    fit_t=NULL;\r\n                    NFitFrames=0;\r\n\r\n                    video_count=floor(frames/job.video_frames);\r\n                    real_video_count=video_count;\r\n                    video=(float*)qfCalloc(frame_width*frame_height*video_count, sizeof(float));\r\n                    video_uncorrected=(float*)qfCalloc(frame_width*frame_height*video_count, sizeof(float));\r\n                    bleachAmplitude=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachTime=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachAmplitude2=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachTime2=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachPoly2=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachPoly3=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachPoly4=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachPoly5=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachFitOK=(uint8_t*)qfCalloc(frame_width*frame_height, sizeof(uint8_t));\r\n                    //firstFrames=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    //lastFrames=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n\r\n                    ////////////////////////////////////////////////////////////////////////////////////////////\r\n                    // CREATE FILENAMES FOR RESULTS AND MAKE SURE THE DIRECTORY FOR THE FILES EXISTS (mkpath() )\r\n                    ////////////////////////////////////////////////////////////////////////////////////////////\r\n                    QDir d=QFileInfo(job.filename).dir();\r\n\r\n                    if (mutexFilename) mutexFilename->lock();\r\n                    int counter=-1;\r\n                    do {\r\n                        outputFilenameBase=d.absoluteFilePath(replacePostfixSpecials(job.prefix)+QFileInfo(job.filename).completeBaseName()+replacePostfixSpecials(job.postfix, counter));\r\n                        counter++;\r\n                    } while (QFile::exists(outputFilenameBase+\".evalsettings.txt\"));\r\n                    //qDebug()<<outputFilenameBase;\r\n                    QString configFilename=outputFilenameBase+\".evalsettings.txt\";\r\n                    QString averageFilename=\"\";\r\n                    QString stdFilename=\"\";\r\n                    QString averageUncorrectedFilename=\"\";\r\n                    QString stdUncorrectedFilename=\"\";\r\n                    QString backstdFilename=\"\";\r\n                    QString averageFilenameF=\"\";\r\n                    QString backgroundFilename=\"\";\r\n                    QString videoFilename=\"\";\r\n                    QString videoUncorrectedFilename=\"\";\r\n                    QString statisticsFilename=\"\";\r\n                    QString statisticsFilename_dv1=\"\";\r\n                    QString statisticsFilename_dv2=\"\";\r\n                    QString uncorrectedStatisticsFilename=\"\";\r\n                    QString uncorrectedStatisticsFilename_dv1=\"\";\r\n                    QString uncorrectedStatisticsFilename_dv2=\"\";\r\n                    QString backstatisticsFilename=\"\";\r\n                    QString backstatisticsFilename_dv1=\"\";\r\n                    QString backstatisticsFilename_dv2=\"\";\r\n                    QString acfFilename=\"\";\r\n                    QString ccfFilename=\"\";\r\n                    QStringList dccfFilename;\r\n                    QString acfFilenameBin=\"\";\r\n                    QString ccfFilenameBin=\"\";\r\n                    QStringList dccfFilenameBin;\r\n                    QString bleachAmplitudeFilename=\"\";\r\n                    QString bleachTimeFilename=\"\";\r\n                    QString bleachAmplitude2Filename=\"\";\r\n                    QString bleachTime2Filename=\"\";\r\n                    QString bleachFitSuccessFilename=\"\";\r\n                    QString bleachPoly2Filename=\"\";\r\n                    QString bleachPoly3Filename=\"\";\r\n                    QString bleachPoly4Filename=\"\";\r\n                    QString bleachPoly5Filename=\"\";\r\n                    QString firstFramesFilename=\"\";\r\n                    QString lastFramesFilename=\"\";\r\n                    QString bleachtimesFilename=\"\";\r\n                    QString bleachframesFilename=\"\";\r\n                    QString localFileDirectory=QFileInfo(d.absoluteFilePath(configFilename)).dir().absolutePath();\r\n\r\n                    if (d.mkpath(localFileDirectory)) {\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n                        // TOUCH OUTPUT FILE (.evalsettings.txt)\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n                        touchFile(configFilename);\r\n\r\n                        if (mutexFilename) mutexFilename->unlock();\r\n\r\n\r\n\r\n\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n                        // RUN THE CORRELATION\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n                        if (job.correlator==CORRELATOR_MTAUALLMON || job.correlator==CORRELATOR_MTAUONEMON) {\r\n                            correlate_loadsingle();\r\n                        } else {\r\n                            correlate_loadall();\r\n                        }\r\n                        reader->close();\r\n\r\n\r\n\r\n\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n                        // SAVE THE RESULTS\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n                        //************** SAVE OVERVIEW IMAGE\r\n                        if ((m_status==1) && !was_canceled && average_frame) {\r\n                            emit messageChanged(tr(\"saving overview image ...\"));\r\n                            QString localFilename=averageFilename=outputFilenameBase+\".overview.tif\";\r\n                            QString error=\"\";\r\n                            if (!SaveTIFFUInt16_scaled(localFilename, average_frame, frame_width, frame_height, tr(\"UInt16 overview image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                averageFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n\r\n                            localFilename=averageFilenameF=outputFilenameBase+\".overview_float.tif\";\r\n                            if (!SaveTIFFFloat(localFilename, average_frame, frame_width, frame_height, tr(\"float overview image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                averageFilenameF=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(5);\r\n\r\n                        //************** SAVE OVERVIEWSTD IMAGE\r\n                        if ((m_status==1) && !was_canceled && sqrsum_frame) {\r\n                            emit messageChanged(tr(\"saving overview stddev image ...\"));\r\n                            QString localFilename=stdFilename=outputFilenameBase+\".overviewstd.tif\";\r\n\r\n                            QString error=\"\";\r\n                            if (!SaveSDTIFF(localFilename, average_frame, sqrsum_frame, frame_width, frame_height, frames, tr(\"stddev overview image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                stdFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n                        }\r\n                        emit progressIncrement(5);\r\n\r\n                        //************** SAVE UNCORRECTED OVERVIEW IMAGE\r\n                        if ((m_status==1) && !was_canceled && average_uncorrected_frame) {\r\n                            emit messageChanged(tr(\"saving uncorrected overview image ...\"));\r\n                            QString localFilename=averageUncorrectedFilename=outputFilenameBase+\".overview_uncorrected.tif\";\r\n\r\n                            QString error=\"\";\r\n                            if (!SaveTIFFFloat(localFilename, average_uncorrected_frame, frame_width, frame_height, tr(\"uncorrected overview image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                averageUncorrectedFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(5);\r\n\r\n                        //************** SAVE UNCORRECTED OVERVIEWSTD IMAGE\r\n                        if ((m_status==1) && !was_canceled && sqrsum_uncorrected_frame && average_uncorrected_frame) {\r\n                            emit messageChanged(tr(\"saving uncorrected overview stddev image ...\"));\r\n                            QString localFilename=stdUncorrectedFilename=outputFilenameBase+\".overviewstd_uncorrected.tif\";\r\n\r\n                            QString error=\"\";\r\n                            if (!SaveSDTIFF(localFilename, average_uncorrected_frame, sqrsum_uncorrected_frame, frame_width, frame_height, frames, tr(\"uncorrected overview stddev image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                stdUncorrectedFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n                        }\r\n                        emit progressIncrement(5);\r\n\r\n                        //************** SAVE BACKGROUND IMAGE\r\n                        if ((m_status==1) && !was_canceled && backgroundImage) {\r\n                            bool doSave=false;\r\n                            for (uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                if (backgroundImage[i]!=0) {\r\n                                    doSave=true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (doSave) {\r\n                                emit messageChanged(tr(\"saving background image ...\"));\r\n                                QString localFilename=backgroundFilename=outputFilenameBase+\".background.tif\";\r\n\r\n                                QString error=\"\";\r\n                                if (!SaveTIFFFloat(localFilename, backgroundImage, frame_width, frame_height, tr(\"background image\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    backgroundFilename=\"\";\r\n                                    emit messageChanged(error);\r\n                                }\r\n\r\n                            }\r\n\r\n                        }\r\n                        //************** SAVE BACKGROUND STDDEV IMAGE\r\n                        if ((m_status==1) && !was_canceled && backgroundImageStd) {\r\n                            bool doSave=false;\r\n                            for (uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                if (backgroundImageStd[i]!=0) {\r\n                                    doSave=true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (doSave) {\r\n                                emit messageChanged(tr(\"saving background S.D. image ...\"));\r\n                                QString localFilename=backstdFilename=outputFilenameBase+\".backgroundstd.tif\";\r\n\r\n                                QString error=\"\";\r\n                                if (!SaveTIFFFloat(localFilename, backgroundImageStd, frame_width, frame_height, tr(\"background S.D. image\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    backstdFilename=\"\";\r\n                                    emit messageChanged(error);\r\n                                }\r\n                            }\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n\r\n                        //************** SAVE BLEACHING PARAMETERS IMAGE\r\n                        if ((m_status==1) && !was_canceled ) {\r\n                            if (job.bleach==BLEACH_EXP || job.bleach==BLEACH_EXP_POLY2 || job.bleach==BLEACH_EXP_POLY3  || job.bleach==BLEACH_EXP_POLY4 || job.bleach==BLEACH_EXP_POLY5  || job.bleach==BLEACH_DBL_EXP || job.bleach==BLEACH_EXPREG) {\r\n                                emit messageChanged(tr(\"saving bleach parameter images ...\"));\r\n                                QString localFilename;\r\n                                TIFF* tif;\r\n                                bool error=false;\r\n\r\n                                localFilename=bleachAmplitudeFilename=outputFilenameBase+\".bleachamplitude.tif\";\r\n                                tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteFloat(tif, bleachAmplitude, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                localFilename=bleachTimeFilename=outputFilenameBase+\".bleachtime.tif\";\r\n                                tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteFloat(tif, bleachTime, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                if (job.bleach==BLEACH_DBL_EXP) {\r\n                                    localFilename=bleachAmplitude2Filename=outputFilenameBase+\".bleachamplitude2.tif\";\r\n                                    tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachAmplitude2, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n\r\n                                    localFilename=bleachTime2Filename=outputFilenameBase+\".bleachtime2.tif\";\r\n                                    tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachTime2, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n\r\n                                }\r\n\r\n                                if (job.bleach==BLEACH_EXP_POLY2||job.bleach==BLEACH_EXP_POLY3||job.bleach==BLEACH_EXP_POLY4||job.bleach==BLEACH_EXP_POLY5 ) {\r\n                                    localFilename=bleachPoly2Filename=outputFilenameBase+\".bleachpoly2.tif\";\r\n                                    tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachPoly2, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n\r\n                                }\r\n                                if (job.bleach==BLEACH_EXP_POLY3||job.bleach==BLEACH_EXP_POLY4||job.bleach==BLEACH_EXP_POLY5 ) {\r\n                                    localFilename=bleachPoly3Filename=outputFilenameBase+\".bleachpoly3.tif\";\r\n                                    tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachPoly3, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n                                }\r\n                                if (job.bleach==BLEACH_EXP_POLY4||job.bleach==BLEACH_EXP_POLY5 ) {\r\n                                    localFilename=bleachPoly4Filename=outputFilenameBase+\".bleachpoly4.tif\";\r\n                                    tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachPoly4, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n                                }\r\n                                if (job.bleach==BLEACH_EXP_POLY5 ) {\r\n                                    localFilename=bleachPoly5Filename=outputFilenameBase+\".bleachpoly5.tif\";\r\n                                    tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachPoly5, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n                                }\r\n                                localFilename=bleachFitSuccessFilename=outputFilenameBase+\".bleachfitok.tif\";\r\n                                tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteUint8(tif, bleachFitOK, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                localFilename=firstFramesFilename=outputFilenameBase+\".firstframes.tif\";\r\n                                tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteFloat(tif, firstFrames, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                localFilename=lastFramesFilename=outputFilenameBase+\".lastframes.tif\";\r\n                                tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteFloat(tif, lastFrames, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                if (NFitFrames>0 && fit_t) {\r\n                                    localFilename=bleachtimesFilename=outputFilenameBase+\".bleachfittimes.txt\";\r\n                                    {\r\n                                        QFile f(localFilename);\r\n                                        if (f.open(QIODevice::WriteOnly|QIODevice::Text)) {\r\n                                            QTextStream text(&f);\r\n                                            text.setLocale(outLocale);\r\n                                            for (int i=0; i<NFitFrames; i++) {\r\n                                                text<<fit_t[i]<<\"\\n\";\r\n                                            }\r\n                                            f.close();\r\n                                        } else {\r\n                                            error=true;\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                if (NFitFrames>0 && fit_frames) {\r\n                                    localFilename=bleachframesFilename=outputFilenameBase+\".bleachfitframes.tif\";\r\n                                    tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                    if (tif) {\r\n                                        for (int i=0; i<NFitFrames; i++) {\r\n                                            TIFFTWriteFloat(tif, &(fit_frames[i*frame_width*frame_height]), frame_width, frame_height);\r\n                                            TIFFWriteDirectory(tif);\r\n                                        }\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n                                }\r\n\r\n\r\n                                if (error) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    backgroundFilename=\"\";\r\n                                    emit messageChanged(tr(\"could not create background image '%1'!\").arg(localFilename));\r\n                                }\r\n                            }\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n                        double videoAvgMin=0;\r\n                        double videoAvgMax=(float)0xFFFF;\r\n                        //************** SAVE VIDEO\r\n                        if ((m_status==1) && !was_canceled && video && real_video_count>0 ) {\r\n                            emit messageChanged(tr(\"saving video ...\"));\r\n                            QString localFilename=videoFilename=outputFilenameBase+\".video.tif\";\r\n                            TinyTIFFFile* tif=TinyTIFFWriter_open(localFilename.toAscii().data(), 16, frame_width, frame_height);\r\n                            //TIFF* tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                            if (tif) {\r\n                                float avgMin=video[0];\r\n                                float avgMax=video[0];\r\n                                for (register uint32_t i=0; i<frame_width*frame_height*video_count; i++) {\r\n                                    avgMin=(video[i]<avgMin)?video[i]:avgMin;\r\n                                    avgMax=(video[i]>avgMax)?video[i]:avgMax;\r\n                                }\r\n                                uint16_t* img=(uint16_t*)qfMalloc(frame_width*frame_height*sizeof(uint16_t));\r\n                                for (register uint32_t c=0; c<real_video_count; c++) {\r\n                                    for (register uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                        img[i]=(uint16_t)round((float)(video[c*frame_width*frame_height+i]-avgMin)*(float)0xFFFF/fabs(avgMax-avgMin));\r\n                                    }\r\n                                    TinyTIFFWriter_writeImage(tif, img);\r\n                                    if (real_video_count/10>0) {\r\n                                        if (c%(real_video_count/10)==0) {\r\n                                            emit messageChanged(tr(\"saving video %1/%2...\").arg(c+1).arg(video_count));\r\n                                            progressIncrement(10);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if (real_video_count/10<=0) progressIncrement(100);\r\n                                qfFree(img);\r\n                                TinyTIFFWriter_close(tif);\r\n                                videoAvgMin = avgMin;\r\n                                videoAvgMax = avgMax;\r\n                            } else {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create video '%1'!\").arg(localFilename));\r\n                            }\r\n\r\n                        } else emit progressIncrement(100);\r\n\r\n                        double videoUncorrectedAvgMin=0;\r\n                        double videoUncorrectedAvgMax=(float)0xFFFF;\r\n                        //************** SAVE VIDEO\r\n                        if ((m_status==1) && !was_canceled && video_uncorrected && real_video_count>0 ) {\r\n                            emit messageChanged(tr(\"saving uncorrected video ...\"));\r\n                            QString localFilename=videoUncorrectedFilename=outputFilenameBase+\".videouncorr.tif\";\r\n                            TinyTIFFFile* tif=TinyTIFFWriter_open(localFilename.toAscii().data(), 16, frame_width, frame_height);\r\n                            //TIFF* tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                            if (tif) {\r\n                                float avgMin=video_uncorrected[0];\r\n                                float avgMax=video_uncorrected[0];\r\n                                for (register uint32_t i=0; i<frame_width*frame_height*video_count; i++) {\r\n                                    avgMin=(video_uncorrected[i]<avgMin)?video_uncorrected[i]:avgMin;\r\n                                    avgMax=(video_uncorrected[i]>avgMax)?video_uncorrected[i]:avgMax;\r\n                                }\r\n                                uint16_t* img=(uint16_t*)qfMalloc(frame_width*frame_height*sizeof(uint16_t));\r\n                                for (register uint32_t c=0; c<real_video_count; c++) {\r\n                                    for (register uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                        img[i]=(uint16_t)round((float)(video_uncorrected[c*frame_width*frame_height+i]-avgMin)*(float)0xFFFF/fabs(avgMax-avgMin));\r\n                                    }\r\n                                    TinyTIFFWriter_writeImage(tif, img);\r\n                                    if (real_video_count/10>0) {\r\n                                        if (c%(real_video_count/10)==0) {\r\n                                            emit messageChanged(tr(\"saving uncorrected video %1/%2...\").arg(c+1).arg(video_count));\r\n                                            progressIncrement(10);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if (real_video_count/10<=0) progressIncrement(100);\r\n                                qfFree(img);\r\n                                TinyTIFFWriter_close(tif);\r\n                                videoUncorrectedAvgMin = avgMin;\r\n                                videoUncorrectedAvgMax = avgMax;\r\n                            } else {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create uncorrected video '%1'!\").arg(localFilename));\r\n                            }\r\n\r\n                        } else emit progressIncrement(100);\r\n\r\n                        //************** SAVE STATISTICS\r\n                        if ((m_status==1) && !was_canceled && job.statistics) {\r\n                            QString error=\"\";\r\n                            emit messageChanged(tr(\"saving statistics ...\"));\r\n                            if (!saveStatistics(statisticsFilename=outputFilenameBase+\".statistics.dat\", outputFilenameBase+\".statistics.plt\", statistics, tr(\"Corrected Statistics\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create statistics file %1!\").arg(error));\r\n                            }\r\n\r\n                            emit messageChanged(tr(\"saving background statistics ...\"));\r\n                            if (!saveStatistics(backstatisticsFilename=outputFilenameBase+\".backstatistics.dat\", outputFilenameBase+\".backstatistics.plt\", backstatistics, tr(\"Background Statistics\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create backgrond statistics file %1!\").arg(error));\r\n                            }\r\n\r\n                            emit messageChanged(tr(\"saving uncorrected statistics ...\"));\r\n                            if (!saveStatistics(uncorrectedStatisticsFilename=outputFilenameBase+\".uncorrstatistics.dat\", outputFilenameBase+\".uncorrstatistics.plt\", statistics_uncorrected, tr(\"Uncorrected Statistics\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create uncorrected statistics file %1!\").arg(error));\r\n                            }\r\n\r\n                            if (job.dualViewMode!=0) {\r\n                                emit messageChanged(tr(\"saving DV 1 statistics ...\"));\r\n                                if (!saveStatistics(statisticsFilename_dv1=outputFilenameBase+\".statistics_dv1.dat\", outputFilenameBase+\".statistics_dv1.plt\", dv_statistics[0], tr(\"Corrected Statistics, DV 1\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 1 statistics file %1!\").arg(error));\r\n                                }\r\n                                emit messageChanged(tr(\"saving DV 2 statistics ...\"));\r\n                                if (!saveStatistics(statisticsFilename_dv2=outputFilenameBase+\".statistics_dv2.dat\", outputFilenameBase+\".statistics_dv2.plt\", dv_statistics[1], tr(\"Corrected Statistics, DV 2\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 2 statistics file %1!\").arg(error));\r\n                                }\r\n\r\n\r\n                                emit messageChanged(tr(\"saving DV 1 background statistics ...\"));\r\n                                if (!saveStatistics(backstatisticsFilename_dv1=outputFilenameBase+\".backstatistics_dv1.dat\", outputFilenameBase+\".backstatistics_dv1.plt\", dv_backstatistics[0], tr(\"Background Statistics, DV 1\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 1 background statistics file %1!\").arg(error));\r\n                                }\r\n                                emit messageChanged(tr(\"saving DV 2 background statistics ...\"));\r\n                                if (!saveStatistics(backstatisticsFilename_dv2=outputFilenameBase+\".backstatistics_dv2.dat\", outputFilenameBase+\".backstatistics_dv2.plt\", dv_backstatistics[1], tr(\"Background Statistics, DV 2\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 2 background statistics file %1!\").arg(error));\r\n                                }\r\n\r\n\r\n                                emit messageChanged(tr(\"saving DV 1 uncorrected statistics ...\"));\r\n                                if (!saveStatistics(uncorrectedStatisticsFilename_dv1=outputFilenameBase+\".uncorrstatistics_dv1.dat\", outputFilenameBase+\".uncorrstatistics_dv1.plt\", dv_statistics_uncorrected[0], tr(\"Background Statistics, DV 1\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 1 uncorrected statistics file %1!\").arg(error));\r\n                                }\r\n                                emit messageChanged(tr(\"saving DV 2 uncorrected statistics ...\"));\r\n                                if (!saveStatistics(uncorrectedStatisticsFilename_dv2=outputFilenameBase+\".uncorrstatistics_dv2.dat\", outputFilenameBase+\".uncorrstatistics_dv2.plt\", dv_statistics_uncorrected[1], tr(\"Background Statistics, DV 2\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 2 uncorrected statistics file %1!\").arg(error));\r\n                                }\r\n\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n\r\n\r\n                        //************** SAVE SETTINGS\r\n                        if ((m_status==1) && !was_canceled) {\r\n                            emit messageChanged(tr(\"saving settings ...\"));\r\n                            QString& localFilename=configFilename;\r\n                            QFile f(localFilename);\r\n                            QDir d=QFileInfo(localFilename).absoluteDir();\r\n                            if (f.open(QIODevice::WriteOnly|QIODevice::Text)) {\r\n                                QTextStream text(&f);\r\n                                text.setLocale(outLocale);\r\n\r\n                                text<<\"date/time                   : \"<<QDateTime::currentDateTime().toString(\"yyyy/MM/dd hh:mm:ss\") << \"\\n\";\r\n                                text<<\"input file                  : \"<<d.relativeFilePath(job.filename) << \"\\n\";\r\n                                if (!job.descriptionFilename.isEmpty()) text<<\"input description file      : \" << d.relativeFilePath(job.descriptionFilename) << \"\\n\";\r\n                                if (!averageFilename.isEmpty())         text<<\"overview image file         : \" << d.relativeFilePath(averageFilename) << \"\\n\";\r\n                                if (!averageFilenameF.isEmpty())        text<<\"overview image file real    : \" << d.relativeFilePath(averageFilenameF) << \"\\n\";\r\n                                if (!stdFilename.isEmpty())             text<<\"overview std image          : \" << d.relativeFilePath(stdFilename) << \"\\n\";\r\n                                if (!backgroundFilename.isEmpty())      text<<\"background image file       : \" << d.relativeFilePath(backgroundFilename) << \"\\n\";\r\n                                if (!backstdFilename.isEmpty())         text<<\"background stddev           : \" << d.relativeFilePath(backstdFilename) << \"\\n\";\r\n                                if (!averageUncorrectedFilename.isEmpty())         text<<\"uncorr. overview image file : \" << d.relativeFilePath(averageUncorrectedFilename) << \"\\n\";\r\n                                if (!stdUncorrectedFilename.isEmpty())             text<<\"uncorr. overview std image  : \" << d.relativeFilePath(stdUncorrectedFilename) << \"\\n\";\r\n                                if (!videoFilename.isEmpty())           text<<\"video file                  : \" << d.relativeFilePath(videoFilename) << \"\\n\";\r\n                                if (!videoUncorrectedFilename.isEmpty())text<<\"uncorrected video file      : \" << d.relativeFilePath(videoUncorrectedFilename) << \"\\n\";\r\n                                if (!statisticsFilename.isEmpty())      text<<\"statistics file             : \" << d.relativeFilePath(statisticsFilename) << \"\\n\";\r\n                                if (!backstatisticsFilename.isEmpty())         text<<\"background statistics file  : \" << d.relativeFilePath(backstatisticsFilename) << \"\\n\";\r\n                                if (!uncorrectedStatisticsFilename.isEmpty())  text<<\"uncorrected statistics file : \" << d.relativeFilePath(uncorrectedStatisticsFilename) << \"\\n\";\r\n\r\n                                if (!statisticsFilename_dv1.isEmpty())      text<<\"statistics file DV1         : \" << d.relativeFilePath(statisticsFilename_dv1) << \"\\n\";\r\n                                if (!backstatisticsFilename_dv1.isEmpty())         text<<\"background statistics file DV1 : \" << d.relativeFilePath(backstatisticsFilename_dv1) << \"\\n\";\r\n                                if (!uncorrectedStatisticsFilename_dv1.isEmpty())  text<<\"uncorrected statistics file DV1 : \" << d.relativeFilePath(uncorrectedStatisticsFilename_dv1) << \"\\n\";\r\n                                if (!statisticsFilename_dv2.isEmpty())      text<<\"statistics file DV2         : \" << d.relativeFilePath(statisticsFilename_dv2) << \"\\n\";\r\n                                if (!backstatisticsFilename_dv2.isEmpty())         text<<\"background statistics file DV2 : \" << d.relativeFilePath(backstatisticsFilename_dv2) << \"\\n\";\r\n                                if (!uncorrectedStatisticsFilename_dv2.isEmpty())  text<<\"uncorrected statistics file DV2 : \" << d.relativeFilePath(uncorrectedStatisticsFilename_dv2) << \"\\n\";\r\n\r\n                                if (!acfFilename.isEmpty())             text<<\"autocorrelation file        : \" << d.relativeFilePath(acfFilename) << \"\\n\";\r\n                                if (!acfFilenameBin.isEmpty())          text<<\"bin. autocorrelation file   : \" << d.relativeFilePath(acfFilenameBin) << \"\\n\";\r\n                                if (!ccfFilename.isEmpty())             text<<\"crosscorrelation file       : \" << d.relativeFilePath(ccfFilename) << \"\\n\";\r\n                                if (!ccfFilenameBin.isEmpty())          text<<\"bin. crosscorrelation file  : \" << d.relativeFilePath(ccfFilenameBin) << \"\\n\";\r\n                                for (int id=0; id<qMax(dccfFilename.size(), dccfFilenameBin.size()); id++) {\r\n                                    if (id<dccfFilename.size())            text<<QString(\"distance ccf file %1        : \").arg(id) << d.relativeFilePath(dccfFilename[id]) << \"\\n\";\r\n                                    if (id<dccfFilenameBin.size())         text<<QString(\"bin. distance ccf file %1   : \").arg(id) << d.relativeFilePath(dccfFilenameBin[id]) << \"\\n\";\r\n                                }\r\n                                text<<\"width                       : \"<<outLocale.toString(frame_width) << \"\\n\";\r\n                                text<<\"height                      : \"<<outLocale.toString(frame_height) << \"\\n\";\r\n                                if (job.cameraSettingsGiven) {\r\n                                    text<<\"pixel width                 : \"<<outLocale.toString(job.cameraPixelWidth) << \"\\n\";\r\n                                    text<<\"pixel height                : \"<<outLocale.toString(job.cameraPixelHeight) << \"\\n\";\r\n                                }\r\n                                text<<\"frametime (ms)              : \"<<job.frameTime*1.0e3 << \"\\n\";\r\n                                text<<\"frametime (s)               : \"<<job.frameTime << \"\\n\";\r\n                                text<<\"dualview mode               : \"<<job.dualViewMode << \"\\n\";\r\n                                text<<\"binning                     : \"<<outLocale.toString(reader->getBinning()) << \"\\n\";\r\n                                text<<\"interleaved binning         : \"<< QString((reader->getInterleavedBinning())?\"true\":\"false\") << \"\\n\";\r\n                                text<<\"averaging binning           : \"<< QString((reader->getAverageBinning())?\"true\":\"false\") << \"\\n\";\r\n                                if (reader->getUseCropping()) {\r\n                                    text<<\"crop x0                     : \"<<outLocale.toString(reader->getCropX0()) << \"\\n\";\r\n                                    text<<\"crop x1                     : \"<<outLocale.toString(reader->getCropX1()) << \"\\n\";\r\n                                    text<<\"crop y0                     : \"<<outLocale.toString(reader->getCropY0()) << \"\\n\";\r\n                                    text<<\"crop y1                     : \"<<outLocale.toString(reader->getCropY1()) << \"\\n\";\r\n                                }\r\n                                text<<\"frame count in file         : \"<<outLocale.toString(frame_count) << \"\\n\";\r\n                                text<<\"frame count                 : \"<<outLocale.toString(frames) << \"\\n\";\r\n                                text<<\"first frame                 : \"<<outLocale.toString(first_frame) << \"\\n\";\r\n                                text<<\"last frame                  : \"<<outLocale.toString(first_frame+frames-1) << \"\\n\";\r\n                                text<<\"correlation segments        : \"<<outLocale.toString(double(frames)/double(job.segments)*job.frameTime) << \"\\n\";\r\n                                text<<\"segments length (s)         : \"<<outLocale.toString(job.segments) << \"\\n\";\r\n                                text<<\"correlator S                : \"<<outLocale.toString(job.S) << \"\\n\";\r\n                                text<<\"correlator m                : \"<<outLocale.toString(job.m) << \"\\n\";\r\n                                text<<\"correlator P                : \"<<outLocale.toString(job.P) << \"\\n\";\r\n                                text<<\"correlator type             : \"<<outLocale.toString(job.correlator) << \"\\n\";\r\n                                text<<\"correlator type name        : \";\r\n                                switch(job.correlator) {\r\n                                    case CORRELATOR_DIRECT:      text<<\"direct\\n\"; break;\r\n                                    case CORRELATOR_DIRECTAVG:   text<<\"direct with averaging\\n\"; break;\r\n                                    case CORRELATOR_DIRECT_INT:    text<<\"direct, integer\\n\"; break;\r\n                                    case CORRELATOR_DIRECTAVG_INT: text<<\"direct with averaging, integer\\n\"; break;\r\n                                    case CORRELATOR_MTAUALLMON:  text<<\"multi-tau with monitors for all channels\\n\"; break;\r\n                                    case CORRELATOR_MTAUONEMON:  text<<\"multi-tau with a single monitor\\n\"; break;\r\n                                    case CORRELATOR_CORRELATORFROMSHAREDLIB:  text<<\"multi-tau from shared library\\n\"; break;\r\n\r\n                                    default: text<<\"correlator type name        : unknown\\n\"; break;\r\n                                }\r\n                                text<<\"smallest tau [s]            : \"<<outLocale.toString(job.frameTime) << \"\\n\";\r\n                                text<<\"baseline                    : \"<<outLocale.toString(baseline) << \"\\n\";\r\n                                if (video && job.video) {\r\n                                    text<<\"video sum up                : \"<<outLocale.toString(job.video_frames) << \"\\n\";\r\n                                    text<<\"video frames                : \"<<outLocale.toString(real_video_count) << \"\\n\";\r\n                                    text<<\"video avgMin                : \"<<outLocale.toString(videoAvgMin) << \"\\n\";\r\n                                    text<<\"video avgMax                : \"<<outLocale.toString(videoAvgMax) << \"\\n\";\r\n                                    text<<\"video uncorrected avgMin    : \"<<outLocale.toString(videoUncorrectedAvgMin) << \"\\n\";\r\n                                    text<<\"video uncorrected avgMax    : \"<<outLocale.toString(videoUncorrectedAvgMax) << \"\\n\";\r\n                                }\r\n                                if (job.statistics) {\r\n                                    text<<\"statistics over             : \"<<outLocale.toString(job.statistics_frames) << \"\\n\";\r\n                                }\r\n                                if (job.distanceCCF) {\r\n                                    for (int id=0; id<job.DCCFDeltaX.size(); id++) {\r\n                                        text<<QString(\"DCCF %1 role                   : \").arg(id)<<job.DCCFrole[id] << \"\\n\";\r\n                                        text<<QString(\"DCCF %1 Delta x                : \").arg(id)<<outLocale.toString(job.DCCFDeltaX[id]) << \"\\n\";\r\n                                        text<<QString(\"DCCF %1 Delta y                : \").arg(id)<<outLocale.toString(job.DCCFDeltaY[id]) << \"\\n\";\r\n                                        text<<QString(\"DCCF %1 frame width            : \").arg(id)<<outLocale.toString(dccf[id].dccfframe_width) << \"\\n\";\r\n                                        text<<QString(\"DCCF %1 frame height           : \").arg(id)<<outLocale.toString(dccf[id].dccfframe_height) << \"\\n\";\r\n                                    }\r\n\r\n                                }\r\n                                text<<\"bleach correction           : \";\r\n                                if (job.bleach==BLEACH_EXP) {\r\n                                    text<<\"remove mono-exponential f(t)=A*exp(-t/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                    text<<\"bleach correction           : \";\r\n                                } else if (job.bleach==BLEACH_EXP_POLY2 ) {\r\n                                    text<<\"remove mono-exponential(polynomial) f(t)=A*exp(-(t+f2*t^2)/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor file : \"<<d.relativeFilePath(bleachPoly2Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 3 file : \"<<d.relativeFilePath(bleachPoly3Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_EXP_POLY3) {\r\n                                    text<<\"remove mono-exponential(polynomial) f(t)=A*exp(-(t+f2*t^2+f3*t^3)/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor file : \"<<d.relativeFilePath(bleachPoly2Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 3 file : \"<<d.relativeFilePath(bleachPoly3Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_EXP_POLY4) {\r\n                                    text<<\"remove mono-exponential(polynomial) f(t)=A*exp(-(t+f*t^2+f3*t^3+f4*t^4)/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor file : \"<<d.relativeFilePath(bleachPoly2Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 3 file : \"<<d.relativeFilePath(bleachPoly3Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 4 file : \"<<d.relativeFilePath(bleachPoly4Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_EXP_POLY5) {\r\n                                    text<<\"remove mono-exponential(polynomial) f(t)=A*exp(-(t+f*t^2+f3*t^3+f4*t^4+f5*t^5)/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor file : \"<<d.relativeFilePath(bleachPoly2Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 3 file : \"<<d.relativeFilePath(bleachPoly3Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 4 file : \"<<d.relativeFilePath(bleachPoly4Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 5 file : \"<<d.relativeFilePath(bleachPoly5Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_DBL_EXP) {\r\n                                    text<<\"remove double-exponential f(t)=A*exp(-t/tau)+A2*exp(-t/tau2) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach amplitude 2 file       : \"<<d.relativeFilePath(bleachAmplitude2Filename) << \"\\n\";\r\n                                    text<<\"bleach time 2 file            : \"<<d.relativeFilePath(bleachTime2Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_EXPREG) {\r\n                                    text<<\"remove mono-exponential f(t)=A*exp(-t/tau) using linear regression\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                }  else if (job.bleach==BLEACH_NONE) {\r\n                                        text<<\"remove frame average\\n\";\r\n                                        text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n\r\n                                } else {\r\n                                    text<<\"none\\n\";\r\n                                }\r\n                                text<<\"duration [s]                : \"<<ptime.elapsed()/1000.0 << \"\\n\";\r\n\r\n                                f.close();\r\n                            } else {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create settings file '%1': %2!\").arg(localFilename).arg(f.errorString()));\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n\r\n                        //************** SAVE ACF\r\n                        if ((m_status==1) && !was_canceled && job.acf && acf && acf_tau && acf_N>0) {\r\n                            QString localFilename=acfFilename=outputFilenameBase+\".autocorrelation.dat\";\r\n                            QString localFilename1=acfFilenameBin=outputFilenameBase+\".autocorrelation.bin\";\r\n\r\n                            emit messageChanged(tr(\"saving autocorrelation ...\"));\r\n                            double* ccf[1]={acf};\r\n                            double* ccferr[1]={acf_std};\r\n                            double* ccfsegments[1]={acf_segments};\r\n                            QString error;\r\n                            //qDebug()<<\"acf = \"<<acf<<\"  acf_std = \"<<acf_std;\r\n                            if (!saveCorrelationCSV(localFilename, acf_tau, ccf, ccferr, 1, acf_N, frame_width, frame_height, input_length, error,125, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create autocorrelation file '%1': %2!\").arg(localFilename).arg(error));\r\n                            }\r\n                            if (!saveCorrelationBIN(localFilename1, acf_tau, ccf, ccferr, 1, acf_N, frame_width, frame_height, ccfsegments, error,125, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create binary autocorrelation file '%1': %2!\").arg(localFilename1).arg(error));\r\n                            }\r\n                            if (job.addFCCSSeparately && job.dualViewMode!=0) {\r\n                                if (QFile::exists(localFilename1)) {\r\n                                    addFiles.append(getFileInfo(localFilename1, configFilename, \"ACF0\", 0, getGroupName()));\r\n                                    addFiles.append(getFileInfo(localFilename1, configFilename, \"ACF1\", 1, getGroupName()));\r\n                                } else {\r\n                                    addFiles.append(getFileInfo(localFilename, configFilename, \"ACF0\", 0, getGroupName()));\r\n                                    addFiles.append(getFileInfo(localFilename, configFilename, \"ACF1\", 1, getGroupName()));\r\n                                }\r\n                            } else {\r\n                                if (QFile::exists(localFilename1)) addFiles.append(getFileInfo(localFilename1, configFilename, \"ACF\", getGroupName()));\r\n                                else addFiles.append(getFileInfo(localFilename, configFilename, \"ACF\", getGroupName()));\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(250);\r\n\r\n\r\n                        //************** SAVE DCCF\r\n                        if ((m_status==1) && !was_canceled && job.distanceCCF) {\r\n                            for (int id=0; id<job.DCCFDeltaX.size(); id++) {\r\n                                if (dccf[id].dccf && dccf[id].dccf_tau && dccf[id].dccf_N>0) {\r\n                                    QString localFilename=outputFilenameBase+QString(\".dccf%1.dat\").arg(id,3,10,QLatin1Char('0'));\r\n                                    QString localFilename1=outputFilenameBase+QString(\".dccf%1.bin\").arg(id,3,10,QLatin1Char('0'));;\r\n                                    dccfFilename.append(localFilename);\r\n                                    dccfFilenameBin.append(localFilename1);\r\n\r\n                                    emit messageChanged(tr(\"saving distance distance crosscorrelation ...\"));\r\n                                    double* ccf[1]={dccf[id].dccf};\r\n                                    double* ccferr[1]={dccf[id].dccf_std};\r\n                                    double* ccfsegments[1]={dccf[id].dccf_segments};\r\n                                    QString error;\r\n                                    if (!saveCorrelationCSV(localFilename, dccf[id].dccf_tau, ccf, ccferr, 1, dccf[id].dccf_N, frame_width, frame_height, input_length, error,125, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                        m_status=-1; emit statusChanged(m_status);\r\n                                        emit messageChanged(tr(\"could not create distance crosscorrelation file '%1': %2!\").arg(localFilename).arg(error));\r\n                                    }\r\n                                    if (!saveCorrelationBIN(localFilename1, dccf[id].dccf_tau, ccf, ccferr, 1, dccf[id].dccf_N, frame_width, frame_height, ccfsegments, error,125, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                        m_status=-1; emit statusChanged(m_status);\r\n                                        emit messageChanged(tr(\"could not create binary distance crosscorrelation file '%1': %2!\").arg(localFilename1).arg(error));\r\n                                    }\r\n                                    QString role=job.DCCFrole.value(id, \"DCCF\");\r\n                                    if (role.toLower()==\"fccs\") {\r\n                                        if (QFile::exists(localFilename1)) addFiles.append(getFileInfo(localFilename1, configFilename, role, 0, getGroupName()));\r\n                                        else addFiles.append(getFileInfo(localFilename, configFilename, role, 0, getGroupName()));\r\n                                    } else {\r\n                                        if (QFile::exists(localFilename1)) addFiles.append(getFileInfo(localFilename1, configFilename, role, getGroupName()));\r\n                                        else addFiles.append(getFileInfo(localFilename, configFilename, role, getGroupName()));\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        emit progressIncrement(250);\r\n\r\n\r\n                        //************** SAVE CCF\r\n                        if ((m_status==1) && !was_canceled && job.ccf && ccf_tau && ccf1 && ccf2 && ccf3 && ccf4 && ccf_N>0) {\r\n                            QString localFilename=ccfFilename=outputFilenameBase+\".crosscorrelation.dat\";\r\n                            QString localFilename1=ccfFilenameBin=outputFilenameBase+\".crosscorrelation.bin\";\r\n\r\n                            emit messageChanged(tr(\"saving distance crosscorrelation ...\"));\r\n                            double* ccf[4]={ccf1, ccf2, ccf3, ccf4};\r\n                            double* ccferr[4]={ccf1_std, ccf2_std, ccf3_std, ccf4_std};\r\n                            double* ccfsegments[4]={ccf1_segments, ccf2_segments, ccf3_segments, ccf4_segments};\r\n                            QString error;\r\n                            if (!saveCorrelationCSV(localFilename, ccf_tau, ccf, ccferr, 4, ccf_N, frame_width, frame_height, input_length, error, 0, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create crosscorrelation file '%1': %2!\").arg(localFilename).arg(error));\r\n                            }\r\n                            if (!saveCorrelationBIN(localFilename1, ccf_tau, ccf, ccferr, 4, ccf_N, frame_width, frame_height, ccfsegments, error, 0, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create binary crosscorrelation file '%1': %2!\").arg(localFilename1).arg(error));\r\n                            }\r\n                            if (QFile::exists(localFilename1)) addFiles.append(getFileInfo(localFilename1, configFilename, QString(\"CCF\"), getGroupName()));\r\n                            else addFiles.append(getFileInfo((localFilename), configFilename, \"CCF\", getGroupName()));\r\n\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n\r\n\r\n                        //qDebug()<<job.addNandB<< QFile::exists(averageFilenameF)<< QFile::exists(stdFilename)<< QFile::exists(backgroundFilename)<< QFile::exists(backstdFilename);\r\n\r\n                        //************** CREATE N&B job\r\n                        if (job.addNandB\r\n                                && QFile::exists(averageFilenameF)\r\n                                && QFile::exists(stdFilename)\r\n                                /*&& QFile::exists(backgroundFilename)\r\n                                && QFile::exists(backstdFilename)*/) {\r\n\r\n                            if (job.addFCCSSeparately && job.dualViewMode!=0) {\r\n                                addFiles.append(getFileInfoNandB(averageFilenameF, stdFilename, backgroundFilename, backstdFilename, configFilename, \"N&B1\", 0, getGroupName()));\r\n                                addFiles.append(getFileInfoNandB(averageFilenameF, stdFilename, backgroundFilename, backstdFilename, configFilename, \"N&B2\", 1, getGroupName()));\r\n                            } else {\r\n                                addFiles.append(getFileInfoNandB(averageFilenameF, stdFilename, backgroundFilename, backstdFilename, configFilename, \"N&B\", 0, getGroupName()));\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (mutexFilename) mutexFilename->unlock();\r\n                        m_status=-1; emit statusChanged(m_status);\r\n                        emit messageChanged(tr(\"could not create output subdirectory '%1' in '%2'!\").arg(localFileDirectory).arg(d.absolutePath()));\r\n                    }\r\n\r\n                    if (video) qfFree(video);\r\n                    if (video_uncorrected) qfFree(video_uncorrected);\r\n                    if (fit_frames) qfFree(fit_frames);\r\n                    if (fit_t) qfFree(fit_t);\r\n                    if (bleachAmplitude) qfFree(bleachAmplitude);\r\n                    if (bleachTime) qfFree(bleachTime);\r\n                    if (bleachAmplitude2) qfFree(bleachAmplitude2);\r\n                    if (bleachTime2) qfFree(bleachTime2);\r\n                    if (bleachPoly2) qfFree(bleachPoly2);\r\n                    if (bleachPoly3) qfFree(bleachPoly3);\r\n                    if (bleachPoly4) qfFree(bleachPoly4);\r\n                    if (bleachPoly5) qfFree(bleachPoly5);\r\n                    if (bleachFitOK) qfFree(bleachFitOK);\r\n                    if (average_frame) qfFree(average_frame);\r\n                    if (sqrsum_frame) qfFree(sqrsum_frame);\r\n                    if (acf_tau) qfFree(acf_tau);\r\n                    if (acf) qfFree(acf);\r\n                    if (acf_segments) qfFree(acf_segments);\r\n                    if (acf_std) qfFree(acf_std);\r\n                    if (ccf_tau) qfFree(ccf_tau);\r\n                    if (ccf1) qfFree(ccf1);\r\n                    if (ccf2) qfFree(ccf2);\r\n                    if (ccf3) qfFree(ccf3);\r\n                    if (ccf4) qfFree(ccf4);\r\n                    if (ccf1_std) qfFree(ccf1_std);\r\n                    if (ccf2_std) qfFree(ccf2_std);\r\n                    if (ccf3_std) qfFree(ccf3_std);\r\n                    if (ccf4_std) qfFree(ccf4_std);\r\n                    if (ccf1_segments) qfFree(ccf1_segments);\r\n                    if (ccf2_segments) qfFree(ccf2_segments);\r\n                    if (ccf3_segments) qfFree(ccf3_segments);\r\n                    if (ccf4_segments) qfFree(ccf4_segments);\r\n                    for (int id=0; id<dccf.size(); id++) {\r\n                        if (dccf[id].dccf_tau) qfFree(dccf[id].dccf_tau);\r\n                        if (dccf[id].dccf) qfFree(dccf[id].dccf);\r\n                        if (dccf[id].dccf_std) qfFree(dccf[id].dccf_std);\r\n                        if (dccf[id].dccf_segments) qfFree(dccf[id].dccf_segments);\r\n                    }\r\n                    dccf.clear();\r\n                    if (m_status==1) {\r\n                        if (was_canceled) {\r\n                            m_status=-1; emit statusChanged(m_status);\r\n                            duration=ptime.elapsed();\r\n                            emit messageChanged(tr(\"canceled by user\"));\r\n                        } else {\r\n                            m_status=2; emit statusChanged(m_status);\r\n                            duration=ptime.elapsed();\r\n                            emit messageChanged(tr(\"correlation ... done [duration = %1 s]\").arg(duration/1.0e3));\r\n                        }\r\n                        emit statusChanged(m_status);\r\n                    }\r\n                } else {\r\n                    m_status=-1; emit statusChanged(m_status);\r\n                    duration=ptime.elapsed();\r\n                    emit messageChanged(tr(\"no frames in file/selected\"));\r\n                }\r\n\r\n\r\n            }\r\n            delete reader;\r\n        } else {\r\n            m_status=-1; emit statusChanged(m_status);\r\n            duration=ptime.elapsed();\r\n            emit messageChanged(tr(\"could not create image reader object\"));\r\n        }\r\n    }\r\n\r\n\r\n    duration=ptime.elapsed();\r\n}"
]