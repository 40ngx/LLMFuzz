{
    "SourcegraphEndpoint": "https://sourcegraph.com",
    "Query": "file:\\.(c|cpp|cc)$ lang:c++ count:all TIFFRGBAImageGet",
    "Site": {
        "BuildVersion": "316984_2025-03-18_6.1-1f1695fa27f5"
    },
    "Results": [
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "761fac6e54c265d9011eaf7abfcac4952261d510"
                },
                "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright The XCSoar Project\n\n#include \"LibTiff.hpp\"\n#include \"UncompressedImage.hpp\"\n#include \"system/Path.hpp\"\n#include \"util/ScopeExit.hxx\"\n\n#include <stdexcept>\n\n#include <tiffio.h>\n\n#ifdef USE_GEOTIFF\n#include \"Geo/Quadrilateral.hpp\"\n\n#include <geotiff.h>\n#include <geo_normalize.h>\n#include <geovalues.h>\n#include <xtiffio.h>\n#endif\n\nstatic TIFF *\nTiffOpen(Path path, const char *mode)\n{\n#ifdef USE_GEOTIFF\n  XTIFFInitialize();\n#endif\n\n#ifdef _UNICODE\n  return TIFFOpenW(path.c_str(), mode);\n#else\n  return TIFFOpen(path.c_str(), mode);\n#endif\n}\n\nclass TiffLoader {\n  TIFF *const tiff;\n\npublic:\n  explicit TiffLoader(Path path)\n    :tiff(TiffOpen(path, \"r\")) {\n    if (tiff == nullptr)\n      throw std::runtime_error(\"Failed to open TIFF file\");\n  }\n\n  ~TiffLoader() {\n    TIFFClose(tiff);\n  }\n\n  TIFF *Get() {\n    return tiff;\n  }\n\n  void GetField(uint32_t tag, int &value_r) {\n    TIFFGetField(tiff, tag, &value_r);\n  }\n\n  void RGBAImageBegin(TIFFRGBAImage &img) {\n    char emsg[1024];\n    if (!TIFFRGBAImageBegin(&img, tiff, 0, emsg))\n      throw std::runtime_error(emsg);\n  }\n};\n\nstatic UncompressedImage\nLoadTiff(TIFFRGBAImage &img)\n{\n  if (img.width > 8192 || img.height > 8192)\n    throw std::runtime_error(\"TIFF file is too large\");\n\n  std::unique_ptr<uint8_t[]> data(new uint8_t[img.width * img.height * 4]);\n  uint32_t *data32 = (uint32_t *)(void *)data.get();\n\n  if (!TIFFRGBAImageGet(&img, data32, img.width, img.height))\n    throw std::runtime_error(\"Failed to copy TIFF data\");\n\n  return UncompressedImage(UncompressedImage::Format::RGBA, img.width * 4,\n                           img.width, img.height, std::move(data), true);\n}\n\nstatic UncompressedImage\nLoadTiff(TiffLoader &tiff)\n{\n  TIFFRGBAImage img;\n  tiff.RGBAImageBegin(img);\n\n  AtScopeExit(&img) { TIFFRGBAImageEnd(&img); };\n\n  return LoadTiff(img);\n}\n\nUncompressedImage\nLoadTiff(Path path)\n{\n  TiffLoader tiff(path);\n  return LoadTiff(tiff);\n}\n\n#ifdef USE_GEOTIFF\n\nstatic GeoPoint\nTiffPixelToGeoPoint(GTIF &gtif, GTIFDefn &defn, double x, double y)\n{\n  if (!GTIFImageToPCS(&gtif, &x, &y))\n    return GeoPoint::Invalid();\n\n  if (defn.Model != ModelTypeGeographic &&\n      !GTIFProj4ToLatLong(&defn, 1, &x, &y))\n    return GeoPoint::Invalid();\n\n  return GeoPoint(Angle::Degrees(x), Angle::Degrees(y));\n}\n\nstd::pair<UncompressedImage, GeoQuadrilateral>\nLoadGeoTiff(Path path)\n{\n  TiffLoader tiff(path);\n\n  GeoQuadrilateral bounds;\n\n  {\n    auto gtif = GTIFNew(tiff.Get());\n    if (gtif == nullptr)\n      throw std::runtime_error(\"Not a GeoTIFF file\");\n\n    AtScopeExit(gtif) { GTIFFree(gtif); };\n\n    GTIFDefn defn;\n    if (!GTIFGetDefn(gtif, &defn))\n      throw std::runtime_error(\"Failed to parse GeoTIFF metadata\");\n\n    int width, height;\n    tiff.GetField(TIFFTAG_IMAGEWIDTH, width);\n    tiff.GetField(TIFFTAG_IMAGELENGTH, height);\n\n    bounds.top_left = TiffPixelToGeoPoint(*gtif, defn, 0, 0);\n    bounds.top_right = TiffPixelToGeoPoint(*gtif, defn, width, 0);\n    bounds.bottom_left = TiffPixelToGeoPoint(*gtif, defn, 0, height);\n    bounds.bottom_right = TiffPixelToGeoPoint(*gtif, defn, width, height);\n\n    if (!bounds.Check())\n      throw std::runtime_error(\"Invalid GeoTIFF bounds\");\n  }\n\n  return std::make_pair(LoadTiff(tiff), bounds);\n}\n\n#endif\n",
                "name": "LibTiff.cpp",
                "path": "src/ui/canvas/custom/LibTiff.cpp",
                "url": "/github.com/XCSoar/XCSoar/-/blob/src/ui/canvas/custom/LibTiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 73,
                    "offsetAndLengths": [
                        [
                            7,
                            16
                        ]
                    ],
                    "preview": "  if (!TIFFRGBAImageGet(&img, data32, img.width, img.height))"
                }
            ],
            "repository": {
                "name": "github.com/XCSoar/XCSoar",
                "url": "/github.com/XCSoar/XCSoar"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "22c32e3cb711eeb92fd412b0df3cbeef1680be04"
                },
                "content": "#include \"StdAfx.h\"\n\n// #define STRICT\n#include \"diblib.h\"\n#include <commdlg.h>\n#include <stdlib.h> // MAX_ constants\n#include <windows.h>\n#include <windowsx.h>\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage\n{\n    TIFFRGBAImage tif;\n    int dibinstalled;\n};\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster);\n\nstatic void MyWarningHandler(const char *module, const char *fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void MyErrorHandler(const char *module, const char *fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF(LPCTSTR lpszPath)\n{\n    int rtn = 0;\n\n    TIFFErrorHandler eh;\n    TIFFErrorHandler wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF *tif = TIFFOpen(lpszPath, \"r\");\n    if (tif)\n    {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage *img);\n\nPVOID ReadTIFF(LPCTSTR lpszPath)\n{\n    void *pDIB = 0;\n    TIFFErrorHandler wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath))\n    {\n        TIFF *tif = TIFFOpen(lpszPath, \"r\");\n        if (tif)\n        {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg))\n            {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg))\n                {\n                    size_t npixels;\n                    uint32_t *raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster =\n                        (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n                    if (raster != NULL)\n                    {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width,\n                                             img.tif.height))\n                        {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else\n            {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg);\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster)\n{\n    void *pDIB = 0;\n    TIFFRGBAImage *img = &dib->tif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER bi;\n    int dwDIBSize;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if (BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled)\n    { // bilevel\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 1;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed = 0;\n        pRgbq[0].rgbBlue = 0;\n        pRgbq[0].rgbGreen = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed = 255;\n        pRgbq[1].rgbBlue = 255;\n        pRgbq[1].rgbGreen = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr(\n            (BITMAPINFOHEADER *)pDIB); //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n    //  For now just always default to the RGB 32 bit form. // save as 32 bit\n    //  for simplicity\n    else if (true /*BitsPerSample == 8 && SamplePerPixel == 3*/)\n    { // 24 bit color\n\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 32;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        // Swap the byte order while copying\n        for (int i = 0; i < sizeWords; ++i)\n        {\n            rgbDib[i].rgbRed = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n#define DECLAREContigPutFunc(name)                                             \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *pp)\n\n#define DECLARESepPutFunc(name)                                                \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *r, u_char *g, u_char *b, u_char *a)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *uraster, uint32_t w,\n                              uint32_t h);\n\n// typdef struct TIFFDibImage {\n//     TIFFRGBAImage tif;\n//     dibinstalled;\n// } TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage *dib)\n{\n    TIFFRGBAImage *img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric)\n    {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n            switch (img->bitspersample)\n            {\n                case 1:\n                    img->put.contig = putContig1bitTile;\n                    img->get = getStripContig1Bit;\n                    dib->dibinstalled = true;\n                    break;\n            }\n            break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void)y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char *ucp = (u_char *)cp;\n\n    /* Convert 'w' to bytes from pixels (rounded up) */\n    w = (w + 7) / 8;\n\n    while (h-- > 0)\n    {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32_t setorientation(TIFFRGBAImage *img, uint32_t h)\n{\n    TIFF *tif = img->tif;\n    uint32_t y;\n\n    switch (img->orientation)\n    {\n        case ORIENTATION_BOTRIGHT:\n        case ORIENTATION_RIGHTBOT: /* XXX */\n        case ORIENTATION_LEFTBOT:  /* XXX */\n            TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n            img->orientation = ORIENTATION_BOTLEFT;\n        /* fall through... */\n        case ORIENTATION_BOTLEFT:\n            y = 0;\n            break;\n        case ORIENTATION_TOPRIGHT:\n        case ORIENTATION_RIGHTTOP: /* XXX */\n        case ORIENTATION_LEFTTOP:  /* XXX */\n        default:\n            TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n            img->orientation = ORIENTATION_TOPLEFT;\n        /* fall through... */\n        case ORIENTATION_TOPLEFT:\n            y = h - 1;\n            break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *raster, uint32_t w,\n                              uint32_t h)\n{\n    TIFF *tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16_t orientation;\n    uint32_t row, y, nrow, rowstoread;\n    uint32_t pos;\n    u_char *buf;\n    uint32_t rowsperstrip;\n    uint32_t imagewidth = img->width;\n    tsize_t scanline;\n    int32_t fromskew, toskew;\n    tstrip_t strip;\n    tsize_t stripsize;\n    u_char *braster = (u_char *)raster; // byte wide raster\n    uint32_t wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char *)_TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32_t)(orientation == ORIENTATION_TOPLEFT ? wb + wb : wb - wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0) / 8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif, row + img->row_offset, 0);\n        stripsize = ((row + img->row_offset) % rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize) < 0 &&\n            img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32_t *)(braster + y * wb), 0, y, w, nrow, fromskew,\n               toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ? -(int32_t)nrow\n                                                 : (int32_t)nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n",
                "name": "Tiffile.cpp",
                "path": "thirdparty/libtiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/GrokImageCompression/grok/-/blob/thirdparty/libtiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 112,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width,"
                }
            ],
            "repository": {
                "name": "github.com/GrokImageCompression/grok",
                "url": "/github.com/GrokImageCompression/grok"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "98dfd34c245528db3d0f1b9944da32904538d295"
                },
                "content": "// Aqsis\n// Copyright (C) 2001, Paul C. Gregory and the other authors and contributors\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of source code must retain the above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name of the software's owners nor the names of its\n//   contributors may be used to endorse or promote products derived from this\n//   software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n//\n// (This is the New BSD license)\n\n/** \\file\n *\n * \\brief Scanline-oriented pixel access for TIFF input - implementation.\n *\n * \\author Chris Foster  chris42f _at_ gmail.com\n *\n */\n\n#include \"tiffinputfile.h\"\n\n#include \"boost/scoped_array.hpp\"\n\n#include \"tiffdirhandle.h\"\n\nnamespace Aqsis {\n\n//------------------------------------------------------------------------------\n// CqTiffInputFile - implementation\n\nCqTiffInputFile::CqTiffInputFile(const boostfs::path& fileName)\n\t: m_header(),\n\tm_fileHandle(new CqTiffFileHandle(fileName, \"r\")),\n\tm_imageIndex(0)\n{\n\tsetDirectory(m_imageIndex);\n}\n\nCqTiffInputFile::CqTiffInputFile(std::istream& inStream)\n\t: m_header(),\n\tm_fileHandle(new CqTiffFileHandle(inStream)),\n\tm_imageIndex(0)\n{\n\tsetDirectory(m_imageIndex);\n}\n\nboostfs::path CqTiffInputFile::fileName() const\n{\n\treturn m_fileHandle->fileName();\n}\n\nvoid CqTiffInputFile::setImageIndex(TqInt newIndex)\n{\n\tif(newIndex < 0)\n\t\tAQSIS_THROW_XQERROR(XqInternal, EqE_Bug, \"Cannot set negative image index.\");\n\tsetDirectory(newIndex);\n}\n\n// Warning: don't use this function from another member which already has a\n// lock on the underlying file handle.\nTqInt CqTiffInputFile::numSubImages() const\n{\n\treturn m_fileHandle->numDirectories();\n}\n\nvoid CqTiffInputFile::readPixelsImpl(TqUint8* buffer,\n\t\tTqInt startLine, TqInt numScanlines) const\n{\n\tif(m_header.find<Attr::TiffUseGenericRGBA>())\n\t{\n\t\t// Use generic libtiff RGBA when we encounter unusual TIFF formats.\n\t\treadPixelsRGBA(buffer, startLine, numScanlines);\n\t}\n\telse\n\t{\n\t\t// The usual case - use aqsistex native pixel input\n\t\tif(m_header.findPtr<Attr::TileInfo>())\n\t\t\treadPixelsTiled(buffer, startLine, numScanlines);\n\t\telse\n\t\t\treadPixelsStripped(buffer, startLine, numScanlines);\n\t}\n}\n\nvoid CqTiffInputFile::readPixelsStripped(TqUint8* buffer, TqInt startLine,\n\t\tTqInt numScanlines) const\n{\n\tCqTiffDirHandle dirHandle(m_fileHandle, m_imageIndex);\n\tconst tsize_t bytesPerRow = TIFFScanlineSize(dirHandle.tiffPtr());\n\t// Implement simplest possible version for now - read in scanlines\n\t// sequentially...  Looking at the source code for libtiff, this should be\n\t// reasonably efficient.\n\t//\n\t// In the unlikely event that it turns out to be a problem, we should look\n\t// at using the strip-based interface via TIFFReadEncodedStrip & friends.\n\tfor(TqInt line = startLine; line < startLine + numScanlines; ++line)\n\t{\n\t\tTIFFReadScanline(dirHandle.tiffPtr(), reinterpret_cast<tdata_t>(buffer),\n\t\t\t\tstatic_cast<uint32>(line));\n\t\tbuffer += bytesPerRow;\n\t}\n}\n\nvoid CqTiffInputFile::readPixelsTiled(TqUint8* buffer, TqInt startLine,\n\t\tTqInt numScanlines) const\n{\n\t// Load in relevant tiles; discard the excess.  At this stage, we don't do\n\t// any caching, under the assumption that the user will want to load a\n\t// bunch of scanlines at once.  If they load a single scanline at a time,\n\t// this will be very inefficient.\n\tCqTiffDirHandle dirHandle(m_fileHandle, m_imageIndex);\n\n\t// lines of interest will be startLine to endLine (exclusive)\n\tTqInt endLine = startLine + numScanlines;\n\n\tSqTileInfo tileInfo = m_header.find<Attr::TileInfo>();\n\t// Compute the boundaries of the smallest tiled region containing the\n\t// scanlines we're interested in.\n\tTqInt startTileLine = (startLine/tileInfo.height) * tileInfo.height;\n\t// endTileLine is the start line of the row of tiles coming *after* the\n\t// last row we want to load.\n\tTqInt endTileLine = ((endLine-1)/tileInfo.height + 1) * tileInfo.height;\n\n\tTqInt width = m_header.width();\n\tTqInt bytesPerPixel = m_header.channelList().bytesPerPixel();\n\tTqInt lineSize = bytesPerPixel*width;\n\tTqInt tileLineSize = bytesPerPixel*tileInfo.width;\n\tTqInt tileSize = tileLineSize*tileInfo.height;\n\n\t// Buffer to hold tiles read using libtiff.\n\tboost::shared_array<TqUint8> tempTileBuf(\n\t\t\tstatic_cast<TqUint8*>(_TIFFmalloc(tileSize)),\n\t\t\t_TIFFfree);\n\n\tfor(TqInt y = startTileLine; y < endTileLine; y += tileInfo.height)\n\t{\n\t\t// Determine how much of the beginning and end of the current strip\n\t\t// should be skipped due to the tiles falling off the range of\n\t\t// relevant scanlines.\n\t\tTqInt outStripSkipStart =\n\t\t\t(y == startTileLine) ? startLine - startTileLine : 0;\n\t\tTqInt outStripSkipEnd =\n\t\t\t(y + tileInfo.height == endTileLine) ? endTileLine - endLine : 0;\n\t\t// The output \"Strip height\" for the current line of tiles might be\n\t\t// smaller than the tile height; take this into account here.\n\t\tTqInt stripHeightOut = tileInfo.height - outStripSkipStart - outStripSkipEnd;\n\n\t\tfor(TqInt x = 0; x < width; x += tileInfo.width)\n\t\t{\n\t\t\t// Grab the tile using libtiff\n\t\t\tTIFFReadTile(dirHandle.tiffPtr(),\n\t\t\t\t\tstatic_cast<tdata_t>(tempTileBuf.get()), x, y, 0, 0);\n\t\t\t// The width of the tile in the output image is smaller when it\n\t\t\t// falls of the RHS of the image.\n\t\t\tTqInt tileLineSizeOut = min(tileLineSize, bytesPerPixel*(width-x));\n\t\t\t// Copy the tile into the output buffer.\n\t\t\tTqUint8* lineBuf = buffer + x*bytesPerPixel;\n\t\t\tTqUint8* tileLineBuf = static_cast<TqUint8*>(tempTileBuf.get())\n\t\t\t\t+ outStripSkipStart*tileLineSize;\n\t\t\tfor(TqInt tileLine = 0; tileLine < stripHeightOut; ++tileLine)\n\t\t\t{\n\t\t\t\t_TIFFmemcpy(lineBuf, tileLineBuf, tileLineSizeOut);\n\t\t\t\ttileLineBuf += tileLineSize;\n\t\t\t\tlineBuf += lineSize;\n\t\t\t}\n\t\t}\n\t\tbuffer += lineSize*stripHeightOut;\n\t}\n}\n\nvoid CqTiffInputFile::readPixelsRGBA(TqUint8* buffer, TqInt startLine,\n\t\tTqInt numScanlines) const\n{\n\tCqTiffDirHandle dirHandle(m_fileHandle, m_imageIndex);\n\t// Support odd tiff formats using the generic RGBA tiff functionality.\n\t//\n\t// We read in the entire image each time readPixelsRGBA() is called; this\n\t// *will* cause a performance bottleneck if the user calls readPixels() on\n\t// only a small number of scanlines at a time.\n\tboost::scoped_array<uint32> inBuf(\n\t\t\tnew uint32[m_header.width()*m_header.height()]);\n\tTIFFReadRGBAImageOriented(dirHandle.tiffPtr(), m_header.width(),\n\t\t\tm_header.height(), inBuf.get(), ORIENTATION_TOPLEFT, 0);\n\n\t// Unfortunately, the RGBA format which libtiff uses puts the RGBA bytes in\n\t// the opposite order which we'd like, so we need to swap them.  It's\n\t// possible to get around this using TIFFRGBAImageGet() but it's extra work\n\t// which somewhat defeats the purpose of using the RGBA functionality as a\n\t// catchall fallback anyway.\n\tTqInt width = m_header.width();\n\tTqInt bytesPerPixel = m_header.channelList().bytesPerPixel();\n\tassert(bytesPerPixel == 4);\n\tconst uint32* inPtr = inBuf.get() + width*startLine;\n\tfor(TqInt line = 0; line < numScanlines; ++line)\n\t{\n\t\tfor(TqInt col = 0; col < width; ++col)\n\t\t{\n\t\t\tbuffer[col*bytesPerPixel] = TIFFGetR(inPtr[col]);\n\t\t\tbuffer[col*bytesPerPixel + 1] = TIFFGetG(inPtr[col]);\n\t\t\tbuffer[col*bytesPerPixel + 2] = TIFFGetB(inPtr[col]);\n\t\t\tbuffer[col*bytesPerPixel + 3] = TIFFGetA(inPtr[col]);\n\t\t}\n\t\tbuffer += width*bytesPerPixel;\n\t\tinPtr += width;\n\t}\n}\n\nvoid CqTiffInputFile::setDirectory(tdir_t newDir)\n{\n\tconst tdir_t numDirs = numSubImages();\n\tif(newDir >= numDirs)\n\t{\n\t\tAQSIS_THROW_XQERROR(XqInternal, EqE_Bug, \"TIFF directory \"\n\t\t\t<< newDir << \" out of range [0,\" << numDirs-1 << \"]\");\n\t}\n\tm_imageIndex = newDir;\n\n\tCqTiffDirHandle dirHandle(m_fileHandle, m_imageIndex);\n\tdirHandle.fillHeader(m_header);\n}\n\n} // namespace Aqsis\n",
                "name": "tiffinputfile.cpp",
                "path": "libs/tex/io/tiffinputfile.cpp",
                "url": "/github.com/aqsis/aqsis/-/blob/libs/tex/io/tiffinputfile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 204,
                    "offsetAndLengths": [
                        [
                            38,
                            16
                        ]
                    ],
                    "preview": "\t// possible to get around this using TIFFRGBAImageGet() but it's extra work"
                }
            ],
            "repository": {
                "name": "github.com/aqsis/aqsis",
                "url": "/github.com/aqsis/aqsis"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "98dfd34c245528db3d0f1b9944da32904538d295"
                },
                "content": "/*\nRGBAImage.cpp\nCopyright (C) 2006 Yangli Hector Yee\n\nThis program is free software; you can redistribute it and/or modify it under the terms of the\nGNU General Public License as published by the Free Software Foundation; either version 2 of the License,\nor (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\nwithout even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\nSee the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program;\nif not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n#include \"RGBAImage.h\"\n#include \"tiff.h\"\n#include \"tiffio.h\"\n\n\n// Reads Tiff Images\nRGBAImage* RGBAImage::ReadTiff(char *filename)\n{\n\tRGBAImage *fimg = 0;\n\t\n    TIFF* tif = TIFFOpen(filename, \"r\");\n    char emsg[1024];\n    if (tif) {\n\t\tTIFFRGBAImage img;\n\t\t\n\t\tif (TIFFRGBAImageBegin(&img, tif, 0, emsg)) {\n\t\t\tsize_t npixels;\n\t\t\tuint32* raster;\n\n\t\t\tnpixels = img.width * img.height;\n\t\t\traster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n\t\t\tif (raster != NULL) {\n\t\t\t\tif (TIFFRGBAImageGet(&img, raster, img.width, img.height)) {\n\t\t\t\t\t// result is in ABGR\n\t\t\t\t\tfimg = new RGBAImage(img.width, img.height);\n\t\t\t\t\tfor (int y = 0; y < img.height; y++) {\n\t\t\t\t\t\tfor (int x = 0; x < img.width; x++) {\n\t\t\t\t\t\t   fimg->Set(x,y, raster[x + y * img.width]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t_TIFFfree(raster);\n\t\t\t}\n\t    }\n\t    TIFFRGBAImageEnd(&img);\n\t} else {\n\t    TIFFError(filename, emsg);\n\t}\n\treturn fimg;\n}",
                "name": "RGBAImage.cpp",
                "path": "thirdparty/pdiff/RGBAImage.cpp",
                "url": "/github.com/aqsis/aqsis/-/blob/thirdparty/pdiff/RGBAImage.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 38,
                    "offsetAndLengths": [
                        [
                            8,
                            16
                        ]
                    ],
                    "preview": "\t\t\t\tif (TIFFRGBAImageGet(&img, raster, img.width, img.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/aqsis/aqsis",
                "url": "/github.com/aqsis/aqsis"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "6f89d11490fe516478b9a477657de7403d12bece"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "exercise-4/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/epi052/fuzzing-101-solutions/-/blob/exercise-4/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/epi052/fuzzing-101-solutions",
                "url": "/github.com/epi052/fuzzing-101-solutions"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "598c43dabd5364d44afa429b4d837086c8fe5e53"
                },
                "content": "#include \"StdAfx.h\"\n\n// #define STRICT\n#include \"diblib.h\"\n#include <commdlg.h>\n#include <stdlib.h> // MAX_ constants\n#include <windows.h>\n#include <windowsx.h>\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage\n{\n    TIFFRGBAImage tif;\n    int dibinstalled;\n};\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster);\n\nstatic void MyWarningHandler(const char *module, const char *fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void MyErrorHandler(const char *module, const char *fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF(LPCTSTR lpszPath)\n{\n    int rtn = 0;\n\n    TIFFErrorHandler eh;\n    TIFFErrorHandler wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF *tif = TIFFOpen(lpszPath, \"r\");\n    if (tif)\n    {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage *img);\n\nPVOID ReadTIFF(LPCTSTR lpszPath)\n{\n    void *pDIB = 0;\n    TIFFErrorHandler wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath))\n    {\n        TIFF *tif = TIFFOpen(lpszPath, \"r\");\n        if (tif)\n        {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg))\n            {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg))\n                {\n                    size_t npixels;\n                    uint32_t *raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster =\n                        (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n                    if (raster != NULL)\n                    {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width,\n                                             img.tif.height))\n                        {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else\n            {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg);\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster)\n{\n    void *pDIB = 0;\n    TIFFRGBAImage *img = &dib->tif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER bi;\n    int dwDIBSize;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if (BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled)\n    { // bilevel\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 1;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed = 0;\n        pRgbq[0].rgbBlue = 0;\n        pRgbq[0].rgbGreen = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed = 255;\n        pRgbq[1].rgbBlue = 255;\n        pRgbq[1].rgbGreen = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr(\n            (BITMAPINFOHEADER *)pDIB); //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n    //  For now just always default to the RGB 32 bit form. // save as 32 bit\n    //  for simplicity\n    else if (true /*BitsPerSample == 8 && SamplePerPixel == 3*/)\n    { // 24 bit color\n\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 32;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        // Swap the byte order while copying\n        for (int i = 0; i < sizeWords; ++i)\n        {\n            rgbDib[i].rgbRed = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n#define DECLAREContigPutFunc(name)                                             \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *pp)\n\n#define DECLARESepPutFunc(name)                                                \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *r, u_char *g, u_char *b, u_char *a)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *uraster, uint32_t w,\n                              uint32_t h);\n\n// typdef struct TIFFDibImage {\n//     TIFFRGBAImage tif;\n//     dibinstalled;\n// } TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage *dib)\n{\n    TIFFRGBAImage *img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric)\n    {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n            switch (img->bitspersample)\n            {\n                case 1:\n                    img->put.contig = putContig1bitTile;\n                    img->get = getStripContig1Bit;\n                    dib->dibinstalled = true;\n                    break;\n            }\n            break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void)y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char *ucp = (u_char *)cp;\n\n    /* Convert 'w' to bytes from pixels (rounded up) */\n    w = (w + 7) / 8;\n\n    while (h-- > 0)\n    {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32_t setorientation(TIFFRGBAImage *img, uint32_t h)\n{\n    TIFF *tif = img->tif;\n    uint32_t y;\n\n    switch (img->orientation)\n    {\n        case ORIENTATION_BOTRIGHT:\n        case ORIENTATION_RIGHTBOT: /* XXX */\n        case ORIENTATION_LEFTBOT:  /* XXX */\n            TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n            img->orientation = ORIENTATION_BOTLEFT;\n        /* fall through... */\n        case ORIENTATION_BOTLEFT:\n            y = 0;\n            break;\n        case ORIENTATION_TOPRIGHT:\n        case ORIENTATION_RIGHTTOP: /* XXX */\n        case ORIENTATION_LEFTTOP:  /* XXX */\n        default:\n            TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n            img->orientation = ORIENTATION_TOPLEFT;\n        /* fall through... */\n        case ORIENTATION_TOPLEFT:\n            y = h - 1;\n            break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *raster, uint32_t w,\n                              uint32_t h)\n{\n    TIFF *tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16_t orientation;\n    uint32_t row, y, nrow, rowstoread;\n    uint32_t pos;\n    u_char *buf;\n    uint32_t rowsperstrip;\n    uint32_t imagewidth = img->width;\n    tsize_t scanline;\n    int32_t fromskew, toskew;\n    tstrip_t strip;\n    tsize_t stripsize;\n    u_char *braster = (u_char *)raster; // byte wide raster\n    uint32_t wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char *)_TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32_t)(orientation == ORIENTATION_TOPLEFT ? wb + wb : wb - wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0) / 8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif, row + img->row_offset, 0);\n        stripsize = ((row + img->row_offset) % rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize) < 0 &&\n            img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32_t *)(braster + y * wb), 0, y, w, nrow, fromskew,\n               toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ? -(int32_t)nrow\n                                                 : (int32_t)nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n",
                "name": "Tiffile.cpp",
                "path": "3rdparty/tiff-4.6.0/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/SuperIlu/DosView/-/blob/3rdparty/tiff-4.6.0/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 112,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width,"
                }
            ],
            "repository": {
                "name": "github.com/SuperIlu/DosView",
                "url": "/github.com/SuperIlu/DosView"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "6dd2dcab2464c1739940a7c7b42eb00b5a82feb1"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n",
                "name": "Tiffile.cpp",
                "path": "libraries/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/POV-Ray/povray/-/blob/libraries/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/POV-Ray/povray",
                "url": "/github.com/POV-Ray/povray"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "464b028c0380183859f1b0bd6b94a6e954772ddf"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "libs/cross_platform/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/Kigs-framework/kigs/-/blob/libs/cross_platform/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/Kigs-framework/kigs",
                "url": "/github.com/Kigs-framework/kigs"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "193c3f4765770ada31ba4ff1e219364f59f4e60f"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "Projects/Android/jni/SupportLibs/SDL2/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/DrBeef/Doom3Quest/-/blob/Projects/Android/jni/SupportLibs/SDL2/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/DrBeef/Doom3Quest",
                "url": "/github.com/DrBeef/Doom3Quest"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "aca0b69befb13a72dae848e110b2bd1cc9007516"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n",
                "name": "Tiffile.cpp",
                "path": "src/main/jni/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/Beyka/Android-TiffBitmapFactory/-/blob/src/main/jni/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/Beyka/Android-TiffBitmapFactory",
                "url": "/github.com/Beyka/Android-TiffBitmapFactory"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "38ade005555056cc7ba454a600d6392ac11a0428"
                },
                "content": "#include \"StdAfx.h\"\r\n\r\n//#define STRICT\r\n#include <windows.h>\r\n#include <windowsx.h>\r\n#include <commdlg.h>\r\n#include <stdlib.h>                     // MAX_ constants\r\n#include \"diblib.h\"\r\n\r\n/*--------------------------------------------------------------------\r\n        READ TIFF\r\n        Load the TIFF data from the file into memory.  Return\r\n        a pointer to a valid DIB (or NULL for errors).\r\n        Uses the TIFFRGBA interface to libtiff.lib to convert\r\n        most file formats to a useable form.  We just keep the 32 bit\r\n        form of the data to display, rather than optimizing for the\r\n        display.\r\n\r\n        Main entry points:\r\n\r\n            int ChkTIFF ( LPCTSTR lpszPath )\r\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\r\n\r\n        RETURN\r\n            A valid DIB pointer for success; NULL for failure.\r\n\r\n  --------------------------------------------------------------------*/\r\n\r\n#include \"TiffLib/tiff.h\"\r\n#include \"TiffLib/tiffio.h\"\r\n#include <assert.h>\r\n#include <stdio.h>\r\n\r\n\r\n// piggyback some data on top of the RGBA Image\r\nstruct TIFFDibImage {\r\n    TIFFRGBAImage tif;\r\n    int  dibinstalled;\r\n} ;\r\n\r\n\r\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\r\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32_t* raster)  ;\r\n\r\nstatic void\r\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\r\n{\r\n    // ignore all warnings (unused tags, etc)\r\n    return;\r\n}\r\n\r\nstatic void\r\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\r\n{\r\n    return;\r\n}\r\n\r\n//  Turn off the error and warning handlers to check if a valid file.\r\n//  Necessary because of the way that the Doc loads images and restart files.\r\nint ChkTIFF ( LPCTSTR lpszPath )\r\n{\r\n    int rtn = 0;\r\n\r\n    TIFFErrorHandler  eh;\r\n    TIFFErrorHandler  wh;\r\n\r\n    eh = TIFFSetErrorHandler(NULL);\r\n    wh = TIFFSetWarningHandler(NULL);\r\n\r\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\r\n    if (tif) {\r\n        rtn = 1;\r\n        TIFFClose(tif);\r\n    }\r\n\r\n    TIFFSetErrorHandler(eh);\r\n    TIFFSetWarningHandler(wh);\r\n\r\n    return rtn;\r\n}\r\n\r\nvoid DibInstallHack(TIFFDibImage* img) ;\r\n\r\nPVOID ReadTIFF ( LPCTSTR lpszPath )\r\n{\r\n    void*             pDIB = 0;\r\n    TIFFErrorHandler  wh;\r\n\r\n    wh = TIFFSetWarningHandler(MyWarningHandler);\r\n\r\n    if (ChkTIFF(lpszPath)) {\r\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\r\n        if (tif) {\r\n            char emsg[1024];\r\n\r\n            if (TIFFRGBAImageOK(tif, emsg)) {\r\n                TIFFDibImage img;\r\n                char emsg[1024];\r\n\r\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\r\n                    size_t npixels;\r\n                    uint32_t* raster;\r\n\r\n                    DibInstallHack(&img);\r\n\r\n                    npixels = img.tif.width * img.tif.height;\r\n                    raster = (uint32_t*) _TIFFmalloc(npixels * sizeof (uint32_t));\r\n                    if (raster != NULL) {\r\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\r\n                            pDIB = TIFFRGBA2DIB(&img, raster);\r\n                        }\r\n                    }\r\n                    _TIFFfree(raster);\r\n                }\r\n                TIFFRGBAImageEnd(&img.tif);\r\n            }\r\n            else {\r\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\r\n            }\r\n            TIFFClose(tif);\r\n        }\r\n    }\r\n\r\n    TIFFSetWarningHandler(wh);\r\n\r\n    return pDIB;\r\n}\r\n\r\n\r\n\r\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32_t* raster)\r\n{\r\n    void*   pDIB = 0;\r\n    TIFFRGBAImage* img = &dib->tif;\r\n\r\n    uint32_t imageLength;\r\n    uint32_t imageWidth;\r\n    uint16_t BitsPerSample;\r\n    uint16_t SamplePerPixel;\r\n    uint32_t RowsPerStrip;\r\n    uint16_t PhotometricInterpretation;\r\n\r\n    BITMAPINFOHEADER   bi;\r\n    int                dwDIBSize ;\r\n\r\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\r\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\r\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\r\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\r\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\r\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\r\n\r\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\r\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\r\n        bi.biWidth          = imageWidth;\r\n        bi.biHeight         = imageLength;\r\n        bi.biPlanes         = 1;  // always\r\n        bi.biBitCount       = 1;\r\n        bi.biCompression    = BI_RGB;\r\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\r\n        bi.biXPelsPerMeter  = 0;\r\n        bi.biYPelsPerMeter  = 0;\r\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\r\n        bi.biClrImportant   = 0;  // always\r\n\r\n        // Get the size of the DIB\r\n        dwDIBSize = GetDIBSize( &bi );\r\n\r\n        // Allocate for the BITMAPINFO structure and the color table.\r\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\r\n        if (pDIB == 0) {\r\n            return( NULL );\r\n        }\r\n\r\n        // Copy the header info\r\n        *((BITMAPINFOHEADER*)pDIB) = bi;\r\n\r\n        // Get a pointer to the color table\r\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\r\n\r\n        pRgbq[0].rgbRed      = 0;\r\n        pRgbq[0].rgbBlue     = 0;\r\n        pRgbq[0].rgbGreen    = 0;\r\n        pRgbq[0].rgbReserved = 0;\r\n        pRgbq[1].rgbRed      = 255;\r\n        pRgbq[1].rgbBlue     = 255;\r\n        pRgbq[1].rgbGreen    = 255;\r\n        pRgbq[1].rgbReserved = 255;\r\n\r\n        // Pointers to the bits\r\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\r\n        //\r\n        // In the BITMAPINFOHEADER documentation, it appears that\r\n        // there should be no color table for 32 bit images, but\r\n        // experience shows that the image is off by 3 words if it\r\n        // is not included.  So here it is.\r\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\r\n\r\n        int       sizeWords = bi.biSizeImage/4;\r\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\r\n        long*     rgbTif = (long*)raster;\r\n\r\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\r\n    }\r\n\r\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\r\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\r\n\r\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\r\n        bi.biWidth          = imageWidth;\r\n        bi.biHeight         = imageLength;\r\n        bi.biPlanes         = 1;  // always\r\n        bi.biBitCount       = 32;\r\n        bi.biCompression    = BI_RGB;\r\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\r\n        bi.biXPelsPerMeter  = 0;\r\n        bi.biYPelsPerMeter  = 0;\r\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\r\n        bi.biClrImportant   = 0;  // always\r\n\r\n        // Get the size of the DIB\r\n        dwDIBSize = GetDIBSize( &bi );\r\n\r\n        // Allocate for the BITMAPINFO structure and the color table.\r\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\r\n        if (pDIB == 0) {\r\n            return( NULL );\r\n        }\r\n\r\n        // Copy the header info\r\n        *((BITMAPINFOHEADER*)pDIB) = bi;\r\n\r\n        // Get a pointer to the color table\r\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\r\n\r\n        // Pointers to the bits\r\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\r\n        //\r\n        // In the BITMAPINFOHEADER documentation, it appears that\r\n        // there should be no color table for 32 bit images, but\r\n        // experience shows that the image is off by 3 words if it\r\n        // is not included.  So here it is.\r\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\r\n\r\n        int       sizeWords = bi.biSizeImage/4;\r\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\r\n        long*     rgbTif = (long*)raster;\r\n\r\n        // Swap the byte order while copying\r\n        for ( int i = 0 ; i < sizeWords ; ++i )\r\n        {\r\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\r\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\r\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\r\n            rgbDib[i].rgbReserved = 0;\r\n        }\r\n    }\r\n\r\n    return pDIB;\r\n}\r\n\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////\r\n//\r\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\r\n//\r\n//\r\ntypedef unsigned char u_char;\r\n\r\n\r\n#define DECLAREContigPutFunc(name) \\\r\nstatic void name(\\\r\n    TIFFRGBAImage* img, \\\r\n    uint32_t* cp, \\\r\n    uint32_t x, uint32_t y, \\\r\n    uint32_t w, uint32_t h, \\\r\n    int32_t fromskew, int32_t toskew, \\\r\n    u_char* pp \\\r\n)\r\n\r\n#define DECLARESepPutFunc(name) \\\r\nstatic void name(\\\r\n    TIFFRGBAImage* img,\\\r\n    uint32_t* cp,\\\r\n    uint32_t x, uint32_t y, \\\r\n    uint32_t w, uint32_t h,\\\r\n    int32_t fromskew, int32_t toskew,\\\r\n    u_char* r, u_char* g, u_char* b, u_char* a\\\r\n)\r\n\r\nDECLAREContigPutFunc(putContig1bitTile);\r\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32_t* uraster, uint32_t w, uint32_t h);\r\n\r\n//typdef struct TIFFDibImage {\r\n//    TIFFRGBAImage tif;\r\n//    dibinstalled;\r\n//} TIFFDibImage ;\r\n\r\nvoid DibInstallHack(TIFFDibImage* dib) {\r\n    TIFFRGBAImage* img = &dib->tif;\r\n    dib->dibinstalled = false;\r\n    switch (img->photometric) {\r\n        case PHOTOMETRIC_MINISWHITE:\r\n        case PHOTOMETRIC_MINISBLACK:\r\n        switch (img->bitspersample) {\r\n            case 1:\r\n                img->put.contig = putContig1bitTile;\r\n                img->get = getStripContig1Bit;\r\n                dib->dibinstalled = true;\r\n                break;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\n/*\r\n * 1-bit packed samples => 1-bit\r\n *\r\n *   Override to just copy the data\r\n */\r\nDECLAREContigPutFunc(putContig1bitTile)\r\n{\r\n    int samplesperpixel = img->samplesperpixel;\r\n\r\n    (void) y;\r\n    fromskew *= samplesperpixel;\r\n    int wb = WIDTHBYTES(w);\r\n    u_char*  ucp = (u_char*)cp;\r\n\r\n    /* Convert 'w' to bytes from pixels (rounded up) */\r\n    w = (w+7)/8;\r\n\r\n    while (h-- > 0) {\r\n        _TIFFmemcpy(ucp, pp, w);\r\n        /*\r\n        for (x = wb; x-- > 0;) {\r\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\r\n            pp += samplesperpixel;\r\n        }\r\n        */\r\n        ucp += (wb + toskew);\r\n        pp += (w + fromskew);\r\n    }\r\n}\r\n\r\n/*\r\n *  Hacked from the tif_getimage.c file.\r\n */\r\nstatic uint32_t\r\nsetorientation(TIFFRGBAImage* img, uint32_t h)\r\n{\r\n    TIFF* tif = img->tif;\r\n    uint32_t y;\r\n\r\n    switch (img->orientation) {\r\n    case ORIENTATION_BOTRIGHT:\r\n    case ORIENTATION_RIGHTBOT:  /* XXX */\r\n    case ORIENTATION_LEFTBOT:   /* XXX */\r\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\r\n    img->orientation = ORIENTATION_BOTLEFT;\r\n    /* fall through... */\r\n    case ORIENTATION_BOTLEFT:\r\n    y = 0;\r\n    break;\r\n    case ORIENTATION_TOPRIGHT:\r\n    case ORIENTATION_RIGHTTOP:  /* XXX */\r\n    case ORIENTATION_LEFTTOP:   /* XXX */\r\n    default:\r\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\r\n    img->orientation = ORIENTATION_TOPLEFT;\r\n    /* fall through... */\r\n    case ORIENTATION_TOPLEFT:\r\n    y = h-1;\r\n    break;\r\n    }\r\n    return (y);\r\n}\r\n\r\n/*\r\n * Get a strip-organized image that has\r\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\r\n * or\r\n *  SamplesPerPixel == 1\r\n *\r\n *  Hacked from the tif_getimage.c file.\r\n *\r\n *    This is set up to allow us to just copy the data to the raster\r\n *    for 1-bit bitmaps\r\n */\r\nstatic int\r\ngetStripContig1Bit(TIFFRGBAImage* img, uint32_t* raster, uint32_t w, uint32_t h)\r\n{\r\n    TIFF* tif = img->tif;\r\n    tileContigRoutine put = img->put.contig;\r\n    uint16_t orientation;\r\n    uint32_t row, y, nrow, rowstoread;\r\n    uint32_t pos;\r\n    u_char* buf;\r\n    uint32_t rowsperstrip;\r\n    uint32_t imagewidth = img->width;\r\n    tsize_t scanline;\r\n    int32_t fromskew, toskew;\r\n    tstrip_t strip;\r\n    tsize_t  stripsize;\r\n    u_char* braster = (u_char*)raster; // byte wide raster\r\n    uint32_t  wb = WIDTHBYTES(w);\r\n    int ret = 1;\r\n\r\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\r\n    if (buf == 0) {\r\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\r\n        return (0);\r\n    }\r\n    y = setorientation(img, h);\r\n    orientation = img->orientation;\r\n    toskew = -(int32_t) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\r\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\r\n    scanline = TIFFScanlineSize(tif);\r\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\r\n    for (row = 0; row < h; row += nrow)\r\n    {\r\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\r\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\r\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\r\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\r\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\r\n            && img->stoponerr)\r\n        {\r\n            ret = 0;\r\n            break;\r\n        }\r\n\r\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\r\n        (*put)(img, (uint32_t*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\r\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32_t) nrow : (int32_t) nrow);\r\n    }\r\n    _TIFFfree(buf);\r\n    return (ret);\r\n}\r\n\r\n/*\r\n * Local Variables:\r\n * mode: c++\r\n * c-basic-offset: 8\r\n * fill-column: 78\r\n * End:\r\n */\r\n",
                "name": "Tiffile.cpp",
                "path": "thirdparty/libtiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/lizabelos/libCML/-/blob/thirdparty/libtiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\r"
                }
            ],
            "repository": {
                "name": "github.com/lizabelos/libCML",
                "url": "/github.com/lizabelos/libCML"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "7e0844e0887634cb7f0d61eed8a9a573e8806f2d"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "extern/SDL_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/wheybags/freeablo/-/blob/extern/SDL_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/wheybags/freeablo",
                "url": "/github.com/wheybags/freeablo"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "60682b2a086988f291725f8c9866a41350abda91"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "app/src/main/jni/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/KillerInk/FreeDcam/-/blob/app/src/main/jni/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/KillerInk/FreeDcam",
                "url": "/github.com/KillerInk/FreeDcam"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "4a6de1675eab8a9e6ab7f70415a27d73277ea911"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/lisanet/Argyll-macos-arm/-/blob/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/lisanet/Argyll-macos-arm",
                "url": "/github.com/lisanet/Argyll-macos-arm"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "81dfe67f5683526006545519766979e5eafba4a6"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "wxwidgets/src/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/arturasn/mdb2sqlite/-/blob/wxwidgets/src/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/arturasn/mdb2sqlite",
                "url": "/github.com/arturasn/mdb2sqlite"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "b77414bc4829cddf2e2f5278da0365c26626332b"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "data/cve/tiff-asan/tiff-4.0.7/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/SanRazor-repo/SanRazor/-/blob/data/cve/tiff-asan/tiff-4.0.7/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/SanRazor-repo/SanRazor",
                "url": "/github.com/SanRazor-repo/SanRazor"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "674bd96d3b917c85ba451ddd902ee46f93179355"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "dependencies/sdl2-image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/ludamad/lanarts/-/blob/dependencies/sdl2-image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/ludamad/lanarts",
                "url": "/github.com/ludamad/lanarts"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "55fff2ecde00c09132e981a8756e824c465f18e6"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "jni/tiff-3.9.5/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/paulasiimwe/Android-ImageMagick/-/blob/jni/tiff-3.9.5/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/paulasiimwe/Android-ImageMagick",
                "url": "/github.com/paulasiimwe/Android-ImageMagick"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "a3b1082519c8526855ec862af3378e46de335f93"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "src/3rdparty/libtiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/Froser/gamemachine/-/blob/src/3rdparty/libtiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/Froser/gamemachine",
                "url": "/github.com/Froser/gamemachine"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "4835cd8c24af2081877184c0ac800f4a3c1106dc"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "src/libtiff/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/fengbingchun/OCR_Test/-/blob/src/libtiff/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/fengbingchun/OCR_Test",
                "url": "/github.com/fengbingchun/OCR_Test"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "943df4fb11980d0b5a30b9115d3bce7f860e31c6"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n",
                "name": "Tiffile.cpp",
                "path": "libtiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/AngusHardie/TesseractOCR-For-Mac/-/blob/libtiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/AngusHardie/TesseractOCR-For-Mac",
                "url": "/github.com/AngusHardie/TesseractOCR-For-Mac"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "7e4212dcc6aeddc3eed76254e7ed1b48bbc53ec4"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n",
                "name": "Tiffile.cpp",
                "path": "lightcrafts/jnisrc/tiff/libtiff/tiff-3.8.2/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/AntonKast/LightZone/-/blob/lightcrafts/jnisrc/tiff/libtiff/tiff-3.8.2/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/AntonKast/LightZone",
                "url": "/github.com/AntonKast/LightZone"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "813fb45dc0652e8803fe32da7acd1c9512ff4902"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "jni/tiff-3.9.5/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/hagish/love-native-android/-/blob/jni/tiff-3.9.5/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/hagish/love-native-android",
                "url": "/github.com/hagish/love-native-android"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "5f1c8b5334f72be0b9bc096ae959556c77338cfb"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "ndk-modules/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/lilac/Android-ImageMagick/-/blob/ndk-modules/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/lilac/Android-ImageMagick",
                "url": "/github.com/lilac/Android-ImageMagick"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "f4be81662b96a074e3dbd1b642b1dd5cc8bdcf2c"
                },
                "content": "#include <Draw/Draw.h>\r\n#include \"tif.h\"\r\n#include <Painter/Painter.h>\r\n\r\n#define\ttif_int32 int32_t\r\n#define\ttif_uint32 uint32_t\r\n\r\n#define LLOG(x)  // LOG(x)\r\n\r\n// #define DBGALLOC 1\r\n\r\nnamespace Upp {\r\n\r\n#if DBGALLOC\r\ndouble total_allocated = 0, total_freed = 0;\r\nunsigned alloc_calls = 0, free_calls = 0, realloc_calls = 0;\r\nIndex<tsize_t> size_index;\r\nVector<int> size_alloc_calls, size_free_calls;\r\nint op_id;\r\n\r\nvoid dbgAddAlloc(void *p, tsize_t s)\r\n{\r\n\t++op_id;\r\n\ttotal_allocated += s;\r\n\tint i = size_index.Find(s);\r\n\tif(i >= 0)\r\n\t\tsize_alloc_calls[i]++;\r\n\telse\r\n\t{\r\n\t\tsize_index.Add(s);\r\n\t\tsize_alloc_calls.Add(1);\r\n\t\tsize_free_calls.Add(0);\r\n\t}\r\n\tLLOG(op_id << \" tAlloc(\" << s << \") = \" << p << \": blks: \" << alloc_calls - free_calls << \", alloc = \" << total_allocated << \", free = \" << total_freed << \", diff = \" << (total_allocated - total_freed));\r\n}\r\n\r\nvoid dbgAddFree(void *p, tsize_t s)\r\n{\r\n\t++op_id;\r\n\ttotal_freed += s;\r\n\tint i = size_index.Find(s);\r\n\tif(i >= 0)\r\n\t\tsize_free_calls[i]++;\r\n\telse\r\n\t{\r\n\t\tsize_index.Add(s);\r\n\t\tsize_alloc_calls.Add(0);\r\n\t\tsize_free_calls.Add(1);\r\n\t}\r\n\tLLOG(op_id << \" tFree(\" << p << \") = \" << s << \": blks: \" << alloc_calls - free_calls << \", alloc = \" << total_allocated << \", free = \" << total_freed << \", diff = \" << (total_allocated - total_freed));\r\n}\r\n\r\nvoid TiffAllocStat()\r\n{\r\n\tfor(int i = 0; i < size_index.GetCount(); i++)\r\n\t\tif(size_alloc_calls[i] != size_free_calls[i])\r\n\t\t\tLOG(\"Alloc/free mismatch: size = \" << size_index[i]\r\n\t\t\t<< \", alloc = \" << size_alloc_calls[i] << \", frees = \" << size_free_calls[i]);\r\n}\r\n#endif\r\n\r\nextern \"C\" tdata_t _TIFFmalloc(tsize_t s)\r\n{\r\n\tbyte *p = new byte[s + 16];\r\n\tPoke32le(p, s);\r\n#if DBGALLOC\r\n\talloc_calls++;\r\n\tdbgAddAlloc(p, s);\r\n#endif\r\n\treturn (tdata_t)(p + 16);\r\n}\r\n\r\nextern \"C\" void* _TIFFcalloc(tmsize_t nmemb, tmsize_t siz)\r\n{\r\n    if( nmemb == 0 || siz == 0 )\r\n        return ((void *) NULL);\r\n\r\n    return _TIFFmalloc(nmemb * siz);\r\n}\r\n\r\nextern \"C\" void    _TIFFfree(tdata_t p)\r\n{\r\n\tif(p) {\r\n\t\tbyte *rawp = (byte *)p - 16;\r\n#if DBGALLOC\r\n\t\tfree_calls++;\r\n\t\tdbgAddFree(p, Peek32le(rawp));\r\n#endif\r\n\t\tdelete[] (rawp);\r\n\t}\r\n}\r\n\r\nextern \"C\" tdata_t _TIFFrealloc(tdata_t p, tsize_t s)\r\n{\r\n\tint oldsize = (p ? Peek32le((const byte *)p - 16) : 0);\r\n\tbyte *newptr = new byte[s + 16];\r\n#if DBGALLOC\r\n\talloc_calls++;\r\n\tdbgAddAlloc(newptr, s);\r\n#endif\r\n\tif(oldsize) {\r\n\t\tmemcpy(newptr + 16, p, min<int>(oldsize, s));\r\n#if DBGALLOC\r\n\t\tfree_calls++;\r\n\t\tdbgAddFree(newptr, oldsize);\r\n#endif\r\n\t\tdelete[] ((byte *)p - 16);\r\n\t}\r\n\tPoke32le(newptr, s);\r\n\treturn (tdata_t)(newptr + 16);\r\n}\r\n\r\nextern \"C\" void _TIFFmemset(void* p, int v, tmsize_t c)           { memset(p, v, c); }\r\nextern \"C\" void _TIFFmemcpy(void* d, const void *s, tmsize_t c) { memcpy(d, s, c); }\r\nextern \"C\" int  _TIFFmemcmp(const void *p1, const void *p2, tmsize_t c) { return memcmp(p1, p2, c); }\r\n\r\n/*\r\nstatic void Blt2to4(byte *dest, const byte *src, unsigned count)\r\n{\r\n\tbyte b;\r\n\r\n#define BLT2_4_4(o) \\\r\n\tb = src[(o)]; \\\r\n\tdest[2 * (o) + 0] = ((b >> 2) & 0x30) | ((b >> 4) & 0x03); \\\r\n\tdest[2 * (o) + 1] = ((b << 2) & 0x30) | (b & 0x03);\r\n\r\n\tfor(unsigned rep = count >> 5; rep; rep--) {\r\n\t\tBLT2_4_4(0) BLT2_4_4(1) BLT2_4_4(2) BLT2_4_4(3)\r\n\t\tBLT2_4_4(4) BLT2_4_4(5) BLT2_4_4(6) BLT2_4_4(7)\r\n\t\tdest += 8 * 2;\r\n\t\tsrc += 8;\r\n\t}\r\n\tif(count & 16) {\r\n\t\tBLT2_4_4(0) BLT2_4_4(1) BLT2_4_4(2) BLT2_4_4(3)\r\n\t\tdest += 4 * 2;\r\n\t\tsrc += 4;\r\n\t}\r\n\tif(count & 8) {\r\n\t\tBLT2_4_4(0) BLT2_4_4(1)\r\n\t\tdest += 2 * 2;\r\n\t\tsrc += 2;\r\n\t}\r\n\tif(count & 4) {\r\n\t\tBLT2_4_4(0)\r\n\t\tdest += 2;\r\n\t\tsrc++;\r\n\t}\r\n\tswitch(count & 3) {\r\n\tcase 0:\r\n\t\tbreak;\r\n\r\n\tcase 1:\r\n\t\t*dest = ((*src >> 2) & 0x30);\r\n\t\tbreak;\r\n\r\n\tcase 2:\r\n\t\t*dest = ((*src >> 2) & 0x30) | ((*src >> 4) & 0x03);\r\n\t\tbreak;\r\n\r\n\tcase 3:\r\n\t\t*dest++ = ((*src >> 2) & 0x30) | ((*src >> 4) & 0x03);\r\n\t\t*dest = (*src << 2) & 0x30;\r\n\t\tbreak;\r\n\t}\r\n}\r\n*/\r\nstatic void BltPack11(byte *dest, const byte *src, byte bit_shift, unsigned count)\r\n{\r\n\tif(bit_shift == 0)\r\n\t{ // simple case\r\n#if defined(CPU_IA32)\r\n#define BLT_PACK_11_4(o) *(unsigned *)(dest + (o)) = *(const unsigned *)(src + (o));\r\n#else\r\n#define BLT_PACK_11_4(o) dest[(o) + 0] = src[(o) + 0]; dest[(o) + 1] = src[(o) + 1]; \\\r\n\tdest[(o) + 2] = src[(o) + 2]; dest[(o) + 3] = src[(o) + 3];\r\n#endif\r\n\t\tfor(unsigned rep = count >> 7; rep; rep--)\r\n\t\t{\r\n\t\t\tBLT_PACK_11_4(0) BLT_PACK_11_4(4) BLT_PACK_11_4(8) BLT_PACK_11_4(12)\r\n\t\t\tdest += 16;\r\n\t\t\tsrc += 16;\r\n\t\t}\r\n\t\tif(count & 0x40)\r\n\t\t{\r\n\t\t\tBLT_PACK_11_4(0) BLT_PACK_11_4(4)\r\n\t\t\tdest += 8;\r\n\t\t\tsrc += 8;\r\n\t\t}\r\n\t\tif(count & 0x20)\r\n\t\t{\r\n\t\t\tBLT_PACK_11_4(0)\r\n\t\t\tdest += 4;\r\n\t\t\tsrc += 4;\r\n\t\t}\r\n\t\tif(count & 0x10)\r\n\t\t{\r\n\t\t\tdest[0] = src[0]; dest[1] = src[1];\r\n\t\t\tdest += 2;\r\n\t\t\tsrc += 2;\r\n\t\t}\r\n\t\tif(count & 8)\r\n\t\t\t*dest++ = *src++;\r\n\t\tswitch(count & 7)\r\n\t\t{\r\n\t\tcase 0: break;\r\n\t\tcase 1: *dest = (*src & 0x80) | (*dest | 0x7f); break;\r\n\t\tcase 2: *dest = (*src & 0xc0) | (*dest | 0x3f); break;\r\n\t\tcase 3: *dest = (*src & 0xe0) | (*dest | 0x1f); break;\r\n\t\tcase 4: *dest = (*src & 0xf0) | (*dest | 0x0f); break;\r\n\t\tcase 5: *dest = (*src & 0xf8) | (*dest | 0x07); break;\r\n\t\tcase 6: *dest = (*src & 0xfc) | (*dest | 0x03); break;\r\n\t\tcase 7: *dest = (*src & 0xfe) | (*dest | 0x01); break;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tconst byte shift1 = bit_shift, shift2 = 8 - bit_shift;\r\n\t\tbyte mask;\r\n\t\tif(count + shift1 <= 8)\r\n\t\t{ // touch just 1 byte\r\n\t\t\tmask = ((1 << count) - 1) << (8 - count - shift1);\r\n\t\t\t*dest = (*dest & ~mask) | ((*src >> shift1) & mask);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tmask = 0xff00 >> shift1;\r\n\t\t*dest = (*dest & ~mask) | ((*src >> shift1) & mask);\r\n\t\tdest++;\r\n\t\tcount -= shift2;\r\n#define BLT_SHIFT_11_1(o) dest[(o)] = (src[(o)] << shift2) | (src[(o) + 1] >> shift1);\r\n#define BLT_SHIFT_11_4(o) BLT_SHIFT_11_1((o)) BLT_SHIFT_11_1((o) + 1) BLT_SHIFT_11_1((o) + 2) BLT_SHIFT_11_1((o) + 3)\r\n\t\tfor(unsigned rep = count >> 6; rep; rep--)\r\n\t\t{\r\n\t\t\tBLT_SHIFT_11_4(0) BLT_SHIFT_11_4(4)\r\n\t\t\tdest += 8;\r\n\t\t\tsrc += 8;\r\n\t\t}\r\n\t\tif(count & 0x20)\r\n\t\t{\r\n\t\t\tBLT_SHIFT_11_4(0)\r\n\t\t\tdest += 4;\r\n\t\t\tsrc += 4;\r\n\t\t}\r\n\t\tif(count & 0x10)\r\n\t\t{\r\n\t\t\tBLT_SHIFT_11_1(0) BLT_SHIFT_11_1(1)\r\n\t\t\tdest += 2;\r\n\t\t\tsrc += 2;\r\n\t\t}\r\n\t\tif(count & 8)\r\n\t\t{\r\n\t\t\tBLT_SHIFT_11_1(0)\r\n\t\t\tdest++;\r\n\t\t\tsrc++;\r\n\t\t}\r\n\t\tif(count &= 7)\r\n\t\t{\r\n\t\t\tbyte data = (count <= shift1 ? src[1] << shift2 : (src[1] << shift2) | (src[2] >> shift1));\r\n\t\t\tmask = 0xff00 >> count;\r\n\t\t\t*dest = (*dest & ~mask) | (data & mask);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// add support for 2 bpp tif - Massimo Del Fedele\r\n// un-optimized way....\r\n// bit_shift should be shift on destination, NOT source\r\nstatic void BltPack22(byte *dest, const byte *src, byte bit_shift, unsigned count)\r\n{\r\n\tunsigned c2 = count >> 2;\r\n\tcount &= 0x03;\r\n\tbyte shift1, shift2;\r\n\tbyte sMask1, sMask2;\r\n\tbyte dMask1, dMask2;\r\n\r\n\tif(!bit_shift) // fast path\r\n\t{\r\n\t\tif(c2)\r\n\t\t{\r\n\t\t\tmemcpy(dest, src, c2);\r\n\t\t\tdest += c2;\r\n\t\t\tsrc += c2;\r\n\t\t}\r\n\t\tswitch(count)\r\n\t\t{\r\n\t\t\tdefault:\r\n\t\t\tcase 0:\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\t*dest = (*dest & 0x3f) | (*src & 0x3f);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\r\n\t\t\t\t*dest = (*dest & 0x0f) | (*src & 0x0f);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 3:\r\n\t\t\t\t*dest = (*dest & 0x03) | (*src & 0x03);\r\n\t\t\t\tbreak;\r\n\t\t} // switch(count)\r\n\t}\r\n\telse // slow path\r\n\t{\r\n\t\tbit_shift <<= 1;\r\n\t\tshift1 = bit_shift;\r\n\t\tshift2 = (8 - bit_shift);\r\n\t\tsMask1 = 0xff << shift1;\r\n\t\tdMask1 = 0xff << shift2;\r\n\t\tsMask2 = 0xff >> shift2;\r\n\t\tdMask2 = 0xff >> shift1;\r\n\t\twhile(c2--)\r\n\t\t{\r\n\t\t\t*dest = (*dest & dMask1) | ((*src & sMask1) >> shift1);\r\n\t\t\tdest++;\r\n\t\t\t*dest = (*dest & dMask2) | ((*src & sMask2) << shift2);\r\n\t\t\tsrc++;\r\n\t\t}\r\n\t\tswitch(count)\r\n\t\t{\r\n\t\t\tcase 0:\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\t*dest = (*dest & ~(0xc0 >> bit_shift)) | ((*src & 0xc0) >> bit_shift);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\r\n\t\t\t\tif(bit_shift <= 4)\r\n\t\t\t\t{\r\n\t\t\t\t\t*dest = (*dest & ~(0xf0 >> bit_shift)) | ((*src & 0xf0) >> bit_shift);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t*dest = (*dest & ~(0xc0 >> bit_shift)) | ((*src & 0xc0) >> bit_shift);\r\n\t\t\t\t\tdest++;\r\n\t\t\t\t\t*dest = (*dest & 0x3f) | ((*src & 0x30) << 2);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 3:\r\n\t\t\t\tif(bit_shift <= 2)\r\n\t\t\t\t{\r\n\t\t\t\t\t*dest = (*dest & ~(0xfc >> bit_shift)) | ((*src & 0xfc) >> bit_shift);\r\n\t\t\t\t}\r\n\t\t\t\telse if(bit_shift <= 4)\r\n\t\t\t\t{\r\n\t\t\t\t\t*dest = (*dest & ~(0xf0 >> bit_shift)) | ((*src & 0xf0) >> bit_shift);\r\n\t\t\t\t\tdest++;\r\n\t\t\t\t\t*dest = (*dest & 0x3f) | ((*src & 0x0c) << 4);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t*dest = (*dest & 0xfc) | ((*src & 0xc0) >> 6);\r\n\t\t\t\t\tdest++;\r\n\t\t\t\t\t*dest = (*dest & 0x0f) | ((*src & 0x3c) << 2);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t} // switch(count)\r\n\t} // end slow path\r\n\r\n}\r\n\r\nstatic void BltPack44(byte *dest, const byte *src, bool shift, unsigned count)\r\n{\r\n//\tRTIMING(\"BltPack44\");\r\n\tASSERT(count > 0);\r\n\tif(shift)\r\n\t{\r\n\t\tbyte c = *src++, d;\r\n\t\t*dest = (*dest & 0xF0) | (c >> 4);\r\n\t\tdest++;\r\n\t\tcount--;\r\n\t\twhile(count >= 8)\r\n\t\t{\r\n\t\t\td = src[0]; dest[0] = (c << 4) | (d >> 4);\r\n\t\t\tc = src[1]; dest[1] = (d << 4) | (c >> 4);\r\n\t\t\td = src[2]; dest[2] = (c << 4) | (d >> 4);\r\n\t\t\tc = src[3]; dest[3] = (d << 4) | (c >> 4);\r\n\t\t\tsrc += 4;\r\n\t\t\tdest += 4;\r\n\t\t\tcount -= 8;\r\n\t\t}\r\n\t\tif(count & 4)\r\n\t\t{\r\n\t\t\td = src[0]; dest[0] = (c << 4) | (d >> 4);\r\n\t\t\tc = src[1]; dest[1] = (d << 4) | (c >> 4);\r\n\t\t\tsrc += 2;\r\n\t\t\tdest += 2;\r\n\t\t}\r\n\t\tif(count & 2)\r\n\t\t{\r\n\t\t\td = src[0]; dest[0] = (c << 4) | (d >> 4);\r\n\t\t\tc = d;\r\n\t\t\tsrc++;\r\n\t\t\tdest++;\r\n\t\t}\r\n\t\tif(count & 1)\r\n\t\t\tdest[0] = (dest[0] & 15) | (c << 4);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tunsigned c2 = count >> 1;\r\n\t\tif(c2)\r\n\t\t\tmemcpy(dest, src, c2);\r\n\t\tif(count & 1)\r\n\t\t\tdest[c2] = (dest[c2] & 15) | (src[c2] & 0xF0);\r\n\t}\r\n}\r\n/*\r\nstatic void BltPack4(byte *dest, const byte *src, unsigned count)\r\n{\r\n#define BLT_PACK_4_4(o) dest[(o)] = src[4 * (o)]; dest[(o) + 1] = src[4 * (o) + 4]; \\\r\n\tdest[(o) + 2] = src[4 * (o) + 8]; dest[(o) + 3] = src[4 * (o) + 12];\r\n\tfor(unsigned rep = count >> 4; rep; rep--)\r\n\t{\r\n\t\tBLT_PACK_4_4(0) BLT_PACK_4_4(4) BLT_PACK_4_4(8) BLT_PACK_4_4(12)\r\n\t\tdest += 16;\r\n\t\tsrc += 4 * 16;\r\n\t}\r\n\tif(count & 8)\r\n\t{\r\n\t\tBLT_PACK_4_4(0) BLT_PACK_4_4(4)\r\n\t\tdest += 8;\r\n\t\tsrc += 4 * 8;\r\n\t}\r\n\tif(count & 4)\r\n\t{\r\n\t\tBLT_PACK_4_4(0)\r\n\t\tdest += 4;\r\n\t\tsrc += 4 * 4;\r\n\t}\r\n\tif(count & 2)\r\n\t{\r\n\t\tdest[0] = src[0]; dest[1] = src[4];\r\n\t\tdest += 2;\r\n\t\tsrc += 4 * 2;\r\n\t}\r\n\tif(count & 1)\r\n\t\tdest[0] = src[0];\r\n}\r\n*/\r\nstatic tsize_t ReadStream(thandle_t fd, tdata_t buf, tsize_t size)\r\n{\r\n\tStream *stream = reinterpret_cast<Stream *>(fd);\r\n\tif(!stream->IsOpen())\r\n\t\treturn 0;\r\n//\tRLOG(\"TiffStream::TIFRaster::Data & \" << (int)wrapper.stream.GetPos() << \", count = \" << size\r\n//\t\t<< \", end = \" << (int)(wrapper.stream.GetPos() + size));\r\n\treturn stream->Get(buf, size);\r\n}\r\n\r\nstatic tsize_t WriteStream(thandle_t fd, tdata_t buf, tsize_t size)\r\n{\r\n\tStream *stream = reinterpret_cast<Stream *>(fd);\r\n\tASSERT(stream->IsOpen());\r\n\tstream->Put(buf, size);\r\n\treturn stream->IsError() ? 0 : size;\r\n}\r\n\r\nstatic toff_t SeekStream(thandle_t fd, toff_t off, int whence)\r\n{\r\n\tStream *stream = reinterpret_cast<Stream *>(fd);\r\n\tASSERT(stream->IsOpen());\r\n\ttoff_t size = (toff_t)stream->GetSize();\r\n\ttoff_t destpos = (toff_t)(off + (whence == 1 ? stream->GetPos() : whence == 2 ? size : 0));\r\n\tstream->Seek(destpos);\r\n//\tRLOG(\"TIFRaster::Data::SeekStream -> \" << (int)off << \", whence = \" << whence << \" -> pos = \" << (int)wrapper.stream.GetPos());\r\n\treturn (toff_t)stream->GetPos();\r\n}\r\n\r\nstatic int CloseStream(thandle_t fd)\r\n{\r\n\treturn 0;\r\n}\r\n\r\nstatic int CloseOwnedStream(thandle_t fd)\r\n{\r\n\tdelete reinterpret_cast<Stream *>(fd);\r\n\treturn 0;\r\n}\r\n\r\nstatic toff_t SizeStream(thandle_t fd)\r\n{\r\n\tStream *stream = reinterpret_cast<Stream *>(fd);\r\n\tASSERT(stream->IsOpen());\r\n//\tRLOG(\"TIFRaster::Data::SizeStream -> \" << (int)wrapper.stream.GetSize());\r\n\treturn (toff_t)stream->GetSize();\r\n}\r\n\r\nstatic int MapStream(thandle_t fd, tdata_t *pbase, toff_t *psize)\r\n{\r\n\treturn 0;\r\n}\r\n\r\nstatic void UnmapStream(thandle_t fd, tdata_t base, toff_t size)\r\n{\r\n}\r\n\r\nstruct ::tiff *TIFFFileStreamOpen(const char *filename, const char *mode)\r\n{\r\n\tOne<FileStream> fs = new FileStream;\r\n\tint m = _TIFFgetMode(NULL, NULL, mode, \"TIFFOpen\");\r\n\tdword fmode = FileStream::READ;\r\n\r\n\tswitch(m) {\r\n\t\tcase O_RDONLY: {\r\n\t\t\tfmode = FileStream::READ;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase O_RDWR: {\r\n\t\t\tfmode = FileStream::READWRITE;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase O_RDWR|O_CREAT:\r\n\t\tcase O_RDWR|O_TRUNC:\r\n\t\tcase O_RDWR|O_CREAT|O_TRUNC: {\r\n\t\t\tfmode = FileStream::CREATE;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif(!fs->Open(filename, fmode))\r\n\t\treturn NULL;\r\n\treturn TIFFStreamOpen(filename, mode, fs.Detach(), true);\r\n}\r\n/*\r\n\r\nstruct ::tiff* TIFFWrapOpen(const char *filename, const char *mode){\r\n\treturn ::TIFFOpen(filename, mode);\r\n}\r\n\r\nint TIFFWrapGetField(::tiff* tif_data, uint32 tag, ...){\r\n\tva_list ap;\r\n\treturn ::TIFFGetField(tif_data, tag, ap);\r\n}\r\n*/\r\n\r\nstruct ::tiff *TIFFStreamOpen(const char *filename, const char *mode, Stream *stream, bool destruct)\r\n{\r\n\treturn TIFFClientOpen(filename, mode, reinterpret_cast<thandle_t>(stream),\r\n\t\t&ReadStream, &WriteStream,\r\n\t\t&SeekStream,\r\n\t\tdestruct ? &CloseOwnedStream : &CloseStream,\r\n\t\t&SizeStream,\r\n\t\t&MapStream, &UnmapStream);\r\n}\r\n\r\n\r\nstruct TIFRaster::Data : public TIFFRGBAImage {\r\n\tData(Stream& stream);\r\n\t~Data();\r\n\r\n\tbool             Create();\r\n\tRaster::Info     GetInfo();\r\n\tRaster::Line     GetLine(int i, Raster *owner);\r\n\tbool             SeekPage(int page);\r\n\tbool             FetchPage();\r\n\r\n\tstatic void      Warning(const char* module, const char* fmt, va_list ap);\r\n\tstatic void      Error(const char* module, const char* fmt, va_list ap);\r\n\r\n\tRasterFormat     format;\r\n\r\n\tStream&          stream;\r\n\tTIFF             *tiff;\r\n\r\n\tstruct Page {\r\n\t\tuint32       width, height;\r\n\t\tuint16       bits_per_sample;\r\n\t\tuint16       samples_per_pixel;\r\n\t\tuint16       photometric;\r\n\t\tuint16       orientation;\r\n\t\tSize         dot_size;\r\n\t\tbool         alpha;\r\n\t};\r\n\tArray<Page>      pages;\r\n\tint              page_index;\r\n\r\n\tVectorMap<String, Value> attr;\r\n\r\n\tbyte *MapDown(int x, int y, int count);\r\n\tbyte *MapUp(int x, int y, int count);\r\n\r\n\tSize size;\r\n\tint bpp;\r\n\tint row_bytes;\r\n\tint cache_size;\r\n\tbool alpha;\r\n\tbool page_open;\r\n\tbool page_fetched;\r\n\tbool page_error;\r\n\tVector<byte> imagebuf;\r\n\tstruct Row {\r\n\t\tRow() {}\r\n\r\n\t\tBuffer<byte> mapping;\r\n\t};\r\n\tenum { MAX_CACHE_SIZE = 50000000 };\r\n\tRGBA palette[256];\r\n\tint palette_count;\r\n\tBuffer<Row> rows;\r\n\tint64 mapping_offset;\r\n\tint mapping_size;\r\n\tVector<uint32_t> buffer;\r\n\ttileContigRoutine contig;\r\n\ttileSeparateRoutine separate;\r\n\tint skewfac;\r\n//\tvoid (*pack)(TIFFImageHelper *helper, uint32 x, uint32 y, uint32 w, uint32 h);\r\n//\tString warnings;\r\n//\tString errors;\r\n};\r\n\r\nextern \"C\" {\r\n\r\nTIFFErrorHandler _TIFFwarningHandler = TIFRaster::Data::Warning;\r\nTIFFErrorHandler _TIFFerrorHandler   = TIFRaster::Data::Error;\r\n\r\n};\r\n\r\nstatic void packTileRGB(TIFRaster::Data *helper, uint32 x, uint32 y, uint32 w, uint32 h)\r\n{\r\n\tif(helper->alpha) {\r\n\t\tint x4 = 4 * x, w4 = 4 * w;\r\n\t//\tbyte *dest = helper->dest.GetUpScan(y) + 3 * x;\r\n\t\tconst byte *src = (const byte *)helper->buffer.Begin();\r\n\t//\tunsigned srow = sizeof(uint32) * w; //, drow = helper->dest.GetUpRowBytes();\r\n\t\tfor(; h; h--, /*src += srow,*/ /*dest += drow*/ y++) {\r\n\t\t\tfor(byte *dest = helper->MapUp(x4, y, w4), *end = dest + w4; dest < end; dest += 4, src += 4) {\r\n\t\t\t\tdest[0] = src[2];\r\n\t\t\t\tdest[1] = src[1];\r\n\t\t\t\tdest[2] = src[0];\r\n\t\t\t\tdest[3] = src[3];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tint x3 = 3 * x, w3 = 3 * w;\r\n\t//\tbyte *dest = helper->dest.GetUpScan(y) + 3 * x;\r\n\t\tconst byte *src = (const byte *)helper->buffer.Begin();\r\n\t//\tunsigned srow = sizeof(uint32) * w; //, drow = helper->dest.GetUpRowBytes();\r\n\t\tfor(; h; h--, /*src += srow,*/ /*dest += drow*/ y++) {\r\n\t\t\tfor(byte *dest = helper->MapUp(x3, y, w3), *end = dest + w3; dest < end; dest += 3, src += 4) {\r\n\t\t\t\tdest[0] = src[2];\r\n\t\t\t\tdest[1] = src[1];\r\n\t\t\t\tdest[2] = src[0];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic void putContig1(TIFFRGBAImage *img, tif_uint32 *cp,\r\n\ttif_uint32 x, tif_uint32 y, tif_uint32 w, tif_uint32 h,\r\n\ttif_int32 fromskew, tif_int32 toskew, byte *pp)\r\n{\r\n\tTIFRaster::Data *helper = (TIFRaster::Data *)img;\r\n//\tSize size = helper->size;\r\n\tint iw = toskew + w;\r\n\tbool keep_y = (iw >= 0);\r\n\tint x8 = x >> 3;\r\n\tint w8 = ((x + w + 7) >> 3) - x8;\r\n\tbool read = !!((x | w) & 7) && (int)w < helper->size.cx;\r\n//\tbyte *dest = helper->dest.GetUpScan(y) + (x >> 3);\r\n//\tint drow = (keep_y ? helper->dest.GetUpRowBytes() : -helper->dest.GetUpRowBytes());\r\n\tint drow = keep_y ? 1 : -1;\r\n\tconst byte *src = pp;\r\n\tint srow = (fromskew + w - 1) / helper->skewfac + 1;\r\n\tfor(; h; h--, y += drow /*dest += drow*/, src += srow)\r\n\t\tBltPack11(helper->MapUp(x8, y, w8), src, (byte)(x & 7), w);\r\n}\r\n\r\nstatic void putContig2(TIFFRGBAImage *img, tif_uint32 *cp,\r\n\ttif_uint32 x, tif_uint32 y, tif_uint32 w, tif_uint32 h,\r\n\ttif_int32 fromskew, tif_int32 toskew, byte *pp)\r\n{\r\n\tTIFRaster::Data *helper = (TIFRaster::Data *)img;\r\n//\tSize size = helper->size;\r\n\tint iw = toskew + w;\r\n\tbool keep_y = (iw >= 0);\r\n\tint x4 = x >> 2;\r\n\tint w4 = ((x + w + 3) >> 2) - x4;\r\n\tbool read = !!((x | w) & 3) && (int)w < helper->size.cx;\r\n//\tbyte *dest = helper->dest.GetUpScan(y) + (x >> 3);\r\n//\tint drow = (keep_y ? helper->dest.GetUpRowBytes() : -helper->dest.GetUpRowBytes());\r\n\tint drow = keep_y ? 1 : -1;\r\n\tconst byte *src = pp;\r\n\tint srow = (fromskew + w - 1) / helper->skewfac + 1;\r\n\tfor(; h; h--, y += drow /*dest += drow*/, src += srow)\r\n\t\tBltPack22(helper->MapUp(x4, y, w4), src, (byte)(x & 3), w);\r\n}\r\n\r\nstatic void putContig4(TIFFRGBAImage *img, tif_uint32 *cp,\r\n\ttif_uint32 x, tif_uint32 y, tif_uint32 w, tif_uint32 h,\r\n\ttif_int32 fromskew, tif_int32 toskew, byte *pp)\r\n{\r\n\tTIFRaster::Data *helper = (TIFRaster::Data *)img;\r\n//\tSize size = helper->size; //dest.GetSize();\r\n\tint iw = toskew + w;\r\n\tbool keep_y = (iw >= 0);\r\n\tint x2 = x >> 1;\r\n\tint w2 = ((x + w + 1) >> 1) - x2;\r\n\tbool read = !!((x | w) & 1) && (int)w < helper->size.cx;\r\n//\tbyte *dest = helper->dest.GetUpScan(y) + (x >> 1);\r\n\tbool shift = (x & 1);\r\n//\tint drow = (keep_y ? helper->dest.GetUpRowBytes() : -helper->dest.GetUpRowBytes());\r\n\tint drow = (keep_y ? 1 : -1);\r\n\tconst byte *src = pp;\r\n\tint srow = (fromskew + w - 1) / helper->skewfac + 1;\r\n\tfor(; h; h--, y /*dest*/ += drow, src += srow)\r\n\t\tBltPack44(helper->MapUp(x2, y, w2), src, shift, w);\r\n}\r\n\r\nstatic void putContig8(TIFFRGBAImage *img, tif_uint32 *cp,\r\n\ttif_uint32 x, tif_uint32 y, tif_uint32 w, tif_uint32 h,\r\n\ttif_int32 fromskew, tif_int32 toskew, byte *pp)\r\n{\r\n\tTIFRaster::Data *helper = (TIFRaster::Data *)img;\r\n//\tSize size = helper->size;\r\n\tint iw = toskew + w;\r\n\tbool keep_y = (iw >= 0);\r\n//\tbyte *dest = helper->dest.GetUpScan(y) + x;\r\n//\tint drow = (keep_y ? helper->dest.GetUpRowBytes() : -helper->dest.GetUpRowBytes());\r\n\tint drow = (keep_y ? 1 : -1);\r\n\tconst byte *src = pp;\r\n\tint srow = (fromskew + w - 1) / helper->skewfac + 1;\r\n\tfor(; h; h--, y /*dest*/ += drow, src += srow)\r\n\t\tmemcpy(helper->MapUp(x, y, w), src, w);\r\n}\r\n\r\nstatic void putContigRGB(TIFFRGBAImage *img, tif_uint32 *cp, tif_uint32 x, tif_uint32 y, tif_uint32 w, tif_uint32 h,\r\n\ttif_int32 fromskew, tif_int32 toskew, byte *pp)\r\n{\r\n\tTIFRaster::Data *helper = (TIFRaster::Data *)img;\r\n//\tSize size = helper->size;\r\n\tint iw = toskew + w;\r\n\tint wh = w * h;\r\n\tif(wh > helper->buffer.GetCount())\r\n\t\thelper->buffer.SetCount(wh);\r\n\tbool keep_y = (iw >= 0);\r\n\thelper->contig(img, (tif_uint32 *)(keep_y ? &helper->buffer[0] : &helper->buffer[0] + w * (h - 1)),\r\n\t\t0, 0, w, h, fromskew, keep_y ? 0 : -2 * (int)w, pp);\r\n\tpackTileRGB(helper, x, keep_y ? y : y - h + 1, w, h);\r\n}\r\n\r\nstatic void putSeparate(TIFFRGBAImage *img, tif_uint32 *cp,\r\n\ttif_uint32 x, tif_uint32 y, tif_uint32 w, tif_uint32 h,\r\n\ttif_int32 fromskew, tif_int32 toskew, byte *r, byte *g, byte *b, byte *a)\r\n{\r\n\tTIFRaster::Data *helper = (TIFRaster::Data *)img;\r\n//\tSize size = helper->size;\r\n\tint wh = w * h;\r\n\tif(wh > helper->buffer.GetCount())\r\n\t\thelper->buffer.SetCount(wh);\r\n\tint iw = toskew + w;\r\n\tbool keep_y = (iw >= 0);\r\n\thelper->separate(img, (tif_uint32 *)(keep_y ? &helper->buffer[0] : &helper->buffer[0] + w * (h - 1)),\r\n\t\t0, 0, w, h, fromskew, keep_y ? 0 : -2 * (int)w, r, g, b, a);\r\n\tpackTileRGB(helper, x, keep_y ? y : y - h + 1, w, h);\r\n}\r\n\r\nbyte *TIFRaster::Data::MapUp(int x, int y, int count)\r\n{\r\n\treturn MapDown(x, size.cy - 1 - y, count);\r\n}\r\n\r\nbyte *TIFRaster::Data::MapDown(int x, int y, int count)\r\n{\r\n\treturn &imagebuf[row_bytes * y] + x;\r\n}\r\n\r\nvoid TIFRaster::Data::Warning(const char *fn, const char *fmt, va_list ap)\r\n{\r\n\tif(!memcmp(fn, \"tiff@\", 5) && IsDigit(fn[5])) {\r\n\t\tint addr = stou(fn + 5);\r\n\t\tif(addr != -1 && addr != 0) {\r\n//\t\t\tTIFRaster::Data& wrapper = *reinterpret_cast<TIFRaster::Data *>(addr);\r\n\t\t\tLLOG(\"TIF warning: \" << VFormat(fmt, ap));\r\n//\t\t\tRLOG(\"TiffWrapper::Warning: \" << wrapper.errors);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid TIFRaster::Data::Error(const char *fn, const char *fmt, va_list ap)\r\n{\r\n\tif(!memcmp(fn, \"tiff@\", 5) && IsDigit(fn[5])) {\r\n\t\tint addr = stou(fn + 5);\r\n\t\tif(addr != -1 && addr != 0) {\r\n//\t\t\tData& wrapper = *reinterpret_cast<Data *>(addr);\r\n\t\t\tLLOG(\"TIF error: \" << VFormat(fmt, ap));\r\n//\t\t\tRLOG(\"TiffWrapper::Error: \" << wrapper.errors);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nTIFRaster::Data::Data(Stream& stream)\r\n: stream(stream)\r\n{\r\n\ttiff = NULL;\r\n\tpage_index = 0;\r\n\tcache_size = 0;\r\n\tpage_open = false;\r\n\tpage_fetched = false;\r\n\tpage_error = false;\r\n}\r\n\r\nTIFRaster::Data::~Data()\r\n{\r\n\tif(tiff) {\r\n\t\tif(page_open)\r\n\t\t\tTIFFRGBAImageEnd(this);\r\n\t\tTIFFClose(tiff);\r\n\t}\r\n}\r\n\r\nbool TIFRaster::Data::Create()\r\n{\r\n\tTIFFSetErrorHandler(NULL);\r\n\tTIFFSetErrorHandlerExt(NULL);\r\n\tTIFFSetWarningHandler(NULL);\r\n\tTIFFSetWarningHandlerExt(NULL);\r\n\r\n\ttiff = TIFFStreamOpen(\"tiff@\" + Format64((intptr_t)this), \"r\", &stream);\r\n\tif(!tiff)\r\n\t\treturn false;\r\n\r\n\tint count = TIFFNumberOfDirectories(tiff);\r\n\tif(count <= 0)\r\n\t\treturn false;\r\n\tfor(int i = 0; i < count; i++) {\r\n\t\tPage& page = pages.Add();\r\n\t\tTIFFSetDirectory(tiff, i);\r\n\t\tTIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &page.width);\r\n\t\tTIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &page.height);\r\n\t\tfloat xres, yres;\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_XRESOLUTION, &xres);\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_YRESOLUTION, &yres);\r\n\t\tuint16 resunit;\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_RESOLUTIONUNIT, &resunit);\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_BITSPERSAMPLE, &page.bits_per_sample);\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLESPERPIXEL, &page.samples_per_pixel);\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_PHOTOMETRIC, &page.photometric);\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_ORIENTATION, &page.orientation);\r\n\t\tdouble dots_per_unit = (resunit == RESUNIT_INCH ? 600.0 : resunit == RESUNIT_CENTIMETER\r\n\t\t\t? 600.0 / 2.54 : 0);\r\n\t\tpage.dot_size.cx = (xres ? fround(page.width * dots_per_unit / xres) : 0);\r\n\t\tpage.dot_size.cy = (yres ? fround(page.height * dots_per_unit / yres) : 0);\r\n\t\tpage.alpha = false;\r\n\t\tuint16 extrasamples, *sampletypes;\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_EXTRASAMPLES, &extrasamples, &sampletypes);\r\n\t\tfor(int e = 0; e < extrasamples; e++)\r\n\t\t\tif(sampletypes[e] == EXTRASAMPLE_ASSOCALPHA) {\r\n\t\t\t\tpage.alpha = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\r\n\t\tif(i == 0) {\r\n\t\t\tconst word TIFFTAG_GEOPIXELSCALE = 33550,\r\n\t\t\t           TIFFTAG_GEOTIEPOINTS = 33922,\r\n\t\t\t           TIFFTAG_GEOTRANSMATRIX = 34264,\r\n\t\t\t           TIFFTAG_GEOKEYDIRECTORY = 34735,\r\n\t\t\t           TIFFTAG_GEODOUBLEPARAMS = 34736,\r\n\t\t\t           TIFFTAG_GEOASCIIPARAMS = 34737;\r\n\r\n\t\t\tword count = 0;\r\n\t\t\tword *geokeys = nullptr;\r\n\t\t\tbool pixel_is_area = true; // Default is true, usually only DTM/DEM use 'RasterPixelIsPoint' and generally include the GeoKey in such case\r\n\r\n\t\t\tint dpc = 0;\r\n\t\t\tdouble *doubleparams = 0;\r\n\r\n\t\t\tint apc = 0;\r\n\t\t\tchar *asciiparams = 0;\r\n\r\n\t\t\tTIFFGetField(tiff, TIFFTAG_GEODOUBLEPARAMS, &dpc, &doubleparams);\r\n\t\t\tTIFFGetField(tiff, TIFFTAG_GEOASCIIPARAMS, &apc, &asciiparams);\r\n\r\n\t\t\tif(TIFFGetField(tiff, TIFFTAG_GEOKEYDIRECTORY, &count, &geokeys) &&\r\n\t\t\t\tcount >= 4 && (count % 4) == 0 && geokeys[0] == 1)\r\n\t\t\t\tfor(int i = 4; i + 3 < count; i += 4) {\r\n\t\t\t\t\tconst word GTRasterTypeGeoKey = 1025,\r\n\t\t\t\t\t           RasterPixelIsArea = 1,\r\n\t\t\t\t\t           GeographicTypeGeoKey = 2048,\r\n\t\t\t\t\t           ProjectedCSTypeGeoKey = 3072;\r\n\r\n\t\t\t\t\tword value = geokeys[i + 3];\r\n\r\n\t\t\t\t\tswitch(geokeys[i]) {\r\n\t\t\t\t\tcase GTRasterTypeGeoKey:\r\n\t\t\t\t\t\tpixel_is_area = value == RasterPixelIsArea;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase GeographicTypeGeoKey:\r\n\t\t\t\t\tcase ProjectedCSTypeGeoKey:\r\n\t\t\t\t\t\tattr.GetAdd(\"epsg\") = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tswitch(geokeys[i+1]){ // by type\r\n\t\t\t\t\t\tcase TIFFTAG_GEOASCIIPARAMS:\r\n\t\t\t\t\t\t\tif(geokeys[i+3]<=apc) attr.GetAdd(Format(\"GK%d\",geokeys[i])) = Value(String(&asciiparams[geokeys[i+3]],geokeys[i+2]));\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase TIFFTAG_GEODOUBLEPARAMS:\r\n\t\t\t\t\t\t\tif(geokeys[i+3]<=dpc) attr.GetAdd(Format(\"GK%d\",geokeys[i])) = Value(doubleparams[geokeys[i+3]]);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tattr.GetAdd(Format(\"GK%d\",geokeys[i])) = Value(geokeys[i+3]);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\tdouble geomatrix[6];\r\n\t        geomatrix[0] = 0.0;\r\n\t        geomatrix[1] = 1.0;\r\n\t        geomatrix[2] = 0.0;\r\n\t        geomatrix[3] = 0.0;\r\n\t        geomatrix[4] = 0.0;\r\n\t        geomatrix[5] = 1.0;\r\n\t        \r\n\t        auto AdjustMatrixOrientation = [&](double dx, double dy) {\r\n\t\t\t\tgeomatrix[0] += (geomatrix[1] * dx + geomatrix[2] * dy);\r\n\t\t\t\tgeomatrix[3] += (geomatrix[4] * dx + geomatrix[5] * dy);\r\n\t\t\t\tif(dx!=0){\r\n\t\t\t\t\tgeomatrix[1] = -geomatrix[1];\r\n\t\t\t\t\tgeomatrix[4] = -geomatrix[4];\r\n\t\t\t\t}\r\n\t\t\t\tif(dy!=0){\r\n\t\t\t\t\tgeomatrix[2] = -geomatrix[2];\r\n\t\t\t\t\tgeomatrix[5] = -geomatrix[5];\r\n\t\t\t\t}\r\n\t        };\r\n\t        \r\n\t\t\tauto NormalizeOrientation = [&] {\r\n\t\t\t\tif(!pixel_is_area) {\r\n\t\t\t\t\tgeomatrix[0] -= (geomatrix[1] * 0.5 + geomatrix[2] * 0.5);\r\n\t\t\t\t\tgeomatrix[3] -= (geomatrix[4] * 0.5 + geomatrix[5] * 0.5);\r\n\t\t\t\t}\r\n\t\t\t\tif(page.orientation>=5){\r\n\t\t\t\t\tSwap(geomatrix[1],geomatrix[2]);\r\n\t\t\t\t\tSwap(geomatrix[4],geomatrix[5]);\r\n\t\t\t\t}\r\n\t\t\t\tswitch(page.orientation){\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(page.width, 0);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(page.width, page.height);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(0, page.height);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 6:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(page.height, 0);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 7:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(page.height, page.width);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 8:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(0, page.width);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t// TIFF orientations:\r\n\t\t\t\t// 1 = FLIP_MIRROR_VERT,\r\n\t\t\t\t// 2 = FLIP_ROTATE_180,\r\n\t\t\t\t// 3 = FLIP_MIRROR_HORZ,\r\n\t\t\t\t// 4 = FLIP_NONE,\r\n\t\t\t\t// 5 = FLIP_ROTATE_CLOCKWISE,\r\n\t\t\t\t// 6 = FLIP_TRANSPOSE,\r\n\t\t\t\t// 7 = FLIP_ROTATE_ANTICLOCKWISE,\r\n\t\t\t\t// 8 = FLIP_TRANSVERSE,\r\n\t\t\t};\r\n\t    \r\n\t        double  *data;\r\n\t        auto FinishMatrix = [&] {\r\n\t\t\t\tValueArray va;\r\n\t\t\t\tfor(int i = 0; i < 6; i++)\r\n\t\t\t\t\tva << geomatrix[i];\r\n\t\t\t\tattr.GetAdd(\"geo_matrix\") = va;\r\n\t        };\r\n\t        \r\n\t\t\tif(TIFFGetField(tiff, TIFFTAG_GEOTRANSMATRIX, &count, &data) && count == 16) {\r\n\t\t\t\tgeomatrix[0] = data[3];\r\n\t\t\t\tgeomatrix[1] = data[0];\r\n\t\t\t\tgeomatrix[2] = data[1];\r\n\t\t\t\tgeomatrix[3] = data[7];\r\n\t\t\t\tgeomatrix[4] = data[4];\r\n\t\t\t\tgeomatrix[5] = data[5];\r\n\r\n\t\t\t\tNormalizeOrientation();\r\n\t\t\t\tFinishMatrix();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\tif(TIFFGetField(tiff, TIFFTAG_GEOTIEPOINTS, &count, &data) && count >= 6) {\r\n\t\t\t\tif(count>=18){ // 3 tiepoints needed for Xform2D::Map()\r\n\t\t\t\t\tfor(int t=0; t<count; t+=6){\r\n\t\t\t\t\t\tif(page.orientation>=5) Swap(data[t + 0], data[t + 1]);\r\n\t\t\t\t\t\tswitch(page.orientation){\r\n\t\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\t\tdata[t + 0] = page.width - data[t + 0];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\t\tdata[t + 0] = page.width - data[t + 0];\r\n\t\t\t\t\t\t\t\tdata[t + 1] = page.height - data[t + 1];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\t\tdata[t + 1] = page.height - data[t + 1];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 5:\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 6:\r\n\t\t\t\t\t\t\t\tdata[t + 0] = page.height - data[t + 0];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 7:\r\n\t\t\t\t\t\t\t\tdata[t + 0] = page.height - data[t + 0];\r\n\t\t\t\t\t\t\t\tdata[t + 1] = page.width - data[t + 1];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 8:\r\n\t\t\t\t\t\t\t\tdata[t + 1] = page.width - data[t + 1];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tXform2D xf = Xform2D::Map(Pointf(data[0],data[1]),Pointf(data[6+0],data[6+1]),Pointf(data[12+0],data[12+1]),\r\n\t\t\t\t\t\t\t\t\t\t\t\tPointf(data[3],data[4]),Pointf(data[6+3],data[6+4]),Pointf(data[12+3],data[12+4]));\r\n\r\n\t\t\t\t\tgeomatrix[0] = xf.t.x;\r\n\t\t\t\t\tgeomatrix[1] = xf.x.x;\r\n\t\t\t\t\tgeomatrix[2] = xf.y.x;\r\n\t\t\t\t\tgeomatrix[3] = xf.t.y;\r\n\t\t\t\t\tgeomatrix[4] = xf.x.y;\r\n\t\t\t\t\tgeomatrix[5] = xf.y.y;\r\n\r\n\t\t\t\t\tif(!pixel_is_area) {\r\n\t\t\t\t\t\tgeomatrix[0] -= (geomatrix[1] * 0.5 + geomatrix[2] * 0.5);\r\n\t\t\t\t\t\tgeomatrix[3] -= (geomatrix[4] * 0.5 + geomatrix[5] * 0.5);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tFinishMatrix();\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tdouble x = data[0];\r\n\t\t\t\t\tdouble y = data[1];\r\n\t\t\t\t\tdouble e = data[3];\r\n\t\t\t\t\tdouble n = data[4];\r\n\r\n\t\t\t\t\tif(TIFFGetField(tiff, TIFFTAG_GEOPIXELSCALE, &count, &data) && count >= 2 && data[0] && data[1]) {\r\n\t\t\t\t\t\tdouble dx = data[0];\r\n\t\t\t\t\t\tdouble dy = -abs(data[1]);\r\n\r\n\t\t\t\t\t\tgeomatrix[0] = e - x * dx;\r\n\t\t\t\t\t\tgeomatrix[1] = dx;\r\n\t\t\t\t\t\tgeomatrix[2] = 0;\r\n\t\t\t\t\t\tgeomatrix[3] = n - y * dy;\r\n\t\t\t\t\t\tgeomatrix[4] = 0;\r\n\t\t\t\t\t\tgeomatrix[5] = dy;\r\n\r\n\t\t\t\t\t\tNormalizeOrientation();\r\n\t\t\t\t\t\tFinishMatrix();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(TIFFGetField(tiff, 42113, &count, &data) && // TIFFTAG_GDAL_NODATA = 42113\r\n\t\t\t\tcount >= 1){\r\n\t\t\t\t\tattr.GetAdd(\"nodata\") = String((const char*)data, count);\r\n\t\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\treturn SeekPage(0);\r\n}\r\n\r\nbool TIFRaster::Data::SeekPage(int pgx)\r\n{\r\n\tif(page_open) {\r\n\t\tTIFFRGBAImageEnd(this);\r\n\t\tpage_open = false;\r\n\t}\r\n\r\n\tASSERT(pgx >= 0 && pgx < pages.GetCount());\r\n\tpage_index = pgx;\r\n\tpage_error = false;\r\n\tTIFFSetDirectory(tiff, page_index);\r\n\r\n\tchar emsg[1024];\r\n\tif(!TIFFRGBAImageBegin(this, tiff, 0, emsg)) {\r\n\t\tTIFFError(TIFFFileName(tiff), \"%s\", emsg);\r\n\t\tpage_error = true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tpage_open = true;\r\n\tconst Page& page = pages[page_index];\r\n\r\n\tsize = Size(page.width, page.height);\r\n\tif(isContig) {\r\n\t\tcontig = put.contig;\r\n\t\tput.contig = putContigRGB;\r\n\t}\r\n\telse {\r\n\t\tseparate = put.separate;\r\n\t\tput.separate = putSeparate;\r\n\t}\r\n\t\r\n\tattr.GetAdd(\"BITSPERSAMPLE\") = page.bits_per_sample;\r\n\tattr.GetAdd(\"SAMPLESPERPIXEL\") = page.samples_per_pixel;\r\n\tattr.GetAdd(\"PHOTOMETRIC\") = page.photometric;\r\n\tattr.GetAdd(\"tiff_orientation\") = Value((int)page.orientation);\r\n\r\n\talpha = page.alpha;\r\n\tif(alpha) {\r\n\t\tformat.Set32le(0xFF << 16, 0xFF << 8, 0xFF, 0xFF << 24);\r\n\t\tbpp = 32;\r\n\t}\r\n\telse {\r\n\t\tformat.Set24le(0xFF << 16, 0xFF << 8, 0xFF);\r\n\t\tbpp = 24;\r\n\t}\r\n\tpalette_count = 0;\r\n\tif(isContig\t&& (photometric == PHOTOMETRIC_PALETTE\r\n\t|| photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK)\r\n\t&& (bitspersample == 1 || bitspersample == 2 || bitspersample == 4 || bitspersample == 8)) {\r\n\t\tbpp = 8;\r\n\t\ttif_uint32 **ppal = (photometric == PHOTOMETRIC_PALETTE ? PALmap : BWmap);\r\n\t\tASSERT(ppal);\r\n//\t\tbyte rshift = 8 - img.bitspersample;\r\n\t\tpalette_count = 1 << min<int>(bitspersample, 8);\r\n\t\tbyte mask = (1 << bitspersample) - 1;\r\n\t\tint part_last = 8 / bitspersample - 1;\r\n\t\tint i;\r\n\t\tfor(i = 0; i <= mask; i++) {\r\n\t\t\tuint32 rgba = ppal[i][part_last];\r\n\t\t\tpalette[i].r = (byte)TIFFGetR(rgba);\r\n\t\t\tpalette[i].g = (byte)TIFFGetG(rgba);\r\n\t\t\tpalette[i].b = (byte)TIFFGetB(rgba);\r\n\t\t\tpalette[i].a = 255;\r\n\t\t}\r\n\t\tput.contig = putContig8;\r\n\t\tswitch(bitspersample) {\r\n\t\tcase 1: bpp = 1; put.contig = putContig1; format.Set1mf(); break;\r\n\t\tcase 2: bpp = 2; put.contig = putContig2; format.Set2mf(); break;\r\n\t\tcase 4: bpp = 4; put.contig = putContig4; format.Set4mf(); break;\r\n\t\tcase 8: format.Set8(); break;\r\n\t\tdefault: NEVER();\r\n\t\t}\r\n\t\tskewfac = 8 / bitspersample;\r\n\t}\r\n\trow_bytes = (bpp * width + 31) >> 5 << 2;\r\n\r\n\tpage_fetched = false;\r\n\treturn true;\r\n}\r\n\r\nbool TIFRaster::Data::FetchPage()\r\n{\r\n\tif(page_error)\r\n\t\treturn false;\r\n\tif(page_fetched)\r\n\t\treturn true;\r\n\r\n\tcache_size = 0;\r\n\trows.Clear();\r\n\tint64 bytes = row_bytes * (int64)height;\r\n\timagebuf.SetCount(size.cy * row_bytes, 0);\r\n\treq_orientation = pages[page_index].orientation;\r\n\r\n\tbool res = TIFFRGBAImageGet(this, 0, width, height);\r\n\tTIFFRGBAImageEnd(this);\r\n\tpage_open = false;\r\n\r\n\tpage_fetched = true;\r\n\treturn true;\r\n}\r\n\r\nRaster::Info TIFRaster::Data::GetInfo()\r\n{\r\n\tconst Page& page = pages[page_index];\r\n\tRaster::Info out;\r\n\tout.kind = (page.alpha ? IMAGE_ALPHA : IMAGE_OPAQUE);\r\n\tout.bpp = bpp;\r\n\tout.colors = 0;\r\n\tout.dots = page.dot_size;\r\n\tout.hotspot = Null;\r\n\tconst int info_orientation[] = { FLIP_NONE, FLIP_MIRROR_VERT, FLIP_ROTATE_180, FLIP_MIRROR_HORZ, FLIP_NONE, FLIP_ROTATE_CLOCKWISE, FLIP_TRANSPOSE, FLIP_ROTATE_ANTICLOCKWISE, FLIP_TRANSVERSE, FLIP_NONE}; // Map from TIFFTAG_ORIENTATION to U++ orientation\r\n\tout.orientation = info_orientation[min((int)page.orientation,9)];\r\n\treturn out;\r\n}\r\n\r\nRaster::Line TIFRaster::Data::GetLine(int line, Raster *raster)\r\n{\r\n\tif(!page_error && !page_fetched)\r\n\t\tFetchPage();\r\n\tif(page_error) {\r\n\t\tbyte *tmp = new byte[row_bytes];\r\n\t\tmemset(tmp, 0, row_bytes);\r\n\t\treturn Raster::Line(tmp, raster, true);\r\n\t}\r\n\tif(!imagebuf.IsEmpty())\r\n\t\treturn Raster::Line(&imagebuf[row_bytes * line], raster, false);\r\n\tconst byte *data = MapDown(0, line, row_bytes);\r\n\tbyte *tmp = new byte[row_bytes];\r\n\tmemcpy(tmp, data, row_bytes);\r\n\treturn Raster::Line(tmp, raster, true);\r\n}\r\n\r\nTIFRaster::TIFRaster()\r\n{\r\n}\r\n\r\nTIFRaster::~TIFRaster()\r\n{\r\n}\r\n\r\nbool TIFRaster::Create()\r\n{\r\n\tdata = new Data(GetStream());\r\n\treturn data->Create();\r\n}\r\n\r\nSize TIFRaster::GetSize()\r\n{\r\n\treturn data->size;\r\n}\r\n\r\nRaster::Info TIFRaster::GetInfo()\r\n{\r\n\treturn data->GetInfo();\r\n}\r\n\r\nRaster::Line TIFRaster::GetLine(int line)\r\n{\r\n\treturn data->GetLine(line, this);\r\n}\r\n\r\nint TIFRaster::GetPaletteCount()\r\n{\r\n\treturn data->palette_count;\r\n}\r\n\r\nconst RGBA *TIFRaster::GetPalette()\r\n{\r\n\treturn data->palette;\r\n}\r\n\r\nconst RasterFormat *TIFRaster::GetFormat()\r\n{\r\n\treturn &data->format;\r\n}\r\n\r\nint TIFRaster::GetPageCount()\r\n{\r\n\treturn data->pages.GetCount();\r\n}\r\n\r\nint TIFRaster::GetActivePage() const\r\n{\r\n\treturn data->page_index;\r\n}\r\n\r\nvoid TIFRaster::SeekPage(int n)\r\n{\r\n\tdata->SeekPage(n);\r\n}\r\n\r\nValue TIFRaster::GetMetaData(String id)\r\n{\r\n\treturn data->attr.Get(id, Value());\r\n}\r\n\r\nvoid TIFRaster::EnumMetaData(Vector<String>& id_list)\r\n{\r\n\tid_list = clone(data->attr.GetKeys());\r\n}\r\n\r\nclass TIFEncoder::Data {\r\npublic:\r\n\tData(Stream& stream, RasterFormat& format);\r\n\t~Data();\r\n\r\n\tvoid             Start(Size size, Size dots, int bpp, const RGBA *palette);\r\n\tvoid             WriteLineRaw(const byte *line);\r\n\r\nprivate:\r\n\tStream&          stream;\r\n\tTIFF             *tiff;\r\n\tSize             size;\r\n\tint              bpp;\r\n\tconst RGBA       *palette;\r\n\tVector<byte>     rowbuf;\r\n\tint              linebytes;\r\n\tRasterFormat&    format;\r\n\tint              line;\r\n\r\n\tstatic tsize_t   ReadStream(thandle_t fd, tdata_t buf, tsize_t size);\r\n\tstatic tsize_t   WriteStream(thandle_t fd, tdata_t buf, tsize_t size);\r\n\tstatic toff_t    SeekStream(thandle_t fd, toff_t off, int whence);\r\n\tstatic int       CloseStream(thandle_t fd);\r\n\tstatic toff_t    SizeStream(thandle_t fd);\r\n\tstatic int       MapStream(thandle_t fd, tdata_t *pbase, toff_t *psize);\r\n\tstatic void      UnmapStream(thandle_t fd, tdata_t base, toff_t size);\r\n};\r\n\r\nTIFEncoder::Data::Data(Stream& stream, RasterFormat& format)\r\n: stream(stream), format(format)\r\n{\r\n\ttiff = NULL;\r\n}\r\n\r\nTIFEncoder::Data::~Data()\r\n{\r\n\tif(tiff) TIFFClose(tiff);\r\n}\r\n\r\ntsize_t TIFEncoder::Data::ReadStream(thandle_t fd, tdata_t buf, tsize_t size)\r\n{\r\n\tData& wrapper = *reinterpret_cast<Data *>(fd);\r\n\tASSERT(wrapper.stream.IsOpen());\r\n//\tRLOG(\"TiffStream::ReadStream & \" << (int)wrapper.stream.GetPos() << \", count = \" << size\r\n//\t\t<< \", end = \" << (int)(wrapper.stream.GetPos() + size));\r\n\treturn wrapper.stream.Get(buf, size);\r\n\treturn 0;\r\n}\r\n\r\ntsize_t TIFEncoder::Data::WriteStream(thandle_t fd, tdata_t buf, tsize_t size)\r\n{\r\n\tData& wrapper = *reinterpret_cast<Data *>(fd);\r\n\tASSERT(wrapper.stream.IsOpen());\r\n//\tRLOG(\"TIFRaster::Data::WriteStream & \" << (int)wrapper.stream.GetPos() << \", count = \" << (int)size\r\n//\t\t<< \", end = \" << (int)(wrapper.stream.GetPos() + size));\r\n\twrapper.stream.Put(buf, size);\r\n\treturn size;\r\n}\r\n\r\ntoff_t TIFEncoder::Data::SeekStream(thandle_t fd, toff_t off, int whence)\r\n{\r\n\tData& wrapper = *reinterpret_cast<Data *>(fd);\r\n\tASSERT(wrapper.stream.IsOpen());\r\n\ttoff_t size = (toff_t)wrapper.stream.GetSize();\r\n\ttoff_t destpos = (toff_t)(off + (whence == 1 ? wrapper.stream.GetPos() : whence == 2 ? size : 0));\r\n\tif(destpos > size) {\r\n\t\twrapper.stream.Seek(size);\r\n\t\twrapper.stream.Put((int)0, (int)(destpos - size));\r\n\t}\r\n\telse\r\n\t\twrapper.stream.Seek(destpos);\r\n//\tRLOG(\"TIFRaster::Data::SeekStream -> \" << (int)off << \", whence = \" << whence << \" -> pos = \" << (int)wrapper.stream.GetPos());\r\n\treturn (toff_t)wrapper.stream.GetPos();\r\n}\r\n\r\nint TIFEncoder::Data::CloseStream(thandle_t fd)\r\n{\r\n\treturn 0;\r\n}\r\n\r\ntoff_t TIFEncoder::Data::SizeStream(thandle_t fd)\r\n{\r\n\tData& wrapper = *reinterpret_cast<Data *>(fd);\r\n\tASSERT(wrapper.stream.IsOpen());\r\n//\tRLOG(\"TIFRaster::Data::SizeStream -> \" << (int)wrapper.stream.GetSize());\r\n\treturn (toff_t)wrapper.stream.GetSize();\r\n}\r\n\r\nint TIFEncoder::Data::MapStream(thandle_t fd, tdata_t *pbase, toff_t *psize)\r\n{\r\n\treturn 0;\r\n}\r\n\r\nvoid TIFEncoder::Data::UnmapStream(thandle_t fd, tdata_t base, toff_t size)\r\n{\r\n}\r\n\r\nvoid TIFEncoder::Data::Start(Size sz, Size dots, int bpp_, const RGBA *palette)\r\n{\r\n\tsize = sz;\r\n\tbpp = bpp_;\r\n\tline = 0;\r\n\r\n\ttiff = TIFFClientOpen(\"tiff@\" + Format64((intptr_t)this), \"w\", reinterpret_cast<thandle_t>(this),\r\n\t\tReadStream, WriteStream, SeekStream, CloseStream, SizeStream, MapStream, UnmapStream);\r\n\r\n\tTIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, size.cx);\r\n\tTIFFSetField(tiff, TIFFTAG_IMAGELENGTH, size.cy);\r\n\tTIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, min<int>(bpp, 8));\r\n\tTIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\tTIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, bpp <= 8 ? PHOTOMETRIC_PALETTE : PHOTOMETRIC_RGB);\r\n\tTIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, bpp <= 8 ? 1 : bpp != 32 ? 3 : 4);\r\n\tTIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\r\n\tTIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n\tif(bpp == 32) {\r\n\t\tuint16 es = EXTRASAMPLE_ASSOCALPHA;\r\n\t\tTIFFSetField(tiff, TIFFTAG_EXTRASAMPLES, 1, &es);\r\n\t}\r\n//\tTIFFSetField(tiff, TIFFTAG_REFERENCEBLACKWHITE, refblackwhite);\r\n//\tTIFFSetField(tiff, TIFFTAG_TRANSFERFUNCTION, gray);\r\n\tif(dots.cx && dots.cy) {\r\n\t\tTIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, (uint16)RESUNIT_INCH);\r\n\t\tfloat xres = float(sz.cx * 600.0 / dots.cx);\r\n\t\tTIFFSetField(tiff, TIFFTAG_XRESOLUTION, xres);\r\n\t\tfloat yres = float(sz.cy * 600.0 / dots.cy);\r\n\t\tTIFFSetField(tiff, TIFFTAG_YRESOLUTION, yres);\r\n\t}\r\n\tswitch(bpp) {\r\n\t\tcase 1: format.Set1mf(); break;\r\n\t\tcase 2: format.Set2mf(); break;\r\n\t\tcase 4: format.Set4mf(); break;\r\n\t\tcase 8: format.Set8(); break;\r\n\t\tdefault: NEVER();\r\n\t\tcase 24: format.Set24le(0xFF, 0xFF << 8, 0xFF << 16); break;\r\n\t\tcase 32: format.Set32le(0xFF, 0xFF << 8, 0xFF << 16, 0xFF << 24); break;\r\n\t}\r\n\tif(bpp <= 8) {\r\n\t\tuint16 rpal[256], gpal[256], bpal[256];\r\n\t\tint c = 1 << bpp;\r\n\t\tmemset(rpal, 0, sizeof(uint16) * c);\r\n\t\tmemset(gpal, 0, sizeof(uint16) * c);\r\n\t\tmemset(bpal, 0, sizeof(uint16) * c);\r\n\t\tfor(int i = 0; i < c; i++) {\r\n\t\t\trpal[i] = palette[i].r << 8;\r\n\t\t\tgpal[i] = palette[i].g << 8;\r\n\t\t\tbpal[i] = palette[i].b << 8;\r\n\t\t}\r\n\t\tTIFFSetField(tiff, TIFFTAG_COLORMAP, rpal, gpal, bpal);\r\n\t}\r\n\tint rowbytes = (bpp * size.cx + 31) >> 5 << 2;\r\n\trowbuf.SetCount(rowbytes);\r\n\tlinebytes = format.GetByteCount(size.cx);\r\n}\r\n\r\nvoid TIFEncoder::Data::WriteLineRaw(const byte *s)\r\n{\r\n\tmemcpy(rowbuf.Begin(), s, linebytes);\r\n\tTIFFWriteScanline(tiff, rowbuf.Begin(), line, 0);\r\n\tif(++line >= size.cy) {\r\n\t\tTIFFClose(tiff);\r\n\t\ttiff = NULL;\r\n\t}\r\n}\r\n\r\nTIFEncoder::TIFEncoder(int bpp)\r\n: bpp(bpp)\r\n{\r\n}\r\n\r\nTIFEncoder::~TIFEncoder()\r\n{\r\n}\r\n\r\nint TIFEncoder::GetPaletteCount()\r\n{\r\n\treturn (bpp > 8 ? 0 : 1 << bpp);\r\n}\r\n\r\nvoid TIFEncoder::Start(Size sz)\r\n{\r\n\tdata = new Data(GetStream(), format);\r\n\tdata->Start(sz, GetDots(), bpp, bpp <= 8 ? GetPalette() : NULL);\r\n}\r\n\r\nvoid TIFEncoder::WriteLineRaw(const byte *s)\r\n{\r\n\tdata->WriteLineRaw(s);\r\n}\r\n\r\n\r\nINITIALIZER(TIFRaster) {\r\n\tStreamRaster::Register<TIFRaster>();\r\n}\r\n\r\n}",
                "name": "tifupp.cpp",
                "path": "uppsrc/plugin/tif/tifupp.cpp",
                "url": "/github.com/ultimatepp/ultimatepp/-/blob/uppsrc/plugin/tif/tifupp.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 1164,
                    "offsetAndLengths": [
                        [
                            12,
                            16
                        ]
                    ],
                    "preview": "\tbool res = TIFFRGBAImageGet(this, 0, width, height);\r"
                }
            ],
            "repository": {
                "name": "github.com/ultimatepp/ultimatepp",
                "url": "/github.com/ultimatepp/ultimatepp"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "6b3d261b24de290f5a80ff71b1b130210ddef3b2"
                },
                "content": "#include \"StdAfx.h\"\n\n// #define STRICT\n#include \"diblib.h\"\n#include <commdlg.h>\n#include <stdlib.h> // MAX_ constants\n#include <windows.h>\n#include <windowsx.h>\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage\n{\n    TIFFRGBAImage tif;\n    int dibinstalled;\n};\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster);\n\nstatic void MyWarningHandler(const char *module, const char *fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void MyErrorHandler(const char *module, const char *fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF(LPCTSTR lpszPath)\n{\n    int rtn = 0;\n\n    TIFFErrorHandler eh;\n    TIFFErrorHandler wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF *tif = TIFFOpen(lpszPath, \"r\");\n    if (tif)\n    {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage *img);\n\nPVOID ReadTIFF(LPCTSTR lpszPath)\n{\n    void *pDIB = 0;\n    TIFFErrorHandler wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath))\n    {\n        TIFF *tif = TIFFOpen(lpszPath, \"r\");\n        if (tif)\n        {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg))\n            {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg))\n                {\n                    size_t npixels;\n                    uint32_t *raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster =\n                        (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n                    if (raster != NULL)\n                    {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width,\n                                             img.tif.height))\n                        {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else\n            {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg);\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster)\n{\n    void *pDIB = 0;\n    TIFFRGBAImage *img = &dib->tif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER bi;\n    int dwDIBSize;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if (BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled)\n    { // bilevel\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 1;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed = 0;\n        pRgbq[0].rgbBlue = 0;\n        pRgbq[0].rgbGreen = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed = 255;\n        pRgbq[1].rgbBlue = 255;\n        pRgbq[1].rgbGreen = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr(\n            (BITMAPINFOHEADER *)pDIB); //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n    //  For now just always default to the RGB 32 bit form. // save as 32 bit\n    //  for simplicity\n    else if (true /*BitsPerSample == 8 && SamplePerPixel == 3*/)\n    { // 24 bit color\n\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 32;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        // Swap the byte order while copying\n        for (int i = 0; i < sizeWords; ++i)\n        {\n            rgbDib[i].rgbRed = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n#define DECLAREContigPutFunc(name)                                             \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *pp)\n\n#define DECLARESepPutFunc(name)                                                \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *r, u_char *g, u_char *b, u_char *a)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *uraster, uint32_t w,\n                              uint32_t h);\n\n// typdef struct TIFFDibImage {\n//     TIFFRGBAImage tif;\n//     dibinstalled;\n// } TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage *dib)\n{\n    TIFFRGBAImage *img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric)\n    {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n            switch (img->bitspersample)\n            {\n                case 1:\n                    img->put.contig = putContig1bitTile;\n                    img->get = getStripContig1Bit;\n                    dib->dibinstalled = true;\n                    break;\n            }\n            break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void)y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char *ucp = (u_char *)cp;\n\n    /* Convert 'w' to bytes from pixels (rounded up) */\n    w = (w + 7) / 8;\n\n    while (h-- > 0)\n    {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32_t setorientation(TIFFRGBAImage *img, uint32_t h)\n{\n    TIFF *tif = img->tif;\n    uint32_t y;\n\n    switch (img->orientation)\n    {\n        case ORIENTATION_BOTRIGHT:\n        case ORIENTATION_RIGHTBOT: /* XXX */\n        case ORIENTATION_LEFTBOT:  /* XXX */\n            TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n            img->orientation = ORIENTATION_BOTLEFT;\n        /* fall through... */\n        case ORIENTATION_BOTLEFT:\n            y = 0;\n            break;\n        case ORIENTATION_TOPRIGHT:\n        case ORIENTATION_RIGHTTOP: /* XXX */\n        case ORIENTATION_LEFTTOP:  /* XXX */\n        default:\n            TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n            img->orientation = ORIENTATION_TOPLEFT;\n        /* fall through... */\n        case ORIENTATION_TOPLEFT:\n            y = h - 1;\n            break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *raster, uint32_t w,\n                              uint32_t h)\n{\n    TIFF *tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16_t orientation;\n    uint32_t row, y, nrow, rowstoread;\n    uint32_t pos;\n    u_char *buf;\n    uint32_t rowsperstrip;\n    uint32_t imagewidth = img->width;\n    tsize_t scanline;\n    int32_t fromskew, toskew;\n    tstrip_t strip;\n    tsize_t stripsize;\n    u_char *braster = (u_char *)raster; // byte wide raster\n    uint32_t wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char *)_TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32_t)(orientation == ORIENTATION_TOPLEFT ? wb + wb : wb - wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0) / 8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif, row + img->row_offset, 0);\n        stripsize = ((row + img->row_offset) % rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize) < 0 &&\n            img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32_t *)(braster + y * wb), 0, y, w, nrow, fromskew,\n               toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ? -(int32_t)nrow\n                                                 : (int32_t)nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n",
                "name": "Tiffile.cpp",
                "path": "external/tiff-4.7.0/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/cnr-isti-vclab/relight/-/blob/external/tiff-4.7.0/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 112,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width,"
                }
            ],
            "repository": {
                "name": "github.com/cnr-isti-vclab/relight",
                "url": "/github.com/cnr-isti-vclab/relight"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "92089a6fff7bd5cb1bc79308359d990c1de39f5c"
                },
                "content": "////////////////////////////////////////////////////////\n//\n// GEM - Graphics Environment for Multimedia\n//\n// zmoelnig@iem.at\n//\n// Implementation file\n//\n//    Copyright (c) 1997-1999 Mark Danks.\n//    Copyright (c) Gnther Geiger.\n//    Copyright (c) 2001-2011 IOhannes m zmlnig. forum::fr::umlute. IEM. zmoelnig@iem.at\n//    For information on usage and redistribution, and for a DISCLAIMER OF ALL\n//    WARRANTIES, see the file, \"GEM.LICENSE.TERMS\" in this distribution.\n//\n/////////////////////////////////////////////////////////\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#ifdef _WIN32\n#include <stdio.h> // AV : in windows, this should be included before tiffio.h\n#endif /* WINVER */\n\n#ifdef HAVE_LIBTIFF\nextern \"C\"\n{\n# include \"tiffio.h\"\n}\n\n#include <string.h>\n#include \"imageTIFF.h\"\n#include \"plugins/PluginFactory.h\"\n\n#include \"Gem/RTE.h\"\n\n\nusing namespace gem::plugins;\n\nREGISTER_IMAGELOADERFACTORY(\"tiff\", imageTIFF);\nREGISTER_IMAGESAVERFACTORY(\"tiff\", imageTIFF);\n\n\n#ifdef _MSC_VER\n# define vsnprintf _vsnprintf\n#endif\n\nnamespace\n{\nstatic void imageTIFF_verbosehandler(const int verbosity,\n                                     const char*module, const char*fmt, va_list ap)\n{\n  std::string result = \"[GEM:imageTIFF] \";\n  char buf[MAXPDSTRING];\n  if(module) {\n    result+=module;\n    result+=\" \";\n  }\n  vsnprintf(buf, MAXPDSTRING, fmt, ap);\n  buf[MAXPDSTRING-1]=0;\n  result+=buf;\n  logpost(0, 3+verbosity, \"%s\", result.c_str());\n}\nstatic void imageTIFF_errorhandler(const char*module, const char*fmt,\n                                   va_list ap)\n{\n  imageTIFF_verbosehandler(-2, module, fmt, ap);\n}\nstatic void imageTIFF_warnhandler(const char*module, const char*fmt,\n                                  va_list ap)\n{\n  imageTIFF_verbosehandler(0, module, fmt, ap);\n}\ntypedef struct _imageTIFF_handlers {\n  TIFFErrorHandler error, warning;\n} t_imageTIFF_handlers;\nstatic t_imageTIFF_handlers imageTIFF_sethandlers(t_imageTIFF_handlers&handlers)\n{\n  t_imageTIFF_handlers newhandlers;\n  newhandlers.error = TIFFSetErrorHandler(handlers.error);\n  newhandlers.warning = TIFFSetWarningHandler(handlers.warning);\n  return newhandlers;\n}\nstatic t_imageTIFF_handlers imageTIFF_sethandlers(void)\n{\n  t_imageTIFF_handlers handlers;\n  handlers.error = TIFFSetErrorHandler(imageTIFF_errorhandler);\n  handlers.warning = TIFFSetWarningHandler(imageTIFF_warnhandler);\n  return handlers;\n}\n#define tiffhandlers_init()   t_imageTIFF_handlers tiffhandler = imageTIFF_sethandlers()\n#define tiffhandlers_cleanup() imageTIFF_sethandlers(tiffhandler)\n\n\n};\n\n/////////////////////////////////////////////////////////\n//\n// imageTIFF\n//\n/////////////////////////////////////////////////////////\n// Constructor\n//\n/////////////////////////////////////////////////////////\n\nimageTIFF :: imageTIFF(void)\n{\n  static bool firsttime=true;\n  if(firsttime) {\n    TIFFSetErrorHandler(imageTIFF_errorhandler);\n    TIFFSetWarningHandler(imageTIFF_warnhandler);\n  }\n  firsttime=false;\n}\nimageTIFF :: ~imageTIFF(void)\n{\n}\n\n/////////////////////////////////////////////////////////\n// really open the file ! (OS dependent)\n//\n/////////////////////////////////////////////////////////\nbool imageTIFF :: load(std::string filename, imageStruct&result,\n                       gem::Properties&props)\n{\n  tiffhandlers_init();\n  TIFF *tif = TIFFOpen(filename.c_str(), \"r\");\n  if (tif == NULL) {\n    tiffhandlers_cleanup();\n    return false;\n  }\n\n  uint32_t width, height;\n  uint16_t orientation;\n  short bits, samps;\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n  TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n  TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samps);\n  TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation);\n\n  int npixels = width * height;\n\n  result.xsize=width;\n  result.ysize=height;\n  result.upsidedown=(ORIENTATION_BOTLEFT != orientation);\n\n  bool knownFormat = false;\n  // Is it a gray8 image?\n  if (bits == 8 && samps == 1) {\n    result.setFormat(GEM_GRAY);\n    knownFormat = true;\n  }\n  // Is it an RGB image?\n  else if (bits == 8 && samps == 3) {\n    result.setFormat(GEM_RGBA);\n    knownFormat = true;\n  }\n  // Is it an RGBA image?\n  else if (bits == 8 && samps == 4) {\n    result.setFormat(GEM_RGBA);\n    knownFormat = true;\n  }\n\n  // can we handle the raw data?\n  if (knownFormat) {\n    unsigned char *buf = new unsigned char [TIFFScanlineSize(tif)];\n    if (buf == NULL) {\n      pd_error(0, \"[GEM:imageTIFF] can't allocate memory for scanline buffer: %s\",\n               filename.c_str());\n      TIFFClose(tif);\n      tiffhandlers_cleanup();\n      return false;\n    }\n\n    result.reallocate();\n    unsigned char *dstLine = result.data;\n    int yStride = result.xsize * result.csize;\n    for (uint32_t row = 0; row < height; row++) {\n      unsigned char *pixels = dstLine;\n      if (TIFFReadScanline(tif, buf, row, 0) < 0) {\n        logpost(0, 3+1, \"[GEM:imageTIFF] bad image data read on line: %d: %s\", row,\n                filename.c_str());\n        TIFFClose(tif);\n        return false;\n      }\n      unsigned char *inp = buf;\n      if (samps == 1) {\n        for (uint32_t i = 0; i < width; i++) {\n          *pixels++ = *inp++;         // Gray8\n        }\n      } else if (samps == 3)  {\n        for (uint32_t i = 0; i < width; i++) {\n          pixels[chRed]   = inp[0];   // Red\n          pixels[chGreen] = inp[1];   // Green\n          pixels[chBlue]  = inp[2];   // Blue\n          pixels[chAlpha] = 255;      // Alpha\n          pixels += 4;\n          inp += 3;\n        }\n      } else {\n        for (uint32_t i = 0; i < width; i++) {\n          pixels[chRed]   = inp[0];   // Red\n          pixels[chGreen] = inp[1];   // Green\n          pixels[chBlue]  = inp[2];   // Blue\n          pixels[chAlpha] = inp[3];   // Alpha\n          pixels += 4;\n          inp += 4;\n        }\n      }\n      dstLine += yStride;\n    }\n    delete [] buf;\n  }\n  // nope, so use the automatic conversion\n  else {\n    char emsg[1024];\n    TIFFRGBAImage img;\n    if (TIFFRGBAImageBegin(&img, tif, 0, emsg) == 0) {\n      logpost(0, 3+0, \"[GEM:imageTIFF] Error reading in image file '%s': %s\",\n              filename.c_str(), emsg);\n      TIFFClose(tif);\n      tiffhandlers_cleanup();\n      return false;\n    }\n\n    uint32_t*raster = reinterpret_cast<uint32_t*>(_TIFFmalloc(npixels * sizeof(\n                      uint32_t)));\n    if (raster == NULL) {\n      pd_error(0, \"[GEM:imageTIFF] Unable to allocate memory for image '%s'\",\n               filename.c_str());\n      TIFFClose(tif);\n      tiffhandlers_cleanup();\n      return false;\n    }\n\n    if (TIFFRGBAImageGet(&img, raster, width, height) == 0) {\n      logpost(0, 3+0, \"[GEM:imageTIFF] Error getting image data in file '%s': %s\",\n              filename.c_str(), emsg);\n      _TIFFfree(raster);\n      TIFFClose(tif);\n      tiffhandlers_cleanup();\n      return false;\n    }\n\n    TIFFRGBAImageEnd(&img);\n    result.setFormat(GEM_RGBA);\n    result.reallocate();\n\n    unsigned char *dstLine = result.data;\n    int yStride = result.xsize * result.csize;\n    // transfer everything over\n    int k = 0;\n    for (uint32_t i = 0; i < height; i++) {\n      unsigned char *pixels = dstLine;\n      for (uint32_t j = 0; j < width; j++) {\n        pixels[chRed]   = static_cast<unsigned char>(TIFFGetR(raster[k])); // Red\n        pixels[chGreen] = static_cast<unsigned char>(TIFFGetG(raster[k])); // Green\n        pixels[chBlue]  = static_cast<unsigned char>(TIFFGetB(raster[k])); // Blue\n        pixels[chAlpha] = static_cast<unsigned char>(TIFFGetA(raster[k])); // Alpha\n        k++;\n        pixels += 4;\n      }\n      dstLine += yStride;\n    }\n    _TIFFfree(raster);\n  }\n\n  result.fixUpDown();\n\n  double value_d;\n  short value_i16;\n  char value_s[MAXPDSTRING];\n  if(TIFFGetField(tif, TIFFTAG_XRESOLUTION, &value_d)) {\n    props.set(\"xresolution\", value_d);\n  }\n  if(TIFFGetField(tif, TIFFTAG_YRESOLUTION, &value_d)) {\n    props.set(\"yresolution\", value_d);\n  }\n  if(TIFFGetField(tif, TIFFTAG_XRESOLUTION, &value_d)) {\n    props.set(\"xresolution\", value_d);\n  }\n  if(TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, &value_i16)) {\n    std::string resunit;\n    switch(value_i16) {\n    case RESUNIT_INCH:\n      resunit=\"inch\";\n      break;\n    case RESUNIT_CENTIMETER:\n      resunit=\"centimeter\";\n      break;\n    default:\n      resunit=\"none\";\n      break;\n    }\n    props.set(\"resolutionunit\", resunit);\n  }\n  if(TIFFGetField(tif, TIFFTAG_SOFTWARE, &value_s)) {\n    props.set(\"software\", std::string(value_s));\n  }\n  if(TIFFGetField(tif, TIFFTAG_ARTIST, &value_s)) {\n    props.set(\"artist\", std::string(value_s));\n  }\n  if(TIFFGetField(tif, TIFFTAG_HOSTCOMPUTER, &value_s)) {\n    props.set(\"hostcomputer\", std::string(value_s));\n  }\n\n  TIFFClose(tif);\n\n  const char*orient=0;\n  switch(orientation) {\n  case ORIENTATION_TOPLEFT:\n  case ORIENTATION_BOTLEFT:\n    break;\n  case ORIENTATION_TOPRIGHT:\n    orient = \"top right\"; break;\n  case ORIENTATION_BOTRIGHT:\n    orient = \"bottom right\"; break;\n  case ORIENTATION_LEFTTOP:\n    orient = \"left top\"; break;\n  case ORIENTATION_RIGHTTOP:\n    orient = \"right top\"; break;\n  case ORIENTATION_RIGHTBOT:\n    orient = \"right bottom\"; break;\n  case ORIENTATION_LEFTBOT:\n    orient = \"left bottom\"; break;\n  default:\n    orient = \"unknown\"; break;\n  }\n  if(orient) {\n    logpost(0, 3+0, \"[GEM:imageTIFF] unhandled orientation '%s' (%d)\", orient, orientation);\n  }\n  return true;\n}\nbool imageTIFF::save(const imageStruct&constimage,\n                     const std::string&filename, const std::string&mimetype,\n                     const gem::Properties&props)\n{\n  tiffhandlers_init();\n  TIFF *tif = NULL;\n  imageStruct image;\n\n  tif=TIFFOpen(filename.c_str(), \"w\");\n  if (tif == NULL) {\n      tiffhandlers_cleanup();\n      return false;\n  }\n  image.convertFrom(&constimage, GEM_RAW_RGBA);\n  image.fixUpDown();\n\n  uint32_t width=image.xsize, height = image.ysize;\n  short bits=8, samps=image.csize;\n  int npixels = width * height;\n  //int planar_conf = PLANARCONFIG_CONTIG;\n  std::string software = \"PD/GEM\";\n  std::string artist;\n  std::string hostcomputer;\n\n  double xresolution = 72., yresolution=72.;\n  short resunit = RESUNIT_INCH;\n\n  props.get(\"xresolution\", xresolution);\n  props.get(\"yresolution\", yresolution);\n  std::string resunit_s;\n  if(props.get(\"resolutionunit\", resunit_s)) {\n    if((\"inch\"==resunit_s) || (\"english\"==resunit_s)\n        || (\"imperial\"==resunit_s)) {\n      resunit=RESUNIT_INCH;\n    } else if((\"centimeter\"==resunit_s) || (\"metric\"==resunit_s)) {\n      resunit=RESUNIT_CENTIMETER;\n    } else {\n      resunit=RESUNIT_NONE;\n    }\n  }\n  props.get(\"software\", software);\n  props.get(\"artist\", artist);\n  props.get(\"hostcomputer\", hostcomputer);\n\n\n  TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n  TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bits);\n  TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, samps);\n  TIFFSetField(tif, TIFFTAG_PLANARCONFIG, 1);\n  TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\n  TIFFSetField(tif, TIFFTAG_XRESOLUTION, xresolution); // RATIONAL\n  TIFFSetField(tif, TIFFTAG_YRESOLUTION, yresolution); // RATIONAL\n  TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resunit);\n\n  uint16_t extra_samples[1] = { EXTRASAMPLE_UNASSALPHA };\n  TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, 1, extra_samples);\n\n  if(!software.empty()) {\n    TIFFSetField(tif, TIFFTAG_SOFTWARE, software.c_str());\n  }\n  if(!artist.empty()) {\n    TIFFSetField(tif, TIFFTAG_ARTIST, artist.c_str());\n  }\n  if(!hostcomputer.empty()) {\n    TIFFSetField(tif, TIFFTAG_HOSTCOMPUTER, hostcomputer.c_str());\n  }\n\n  int yStride = image.xsize * image.csize;\n  unsigned char *srcLine = image.data;\n\n  for (uint32_t row = 0; row < height; row++) {\n    if (TIFFWriteScanline(tif, srcLine, row, 0) < 0) {\n      logpost(0, 3+0, \"[GEM:imageTIFF] could not write line %d to image '%s'\", row,\n              filename.c_str());\n      TIFFClose(tif);\n      tiffhandlers_cleanup();\n      return false;\n    }\n    srcLine += yStride;\n  }\n  TIFFClose(tif);\n\n  tiffhandlers_cleanup();\n  return true;\n}\n\n\nfloat imageTIFF::estimateSave(const imageStruct&img,\n                              const std::string&filename, const std::string&mimetype,\n                              const gem::Properties&props)\n{\n  float result=0;\n  if(mimetype == \"image/tiff\" || mimetype == \"image/x-tiff\") {\n    result += 100;\n  }\n\n  if(gem::Properties::UNSET != props.type(\"xresolution\")) {\n    result+=1.;\n  }\n  if(gem::Properties::UNSET != props.type(\"yresolution\")) {\n    result+=1.;\n  }\n  if(gem::Properties::UNSET != props.type(\"resolutionunit\")) {\n    result+=1.;\n  }\n  if(gem::Properties::UNSET != props.type(\"software\")) {\n    result+=1.;\n  }\n  if(gem::Properties::UNSET != props.type(\"artist\")) {\n    result+=1.;\n  }\n  if(gem::Properties::UNSET != props.type(\"hostcomputer\")) {\n    result+=1.;\n  }\n\n  return result;\n}\n\n\nvoid imageTIFF::getWriteCapabilities(std::vector<std::string>&mimetypes,\n                                     gem::Properties&props)\n{\n  mimetypes.clear();\n  props.clear();\n\n  mimetypes.push_back(\"image/tiff\");\n  mimetypes.push_back(\"image/x-tiff\");\n\n  gem::any value;\n\n\n  value=72.f;\n  props.set(\"xresolution\", value);\n  props.set(\"yresolution\", value);\n\n  value=std::string(\"inch\");\n  props.set(\"resolutionunit\", value);\n  value=std::string(\"PD/GEM\");\n  props.set(\"software\", value);\n  value=std::string(\"\");\n  props.set(\"artist\", value);\n  props.set(\"hostcomputer\", value);\n}\n#endif\n",
                "name": "imageTIFF.cpp",
                "path": "plugins/TIFF/imageTIFF.cpp",
                "url": "/github.com/umlaeute/Gem/-/blob/plugins/TIFF/imageTIFF.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 235,
                    "offsetAndLengths": [
                        [
                            8,
                            16
                        ]
                    ],
                    "preview": "    if (TIFFRGBAImageGet(&img, raster, width, height) == 0) {"
                }
            ],
            "repository": {
                "name": "github.com/umlaeute/Gem",
                "url": "/github.com/umlaeute/Gem"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "61d8a3923d2f6c87da136676e64754796f379826"
                },
                "content": "/*\n * Copyright (c) 2020-2022, NVIDIA CORPORATION.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#define CUCIM_EXPORTS\n\n#include \"cuslide.h\"\n\n#include \"cucim/core/framework.h\"\n#include \"cucim/core/plugin_util.h\"\n#include \"cucim/io/format/image_format.h\"\n#include \"tiff/tiff.h\"\n\n#include <fmt/format.h>\n#include <nlohmann/json.hpp>\n\n#include <array>\n#include <cassert>\n#include <cstring>\n#include <fcntl.h>\n#include <filesystem>\n#include <memory>\n\nusing json = nlohmann::json;\n\nconst struct cucim::PluginImplDesc kPluginImpl = {\n    \"cucim.kit.cuslide\", // name\n    { 0, 1, 0 }, // version\n    \"dev\", // build\n    \"clara team\", // author\n    \"cuslide\", // description\n    \"cuslide plugin\", // long_description\n    \"Apache-2.0\", // license\n    \"https://github.com/rapidsai/cucim\", // url\n    \"linux\", // platforms,\n    cucim::PluginHotReload::kDisabled, // hot_reload\n};\n\n// Using CARB_PLUGIN_IMPL_MINIMAL instead of CARB_PLUGIN_IMPL\n// This minimal macro doesn't define global variables for logging, profiler, crash reporting,\n// and also doesn't call for the client registration for those systems\nCUCIM_PLUGIN_IMPL_MINIMAL(kPluginImpl, cucim::io::format::IImageFormat)\nCUCIM_PLUGIN_IMPL_NO_DEPS()\n\n\nstatic void set_enabled(bool val)\n{\n    (void)val;\n}\n\nstatic bool is_enabled()\n{\n    return true;\n}\n\nstatic const char* get_format_name()\n{\n    return \"Generic TIFF\";\n}\n\nstatic bool CUCIM_ABI checker_is_valid(const char* file_name, const char* buf, size_t size)\n{\n    (void)buf;\n    (void)size;\n    auto file = std::filesystem::path(file_name);\n    auto extension = file.extension().string();\n    if (extension.compare(\".tif\") == 0 || extension.compare(\".tiff\") == 0 || extension.compare(\".svs\") == 0)\n    {\n        return true;\n    }\n    return false;\n}\n\nstatic CuCIMFileHandle_share CUCIM_ABI parser_open(const char* file_path)\n{\n    auto tif = new cuslide::tiff::TIFF(file_path, O_RDONLY);\n    tif->construct_ifds();\n    // Move the ownership of the file handle object to the caller (CuImage).\n    auto handle_t = tif->file_handle();\n    tif->file_handle() = nullptr;\n    CuCIMFileHandle_share handle = new std::shared_ptr<CuCIMFileHandle>(handle_t);\n    return handle;\n}\n\nstatic bool CUCIM_ABI parser_parse(CuCIMFileHandle_ptr handle_ptr, cucim::io::format::ImageMetadataDesc* out_metadata_desc)\n{\n    CuCIMFileHandle* handle = reinterpret_cast<CuCIMFileHandle*>(handle_ptr);\n    if (!out_metadata_desc || !out_metadata_desc->handle)\n    {\n        throw std::runtime_error(\"out_metadata_desc shouldn't be nullptr!\");\n    }\n    cucim::io::format::ImageMetadata& out_metadata =\n        *reinterpret_cast<cucim::io::format::ImageMetadata*>(out_metadata_desc->handle);\n\n    auto tif = static_cast<cuslide::tiff::TIFF*>(handle->client_data);\n\n    size_t ifd_count = tif->ifd_count();\n    size_t level_count = tif->level_count();\n\n    // If not Aperio SVS format (== Ordinary Pyramid TIFF image)\n    if (tif->ifd(0)->image_description().rfind(\"Aperio\", 0) != 0)\n    {\n        std::vector<size_t> main_ifd_list;\n        for (size_t i = 0; i < ifd_count; i++)\n        {\n            const std::shared_ptr<cuslide::tiff::IFD>& ifd = tif->ifd(i);\n            uint64_t subfile_type = ifd->subfile_type();\n            if (subfile_type == 0)\n            {\n                main_ifd_list.push_back(i);\n            }\n        }\n\n        // Assume that the image has only one main (high resolution) image.\n        if (main_ifd_list.size() != 1)\n        {\n            throw std::runtime_error(\n                fmt::format(\"This format has more than one image with Subfile Type 0 so cannot be loaded!\"));\n        }\n    }\n\n    //\n    // Metadata Setup\n    //\n\n    // Note: int-> uint16_t due to type differences between ImageMetadataDesc.ndim and DLTensor.ndim\n    const uint16_t ndim = 3;\n    auto& resource = out_metadata.get_resource();\n\n    std::string_view dims{ \"YXC\" };\n\n    const auto& level0_ifd = tif->level_ifd(0);\n    std::pmr::vector<int64_t> shape(\n        { level0_ifd->height(), level0_ifd->width(), level0_ifd->samples_per_pixel() }, &resource);\n\n    DLDataType dtype{ kDLUInt, 8, 1 };\n\n    // TODO: Fill correct values for cucim::io::format::ImageMetadataDesc\n    uint8_t n_ch = level0_ifd->samples_per_pixel();\n    if (n_ch != 3)\n    {\n        // Image loaded by a slow-path(libtiff) always will have 4 channel\n        // (by TIFFRGBAImageGet() method in libtiff)\n        n_ch = 4;\n        shape[2] = 4;\n    }\n    std::pmr::vector<std::string_view> channel_names(&resource);\n    channel_names.reserve(n_ch);\n    if (n_ch == 3)\n    {\n        channel_names.emplace_back(std::string_view{ \"R\" });\n        channel_names.emplace_back(std::string_view{ \"G\" });\n        channel_names.emplace_back(std::string_view{ \"B\" });\n    }\n    else\n    {\n        channel_names.emplace_back(std::string_view{ \"R\" });\n        channel_names.emplace_back(std::string_view{ \"G\" });\n        channel_names.emplace_back(std::string_view{ \"B\" });\n        channel_names.emplace_back(std::string_view{ \"A\" });\n    }\n\n    // Spacing units\n    std::pmr::vector<std::string_view> spacing_units(&resource);\n    spacing_units.reserve(ndim);\n\n    std::pmr::vector<float> spacing(&resource);\n    spacing.reserve(ndim);\n    const auto resolution_unit = level0_ifd->resolution_unit();\n    const auto x_resolution = level0_ifd->x_resolution();\n    const auto y_resolution = level0_ifd->y_resolution();\n\n    switch (resolution_unit)\n    {\n    case 1: // no absolute unit of measurement\n        spacing.emplace_back(y_resolution);\n        spacing.emplace_back(x_resolution);\n        spacing.emplace_back(1.0f);\n\n        spacing_units.emplace_back(std::string_view{ \"\" });\n        spacing_units.emplace_back(std::string_view{ \"\" });\n        break;\n    case 2: // inch\n        spacing.emplace_back(y_resolution != 0 ? 25400 / y_resolution : 1.0f);\n        spacing.emplace_back(x_resolution != 0 ? 25400 / x_resolution : 1.0f);\n        spacing.emplace_back(1.0f);\n\n        spacing_units.emplace_back(std::string_view{ \"micrometer\" });\n        spacing_units.emplace_back(std::string_view{ \"micrometer\" });\n        break;\n    case 3: // centimeter\n        spacing.emplace_back(y_resolution != 0 ? 10000 / y_resolution : 1.0f);\n        spacing.emplace_back(x_resolution != 0 ? 10000 / x_resolution : 1.0f);\n        spacing.emplace_back(1.0f);\n\n        spacing_units.emplace_back(std::string_view{ \"micrometer\" });\n        spacing_units.emplace_back(std::string_view{ \"micrometer\" });\n        break;\n    default:\n        spacing.insert(spacing.end(), ndim, 1.0f);\n    }\n\n    spacing_units.emplace_back(std::string_view{ \"color\" });\n\n    std::pmr::vector<float> origin({ 0.0, 0.0, 0.0 }, &resource);\n    // Direction cosines (size is always 3x3)\n    // clang-format off\n    std::pmr::vector<float> direction({ 1.0, 0.0, 0.0,\n                                        0.0, 1.0, 0.0,\n                                        0.0, 0.0, 1.0}, &resource);\n    // clang-format on\n\n    // The coordinate frame in which the direction cosines are measured (either 'LPS'(ITK/DICOM) or 'RAS'(NIfTI/3D\n    // Slicer))\n    std::string_view coord_sys{ \"LPS\" };\n\n    const uint16_t level_ndim = 2;\n    std::pmr::vector<int64_t> level_dimensions(&resource);\n    level_dimensions.reserve(level_count * 2);\n    for (size_t i = 0; i < level_count; ++i)\n    {\n        const auto& level_ifd = tif->level_ifd(i);\n        level_dimensions.emplace_back(level_ifd->width());\n        level_dimensions.emplace_back(level_ifd->height());\n    }\n\n    std::pmr::vector<float> level_downsamples(&resource);\n    float orig_width = static_cast<float>(shape[1]);\n    float orig_height = static_cast<float>(shape[0]);\n    for (size_t i = 0; i < level_count; ++i)\n    {\n        const auto& level_ifd = tif->level_ifd(i);\n        level_downsamples.emplace_back(((orig_width / level_ifd->width()) + (orig_height / level_ifd->height())) / 2);\n    }\n\n    std::pmr::vector<uint32_t> level_tile_sizes(&resource);\n    level_tile_sizes.reserve(level_count * 2);\n    for (size_t i = 0; i < level_count; ++i)\n    {\n        const auto& level_ifd = tif->level_ifd(i);\n        level_tile_sizes.emplace_back(level_ifd->tile_width());\n        level_tile_sizes.emplace_back(level_ifd->tile_height());\n    }\n\n    const size_t associated_image_count = tif->associated_image_count();\n    std::pmr::vector<std::string_view> associated_image_names(&resource);\n    for (const auto& associated_image : tif->associated_images())\n    {\n        associated_image_names.emplace_back(std::string_view{ associated_image.first.c_str() });\n    }\n\n    auto& image_description = level0_ifd->image_description();\n    std::string_view raw_data{ image_description.empty() ? \"\" : image_description.c_str() };\n\n    // Dynamically allocate memory for json_data (need to be freed manually);\n    const std::string& json_str = tif->metadata();\n    char* json_data_ptr = static_cast<char*>(cucim_malloc(json_str.size() + 1));\n    memcpy(json_data_ptr, json_str.data(), json_str.size() + 1);\n    std::string_view json_data{ json_data_ptr, json_str.size() };\n\n    out_metadata.ndim(ndim);\n    out_metadata.dims(std::move(dims));\n    out_metadata.shape(std::move(shape));\n    out_metadata.dtype(dtype);\n    out_metadata.channel_names(std::move(channel_names));\n    out_metadata.spacing(std::move(spacing));\n    out_metadata.spacing_units(std::move(spacing_units));\n    out_metadata.origin(std::move(origin));\n    out_metadata.direction(std::move(direction));\n    out_metadata.coord_sys(std::move(coord_sys));\n    out_metadata.level_count(level_count);\n    out_metadata.level_ndim(level_ndim);\n    out_metadata.level_dimensions(std::move(level_dimensions));\n    out_metadata.level_downsamples(std::move(level_downsamples));\n    out_metadata.level_tile_sizes(std::move(level_tile_sizes));\n    out_metadata.image_count(associated_image_count);\n    out_metadata.image_names(std::move(associated_image_names));\n    out_metadata.raw_data(raw_data);\n    out_metadata.json_data(json_data);\n\n    return true;\n}\n\nstatic bool CUCIM_ABI parser_close(CuCIMFileHandle_ptr handle_ptr)\n{\n    CuCIMFileHandle* handle = reinterpret_cast<CuCIMFileHandle*>(handle_ptr);\n\n    auto tif = static_cast<cuslide::tiff::TIFF*>(handle->client_data);\n    delete tif;\n    handle->client_data = nullptr;\n    return true;\n}\n\nstatic bool CUCIM_ABI reader_read(const CuCIMFileHandle_ptr handle_ptr,\n                                  const cucim::io::format::ImageMetadataDesc* metadata,\n                                  const cucim::io::format::ImageReaderRegionRequestDesc* request,\n                                  cucim::io::format::ImageDataDesc* out_image_data,\n                                  cucim::io::format::ImageMetadataDesc* out_metadata = nullptr)\n{\n    CuCIMFileHandle* handle = reinterpret_cast<CuCIMFileHandle*>(handle_ptr);\n    auto tif = static_cast<cuslide::tiff::TIFF*>(handle->client_data);\n    bool result = tif->read(metadata, request, out_image_data, out_metadata);\n\n    return result;\n}\n\nstatic bool CUCIM_ABI writer_write(const CuCIMFileHandle_ptr handle_ptr,\n                                   const cucim::io::format::ImageMetadataDesc* metadata,\n                                   const cucim::io::format::ImageDataDesc* image_data)\n{\n    CuCIMFileHandle* handle = reinterpret_cast<CuCIMFileHandle*>(handle_ptr);\n    (void)handle;\n    (void)metadata;\n    (void)image_data;\n\n    return true;\n}\n\nvoid fill_interface(cucim::io::format::IImageFormat& iface)\n{\n    static cucim::io::format::ImageCheckerDesc image_checker = { 0, 0, checker_is_valid };\n    static cucim::io::format::ImageParserDesc image_parser = { parser_open, parser_parse, parser_close };\n\n    static cucim::io::format::ImageReaderDesc image_reader = { reader_read };\n    static cucim::io::format::ImageWriterDesc image_writer = { writer_write };\n\n    // clang-format off\n    static cucim::io::format::ImageFormatDesc image_format_desc = {\n        set_enabled,\n        is_enabled,\n        get_format_name,\n        image_checker,\n        image_parser,\n        image_reader,\n        image_writer\n    };\n    // clang-format on\n\n    // clang-format off\n    iface =\n    {\n        &image_format_desc,\n        1\n    };\n    // clang-format on\n}\n",
                "name": "cuslide.cpp",
                "path": "cpp/plugins/cucim.kit.cuslide/src/cuslide/cuslide.cpp",
                "url": "/github.com/rapidsai/cucim/-/blob/cpp/plugins/cucim.kit.cuslide/src/cuslide/cuslide.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 153,
                    "offsetAndLengths": [
                        [
                            15,
                            16
                        ]
                    ],
                    "preview": "        // (by TIFFRGBAImageGet() method in libtiff)"
                }
            ],
            "repository": {
                "name": "github.com/rapidsai/cucim",
                "url": "/github.com/rapidsai/cucim"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "f44e853beacb141a718b37118a1cc72404a43bd3"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "dependencies/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/fegennari/3DWorld/-/blob/dependencies/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/fegennari/3DWorld",
                "url": "/github.com/fegennari/3DWorld"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "f44e853beacb141a718b37118a1cc72404a43bd3"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32_t* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32_t* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32_t*) _TIFFmalloc(npixels * sizeof (uint32_t));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32_t* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32_t* cp, \\\n    uint32_t x, uint32_t y, \\\n    uint32_t w, uint32_t h, \\\n    int32_t fromskew, int32_t toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32_t* cp,\\\n    uint32_t x, uint32_t y, \\\n    uint32_t w, uint32_t h,\\\n    int32_t fromskew, int32_t toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32_t* uraster, uint32_t w, uint32_t h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Convert 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32_t\nsetorientation(TIFFRGBAImage* img, uint32_t h)\n{\n    TIFF* tif = img->tif;\n    uint32_t y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32_t* raster, uint32_t w, uint32_t h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16_t orientation;\n    uint32_t row, y, nrow, rowstoread;\n    uint32_t pos;\n    u_char* buf;\n    uint32_t rowsperstrip;\n    uint32_t imagewidth = img->width;\n    tsize_t scanline;\n    int32_t fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32_t  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32_t) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32_t*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32_t) nrow : (int32_t) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "dependencies/tiff-4.3.0/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/fegennari/3DWorld/-/blob/dependencies/tiff-4.3.0/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/fegennari/3DWorld",
                "url": "/github.com/fegennari/3DWorld"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "61d8a3923d2f6c87da136676e64754796f379826"
                },
                "content": "/*\n * Copyright (c) 2020-2021, NVIDIA CORPORATION.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"ifd.h\"\n\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <algorithm>\n#include <iostream>\n#include <random>\n#include <thread>\n\n#include <fmt/format.h>\n#include <tiffio.h>\n#include <tiffiop.h> // this is not included in the released library\n#include <turbojpeg.h>\n\n#include <cucim/codec/hash_function.h>\n#include <cucim/cuimage.h>\n#include <cucim/logger/timer.h>\n#include <cucim/memory/memory_manager.h>\n#include <cucim/profiler/nvtx3.h>\n#include <cucim/util/cuda.h>\n\n#include \"cuslide/deflate/deflate.h\"\n#include \"cuslide/jpeg/libjpeg_turbo.h\"\n#include \"cuslide/jpeg2k/libopenjpeg.h\"\n#include \"cuslide/loader/nvjpeg_processor.h\"\n#include \"cuslide/lzw/lzw.h\"\n#include \"cuslide/raw/raw.h\"\n#include \"tiff.h\"\n\n\nnamespace cuslide::tiff\n{\n\nIFD::IFD(TIFF* tiff, uint16_t index, ifd_offset_t offset) : tiff_(tiff), ifd_index_(index), ifd_offset_(offset)\n{\n    PROF_SCOPED_RANGE(PROF_EVENT(ifd_ifd));\n    auto tif = tiff->client();\n\n    char* software_char_ptr = nullptr;\n    char* model_char_ptr = nullptr;\n\n    // TODO: error handling\n    TIFFGetField(tif, TIFFTAG_SOFTWARE, &software_char_ptr);\n    software_ = std::string(software_char_ptr ? software_char_ptr : \"\");\n    TIFFGetField(tif, TIFFTAG_MODEL, &model_char_ptr);\n    model_ = std::string(model_char_ptr ? model_char_ptr : \"\");\n    TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &model_char_ptr);\n    image_description_ = std::string(model_char_ptr ? model_char_ptr : \"\");\n    TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, &resolution_unit_);\n    TIFFGetField(tif, TIFFTAG_XRESOLUTION, &x_resolution_);\n    TIFFGetField(tif, TIFFTAG_YRESOLUTION, &y_resolution_);\n\n    TIFFDirectory& tif_dir = tif->tif_dir;\n    flags_ = tif->tif_flags;\n\n    width_ = tif_dir.td_imagewidth;\n    height_ = tif_dir.td_imagelength;\n    if ((flags_ & TIFF_ISTILED) != 0)\n    {\n        tile_width_ = tif_dir.td_tilewidth;\n        tile_height_ = tif_dir.td_tilelength;\n    }\n    else\n    {\n        rows_per_strip_ = tif_dir.td_rowsperstrip;\n    }\n    bits_per_sample_ = tif_dir.td_bitspersample;\n    samples_per_pixel_ = tif_dir.td_samplesperpixel;\n    subfile_type_ = tif_dir.td_subfiletype;\n    planar_config_ = tif_dir.td_planarconfig;\n    photometric_ = tif_dir.td_photometric;\n    compression_ = tif_dir.td_compression;\n    TIFFGetField(tif, TIFFTAG_PREDICTOR, &predictor_);\n    subifd_count_ = tif_dir.td_nsubifd;\n    uint64_t* subifd_offsets = tif_dir.td_subifd;\n    if (subifd_count_)\n    {\n        subifd_offsets_.resize(subifd_count_);\n        subifd_offsets_.insert(subifd_offsets_.end(), &subifd_offsets[0], &subifd_offsets[subifd_count_]);\n    }\n\n    if (compression_ == COMPRESSION_JPEG)\n    {\n        uint8_t* jpegtable_data = nullptr;\n        uint32_t jpegtable_count = 0;\n\n        TIFFGetField(tif, TIFFTAG_JPEGTABLES, &jpegtable_count, &jpegtable_data);\n        jpegtable_.reserve(jpegtable_count);\n        jpegtable_.insert(jpegtable_.end(), jpegtable_data, jpegtable_data + jpegtable_count);\n\n        if (photometric_ == PHOTOMETRIC_RGB)\n        {\n            jpeg_color_space_ = 2; // JCS_RGB\n        }\n        else if (photometric_ == PHOTOMETRIC_YCBCR)\n        {\n            jpeg_color_space_ = 3; // JCS_YCbCr\n        }\n    }\n\n    image_piece_count_ = tif_dir.td_stripoffset_entry.tdir_count;\n\n    image_piece_offsets_.reserve(image_piece_count_);\n    uint64* td_stripoffset_p = tif_dir.td_stripoffset_p;\n    uint64* td_stripbytecount_p = tif_dir.td_stripbytecount_p;\n\n    // Copy data to vector\n    image_piece_offsets_.insert(image_piece_offsets_.end(), &td_stripoffset_p[0], &td_stripoffset_p[image_piece_count_]);\n    image_piece_bytecounts_.insert(\n        image_piece_bytecounts_.end(), &td_stripbytecount_p[0], &td_stripbytecount_p[image_piece_count_]);\n\n    // Calculate hash value with IFD index\n    hash_value_ = tiff->file_handle_->hash_value ^ cucim::codec::splitmix64(index);\n\n    //    TIFFPrintDirectory(tif, stdout, TIFFPRINT_STRIPS);\n}\n\nbool IFD::read(const TIFF* tiff,\n               const cucim::io::format::ImageMetadataDesc* metadata,\n               const cucim::io::format::ImageReaderRegionRequestDesc* request,\n               cucim::io::format::ImageDataDesc* out_image_data)\n{\n    PROF_SCOPED_RANGE(PROF_EVENT(ifd_read));\n    ::TIFF* tif = tiff->tiff_client_;\n\n    uint16_t ifd_index = ifd_index_;\n\n    std::string device_name(request->device);\n\n    if (request->shm_name)\n    {\n        device_name = device_name + fmt::format(\"[{}]\", request->shm_name); // TODO: check performance\n    }\n    cucim::io::Device out_device(device_name);\n\n    int64_t sx = request->location[0];\n    int64_t sy = request->location[1];\n    uint32_t batch_size = request->batch_size;\n    int64_t w = request->size[0];\n    int64_t h = request->size[1];\n    int32_t n_ch = samples_per_pixel_; // number of channels\n    int ndim = 3;\n\n    size_t raster_size = w * h * samples_per_pixel_;\n    void* raster = nullptr;\n    auto raster_type = cucim::io::DeviceType::kCPU;\n\n    DLTensor* out_buf = request->buf;\n    bool is_buf_available = out_buf && out_buf->data;\n\n    if (is_buf_available)\n    {\n        // TODO: memory size check if out_buf->data has high-enough memory (>= tjBufSize())\n        raster = out_buf->data;\n    }\n\n    if (is_read_optimizable())\n    {\n        if (batch_size > 1)\n        {\n            ndim = 4;\n        }\n        int64_t* location = request->location;\n        uint64_t location_len = request->location_len;\n        const uint32_t num_workers = request->num_workers;\n        const bool drop_last = request->drop_last;\n        uint32_t prefetch_factor = request->prefetch_factor;\n        const bool shuffle = request->shuffle;\n        const uint64_t seed = request->seed;\n\n        if (num_workers == 0 && location_len > 1)\n        {\n            throw std::runtime_error(\"Cannot read multiple locations with zero workers!\");\n        }\n\n        // Shuffle data\n        if (shuffle)\n        {\n            auto rng = std::default_random_engine{ seed };\n            struct position\n            {\n                int64_t x;\n                int64_t y;\n            };\n            std::shuffle(reinterpret_cast<position*>(&location[0]),\n                         reinterpret_cast<position*>(&location[location_len * 2]), rng);\n        }\n\n        // Adjust location length based on 'drop_last'\n        const uint32_t remaining_len = location_len % batch_size;\n        if (drop_last)\n        {\n            location_len -= remaining_len;\n        }\n\n        // Do not use prefetch if the image is too small\n        if (1 + prefetch_factor > location_len)\n        {\n            prefetch_factor = location_len - 1;\n        }\n\n        size_t one_raster_size = raster_size;\n        raster_size *= batch_size;\n\n        const IFD* ifd = this;\n\n        if (location_len > 1 || batch_size > 1 || num_workers > 0)\n        {\n            // Reconstruct location\n            std::unique_ptr<std::vector<int64_t>>* location_unique =\n                reinterpret_cast<std::unique_ptr<std::vector<int64_t>>*>(request->location_unique);\n            std::unique_ptr<std::vector<int64_t>> request_location = std::move(*location_unique);\n            delete location_unique;\n\n            // Reconstruct size\n            std::unique_ptr<std::vector<int64_t>>* size_unique =\n                reinterpret_cast<std::unique_ptr<std::vector<int64_t>>*>(request->size_unique);\n            std::unique_ptr<std::vector<int64_t>> request_size = std::move(*size_unique);\n            delete size_unique;\n\n            auto load_func = [tiff, ifd, location, w, h, out_device](\n                                 cucim::loader::ThreadBatchDataLoader* loader_ptr, uint64_t location_index) {\n                uint8_t* raster_ptr = loader_ptr->raster_pointer(location_index);\n\n                if (!read_region_tiles(tiff, ifd, location, location_index, w, h,\n                                       raster_ptr, out_device, loader_ptr))\n                {\n                    fmt::print(stderr, \"[Error] Failed to read region!\\n\");\n                }\n            };\n\n            uint32_t maximum_tile_count = 0;\n\n            std::unique_ptr<cucim::loader::BatchDataProcessor> batch_processor;\n\n            // Set raster_type to CUDA because loader will handle this with nvjpeg\n            if (out_device.type() == cucim::io::DeviceType::kCUDA)\n            {\n                raster_type = cucim::io::DeviceType::kCUDA;\n\n                // The maximal number of tiles (x-axis) overapped with the given patch\n                uint32_t tile_across_count = std::min(static_cast<uint64_t>(ifd->width_) + (ifd->tile_width_ - 1),\n                                                      static_cast<uint64_t>(w) + (ifd->tile_width_ - 1)) /\n                                                 ifd->tile_width_ +\n                                             1;\n                // The maximal number of tiles (y-axis) overapped with the given patch\n                uint32_t tile_down_count = std::min(static_cast<uint64_t>(ifd->height_) + (ifd->tile_height_ - 1),\n                                                    static_cast<uint64_t>(h) + (ifd->tile_height_ - 1)) /\n                                               ifd->tile_height_ +\n                                           1;\n                // The maximal number of possible tiles (# of tasks) to load for the given image batch\n                maximum_tile_count = tile_across_count * tile_down_count * batch_size;\n\n                // Create NvJpegProcessor\n                auto& jpegtable = ifd->jpegtable_;\n                const void* jpegtable_data = jpegtable.data();\n                uint32_t jpegtable_size = jpegtable.size();\n\n                auto nvjpeg_processor = std::make_unique<cuslide::loader::NvJpegProcessor>(\n                    tiff->file_handle_, ifd, request_location->data(), request_size->data(), location_len, batch_size,\n                    maximum_tile_count, static_cast<const uint8_t*>(jpegtable_data), jpegtable_size);\n\n                // Update prefetch_factor\n                prefetch_factor = nvjpeg_processor->preferred_loader_prefetch_factor();\n\n                batch_processor = std::move(nvjpeg_processor);\n            }\n\n            auto loader = std::make_unique<cucim::loader::ThreadBatchDataLoader>(\n                load_func, std::move(batch_processor), out_device, std::move(request_location), std::move(request_size),\n                location_len, one_raster_size, batch_size, prefetch_factor, num_workers);\n\n            const uint32_t load_size = std::min(static_cast<uint64_t>(batch_size) * (1 + prefetch_factor), location_len);\n\n            loader->request(load_size);\n\n            // If it reads entire image with multi threads (using loader), fetch the next item.\n            if (location_len == 1 && batch_size == 1)\n            {\n                raster = loader->next_data();\n            }\n\n            out_image_data->loader = loader.release(); // set loader to out_image_data\n        }\n        else\n        {\n            if (!raster)\n            {\n                raster = cucim_malloc(one_raster_size);\n            }\n\n            if (!read_region_tiles(tiff, ifd, location, 0, w, h, raster, out_device, nullptr))\n            {\n                fmt::print(stderr, \"[Error] Failed to read region!\\n\");\n            }\n        }\n    }\n    else\n    {\n        PROF_SCOPED_RANGE(PROF_EVENT(ifd_read_slowpath));\n        // Print a warning message for the slow path\n        std::call_once(\n            tiff->slow_path_warning_flag_,\n            [](const std::string& file_path) {\n                fmt::print(\n                    stderr,\n                    \"[Warning] Loading image('{}') with a slow-path. The pixel format of the loaded image would be RGBA (4 channels) instead of RGB!\\n\",\n                    file_path);\n            },\n            tiff->file_path());\n        // Handle out-of-boundary case\n        int64_t ex = sx + w - 1;\n        int64_t ey = sy + h - 1;\n        if (sx < 0 || sy < 0 || sx >= width_ || sy >= height_ || ex < 0 || ey < 0 || ex >= width_ || ey >= height_)\n        {\n            throw std::invalid_argument(fmt::format(\"Cannot handle the out-of-boundary cases.\"));\n        }\n\n        // Check if the image format is supported or not\n        if (!is_format_supported())\n        {\n            throw std::runtime_error(fmt::format(\n                \"This format (compression: {}, sample_per_pixel: {}, planar_config: {}, photometric: {}) is not supported yet!.\",\n                compression_, samples_per_pixel_, planar_config_, photometric_));\n        }\n\n        if (tif->tif_curdir != ifd_index)\n        {\n            TIFFSetDirectory(tif, ifd_index);\n        }\n        // RGBA -> 4 channels\n        n_ch = 4;\n\n        char emsg[1024];\n        if (TIFFRGBAImageOK(tif, emsg))\n        {\n            TIFFRGBAImage img;\n            if (TIFFRGBAImageBegin(&img, tif, -1, emsg))\n            {\n                size_t npixels;\n                npixels = w * h;\n                raster_size = npixels * 4;\n                if (!raster)\n                {\n                    raster = cucim_malloc(raster_size);\n                }\n                img.col_offset = sx;\n                img.row_offset = sy;\n                img.req_orientation = ORIENTATION_TOPLEFT;\n\n                if (raster != nullptr)\n                {\n                    if (!TIFFRGBAImageGet(&img, (uint32_t*)raster, w, h))\n                    {\n                        memset(raster, 0, raster_size);\n                    }\n                }\n            }\n            else\n            {\n                throw std::runtime_error(fmt::format(\n                    \"This format (compression: {}, sample_per_pixel: {}, planar_config: {}, photometric: {}) is not supported yet!: {}\",\n                    compression_, samples_per_pixel_, planar_config_, photometric_, emsg));\n            }\n            TIFFRGBAImageEnd(&img);\n        }\n        else\n        {\n            throw std::runtime_error(fmt::format(\n                \"This format (compression: {}, sample_per_pixel: {}, planar_config: {}, photometric: {}) is not supported yet!: {}\",\n                compression_, samples_per_pixel_, planar_config_, photometric_, emsg));\n        }\n    }\n\n    int64_t* shape = static_cast<int64_t*>(cucim_malloc(sizeof(int64_t) * ndim));\n    if (ndim == 3)\n    {\n        shape[0] = h;\n        shape[1] = w;\n        shape[2] = n_ch;\n    }\n    else // ndim == 4\n    {\n        shape[0] = batch_size;\n        shape[1] = h;\n        shape[2] = w;\n        shape[3] = n_ch;\n    }\n\n    // Copy the raster memory and free it if needed.\n    if (!is_buf_available && raster && raster_type == cucim::io::DeviceType::kCPU)\n    {\n        cucim::memory::move_raster_from_host(&raster, raster_size, out_device);\n    }\n\n    auto& out_image_container = out_image_data->container;\n    out_image_container.data = raster;\n    out_image_container.device = DLDevice{ static_cast<DLDeviceType>(out_device.type()), out_device.index() };\n    out_image_container.ndim = ndim;\n    out_image_container.dtype = metadata->dtype;\n    out_image_container.shape = shape;\n    out_image_container.strides = nullptr; // Tensor is compact and row-majored\n    out_image_container.byte_offset = 0;\n    auto& shm_name = out_device.shm_name();\n    size_t shm_name_len = shm_name.size();\n    if (shm_name_len != 0)\n    {\n        out_image_data->shm_name = static_cast<char*>(cucim_malloc(shm_name_len + 1));\n        memcpy(out_image_data->shm_name, shm_name.c_str(), shm_name_len + 1);\n    }\n    else\n    {\n        out_image_data->shm_name = nullptr;\n    }\n\n    return true;\n}\n\nuint32_t IFD::index() const\n{\n    return ifd_index_;\n}\nifd_offset_t IFD::offset() const\n{\n    return ifd_offset_;\n}\n\nstd::string& IFD::software()\n{\n    return software_;\n}\nstd::string& IFD::model()\n{\n    return model_;\n}\nstd::string& IFD::image_description()\n{\n    return image_description_;\n}\nuint16_t IFD::resolution_unit() const\n{\n    return resolution_unit_;\n}\nfloat IFD::x_resolution() const\n{\n    return x_resolution_;\n}\nfloat IFD::y_resolution() const\n{\n    return y_resolution_;\n}\nuint32_t IFD::width() const\n{\n    return width_;\n}\nuint32_t IFD::height() const\n{\n    return height_;\n}\nuint32_t IFD::tile_width() const\n{\n    return tile_width_;\n}\nuint32_t IFD::tile_height() const\n{\n    return tile_height_;\n}\nuint32_t IFD::rows_per_strip() const\n{\n    return rows_per_strip_;\n}\nuint32_t IFD::bits_per_sample() const\n{\n    return bits_per_sample_;\n}\nuint32_t IFD::samples_per_pixel() const\n{\n    return samples_per_pixel_;\n}\nuint64_t IFD::subfile_type() const\n{\n    return subfile_type_;\n}\nuint16_t IFD::planar_config() const\n{\n    return planar_config_;\n}\nuint16_t IFD::photometric() const\n{\n    return photometric_;\n}\nuint16_t IFD::compression() const\n{\n    return compression_;\n}\nuint16_t IFD::predictor() const\n{\n    return predictor_;\n}\n\nuint16_t IFD::subifd_count() const\n{\n    return subifd_count_;\n}\nstd::vector<uint64_t>& IFD::subifd_offsets()\n{\n    return subifd_offsets_;\n}\nuint32_t IFD::image_piece_count() const\n{\n    return image_piece_count_;\n}\nconst std::vector<uint64_t>& IFD::image_piece_offsets() const\n{\n    return image_piece_offsets_;\n}\nconst std::vector<uint64_t>& IFD::image_piece_bytecounts() const\n{\n    return image_piece_bytecounts_;\n}\n\nsize_t IFD::pixel_size_nbytes() const\n{\n    const int pixel_format = TJPF_RGB; // TODO: support other pixel format\n    const int nbytes = tjPixelSize[pixel_format];\n    return nbytes;\n}\n\nsize_t IFD::tile_raster_size_nbytes() const\n{\n    const size_t nbytes = tile_width_ * tile_height_ * pixel_size_nbytes();\n    return nbytes;\n}\n\nbool IFD::is_compression_supported() const\n{\n    switch (compression_)\n    {\n    case COMPRESSION_NONE:\n    case COMPRESSION_JPEG:\n    case COMPRESSION_ADOBE_DEFLATE:\n    case COMPRESSION_DEFLATE:\n    case cuslide::jpeg2k::kAperioJpeg2kYCbCr: // 33003: Jpeg 2000 with YCbCr format, possibly with a chroma subsampling\n                                              // of 4:2:2\n    case cuslide::jpeg2k::kAperioJpeg2kRGB: // 33005: Jpeg 2000 with RGB\n    case COMPRESSION_LZW:\n        return true;\n    default:\n        return false;\n    }\n}\n\nbool IFD::is_read_optimizable() const\n{\n    return is_compression_supported() && bits_per_sample_ == 8 && samples_per_pixel_ == 3 &&\n           (tile_width_ != 0 && tile_height_ != 0) && planar_config_ == PLANARCONFIG_CONTIG &&\n           (photometric_ == PHOTOMETRIC_RGB || photometric_ == PHOTOMETRIC_YCBCR) &&\n           !tiff_->is_in_read_config(TIFF::kUseLibTiff);\n}\n\nbool IFD::is_format_supported() const\n{\n    return is_compression_supported();\n}\n\nbool IFD::read_region_tiles(const TIFF* tiff,\n                            const IFD* ifd,\n                            const int64_t* location,\n                            const int64_t location_index,\n                            const int64_t w,\n                            const int64_t h,\n                            void* raster,\n                            const cucim::io::Device& out_device,\n                            cucim::loader::ThreadBatchDataLoader* loader)\n{\n    PROF_SCOPED_RANGE(PROF_EVENT(ifd_read_region_tiles));\n    // Reference code: https://github.com/libjpeg-turbo/libjpeg-turbo/blob/master/tjexample.c\n\n    int64_t sx = location[location_index * 2];\n    int64_t sy = location[location_index * 2 + 1];\n    int64_t ex = sx + w - 1;\n    int64_t ey = sy + h - 1;\n\n    uint32_t width = ifd->width_;\n    uint32_t height = ifd->height_;\n\n    // Handle out-of-boundary case\n    if (sx < 0 || sy < 0 || sx >= width || sy >= height || ex < 0 || ey < 0 || ex >= width || ey >= height)\n    {\n        return read_region_tiles_boundary(tiff, ifd, location, location_index, w, h, raster, out_device, loader);\n    }\n    cucim::cache::ImageCache& image_cache = cucim::CuImage::cache_manager().cache();\n    cucim::cache::CacheType cache_type = image_cache.type();\n\n    uint8_t background_value = tiff->background_value_;\n    uint16_t compression_method = ifd->compression_;\n    int jpeg_color_space = ifd->jpeg_color_space_;\n    int predictor = ifd->predictor_;\n\n    // TODO: revert this once we can get RGB data instead of RGBA\n    uint32_t samples_per_pixel = 3; // ifd->samples_per_pixel();\n\n    const void* jpegtable_data = ifd->jpegtable_.data();\n    uint32_t jpegtable_count = ifd->jpegtable_.size();\n\n    uint32_t tw = ifd->tile_width_;\n    uint32_t th = ifd->tile_height_;\n\n    uint32_t offset_sx = static_cast<uint32_t>(sx / tw); // x-axis start offset for the requested region in the ifd tile\n                                                         // array as grid\n    uint32_t offset_ex = static_cast<uint32_t>(ex / tw); // x-axis end  offset for the requested region in the ifd tile\n                                                         // array as grid\n    uint32_t offset_sy = static_cast<uint32_t>(sy / th); // y-axis start offset for the requested region in the ifd tile\n                                                         // array as grid\n    uint32_t offset_ey = static_cast<uint32_t>(ey / th); // y-axis end offset for the requested region in the ifd tile\n                                                         // array as grid\n\n    uint32_t pixel_offset_sx = static_cast<uint32_t>(sx % tw);\n    uint32_t pixel_offset_ex = static_cast<uint32_t>(ex % tw);\n    uint32_t pixel_offset_sy = static_cast<uint32_t>(sy % th);\n    uint32_t pixel_offset_ey = static_cast<uint32_t>(ey % th);\n\n    uint32_t stride_y = width / tw + !!(width % tw); // # of tiles in a row(y) in the ifd tile array as grid\n\n    uint32_t start_index_y = offset_sy * stride_y;\n    uint32_t end_index_y = offset_ey * stride_y;\n\n    const size_t tile_raster_nbytes = ifd->tile_raster_size_nbytes();\n\n    int tiff_file = tiff->file_handle_->fd;\n    uint64_t ifd_hash_value = ifd->hash_value_;\n    uint32_t dest_pixel_step_y = w * samples_per_pixel;\n\n    uint32_t nbytes_tw = tw * samples_per_pixel;\n    auto dest_start_ptr = static_cast<uint8_t*>(raster);\n\n    // TODO: Current implementation doesn't consider endianness so need to consider later\n    // TODO: Consider tile's depth tag.\n    for (uint32_t index_y = start_index_y; index_y <= end_index_y; index_y += stride_y)\n    {\n        uint32_t tile_pixel_offset_sy = (index_y == start_index_y) ? pixel_offset_sy : 0;\n        uint32_t tile_pixel_offset_ey = (index_y == end_index_y) ? pixel_offset_ey : (th - 1);\n        uint32_t dest_pixel_offset_len_y = tile_pixel_offset_ey - tile_pixel_offset_sy + 1;\n\n        uint32_t dest_pixel_index_x = 0;\n\n        uint32_t index = index_y + offset_sx;\n        for (uint32_t offset_x = offset_sx; offset_x <= offset_ex; ++offset_x, ++index)\n        {\n            PROF_SCOPED_RANGE(PROF_EVENT_P(ifd_read_region_tiles_iter, index));\n            auto tiledata_offset = static_cast<uint64_t>(ifd->image_piece_offsets_[index]);\n            auto tiledata_size = static_cast<uint64_t>(ifd->image_piece_bytecounts_[index]);\n\n            // Calculate a simple hash value for the tile index\n            uint64_t index_hash = ifd_hash_value ^ (static_cast<uint64_t>(index) | (static_cast<uint64_t>(index) << 32));\n\n            uint32_t tile_pixel_offset_x = (offset_x == offset_sx) ? pixel_offset_sx : 0;\n            uint32_t nbytes_tile_pixel_size_x = (offset_x == offset_ex) ?\n                                                    (pixel_offset_ex - tile_pixel_offset_x + 1) * samples_per_pixel :\n                                                    (tw - tile_pixel_offset_x) * samples_per_pixel;\n            auto decode_func = [=, &image_cache]() {\n                PROF_SCOPED_RANGE(PROF_EVENT_P(ifd_read_region_tiles_task, index_hash));\n                uint32_t nbytes_tile_index = (tile_pixel_offset_sy * tw + tile_pixel_offset_x) * samples_per_pixel;\n                uint32_t dest_pixel_index = dest_pixel_index_x;\n                uint8_t* tile_data = nullptr;\n                if (tiledata_size > 0)\n                {\n                    std::unique_ptr<uint8_t, decltype(cucim_free)*> tile_raster =\n                        std::unique_ptr<uint8_t, decltype(cucim_free)*>(nullptr, cucim_free);\n\n                    if (loader && loader->batch_data_processor())\n                    {\n                        switch (compression_method)\n                        {\n                        case COMPRESSION_JPEG:\n                            break;\n                        default:\n                            throw std::runtime_error(\"Unsupported compression method\");\n                        }\n                        auto value = loader->wait_for_processing(index);\n                        if (!value) // if shutdown\n                        {\n                            return;\n                        }\n                        tile_data = static_cast<uint8_t*>(value->data);\n\n                        cudaError_t cuda_status;\n                        CUDA_ERROR(cudaMemcpy2D(dest_start_ptr + dest_pixel_index, dest_pixel_step_y,\n                                                tile_data + nbytes_tile_index, nbytes_tw, nbytes_tile_pixel_size_x,\n                                                tile_pixel_offset_ey - tile_pixel_offset_sy + 1,\n                                                cudaMemcpyDeviceToDevice));\n                    }\n                    else\n                    {\n                        auto key = image_cache.create_key(ifd_hash_value, index);\n                        image_cache.lock(index_hash);\n                        auto value = image_cache.find(key);\n                        if (value)\n                        {\n                            image_cache.unlock(index_hash);\n                            tile_data = static_cast<uint8_t*>(value->data);\n                        }\n                        else\n                        {\n                            // Lifetime of tile_data is same with `value`\n                            // : do not access this data when `value` is not accessible.\n                            if (cache_type != cucim::cache::CacheType::kNoCache)\n                            {\n                                tile_data = static_cast<uint8_t*>(image_cache.allocate(tile_raster_nbytes));\n                            }\n                            else\n                            {\n                                // Allocate temporary buffer for tile data\n                                tile_raster = std::unique_ptr<uint8_t, decltype(cucim_free)*>(\n                                    reinterpret_cast<uint8_t*>(cucim_malloc(tile_raster_nbytes)), cucim_free);\n                                tile_data = tile_raster.get();\n                            }\n                            {\n                                PROF_SCOPED_RANGE(PROF_EVENT(ifd_decompression));\n                                switch (compression_method)\n                                {\n                                case COMPRESSION_NONE:\n                                    cuslide::raw::decode_raw(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                             &tile_data, tile_raster_nbytes, out_device);\n                                    break;\n                                case COMPRESSION_JPEG:\n                                    cuslide::jpeg::decode_libjpeg(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                                  jpegtable_data, jpegtable_count, &tile_data,\n                                                                  out_device, jpeg_color_space);\n                                    break;\n                                case COMPRESSION_ADOBE_DEFLATE:\n                                case COMPRESSION_DEFLATE:\n                                    cuslide::deflate::decode_deflate(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                                     &tile_data, tile_raster_nbytes, out_device);\n                                    break;\n                                case cuslide::jpeg2k::kAperioJpeg2kYCbCr: // 33003\n                                    cuslide::jpeg2k::decode_libopenjpeg(tiff_file, nullptr, tiledata_offset,\n                                                                        tiledata_size, &tile_data, tile_raster_nbytes,\n                                                                        out_device, cuslide::jpeg2k::ColorSpace::kSYCC);\n                                    break;\n                                case cuslide::jpeg2k::kAperioJpeg2kRGB: // 33005\n                                    cuslide::jpeg2k::decode_libopenjpeg(tiff_file, nullptr, tiledata_offset,\n                                                                        tiledata_size, &tile_data, tile_raster_nbytes,\n                                                                        out_device, cuslide::jpeg2k::ColorSpace::kRGB);\n                                    break;\n                                case COMPRESSION_LZW:\n                                    cuslide::lzw::decode_lzw(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                             &tile_data, tile_raster_nbytes, out_device);\n                                    // Apply unpredictor\n                                    //   1: none, 2: horizontal differencing, 3: floating point predictor\n                                    //   https://www.adobe.io/content/dam/udp/en/open/standards/tiff/TIFF6.pdf\n                                    if (predictor == 2)\n                                    {\n                                        cuslide::lzw::horAcc8(tile_data, tile_raster_nbytes, nbytes_tw);\n                                    }\n                                    break;\n                                default:\n                                    throw std::runtime_error(\"Unsupported compression method\");\n                                }\n                            }\n\n                            value = image_cache.create_value(tile_data, tile_raster_nbytes);\n                            image_cache.insert(key, value);\n                            image_cache.unlock(index_hash);\n                        }\n\n                        for (uint32_t ty = tile_pixel_offset_sy; ty <= tile_pixel_offset_ey;\n                             ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                        {\n                            memcpy(dest_start_ptr + dest_pixel_index, tile_data + nbytes_tile_index,\n                                   nbytes_tile_pixel_size_x);\n                        }\n                    }\n                }\n                else\n                {\n                    if (out_device.type() == cucim::io::DeviceType::kCPU)\n                    {\n                        for (uint32_t ty = tile_pixel_offset_sy; ty <= tile_pixel_offset_ey;\n                             ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                        {\n                            // Set background value such as (255,255,255)\n                            memset(dest_start_ptr + dest_pixel_index, background_value, nbytes_tile_pixel_size_x);\n                        }\n                    }\n                    else\n                    {\n                        cudaError_t cuda_status;\n                        CUDA_ERROR(cudaMemset2D(dest_start_ptr + dest_pixel_index, dest_pixel_step_y, background_value,\n                                                nbytes_tile_pixel_size_x,\n                                                tile_pixel_offset_ey - tile_pixel_offset_sy + 1));\n                    }\n                }\n            };\n\n            if (loader && *loader)\n            {\n                loader->enqueue(std::move(decode_func),\n                                cucim::loader::TileInfo{ location_index, index, tiledata_offset, tiledata_size });\n            }\n            else\n            {\n                decode_func();\n            }\n\n            dest_pixel_index_x += nbytes_tile_pixel_size_x;\n        }\n        dest_start_ptr += dest_pixel_step_y * dest_pixel_offset_len_y;\n    }\n\n    return true;\n}\n\nbool IFD::read_region_tiles_boundary(const TIFF* tiff,\n                                     const IFD* ifd,\n                                     const int64_t* location,\n                                     const int64_t location_index,\n                                     const int64_t w,\n                                     const int64_t h,\n                                     void* raster,\n                                     const cucim::io::Device& out_device,\n                                     cucim::loader::ThreadBatchDataLoader* loader)\n{\n    PROF_SCOPED_RANGE(PROF_EVENT(ifd_read_region_tiles_boundary));\n    (void)out_device;\n    // Reference code: https://github.com/libjpeg-turbo/libjpeg-turbo/blob/master/tjexample.c\n    int64_t sx = location[location_index * 2];\n    int64_t sy = location[location_index * 2 + 1];\n\n    uint8_t background_value = tiff->background_value_;\n    uint16_t compression_method = ifd->compression_;\n    int jpeg_color_space = ifd->jpeg_color_space_;\n    int predictor = ifd->predictor_;\n\n    int64_t ex = sx + w - 1;\n    int64_t ey = sy + h - 1;\n\n    uint32_t width = ifd->width_;\n    uint32_t height = ifd->height_;\n\n    // Memory for tile_raster would be manually allocated here, instead of using decode_libjpeg().\n    // Need to free the manually. Usually it is set to nullptr and memory is created by decode_libjpeg() by using\n    // tjAlloc() (Also need to free with tjFree() after use. See the documentation of tjAlloc() for the detail.)\n    const int pixel_size_nbytes = ifd->pixel_size_nbytes();\n    auto dest_start_ptr = static_cast<uint8_t*>(raster);\n\n    bool is_out_of_image = (ex < 0 || width <= sx || ey < 0 || height <= sy);\n    if (is_out_of_image)\n    {\n        // Fill background color(255,255,255) and return\n        memset(dest_start_ptr, background_value, w * h * pixel_size_nbytes);\n        return true;\n    }\n    cucim::cache::ImageCache& image_cache = cucim::CuImage::cache_manager().cache();\n    cucim::cache::CacheType cache_type = image_cache.type();\n\n    uint32_t tw = ifd->tile_width_;\n    uint32_t th = ifd->tile_height_;\n\n    const size_t tile_raster_nbytes = tw * th * pixel_size_nbytes;\n\n    // TODO: revert this once we can get RGB data instead of RGBA\n    uint32_t samples_per_pixel = 3; // ifd->samples_per_pixel();\n\n    const void* jpegtable_data = ifd->jpegtable_.data();\n    uint32_t jpegtable_count = ifd->jpegtable_.size();\n\n    bool sx_in_range = (sx >= 0 && sx < width);\n    bool ex_in_range = (ex >= 0 && ex < width);\n    bool sy_in_range = (sy >= 0 && sy < height);\n    bool ey_in_range = (ey >= 0 && ey < height);\n\n    int64_t offset_boundary_x = (static_cast<int64_t>(width) - 1) / tw;\n    int64_t offset_boundary_y = (static_cast<int64_t>(height) - 1) / th;\n\n    int64_t offset_sx = sx / tw; // x-axis start offset for the requested region in the\n                                 // ifd tile array as grid\n\n    int64_t offset_ex = ex / tw; // x-axis end  offset for the requested region in the\n                                 // ifd tile array as grid\n\n    int64_t offset_sy = sy / th; // y-axis start offset for the requested region in the\n                                 // ifd tile array as grid\n    int64_t offset_ey = ey / th; // y-axis end offset for the requested region in the\n                                 // ifd tile array as grid\n    int64_t pixel_offset_sx = (sx % tw);\n    int64_t pixel_offset_ex = (ex % tw);\n    int64_t pixel_offset_sy = (sy % th);\n    int64_t pixel_offset_ey = (ey % th);\n    int64_t pixel_offset_boundary_x = ((width - 1) % tw);\n    int64_t pixel_offset_boundary_y = ((height - 1) % th);\n\n    // Make sure that division and modulo has same value with Python's one (e.g., making -1 / 3 == -1 instead of 0)\n    if (pixel_offset_sx < 0)\n    {\n        pixel_offset_sx += tw;\n        --offset_sx;\n    }\n    if (pixel_offset_ex < 0)\n    {\n        pixel_offset_ex += tw;\n        --offset_ex;\n    }\n    if (pixel_offset_sy < 0)\n    {\n        pixel_offset_sy += th;\n        --offset_sy;\n    }\n    if (pixel_offset_ey < 0)\n    {\n        pixel_offset_ey += th;\n        --offset_ey;\n    }\n    int64_t offset_min_x = sx_in_range ? offset_sx : 0;\n    int64_t offset_max_x = ex_in_range ? offset_ex : offset_boundary_x;\n    int64_t offset_min_y = sy_in_range ? offset_sy : 0;\n    int64_t offset_max_y = ey_in_range ? offset_ey : offset_boundary_y;\n\n    uint32_t stride_y = width / tw + !!(width % tw); // # of tiles in a row(y) in the ifd tile array as grid\n\n    int64_t start_index_y = offset_sy * stride_y;\n    int64_t start_index_min_y = offset_min_y * stride_y;\n    int64_t end_index_y = offset_ey * stride_y;\n    int64_t end_index_max_y = offset_max_y * stride_y;\n    int64_t boundary_index_y = offset_boundary_y * stride_y;\n\n\n    int tiff_file = tiff->file_handle_->fd;\n    uint64_t ifd_hash_value = ifd->hash_value_;\n\n    uint32_t dest_pixel_step_y = w * samples_per_pixel;\n    uint32_t nbytes_tw = tw * samples_per_pixel;\n\n\n    // TODO: Current implementation doesn't consider endianness so need to consider later\n    // TODO: Consider tile's depth tag.\n    // TODO: update the type of variables (index, index_y) : other function uses uint32_t\n    for (int64_t index_y = start_index_y; index_y <= end_index_y; index_y += stride_y)\n    {\n        uint32_t tile_pixel_offset_sy = (index_y == start_index_y) ? pixel_offset_sy : 0;\n        uint32_t tile_pixel_offset_ey = (index_y == end_index_y) ? pixel_offset_ey : (th - 1);\n        uint32_t dest_pixel_offset_len_y = tile_pixel_offset_ey - tile_pixel_offset_sy + 1;\n\n        uint32_t dest_pixel_index_x = 0;\n\n        int64_t index = index_y + offset_sx;\n        for (int64_t offset_x = offset_sx; offset_x <= offset_ex; ++offset_x, ++index)\n        {\n            PROF_SCOPED_RANGE(PROF_EVENT_P(ifd_read_region_tiles_boundary_iter, index));\n            uint64_t tiledata_offset = 0;\n            uint64_t tiledata_size = 0;\n\n            // Calculate a simple hash value for the tile index\n            uint64_t index_hash = ifd_hash_value ^ (static_cast<uint64_t>(index) | (static_cast<uint64_t>(index) << 32));\n\n            if (offset_x >= offset_min_x && offset_x <= offset_max_x && index_y >= start_index_min_y &&\n                index_y <= end_index_max_y)\n            {\n                tiledata_offset = static_cast<uint64_t>(ifd->image_piece_offsets_[index]);\n                tiledata_size = static_cast<uint64_t>(ifd->image_piece_bytecounts_[index]);\n            }\n\n            uint32_t tile_pixel_offset_x = (offset_x == offset_sx) ? pixel_offset_sx : 0;\n            uint32_t nbytes_tile_pixel_size_x = (offset_x == offset_ex) ?\n                                                    (pixel_offset_ex - tile_pixel_offset_x + 1) * samples_per_pixel :\n                                                    (tw - tile_pixel_offset_x) * samples_per_pixel;\n\n            uint32_t nbytes_tile_index_orig = (tile_pixel_offset_sy * tw + tile_pixel_offset_x) * samples_per_pixel;\n            uint32_t dest_pixel_index_orig = dest_pixel_index_x;\n\n            auto decode_func = [=, &image_cache]() {\n                PROF_SCOPED_RANGE(PROF_EVENT_P(ifd_read_region_tiles_boundary_task, index_hash));\n                uint32_t nbytes_tile_index = nbytes_tile_index_orig;\n                uint32_t dest_pixel_index = dest_pixel_index_orig;\n\n                if (tiledata_size > 0)\n                {\n                    bool copy_partial = false;\n                    uint32_t fixed_nbytes_tile_pixel_size_x = nbytes_tile_pixel_size_x;\n                    uint32_t fixed_tile_pixel_offset_ey = tile_pixel_offset_ey;\n\n                    if (offset_x == offset_boundary_x)\n                    {\n                        copy_partial = true;\n                        if (offset_x != offset_ex)\n                        {\n                            fixed_nbytes_tile_pixel_size_x =\n                                (pixel_offset_boundary_x - tile_pixel_offset_x + 1) * samples_per_pixel;\n                        }\n                        else\n                        {\n                            fixed_nbytes_tile_pixel_size_x =\n                                (std::min(pixel_offset_boundary_x, pixel_offset_ex) - tile_pixel_offset_x + 1) *\n                                samples_per_pixel;\n                        }\n                    }\n                    if (index_y == boundary_index_y)\n                    {\n                        copy_partial = true;\n                        if (index_y != end_index_y)\n                        {\n                            fixed_tile_pixel_offset_ey = pixel_offset_boundary_y;\n                        }\n                        else\n                        {\n                            fixed_tile_pixel_offset_ey = std::min(pixel_offset_boundary_y, pixel_offset_ey);\n                        }\n                    }\n\n                    uint8_t* tile_data = nullptr;\n                    std::unique_ptr<uint8_t, decltype(cucim_free)*> tile_raster =\n                        std::unique_ptr<uint8_t, decltype(cucim_free)*>(nullptr, cucim_free);\n\n                    if (loader && loader->batch_data_processor())\n                    {\n                        switch (compression_method)\n                        {\n                        case COMPRESSION_JPEG:\n                            break;\n                        default:\n                            throw std::runtime_error(\"Unsupported compression method\");\n                        }\n                        auto value = loader->wait_for_processing(index);\n                        if (!value) // if shutdown\n                        {\n                            return;\n                        }\n\n                        tile_data = static_cast<uint8_t*>(value->data);\n\n                        cudaError_t cuda_status;\n                        if (copy_partial)\n                        {\n                            uint32_t fill_gap_x = nbytes_tile_pixel_size_x - fixed_nbytes_tile_pixel_size_x;\n                            // Fill original, then fill white for remaining\n                            if (fill_gap_x > 0)\n                            {\n                                CUDA_ERROR(cudaMemcpy2D(\n                                    dest_start_ptr + dest_pixel_index, dest_pixel_step_y, tile_data + nbytes_tile_index,\n                                    nbytes_tw, fixed_nbytes_tile_pixel_size_x,\n                                    fixed_tile_pixel_offset_ey - tile_pixel_offset_sy + 1, cudaMemcpyDeviceToDevice));\n                                CUDA_ERROR(cudaMemset2D(dest_start_ptr + dest_pixel_index + fixed_nbytes_tile_pixel_size_x,\n                                                        dest_pixel_step_y, background_value, fill_gap_x,\n                                                        fixed_tile_pixel_offset_ey - tile_pixel_offset_sy + 1));\n                                dest_pixel_index +=\n                                    dest_pixel_step_y * (fixed_tile_pixel_offset_ey - tile_pixel_offset_sy + 1);\n                            }\n                            else\n                            {\n                                CUDA_ERROR(cudaMemcpy2D(\n                                    dest_start_ptr + dest_pixel_index, dest_pixel_step_y, tile_data + nbytes_tile_index,\n                                    nbytes_tw, fixed_nbytes_tile_pixel_size_x,\n                                    fixed_tile_pixel_offset_ey - tile_pixel_offset_sy + 1, cudaMemcpyDeviceToDevice));\n                                dest_pixel_index +=\n                                    dest_pixel_step_y * (fixed_tile_pixel_offset_ey - tile_pixel_offset_sy + 1);\n                            }\n\n                            CUDA_ERROR(cudaMemset2D(dest_start_ptr + dest_pixel_index, dest_pixel_step_y,\n                                                    background_value, nbytes_tile_pixel_size_x,\n                                                    tile_pixel_offset_ey - (fixed_tile_pixel_offset_ey + 1) + 1));\n                        }\n                        else\n                        {\n                            CUDA_ERROR(cudaMemcpy2D(dest_start_ptr + dest_pixel_index, dest_pixel_step_y,\n                                                    tile_data + nbytes_tile_index, nbytes_tw, nbytes_tile_pixel_size_x,\n                                                    tile_pixel_offset_ey - tile_pixel_offset_sy + 1,\n                                                    cudaMemcpyDeviceToDevice));\n                        }\n                    }\n                    else\n                    {\n                        auto key = image_cache.create_key(ifd_hash_value, index);\n                        image_cache.lock(index_hash);\n                        auto value = image_cache.find(key);\n                        if (value)\n                        {\n                            image_cache.unlock(index_hash);\n                            tile_data = static_cast<uint8_t*>(value->data);\n                        }\n                        else\n                        {\n                            // Lifetime of tile_data is same with `value`\n                            // : do not access this data when `value` is not accessible.\n                            if (cache_type != cucim::cache::CacheType::kNoCache)\n                            {\n                                tile_data = static_cast<uint8_t*>(image_cache.allocate(tile_raster_nbytes));\n                            }\n                            else\n                            {\n                                // Allocate temporary buffer for tile data\n                                tile_raster = std::unique_ptr<uint8_t, decltype(cucim_free)*>(\n                                    reinterpret_cast<uint8_t*>(cucim_malloc(tile_raster_nbytes)), cucim_free);\n                                tile_data = tile_raster.get();\n                            }\n                            {\n                                PROF_SCOPED_RANGE(PROF_EVENT(ifd_decompression));\n                                switch (compression_method)\n                                {\n                                case COMPRESSION_NONE:\n                                    cuslide::raw::decode_raw(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                             &tile_data, tile_raster_nbytes, out_device);\n                                    break;\n                                case COMPRESSION_JPEG:\n                                    cuslide::jpeg::decode_libjpeg(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                                  jpegtable_data, jpegtable_count, &tile_data,\n                                                                  out_device, jpeg_color_space);\n                                    break;\n                                case COMPRESSION_ADOBE_DEFLATE:\n                                case COMPRESSION_DEFLATE:\n                                    cuslide::deflate::decode_deflate(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                                     &tile_data, tile_raster_nbytes, out_device);\n                                    break;\n                                case cuslide::jpeg2k::kAperioJpeg2kYCbCr: // 33003\n                                    cuslide::jpeg2k::decode_libopenjpeg(tiff_file, nullptr, tiledata_offset,\n                                                                        tiledata_size, &tile_data, tile_raster_nbytes,\n                                                                        out_device, cuslide::jpeg2k::ColorSpace::kSYCC);\n                                    break;\n                                case cuslide::jpeg2k::kAperioJpeg2kRGB: // 33005\n                                    cuslide::jpeg2k::decode_libopenjpeg(tiff_file, nullptr, tiledata_offset,\n                                                                        tiledata_size, &tile_data, tile_raster_nbytes,\n                                                                        out_device, cuslide::jpeg2k::ColorSpace::kRGB);\n                                    break;\n                                case COMPRESSION_LZW:\n                                    cuslide::lzw::decode_lzw(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                             &tile_data, tile_raster_nbytes, out_device);\n                                    // Apply unpredictor\n                                    //   1: none, 2: horizontal differencing, 3: floating point predictor\n                                    //   https://www.adobe.io/content/dam/udp/en/open/standards/tiff/TIFF6.pdf\n                                    if (predictor == 2)\n                                    {\n                                        cuslide::lzw::horAcc8(tile_data, tile_raster_nbytes, nbytes_tw);\n                                    }\n                                    break;\n                                default:\n                                    throw std::runtime_error(\"Unsupported compression method\");\n                                }\n                            }\n                            value = image_cache.create_value(tile_data, tile_raster_nbytes);\n                            image_cache.insert(key, value);\n                            image_cache.unlock(index_hash);\n                        }\n                        if (copy_partial)\n                        {\n                            uint32_t fill_gap_x = nbytes_tile_pixel_size_x - fixed_nbytes_tile_pixel_size_x;\n                            // Fill original, then fill white for remaining\n                            if (fill_gap_x > 0)\n                            {\n                                for (uint32_t ty = tile_pixel_offset_sy; ty <= fixed_tile_pixel_offset_ey;\n                                     ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                                {\n                                    memcpy(dest_start_ptr + dest_pixel_index, tile_data + nbytes_tile_index,\n                                           fixed_nbytes_tile_pixel_size_x);\n                                    memset(dest_start_ptr + dest_pixel_index + fixed_nbytes_tile_pixel_size_x,\n                                           background_value, fill_gap_x);\n                                }\n                            }\n                            else\n                            {\n                                for (uint32_t ty = tile_pixel_offset_sy; ty <= fixed_tile_pixel_offset_ey;\n                                     ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                                {\n                                    memcpy(dest_start_ptr + dest_pixel_index, tile_data + nbytes_tile_index,\n                                           fixed_nbytes_tile_pixel_size_x);\n                                }\n                            }\n\n                            for (uint32_t ty = fixed_tile_pixel_offset_ey + 1; ty <= tile_pixel_offset_ey;\n                                 ++ty, dest_pixel_index += dest_pixel_step_y)\n                            {\n                                memset(dest_start_ptr + dest_pixel_index, background_value, nbytes_tile_pixel_size_x);\n                            }\n                        }\n                        else\n                        {\n                            for (uint32_t ty = tile_pixel_offset_sy; ty <= tile_pixel_offset_ey;\n                                 ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                            {\n                                memcpy(dest_start_ptr + dest_pixel_index, tile_data + nbytes_tile_index,\n                                       nbytes_tile_pixel_size_x);\n                            }\n                        }\n                    }\n                }\n                else\n                {\n\n                    if (out_device.type() == cucim::io::DeviceType::kCPU)\n                    {\n                        for (uint32_t ty = tile_pixel_offset_sy; ty <= tile_pixel_offset_ey;\n                             ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                        {\n                            // Set (255,255,255)\n                            memset(dest_start_ptr + dest_pixel_index, background_value, nbytes_tile_pixel_size_x);\n                        }\n                    }\n                    else\n                    {\n                        cudaError_t cuda_status;\n                        CUDA_ERROR(cudaMemset2D(dest_start_ptr + dest_pixel_index, dest_pixel_step_y, background_value,\n                                                nbytes_tile_pixel_size_x, tile_pixel_offset_ey - tile_pixel_offset_sy));\n                    }\n                }\n            };\n\n            if (loader && *loader)\n            {\n                loader->enqueue(std::move(decode_func),\n                                cucim::loader::TileInfo{ location_index, index, tiledata_offset, tiledata_size });\n            }\n            else\n            {\n                decode_func();\n            }\n\n            dest_pixel_index_x += nbytes_tile_pixel_size_x;\n        }\n        dest_start_ptr += dest_pixel_step_y * dest_pixel_offset_len_y;\n    }\n    return true;\n}\n\n} // namespace cuslide::tiff\n\n\n// Hidden methods for benchmarking.\n\n#include <fmt/format.h>\n#include <langinfo.h>\n#include <iostream>\n#include <fstream>\n\nnamespace cuslide::tiff\n{\nvoid IFD::write_offsets_(const char* file_path)\n{\n    std::ofstream offsets(fmt::format(\"{}.offsets\", file_path), std::ios::out | std::ios::binary | std::ios::trunc);\n    std::ofstream bytecounts(fmt::format(\"{}.bytecounts\", file_path), std::ios::out | std::ios::binary | std::ios::trunc);\n\n    offsets.write(reinterpret_cast<char*>(&image_piece_count_), sizeof(image_piece_count_));\n    bytecounts.write(reinterpret_cast<char*>(&image_piece_count_), sizeof(image_piece_count_));\n    for (uint32_t i = 0; i < image_piece_count_; i++)\n    {\n        offsets.write(reinterpret_cast<char*>(&image_piece_offsets_[i]), sizeof(image_piece_offsets_[i]));\n        bytecounts.write(reinterpret_cast<char*>(&image_piece_bytecounts_[i]), sizeof(image_piece_bytecounts_[i]));\n    }\n    bytecounts.close();\n    offsets.close();\n}\n\n} // namespace cuslide::tiff\n",
                "name": "ifd.cpp",
                "path": "cpp/plugins/cucim.kit.cuslide/src/cuslide/tiff/ifd.cpp",
                "url": "/github.com/rapidsai/cucim/-/blob/cpp/plugins/cucim.kit.cuslide/src/cuslide/tiff/ifd.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 369,
                    "offsetAndLengths": [
                        [
                            25,
                            16
                        ]
                    ],
                    "preview": "                    if (!TIFFRGBAImageGet(&img, (uint32_t*)raster, w, h))"
                }
            ],
            "repository": {
                "name": "github.com/rapidsai/cucim",
                "url": "/github.com/rapidsai/cucim"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "23b9043a2bd576e90bb542f1f76be2d6bfb5fd3c"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "thirdparty/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/opentoonz/opentoonz/-/blob/thirdparty/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/opentoonz/opentoonz",
                "url": "/github.com/opentoonz/opentoonz"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "b6715ba10ccc73bcdd51b221e3d05e393d14ede4"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "thirdparty/tiff-4.2.0/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/tahoma2d/tahoma2d/-/blob/thirdparty/tiff-4.2.0/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/tahoma2d/tahoma2d",
                "url": "/github.com/tahoma2d/tahoma2d"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "a09a46246168a6bb8e8e32a5eb8256440690f6bc"
                },
                "content": "#include \"StdAfx.h\"\n\n// #define STRICT\n#include \"diblib.h\"\n#include <commdlg.h>\n#include <stdlib.h> // MAX_ constants\n#include <windows.h>\n#include <windowsx.h>\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage\n{\n    TIFFRGBAImage tif;\n    int dibinstalled;\n};\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster);\n\nstatic void MyWarningHandler(const char *module, const char *fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void MyErrorHandler(const char *module, const char *fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF(LPCTSTR lpszPath)\n{\n    int rtn = 0;\n\n    TIFFErrorHandler eh;\n    TIFFErrorHandler wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF *tif = TIFFOpen(lpszPath, \"r\");\n    if (tif)\n    {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage *img);\n\nPVOID ReadTIFF(LPCTSTR lpszPath)\n{\n    void *pDIB = 0;\n    TIFFErrorHandler wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath))\n    {\n        TIFF *tif = TIFFOpen(lpszPath, \"r\");\n        if (tif)\n        {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg))\n            {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg))\n                {\n                    size_t npixels;\n                    uint32_t *raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster =\n                        (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n                    if (raster != NULL)\n                    {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width,\n                                             img.tif.height))\n                        {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else\n            {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg);\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster)\n{\n    void *pDIB = 0;\n    TIFFRGBAImage *img = &dib->tif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER bi;\n    int dwDIBSize;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if (BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled)\n    { // bilevel\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 1;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed = 0;\n        pRgbq[0].rgbBlue = 0;\n        pRgbq[0].rgbGreen = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed = 255;\n        pRgbq[1].rgbBlue = 255;\n        pRgbq[1].rgbGreen = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr(\n            (BITMAPINFOHEADER *)pDIB); //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n    //  For now just always default to the RGB 32 bit form. // save as 32 bit\n    //  for simplicity\n    else if (true /*BitsPerSample == 8 && SamplePerPixel == 3*/)\n    { // 24 bit color\n\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 32;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        // Swap the byte order while copying\n        for (int i = 0; i < sizeWords; ++i)\n        {\n            rgbDib[i].rgbRed = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n#define DECLAREContigPutFunc(name)                                             \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *pp)\n\n#define DECLARESepPutFunc(name)                                                \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *r, u_char *g, u_char *b, u_char *a)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *uraster, uint32_t w,\n                              uint32_t h);\n\n// typdef struct TIFFDibImage {\n//     TIFFRGBAImage tif;\n//     dibinstalled;\n// } TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage *dib)\n{\n    TIFFRGBAImage *img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric)\n    {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n            switch (img->bitspersample)\n            {\n                case 1:\n                    img->put.contig = putContig1bitTile;\n                    img->get = getStripContig1Bit;\n                    dib->dibinstalled = true;\n                    break;\n            }\n            break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void)y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char *ucp = (u_char *)cp;\n\n    /* Convert 'w' to bytes from pixels (rounded up) */\n    w = (w + 7) / 8;\n\n    while (h-- > 0)\n    {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32_t setorientation(TIFFRGBAImage *img, uint32_t h)\n{\n    TIFF *tif = img->tif;\n    uint32_t y;\n\n    switch (img->orientation)\n    {\n        case ORIENTATION_BOTRIGHT:\n        case ORIENTATION_RIGHTBOT: /* XXX */\n        case ORIENTATION_LEFTBOT:  /* XXX */\n            TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n            img->orientation = ORIENTATION_BOTLEFT;\n        /* fall through... */\n        case ORIENTATION_BOTLEFT:\n            y = 0;\n            break;\n        case ORIENTATION_TOPRIGHT:\n        case ORIENTATION_RIGHTTOP: /* XXX */\n        case ORIENTATION_LEFTTOP:  /* XXX */\n        default:\n            TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n            img->orientation = ORIENTATION_TOPLEFT;\n        /* fall through... */\n        case ORIENTATION_TOPLEFT:\n            y = h - 1;\n            break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *raster, uint32_t w,\n                              uint32_t h)\n{\n    TIFF *tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16_t orientation;\n    uint32_t row, y, nrow, rowstoread;\n    uint32_t pos;\n    u_char *buf;\n    uint32_t rowsperstrip;\n    uint32_t imagewidth = img->width;\n    tsize_t scanline;\n    int32_t fromskew, toskew;\n    tstrip_t strip;\n    tsize_t stripsize;\n    u_char *braster = (u_char *)raster; // byte wide raster\n    uint32_t wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char *)_TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32_t)(orientation == ORIENTATION_TOPLEFT ? wb + wb : wb - wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0) / 8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif, row + img->row_offset, 0);\n        stripsize = ((row + img->row_offset) % rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize) < 0 &&\n            img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32_t *)(braster + y * wb), 0, y, w, nrow, fromskew,\n               toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ? -(int32_t)nrow\n                                                 : (int32_t)nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n",
                "name": "Tiffile.cpp",
                "path": "tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/ArtifexSoftware/ghostpdl/-/blob/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 112,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width,"
                }
            ],
            "repository": {
                "name": "github.com/ArtifexSoftware/ghostpdl",
                "url": "/github.com/ArtifexSoftware/ghostpdl"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "24960575263e1c13c2234b1305eab90a7364ff82"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n",
                "name": "Tiffile.cpp",
                "path": "third_party/codecs/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/google/sagetv/-/blob/third_party/codecs/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/google/sagetv",
                "url": "/github.com/google/sagetv"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "8123ecb826d8bd1cfa990909cc64e70219f7d959"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "extensions/android/ringlibsdl/project/jni/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/ring-lang/ring/-/blob/extensions/android/ringlibsdl/project/jni/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/ring-lang/ring",
                "url": "/github.com/ring-lang/ring"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "62b4d098d1472c3534dd098ca2a0e0e10712f1c6"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "external/SDL2_image-2.0.6/external/tiff-4.0.9/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/ValveSoftware/steamlink-sdk/-/blob/external/SDL2_image-2.0.6/external/tiff-4.0.9/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/ValveSoftware/steamlink-sdk",
                "url": "/github.com/ValveSoftware/steamlink-sdk"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "268c102e8fbe59c377dfe542cd4bb728f5523a95"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "external/SDL2_image/external/tiff-4.0.9/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/SpaceManiac/HamSandwich/-/blob/external/SDL2_image/external/tiff-4.0.9/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/SpaceManiac/HamSandwich",
                "url": "/github.com/SpaceManiac/HamSandwich"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "126e4aad9f287a1496cd966018f5d7faa674523a"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "indigo_libs/externals/libtiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/indigo-astronomy/indigo/-/blob/indigo_libs/externals/libtiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/indigo-astronomy/indigo",
                "url": "/github.com/indigo-astronomy/indigo"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "8123ecb826d8bd1cfa990909cc64e70219f7d959"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "extensions/android/ringlibsdl/project/jni/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/ring-lang/ring/-/blob/extensions/android/ringlibsdl/project/jni/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/ring-lang/ring",
                "url": "/github.com/ring-lang/ring"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "0c0258c63055d8b2cd57109245bf2e206700cf07"
                },
                "content": "#include \"StdAfx.h\"\n\n// #define STRICT\n#include \"diblib.h\"\n#include <commdlg.h>\n#include <stdlib.h> // MAX_ constants\n#include <windows.h>\n#include <windowsx.h>\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage\n{\n    TIFFRGBAImage tif;\n    int dibinstalled;\n};\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster);\n\nstatic void MyWarningHandler(const char *module, const char *fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void MyErrorHandler(const char *module, const char *fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF(LPCTSTR lpszPath)\n{\n    int rtn = 0;\n\n    TIFFErrorHandler eh;\n    TIFFErrorHandler wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF *tif = TIFFOpen(lpszPath, \"r\");\n    if (tif)\n    {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage *img);\n\nPVOID ReadTIFF(LPCTSTR lpszPath)\n{\n    void *pDIB = 0;\n    TIFFErrorHandler wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath))\n    {\n        TIFF *tif = TIFFOpen(lpszPath, \"r\");\n        if (tif)\n        {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg))\n            {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg))\n                {\n                    size_t npixels;\n                    uint32_t *raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster =\n                        (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n                    if (raster != NULL)\n                    {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width,\n                                             img.tif.height))\n                        {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else\n            {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg);\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster)\n{\n    void *pDIB = 0;\n    TIFFRGBAImage *img = &dib->tif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER bi;\n    int dwDIBSize;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if (BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled)\n    { // bilevel\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 1;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed = 0;\n        pRgbq[0].rgbBlue = 0;\n        pRgbq[0].rgbGreen = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed = 255;\n        pRgbq[1].rgbBlue = 255;\n        pRgbq[1].rgbGreen = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr(\n            (BITMAPINFOHEADER *)pDIB); //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n    //  For now just always default to the RGB 32 bit form. // save as 32 bit\n    //  for simplicity\n    else if (true /*BitsPerSample == 8 && SamplePerPixel == 3*/)\n    { // 24 bit color\n\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 32;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        // Swap the byte order while copying\n        for (int i = 0; i < sizeWords; ++i)\n        {\n            rgbDib[i].rgbRed = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n#define DECLAREContigPutFunc(name)                                             \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *pp)\n\n#define DECLARESepPutFunc(name)                                                \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *r, u_char *g, u_char *b, u_char *a)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *uraster, uint32_t w,\n                              uint32_t h);\n\n// typdef struct TIFFDibImage {\n//     TIFFRGBAImage tif;\n//     dibinstalled;\n// } TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage *dib)\n{\n    TIFFRGBAImage *img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric)\n    {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n            switch (img->bitspersample)\n            {\n                case 1:\n                    img->put.contig = putContig1bitTile;\n                    img->get = getStripContig1Bit;\n                    dib->dibinstalled = true;\n                    break;\n            }\n            break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void)y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char *ucp = (u_char *)cp;\n\n    /* Convert 'w' to bytes from pixels (rounded up) */\n    w = (w + 7) / 8;\n\n    while (h-- > 0)\n    {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32_t setorientation(TIFFRGBAImage *img, uint32_t h)\n{\n    TIFF *tif = img->tif;\n    uint32_t y;\n\n    switch (img->orientation)\n    {\n        case ORIENTATION_BOTRIGHT:\n        case ORIENTATION_RIGHTBOT: /* XXX */\n        case ORIENTATION_LEFTBOT:  /* XXX */\n            TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n            img->orientation = ORIENTATION_BOTLEFT;\n        /* fall through... */\n        case ORIENTATION_BOTLEFT:\n            y = 0;\n            break;\n        case ORIENTATION_TOPRIGHT:\n        case ORIENTATION_RIGHTTOP: /* XXX */\n        case ORIENTATION_LEFTTOP:  /* XXX */\n        default:\n            TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n            img->orientation = ORIENTATION_TOPLEFT;\n        /* fall through... */\n        case ORIENTATION_TOPLEFT:\n            y = h - 1;\n            break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *raster, uint32_t w,\n                              uint32_t h)\n{\n    TIFF *tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16_t orientation;\n    uint32_t row, y, nrow, rowstoread;\n    uint32_t pos;\n    u_char *buf;\n    uint32_t rowsperstrip;\n    uint32_t imagewidth = img->width;\n    tsize_t scanline;\n    int32_t fromskew, toskew;\n    tstrip_t strip;\n    tsize_t stripsize;\n    u_char *braster = (u_char *)raster; // byte wide raster\n    uint32_t wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char *)_TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32_t)(orientation == ORIENTATION_TOPLEFT ? wb + wb : wb - wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0) / 8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif, row + img->row_offset, 0);\n        stripsize = ((row + img->row_offset) % rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize) < 0 &&\n            img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32_t *)(braster + y * wb), 0, y, w, nrow, fromskew,\n               toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ? -(int32_t)nrow\n                                                 : (int32_t)nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n",
                "name": "Tiffile.cpp",
                "path": "lib/libtiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/ravynsoft/ravynos/-/blob/lib/libtiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 112,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width,"
                }
            ],
            "repository": {
                "name": "github.com/ravynsoft/ravynos",
                "url": "/github.com/ravynsoft/ravynos"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "7c3e0a2b3dc1cee743f5d5cadf47ffdecdbfebfa"
                },
                "content": "#include \"StdAfx.h\"\r\n\r\n//#define STRICT\r\n#include <windows.h>\r\n#include <windowsx.h>\r\n#include <commdlg.h>\r\n#include <stdlib.h>                     // MAX_ constants\r\n#include \"diblib.h\"\r\n\r\n/*--------------------------------------------------------------------\r\n        READ TIFF\r\n        Load the TIFF data from the file into memory.  Return\r\n        a pointer to a valid DIB (or NULL for errors).\r\n        Uses the TIFFRGBA interface to libtiff.lib to convert\r\n        most file formats to a useable form.  We just keep the 32 bit\r\n        form of the data to display, rather than optimizing for the\r\n        display.\r\n\r\n        Main entry points:\r\n\r\n            int ChkTIFF ( LPCTSTR lpszPath )\r\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\r\n\r\n        RETURN\r\n            A valid DIB pointer for success; NULL for failure.\r\n\r\n  --------------------------------------------------------------------*/\r\n\r\n#include \"TiffLib/tiff.h\"\r\n#include \"TiffLib/tiffio.h\"\r\n#include <assert.h>\r\n#include <stdio.h>\r\n\r\n\r\n// piggyback some data on top of the RGBA Image\r\nstruct TIFFDibImage {\r\n    TIFFRGBAImage tif;\r\n    int  dibinstalled;\r\n} ;\r\n\r\n\r\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\r\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\r\n\r\nstatic void\r\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\r\n{\r\n    // ignore all warnings (unused tags, etc)\r\n    return;\r\n}\r\n\r\nstatic void\r\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\r\n{\r\n    return;\r\n}\r\n\r\n//  Turn off the error and warning handlers to check if a valid file.\r\n//  Necessary because of the way that the Doc loads images and restart files.\r\nint ChkTIFF ( LPCTSTR lpszPath )\r\n{\r\n    int rtn = 0;\r\n\r\n    TIFFErrorHandler  eh;\r\n    TIFFErrorHandler  wh;\r\n\r\n    eh = TIFFSetErrorHandler(NULL);\r\n    wh = TIFFSetWarningHandler(NULL);\r\n\r\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\r\n    if (tif) {\r\n        rtn = 1;\r\n        TIFFClose(tif);\r\n    }\r\n\r\n    TIFFSetErrorHandler(eh);\r\n    TIFFSetWarningHandler(wh);\r\n\r\n    return rtn;\r\n}\r\n\r\nvoid DibInstallHack(TIFFDibImage* img) ;\r\n\r\nPVOID ReadTIFF ( LPCTSTR lpszPath )\r\n{\r\n    void*             pDIB = 0;\r\n    TIFFErrorHandler  wh;\r\n\r\n    wh = TIFFSetWarningHandler(MyWarningHandler);\r\n\r\n    if (ChkTIFF(lpszPath)) {\r\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\r\n        if (tif) {\r\n            char emsg[1024];\r\n\r\n            if (TIFFRGBAImageOK(tif, emsg)) {\r\n                TIFFDibImage img;\r\n                char emsg[1024];\r\n\r\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\r\n                    size_t npixels;\r\n                    uint32* raster;\r\n\r\n                    DibInstallHack(&img);\r\n\r\n                    npixels = img.tif.width * img.tif.height;\r\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\r\n                    if (raster != NULL) {\r\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\r\n                            pDIB = TIFFRGBA2DIB(&img, raster);\r\n                        }\r\n                    }\r\n                    _TIFFfree(raster);\r\n                }\r\n                TIFFRGBAImageEnd(&img.tif);\r\n            }\r\n            else {\r\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\r\n            }\r\n            TIFFClose(tif);\r\n        }\r\n    }\r\n\r\n    TIFFSetWarningHandler(wh);\r\n\r\n    return pDIB;\r\n}\r\n\r\n\r\n\r\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\r\n{\r\n    void*   pDIB = 0;\r\n    TIFFRGBAImage* img = &dib->tif;\r\n\r\n    uint32 imageLength;\r\n    uint32 imageWidth;\r\n    uint16 BitsPerSample;\r\n    uint16 SamplePerPixel;\r\n    uint32 RowsPerStrip;\r\n    uint16 PhotometricInterpretation;\r\n\r\n    BITMAPINFOHEADER   bi;\r\n    int                dwDIBSize ;\r\n\r\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\r\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\r\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\r\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\r\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\r\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\r\n\r\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\r\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\r\n        bi.biWidth          = imageWidth;\r\n        bi.biHeight         = imageLength;\r\n        bi.biPlanes         = 1;  // always\r\n        bi.biBitCount       = 1;\r\n        bi.biCompression    = BI_RGB;\r\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\r\n        bi.biXPelsPerMeter  = 0;\r\n        bi.biYPelsPerMeter  = 0;\r\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\r\n        bi.biClrImportant   = 0;  // always\r\n\r\n        // Get the size of the DIB\r\n        dwDIBSize = GetDIBSize( &bi );\r\n\r\n        // Allocate for the BITMAPINFO structure and the color table.\r\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\r\n        if (pDIB == 0) {\r\n            return( NULL );\r\n        }\r\n\r\n        // Copy the header info\r\n        *((BITMAPINFOHEADER*)pDIB) = bi;\r\n\r\n        // Get a pointer to the color table\r\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\r\n\r\n        pRgbq[0].rgbRed      = 0;\r\n        pRgbq[0].rgbBlue     = 0;\r\n        pRgbq[0].rgbGreen    = 0;\r\n        pRgbq[0].rgbReserved = 0;\r\n        pRgbq[1].rgbRed      = 255;\r\n        pRgbq[1].rgbBlue     = 255;\r\n        pRgbq[1].rgbGreen    = 255;\r\n        pRgbq[1].rgbReserved = 255;\r\n\r\n        // Pointers to the bits\r\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\r\n        //\r\n        // In the BITMAPINFOHEADER documentation, it appears that\r\n        // there should be no color table for 32 bit images, but\r\n        // experience shows that the image is off by 3 words if it\r\n        // is not included.  So here it is.\r\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\r\n\r\n        int       sizeWords = bi.biSizeImage/4;\r\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\r\n        long*     rgbTif = (long*)raster;\r\n\r\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\r\n    }\r\n\r\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\r\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\r\n\r\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\r\n        bi.biWidth          = imageWidth;\r\n        bi.biHeight         = imageLength;\r\n        bi.biPlanes         = 1;  // always\r\n        bi.biBitCount       = 32;\r\n        bi.biCompression    = BI_RGB;\r\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\r\n        bi.biXPelsPerMeter  = 0;\r\n        bi.biYPelsPerMeter  = 0;\r\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\r\n        bi.biClrImportant   = 0;  // always\r\n\r\n        // Get the size of the DIB\r\n        dwDIBSize = GetDIBSize( &bi );\r\n\r\n        // Allocate for the BITMAPINFO structure and the color table.\r\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\r\n        if (pDIB == 0) {\r\n            return( NULL );\r\n        }\r\n\r\n        // Copy the header info\r\n        *((BITMAPINFOHEADER*)pDIB) = bi;\r\n\r\n        // Get a pointer to the color table\r\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\r\n\r\n        // Pointers to the bits\r\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\r\n        //\r\n        // In the BITMAPINFOHEADER documentation, it appears that\r\n        // there should be no color table for 32 bit images, but\r\n        // experience shows that the image is off by 3 words if it\r\n        // is not included.  So here it is.\r\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\r\n\r\n        int       sizeWords = bi.biSizeImage/4;\r\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\r\n        long*     rgbTif = (long*)raster;\r\n\r\n        // Swap the byte order while copying\r\n        for ( int i = 0 ; i < sizeWords ; ++i )\r\n        {\r\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\r\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\r\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\r\n            rgbDib[i].rgbReserved = 0;\r\n        }\r\n    }\r\n\r\n    return pDIB;\r\n}\r\n\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////\r\n//\r\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\r\n//\r\n//\r\ntypedef unsigned char u_char;\r\n\r\n\r\n#define DECLAREContigPutFunc(name) \\\r\nstatic void name(\\\r\n    TIFFRGBAImage* img, \\\r\n    uint32* cp, \\\r\n    uint32 x, uint32 y, \\\r\n    uint32 w, uint32 h, \\\r\n    int32 fromskew, int32 toskew, \\\r\n    u_char* pp \\\r\n)\r\n\r\n#define DECLARESepPutFunc(name) \\\r\nstatic void name(\\\r\n    TIFFRGBAImage* img,\\\r\n    uint32* cp,\\\r\n    uint32 x, uint32 y, \\\r\n    uint32 w, uint32 h,\\\r\n    int32 fromskew, int32 toskew,\\\r\n    u_char* r, u_char* g, u_char* b, u_char* a\\\r\n)\r\n\r\nDECLAREContigPutFunc(putContig1bitTile);\r\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\r\n\r\n//typdef struct TIFFDibImage {\r\n//    TIFFRGBAImage tif;\r\n//    dibinstalled;\r\n//} TIFFDibImage ;\r\n\r\nvoid DibInstallHack(TIFFDibImage* dib) {\r\n    TIFFRGBAImage* img = &dib->tif;\r\n    dib->dibinstalled = false;\r\n    switch (img->photometric) {\r\n        case PHOTOMETRIC_MINISWHITE:\r\n        case PHOTOMETRIC_MINISBLACK:\r\n        switch (img->bitspersample) {\r\n            case 1:\r\n                img->put.contig = putContig1bitTile;\r\n                img->get = getStripContig1Bit;\r\n                dib->dibinstalled = true;\r\n                break;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\n/*\r\n * 1-bit packed samples => 1-bit\r\n *\r\n *   Override to just copy the data\r\n */\r\nDECLAREContigPutFunc(putContig1bitTile)\r\n{\r\n    int samplesperpixel = img->samplesperpixel;\r\n\r\n    (void) y;\r\n    fromskew *= samplesperpixel;\r\n    int wb = WIDTHBYTES(w);\r\n    u_char*  ucp = (u_char*)cp;\r\n\r\n    /* Conver 'w' to bytes from pixels (rounded up) */\r\n    w = (w+7)/8;\r\n\r\n    while (h-- > 0) {\r\n        _TIFFmemcpy(ucp, pp, w);\r\n        /*\r\n        for (x = wb; x-- > 0;) {\r\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\r\n            pp += samplesperpixel;\r\n        }\r\n        */\r\n        ucp += (wb + toskew);\r\n        pp += (w + fromskew);\r\n    }\r\n}\r\n\r\n/*\r\n *  Hacked from the tif_getimage.c file.\r\n */\r\nstatic uint32\r\nsetorientation(TIFFRGBAImage* img, uint32 h)\r\n{\r\n    TIFF* tif = img->tif;\r\n    uint32 y;\r\n\r\n    switch (img->orientation) {\r\n    case ORIENTATION_BOTRIGHT:\r\n    case ORIENTATION_RIGHTBOT:  /* XXX */\r\n    case ORIENTATION_LEFTBOT:   /* XXX */\r\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\r\n    img->orientation = ORIENTATION_BOTLEFT;\r\n    /* fall through... */\r\n    case ORIENTATION_BOTLEFT:\r\n    y = 0;\r\n    break;\r\n    case ORIENTATION_TOPRIGHT:\r\n    case ORIENTATION_RIGHTTOP:  /* XXX */\r\n    case ORIENTATION_LEFTTOP:   /* XXX */\r\n    default:\r\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\r\n    img->orientation = ORIENTATION_TOPLEFT;\r\n    /* fall through... */\r\n    case ORIENTATION_TOPLEFT:\r\n    y = h-1;\r\n    break;\r\n    }\r\n    return (y);\r\n}\r\n\r\n/*\r\n * Get a strip-organized image that has\r\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\r\n * or\r\n *  SamplesPerPixel == 1\r\n *\r\n *  Hacked from the tif_getimage.c file.\r\n *\r\n *    This is set up to allow us to just copy the data to the raster\r\n *    for 1-bit bitmaps\r\n */\r\nstatic int\r\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\r\n{\r\n    TIFF* tif = img->tif;\r\n    tileContigRoutine put = img->put.contig;\r\n    uint16 orientation;\r\n    uint32 row, y, nrow, rowstoread;\r\n    uint32 pos;\r\n    u_char* buf;\r\n    uint32 rowsperstrip;\r\n    uint32 imagewidth = img->width;\r\n    tsize_t scanline;\r\n    int32 fromskew, toskew;\r\n    tstrip_t strip;\r\n    tsize_t  stripsize;\r\n    u_char* braster = (u_char*)raster; // byte wide raster\r\n    uint32  wb = WIDTHBYTES(w);\r\n    int ret = 1;\r\n\r\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\r\n    if (buf == 0) {\r\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\r\n        return (0);\r\n    }\r\n    y = setorientation(img, h);\r\n    orientation = img->orientation;\r\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\r\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\r\n    scanline = TIFFScanlineSize(tif);\r\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\r\n    for (row = 0; row < h; row += nrow)\r\n    {\r\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\r\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\r\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\r\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\r\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\r\n            && img->stoponerr)\r\n        {\r\n            ret = 0;\r\n            break;\r\n        }\r\n\r\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\r\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\r\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\r\n    }\r\n    _TIFFfree(buf);\r\n    return (ret);\r\n}\r\n\r\n/*\r\n * Local Variables:\r\n * mode: c++\r\n * c-basic-offset: 8\r\n * fill-column: 78\r\n * End:\r\n */\r\n",
                "name": "Tiffile.cpp",
                "path": "tkimg/compat/libtiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/SAOImageDS9/SAOImageDS9/-/blob/tkimg/compat/libtiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\r"
                }
            ],
            "repository": {
                "name": "github.com/SAOImageDS9/SAOImageDS9",
                "url": "/github.com/SAOImageDS9/SAOImageDS9"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "7212bd40c743d703c17bdcac5239fc490dcf85ec"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "wxWidgets/src/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/Ravbug/UnityHubNative/-/blob/wxWidgets/src/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/Ravbug/UnityHubNative",
                "url": "/github.com/Ravbug/UnityHubNative"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "01f545b81fea715e32319582bfbbc8bb8b2109f4"
                },
                "content": "#include \"StdAfx.h\"\n\n// #define STRICT\n#include \"diblib.h\"\n#include <commdlg.h>\n#include <stdlib.h> // MAX_ constants\n#include <windows.h>\n#include <windowsx.h>\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage\n{\n    TIFFRGBAImage tif;\n    int dibinstalled;\n};\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster);\n\nstatic void MyWarningHandler(const char *module, const char *fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void MyErrorHandler(const char *module, const char *fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF(LPCTSTR lpszPath)\n{\n    int rtn = 0;\n\n    TIFFErrorHandler eh;\n    TIFFErrorHandler wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF *tif = TIFFOpen(lpszPath, \"r\");\n    if (tif)\n    {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage *img);\n\nPVOID ReadTIFF(LPCTSTR lpszPath)\n{\n    void *pDIB = 0;\n    TIFFErrorHandler wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath))\n    {\n        TIFF *tif = TIFFOpen(lpszPath, \"r\");\n        if (tif)\n        {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg))\n            {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg))\n                {\n                    size_t npixels;\n                    uint32_t *raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster =\n                        (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n                    if (raster != NULL)\n                    {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width,\n                                             img.tif.height))\n                        {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else\n            {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg);\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster)\n{\n    void *pDIB = 0;\n    TIFFRGBAImage *img = &dib->tif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER bi;\n    int dwDIBSize;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if (BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled)\n    { // bilevel\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 1;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed = 0;\n        pRgbq[0].rgbBlue = 0;\n        pRgbq[0].rgbGreen = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed = 255;\n        pRgbq[1].rgbBlue = 255;\n        pRgbq[1].rgbGreen = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr(\n            (BITMAPINFOHEADER *)pDIB); //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n    //  For now just always default to the RGB 32 bit form. // save as 32 bit\n    //  for simplicity\n    else if (true /*BitsPerSample == 8 && SamplePerPixel == 3*/)\n    { // 24 bit color\n\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 32;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        // Swap the byte order while copying\n        for (int i = 0; i < sizeWords; ++i)\n        {\n            rgbDib[i].rgbRed = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n#define DECLAREContigPutFunc(name)                                             \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *pp)\n\n#define DECLARESepPutFunc(name)                                                \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *r, u_char *g, u_char *b, u_char *a)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *uraster, uint32_t w,\n                              uint32_t h);\n\n// typdef struct TIFFDibImage {\n//     TIFFRGBAImage tif;\n//     dibinstalled;\n// } TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage *dib)\n{\n    TIFFRGBAImage *img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric)\n    {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n            switch (img->bitspersample)\n            {\n                case 1:\n                    img->put.contig = putContig1bitTile;\n                    img->get = getStripContig1Bit;\n                    dib->dibinstalled = true;\n                    break;\n            }\n            break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void)y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char *ucp = (u_char *)cp;\n\n    /* Convert 'w' to bytes from pixels (rounded up) */\n    w = (w + 7) / 8;\n\n    while (h-- > 0)\n    {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32_t setorientation(TIFFRGBAImage *img, uint32_t h)\n{\n    TIFF *tif = img->tif;\n    uint32_t y;\n\n    switch (img->orientation)\n    {\n        case ORIENTATION_BOTRIGHT:\n        case ORIENTATION_RIGHTBOT: /* XXX */\n        case ORIENTATION_LEFTBOT:  /* XXX */\n            TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n            img->orientation = ORIENTATION_BOTLEFT;\n        /* fall through... */\n        case ORIENTATION_BOTLEFT:\n            y = 0;\n            break;\n        case ORIENTATION_TOPRIGHT:\n        case ORIENTATION_RIGHTTOP: /* XXX */\n        case ORIENTATION_LEFTTOP:  /* XXX */\n        default:\n            TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n            img->orientation = ORIENTATION_TOPLEFT;\n        /* fall through... */\n        case ORIENTATION_TOPLEFT:\n            y = h - 1;\n            break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *raster, uint32_t w,\n                              uint32_t h)\n{\n    TIFF *tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16_t orientation;\n    uint32_t row, y, nrow, rowstoread;\n    uint32_t pos;\n    u_char *buf;\n    uint32_t rowsperstrip;\n    uint32_t imagewidth = img->width;\n    tsize_t scanline;\n    int32_t fromskew, toskew;\n    tstrip_t strip;\n    tsize_t stripsize;\n    u_char *braster = (u_char *)raster; // byte wide raster\n    uint32_t wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char *)_TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32_t)(orientation == ORIENTATION_TOPLEFT ? wb + wb : wb - wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0) / 8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif, row + img->row_offset, 0);\n        stripsize = ((row + img->row_offset) % rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize) < 0 &&\n            img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32_t *)(braster + y * wb), 0, y, w, nrow, fromskew,\n               toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ? -(int32_t)nrow\n                                                 : (int32_t)nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n",
                "name": "Tiffile.cpp",
                "path": "3rdparty/tiff-4.6.0/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/SuperIlu/DOjS/-/blob/3rdparty/tiff-4.6.0/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 112,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width,"
                }
            ],
            "repository": {
                "name": "github.com/SuperIlu/DOjS",
                "url": "/github.com/SuperIlu/DOjS"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "616b730d109b733fc7d71097ccddcb6e61858684"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "testcases/SanRazor/data/cve/tiff-asan/tiff-4.0.7/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/junxzm1990/ASAN--/-/blob/testcases/SanRazor/data/cve/tiff-asan/tiff-4.0.7/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/junxzm1990/ASAN--",
                "url": "/github.com/junxzm1990/ASAN--"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "e543e9ec583afbcd2535f1941f2af4cc44890a45"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "humble-video-captive/src/main/gnu/libtiff/csrc/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/artclarke/humble-video/-/blob/humble-video-captive/src/main/gnu/libtiff/csrc/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/artclarke/humble-video",
                "url": "/github.com/artclarke/humble-video"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "9e58aaf853fc5244ff77cab6bd579a10956e99a2"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n",
                "name": "Tiffile.cpp",
                "path": "Thirdparty/wxWidgets/src/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/bjakja/Kainote/-/blob/Thirdparty/wxWidgets/src/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/bjakja/Kainote",
                "url": "/github.com/bjakja/Kainote"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "a33afddbf01ce91ae645416c2f903778c764349b"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "examples/pxScene2d/external/WinSparkle/3rdparty/wxWidgets/src/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/pxscene/pxCore2/-/blob/examples/pxScene2d/external/WinSparkle/3rdparty/wxWidgets/src/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/pxscene/pxCore2",
                "url": "/github.com/pxscene/pxCore2"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "a99f20706f9c666903a12a205edce13263b1fadb"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "components/SDL2/src/image/external/tiff-4.0.9/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/alibaba/AliOS-Things/-/blob/components/SDL2/src/image/external/tiff-4.0.9/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/alibaba/AliOS-Things",
                "url": "/github.com/alibaba/AliOS-Things"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "a5af9887ca6b829bcbf15bf401430d1621373c25"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "vendor/tiff-4.0.6/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/microsoft/microsoft-r-open/-/blob/vendor/tiff-4.0.6/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/microsoft/microsoft-r-open",
                "url": "/github.com/microsoft/microsoft-r-open"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "2d1b6f8369fc3ea8c0b688aac3004d0f8bc1bfbd"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "wxWidgets-3.2.0/src/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/fligger/FateInjector/-/blob/wxWidgets-3.2.0/src/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/fligger/FateInjector",
                "url": "/github.com/fligger/FateInjector"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "31bcfbf9c9a5803dc0ffb022b7e7abd76e5c3cfd"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "SDL2_image/external/tiff-4.0.8/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/mozeal/SDL_gui/-/blob/SDL2_image/external/tiff-4.0.8/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/mozeal/SDL_gui",
                "url": "/github.com/mozeal/SDL_gui"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "857e4e76e26f05d72400ae5d9f2a22cae88f3548"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "joycon-driver/full/wxWidgets-3.0.4/src/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/fossephate/JoyCon-Driver/-/blob/joycon-driver/full/wxWidgets-3.0.4/src/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/fossephate/JoyCon-Driver",
                "url": "/github.com/fossephate/JoyCon-Driver"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "857e4e76e26f05d72400ae5d9f2a22cae88f3548"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "joycon-driver/full/wxWidgets-3.0.3/src/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/fossephate/JoyCon-Driver/-/blob/joycon-driver/full/wxWidgets-3.0.3/src/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/fossephate/JoyCon-Driver",
                "url": "/github.com/fossephate/JoyCon-Driver"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "fa0a13f73d4e3b31dd3edc11bba1f33ea80d064f"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "Android/jni/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/a1studmuffin/Cataclysm-DDA-Android/-/blob/Android/jni/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/a1studmuffin/Cataclysm-DDA-Android",
                "url": "/github.com/a1studmuffin/Cataclysm-DDA-Android"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "6f21411884ca8de78014316abe2186cd6cbbba79"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "sdlplugin/src/main/jni/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/tranleduy2000/c_cpp_compiler/-/blob/sdlplugin/src/main/jni/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/tranleduy2000/c_cpp_compiler",
                "url": "/github.com/tranleduy2000/c_cpp_compiler"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "049d345b74f449bef0074af20d9b9e2e9bdf8b70"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "filezillaclient/wxWidgets-3.1.0/src/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/helloworldgnu/filezilla/-/blob/filezillaclient/wxWidgets-3.1.0/src/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/helloworldgnu/filezilla",
                "url": "/github.com/helloworldgnu/filezilla"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "049d345b74f449bef0074af20d9b9e2e9bdf8b70"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "filezillaclient/wxWidgets-3.0.2/src/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/helloworldgnu/filezilla/-/blob/filezillaclient/wxWidgets-3.0.2/src/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/helloworldgnu/filezilla",
                "url": "/github.com/helloworldgnu/filezilla"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "8d4f3e6d31def1547a7564a9104d2b9d913a785a"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "kingdom-src/SDL/SDL2_image-2.0.1/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/freeors/War-Of-Kingdom/-/blob/kingdom-src/SDL/SDL2_image-2.0.1/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/freeors/War-Of-Kingdom",
                "url": "/github.com/freeors/War-Of-Kingdom"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "3e8682f24fe223c7065671d0204de639a6d2ec05"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "opengames/src/main/jni/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/emileb/OpenGames/-/blob/opengames/src/main/jni/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/emileb/OpenGames",
                "url": "/github.com/emileb/OpenGames"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "74c896af5826ebe8fb72f2911015738f38ab7bb2"
                },
                "content": "#include \"StdAfx.h\"\r\n\r\n//#define STRICT\r\n#include <windows.h>\r\n#include <windowsx.h>\r\n#include <commdlg.h>\r\n#include <stdlib.h>                     // MAX_ constants\r\n#include \"diblib.h\"\r\n\r\n/*--------------------------------------------------------------------\r\n        READ TIFF\r\n        Load the TIFF data from the file into memory.  Return\r\n        a pointer to a valid DIB (or NULL for errors).\r\n        Uses the TIFFRGBA interface to libtiff.lib to convert\r\n        most file formats to a useable form.  We just keep the 32 bit\r\n        form of the data to display, rather than optimizing for the\r\n        display.\r\n\r\n        Main entry points:\r\n\r\n            int ChkTIFF ( LPCTSTR lpszPath )\r\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\r\n\r\n        RETURN\r\n            A valid DIB pointer for success; NULL for failure.\r\n\r\n  --------------------------------------------------------------------*/\r\n\r\n#include \"TiffLib/tiff.h\"\r\n#include \"TiffLib/tiffio.h\"\r\n#include <assert.h>\r\n#include <stdio.h>\r\n\r\n\r\n// piggyback some data on top of the RGBA Image\r\nstruct TIFFDibImage {\r\n    TIFFRGBAImage tif;\r\n    int  dibinstalled;\r\n} ;\r\n\r\n\r\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\r\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\r\n\r\nstatic void\r\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\r\n{\r\n    // ignore all warnings (unused tags, etc)\r\n    return;\r\n}\r\n\r\nstatic void\r\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\r\n{\r\n    return;\r\n}\r\n\r\n//  Turn off the error and warning handlers to check if a valid file.\r\n//  Necessary because of the way that the Doc loads images and restart files.\r\nint ChkTIFF ( LPCTSTR lpszPath )\r\n{\r\n    int rtn = 0;\r\n\r\n    TIFFErrorHandler  eh;\r\n    TIFFErrorHandler  wh;\r\n\r\n    eh = TIFFSetErrorHandler(NULL);\r\n    wh = TIFFSetWarningHandler(NULL);\r\n\r\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\r\n    if (tif) {\r\n        rtn = 1;\r\n        TIFFClose(tif);\r\n    }\r\n\r\n    TIFFSetErrorHandler(eh);\r\n    TIFFSetWarningHandler(wh);\r\n\r\n    return rtn;\r\n}\r\n\r\nvoid DibInstallHack(TIFFDibImage* img) ;\r\n\r\nPVOID ReadTIFF ( LPCTSTR lpszPath )\r\n{\r\n    void*             pDIB = 0;\r\n    TIFFErrorHandler  wh;\r\n\r\n    wh = TIFFSetWarningHandler(MyWarningHandler);\r\n\r\n    if (ChkTIFF(lpszPath)) {\r\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\r\n        if (tif) {\r\n            char emsg[1024];\r\n\r\n            if (TIFFRGBAImageOK(tif, emsg)) {\r\n                TIFFDibImage img;\r\n                char emsg[1024];\r\n\r\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\r\n                    size_t npixels;\r\n                    uint32* raster;\r\n\r\n                    DibInstallHack(&img);\r\n\r\n                    npixels = img.tif.width * img.tif.height;\r\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\r\n                    if (raster != NULL) {\r\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\r\n                            pDIB = TIFFRGBA2DIB(&img, raster);\r\n                        }\r\n                    }\r\n                    _TIFFfree(raster);\r\n                }\r\n                TIFFRGBAImageEnd(&img.tif);\r\n            }\r\n            else {\r\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\r\n            }\r\n            TIFFClose(tif);\r\n        }\r\n    }\r\n\r\n    TIFFSetWarningHandler(wh);\r\n\r\n    return pDIB;\r\n}\r\n\r\n\r\n\r\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\r\n{\r\n    void*   pDIB = 0;\r\n    TIFFRGBAImage* img = &dib->tif;\r\n\r\n    uint32 imageLength;\r\n    uint32 imageWidth;\r\n    uint16 BitsPerSample;\r\n    uint16 SamplePerPixel;\r\n    uint32 RowsPerStrip;\r\n    uint16 PhotometricInterpretation;\r\n\r\n    BITMAPINFOHEADER   bi;\r\n    int                dwDIBSize ;\r\n\r\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\r\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\r\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\r\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\r\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\r\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\r\n\r\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\r\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\r\n        bi.biWidth          = imageWidth;\r\n        bi.biHeight         = imageLength;\r\n        bi.biPlanes         = 1;  // always\r\n        bi.biBitCount       = 1;\r\n        bi.biCompression    = BI_RGB;\r\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\r\n        bi.biXPelsPerMeter  = 0;\r\n        bi.biYPelsPerMeter  = 0;\r\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\r\n        bi.biClrImportant   = 0;  // always\r\n\r\n        // Get the size of the DIB\r\n        dwDIBSize = GetDIBSize( &bi );\r\n\r\n        // Allocate for the BITMAPINFO structure and the color table.\r\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\r\n        if (pDIB == 0) {\r\n            return( NULL );\r\n        }\r\n\r\n        // Copy the header info\r\n        *((BITMAPINFOHEADER*)pDIB) = bi;\r\n\r\n        // Get a pointer to the color table\r\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\r\n\r\n        pRgbq[0].rgbRed      = 0;\r\n        pRgbq[0].rgbBlue     = 0;\r\n        pRgbq[0].rgbGreen    = 0;\r\n        pRgbq[0].rgbReserved = 0;\r\n        pRgbq[1].rgbRed      = 255;\r\n        pRgbq[1].rgbBlue     = 255;\r\n        pRgbq[1].rgbGreen    = 255;\r\n        pRgbq[1].rgbReserved = 255;\r\n\r\n        // Pointers to the bits\r\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\r\n        //\r\n        // In the BITMAPINFOHEADER documentation, it appears that\r\n        // there should be no color table for 32 bit images, but\r\n        // experience shows that the image is off by 3 words if it\r\n        // is not included.  So here it is.\r\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\r\n\r\n        int       sizeWords = bi.biSizeImage/4;\r\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\r\n        long*     rgbTif = (long*)raster;\r\n\r\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\r\n    }\r\n\r\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\r\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\r\n\r\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\r\n        bi.biWidth          = imageWidth;\r\n        bi.biHeight         = imageLength;\r\n        bi.biPlanes         = 1;  // always\r\n        bi.biBitCount       = 32;\r\n        bi.biCompression    = BI_RGB;\r\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\r\n        bi.biXPelsPerMeter  = 0;\r\n        bi.biYPelsPerMeter  = 0;\r\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\r\n        bi.biClrImportant   = 0;  // always\r\n\r\n        // Get the size of the DIB\r\n        dwDIBSize = GetDIBSize( &bi );\r\n\r\n        // Allocate for the BITMAPINFO structure and the color table.\r\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\r\n        if (pDIB == 0) {\r\n            return( NULL );\r\n        }\r\n\r\n        // Copy the header info\r\n        *((BITMAPINFOHEADER*)pDIB) = bi;\r\n\r\n        // Get a pointer to the color table\r\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\r\n\r\n        // Pointers to the bits\r\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\r\n        //\r\n        // In the BITMAPINFOHEADER documentation, it appears that\r\n        // there should be no color table for 32 bit images, but\r\n        // experience shows that the image is off by 3 words if it\r\n        // is not included.  So here it is.\r\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\r\n\r\n        int       sizeWords = bi.biSizeImage/4;\r\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\r\n        long*     rgbTif = (long*)raster;\r\n\r\n        // Swap the byte order while copying\r\n        for ( int i = 0 ; i < sizeWords ; ++i )\r\n        {\r\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\r\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\r\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\r\n            rgbDib[i].rgbReserved = 0;\r\n        }\r\n    }\r\n\r\n    return pDIB;\r\n}\r\n\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////\r\n//\r\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\r\n//\r\n//\r\ntypedef unsigned char u_char;\r\n\r\n\r\n#define DECLAREContigPutFunc(name) \\\r\nstatic void name(\\\r\n    TIFFRGBAImage* img, \\\r\n    uint32* cp, \\\r\n    uint32 x, uint32 y, \\\r\n    uint32 w, uint32 h, \\\r\n    int32 fromskew, int32 toskew, \\\r\n    u_char* pp \\\r\n)\r\n\r\n#define DECLARESepPutFunc(name) \\\r\nstatic void name(\\\r\n    TIFFRGBAImage* img,\\\r\n    uint32* cp,\\\r\n    uint32 x, uint32 y, \\\r\n    uint32 w, uint32 h,\\\r\n    int32 fromskew, int32 toskew,\\\r\n    u_char* r, u_char* g, u_char* b, u_char* a\\\r\n)\r\n\r\nDECLAREContigPutFunc(putContig1bitTile);\r\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\r\n\r\n//typdef struct TIFFDibImage {\r\n//    TIFFRGBAImage tif;\r\n//    dibinstalled;\r\n//} TIFFDibImage ;\r\n\r\nvoid DibInstallHack(TIFFDibImage* dib) {\r\n    TIFFRGBAImage* img = &dib->tif;\r\n    dib->dibinstalled = false;\r\n    switch (img->photometric) {\r\n        case PHOTOMETRIC_MINISWHITE:\r\n        case PHOTOMETRIC_MINISBLACK:\r\n        switch (img->bitspersample) {\r\n            case 1:\r\n                img->put.contig = putContig1bitTile;\r\n                img->get = getStripContig1Bit;\r\n                dib->dibinstalled = true;\r\n                break;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\n/*\r\n * 1-bit packed samples => 1-bit\r\n *\r\n *   Override to just copy the data\r\n */\r\nDECLAREContigPutFunc(putContig1bitTile)\r\n{\r\n    int samplesperpixel = img->samplesperpixel;\r\n\r\n    (void) y;\r\n    fromskew *= samplesperpixel;\r\n    int wb = WIDTHBYTES(w);\r\n    u_char*  ucp = (u_char*)cp;\r\n\r\n    /* Conver 'w' to bytes from pixels (rounded up) */\r\n    w = (w+7)/8;\r\n\r\n    while (h-- > 0) {\r\n        _TIFFmemcpy(ucp, pp, w);\r\n        /*\r\n        for (x = wb; x-- > 0;) {\r\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\r\n            pp += samplesperpixel;\r\n        }\r\n        */\r\n        ucp += (wb + toskew);\r\n        pp += (w + fromskew);\r\n    }\r\n}\r\n\r\n/*\r\n *  Hacked from the tif_getimage.c file.\r\n */\r\nstatic uint32\r\nsetorientation(TIFFRGBAImage* img, uint32 h)\r\n{\r\n    TIFF* tif = img->tif;\r\n    uint32 y;\r\n\r\n    switch (img->orientation) {\r\n    case ORIENTATION_BOTRIGHT:\r\n    case ORIENTATION_RIGHTBOT:  /* XXX */\r\n    case ORIENTATION_LEFTBOT:   /* XXX */\r\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\r\n    img->orientation = ORIENTATION_BOTLEFT;\r\n    /* fall thru... */\r\n    case ORIENTATION_BOTLEFT:\r\n    y = 0;\r\n    break;\r\n    case ORIENTATION_TOPRIGHT:\r\n    case ORIENTATION_RIGHTTOP:  /* XXX */\r\n    case ORIENTATION_LEFTTOP:   /* XXX */\r\n    default:\r\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\r\n    img->orientation = ORIENTATION_TOPLEFT;\r\n    /* fall thru... */\r\n    case ORIENTATION_TOPLEFT:\r\n    y = h-1;\r\n    break;\r\n    }\r\n    return (y);\r\n}\r\n\r\n/*\r\n * Get a strip-organized image that has\r\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\r\n * or\r\n *  SamplesPerPixel == 1\r\n *\r\n *  Hacked from the tif_getimage.c file.\r\n *\r\n *    This is set up to allow us to just copy the data to the raster\r\n *    for 1-bit bitmaps\r\n */\r\nstatic int\r\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\r\n{\r\n    TIFF* tif = img->tif;\r\n    tileContigRoutine put = img->put.contig;\r\n    uint16 orientation;\r\n    uint32 row, y, nrow, rowstoread;\r\n    uint32 pos;\r\n    u_char* buf;\r\n    uint32 rowsperstrip;\r\n    uint32 imagewidth = img->width;\r\n    tsize_t scanline;\r\n    int32 fromskew, toskew;\r\n    tstrip_t strip;\r\n    tsize_t  stripsize;\r\n    u_char* braster = (u_char*)raster; // byte wide raster\r\n    uint32  wb = WIDTHBYTES(w);\r\n    int ret = 1;\r\n\r\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\r\n    if (buf == 0) {\r\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\r\n        return (0);\r\n    }\r\n    y = setorientation(img, h);\r\n    orientation = img->orientation;\r\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\r\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\r\n    scanline = TIFFScanlineSize(tif);\r\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\r\n    for (row = 0; row < h; row += nrow)\r\n    {\r\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\r\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\r\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\r\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\r\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\r\n            && img->stoponerr)\r\n        {\r\n            ret = 0;\r\n            break;\r\n        }\r\n\r\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\r\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\r\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\r\n    }\r\n    _TIFFfree(buf);\r\n    return (ret);\r\n}\r\n\r\n",
                "name": "Tiffile.cpp",
                "path": "wxWidgets-2.9.1/src/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/gamekit-developers/gamekit/-/blob/wxWidgets-2.9.1/src/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\r"
                }
            ],
            "repository": {
                "name": "github.com/gamekit-developers/gamekit",
                "url": "/github.com/gamekit-developers/gamekit"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "993c84e35658155228da86e992a2f69f94ac40e0"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "captive/libtiff/csrc/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/artclarke/xuggle-xuggler/-/blob/captive/libtiff/csrc/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/artclarke/xuggle-xuggler",
                "url": "/github.com/artclarke/xuggle-xuggler"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "eb0cf9617bd22b69ad625575a95cf4fa2c140d55"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n",
                "name": "Tiffile.cpp",
                "path": "lib/libtiff/tiff-4.0.0beta3/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/scs/uclinux/-/blob/lib/libtiff/tiff-4.0.0beta3/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/scs/uclinux",
                "url": "/github.com/scs/uclinux"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "34e34a6a539b5a822cda4074e56a7ced9b57da71"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "tcl-102/tcl_ext/tkimg/tkimg/compat/libtiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/st3fan/osx-10.9/-/blob/tcl-102/tcl_ext/tkimg/tkimg/compat/libtiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/st3fan/osx-10.9",
                "url": "/github.com/st3fan/osx-10.9"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "068586f28f5df67ed531de202343af0d1cc2f8c6"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n",
                "name": "Tiffile.cpp",
                "path": "libs/tiff-3.8.2/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/seven1240/FreeSWITCH-OLD/-/blob/libs/tiff-3.8.2/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/seven1240/FreeSWITCH-OLD",
                "url": "/github.com/seven1240/FreeSWITCH-OLD"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "05ae6bf6dfa41f81ecdd30b538d1a4df4f399dce"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "source/wxWidgets/src/tiff/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/dsp56300/dsp56300/-/blob/source/wxWidgets/src/tiff/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/dsp56300/dsp56300",
                "url": "/github.com/dsp56300/dsp56300"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "4e5531ea1a00f247f9f43bbf55cadbed698418cd"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "libs/SDL2_image/2.0.0/src/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/bfosterjr/windowsrtdev/-/blob/libs/SDL2_image/2.0.0/src/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/bfosterjr/windowsrtdev",
                "url": "/github.com/bfosterjr/windowsrtdev"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "e5f0f3e5b1183facee2dd0c723757e9033d89c61"
                },
                "content": "/*\n   Copyright (C) 2017-2024 Peter S. Zhigalov <peter.zhigalov@gmail.com>\n\n   This file is part of the `ImageViewer' program.\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <limits>\n\n#if !defined (TIFF_DISABLE_DEPRECATED)\n#define TIFF_DISABLE_DEPRECATED\n#endif\n#include <tiffio.h>\n\n#include <QFileInfo>\n#include <QImage>\n#include <QFile>\n#include <QByteArray>\n\n#include \"Utils/Global.h\"\n#include \"Utils/IsOneOf.h\"\n#include \"Utils/Logging.h\"\n#include \"Utils/ScopedPointer.h\"\n\n#include \"../IDecoder.h\"\n#include \"Internal/DecoderAutoRegistrator.h\"\n#include \"Internal/GraphicsItemsFactory.h\"\n#include \"Internal/ImageData.h\"\n#include \"Internal/ImageMetaData.h\"\n#include \"Internal/PayloadWithMetaData.h\"\n#include \"Internal/Utils/CmsUtils.h\"\n#include \"Internal/Utils/DataProcessing.h\"\n\n#define USE_RGBA_8888   (QT_VERSION >= QT_VERSION_CHECK(5, 2, 0) && Q_BYTE_ORDER == Q_LITTLE_ENDIAN)\n#define USE_GRAYSCALE_8 (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))\n#define USE_CMYK_8888   (QT_VERSION >= QT_VERSION_CHECK(6, 8, 0))\n#define ALLOW_BUFFER_UNDERFLOW\n\n// #define DEBUG_FORCE_BIT_ACCESS\n// #define DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER\n// #define DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER\n\n/// @note Buffer is zero-filled since LibTIFF-4.7.0:\n/// https://gitlab.com/libtiff/libtiff/-/merge_requests/628/\n#define BUFFER_FILL_PATTERN 0\n#define BUFFER_MAX_SIZE (static_cast<qint64>(std::numeric_limits<int>::max()))\n\nnamespace\n{\n\n// ====================================================================================================\n\nstruct Context\n{\n    TIFF *tiff;\n    qint64 width;\n    qint64 height;\n    quint16 compression;\n    quint16 photometric;\n    qint64 samplesPerPixel;\n    qint64 bitsPerSample;\n    quint16 sampleFormat;\n    quint16 inkSet;\n    ICCProfile *iccProfile;\n    const float *ycbcrcoeffs;\n    qint64 subsamplinghor;\n    qint64 subsamplingver;\n    quint16 ycbcrpositioning;\n    qint64 extrasamplesCount;\n    qint64 primarysamplesCount;\n    int alphaIndex;\n    bool alphaPremultiplied;\n    const quint16 *redTable;\n    const quint16 *greenTable;\n    const quint16 *blueTable;\n    bool colorTablesIs16Bit;\n};\n\n// ====================================================================================================\n\nQString photometricToString(quint16 photometric)\n{\n    switch(photometric)\n    {\n#define ADD_CASE(X) case X: return QString::fromLatin1(#X)\n    ADD_CASE(PHOTOMETRIC_MINISWHITE);\n    ADD_CASE(PHOTOMETRIC_MINISBLACK);\n    ADD_CASE(PHOTOMETRIC_RGB);\n    ADD_CASE(PHOTOMETRIC_PALETTE);\n    ADD_CASE(PHOTOMETRIC_MASK);\n    ADD_CASE(PHOTOMETRIC_SEPARATED);\n    ADD_CASE(PHOTOMETRIC_YCBCR);\n    ADD_CASE(PHOTOMETRIC_CIELAB);\n    ADD_CASE(PHOTOMETRIC_ICCLAB);\n    ADD_CASE(PHOTOMETRIC_ITULAB);\n#if defined (PHOTOMETRIC_CFA)\n    ADD_CASE(PHOTOMETRIC_CFA);\n#endif\n    ADD_CASE(PHOTOMETRIC_LOGL);\n    ADD_CASE(PHOTOMETRIC_LOGLUV);\n#undef ADD_CASE\n    default:\n        break;\n    }\n    return QString::fromLatin1(\"%1\").arg(photometric);\n}\n\nQString inkSetToString(quint16 inkSet)\n{\n    switch(inkSet)\n    {\n#define ADD_CASE(X) case X: return QString::fromLatin1(#X)\n    ADD_CASE(INKSET_CMYK);\n    ADD_CASE(INKSET_MULTIINK);\n#undef ADD_CASE\n    default:\n        break;\n    }\n    return QString::fromLatin1(\"%1\").arg(inkSet);\n}\n\nQString orientationToString(quint16 orientation)\n{\n    switch(orientation)\n    {\n#define ADD_CASE(X) case X: return QString::fromLatin1(#X)\n    ADD_CASE(ORIENTATION_TOPLEFT);\n    ADD_CASE(ORIENTATION_TOPRIGHT);\n    ADD_CASE(ORIENTATION_BOTRIGHT);\n    ADD_CASE(ORIENTATION_BOTLEFT);\n    ADD_CASE(ORIENTATION_LEFTTOP);\n    ADD_CASE(ORIENTATION_RIGHTTOP);\n    ADD_CASE(ORIENTATION_RIGHTBOT);\n    ADD_CASE(ORIENTATION_LEFTBOT);\n#undef ADD_CASE\n    default:\n        break;\n    }\n    return QString::fromLatin1(\"%1\").arg(orientation);\n}\n\nQString sampleFormatToString(quint16 sampleFormat)\n{\n    switch(sampleFormat)\n    {\n#define ADD_CASE(X) case X: return QString::fromLatin1(#X)\n    ADD_CASE(SAMPLEFORMAT_UINT);\n    ADD_CASE(SAMPLEFORMAT_INT);\n    ADD_CASE(SAMPLEFORMAT_IEEEFP);\n    ADD_CASE(SAMPLEFORMAT_VOID);\n    ADD_CASE(SAMPLEFORMAT_COMPLEXINT);\n    ADD_CASE(SAMPLEFORMAT_COMPLEXIEEEFP);\n#undef ADD_CASE\n    default:\n        break;\n    }\n    return QString::fromLatin1(\"%1\").arg(sampleFormat);\n}\n\nQString extrasamplesToString(quint16 extrasamplesCount, const quint16 *extrasamples)\n{\n    QString result;\n    // Avoid too long string, it is not human-readable\n    if(extrasamplesCount > 16)\n    {\n        quint16 unspecified = 0;\n        quint16 assocalpha = 0;\n        quint16 unassocalpha = 0;\n        quint16 other = 0;\n        for(quint16 i = 0; i < extrasamplesCount; ++i)\n        {\n            switch(extrasamples[i])\n            {\n            case EXTRASAMPLE_UNSPECIFIED:\n                ++unspecified;\n                break;\n            case EXTRASAMPLE_ASSOCALPHA:\n                ++assocalpha;\n                break;\n            case EXTRASAMPLE_UNASSALPHA:\n                ++unassocalpha;\n                break;\n            default:\n                ++other;\n                break;\n            }\n        }\n#define APPEND_RESULT(S, C) if((C) > 0) result = result + (result.isEmpty() ? QString() : QString::fromLatin1(\", \")) + QString::fromLatin1(\"%1x%2\").arg(C).arg(QString::fromLatin1(#S))\n        APPEND_RESULT(EXTRASAMPLE_UNSPECIFIED, unspecified);\n        APPEND_RESULT(EXTRASAMPLE_ASSOCALPHA, assocalpha);\n        APPEND_RESULT(EXTRASAMPLE_UNASSALPHA, unassocalpha);\n        APPEND_RESULT(Unknown, other);\n#undef APPEND_RESULT\n    }\n    else\n    {\n        for(quint16 i = 0; i < extrasamplesCount; ++i)\n        {\n            switch(extrasamples[i])\n            {\n#define APPEND_RESULT(S) result = result + (result.isEmpty() ? QString() : QString::fromLatin1(\", \")) + (S)\n#define ADD_CASE(X) case X: APPEND_RESULT(QString::fromLatin1(#X)); break\n            ADD_CASE(EXTRASAMPLE_UNSPECIFIED);\n            ADD_CASE(EXTRASAMPLE_ASSOCALPHA);\n            ADD_CASE(EXTRASAMPLE_UNASSALPHA);\n#undef ADD_CASE\n            default:\n                APPEND_RESULT(QString::fromLatin1(\"%1\").arg(extrasamples[i]));\n                break;\n#undef APPEND_RESULT\n            }\n        }\n    }\n    return QString::fromLatin1(\"(%1)\").arg(result);\n}\n\nQString planarConfigToString(quint16 planarConfig)\n{\n    switch(planarConfig)\n    {\n#define ADD_CASE(X) case X: return QString::fromLatin1(#X)\n    ADD_CASE(PLANARCONFIG_CONTIG);\n    ADD_CASE(PLANARCONFIG_SEPARATE);\n#undef ADD_CASE\n    default:\n        break;\n    }\n    return QString::fromLatin1(\"%1\").arg(planarConfig);\n}\n\nQString compressionToString(quint16 compression)\n{\n    switch(compression)\n    {\n#define ADD_CASE(X) case X: return QString::fromLatin1(#X)\n#if defined (COMPRESSION_NONE)\n    ADD_CASE(COMPRESSION_NONE);\n#endif\n#if defined (COMPRESSION_CCITTRLE)\n    ADD_CASE(COMPRESSION_CCITTRLE);\n#endif\n#if defined (COMPRESSION_CCITTFAX3)\n    ADD_CASE(COMPRESSION_CCITTFAX3);\n#elif defined (COMPRESSION_CCITT_T4)\n    ADD_CASE(COMPRESSION_CCITT_T4);\n#endif\n#if defined (COMPRESSION_CCITTFAX4)\n    ADD_CASE(COMPRESSION_CCITTFAX4);\n#elif defined (COMPRESSION_CCITT_T6)\n    ADD_CASE(COMPRESSION_CCITT_T6);\n#endif\n#if defined (COMPRESSION_LZW)\n    ADD_CASE(COMPRESSION_LZW);\n#endif\n#if defined (COMPRESSION_OJPEG)\n    ADD_CASE(COMPRESSION_OJPEG);\n#endif\n#if defined (COMPRESSION_JPEG)\n    ADD_CASE(COMPRESSION_JPEG);\n#endif\n#if defined (COMPRESSION_T85)\n    ADD_CASE(COMPRESSION_T85);\n#endif\n#if defined (COMPRESSION_T43)\n    ADD_CASE(COMPRESSION_T43);\n#endif\n#if defined (COMPRESSION_NEXT)\n    ADD_CASE(COMPRESSION_NEXT);\n#endif\n#if defined (COMPRESSION_CCITTRLEW)\n    ADD_CASE(COMPRESSION_CCITTRLEW);\n#endif\n#if defined (COMPRESSION_PACKBITS)\n    ADD_CASE(COMPRESSION_PACKBITS);\n#endif\n#if defined (COMPRESSION_THUNDERSCAN)\n    ADD_CASE(COMPRESSION_THUNDERSCAN);\n#endif\n#if defined (COMPRESSION_IT8CTPAD)\n    ADD_CASE(COMPRESSION_IT8CTPAD);\n#endif\n#if defined (COMPRESSION_IT8LW)\n    ADD_CASE(COMPRESSION_IT8LW);\n#endif\n#if defined (COMPRESSION_IT8MP)\n    ADD_CASE(COMPRESSION_IT8MP);\n#endif\n#if defined (COMPRESSION_IT8BL)\n    ADD_CASE(COMPRESSION_IT8BL);\n#endif\n#if defined (COMPRESSION_PIXARFILM)\n    ADD_CASE(COMPRESSION_PIXARFILM);\n#endif\n#if defined (COMPRESSION_PIXARLOG)\n    ADD_CASE(COMPRESSION_PIXARLOG);\n#endif\n#if defined (COMPRESSION_DEFLATE)\n    ADD_CASE(COMPRESSION_DEFLATE);\n#endif\n#if defined (COMPRESSION_ADOBE_DEFLATE)\n    ADD_CASE(COMPRESSION_ADOBE_DEFLATE);\n#endif\n#if defined (COMPRESSION_DCS)\n    ADD_CASE(COMPRESSION_DCS);\n#endif\n#if defined (COMPRESSION_JBIG)\n    ADD_CASE(COMPRESSION_JBIG);\n#endif\n#if defined (COMPRESSION_SGILOG)\n    ADD_CASE(COMPRESSION_SGILOG);\n#endif\n#if defined (COMPRESSION_SGILOG24)\n    ADD_CASE(COMPRESSION_SGILOG24);\n#endif\n#if defined (COMPRESSION_JP2000)\n    ADD_CASE(COMPRESSION_JP2000);\n#endif\n#if defined (COMPRESSION_LERC)\n    ADD_CASE(COMPRESSION_LERC);\n#endif\n#if defined (COMPRESSION_LZMA)\n    ADD_CASE(COMPRESSION_LZMA);\n#endif\n#if defined (COMPRESSION_ZSTD)\n    ADD_CASE(COMPRESSION_ZSTD);\n#endif\n#if defined (COMPRESSION_WEBP)\n    ADD_CASE(COMPRESSION_WEBP);\n#endif\n#if defined (COMPRESSION_JXL)\n    ADD_CASE(COMPRESSION_JXL);\n#endif\n#undef ADD_CASE\n    default:\n        break;\n    }\n    return QString::fromLatin1(\"%1\").arg(compression);\n}\n\nQString ycbcrpositioningToString(quint16 ycbcrpositioning)\n{\n    switch(ycbcrpositioning)\n    {\n#define ADD_CASE(X) case X: return QString::fromLatin1(#X)\n        ADD_CASE(YCBCRPOSITION_CENTERED);\n        ADD_CASE(YCBCRPOSITION_COSITED);\n#undef ADD_CASE\n    default:\n        break;\n    }\n    return QString::fromLatin1(\"%1\").arg(ycbcrpositioning);\n}\n\n// ====================================================================================================\n\ntsize_t readProc(thandle_t fd, tdata_t buf, tsize_t size)\n{\n    QIODevice *device = static_cast<QIODevice*>(fd);\n    return device->isReadable() ? device->read(static_cast<char*>(buf), size) : -1;\n}\n\ntsize_t writeProc(thandle_t fd, tdata_t buf, tsize_t size)\n{\n    QIODevice *device = static_cast<QIODevice*>(fd);\n    return device->isWritable() ? device->write(static_cast<char*>(buf), size) : -1;\n}\n\ntoff_t seekProc(thandle_t fd, toff_t off, int whence)\n{\n    QIODevice *device = static_cast<QIODevice*>(fd);\n    const qint64 soff = static_cast<qint64>(off);\n    switch(whence)\n    {\n    case SEEK_SET:\n        device->seek(soff);\n        break;\n    case SEEK_CUR:\n        device->seek(device->pos() + soff);\n        break;\n    case SEEK_END:\n        device->seek(device->size() + soff);\n        break;\n    }\n    return static_cast<toff_t>(device->pos());\n}\n\nint closeProc(thandle_t /*fd*/)\n{\n    return 0;\n}\n\ntoff_t sizeProc(thandle_t fd)\n{\n    QIODevice *device = static_cast<QIODevice*>(fd);\n    return static_cast<toff_t>(device->size());\n}\n\nint mapProc(thandle_t /*fd*/, tdata_t* /*pbase*/, toff_t* /*psize*/)\n{\n    return 0;\n}\n\nvoid unmapProc(thandle_t /*fd*/, tdata_t /*base*/, toff_t /*size*/)\n{\n}\n\n#if defined (TIFFLIB_VERSION) && (TIFFLIB_VERSION >= 20221213) && (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))\nint errorHandlerProc(TIFF* /*tiff*/, void* /*user_data*/, const char *module, const char *fmt, va_list ap)\n{\n    LOG_WARNING() << LOGGING_CTXS(module) <<  QString::vasprintf(fmt, ap).toLocal8Bit().data();\n    return 1;\n}\n\nint warningHandlerProc(TIFF* /*tiff*/, void* /*user_data*/, const char *module, const char *fmt, va_list ap)\n{\n    LOG_WARNING() << LOGGING_CTXS(module) <<  QString::vasprintf(fmt, ap).toLocal8Bit().data();\n    return 1;\n}\n#endif\n\nICCProfile *readICCProfile(TIFF *tiff)\n{\n    unsigned iccProfileSize = 0;\n    void *iccProfileData = Q_NULLPTR;\n    if(TIFFGetField(tiff, TIFFTAG_ICCPROFILE, &iccProfileSize, &iccProfileData))\n    {\n        LOG_DEBUG() << LOGGING_CTX << \"Found ICCP metadata (TIFFTAG_ICCPROFILE)\";\n        return new ICCProfile(QByteArray(reinterpret_cast<const char*>(iccProfileData), static_cast<int>(iccProfileSize)));\n    }\n\n    quint16 samplesPerPixel = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel))\n        return Q_NULLPTR;\n\n    quint16 bitsPerSample = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample))\n        return Q_NULLPTR;\n\n    float *whitePoint = Q_NULLPTR, *primaryChromaticities = Q_NULLPTR;\n    unsigned short *transferFunctionRed = Q_NULLPTR, *transferFunctionGreen = Q_NULLPTR, *transferFunctionBlue = Q_NULLPTR;\n    if(!TIFFGetField(tiff, TIFFTAG_WHITEPOINT, &whitePoint))\n        whitePoint = Q_NULLPTR;\n    if(!TIFFGetField(tiff, TIFFTAG_PRIMARYCHROMATICITIES, &primaryChromaticities))\n        primaryChromaticities = Q_NULLPTR;\n    if(samplesPerPixel == 1)\n    {\n        if(!TIFFGetField(tiff, TIFFTAG_TRANSFERFUNCTION, &transferFunctionRed, &transferFunctionGreen, &transferFunctionBlue))\n            transferFunctionRed = transferFunctionGreen = transferFunctionBlue = Q_NULLPTR;\n        else\n            transferFunctionGreen = transferFunctionBlue = transferFunctionRed;\n    }\n    else\n    {\n        if(!TIFFGetField(tiff, TIFFTAG_TRANSFERFUNCTION, &transferFunctionRed, &transferFunctionGreen, &transferFunctionBlue))\n            transferFunctionRed = transferFunctionGreen = transferFunctionBlue = Q_NULLPTR;\n    }\n\n    if(whitePoint || primaryChromaticities || transferFunctionRed || transferFunctionGreen || transferFunctionBlue)\n    {\n        LOG_DEBUG() << LOGGING_CTX << \"Found ICCP metadata (TIFFTAG_WHITEPOINT + TIFFTAG_PRIMARYCHROMATICITIES + TIFFTAG_TRANSFERFUNCTION)\";\n\n        /// @note TIFF defaults (CIE D50) does not match sRGB defaults (CIE D65)\n        if(!whitePoint && !TIFFGetFieldDefaulted(tiff, TIFFTAG_WHITEPOINT, &whitePoint))\n            whitePoint = Q_NULLPTR;\n\n        const size_t transferFunctionSize = (static_cast<std::size_t>(1) << bitsPerSample);\n        return new ICCProfile(whitePoint, primaryChromaticities, transferFunctionRed, transferFunctionGreen, transferFunctionBlue, transferFunctionSize);\n    }\n\n    return Q_NULLPTR;\n}\n\n#if defined (TIFFLIB_VERSION) && (TIFFLIB_VERSION >= 20120922)\n\n/// @note See https://learn.foundry.com/nuke/developers/63/ndkreference/examples/tiffReader.cpp\ntemplate<class T>\nvoid addMetaData(TIFF *tiff, const TIFFField *field, ImageMetaData *metaData, const QString &group, const QString &tag)\n{\n    const int readCount = TIFFFieldReadCount(field);\n    if(readCount == TIFF_VARIABLE2 || readCount == TIFF_VARIABLE || readCount > 1)\n    {\n        quint32 actualCount = 0;\n        T *data;\n        if(readCount == TIFF_VARIABLE)\n        {\n            quint16 gotCount = 0;\n            if(!TIFFGetField(tiff, TIFFFieldTag(field), &gotCount, &data))\n                return;\n            actualCount = gotCount;\n        }\n        else if(readCount == TIFF_VARIABLE2)\n        {\n            quint32 gotCount = 0;\n            if(!TIFFGetField(tiff, TIFFFieldTag(field), &gotCount, &data))\n                return;\n            actualCount = gotCount;\n        }\n        else\n        {\n            if(!TIFFGetField(tiff, TIFFFieldTag(field), &data))\n                return;\n            actualCount = readCount;\n        }\n        if(TIFFFieldDataType(field) == TIFF_UNDEFINED)\n        {\n            const char *charData = reinterpret_cast<const char*>(data);\n            const int charSize = static_cast<int>(actualCount * sizeof(T) / sizeof(char));\n            metaData->addExifEntry(group, TIFFFieldTag(field), tag, QString::fromLatin1(QByteArray(charData, charSize).toHex().prepend(\"0x\")));\n        }\n        else\n        {\n            QStringList values;\n            for(quint32 i = 0; i < actualCount; i++)\n                values.append(QString::fromLatin1(\"%1\").arg(data[i]));\n            metaData->addExifEntry(group, TIFFFieldTag(field), tag, QString::fromLatin1(\"{ %1 }\").arg(values.join(QString::fromLatin1(\", \"))));\n        }\n    }\n    else if(readCount == 1)\n    {\n        T data;\n        TIFFGetField(tiff, TIFFFieldTag(field), &data);\n        metaData->addExifEntry(group, TIFFFieldTag(field), tag, QString::fromLatin1(\"%1\").arg(data));\n    }\n}\n\ntemplate<>\nvoid addMetaData<QString>(TIFF *tiff, const TIFFField *field, ImageMetaData *metaData, const QString &group, const QString &tag)\n{\n    if(TIFFFieldReadCount(field) <= 1)\n        return;\n    char *data = Q_NULLPTR;\n    if(!TIFFGetField(tiff, TIFFFieldTag(field), &data) || !data)\n        return;\n    metaData->addExifEntry(group, TIFFFieldTag(field), tag, QString::fromUtf8(data));\n}\n\nvoid readTiffTagToMetaData(TIFF *tiff, ImageMetaData *&metaData, quint32 tag, const QString &tagDescription)\n{\n    const TIFFField *tagField = TIFFFindField(tiff, tag, TIFF_ANY);\n    if(!tagField)\n        return;\n    if(TIFFFieldDataType(tagField) != TIFF_IFD8)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"TIFFFieldDataType for tag (\" << tagDescription << \") is not TIFF_IFD8!\";\n        return;\n    }\n    quint64 exifOffset = 0;\n    if(!TIFFGetField(tiff, tag, &exifOffset))\n        return;\n    if(!TIFFReadEXIFDirectory(tiff, exifOffset))\n        return;\n    LOG_DEBUG() << LOGGING_CTX << \"Found EXIF metadata (\" << tagDescription << \")\";\n    if(!metaData)\n        metaData = new ImageMetaData;\n    for(int i = 0, tagListCount = TIFFGetTagListCount(tiff); i < tagListCount; i++)\n    {\n        ttag_t tag = TIFFGetTagListEntry(tiff, i);\n        const TIFFField *field = TIFFFieldWithTag(tiff, tag);\n        const QString exifName = QString::fromUtf8(TIFFFieldName(field));\n        /// @note See _TIFFVGetField in tif_dir.c\n        switch(TIFFFieldDataType(field))\n        {\n        case TIFF_BYTE:\n        case TIFF_UNDEFINED:\n            addMetaData<quint8>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_ASCII:\n            addMetaData<QString>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SHORT:\n            addMetaData<quint16>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_LONG:\n            addMetaData<quint32>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SBYTE:\n            addMetaData<qint8>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SSHORT:\n            addMetaData<qint16>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SLONG:\n            addMetaData<qint32>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SRATIONAL:\n        case TIFF_RATIONAL:\n        case TIFF_FLOAT:\n            addMetaData<float>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_DOUBLE:\n            addMetaData<double>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_LONG8:\n            addMetaData<quint64>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SLONG8:\n            addMetaData<qint64>(tiff, field, metaData, tagDescription, exifName);\n            break;\n        default:\n            break;\n        }\n    }\n}\n\nImageMetaData *readExifMetaData(TIFF *tiff)\n{\n    ImageMetaData *metaData = Q_NULLPTR;\n    readTiffTagToMetaData(tiff, metaData, TIFFTAG_EXIFIFD, QString::fromLatin1(\"TIFFTAG_EXIFIFD\"));\n    readTiffTagToMetaData(tiff, metaData, TIFFTAG_GPSIFD, QString::fromLatin1(\"TIFFTAG_GPSIFD\"));\n    readTiffTagToMetaData(tiff, metaData, TIFFTAG_INTEROPERABILITYIFD, QString::fromLatin1(\"TIFFTAG_INTEROPERABILITYIFD\"));\n    return metaData;\n}\n\n#else\n\nImageMetaData *readExifMetaData(TIFF */*tiff*/)\n{\n    /// @todo LibTIFF-3.x: Add implementation?\n    return Q_NULLPTR;\n}\n\n#endif\n\n// ====================================================================================================\n\nquint64 getMaxValueUInt(quint64 bitsPerSample)\n{\n    assert(bitsPerSample <= 64);\n    switch(bitsPerSample)\n    {\n    case 8:\n        return static_cast<quint64>(std::numeric_limits<quint8>::max());\n    case 16:\n        return static_cast<quint64>(std::numeric_limits<quint16>::max());\n    case 32:\n        return static_cast<quint64>(std::numeric_limits<quint32>::max());\n    case 64:\n        return static_cast<quint64>(std::numeric_limits<quint64>::max());\n    default:\n        break;\n    }\n    return static_cast<quint64>(0xffffffffffffffffull >> (64 - bitsPerSample));\n}\n\nquint64 getMinValueUInt(quint64 bitsPerSample)\n{\n    assert(bitsPerSample <= 64);\n    Q_UNUSED(bitsPerSample);\n    return 0;\n}\n\nquint64 getValueUInt(const quint8 *buffer, quint64 bitsOffset, quint64 bitsPerSample)\n{\n    assert(buffer);\n    assert(bitsPerSample <= 64);\n    switch(bitsPerSample)\n    {\n    case 8:\n        assert(bitsOffset % 8 == 0);\n        return static_cast<quint64>(*reinterpret_cast<const quint8*>(buffer + bitsOffset / 8));\n    case 16:\n        assert(bitsOffset % 8 == 0);\n        return static_cast<quint64>(DataProcessing::extractFromUnalignedPtr<quint16>(buffer + bitsOffset / 8));\n    case 32:\n        assert(bitsOffset % 8 == 0);\n        return static_cast<quint64>(DataProcessing::extractFromUnalignedPtr<quint32>(buffer + bitsOffset / 8));\n    case 64:\n        assert(bitsOffset % 8 == 0);\n        return static_cast<quint64>(DataProcessing::extractFromUnalignedPtr<quint64>(buffer + bitsOffset / 8));\n    default:\n        break;\n    }\n    return static_cast<quint64>(DataProcessing::getBits(buffer, bitsOffset, bitsPerSample));\n}\n\nqint64 getMaxValueSInt(quint64 bitsPerSample)\n{\n    assert(bitsPerSample <= 64);\n    switch(bitsPerSample)\n    {\n    case 8:\n        return static_cast<qint64>(std::numeric_limits<qint8>::max());\n    case 16:\n        return static_cast<qint64>(std::numeric_limits<qint16>::max());\n    case 32:\n        return static_cast<qint64>(std::numeric_limits<qint32>::max());\n    case 64:\n        return static_cast<qint64>(std::numeric_limits<qint64>::max());\n    default:\n        break;\n    }\n    return static_cast<qint64>(0x7fffffffffffffffull >> (64 - bitsPerSample));\n}\n\nqint64 getMinValueSInt(quint64 bitsPerSample)\n{\n    assert(bitsPerSample <= 64);\n    switch(bitsPerSample)\n    {\n    case 8:\n        return static_cast<qint64>(std::numeric_limits<qint8>::min());\n    case 16:\n        return static_cast<qint64>(std::numeric_limits<qint16>::min());\n    case 32:\n        return static_cast<qint64>(std::numeric_limits<qint32>::min());\n    case 64:\n        return static_cast<qint64>(std::numeric_limits<qint64>::min());\n    default:\n        break;\n    }\n    return static_cast<qint64>(~0ull << (bitsPerSample - 1));\n}\n\nqint64 getValueSInt(const quint8 *buffer, quint64 bitsOffset, quint64 bitsPerSample)\n{\n    assert(buffer);\n    assert(bitsPerSample <= 64);\n    switch(bitsPerSample)\n    {\n    case 8:\n        assert(bitsOffset % 8 == 0);\n        return static_cast<qint64>(*reinterpret_cast<const qint8*>(buffer + bitsOffset / 8));\n    case 16:\n        assert(bitsOffset % 8 == 0);\n        return static_cast<qint64>(DataProcessing::extractFromUnalignedPtr<qint16>(buffer + bitsOffset / 8));\n    case 32:\n        assert(bitsOffset % 8 == 0);\n        return static_cast<qint64>(DataProcessing::extractFromUnalignedPtr<qint32>(buffer + bitsOffset / 8));\n    case 64:\n        assert(bitsOffset % 8 == 0);\n        return static_cast<qint64>(DataProcessing::extractFromUnalignedPtr<qint64>(buffer + bitsOffset / 8));\n    default:\n        break;\n    }\n    quint64 rawValue = static_cast<quint64>(DataProcessing::getBits(buffer, bitsOffset, bitsPerSample));\n    const quint64 signBit = (rawValue >> (bitsPerSample - 1)) & 0x1;\n    if(signBit)\n        rawValue |= static_cast<quint64>(~0ull << (bitsPerSample - 1));\n    return static_cast<qint64>(rawValue);\n}\n\nfloat getValueFP(const quint8 *buffer, quint64 bitsOffset, quint64 bitsPerSample)\n{\n    assert(buffer);\n    assert(bitsPerSample <= 64);\n    switch(bitsPerSample)\n    {\n    case 16:\n        return DataProcessing::float16ToFloat(buffer + bitsOffset / 8);\n    case 24:\n        return DataProcessing::float24ToFloat(buffer + bitsOffset / 8);\n    case 32:\n        return DataProcessing::extractFromUnalignedPtr<float>(buffer + bitsOffset / 8);\n    case 64:\n        return static_cast<float>(DataProcessing::extractFromUnalignedPtr<double>(buffer + bitsOffset / 8));\n    }\n    LOG_WARNING() << LOGGING_CTX << \"Unsupported floating bits per sample =\" << bitsPerSample;\n    assert(false);\n    return static_cast<float>(nan(\"\"));\n}\n\nfloat convertValueToFP(const quint8 *buffer, quint64 bitsOffset, quint16 sampleFormat, quint64 bitsPerSample)\n{\n    assert(buffer);\n    assert(bitsPerSample <= 64);\n    switch(sampleFormat)\n    {\n    case SAMPLEFORMAT_UINT:\n    case SAMPLEFORMAT_VOID:\n    {\n        bitsPerSample = std::min<quint64>(bitsPerSample, static_cast<quint64>(64));\n        const double minValue = static_cast<double>(getMinValueUInt(bitsPerSample));\n        const double maxValue = static_cast<double>(getMaxValueUInt(bitsPerSample));\n        const double value = (static_cast<double>(getValueUInt(buffer, bitsOffset, bitsPerSample)) - minValue) / (maxValue - minValue);\n        return static_cast<float>(value);\n    }\n    case SAMPLEFORMAT_INT:\n    {\n        bitsPerSample = std::min<quint64>(bitsPerSample, static_cast<quint64>(64));\n        const double minValue = static_cast<double>(getMinValueSInt(bitsPerSample));\n        const double maxValue = static_cast<double>(getMaxValueSInt(bitsPerSample));\n        const double value = (static_cast<double>(getValueSInt(buffer, bitsOffset, bitsPerSample)) - minValue) / (maxValue - minValue);\n        return static_cast<float>(value);\n    }\n    case SAMPLEFORMAT_IEEEFP:\n    {\n        const float value = getValueFP(buffer, bitsOffset, bitsPerSample);\n        return value;\n    }\n    case SAMPLEFORMAT_COMPLEXINT:\n    case SAMPLEFORMAT_COMPLEXIEEEFP:\n        LOG_WARNING() << LOGGING_CTX << \"SAMPLEFORMAT_COMPLEXINT and SAMPLEFORMAT_COMPLEXIEEEFP are not supported\";\n        assert(false);\n        break;\n    default:\n        break;\n    }\n    return static_cast<float>(nan(\"\"));\n}\n\nquint8 convertValueToU8(const quint8 *buffer, quint64 bitsOffset, quint16 sampleFormat, quint64 bitsPerSample)\n{\n    assert(buffer);\n    assert(bitsPerSample <= 64);\n    switch(sampleFormat)\n    {\n    case SAMPLEFORMAT_UINT:\n    case SAMPLEFORMAT_VOID:\n    {\n        bitsPerSample = std::min<quint64>(bitsPerSample, static_cast<quint64>(64));\n        if(bitsPerSample == 8)\n        {\n            const quint64 value = getValueUInt(buffer, bitsOffset, bitsPerSample);\n            return DataProcessing::clampByte(value);\n        }\n        if(bitsPerSample < 8 || bitsPerSample > 62)\n        {\n            const float value = convertValueToFP(buffer, bitsOffset, sampleFormat, bitsPerSample);\n            return DataProcessing::clampByte(value * 255.0f);\n        }\n        const quint64 shift = bitsPerSample - 8;\n        const quint64 value = getValueUInt(buffer, bitsOffset, bitsPerSample);\n        return DataProcessing::clampByte(value >> shift);\n    }\n    case SAMPLEFORMAT_INT:\n    {\n        bitsPerSample = std::min<quint64>(bitsPerSample, static_cast<quint64>(64));\n        if(bitsPerSample == 8)\n        {\n            const qint64 minValue = getMinValueSInt(bitsPerSample);\n            const qint64 value = getValueSInt(buffer, bitsOffset, bitsPerSample);\n            return DataProcessing::clampByte(value - minValue);\n        }\n        if(bitsPerSample < 8 || bitsPerSample > 62)\n        {\n            const float value = convertValueToFP(buffer, bitsOffset, sampleFormat, bitsPerSample);\n            return DataProcessing::clampByte(value * 255.0f);\n        }\n        const quint64 shift = bitsPerSample - 8;\n        const qint64 minValue = getMinValueSInt(bitsPerSample);\n        const qint64 value = getValueSInt(buffer, bitsOffset, bitsPerSample);\n        return DataProcessing::clampByte((value - minValue) >> shift);\n    }\n    case SAMPLEFORMAT_IEEEFP:\n    {\n        const float value = getValueFP(buffer, bitsOffset, bitsPerSample);\n        return DataProcessing::clampByte(value * 255.0f);\n    }\n    case SAMPLEFORMAT_COMPLEXINT:\n    case SAMPLEFORMAT_COMPLEXIEEEFP:\n        LOG_WARNING() << LOGGING_CTX << \"SAMPLEFORMAT_COMPLEXINT and SAMPLEFORMAT_COMPLEXIEEEFP are not supported\";\n        assert(false);\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\n// ====================================================================================================\n\nQImage readFromRawBuffer(const quint8 *buffer, qint64 width, qint64 height, qint64 bufferLineSize, const Context *ctx)\n{\n    assert(buffer);\n    assert(ctx);\n\n    switch(ctx->photometric)\n    {\n    case PHOTOMETRIC_MINISWHITE:\n    case PHOTOMETRIC_MINISBLACK:\n    case PHOTOMETRIC_LOGL: // TIFFTAG_SGILOGDATAFMT == SGILOGDATAFMT_8BIT is required\n    {\n        assert(ctx->primarysamplesCount >= 1);\n        const QImage::Format resultFormat = ctx->alphaIndex >= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32;\n#if (USE_GRAYSCALE_8)\n        QImage result(width, height, QImage::Format_Grayscale8);\n        QImage alphaChannel;\n        if(ctx->alphaIndex >= 0)\n            alphaChannel = QImage(width, height, QImage::Format_Alpha8);\n#else\n        QImage result(width, height, resultFormat);\n#endif\n        if(result.isNull())\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n            return result;\n        }\n        for(qint64 y = 0; y < height; ++y)\n        {\n            QRgb *outPtr = reinterpret_cast<QRgb*>(result.scanLine(y));\n            const quint8 *inPtr = reinterpret_cast<const quint8*>(buffer + bufferLineSize * y);\n            for(qint64 x = 0; x < width; ++x)\n            {\n                const qint64 bitOffset = x * ctx->samplesPerPixel * ctx->bitsPerSample;\n                quint8 gray = convertValueToU8(inPtr, static_cast<quint64>(bitOffset), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample));\n                if(ctx->photometric == PHOTOMETRIC_MINISWHITE)\n                    gray = 255 - gray;\n                quint8 alpha = 255;\n                if(ctx->alphaIndex >= 0)\n                {\n                    alpha = convertValueToU8(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * (ctx->primarysamplesCount + ctx->alphaIndex)), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample));\n                    if(ctx->photometric == PHOTOMETRIC_MINISWHITE)\n                        alpha = 255 - alpha;\n                }\n\n#if (USE_GRAYSCALE_8)\n                if(ctx->alphaPremultiplied)\n                    reinterpret_cast<quint8*>(outPtr)[x] = qGray(DataProcessing::unpremultiply(qRgba(gray, gray, gray, alpha)));\n                else\n                    reinterpret_cast<quint8*>(outPtr)[x] = gray;\n                if(!alphaChannel.isNull())\n                    *reinterpret_cast<quint8*>(alphaChannel.scanLine(y) + x) = alpha;\n#else\n                if(ctx->alphaPremultiplied)\n                    outPtr[x] = DataProcessing::unpremultiply(qRgba(gray, gray, gray, alpha));\n                else\n                    outPtr[x] = qRgba(gray, gray, gray, alpha);\n#endif\n            }\n        }\n        if(ctx->iccProfile)\n            ctx->iccProfile->applyToImage(&result);\n#if (USE_GRAYSCALE_8)\n        if(!alphaChannel.isNull())\n        {\n            if(result.hasAlphaChannel())\n                QImage_convertTo(result, QImage::Format_RGB32);\n            QImage_convertTo(result, QImage::Format_ARGB32);\n            result.setAlphaChannel(alphaChannel);\n        }\n#endif\n        if(!IsOneOf(result.format(), resultFormat, QImage::Format_RGB32, QImage::Format_ARGB32))\n            QImage_convertTo(result, resultFormat);\n        return result;\n    }\n    case PHOTOMETRIC_RGB:\n    case PHOTOMETRIC_LOGLUV: // TIFFTAG_SGILOGDATAFMT == SGILOGDATAFMT_8BIT is required\n    {\n        assert(ctx->primarysamplesCount >= 3);\n        const QImage::Format resultFormat = ctx->alphaIndex >= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32;\n        QImage result(width, height, resultFormat);\n        if(result.isNull())\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n            return result;\n        }\n        for(qint64 y = 0; y < height; ++y)\n        {\n            QRgb *outPtr = reinterpret_cast<QRgb*>(result.scanLine(y));\n            const quint8 *inPtr = reinterpret_cast<const quint8*>(buffer + bufferLineSize * y);\n            for(qint64 x = 0; x < width; ++x)\n            {\n                const qint64 bitOffset = x * ctx->samplesPerPixel * ctx->bitsPerSample;\n                const quint8 red = convertValueToU8(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * 0), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample));\n                const quint8 green = convertValueToU8(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * 1), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample));\n                const quint8 blue = convertValueToU8(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * 2), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample));\n                const quint8 alpha = ctx->alphaIndex >= 0\n                        ? convertValueToU8(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * (ctx->primarysamplesCount + ctx->alphaIndex)), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample))\n                        : 255;\n                if(ctx->alphaPremultiplied)\n                    outPtr[x] = DataProcessing::unpremultiply(qRgba(red, green, blue, alpha));\n                else\n                    outPtr[x] = qRgba(red, green, blue, alpha);\n            }\n        }\n        if(ctx->iccProfile)\n            ctx->iccProfile->applyToImage(&result);\n        if(!IsOneOf(result.format(), resultFormat, QImage::Format_RGB32, QImage::Format_ARGB32))\n            QImage_convertTo(result, resultFormat);\n        return result;\n    }\n    case PHOTOMETRIC_SEPARATED:\n    {\n        assert(ctx->primarysamplesCount >= 4);\n        const QImage::Format resultFormat = ctx->alphaIndex >= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32;\n#if (USE_CMYK_8888)\n        QImage result(width, height, QImage::Format_CMYK8888);\n        QImage alphaChannel;\n        if(ctx->alphaIndex >= 0)\n            alphaChannel = QImage(width, height, QImage::Format_Alpha8);\n#else\n        QImage result(width, height, resultFormat);\n#endif\n        if(result.isNull())\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n            return result;\n        }\n        for(qint64 y = 0; y < height; ++y)\n        {\n            QRgb *outPtr = reinterpret_cast<QRgb*>(result.scanLine(y));\n            const quint8 *inPtr = reinterpret_cast<const quint8*>(buffer + bufferLineSize * y);\n            for(qint64 x = 0; x < width; ++x)\n            {\n                const qint64 bitOffset = x * ctx->samplesPerPixel * ctx->bitsPerSample;\n                const quint8 cyan = convertValueToU8(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * 0), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample));\n                const quint8 magenta = convertValueToU8(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * 1), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample));\n                const quint8 yellow = convertValueToU8(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * 2), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample));\n                const quint8 key = convertValueToU8(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * 3), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample));\n                const quint8 alpha = ctx->alphaIndex >= 0\n                        ? convertValueToU8(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * (ctx->primarysamplesCount + ctx->alphaIndex)), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample))\n                        : 255;\n                /// @todo Why alpha is not premultiplied in CMYK images from Adobe Photoshop even for EXTRASAMPLE_ASSOCALPHA?\n#if (USE_CMYK_8888)\n                quint8 *outColor = reinterpret_cast<quint8*>(outPtr + x);\n                outColor[0] = cyan;\n                outColor[1] = magenta;\n                outColor[2] = yellow;\n                outColor[3] = key;\n                if(!alphaChannel.isNull())\n                    *reinterpret_cast<quint8*>(alphaChannel.scanLine(y) + x) = alpha;\n#else\n                outPtr[x] = DataProcessing::CMYK8ToRgba(cyan, magenta, yellow, key, alpha);\n#endif\n            }\n        }\n        if(ctx->iccProfile)\n            ctx->iccProfile->applyToImage(&result);\n#if (USE_CMYK_8888)\n        if(!alphaChannel.isNull())\n        {\n            if(result.hasAlphaChannel())\n                QImage_convertTo(result, QImage::Format_RGB32);\n            QImage_convertTo(result, QImage::Format_ARGB32);\n            result.setAlphaChannel(alphaChannel);\n        }\n#endif\n        if(!IsOneOf(result.format(), resultFormat, QImage::Format_RGB32, QImage::Format_ARGB32))\n            QImage_convertTo(result, resultFormat);\n        return result;\n    }\n    case PHOTOMETRIC_YCBCR:\n    {\n        assert(ctx->primarysamplesCount == 3);\n        const QImage::Format resultFormat = ctx->alphaIndex >= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32;\n        QImage result(width, height, resultFormat);\n        if(result.isNull())\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n            return result;\n        }\n        if(ctx->subsamplinghor > 1 || ctx->subsamplingver > 1)\n        {\n            QImage upsampledCbCr(result.width(), result.height(), QImage::Format_ARGB32);\n            if(upsampledCbCr.isNull())\n            {\n                LOG_WARNING() << LOGGING_CTX << \"Invalid upsampled image size\";\n                goto NoUpsampling;\n            }\n            for(qint64 y = 0; y < height; ++y)\n            {\n                quint8 *outPtr = reinterpret_cast<quint8*>(upsampledCbCr.scanLine(y));\n                const quint8 *inPtr = reinterpret_cast<const quint8*>(buffer + bufferLineSize * y);\n                for(qint64 x = 0; x < width; ++x)\n                {\n                    const qint64 bitOffset = x * ctx->samplesPerPixel * ctx->bitsPerSample;\n                    const quint8 Cb = convertValueToU8(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * 1), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample));\n                    const quint8 Cr = convertValueToU8(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * 2), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample));\n                    outPtr[x * 4 + 0] = outPtr[x * 4 + 2] = Cb;\n                    outPtr[x * 4 + 1] = outPtr[x * 4 + 3] = Cr;\n                }\n            }\n            if(ctx->subsamplinghor > 1)\n            {\n                for(qint64 y = 0; y < height; y += ctx->subsamplingver)\n                {\n                    quint8 *outPtr = reinterpret_cast<quint8*>(upsampledCbCr.scanLine(y));\n                    const quint8 *inPtr = reinterpret_cast<const quint8*>(upsampledCbCr.scanLine(y));\n                    for(qint64 x = 0; x < width; ++x)\n                    {\n                        qint64 leftIndex;\n                        float rightWeight;\n                        if(ctx->ycbcrpositioning == YCBCRPOSITION_COSITED)\n                        {\n                            leftIndex = std::max<qint64>(0, x - (x % ctx->subsamplinghor));\n                            rightWeight = static_cast<float>(x - leftIndex) / static_cast<float>(ctx->subsamplinghor);\n                        }\n                        else\n                        {\n                            const float leftPos = static_cast<float>(x - (x % ctx->subsamplinghor) - (((x % ctx->subsamplinghor) >= ctx->subsamplinghor / 2) ? 0 : ctx->subsamplinghor))\n                                    + static_cast<float>(ctx->subsamplinghor - 1) / 2.0f;\n                            leftIndex = std::max<qint64>(0, static_cast<int>(leftPos));\n                            rightWeight = (static_cast<float>(x) - leftPos) / static_cast<float>(ctx->subsamplinghor);\n                        }\n                        const qint64 rightIndex = std::min<qint64>(width - 1, leftIndex + ctx->subsamplinghor);\n                        const float leftWeight = 1.0f - rightWeight;\n                        for(qint64 c = 0; c < 2; ++c)\n                        {\n                            const quint8 leftValue = inPtr[leftIndex * 4 + c];\n                            const quint8 rightValue = inPtr[rightIndex * 4 + c];\n                            const float newValue = static_cast<float>(leftValue) * leftWeight + static_cast<float>(rightValue) * rightWeight;\n                            outPtr[x * 4 + c + 2] = DataProcessing::clampByte(newValue);\n                        }\n                    }\n                    for(qint64 x = 0; x < width; ++x)\n                    {\n                        for(qint64 c = 0; c < 2; ++c)\n                            outPtr[x * 4 + c] = outPtr[x * 4 + c + 2];\n                    }\n                    for(qint64 i = 0; i < ctx->subsamplingver && y + i < height; ++i)\n                        memcpy(upsampledCbCr.scanLine(y + i), outPtr, width * 4);\n                }\n            }\n            if(ctx->subsamplingver > 1)\n            {\n                for(qint64 y = 0; y < height; ++y)\n                {\n                    qint64 upIndex;\n                    float downWeight;\n                    if(ctx->ycbcrpositioning == YCBCRPOSITION_COSITED)\n                    {\n                        upIndex = std::max<qint64>(0, y - (y % ctx->subsamplingver));\n                        downWeight = static_cast<float>(y - upIndex) / static_cast<float>(ctx->subsamplingver);\n                    }\n                    else\n                    {\n                        const float upPos = static_cast<float>(y - (y % ctx->subsamplingver) - (((y % ctx->subsamplingver) >= ctx->subsamplingver / 2) ? 0 : ctx->subsamplingver))\n                                + static_cast<float>(ctx->subsamplingver - 1) / 2.0f;\n                        upIndex = std::max<qint64>(0, static_cast<int>(upPos));\n                        downWeight = (static_cast<float>(y) - upPos) / static_cast<float>(ctx->subsamplingver);\n                    }\n                    const qint64 downIndex = std::min<qint64>(height - 1, upIndex + ctx->subsamplingver);\n                    const float upWeight = 1.0f - downWeight;\n                    const quint8 *upPtr = reinterpret_cast<const quint8*>(upsampledCbCr.scanLine(upIndex));\n                    const quint8 *downPtr = reinterpret_cast<const quint8*>(upsampledCbCr.scanLine(downIndex));\n                    quint8 *outPtr = reinterpret_cast<quint8*>(upsampledCbCr.scanLine(y));\n                    for(qint64 x = 0; x < width; ++x)\n                    {\n                        for(qint64 c = 0; c < 2; ++c)\n                        {\n                            const quint8 upValue = upPtr[x * 4 + c];\n                            const quint8 downValue = downPtr[x * 4 + c];\n                            const float newValue = static_cast<float>(upValue) * upWeight + static_cast<float>(downValue) * downWeight;\n                            outPtr[x * 4 + c + 2] = DataProcessing::clampByte(newValue);\n                        }\n                    }\n                }\n                for(qint64 y = 0; y < height; ++y)\n                {\n                    quint8 *outPtr = reinterpret_cast<quint8*>(upsampledCbCr.scanLine(y));\n                    for(qint64 x = 0; x < width; ++x)\n                    {\n                        for(qint64 c = 0; c < 2; ++c)\n                            outPtr[x * 4 + c] = outPtr[x * 4 + c + 2];\n                    }\n                }\n            }\n            for(qint64 y = 0; y < height; ++y)\n            {\n                QRgb *outPtr = reinterpret_cast<QRgb*>(result.scanLine(y));\n                const quint8 *inPtr = reinterpret_cast<const quint8*>(buffer + bufferLineSize * y);\n                const quint8 *inCbCrPtr = reinterpret_cast<const quint8*>(upsampledCbCr.scanLine(y));\n                for(qint64 x = 0; x < width; ++x)\n                {\n                    const qint64 bitOffset = x * ctx->samplesPerPixel * ctx->bitsPerSample;\n                    float Y  = convertValueToFP(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * 0), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample));\n                    float Cb = inCbCrPtr[x * 4 + 0] / 255.0f;\n                    float Cr = inCbCrPtr[x * 4 + 1] / 255.0f;\n                    const float alpha = ctx->alphaIndex >= 0\n                            ? convertValueToFP(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * (ctx->primarysamplesCount + ctx->alphaIndex)), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample))\n                            : 1.0f;\n                    if(ctx->alphaPremultiplied)\n                    {\n                        const float alphaScale = alpha > 0.0f ? (1.0f / alpha) : 1.0f;\n                        Y *= alphaScale;\n                        Cb *= alphaScale;\n                        Cr *= alphaScale;\n                    }\n                    Cb -= 0.5f;\n                    Cr -= 0.5f;\n                    outPtr[x] = DataProcessing::YCbCrToRgba(Y, Cb, Cr, alpha, ctx->ycbcrcoeffs);\n                }\n            }\n        }\n        else\n        {\nNoUpsampling:\n            for(qint64 y = 0; y < height; ++y)\n            {\n                QRgb *outPtr = reinterpret_cast<QRgb*>(result.scanLine(y));\n                const quint8 *inPtr = reinterpret_cast<const quint8*>(buffer + bufferLineSize * y);\n                for(qint64 x = 0; x < width; ++x)\n                {\n                    const qint64 bitOffset = x * ctx->samplesPerPixel * ctx->bitsPerSample;\n                    float Y  = convertValueToFP(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * 0), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample));\n                    float Cb = convertValueToFP(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * 1), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample));\n                    float Cr = convertValueToFP(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * 2), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample));\n                    const float alpha = ctx->alphaIndex >= 0\n                            ? convertValueToFP(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * (ctx->primarysamplesCount + ctx->alphaIndex)), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample))\n                            : 1.0f;\n                    if(ctx->alphaPremultiplied)\n                    {\n                        const float alphaScale = alpha > 0.0f ? (1.0f / alpha) : 1.0f;\n                        Y *= alphaScale;\n                        Cb *= alphaScale;\n                        Cr *= alphaScale;\n                    }\n                    Cb -= 0.5f;\n                    Cr -= 0.5f;\n                    outPtr[x] = DataProcessing::YCbCrToRgba(Y, Cb, Cr, alpha, ctx->ycbcrcoeffs);\n                }\n            }\n        }\n        if(ctx->iccProfile)\n            ctx->iccProfile->applyToImage(&result);\n        if(!IsOneOf(result.format(), resultFormat, QImage::Format_RGB32, QImage::Format_ARGB32))\n            QImage_convertTo(result, resultFormat);\n        return result;\n    }\n    case PHOTOMETRIC_CIELAB:\n    case PHOTOMETRIC_ICCLAB:\n    case PHOTOMETRIC_ITULAB:\n    {\n        assert(ctx->primarysamplesCount >= 1);\n        const QImage::Format resultFormat = ctx->alphaIndex >= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32;\n        QImage result(width, height, resultFormat);\n        if(result.isNull())\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n            return result;\n        }\n        for(qint64 y = 0; y < height; ++y)\n        {\n            QRgb *outPtr = reinterpret_cast<QRgb*>(result.scanLine(y));\n            const quint8 *inPtr = reinterpret_cast<const quint8*>(buffer + bufferLineSize * y);\n            for(qint64 x = 0; x < width; ++x)\n            {\n                quint16 abSampleFormat = ctx->sampleFormat;\n                /// @note CIELAB is meaningless for unsigned input, as for ITULAB is meaningless for signed input.\n                /// But we will try to fix some ill-formed files with wrong sample format because it should be safe\n                if(ctx->photometric == PHOTOMETRIC_CIELAB && IsOneOf(ctx->sampleFormat, SAMPLEFORMAT_VOID, SAMPLEFORMAT_UINT))\n                    abSampleFormat = SAMPLEFORMAT_INT;\n                else if(IsOneOf(ctx->photometric, PHOTOMETRIC_ITULAB, PHOTOMETRIC_ITULAB) && IsOneOf(ctx->sampleFormat, SAMPLEFORMAT_VOID, SAMPLEFORMAT_INT))\n                    abSampleFormat = SAMPLEFORMAT_UINT;\n                const qint64 bitOffset = x * ctx->samplesPerPixel * ctx->bitsPerSample;\n                float L = convertValueToFP(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * 0), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample));\n                float a = ctx->primarysamplesCount >= 3\n                        ? convertValueToFP(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * 1), abSampleFormat, static_cast<quint64>(ctx->bitsPerSample))\n                        : 0.0f;\n                float b = ctx->primarysamplesCount >= 3\n                        ? convertValueToFP(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * 2), abSampleFormat, static_cast<quint64>(ctx->bitsPerSample))\n                        : 0.0f;\n                const float alpha = ctx->alphaIndex >= 0\n                        ? convertValueToFP(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * (ctx->primarysamplesCount + ctx->alphaIndex)), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample))\n                        : 1.0f;\n                if(ctx->alphaPremultiplied)\n                {\n                    const float alphaScale = alpha > 0.0f ? (1.0f / alpha) : 1.0f;\n                    L *= alphaScale;\n                    a *= alphaScale;\n                    b *= alphaScale;\n                }\n                L *= 100.0f;\n                if(ctx->primarysamplesCount >= 3)\n                {\n                    if(ctx->photometric == PHOTOMETRIC_ITULAB)\n                    {\n                        a = (-21760.0f / 255.0f) + a * ((21590.0f / 255.0f) - (-21760.0f / 255.0f));\n                        b = (-19200.0f / 255.0f) + b * ((31800.0f / 255.0f) - (-19200.0f / 255.0f));\n                    }\n                    else\n                    {\n                        a = a * 256.0f - 128.0f;\n                        b = b * 256.0f - 128.0f;\n                    }\n                }\n                outPtr[x] = DataProcessing::LabToRgba(L, a, b, alpha);\n            }\n        }\n        if(ctx->iccProfile)\n            ctx->iccProfile->applyToImage(&result);\n        if(!IsOneOf(result.format(), resultFormat, QImage::Format_RGB32, QImage::Format_ARGB32))\n            QImage_convertTo(result, resultFormat);\n        return result;\n    }\n    case PHOTOMETRIC_PALETTE:\n    {\n        assert(ctx->redTable);\n        assert(ctx->greenTable);\n        assert(ctx->blueTable);\n        assert(ctx->primarysamplesCount >= 1);\n        const QImage::Format resultFormat = ctx->alphaIndex >= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32;\n        QImage result(width, height, resultFormat);\n        if(result.isNull())\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n            return result;\n        }\n        const quint16 shiftFor8BitColors = ctx->colorTablesIs16Bit ? 8 : 0;\n        for(qint64 y = 0; y < height; ++y)\n        {\n            QRgb *outPtr = reinterpret_cast<QRgb*>(result.scanLine(y));\n            const quint8 *inPtr = reinterpret_cast<const quint8*>(buffer + bufferLineSize * y);\n            for(qint64 x = 0; x < width; ++x)\n            {\n                const qint64 bitOffset = x * ctx->samplesPerPixel * ctx->bitsPerSample;\n                const quint64 colorIndex = getValueUInt(inPtr, static_cast<quint64>(bitOffset), static_cast<quint64>(ctx->bitsPerSample));\n                assert(colorIndex <= getMaxValueUInt(static_cast<quint64>(ctx->bitsPerSample)));\n                const quint8 red = ctx->redTable[colorIndex] >> shiftFor8BitColors;\n                const quint8 green = ctx->greenTable[colorIndex] >> shiftFor8BitColors;\n                const quint8 blue = ctx->blueTable[colorIndex] >> shiftFor8BitColors;\n                const quint8 alpha = ctx->alphaIndex >= 0\n                        ? convertValueToU8(inPtr, static_cast<quint64>(bitOffset + ctx->bitsPerSample * (ctx->primarysamplesCount + ctx->alphaIndex)), ctx->sampleFormat, static_cast<quint64>(ctx->bitsPerSample))\n                        : 255;\n                if(ctx->alphaPremultiplied)\n                    outPtr[x] = DataProcessing::unpremultiply(qRgba(red, green, blue, alpha));\n                else\n                    outPtr[x] = qRgba(red, green, blue, alpha);\n            }\n        }\n        if(ctx->iccProfile)\n            ctx->iccProfile->applyToImage(&result);\n        if(!IsOneOf(result.format(), resultFormat, QImage::Format_RGB32, QImage::Format_ARGB32))\n            QImage_convertTo(result, resultFormat);\n        return result;\n    }\n    default:\n        break;\n    }\n    return QImage();\n}\n\n// ====================================================================================================\n\nQImage readTiffFileTiledContig(const Context *ctx, qint64 nTiles, qint64 tileWidth, qint64 tileHeight)\n{\n    assert(ctx);\n    assert(ctx->tiff);\n    assert(nTiles > 0);\n    assert(tileWidth > 0);\n    assert(tileHeight > 0);\n    LOG_DEBUG() << LOGGING_CTX << \"Tiled data with single image plane of data detected\";\n\n    QImage result(ctx->width, ctx->height, ctx->alphaIndex >= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n    if(result.isNull())\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n        return QImage();\n    }\n    result.fill(ctx->alphaIndex >= 0 ? Qt::transparent : Qt::white);\n\n    const qint64 bufferAllocSize = tileWidth * tileHeight * ctx->samplesPerPixel * ctx->bitsPerSample / 8;\n    if(bufferAllocSize > BUFFER_MAX_SIZE)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't allocate buffer with size =\" << bufferAllocSize << \"due to allocation limit =\" << BUFFER_MAX_SIZE;\n        return QImage();\n    }\n\n    QByteArray buffer;\n    buffer.resize(bufferAllocSize);\n\n    const qint64 leftX = ctx->width % tileWidth;\n    const qint64 leftY = ctx->height % tileHeight;\n    const qint64 nTilesX = (ctx->width / tileWidth)   + (leftX == 0 ? 0 : 1);\n    const qint64 nTilesY = (ctx->height / tileHeight) + (leftY == 0 ? 0 : 1);\n    const qint64 tileLineSize = tileWidth * ctx->samplesPerPixel * ctx->bitsPerSample / 8;\n\n    bool somethingReaded = false;\n    for(qint64 tile = 0; tile < nTiles; ++tile)\n    {\n        memset(buffer.data(), BUFFER_FILL_PATTERN, static_cast<size_t>(buffer.size()));\n        const qint64 currTileX = tile % nTilesX;\n        const qint64 currTileY = tile / nTilesX;\n        const qint64 currTileWidth  = ((currTileX == nTilesX - 1) && leftX) ? leftX : tileWidth;\n        const qint64 currTileHeight = ((currTileY == nTilesY - 1) && leftY) ? leftY : tileHeight;\n        const qint64 expectedTileBufferSize = tileLineSize * tileHeight;\n        assert(bufferAllocSize >= expectedTileBufferSize);\n#if !defined (DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER)\n        qint64 bufferSize = TIFFReadEncodedTile(ctx->tiff, static_cast<quint32>(tile), buffer.data(), buffer.size());\n#else\n        qint64 bufferSize = -1;\n#endif\n#if defined (DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER)\n        bufferSize = -1;\n#endif\n        if(bufferSize <= 0)\n        {\n            LOG_WARNING() << LOGGING_CTX << \"TIFFReadEncodedTile failed for tile\" << tile;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n            /// @todo LibTIFF-4.6.0: Repeated read is not supported for some compression formats (e.g. OJPEG)\n            /// So let's check current buffer, it may be already filled with all available data\n            bool bufferIsEmpty = true;\n            for(qint64 i = 0; i < buffer.size() && bufferIsEmpty; ++i)\n            {\n                if(*reinterpret_cast<quint8*>(buffer.data() + i) != BUFFER_FILL_PATTERN)\n                    bufferIsEmpty = false;\n            }\n            if(bufferIsEmpty)\n            {\n                for(qint64 row = currTileHeight; row >= 1; --row)\n                {\n                    const qint64 newSize = TIFFReadEncodedTile(ctx->tiff, static_cast<quint32>(tile), buffer.data(), row * tileLineSize);\n                    if(newSize > 0)\n                    {\n                        LOG_DEBUG() << LOGGING_CTX << \"Recovered rows:\" << row << \"of\" << currTileHeight;\n                        bufferSize = std::max(expectedTileBufferSize, newSize);\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                LOG_DEBUG() << LOGGING_CTX << \"Buffer has some data, assume recovered\";\n                bufferSize = expectedTileBufferSize;\n            }\n#endif\n            if(bufferSize <= 0)\n                continue;\n        }\n        if(bufferSize < expectedTileBufferSize)\n        {\n            LOG_WARNING() << LOGGING_CTX << \"TIFFReadEncodedTile returns not enough data to decode tile\" << tile << \"got:\" << bufferSize << \"expected:\" << expectedTileBufferSize;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n            bufferSize = expectedTileBufferSize;\n#else\n            continue;\n#endif\n        }\n\n        assert(tileLineSize * tileHeight <= bufferSize);\n        const QImage tileRgb = readFromRawBuffer(reinterpret_cast<const quint8*>(buffer.data()), tileWidth, tileHeight, tileLineSize, ctx);\n        if(tileRgb.isNull())\n            continue;\n\n        assert(IsOneOf(tileRgb.format(), QImage::Format_ARGB32, QImage::Format_RGB32));\n        for(qint64 y = 0; y < currTileHeight; ++y)\n        {\n            const QRgb *inScanLine = reinterpret_cast<const QRgb*>(tileRgb.scanLine(y));\n            QRgb *outScanLine = reinterpret_cast<QRgb*>(result.scanLine(currTileY * tileHeight + y)) + currTileX * tileWidth;\n            memcpy(outScanLine, inScanLine, static_cast<size_t>(currTileWidth * 4));\n        }\n        somethingReaded = true;\n    }\n\n    if(!somethingReaded)\n        return QImage();\n    return result;\n}\n\nQImage readTiffFileTiledContigSubsampled(const Context *ctx, qint64 nTiles, qint64 tileWidth, qint64 tileHeight)\n{\n    assert(ctx);\n    assert(ctx->tiff);\n    assert(nTiles > 0);\n    assert(tileWidth > 0);\n    assert(tileHeight > 0);\n    LOG_DEBUG() << LOGGING_CTX << \"Tiled data with single image plane of subsampled data detected\";\n\n    QImage result(ctx->width, ctx->height, ctx->alphaIndex >= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n    if(result.isNull())\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n        return QImage();\n    }\n    result.fill(ctx->alphaIndex >= 0 ? Qt::transparent : Qt::white);\n\n    const qint64 bufferAllocSize = (tileWidth + 4) * (tileHeight + 4) * ctx->samplesPerPixel * ctx->bitsPerSample / 8;\n    if(bufferAllocSize > BUFFER_MAX_SIZE)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't allocate buffer with size =\" << bufferAllocSize << \"due to allocation limit =\" << BUFFER_MAX_SIZE;\n        return QImage();\n    }\n\n    QByteArray buffer;\n    buffer.resize(bufferAllocSize);\n\n    QByteArray tileBuffer;\n    tileBuffer.resize(bufferAllocSize);\n\n    const qint64 leftX = ctx->width % tileWidth;\n    const qint64 leftY = ctx->height % tileHeight;\n    const qint64 nTilesX = (ctx->width / tileWidth)   + (leftX == 0 ? 0 : 1);\n    const qint64 nTilesY = (ctx->height / tileHeight) + (leftY == 0 ? 0 : 1);\n    const qint64 tileLineBitSize = tileWidth * ctx->samplesPerPixel * ctx->bitsPerSample;\n    const qint64 tileLineSize = tileLineBitSize / 8;\n    const qint64 tileWidthAligned = tileWidth + (tileWidth % ctx->subsamplinghor > 0 ? (ctx->subsamplinghor - tileWidth % ctx->subsamplinghor) : 0);\n    const qint64 tileHeightAligned = tileHeight + (tileHeight % ctx->subsamplingver > 0 ? (ctx->subsamplingver - tileHeight % ctx->subsamplingver) : 0);\n\n    bool somethingReaded = false;\n    for(qint64 tile = 0; tile < nTiles; ++tile)\n    {\n        memset(buffer.data(), BUFFER_FILL_PATTERN, static_cast<size_t>(buffer.size()));\n        memset(tileBuffer.data(), BUFFER_FILL_PATTERN, static_cast<size_t>(tileBuffer.size()));\n        const qint64 currTileX = tile % nTilesX;\n        const qint64 currTileY = tile / nTilesX;\n        const qint64 currTileWidth  = ((currTileX == nTilesX - 1) && leftX) ? leftX : tileWidth;\n        const qint64 currTileHeight = ((currTileY == nTilesY - 1) && leftY) ? leftY : tileHeight;\n        const qint64 expectedTileBufferSize = tileHeight * tileWidth * (ctx->samplesPerPixel - 2) * ctx->bitsPerSample / 8 + tileHeight / ctx->subsamplingver * tileWidth / ctx->subsamplinghor * 2 * ctx->bitsPerSample / 8;\n        const qint64 expectedTileBufferSizeAligned = expectedTileBufferSize * tileWidthAligned * tileHeightAligned / tileHeight / tileWidth;\n        assert(tileBuffer.size() >= expectedTileBufferSizeAligned);\n#if !defined (DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER)\n        qint64 tileBufferSize = TIFFReadEncodedTile(ctx->tiff, static_cast<quint32>(tile), tileBuffer.data(), tileBuffer.size());\n#else\n        qint64 tileBufferSize = -1;\n#endif\n#if defined (DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER)\n        tileBufferSize = -1;\n#endif\n        if(tileBufferSize <= 0)\n        {\n            LOG_WARNING() << LOGGING_CTX << \"TIFFReadEncodedTile failed for tile\" << tile;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n            /// @todo LibTIFF-4.6.0: Repeated read is not supported for some compression formats (e.g. OJPEG)\n            /// So let's check current buffer, it may be already filled with all available data\n            bool bufferIsEmpty = true;\n            for(qint64 i = 0; i < tileBuffer.size() && bufferIsEmpty; ++i)\n            {\n                if(*reinterpret_cast<quint8*>(tileBuffer.data() + i) != BUFFER_FILL_PATTERN)\n                    bufferIsEmpty = false;\n            }\n            if(bufferIsEmpty)\n            {\n                const qint64 currTileHeightAligned = currTileHeight + (currTileHeight % ctx->subsamplingver > 0 ? (ctx->subsamplingver - currTileHeight % ctx->subsamplingver) : 0);\n                for(qint64 row = currTileHeightAligned; row >= ctx->subsamplingver; row -= ctx->subsamplingver)\n                {\n                    const qint64 newSize = TIFFReadEncodedTile(ctx->tiff, static_cast<quint32>(tile), tileBuffer.data(), row * expectedTileBufferSize / tileHeight);\n                    if(newSize > 0)\n                    {\n                        LOG_DEBUG() << LOGGING_CTX << \"Recovered rows:\" << row << \"of\" << currTileHeightAligned;\n                        tileBufferSize = std::max(expectedTileBufferSizeAligned, newSize);\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                LOG_DEBUG() << LOGGING_CTX << \"Buffer has some data, assume recovered\";\n                tileBufferSize = expectedTileBufferSize;\n            }\n#endif\n            if(tileBufferSize <= 0)\n                continue;\n        }\n        if(tileBufferSize < expectedTileBufferSize)\n        {\n            LOG_WARNING() << LOGGING_CTX << \"TIFFReadEncodedTile returns not enough data to decode tile\" << tile << \"got:\" << tileBufferSize << \"expected:\" << expectedTileBufferSize;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n            tileBufferSize = expectedTileBufferSizeAligned;\n#else\n            Q_UNUSED(expectedTileBufferSizeAligned);\n            continue;\n#endif\n        }\n\n        const qint64 tileScanlineSize = tileBufferSize / ctx->subsamplinghor / tileHeight * ctx->subsamplingver;\n#if !defined (DEBUG_FORCE_BIT_ACCESS)\n        if(ctx->bitsPerSample % 8 == 0)\n#else\n        if(false)\n#endif\n        {\n            qint64 bufferLinePos = 0;\n            qint64 bufferOffset = bufferLinePos;\n            qint64 tileBufferLinePos = 0;\n            qint64 tileBufferOffset = tileBufferLinePos;\n\n            while(tileBufferOffset < tileBufferSize && bufferOffset < buffer.size())\n            {\n                for(qint64 c = 0; c < ctx->samplesPerPixel; ++c)\n                {\n                    const bool isChroma = IsOneOf(c, 1, 2);\n                    if(!isChroma)\n                    {\n                        for(qint64 y = 0; y < ctx->subsamplingver; ++y)\n                        {\n                            for(qint64 x = 0; x < ctx->subsamplinghor; ++x)\n                            {\n                                const qint64 bufferCurrOffset = bufferOffset + y * tileLineSize + x * ctx->bitsPerSample / 8 * ctx->samplesPerPixel + c * ctx->bitsPerSample / 8;\n                                qint64 tileBufferCurrOffset = tileBufferOffset;\n                                assert(bufferCurrOffset + ctx->bitsPerSample / 8 <= buffer.size());\n                                assert(tileBufferCurrOffset + ctx->bitsPerSample / 8 <= tileBufferSize);\n                                memcpy(buffer.data() + bufferCurrOffset, tileBuffer.data() + tileBufferCurrOffset, static_cast<size_t>(ctx->bitsPerSample / 8));\n                                tileBufferOffset += ctx->bitsPerSample / 8;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        for(qint64 y = 0; y < ctx->subsamplingver; ++y)\n                        {\n                            for(qint64 x = 0; x < ctx->subsamplinghor; ++x)\n                            {\n                                const qint64 bufferCurrOffset = bufferOffset + y * tileLineSize + x * ctx->bitsPerSample / 8 * ctx->samplesPerPixel + c * ctx->bitsPerSample / 8;\n                                assert(bufferCurrOffset + ctx->bitsPerSample / 8 <= buffer.size());\n                                assert(tileBufferOffset + ctx->bitsPerSample / 8 <= tileBufferSize);\n                                memcpy(buffer.data() + bufferCurrOffset, tileBuffer.data() + tileBufferOffset, static_cast<size_t>(ctx->bitsPerSample / 8));\n                            }\n                        }\n                        tileBufferOffset += ctx->bitsPerSample / 8;\n                    }\n                }\n                bufferOffset += ctx->bitsPerSample / 8 * ctx->samplesPerPixel * ctx->subsamplinghor;\n                if(bufferLinePos + tileWidth * ctx->samplesPerPixel * ctx->bitsPerSample / 8 <= bufferOffset)\n                {\n                    bufferLinePos += tileLineSize * ctx->subsamplingver;\n                    bufferOffset = bufferLinePos;\n                    tileBufferLinePos += tileScanlineSize * ctx->subsamplingver;\n                    tileBufferOffset = tileBufferLinePos;\n                }\n                if(bufferLinePos + tileLineSize > tileLineSize * tileHeight)\n                    break;\n            }\n        }\n        else\n        {\n            qint64 bufferLineBitPos = 0;\n            qint64 bufferBitOffset = bufferLineBitPos;\n            qint64 tileBufferLineBitPos = 0;\n            qint64 tileBufferBitOffset = tileBufferLineBitPos;\n\n            while(tileBufferBitOffset < tileBufferSize * 8 && bufferBitOffset < buffer.size() * 8)\n            {\n                for(qint64 c = 0; c < ctx->samplesPerPixel; ++c)\n                {\n                    const bool isChroma = IsOneOf(c, 1, 2);\n                    if(!isChroma)\n                    {\n                        for(qint64 y = 0; y < ctx->subsamplingver; ++y)\n                        {\n                            for(qint64 x = 0; x < ctx->subsamplinghor; ++x)\n                            {\n                                const qint64 bufferCurrBitOffset = bufferBitOffset + y * tileLineSize * 8 + x * ctx->bitsPerSample * ctx->samplesPerPixel + c * ctx->bitsPerSample;\n                                qint64 tileBufferCurrBitOffset = tileBufferBitOffset;\n                                assert(bufferCurrBitOffset + ctx->bitsPerSample <= buffer.size() * 8);\n                                assert(tileBufferCurrBitOffset + ctx->bitsPerSample <= tileBufferSize * 8);\n                                DataProcessing::memcpyBits(buffer.data(), static_cast<quint64>(bufferCurrBitOffset),\n                                                           tileBuffer.data(), static_cast<quint64>(tileBufferCurrBitOffset),\n                                                           static_cast<quint64>(ctx->bitsPerSample));\n                                tileBufferBitOffset += ctx->bitsPerSample;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        for(qint64 y = 0; y < ctx->subsamplingver; ++y)\n                        {\n                            for(qint64 x = 0; x < ctx->subsamplinghor; ++x)\n                            {\n                                const qint64 bufferCurrBitOffset = bufferBitOffset + y * tileLineSize * 8 + x * ctx->bitsPerSample * ctx->samplesPerPixel + c * ctx->bitsPerSample;\n                                assert(bufferCurrBitOffset + ctx->bitsPerSample <= buffer.size() * 8);\n                                assert(tileBufferBitOffset + ctx->bitsPerSample <= tileBufferSize * 8);\n                                DataProcessing::memcpyBits(buffer.data(), static_cast<quint64>(bufferCurrBitOffset),\n                                                           tileBuffer.data(), static_cast<quint64>(tileBufferBitOffset),\n                                                           static_cast<quint64>(ctx->bitsPerSample));\n                            }\n                        }\n                        tileBufferBitOffset += ctx->bitsPerSample;\n                    }\n                }\n                bufferBitOffset += ctx->bitsPerSample * ctx->samplesPerPixel * ctx->subsamplinghor;\n                if(bufferLineBitPos + currTileWidth * ctx->samplesPerPixel * ctx->bitsPerSample <= bufferBitOffset)\n                {\n                    bufferLineBitPos += tileLineSize * ctx->subsamplingver * 8;\n                    bufferBitOffset = bufferLineBitPos;\n                    tileBufferLineBitPos += tileScanlineSize * ctx->subsamplingver * 8;\n                    tileBufferBitOffset = tileBufferLineBitPos;\n                }\n                if(bufferLineBitPos + tileLineSize * 8 > tileLineSize * 8 * tileHeight)\n                    break;\n            }\n        }\n\n        assert(tileLineSize * tileHeight <= buffer.size());\n        const QImage tileRgb = readFromRawBuffer(reinterpret_cast<const quint8*>(buffer.data()), tileWidth, tileHeight, tileLineSize, ctx);\n        if(tileRgb.isNull())\n            continue;\n\n        assert(IsOneOf(tileRgb.format(), QImage::Format_ARGB32, QImage::Format_RGB32));\n        for(qint64 y = 0; y < currTileHeight; ++y)\n        {\n            const QRgb *inScanLine = reinterpret_cast<const QRgb*>(tileRgb.scanLine(y));\n            QRgb *outScanLine = reinterpret_cast<QRgb*>(result.scanLine(currTileY * tileHeight + y)) + currTileX * tileWidth;\n            memcpy(outScanLine, inScanLine, static_cast<size_t>(currTileWidth * 4));\n        }\n        somethingReaded = true;\n    }\n\n    if(!somethingReaded)\n        return QImage();\n    return result;\n}\n\nQImage readTiffFileTiledSeparate(const Context *ctx, qint64 nTiles, qint64 tileWidth, qint64 tileHeight)\n{\n    assert(ctx);\n    assert(ctx->tiff);\n    assert(nTiles > 0);\n    assert(tileWidth > 0);\n    assert(tileHeight > 0);\n    LOG_DEBUG() << LOGGING_CTX << \"Tiled data with separate planes of data detected\";\n\n    if(nTiles % ctx->samplesPerPixel != 0)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Invalid tiles count,\" << nTiles << \"should be multiple of\" << ctx->samplesPerPixel;\n        return QImage();\n    }\n\n    QImage result(ctx->width, ctx->height, ctx->alphaIndex >= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n    if(result.isNull())\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n        return QImage();\n    }\n    result.fill(ctx->alphaIndex >= 0 ? Qt::transparent : Qt::white);\n\n    const qint64 bufferAllocSize = tileWidth * tileHeight * ctx->samplesPerPixel * ctx->bitsPerSample / 8;\n    if(bufferAllocSize > BUFFER_MAX_SIZE)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't allocate buffer with size =\" << bufferAllocSize << \"due to allocation limit =\" << BUFFER_MAX_SIZE;\n        return QImage();\n    }\n\n    QByteArray buffer;\n    buffer.resize(bufferAllocSize);\n\n    QByteArray tileBuffer;\n    tileBuffer.resize(tileWidth * tileHeight * ctx->bitsPerSample / 8);\n\n    const qint64 leftX = ctx->width % tileWidth;\n    const qint64 leftY = ctx->height % tileHeight;\n    const qint64 nTilesX = (ctx->width / tileWidth)   + (leftX == 0 ? 0 : 1);\n    const qint64 nTilesY = (ctx->height / tileHeight) + (leftY == 0 ? 0 : 1);\n    const qint64 tileLineBitSize = tileWidth * ctx->samplesPerPixel * ctx->bitsPerSample;\n    const qint64 tileLineSize = tileLineBitSize / 8;\n    const qint64 tilesPerSample = nTiles / ctx->samplesPerPixel;\n\n    bool somethingReaded = false;\n    for(qint64 tile = 0; tile < tilesPerSample; ++tile)\n    {\n        memset(buffer.data(), BUFFER_FILL_PATTERN, static_cast<size_t>(buffer.size()));\n        const qint64 currTileX = tile % nTilesX;\n        const qint64 currTileY = tile / nTilesX;\n        const qint64 currTileWidth  = ((currTileX == nTilesX - 1) && leftX) ? leftX : tileWidth;\n        const qint64 currTileHeight = ((currTileY == nTilesY - 1) && leftY) ? leftY : tileHeight;\n\n        for(qint64 sample = 0; sample < ctx->samplesPerPixel; ++sample)\n        {\n            memset(tileBuffer.data(), BUFFER_FILL_PATTERN, static_cast<size_t>(tileBuffer.size()));\n            const qint64 expectedTileBufferSize = tileHeight * tileWidth * ctx->bitsPerSample / 8;\n            assert(tileBuffer.size() >= expectedTileBufferSize);\n#if !defined (DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER)\n            qint64 tileBufferSize = TIFFReadEncodedTile(ctx->tiff, static_cast<quint32>(sample * tilesPerSample + tile), tileBuffer.data(), tileBuffer.size());\n#else\n            qint64 tileBufferSize = -1;\n#endif\n#if defined (DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER)\n            tileBufferSize = -1;\n#endif\n            if(tileBufferSize <= 0)\n            {\n                LOG_WARNING() << LOGGING_CTX << \"TIFFReadEncodedTile failed for tile\" << tile;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n                /// @todo LibTIFF-4.6.0: Repeated read is not supported for some compression formats (e.g. OJPEG)\n                /// So let's check current buffer, it may be already filled with all available data\n                bool bufferIsEmpty = true;\n                for(qint64 i = 0; i < tileBuffer.size() && bufferIsEmpty; ++i)\n                {\n                    if(*reinterpret_cast<quint8*>(tileBuffer.data() + i) != BUFFER_FILL_PATTERN)\n                        bufferIsEmpty = false;\n                }\n                if(bufferIsEmpty)\n                {\n                    for(qint64 row = currTileHeight; row >= 1; --row)\n                    {\n                        const qint64 newSize = TIFFReadEncodedTile(ctx->tiff, static_cast<quint32>(sample * tilesPerSample + tile), tileBuffer.data(), row * expectedTileBufferSize / tileHeight);\n                        if(newSize > 0)\n                        {\n                            LOG_DEBUG() << LOGGING_CTX << \"Recovered rows:\" << row << \"of\" << currTileHeight;\n                            tileBufferSize = std::max(expectedTileBufferSize, newSize);\n                            break;\n                        }\n                    }\n                }\n                else\n                {\n                    LOG_DEBUG() << LOGGING_CTX << \"Buffer has some data, assume recovered\";\n                    tileBufferSize = expectedTileBufferSize;\n                }\n#endif\n                if(tileBufferSize <= 0)\n                    continue;\n            }\n            if(tileBufferSize < expectedTileBufferSize)\n            {\n                LOG_WARNING() << LOGGING_CTX << \"TIFFReadEncodedTile returns not enough data to decode tile\" << tile << \"got:\" << tileBufferSize << \"expected:\" << expectedTileBufferSize;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n                tileBufferSize = expectedTileBufferSize;\n#else\n                continue;\n#endif\n            }\n\n#if !defined (DEBUG_FORCE_BIT_ACCESS)\n            if(ctx->bitsPerSample % 8 == 0)\n#else\n            if(false)\n#endif\n            {\n                for(qint64 y = 0; y < tileHeight; ++y)\n                {\n                    for(qint64 x = 0; x < tileWidth; ++x)\n                    {\n                        const qint64 bufferOffset = ((y * tileWidth + x) * ctx->samplesPerPixel + sample) * ctx->bitsPerSample / 8;\n                        const qint64 tileBufferOffset = (y * tileWidth + x) * ctx->bitsPerSample / 8;\n                        assert(bufferOffset + ctx->bitsPerSample / 8 <= buffer.size());\n                        assert(tileBufferOffset + ctx->bitsPerSample / 8 <= tileBufferSize);\n                        memcpy(buffer.data() + bufferOffset, tileBuffer.data() + tileBufferOffset, static_cast<size_t>(ctx->bitsPerSample / 8));\n                    }\n                }\n            }\n            else\n            {\n                for(qint64 y = 0; y < tileHeight; ++y)\n                {\n                    for(qint64 x = 0; x < tileWidth; ++x)\n                    {\n                        const qint64 bufferBitOffset = ((y * tileWidth + x) * ctx->samplesPerPixel + sample) * ctx->bitsPerSample;\n                        const qint64 tileBufferBitOffset = (y * tileWidth + x) * ctx->bitsPerSample;\n                        assert(bufferBitOffset + ctx->bitsPerSample <= buffer.size() * 8);\n                        assert(tileBufferBitOffset + ctx->bitsPerSample <= tileBufferSize * 8);\n                        DataProcessing::memcpyBits(buffer.data(), static_cast<quint64>(bufferBitOffset),\n                                                   tileBuffer.data(), static_cast<quint64>(tileBufferBitOffset),\n                                                   static_cast<quint64>(ctx->bitsPerSample));\n                    }\n                }\n            }\n        }\n\n        assert(tileLineSize * tileHeight <= buffer.size());\n        const QImage tileRgb = readFromRawBuffer(reinterpret_cast<const quint8*>(buffer.data()), tileWidth, tileHeight, tileLineSize, ctx);\n        if(tileRgb.isNull())\n            continue;\n\n        assert(IsOneOf(tileRgb.format(), QImage::Format_ARGB32, QImage::Format_RGB32));\n        for(qint64 y = 0; y < currTileHeight; ++y)\n        {\n            const QRgb *inScanLine = reinterpret_cast<const QRgb*>(tileRgb.scanLine(y));\n            QRgb *outScanLine = reinterpret_cast<QRgb*>(result.scanLine(currTileY * tileHeight + y)) + currTileX * tileWidth;\n            memcpy(outScanLine, inScanLine, static_cast<size_t>(currTileWidth * 4));\n        }\n        somethingReaded = true;\n    }\n\n    if(!somethingReaded)\n        return QImage();\n    return result;\n}\n\nQImage readTiffFileTiledSeparateSubsampled(const Context *ctx, qint64 nTiles, qint64 tileWidth, qint64 tileHeight)\n{\n    /// @todo No known test samples for this layout\n    assert(ctx);\n    assert(ctx->tiff);\n    assert(nTiles > 0);\n    assert(tileWidth > 0);\n    assert(tileHeight > 0);\n    LOG_DEBUG() << LOGGING_CTX << \"Tiled data with separate planes of subsampled data detected\";\n\n    if(nTiles % ctx->samplesPerPixel != 0)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Invalid tiles count,\" << nTiles << \"should be multiple of\" << ctx->samplesPerPixel;\n        return QImage();\n    }\n\n    QImage result(ctx->width, ctx->height, ctx->alphaIndex >= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n    if(result.isNull())\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n        return QImage();\n    }\n    result.fill(ctx->alphaIndex >= 0 ? Qt::transparent : Qt::white);\n\n    const qint64 bufferAllocSize = (tileWidth + 4) * (tileHeight + 4) * ctx->samplesPerPixel * ctx->bitsPerSample / 8;\n    if(bufferAllocSize > BUFFER_MAX_SIZE)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't allocate buffer with size =\" << bufferAllocSize << \"due to allocation limit =\" << BUFFER_MAX_SIZE;\n        return QImage();\n    }\n\n    QByteArray buffer;\n    buffer.resize(bufferAllocSize);\n\n    QByteArray tileBuffer;\n    tileBuffer.resize(tileWidth * tileHeight * ctx->bitsPerSample / 8);\n\n    const qint64 leftX = ctx->width % tileWidth;\n    const qint64 leftY = ctx->height % tileHeight;\n    const qint64 nTilesX = (ctx->width / tileWidth)   + (leftX == 0 ? 0 : 1);\n    const qint64 nTilesY = (ctx->height / tileHeight) + (leftY == 0 ? 0 : 1);\n    const qint64 tileLineBitSize = tileWidth * ctx->samplesPerPixel * ctx->bitsPerSample;\n    const qint64 tileLineSize = tileLineBitSize / 8;\n    const qint64 tilesPerSample = nTiles / ctx->samplesPerPixel;\n\n    bool somethingReaded = false;\n    for(qint64 tile = 0; tile < tilesPerSample; ++tile)\n    {\n        memset(buffer.data(), BUFFER_FILL_PATTERN, static_cast<size_t>(buffer.size()));\n        const qint64 currTileX = tile % nTilesX;\n        const qint64 currTileY = tile / nTilesX;\n        const qint64 currTileWidth  = ((currTileX == nTilesX - 1) && leftX) ? leftX : tileWidth;\n        const qint64 currTileHeight = ((currTileY == nTilesY - 1) && leftY) ? leftY : tileHeight;\n\n        for(qint64 sample = 0; sample < ctx->samplesPerPixel; ++sample)\n        {\n            memset(tileBuffer.data(), BUFFER_FILL_PATTERN, static_cast<size_t>(tileBuffer.size()));\n            const bool isSubsampledChroma = IsOneOf(sample, 1, 2);\n            const qint64 expectedTileBufferSize = tileHeight * tileWidth * ctx->bitsPerSample / 8 / (isSubsampledChroma ? (ctx->subsamplingver * ctx->subsamplinghor) : 1);\n#if !defined (DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER)\n            qint64 tileBufferSize = TIFFReadEncodedTile(ctx->tiff, static_cast<quint32>(sample * tilesPerSample + tile), tileBuffer.data(), tileBuffer.size());\n#else\n            qint64 tileBufferSize = -1;\n#endif\n#if defined (DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER)\n            tileBufferSize = -1;\n#endif\n            if(tileBufferSize <= 0)\n            {\n                LOG_WARNING() << LOGGING_CTX << \"TIFFReadEncodedTile failed for tile\" << tile;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n                /// @todo LibTIFF-4.6.0: Repeated read is not supported for some compression formats (e.g. OJPEG)\n                /// So let's check current buffer, it may be already filled with all available data\n                bool bufferIsEmpty = true;\n                for(qint64 i = 0; i < tileBuffer.size() && bufferIsEmpty; ++i)\n                {\n                    if(*reinterpret_cast<quint8*>(tileBuffer.data() + i) != BUFFER_FILL_PATTERN)\n                        bufferIsEmpty = false;\n                }\n                if(bufferIsEmpty)\n                {\n                    const qint64 currTileHeightSubsampled = currTileHeight / (isSubsampledChroma ? ctx->subsamplingver : 1);\n                    for(qint64 row = currTileHeightSubsampled; row >= 1; --row)\n                    {\n                        const qint64 newSize =  TIFFReadEncodedTile(ctx->tiff, static_cast<quint32>(sample * tilesPerSample + tile), tileBuffer.data(), expectedTileBufferSize * row / currTileHeightSubsampled);\n                        if(newSize > 0)\n                        {\n                            LOG_DEBUG() << LOGGING_CTX << \"Recovered rows:\" << row << \"of\" << currTileHeightSubsampled;\n                            tileBufferSize = std::max(expectedTileBufferSize, newSize);\n                            break;\n                        }\n                    }\n                }\n                else\n                {\n                    LOG_DEBUG() << LOGGING_CTX << \"Buffer has some data, assume recovered\";\n                    tileBufferSize = expectedTileBufferSize;\n                }\n#endif\n                if(tileBufferSize <= 0)\n                    continue;\n            }\n\n            if(tileBufferSize < expectedTileBufferSize)\n            {\n                LOG_WARNING() << LOGGING_CTX << \"TIFFReadEncodedTile returns not enough data to decode tile\" << tile << \"got:\" << tileBufferSize << \"expected:\" << expectedTileBufferSize;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n                tileBufferSize = expectedTileBufferSize;\n#else\n                continue;\n#endif\n            }\n\n            if(isSubsampledChroma)\n            {\n#if !defined (DEBUG_FORCE_BIT_ACCESS)\n                if(ctx->bitsPerSample % 8 == 0)\n#else\n                if(false)\n#endif\n                {\n                    for(qint64 y = 0; y < tileHeight / ctx->subsamplingver; ++y)\n                    {\n                        for(qint64 x = 0; x < tileWidth / ctx->subsamplinghor; ++x)\n                        {\n                            const qint64 tileBufferOffset = (y * tileWidth / ctx->subsamplinghor + x) * ctx->bitsPerSample / 8;\n                            assert(tileBufferOffset + ctx->bitsPerSample / 8 <= tileBufferSize);\n                            for(qint64 yu = y * ctx->subsamplingver; yu < (y + 1) * ctx->subsamplingver; ++yu)\n                            {\n                                for(qint64 xu = x * ctx->subsamplinghor; xu < (x + 1) * ctx->subsamplinghor; ++xu)\n                                {\n                                    const qint64 bufferOffset = ((yu * tileWidth + xu) * ctx->samplesPerPixel + sample) * ctx->bitsPerSample / 8;\n                                    assert(bufferOffset + ctx->bitsPerSample / 8 <= buffer.size());\n                                    memcpy(buffer.data() + bufferOffset, tileBuffer.data() + tileBufferOffset, static_cast<size_t>(ctx->bitsPerSample / 8));\n                                }\n                            }\n                        }\n                    }\n                }\n                else\n                {\n                    for(qint64 y = 0; y < tileHeight / ctx->subsamplingver; ++y)\n                    {\n                        for(qint64 x = 0; x < tileWidth / ctx->subsamplinghor; ++x)\n                        {\n                            const qint64 tileBufferBitOffset = (y * tileWidth / ctx->subsamplinghor + x) * ctx->bitsPerSample;\n                            assert(tileBufferBitOffset + ctx->bitsPerSample <= tileBufferSize * 8);\n                            for(qint64 yu = y * ctx->subsamplingver; yu < (y + 1) * ctx->subsamplingver; ++yu)\n                            {\n                                for(qint64 xu = x * ctx->subsamplinghor; xu < (x + 1) * ctx->subsamplinghor; ++xu)\n                                {\n                                    const qint64 bufferBitOffset = ((yu * tileWidth + xu) * ctx->samplesPerPixel + sample) * ctx->bitsPerSample;\n                                    assert(bufferBitOffset + ctx->bitsPerSample <= buffer.size() * 8);\n                                    DataProcessing::memcpyBits(buffer.data(), static_cast<quint64>(bufferBitOffset),\n                                                               tileBuffer.data(), static_cast<quint64>(tileBufferBitOffset),\n                                                               static_cast<quint64>(ctx->bitsPerSample));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            else\n            {\n#if !defined (DEBUG_FORCE_BIT_ACCESS)\n                if(ctx->bitsPerSample % 8 == 0)\n#else\n                if(false)\n#endif\n                {\n                    for(qint64 y = 0; y < tileHeight; ++y)\n                    {\n                        for(qint64 x = 0; x < tileWidth; ++x)\n                        {\n                            const qint64 bufferOffset = ((y * tileWidth + x) * ctx->samplesPerPixel + sample) * ctx->bitsPerSample / 8;\n                            const qint64 tileBufferOffset = (y * tileWidth + x) * ctx->bitsPerSample / 8;\n                            assert(bufferOffset + ctx->bitsPerSample / 8 <= buffer.size());\n                            assert(tileBufferOffset + ctx->bitsPerSample / 8 <= tileBufferSize);\n                            memcpy(buffer.data() + bufferOffset, tileBuffer.data() + tileBufferOffset, static_cast<size_t>(ctx->bitsPerSample / 8));\n                        }\n                    }\n                }\n                else\n                {\n                    for(qint64 y = 0; y < tileHeight; ++y)\n                    {\n                        for(qint64 x = 0; x < tileWidth; ++x)\n                        {\n                            const qint64 bufferBitOffset = ((y * tileWidth + x) * ctx->samplesPerPixel + sample) * ctx->bitsPerSample;\n                            const qint64 tileBufferBitOffset = (y * tileWidth + x) * ctx->bitsPerSample;\n                            assert(bufferBitOffset + ctx->bitsPerSample <= buffer.size() * 8);\n                            assert(tileBufferBitOffset + ctx->bitsPerSample <= tileBufferSize * 8);\n                            DataProcessing::memcpyBits(buffer.data(), static_cast<quint64>(bufferBitOffset),\n                                                       tileBuffer.data(), static_cast<quint64>(tileBufferBitOffset),\n                                                       static_cast<quint64>(ctx->bitsPerSample));\n                        }\n                    }\n                }\n            }\n        }\n\n        assert(tileLineSize * tileHeight <= buffer.size());\n        const QImage tileRgb = readFromRawBuffer(reinterpret_cast<const quint8*>(buffer.data()), tileWidth, tileHeight, tileLineSize, ctx);\n        if(tileRgb.isNull())\n            continue;\n\n        assert(IsOneOf(tileRgb.format(), QImage::Format_ARGB32, QImage::Format_RGB32));\n        for(qint64 y = 0; y < currTileHeight; ++y)\n        {\n            const QRgb *inScanLine = reinterpret_cast<const QRgb*>(tileRgb.scanLine(y));\n            QRgb *outScanLine = reinterpret_cast<QRgb*>(result.scanLine(currTileY * tileHeight + y)) + currTileX * tileWidth;\n            memcpy(outScanLine, inScanLine, static_cast<size_t>(currTileWidth * 4));\n        }\n        somethingReaded = true;\n    }\n\n    if(!somethingReaded)\n        return QImage();\n    return result;\n}\n\nQImage readTiffFileTiled(const Context *ctx)\n{\n    assert(ctx);\n    assert(ctx->tiff);\n\n    quint16 planarConfig = 0;\n    if(!TIFFGetFieldDefaulted(ctx->tiff, TIFFTAG_PLANARCONFIG, &planarConfig) || !IsOneOf(planarConfig, PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE))\n        planarConfig = PLANARCONFIG_CONTIG;\n\n    const qint64 nTiles = static_cast<qint64>(TIFFNumberOfTiles(ctx->tiff));\n    if(nTiles <= 0)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Invalid TIFFNumberOfTiles =\" << nTiles;\n        return QImage();\n    }\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFNumberOfTiles =\" << nTiles;\n\n    quint32 tileWidth = 0;\n    if(!TIFFGetFieldDefaulted(ctx->tiff, TIFFTAG_TILEWIDTH, &tileWidth) || tileWidth == 0)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't get TIFFTAG_TILEWIDTH\";\n        return QImage();\n    }\n    const qint64 tileWidth64 = static_cast<qint64>(tileWidth);\n\n    quint32 tileHeight = 0;\n    if(!TIFFGetFieldDefaulted(ctx->tiff, TIFFTAG_TILELENGTH, &tileHeight) || tileHeight == 0)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't get TIFFTAG_TILELENGTH\";\n        return QImage();\n    }\n    const qint64 tileHeight64 = static_cast<qint64>(tileHeight);\n\n    const bool isValidSubsamplingH = IsOneOf(ctx->subsamplinghor, 1, 2, 4);\n    const bool isValidSubsamplingV = IsOneOf(ctx->subsamplingver, 1, 2, 4);\n    const bool isValidSubsampledYCbCr = ctx->photometric == PHOTOMETRIC_YCBCR && ctx->primarysamplesCount == 3 && isValidSubsamplingH && isValidSubsamplingV && (ctx->subsamplinghor > 1 || ctx->subsamplingver > 1);\n\n    if(planarConfig == PLANARCONFIG_CONTIG)\n    {\n        if(isValidSubsampledYCbCr)\n            return readTiffFileTiledContigSubsampled(ctx, nTiles, tileWidth64, tileHeight64);\n        else\n            return readTiffFileTiledContig(ctx, nTiles, tileWidth64, tileHeight64);\n    }\n    else if(planarConfig == PLANARCONFIG_SEPARATE)\n    {\n        if(isValidSubsampledYCbCr)\n            return readTiffFileTiledSeparateSubsampled(ctx, nTiles, tileWidth64, tileHeight64);\n        else\n            return readTiffFileTiledSeparate(ctx, nTiles, tileWidth64, tileHeight64);\n    }\n\n    assert(false);\n    return QImage();\n}\n\n// ====================================================================================================\n\nQImage readTiffFileStripedContig(const Context *ctx, qint64 numberOfStrips, qint64 stripSize, qint64 rowsperstrip, qint64 scanlineSize, qint64 rasterScanlineSize)\n{\n    assert(ctx);\n    assert(ctx->tiff);\n    assert(numberOfStrips > 0);\n    assert(stripSize > 0);\n    assert(rowsperstrip > 0);\n    LOG_DEBUG() << LOGGING_CTX << \"Striped data with single image plane of data detected\";\n\n    if(scanlineSize != rasterScanlineSize)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Invalid scanline sizes: scanlineSize =\" << scanlineSize << \"rasterScanlineSize =\" << rasterScanlineSize;\n        return QImage();\n    }\n\n    if(scanlineSize < ctx->width * ctx->samplesPerPixel * ctx->bitsPerSample / 8)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Invalid scanline size,\" << scanlineSize << \"should be great or equal\" << ctx->width * ctx->samplesPerPixel * ctx->bitsPerSample / 8;\n        return QImage();\n    }\n\n    QImage result(ctx->width, ctx->height, ctx->alphaIndex >= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n    if(result.isNull())\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n        return QImage();\n    }\n    result.fill(ctx->alphaIndex >= 0 ? Qt::transparent : Qt::white);\n\n    const qint64 bufferAllocSize = stripSize;\n    if(bufferAllocSize > BUFFER_MAX_SIZE)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't allocate buffer with size =\" << bufferAllocSize << \"due to allocation limit =\" << BUFFER_MAX_SIZE;\n        return QImage();\n    }\n\n    QByteArray buffer;\n    buffer.resize(bufferAllocSize);\n\n    const qint64 leftRows = ctx->height % rowsperstrip;\n\n    bool somethingReaded = false;\n    for(qint64 strip = 0; strip < numberOfStrips; ++strip)\n    {\n        memset(buffer.data(), BUFFER_FILL_PATTERN, static_cast<size_t>(buffer.size()));\n        const qint64 currStripHeight = ((strip == numberOfStrips - 1) && leftRows) ? leftRows : rowsperstrip;\n        const qint64 expectedStripBufferSize = currStripHeight * rasterScanlineSize;\n        assert(bufferAllocSize >= expectedStripBufferSize);\n#if !defined (DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER)\n        qint64 stripBufferSize = TIFFReadEncodedStrip(ctx->tiff, static_cast<quint32>(strip), buffer.data(), buffer.size());\n#else\n        qint64 stripBufferSize = -1;\n#endif\n#if defined (DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER)\n        stripBufferSize = -1;\n#endif\n        if(stripBufferSize <= 0)\n        {\n            LOG_WARNING() << LOGGING_CTX << \"TIFFReadEncodedStrip failed for strip\" << strip;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n            /// @todo LibTIFF-4.6.0: Repeated read is not supported for some compression formats (e.g. OJPEG)\n            /// So let's check current buffer, it may be already filled with all available data\n            bool bufferIsEmpty = true;\n            for(qint64 i = 0; i < buffer.size() && bufferIsEmpty; ++i)\n            {\n                if(*reinterpret_cast<quint8*>(buffer.data() + i) != BUFFER_FILL_PATTERN)\n                    bufferIsEmpty = false;\n            }\n            if(bufferIsEmpty)\n            {\n                for(qint64 row = currStripHeight; row >= 1; --row)\n                {\n                    const qint64 newSize = TIFFReadEncodedStrip(ctx->tiff, static_cast<quint32>(strip), buffer.data(), row * scanlineSize);\n                    if(newSize > 0)\n                    {\n                        LOG_DEBUG() << LOGGING_CTX << \"Recovered rows:\" << row << \"of\" << currStripHeight;\n                        stripBufferSize = std::max(expectedStripBufferSize, newSize);\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                LOG_DEBUG() << LOGGING_CTX << \"Buffer has some data, assume recovered\";\n                stripBufferSize = expectedStripBufferSize;\n            }\n#endif\n            if(stripBufferSize <= 0)\n                continue;\n        }\n        if(stripBufferSize < expectedStripBufferSize)\n        {\n            LOG_WARNING() << LOGGING_CTX << \"TIFFReadEncodedStrip returns not enough data to decode strip\" << strip << \"got:\" << stripBufferSize << \"expected:\" << expectedStripBufferSize;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n            stripBufferSize = expectedStripBufferSize;\n#else\n            continue;\n#endif\n        }\n\n        assert(currStripHeight * rasterScanlineSize <= stripBufferSize);\n        const QImage stripRgb = readFromRawBuffer(reinterpret_cast<const quint8*>(buffer.data()), ctx->width, currStripHeight, rasterScanlineSize, ctx);\n        if(stripRgb.isNull())\n            continue;\n\n        assert(IsOneOf(stripRgb.format(), QImage::Format_ARGB32, QImage::Format_RGB32));\n        for(qint64 y = 0; y < currStripHeight && strip * rowsperstrip + y < ctx->height; ++y)\n        {\n            const QRgb *inScanLine = reinterpret_cast<const QRgb*>(stripRgb.scanLine(y));\n            QRgb *outScanLine = reinterpret_cast<QRgb*>(result.scanLine(strip * rowsperstrip + y));\n            memcpy(outScanLine, inScanLine, static_cast<size_t>(ctx->width * 4));\n        }\n\n        somethingReaded = true;\n    }\n\n    if(!somethingReaded)\n        return QImage();\n    return result;\n}\n\nQImage readTiffFileStripedContigSubsampled(const Context *ctx, qint64 numberOfStrips, qint64 stripSize, qint64 rowsperstrip, qint64 scanlineSize, qint64 rasterScanlineSize)\n{\n    assert(ctx);\n    assert(ctx->tiff);\n    assert(numberOfStrips > 0);\n    assert(stripSize > 0);\n    assert(rowsperstrip > 0);\n    LOG_DEBUG() << LOGGING_CTX << \"Striped data with single image plane of subsampled data detected\";\n\n    QImage result(ctx->width, ctx->height, ctx->alphaIndex >= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n    if(result.isNull())\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n        return QImage();\n    }\n    result.fill(ctx->alphaIndex >= 0 ? Qt::transparent : Qt::white);\n\n    const qint64 bufferAllocSize = rasterScanlineSize * (ctx->height + 4);\n    if(bufferAllocSize > BUFFER_MAX_SIZE)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't allocate buffer with size =\" << bufferAllocSize << \"due to allocation limit =\" << BUFFER_MAX_SIZE;\n        return QImage();\n    }\n\n    QByteArray buffer;\n    buffer.resize(bufferAllocSize);\n\n    QByteArray stripBuffer;\n    stripBuffer.resize(stripSize);\n\n    const qint64 leftRows = ctx->height % rowsperstrip;\n    const qint64 minLineBitSize = ctx->width * ctx->samplesPerPixel * ctx->bitsPerSample;\n    const qint64 minLineSize = minLineBitSize / 8;\n\n    bool somethingReaded = false;\n    for(qint64 strip = 0; strip < numberOfStrips; ++strip)\n    {\n        memset(buffer.data(), BUFFER_FILL_PATTERN, static_cast<size_t>(buffer.size()));\n        memset(stripBuffer.data(), BUFFER_FILL_PATTERN, static_cast<size_t>(stripBuffer.size()));\n        const qint64 currStripHeight = ((strip == numberOfStrips - 1) && leftRows) ? leftRows : rowsperstrip;\n        const qint64 currStripHeightAligned = currStripHeight + (currStripHeight % ctx->subsamplingver > 0 ? (ctx->subsamplingver - currStripHeight % ctx->subsamplingver) : 0);\n        const qint64 expectedStripBufferSize = currStripHeight * ctx->width * (ctx->samplesPerPixel - 2) * ctx->bitsPerSample / 8 + currStripHeight / ctx->subsamplingver * ctx->width / ctx->subsamplinghor * 2 * ctx->bitsPerSample / 8;\n        const qint64 expectedStripBufferSizeAligned = expectedStripBufferSize * currStripHeightAligned / currStripHeight;\n        assert(stripSize >= expectedStripBufferSizeAligned);\n#if !defined (DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER)\n        qint64 stripBufferSize = TIFFReadEncodedStrip(ctx->tiff, static_cast<quint32>(strip), stripBuffer.data(), stripBuffer.size());\n#else\n        qint64 stripBufferSize = -1;\n#endif\n#if defined (DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER)\n        stripBufferSize = -1;\n#endif\n        if(stripBufferSize <= 0)\n        {\n            LOG_WARNING() << LOGGING_CTX << \"TIFFReadEncodedStrip failed for strip\" << strip;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n            /// @todo LibTIFF-4.6.0: Repeated read is not supported for some compression formats (e.g. OJPEG)\n            /// So let's check current buffer, it may be already filled with all available data\n            bool bufferIsEmpty = true;\n            for(qint64 i = 0; i < stripBuffer.size() && bufferIsEmpty; ++i)\n            {\n                if(*reinterpret_cast<quint8*>(stripBuffer.data() + i) != BUFFER_FILL_PATTERN)\n                    bufferIsEmpty = false;\n            }\n            if(bufferIsEmpty)\n            {\n                for(qint64 row = currStripHeightAligned; row >= ctx->subsamplingver; row -= ctx->subsamplingver)\n                {\n                    const qint64 newSize = TIFFReadEncodedStrip(ctx->tiff, static_cast<quint32>(strip), stripBuffer.data(), row * scanlineSize);\n                    if(newSize > 0)\n                    {\n                        LOG_DEBUG() << LOGGING_CTX << \"Recovered rows:\" << row << \"of\" << currStripHeightAligned;\n                        stripBufferSize = std::max(expectedStripBufferSizeAligned, newSize);\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                LOG_DEBUG() << LOGGING_CTX << \"Buffer has some data, assume recovered\";\n                stripBufferSize = expectedStripBufferSize;\n            }\n#endif\n            if(stripBufferSize <= 0)\n                continue;\n        }\n        if(stripBufferSize < expectedStripBufferSize)\n        {\n            LOG_WARNING() << LOGGING_CTX << \"TIFFReadEncodedStrip returns not enough data to decode strip\" << strip << \"got:\" << stripBufferSize << \"expected:\" << expectedStripBufferSize;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n            stripBufferSize = expectedStripBufferSizeAligned;\n#else\n            Q_UNUSED(expectedStripBufferSizeAligned);\n            continue;\n#endif\n        }\n\n#if !defined (DEBUG_FORCE_BIT_ACCESS)\n        if(ctx->bitsPerSample % 8 == 0)\n#else\n        if(false)\n#endif\n        {\n            qint64 bufferLinePos = 0;\n            qint64 bufferOffset = bufferLinePos;\n            qint64 stripBufferLinePos = 0;\n            qint64 stripBufferOffset = stripBufferLinePos;\n\n            while(stripBufferOffset < stripBufferSize && bufferOffset < buffer.size())\n            {\n                for(qint64 c = 0; c < ctx->samplesPerPixel; ++c)\n                {\n                    const bool isChroma = IsOneOf(c, 1, 2);\n                    if(!isChroma)\n                    {\n                        for(qint64 y = 0; y < ctx->subsamplingver; ++y)\n                        {\n                            for(qint64 x = 0; x < ctx->subsamplinghor; ++x)\n                            {\n                                const qint64 bufferCurrOffset = bufferOffset + y * rasterScanlineSize + x * ctx->bitsPerSample / 8 * ctx->samplesPerPixel + c * ctx->bitsPerSample / 8;\n                                qint64 stripBufferCurrOffset = stripBufferOffset;\n                                assert(bufferCurrOffset + ctx->bitsPerSample / 8 <= buffer.size());\n                                assert(stripBufferCurrOffset + ctx->bitsPerSample / 8 <= stripBufferSize);\n                                memcpy(buffer.data() + bufferCurrOffset, stripBuffer.data() + stripBufferCurrOffset, static_cast<size_t>(ctx->bitsPerSample / 8));\n                                stripBufferOffset += ctx->bitsPerSample / 8;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        for(qint64 y = 0; y < ctx->subsamplingver; ++y)\n                        {\n                            for(qint64 x = 0; x < ctx->subsamplinghor; ++x)\n                            {\n                                const qint64 bufferCurrOffset = bufferOffset + y * rasterScanlineSize + x * ctx->bitsPerSample / 8 * ctx->samplesPerPixel + c * ctx->bitsPerSample / 8;\n                                assert(bufferCurrOffset + ctx->bitsPerSample / 8 <= buffer.size());\n                                assert(stripBufferOffset + ctx->bitsPerSample / 8 <= stripBufferSize);\n                                memcpy(buffer.data() + bufferCurrOffset, stripBuffer.data() + stripBufferOffset, static_cast<size_t>(ctx->bitsPerSample / 8));\n                            }\n                        }\n                        stripBufferOffset += ctx->bitsPerSample / 8;\n                    }\n                }\n                bufferOffset += ctx->bitsPerSample / 8 * ctx->samplesPerPixel * ctx->subsamplinghor;\n                if(bufferLinePos + minLineSize <= bufferOffset)\n                {\n                    bufferLinePos += rasterScanlineSize * ctx->subsamplingver;\n                    bufferOffset = bufferLinePos;\n                    stripBufferLinePos += scanlineSize * ctx->subsamplingver;\n                    stripBufferOffset = stripBufferLinePos;\n                }\n                if(bufferLinePos + rasterScanlineSize > rasterScanlineSize * ctx->height)\n                    break;\n            }\n        }\n        else\n        {\n            qint64 bufferLineBitPos = 0;\n            qint64 bufferBitOffset = bufferLineBitPos;\n            qint64 stripBufferLineBitPos = 0;\n            qint64 stripBufferBitOffset = stripBufferLineBitPos;\n\n            while(stripBufferBitOffset < stripBufferSize * 8 && bufferBitOffset < buffer.size() * 8)\n            {\n                for(qint64 c = 0; c < ctx->samplesPerPixel; ++c)\n                {\n                    const bool isChroma = IsOneOf(c, 1, 2);\n                    if(!isChroma)\n                    {\n                        for(qint64 y = 0; y < ctx->subsamplingver; ++y)\n                        {\n                            for(qint64 x = 0; x < ctx->subsamplinghor; ++x)\n                            {\n                                const qint64 bufferCurrBitOffset = bufferBitOffset + y * rasterScanlineSize * 8 + x * ctx->bitsPerSample * ctx->samplesPerPixel + c * ctx->bitsPerSample;\n                                qint64 stripBufferCurrBitOffset = stripBufferBitOffset;\n                                assert(bufferCurrBitOffset + ctx->bitsPerSample <= buffer.size() * 8);\n                                assert(stripBufferCurrBitOffset + ctx->bitsPerSample <= stripBufferSize * 8);\n                                DataProcessing::memcpyBits(buffer.data(), static_cast<quint64>(bufferCurrBitOffset),\n                                                           stripBuffer.data(), static_cast<quint64>(stripBufferCurrBitOffset),\n                                                           static_cast<quint64>(ctx->bitsPerSample));\n                                stripBufferBitOffset += ctx->bitsPerSample;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        for(qint64 y = 0; y < ctx->subsamplingver; ++y)\n                        {\n                            for(qint64 x = 0; x < ctx->subsamplinghor; ++x)\n                            {\n                                const qint64 bufferCurrBitOffset = bufferBitOffset + y * rasterScanlineSize * 8 + x * ctx->bitsPerSample * ctx->samplesPerPixel + c * ctx->bitsPerSample;\n                                assert(bufferCurrBitOffset + ctx->bitsPerSample <= buffer.size() * 8);\n                                assert(stripBufferBitOffset + ctx->bitsPerSample <= stripBufferSize * 8);\n                                DataProcessing::memcpyBits(buffer.data(), static_cast<quint64>(bufferCurrBitOffset),\n                                                           stripBuffer.data(), static_cast<quint64>(stripBufferBitOffset),\n                                                           static_cast<quint64>(ctx->bitsPerSample));\n                            }\n                        }\n                        stripBufferBitOffset += ctx->bitsPerSample;\n                    }\n                }\n                bufferBitOffset += ctx->bitsPerSample * ctx->samplesPerPixel * ctx->subsamplinghor;\n                if(bufferLineBitPos + minLineBitSize <= bufferBitOffset)\n                {\n                    bufferLineBitPos += rasterScanlineSize * 8 * ctx->subsamplingver;\n                    bufferBitOffset = bufferLineBitPos;\n                    stripBufferLineBitPos += scanlineSize * 8 * ctx->subsamplingver;\n                    stripBufferBitOffset = stripBufferLineBitPos;\n                }\n                if(bufferLineBitPos + rasterScanlineSize * 8 > rasterScanlineSize * 8 * ctx->height)\n                    break;\n            }\n        }\n\n        assert(currStripHeight * rasterScanlineSize <= buffer.size());\n        const QImage stripRgb = readFromRawBuffer(reinterpret_cast<const quint8*>(buffer.data()), ctx->width, currStripHeight, rasterScanlineSize, ctx);\n        if(stripRgb.isNull())\n            continue;\n\n        assert(IsOneOf(stripRgb.format(), QImage::Format_ARGB32, QImage::Format_RGB32));\n        for(qint64 y = 0; y < currStripHeight && strip * rowsperstrip + y < ctx->height; ++y)\n        {\n            const QRgb *inScanLine = reinterpret_cast<const QRgb*>(stripRgb.scanLine(y));\n            QRgb *outScanLine = reinterpret_cast<QRgb*>(result.scanLine(strip * rowsperstrip + y));\n            memcpy(outScanLine, inScanLine, static_cast<size_t>(ctx->width * 4));\n        }\n\n        somethingReaded = true;\n    }\n\n    if(!somethingReaded)\n        return QImage();\n    return result;\n}\n\nQImage readTiffFileStripedSeparate(const Context *ctx, qint64 numberOfStrips, qint64 stripSize, qint64 rowsperstrip, qint64 scanlineSize, qint64 rasterScanlineSize)\n{\n    assert(ctx);\n    assert(ctx->tiff);\n    assert(numberOfStrips > 0);\n    assert(stripSize > 0);\n    assert(rowsperstrip > 0);\n    LOG_DEBUG() << LOGGING_CTX << \"Striped data with separate planes of data detected\";\n\n    if(numberOfStrips % ctx->samplesPerPixel != 0)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Invalid strips count,\" << numberOfStrips << \"should be multiple of\" << ctx->samplesPerPixel;\n        return QImage();\n    }\n\n    if(scanlineSize < ctx->width * ctx->bitsPerSample / 8)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Invalid scanline size,\" << scanlineSize << \"should be great or equal\" << ctx->width * ctx->bitsPerSample / 8;\n        return QImage();\n    }\n\n    QImage result(ctx->width, ctx->height, ctx->alphaIndex >= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n    if(result.isNull())\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n        return QImage();\n    }\n    result.fill(ctx->alphaIndex >= 0 ? Qt::transparent : Qt::white);\n\n    const qint64 bufferAllocSize = rasterScanlineSize * (ctx->height + 4);\n    if(bufferAllocSize > BUFFER_MAX_SIZE)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't allocate buffer with size =\" << bufferAllocSize << \"due to allocation limit =\" << BUFFER_MAX_SIZE;\n        return QImage();\n    }\n\n    QByteArray buffer;\n    buffer.resize(bufferAllocSize);\n\n    QByteArray stripBuffer;\n    stripBuffer.resize(stripSize);\n\n    const qint64 leftRows = ctx->height % rowsperstrip;\n    const qint64 stripsPerSample = numberOfStrips / ctx->samplesPerPixel;\n\n    bool somethingReaded = false;\n    for(qint64 strip = 0; strip < stripsPerSample; ++strip)\n    {\n        memset(buffer.data(), BUFFER_FILL_PATTERN, static_cast<size_t>(buffer.size()));\n        const qint64 currStripHeight = ((strip == stripsPerSample - 1) && leftRows) ? leftRows : rowsperstrip;\n\n        for(qint64 sample = 0; sample < ctx->samplesPerPixel; ++sample)\n        {\n            memset(stripBuffer.data(), BUFFER_FILL_PATTERN, static_cast<size_t>(stripBuffer.size()));\n            const qint64 expectedStripBufferSize = currStripHeight * ctx->width * ctx->bitsPerSample / 8;\n            assert(stripSize >= expectedStripBufferSize);\n#if !defined (DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER)\n            qint64 stripBufferSize = TIFFReadEncodedStrip(ctx->tiff, static_cast<quint32>(sample * stripsPerSample + strip), stripBuffer.data(), stripBuffer.size());\n#else\n            qint64 stripBufferSize = -1;\n#endif\n#if defined (DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER)\n            stripBufferSize = -1;\n#endif\n            if(stripBufferSize <= 0)\n            {\n                LOG_WARNING() << LOGGING_CTX << \"TIFFReadEncodedStrip failed for strip\" << strip;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n                /// @todo LibTIFF-4.6.0: Repeated read is not supported for some compression formats (e.g. OJPEG)\n                /// So let's check current buffer, it may be already filled with all available data\n                bool bufferIsEmpty = true;\n                for(qint64 i = 0; i < stripBuffer.size() && bufferIsEmpty; ++i)\n                {\n                    if(*reinterpret_cast<quint8*>(stripBuffer.data() + i) != BUFFER_FILL_PATTERN)\n                        bufferIsEmpty = false;\n                }\n                if(bufferIsEmpty)\n                {\n                    for(qint64 row = currStripHeight; row >= 1; --row)\n                    {\n                        const qint64 newSize = TIFFReadEncodedStrip(ctx->tiff, static_cast<quint32>(sample * stripsPerSample + strip), stripBuffer.data(), row * scanlineSize);\n                        if(newSize > 0)\n                        {\n                            LOG_DEBUG() << LOGGING_CTX << \"Recovered rows:\" << row << \"of\" << currStripHeight;\n                            stripBufferSize = std::max(expectedStripBufferSize, newSize);\n                            break;\n                        }\n                    }\n                }\n                else\n                {\n                    LOG_DEBUG() << LOGGING_CTX << \"Buffer has some data, assume recovered\";\n                    stripBufferSize = expectedStripBufferSize;\n                }\n#endif\n                if(stripBufferSize <= 0)\n                    continue;\n            }\n            if(stripBufferSize < expectedStripBufferSize)\n            {\n                LOG_WARNING() << LOGGING_CTX << \"TIFFReadEncodedStrip returns not enough data to decode strip\" << strip << \"got:\" << stripBufferSize << \"expected:\" << expectedStripBufferSize;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n                stripBufferSize = expectedStripBufferSize;\n#else\n                Q_UNUSED(expectedStripBufferSize);\n                continue;\n#endif\n            }\n\n#if !defined (DEBUG_FORCE_BIT_ACCESS)\n            if(ctx->bitsPerSample % 8 == 0)\n#else\n            if(false)\n#endif\n            {\n                for(qint64 y = 0; y < currStripHeight; ++y)\n                {\n                    for(qint64 x = 0; x < ctx->width; ++x)\n                    {\n                        const qint64 bufferOffset = y * rasterScanlineSize + (x * ctx->samplesPerPixel + sample) * ctx->bitsPerSample / 8;\n                        const qint64 stripBufferOffset = y * scanlineSize + x * ctx->bitsPerSample / 8;\n                        assert(bufferOffset + ctx->bitsPerSample / 8 <= buffer.size());\n                        assert(stripBufferOffset + ctx->bitsPerSample / 8 <= stripBufferSize);\n                        memcpy(buffer.data() + bufferOffset, stripBuffer.data() + stripBufferOffset, static_cast<size_t>(ctx->bitsPerSample / 8));\n                    }\n                }\n            }\n            else\n            {\n                for(qint64 y = 0; y < currStripHeight; ++y)\n                {\n                    for(qint64 x = 0; x < ctx->width; ++x)\n                    {\n                        const qint64 bufferBitOffset = y * rasterScanlineSize * 8 + (x * ctx->samplesPerPixel + sample) * ctx->bitsPerSample;\n                        const qint64 stripBufferBitOffset = y * scanlineSize * 8 + x * ctx->bitsPerSample;\n                        assert(bufferBitOffset + ctx->bitsPerSample <= buffer.size() * 8);\n                        assert(stripBufferBitOffset + ctx->bitsPerSample <= stripBufferSize * 8);\n                        DataProcessing::memcpyBits(buffer.data(), static_cast<quint64>(bufferBitOffset),\n                                                   stripBuffer.data(), static_cast<quint64>(stripBufferBitOffset),\n                                                   static_cast<quint64>(ctx->bitsPerSample));\n                    }\n                }\n            }\n        }\n\n        assert(currStripHeight * rasterScanlineSize <= buffer.size());\n        const QImage stripRgb = readFromRawBuffer(reinterpret_cast<const quint8*>(buffer.data()), ctx->width, currStripHeight, rasterScanlineSize, ctx);\n        if(stripRgb.isNull())\n            continue;\n\n        assert(IsOneOf(stripRgb.format(), QImage::Format_ARGB32, QImage::Format_RGB32));\n        for(qint64 y = 0; y < currStripHeight && strip * rowsperstrip + y < ctx->height; ++y)\n        {\n            const QRgb *inScanLine = reinterpret_cast<const QRgb*>(stripRgb.scanLine(y));\n            QRgb *outScanLine = reinterpret_cast<QRgb*>(result.scanLine(strip * rowsperstrip + y));\n            memcpy(outScanLine, inScanLine, static_cast<size_t>(ctx->width * 4));\n        }\n\n        somethingReaded = true;\n    }\n\n    if(!somethingReaded)\n        return QImage();\n    return result;\n}\n\nQImage readTiffFileStripedSeparateSubsampled(const Context *ctx, qint64 numberOfStrips, qint64 stripSize, qint64 rowsperstrip, qint64 scanlineSize, qint64 rasterScanlineSize)\n{\n    assert(ctx);\n    assert(ctx->tiff);\n    assert(numberOfStrips > 0);\n    assert(stripSize > 0);\n    assert(rowsperstrip > 0);\n    LOG_DEBUG() << LOGGING_CTX << \"Striped data with separate planes of subsampled data detected\";\n\n    if(numberOfStrips % ctx->samplesPerPixel != 0)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Invalid strips count,\" << numberOfStrips << \"should be multiple of\" << ctx->samplesPerPixel;\n        return QImage();\n    }\n\n    QImage result(ctx->width, ctx->height, ctx->alphaIndex >= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n    if(result.isNull())\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n        return QImage();\n    }\n    result.fill(ctx->alphaIndex >= 0 ? Qt::transparent : Qt::white);\n\n    const qint64 bufferAllocSize = rasterScanlineSize * (ctx->height + 4);\n    if(bufferAllocSize > BUFFER_MAX_SIZE)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't allocate buffer with size =\" << bufferAllocSize << \"due to allocation limit =\" << BUFFER_MAX_SIZE;\n        return QImage();\n    }\n\n    QByteArray buffer;\n    buffer.resize(bufferAllocSize);\n\n    QByteArray stripBuffer;\n    stripBuffer.resize(stripSize);\n\n    const qint64 leftRows = ctx->height % rowsperstrip;\n    const qint64 stripsPerSample = numberOfStrips / ctx->samplesPerPixel;\n\n    bool somethingReaded = false;\n    for(qint64 strip = 0; strip < stripsPerSample; ++strip)\n    {\n        memset(buffer.data(), BUFFER_FILL_PATTERN, static_cast<size_t>(buffer.size()));\n        const qint64 currStripHeight = ((strip == stripsPerSample - 1) && leftRows) ? leftRows : rowsperstrip;\n\n        for(qint64 sample = 0; sample < ctx->samplesPerPixel; ++sample)\n        {\n            memset(stripBuffer.data(), BUFFER_FILL_PATTERN, static_cast<size_t>(stripBuffer.size()));\n            /// @todo LibTIFF-4.6.0: TIFFReadEncodedStrip can't handle subsampled YCbCr strips\n            /// directly for PLANARCONFIG_SEPARATE. Error example: \"TIFFReadEncodedStrip: Read\n            /// error at scanline 4294967295; got 8540 bytes, expected 16384.\". So we will try\n            /// to read strip with reduced buffer size\n            const bool isSubsampledChroma = IsOneOf(sample, 1, 2);\n            const qint64 expectedStripBufferSize = currStripHeight * ctx->width * ctx->bitsPerSample / 8 / (isSubsampledChroma ? (ctx->subsamplingver * ctx->subsamplinghor) : 1);\n            assert(stripSize >= expectedStripBufferSize);\n#if !defined (DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER)\n            qint64 stripBufferSize = TIFFReadEncodedStrip(ctx->tiff, static_cast<quint32>(sample * stripsPerSample + strip), stripBuffer.data(), expectedStripBufferSize);\n#else\n            qint64 stripBufferSize = -1;\n#endif\n#if defined (DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER)\n            stripBufferSize = -1;\n#endif\n            if(stripBufferSize <= 0)\n            {\n                LOG_WARNING() << LOGGING_CTX << \"TIFFReadEncodedStrip failed for strip\" << strip;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n                /// @todo LibTIFF-4.6.0: Repeated read is not supported for some compression formats (e.g. OJPEG)\n                /// So let's check current buffer, it may be already filled with all available data\n                bool bufferIsEmpty = true;\n                for(qint64 i = 0; i < stripBuffer.size() && bufferIsEmpty; ++i)\n                {\n                    if(*reinterpret_cast<quint8*>(stripBuffer.data() + i) != BUFFER_FILL_PATTERN)\n                        bufferIsEmpty = false;\n                }\n                if(bufferIsEmpty)\n                {\n                    const qint64 currStripHeightSubsampled = currStripHeight / (isSubsampledChroma ? ctx->subsamplingver : 1);\n                    for(qint64 row = currStripHeightSubsampled; row >= 1; --row)\n                    {\n                        const qint64 newSize = TIFFReadEncodedStrip(ctx->tiff, static_cast<quint32>(sample * stripsPerSample + strip), stripBuffer.data(), expectedStripBufferSize * row / currStripHeightSubsampled);\n                        if(newSize > 0)\n                        {\n                            LOG_DEBUG() << LOGGING_CTX << \"Recovered rows:\" << row << \"of\" << currStripHeightSubsampled;\n                            stripBufferSize = std::max(expectedStripBufferSize, newSize);\n                            break;\n                        }\n                    }\n                }\n                else\n                {\n                    LOG_DEBUG() << LOGGING_CTX << \"Buffer has some data, assume recovered\";\n                    stripBufferSize = expectedStripBufferSize;\n                }\n#endif\n                if(stripBufferSize <= 0)\n                    continue;\n            }\n\n            if(stripBufferSize < expectedStripBufferSize)\n            {\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n                stripBufferSize = expectedStripBufferSize;\n#else\n                Q_UNUSED(expectedStripBufferSize);\n                continue;\n#endif\n            }\n\n            if(isSubsampledChroma)\n            {\n#if !defined (DEBUG_FORCE_BIT_ACCESS)\n                if(ctx->bitsPerSample % 8 == 0)\n#else\n                if(false)\n#endif\n                {\n                    for(qint64 y = 0; y < currStripHeight / ctx->subsamplingver; ++y)\n                    {\n                        for(qint64 x = 0; x < ctx->width / ctx->subsamplinghor; ++x)\n                        {\n                            const qint64 stripBufferOffset = y * scanlineSize / ctx->subsamplinghor + x * ctx->bitsPerSample / 8;\n                            // const qint64 stripBufferOffset = (y * ctx->width / ctx->subsamplinghor + x) * ctx->bitsPerSample / 8;\n                            assert(stripBufferOffset + ctx->bitsPerSample / 8 <= stripBufferSize);\n                            for(qint64 yu = y * ctx->subsamplingver; yu < (y + 1) * ctx->subsamplingver; ++yu)\n                            {\n                                for(qint64 xu = x * ctx->subsamplinghor; xu < (x + 1) * ctx->subsamplinghor; ++xu)\n                                {\n                                    const qint64 bufferOffset = yu * rasterScanlineSize + (xu * ctx->samplesPerPixel + sample) * ctx->bitsPerSample / 8;\n                                    // const qint64 bufferOffset = ((yu * ctx->width + xu) * ctx->samplesPerPixel + sample) * ctx->bitsPerSample / 8;\n                                    assert(bufferOffset + ctx->bitsPerSample / 8 <= buffer.size());\n                                    memcpy(buffer.data() + bufferOffset, stripBuffer.data() + stripBufferOffset, static_cast<size_t>(ctx->bitsPerSample / 8));\n                                }\n                            }\n                        }\n                    }\n                }\n                else\n                {\n                    for(qint64 y = 0; y < currStripHeight / ctx->subsamplingver; ++y)\n                    {\n                        for(qint64 x = 0; x < ctx->width / ctx->subsamplinghor; ++x)\n                        {\n                            const qint64 stripBufferBitOffset = y * scanlineSize / ctx->subsamplinghor * 8 + x * ctx->bitsPerSample;\n                            // const qint64 stripBufferBitOffset = (y * ctx->width / ctx->subsamplinghor + x) * ctx->bitsPerSample;\n                            assert(stripBufferBitOffset + ctx->bitsPerSample <= stripBufferSize * 8);\n                            for(qint64 yu = y * ctx->subsamplingver; yu < (y + 1) * ctx->subsamplingver; ++yu)\n                            {\n                                for(qint64 xu = x * ctx->subsamplinghor; xu < (x + 1) * ctx->subsamplinghor; ++xu)\n                                {\n                                    const qint64 bufferBitOffset = yu * rasterScanlineSize * 8 + (xu * ctx->samplesPerPixel + sample) * ctx->bitsPerSample;\n                                    // const qint64 bufferBitOffset = ((yu * ctx->width + xu) * ctx->samplesPerPixel + sample) * ctx->bitsPerSample;\n                                    assert(bufferBitOffset + ctx->bitsPerSample <= buffer.size() * 8);\n                                    DataProcessing::memcpyBits(buffer.data(), static_cast<quint64>(bufferBitOffset),\n                                                               stripBuffer.data(), static_cast<quint64>(stripBufferBitOffset),\n                                                               static_cast<quint64>(ctx->bitsPerSample));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            else\n            {\n#if !defined (DEBUG_FORCE_BIT_ACCESS)\n                if(ctx->bitsPerSample % 8 == 0)\n#else\n                if(false)\n#endif\n                {\n                    for(qint64 y = 0; y < currStripHeight; ++y)\n                    {\n                        for(qint64 x = 0; x < ctx->width; ++x)\n                        {\n                            const qint64 bufferOffset = y * rasterScanlineSize + (x * ctx->samplesPerPixel + sample) * ctx->bitsPerSample / 8;\n                            const qint64 stripBufferOffset = y * scanlineSize + x * ctx->bitsPerSample / 8;\n                            // const qint64 bufferOffset = ((y * ctx->width + x) * ctx->samplesPerPixel + sample) * ctx->bitsPerSample / 8;\n                            // const qint64 stripBufferOffset = (y * ctx->width + x) * ctx->bitsPerSample / 8;\n                            assert(bufferOffset + ctx->bitsPerSample / 8 <= buffer.size());\n                            assert(stripBufferOffset + ctx->bitsPerSample / 8 <= stripBufferSize);\n                            memcpy(buffer.data() + bufferOffset, stripBuffer.data() + stripBufferOffset, static_cast<size_t>(ctx->bitsPerSample / 8));\n                        }\n                    }\n                }\n                else\n                {\n                    for(qint64 y = 0; y < currStripHeight; ++y)\n                    {\n                        for(qint64 x = 0; x < ctx->width; ++x)\n                        {\n                            const qint64 bufferBitOffset = y * rasterScanlineSize * 8 + (x * ctx->samplesPerPixel + sample) * ctx->bitsPerSample;\n                            const qint64 stripBufferBitOffset = y * scanlineSize * 8 + x * ctx->bitsPerSample;\n                            // const qint64 bufferBitOffset = ((y * ctx->width + x) * ctx->samplesPerPixel + sample) * ctx->bitsPerSample;\n                            // const qint64 stripBufferBitOffset = (y * ctx->width + x) * ctx->bitsPerSample;\n                            assert(bufferBitOffset + ctx->bitsPerSample <= buffer.size() * 8);\n                            assert(stripBufferBitOffset + ctx->bitsPerSample <= stripBufferSize * 8);\n                            DataProcessing::memcpyBits(buffer.data(), static_cast<quint64>(bufferBitOffset),\n                                                       stripBuffer.data(), static_cast<quint64>(stripBufferBitOffset),\n                                                       static_cast<quint64>(ctx->bitsPerSample));\n                        }\n                    }\n                }\n            }\n        }\n\n        assert(currStripHeight * rasterScanlineSize <= buffer.size());\n        const QImage stripRgb = readFromRawBuffer(reinterpret_cast<const quint8*>(buffer.data()), ctx->width, currStripHeight, rasterScanlineSize, ctx);\n        if(stripRgb.isNull())\n            continue;\n\n        assert(IsOneOf(stripRgb.format(), QImage::Format_ARGB32, QImage::Format_RGB32));\n        for(qint64 y = 0; y < currStripHeight && strip * rowsperstrip + y < ctx->height; ++y)\n        {\n            const QRgb *inScanLine = reinterpret_cast<const QRgb*>(stripRgb.scanLine(y));\n            QRgb *outScanLine = reinterpret_cast<QRgb*>(result.scanLine(strip * rowsperstrip + y));\n            memcpy(outScanLine, inScanLine, static_cast<size_t>(ctx->width * 4));\n        }\n\n        somethingReaded = true;\n    }\n\n    if(!somethingReaded)\n        return QImage();\n    return result;\n}\n\nQImage readTiffFileStriped(const Context *ctx)\n{\n    assert(ctx);\n    assert(ctx->tiff);\n\n    quint16 planarConfig = 0;\n    if(!TIFFGetFieldDefaulted(ctx->tiff, TIFFTAG_PLANARCONFIG, &planarConfig) || !IsOneOf(planarConfig, PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE))\n        planarConfig = PLANARCONFIG_CONTIG;\n\n    quint32 rowsperstrip = 0;\n    if(!TIFFGetFieldDefaulted(ctx->tiff, TIFFTAG_ROWSPERSTRIP, &rowsperstrip) || rowsperstrip <= 0)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't get TIFFTAG_ROWSPERSTRIP\";\n        return QImage();\n    }\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_ROWSPERSTRIP =\" << rowsperstrip;\n\n    const qint64 scanlineSize = static_cast<qint64>(TIFFScanlineSize(ctx->tiff));\n    const qint64 rasterScanlineSize = static_cast<qint64>(TIFFRasterScanlineSize(ctx->tiff));\n    const qint64 rowsperstrip64 = static_cast<qint64>(rowsperstrip);\n    const qint64 numberOfStrips = static_cast<qint64>(TIFFNumberOfStrips(ctx->tiff));\n    const qint64 stripSize = static_cast<qint64>(TIFFStripSize(ctx->tiff));\n\n    const bool isValidSubsamplingH = IsOneOf(ctx->subsamplinghor, 1, 2, 4);\n    const bool isValidSubsamplingV = IsOneOf(ctx->subsamplingver, 1, 2, 4);\n    const bool isValidSubsampledYCbCr = ctx->photometric == PHOTOMETRIC_YCBCR && ctx->primarysamplesCount == 3 && isValidSubsamplingH && isValidSubsamplingV && (ctx->subsamplinghor > 1 || ctx->subsamplingver > 1);\n\n    if(planarConfig == PLANARCONFIG_CONTIG)\n    {\n        if(isValidSubsampledYCbCr)\n            return readTiffFileStripedContigSubsampled(ctx, numberOfStrips, stripSize, rowsperstrip64, scanlineSize, rasterScanlineSize);\n        else\n            return readTiffFileStripedContig(ctx, numberOfStrips, stripSize, rowsperstrip64, scanlineSize, rasterScanlineSize);\n    }\n    else if(planarConfig == PLANARCONFIG_SEPARATE)\n    {\n        if(isValidSubsampledYCbCr)\n            return readTiffFileStripedSeparateSubsampled(ctx, numberOfStrips, stripSize, rowsperstrip64, scanlineSize, rasterScanlineSize);\n        else\n            return readTiffFileStripedSeparate(ctx, numberOfStrips, stripSize, rowsperstrip64, scanlineSize, rasterScanlineSize);\n    }\n\n    assert(false);\n    return QImage();\n}\n\n// ====================================================================================================\n\nPayloadWithMetaData<QImage> readTiffFile(const QString &filename)\n{\n    QFile inFile(filename);\n    if(!inFile.open(QIODevice::ReadOnly))\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't open\" << filename;\n        return QImage();\n    }\n\n#if defined (TIFFLIB_VERSION) && (TIFFLIB_VERSION >= 20221213) && (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))\n    TIFFOpenOptions *opts = TIFFOpenOptionsAlloc();\n    TIFFOpenOptionsSetErrorHandlerExtR(opts, errorHandlerProc, Q_NULLPTR);\n    TIFFOpenOptionsSetWarningHandlerExtR(opts, &warningHandlerProc, Q_NULLPTR);\n    TIFF *tiff = TIFFClientOpenExt(\"DecoderLibTiff\", \"r\", &inFile, readProc, writeProc, seekProc, closeProc, sizeProc, mapProc, unmapProc, opts);\n    TIFFOpenOptionsFree(opts);\n#else\n    TIFF *tiff = TIFFClientOpen(\"DecoderLibTiff\", \"r\", &inFile, readProc, writeProc, seekProc, closeProc, sizeProc, mapProc, unmapProc);\n#endif\n    if(!tiff)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't TIFFClientOpen for\" << filename;\n        return QImage();\n    }\n\n    if(!TIFFSetDirectory(tiff, 0))\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't TIFFSetDirectory for\" << filename;\n        TIFFClose(tiff);\n        return QImage();\n    }\n\n    quint32 width = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_IMAGEWIDTH, &width) || width <= 0)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't get TIFFTAG_IMAGEWIDTH for\" << filename;\n        TIFFClose(tiff);\n        return QImage();\n    }\n\n    quint32 height = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_IMAGELENGTH, &height) || height <= 0)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't get TIFFTAG_IMAGELENGTH for\" << filename;\n        TIFFClose(tiff);\n        return QImage();\n    }\n\n    quint16 compression = 0;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_COMPRESSION, &compression);\n\n    /// @todo LibTIFF-4.6.0: Looks like samples layout for subsampled YCbCr data\n    /// for JPEG compression is differ from samples layout for other compression\n    /// types. So we will enforce built-in YCbCr to RGB converter. Despite tag\n    /// name, non-YCbCr colorspaces like CMYK or RGB are not affected\n    if(compression == COMPRESSION_JPEG)\n        TIFFSetField(tiff, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\n    quint16 samplesPerPixel = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel) || samplesPerPixel <= 0)\n        samplesPerPixel = 1;\n\n    int alphaIndex = -1;\n    quint16 extrasamplesCount = 0;\n    const quint16 *extrasamples = Q_NULLPTR;\n    if(TIFFGetFieldDefaulted(tiff, TIFFTAG_EXTRASAMPLES, &extrasamplesCount, &extrasamples))\n    {\n        for(quint16 i = 0; i < extrasamplesCount && alphaIndex < 0; ++i)\n        {\n            if(extrasamples[i] == EXTRASAMPLE_ASSOCALPHA)\n                alphaIndex = static_cast<int>(i);\n        }\n        for(quint16 i = 0; i < extrasamplesCount && alphaIndex < 0; ++i)\n        {\n            if(extrasamples[i] == EXTRASAMPLE_UNASSALPHA)\n                alphaIndex = static_cast<int>(i);\n        }\n    }\n    const quint16 primarysamplesCount = samplesPerPixel > extrasamplesCount ? samplesPerPixel - extrasamplesCount : 0;\n\n    quint16 photometric = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_PHOTOMETRIC, &photometric))\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't get TIFFTAG_PHOTOMETRIC for\" << filename;\n        if(primarysamplesCount == 1)\n        {\n            photometric = PHOTOMETRIC_MINISWHITE;\n            LOG_WARNING() << LOGGING_CTX << \"Assuming PHOTOMETRIC_MINISWHITE\";\n        }\n        else if(primarysamplesCount == 3)\n        {\n            photometric = PHOTOMETRIC_RGB;\n            LOG_WARNING() << LOGGING_CTX << \"Assuming PHOTOMETRIC_RGB\";\n        }\n        else\n        {\n            TIFFClose(tiff);\n            return QImage();\n        }\n    }\n\n    /// @note Enable converting PHOTOMETRIC_LOGL and PHOTOMETRIC_LOGLUV to 8 bit\n    /// RGB and grayscale values respective\n    if(IsOneOf(photometric, PHOTOMETRIC_LOGL, PHOTOMETRIC_LOGLUV))\n        TIFFSetField(tiff, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n\n    quint16 orientation = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_ORIENTATION, &orientation) || orientation <= 0)\n        orientation = ORIENTATION_TOPLEFT;\n\n    quint16 bitsPerSample = 0;\n    if(!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample) || bitsPerSample <= 0)\n        bitsPerSample = 1;\n\n    quint16 sampleFormat = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat) || sampleFormat <= 0)\n        sampleFormat = SAMPLEFORMAT_VOID;\n\n    quint16 inkSet = 0;\n    if(photometric == PHOTOMETRIC_SEPARATED)\n    {\n        if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_INKSET, &inkSet) || inkSet <= 0)\n            inkSet = INKSET_CMYK;\n    }\n\n    quint16 planarConfig = 0;\n    TIFFGetField(tiff, TIFFTAG_PLANARCONFIG, &planarConfig);\n\n    const float *ycbcrcoeffs = Q_NULLPTR;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_YCBCRCOEFFICIENTS, &ycbcrcoeffs);\n\n    quint16 subsamplinghor = 0, subsamplingver = 0;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver);\n\n    quint16 ycbcrpositioning = 0;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_YCBCRPOSITIONING, &ycbcrpositioning);\n\n    const quint16 *redTable = Q_NULLPTR;\n    const quint16 *greenTable = Q_NULLPTR;\n    const quint16 *blueTable = Q_NULLPTR;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_COLORMAP, &redTable, &greenTable, &blueTable);\n\n    QScopedPointer<ICCProfile> iccProfile(readICCProfile(tiff));\n    if((!iccProfile || !iccProfile->isValid()) && photometric == PHOTOMETRIC_SEPARATED && inkSet == INKSET_CMYK)\n        iccProfile.reset(new ICCProfile(ICCProfile::defaultCmykProfileData()));\n\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_IMAGEWIDTH =\" << width;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_IMAGELENGTH =\" << height;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_PHOTOMETRIC =\" << photometricToString(photometric).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_INKSET =\" << inkSetToString(inkSet).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_ORIENTATION =\" << orientationToString(orientation).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_BITSPERSAMPLE =\" << bitsPerSample;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_SAMPLESPERPIXEL =\" << samplesPerPixel;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_SAMPLEFORMAT =\" << sampleFormatToString(sampleFormat).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_EXTRASAMPLES =\" << extrasamplesToString(extrasamplesCount, extrasamples).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_PLANARCONFIG =\" << planarConfigToString(planarConfig).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_COMPRESSION =\" << compressionToString(compression).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_YCBCRSUBSAMPLING =\" << subsamplinghor << subsamplingver;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_YCBCRPOSITIONING =\" << ycbcrpositioningToString(ycbcrpositioning).toLatin1().data();\n\n    const bool isSupportedInt = IsOneOf(sampleFormat, SAMPLEFORMAT_UINT, SAMPLEFORMAT_VOID, SAMPLEFORMAT_INT) && bitsPerSample <= 64;\n    const bool isSupportedFp = sampleFormat == SAMPLEFORMAT_IEEEFP && IsOneOf(bitsPerSample, 16, 24, 32, 64);\n    bool isReadingSupported = false;\n    switch(photometric)\n    {\n    case PHOTOMETRIC_MINISWHITE:\n    case PHOTOMETRIC_MINISBLACK:\n    case PHOTOMETRIC_LOGL:\n        isReadingSupported = (isSupportedInt || isSupportedFp) && primarysamplesCount >= 1;\n        break;\n    case PHOTOMETRIC_RGB:\n    case PHOTOMETRIC_YCBCR:\n    case PHOTOMETRIC_LOGLUV:\n        isReadingSupported = (isSupportedInt || isSupportedFp) && primarysamplesCount >= 3;\n        break;\n    case PHOTOMETRIC_SEPARATED:\n        isReadingSupported = (isSupportedInt || isSupportedFp) && primarysamplesCount >= 4;\n        break;\n    case PHOTOMETRIC_CIELAB:\n    case PHOTOMETRIC_ICCLAB:\n    case PHOTOMETRIC_ITULAB:\n        isReadingSupported = (isSupportedInt || isSupportedFp) && primarysamplesCount >= 1;\n        break;\n    case PHOTOMETRIC_PALETTE:\n        isReadingSupported = redTable && greenTable && blueTable && bitsPerSample <= 16 && primarysamplesCount >= 1;\n        break;\n    // case PHOTOMETRIC_MASK:\n    // case PHOTOMETRIC_CFA:\n    default:\n        break;\n    }\n\n    QImage result;\n    if(isReadingSupported)\n    {\n        Context ctx;\n        memset(&ctx, 0, sizeof(ctx));\n        ctx.tiff = tiff;\n        ctx.width = static_cast<qint64>(width);\n        ctx.height = static_cast<qint64>(height);\n        ctx.compression = compression;\n        ctx.photometric = compression == COMPRESSION_JPEG && photometric == PHOTOMETRIC_YCBCR ? PHOTOMETRIC_RGB : photometric;\n        ctx.samplesPerPixel = static_cast<qint64>(samplesPerPixel);\n        ctx.bitsPerSample = static_cast<qint64>(bitsPerSample);\n        ctx.sampleFormat = sampleFormat;\n        ctx.inkSet = inkSet;\n        ctx.iccProfile = iccProfile.data();\n        ctx.ycbcrcoeffs = ycbcrcoeffs;\n        ctx.subsamplinghor = static_cast<qint64>(subsamplinghor);\n        ctx.subsamplingver = static_cast<qint64>(subsamplingver);\n        ctx.ycbcrpositioning = ycbcrpositioning;\n        ctx.extrasamplesCount = static_cast<qint64>(extrasamplesCount);\n        ctx.primarysamplesCount = static_cast<qint64>(primarysamplesCount);\n        ctx.alphaIndex = alphaIndex;\n        ctx.alphaPremultiplied = alphaIndex >= 0 ? extrasamples[alphaIndex] == EXTRASAMPLE_ASSOCALPHA : false;\n        ctx.redTable = redTable;\n        ctx.greenTable = greenTable;\n        ctx.blueTable = blueTable;\n        ctx.colorTablesIs16Bit = false;\n\n        if(photometric == PHOTOMETRIC_PALETTE && redTable && greenTable && blueTable)\n        {\n            /// @note See buildMap and checkcmap in tif_getimage.c\n            for(quint64 i = 0, count = (1ull << bitsPerSample); i < count && !ctx.colorTablesIs16Bit; ++i)\n                if(redTable[i] >= 256 || greenTable[i] >= 256 || blueTable[i] >= 256)\n                    ctx.colorTablesIs16Bit = true;\n        }\n\n        if(TIFFIsTiled(tiff))\n            result = readTiffFileTiled(&ctx);\n        else\n            result = readTiffFileStriped(&ctx);\n    }\n\n    /// @todo LibTIFF-4.6.0: TIFFRGBA* has bad errors handling and reports OK\n    /// sometimes even if no data was decoded. So we will disable it for all\n    /// supported formats\n    if(result.isNull() && !isReadingSupported)\n    {\n        TIFFRGBAImage img;\n        char emsg[1024];\n        if(!TIFFRGBAImageBegin(&img, tiff, 0, emsg))\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Can't TIFFRGBAImageBegin for\" << filename;\n            LOG_WARNING() << LOGGING_CTX << \"Reason:\" << emsg;\n            TIFFClose(tiff);\n            return QImage();\n        }\n\n        result = QImage(static_cast<int>(img.width), static_cast<int>(img.height),\n#if (USE_RGBA_8888)\n                      QImage::Format_RGBA8888);\n#else\n                      QImage::Format_ARGB32);\n#endif\n        if(result.isNull())\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n            TIFFClose(tiff);\n            return QImage();\n        }\n\n        img.req_orientation = img.orientation;\n\n#if defined (TIFFLIB_VERSION) && (TIFFLIB_VERSION >= 20210416)\n        typedef uint32_t TiffImageBitsType;\n#else\n        typedef uint32 TiffImageBitsType;\n#endif\n\n        if(!TIFFRGBAImageGet(&img, reinterpret_cast<TiffImageBitsType*>(result.bits()), img.width, img.height))\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Can't TIFFRGBAImageGet for\" << filename;\n            TIFFClose(tiff);\n            return QImage();\n        }\n\n#if (!USE_RGBA_8888)\n        QImage_rgbSwap(result);\n#endif\n\n#undef USE_RGBA_8888\n\n        TIFFRGBAImageEnd(&img);\n\n        if(iccProfile)\n            iccProfile->applyToImage(&result);\n    }\n\n    // Some image formats can't be rendered successfully\n    if(!IsOneOf(result.format(), QImage::Format_RGB32, QImage::Format_ARGB32))\n        QImage_convertTo(result, result.hasAlphaChannel() ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n\n    ImageMetaData *metaData = ImageMetaData::createMetaData(filename);\n    if(!metaData)\n        metaData = readExifMetaData(tiff);\n    if(!metaData)\n        metaData = new ImageMetaData;\n\n    metaData->addCustomOrientation(orientation);\n    metaData->applyExifOrientation(&result);\n\n    quint16 resUnit = 0;\n    if(!TIFFGetField(tiff, TIFFTAG_RESOLUTIONUNIT, &resUnit))\n        resUnit = RESUNIT_INCH;\n    float resX = 0.0f, resY = 0.0f;\n    if(TIFFGetField(tiff, TIFFTAG_XRESOLUTION, &resX) && TIFFGetField(tiff, TIFFTAG_YRESOLUTION, &resY))\n    {\n        if(resUnit == RESUNIT_CENTIMETER)\n            metaData->addCustomDpi(static_cast<qreal>(resX * 2.54f), static_cast<qreal>(resY * 2.54f));\n        else if(resUnit == RESUNIT_INCH)\n            metaData->addCustomDpi(static_cast<qreal>(resX), static_cast<qreal>(resY));\n    }\n\n    TIFFClose(tiff);\n\n    return PayloadWithMetaData<QImage>(result, metaData);\n}\n\n// ====================================================================================================\n\nclass DecoderLibTiff : public IDecoder\n{\npublic:\n    QString name() const Q_DECL_OVERRIDE\n    {\n        return QString::fromLatin1(\"DecoderLibTiff\");\n    }\n\n    QStringList supportedFormats() const Q_DECL_OVERRIDE\n    {\n        return QStringList()\n                << QString::fromLatin1(\"tif\")\n                << QString::fromLatin1(\"tiff\");\n    }\n\n    QStringList advancedFormats() const Q_DECL_OVERRIDE\n    {\n        return QStringList();\n    }\n\n    bool isAvailable() const Q_DECL_OVERRIDE\n    {\n        return true;\n    }\n\n    QSharedPointer<IImageData> loadImage(const QString &filePath) Q_DECL_OVERRIDE\n    {\n        const QFileInfo fileInfo(filePath);\n        if(!fileInfo.exists() || !fileInfo.isReadable())\n            return QSharedPointer<IImageData>();\n        const PayloadWithMetaData<QImage> readData = readTiffFile(filePath);\n        QGraphicsItem *item = GraphicsItemsFactory::instance().createImageItem(readData);\n        return QSharedPointer<IImageData>(new ImageData(item, filePath, name(), readData.metaData()));\n    }\n};\n\nDecoderAutoRegistrator registrator(new DecoderLibTiff);\n\n// ====================================================================================================\n\n} // namespace\n",
                "name": "DecoderLibTiff.cpp",
                "path": "src/ImageViewer/src/Decoders/Impl/DecoderLibTiff.cpp",
                "url": "/github.com/AlienCowEatCake/ImageViewer/-/blob/src/ImageViewer/src/Decoders/Impl/DecoderLibTiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 3208,
                    "offsetAndLengths": [
                        [
                            12,
                            16
                        ]
                    ],
                    "preview": "        if(!TIFFRGBAImageGet(&img, reinterpret_cast<TiffImageBitsType*>(result.bits()), img.width, img.height))"
                },
                {
                    "limitHit": false,
                    "lineNumber": 3210,
                    "offsetAndLengths": [
                        [
                            51,
                            16
                        ]
                    ],
                    "preview": "            LOG_WARNING() << LOGGING_CTX << \"Can't TIFFRGBAImageGet for\" << filename;"
                }
            ],
            "repository": {
                "name": "github.com/AlienCowEatCake/ImageViewer",
                "url": "/github.com/AlienCowEatCake/ImageViewer"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "e5f0f3e5b1183facee2dd0c723757e9033d89c61"
                },
                "content": "#include \"StdAfx.h\"\n\n// #define STRICT\n#include \"diblib.h\"\n#include <commdlg.h>\n#include <stdlib.h> // MAX_ constants\n#include <windows.h>\n#include <windowsx.h>\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage\n{\n    TIFFRGBAImage tif;\n    int dibinstalled;\n};\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster);\n\nstatic void MyWarningHandler(const char *module, const char *fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void MyErrorHandler(const char *module, const char *fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF(LPCTSTR lpszPath)\n{\n    int rtn = 0;\n\n    TIFFErrorHandler eh;\n    TIFFErrorHandler wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF *tif = TIFFOpen(lpszPath, \"r\");\n    if (tif)\n    {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage *img);\n\nPVOID ReadTIFF(LPCTSTR lpszPath)\n{\n    void *pDIB = 0;\n    TIFFErrorHandler wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath))\n    {\n        TIFF *tif = TIFFOpen(lpszPath, \"r\");\n        if (tif)\n        {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg))\n            {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg))\n                {\n                    size_t npixels;\n                    uint32_t *raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster =\n                        (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n                    if (raster != NULL)\n                    {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width,\n                                             img.tif.height))\n                        {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else\n            {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg);\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster)\n{\n    void *pDIB = 0;\n    TIFFRGBAImage *img = &dib->tif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER bi;\n    int dwDIBSize;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if (BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled)\n    { // bilevel\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 1;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed = 0;\n        pRgbq[0].rgbBlue = 0;\n        pRgbq[0].rgbGreen = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed = 255;\n        pRgbq[1].rgbBlue = 255;\n        pRgbq[1].rgbGreen = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr(\n            (BITMAPINFOHEADER *)pDIB); //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n    //  For now just always default to the RGB 32 bit form. // save as 32 bit\n    //  for simplicity\n    else if (true /*BitsPerSample == 8 && SamplePerPixel == 3*/)\n    { // 24 bit color\n\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 32;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        // Swap the byte order while copying\n        for (int i = 0; i < sizeWords; ++i)\n        {\n            rgbDib[i].rgbRed = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n#define DECLAREContigPutFunc(name)                                             \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *pp)\n\n#define DECLARESepPutFunc(name)                                                \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *r, u_char *g, u_char *b, u_char *a)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *uraster, uint32_t w,\n                              uint32_t h);\n\n// typdef struct TIFFDibImage {\n//     TIFFRGBAImage tif;\n//     dibinstalled;\n// } TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage *dib)\n{\n    TIFFRGBAImage *img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric)\n    {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n            switch (img->bitspersample)\n            {\n                case 1:\n                    img->put.contig = putContig1bitTile;\n                    img->get = getStripContig1Bit;\n                    dib->dibinstalled = true;\n                    break;\n            }\n            break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void)y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char *ucp = (u_char *)cp;\n\n    /* Convert 'w' to bytes from pixels (rounded up) */\n    w = (w + 7) / 8;\n\n    while (h-- > 0)\n    {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32_t setorientation(TIFFRGBAImage *img, uint32_t h)\n{\n    TIFF *tif = img->tif;\n    uint32_t y;\n\n    switch (img->orientation)\n    {\n        case ORIENTATION_BOTRIGHT:\n        case ORIENTATION_RIGHTBOT: /* XXX */\n        case ORIENTATION_LEFTBOT:  /* XXX */\n            TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n            img->orientation = ORIENTATION_BOTLEFT;\n        /* fall through... */\n        case ORIENTATION_BOTLEFT:\n            y = 0;\n            break;\n        case ORIENTATION_TOPRIGHT:\n        case ORIENTATION_RIGHTTOP: /* XXX */\n        case ORIENTATION_LEFTTOP:  /* XXX */\n        default:\n            TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n            img->orientation = ORIENTATION_TOPLEFT;\n        /* fall through... */\n        case ORIENTATION_TOPLEFT:\n            y = h - 1;\n            break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *raster, uint32_t w,\n                              uint32_t h)\n{\n    TIFF *tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16_t orientation;\n    uint32_t row, y, nrow, rowstoread;\n    uint32_t pos;\n    u_char *buf;\n    uint32_t rowsperstrip;\n    uint32_t imagewidth = img->width;\n    tsize_t scanline;\n    int32_t fromskew, toskew;\n    tstrip_t strip;\n    tsize_t stripsize;\n    u_char *braster = (u_char *)raster; // byte wide raster\n    uint32_t wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char *)_TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32_t)(orientation == ORIENTATION_TOPLEFT ? wb + wb : wb - wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0) / 8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif, row + img->row_offset, 0);\n        stripsize = ((row + img->row_offset) % rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize) < 0 &&\n            img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32_t *)(braster + y * wb), 0, y, w, nrow, fromskew,\n               toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ? -(int32_t)nrow\n                                                 : (int32_t)nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n",
                "name": "Tiffile.cpp",
                "path": "src/ThirdParty/libtiff/tiff-4.7.0/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/AlienCowEatCake/ImageViewer/-/blob/src/ThirdParty/libtiff/tiff-4.7.0/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 112,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width,"
                }
            ],
            "repository": {
                "name": "github.com/AlienCowEatCake/ImageViewer",
                "url": "/github.com/AlienCowEatCake/ImageViewer"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "f816c264cfa21b85f195d5ecb884254cebd42752"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "tiff-4.0.1/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/alexmac/alcextra/-/blob/tiff-4.0.1/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/alexmac/alcextra",
                "url": "/github.com/alexmac/alcextra"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "c0106bb5b14269696fab740437cf18dd2eb47986"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "src/jni/sdl2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/renpy/python-for-android/-/blob/src/jni/sdl2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/renpy/python-for-android",
                "url": "/github.com/renpy/python-for-android"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "f9c15052c8f830e076838142ac65aca620396e63"
                },
                "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include <windows.h>\n#include <windowsx.h>\n#include <commdlg.h>\n#include <stdlib.h>                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include <assert.h>\n#include <stdio.h>\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples => 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel > 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
                "name": "Tiffile.cpp",
                "path": "tools/dist/rcbasic_android/android-project/app/jni/SDL2_image/external/tiff-4.0.9/contrib/win_dib/Tiffile.cpp",
                "url": "/github.com/n00b87/RCBASIC3/-/blob/tools/dist/rcbasic_android/android-project/app/jni/SDL2_image/external/tiff-4.0.9/contrib/win_dib/Tiffile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            28,
                            16
                        ]
                    ],
                    "preview": "                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {"
                }
            ],
            "repository": {
                "name": "github.com/n00b87/RCBASIC3",
                "url": "/github.com/n00b87/RCBASIC3"
            }
        }
    ],
    "LimitHit": false,
    "Cloning": [],
    "Missing": [],
    "Timedout": [],
    "ResultCount": 75,
    "ElapsedMilliseconds": 1424,
    "Alert": {
        "Title": "",
        "Description": "",
        "ProposedQueries": null
    }
}