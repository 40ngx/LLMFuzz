[
    "static UncompressedImage\nLoadTiff(TIFFRGBAImage &img)\n{\n  if (img.width > 8192 || img.height > 8192)\n    throw std::runtime_error(\"TIFF file is too large\");\n\n  std::unique_ptr<uint8_t[]> data(new uint8_t[img.width * img.height * 4]);\n  uint32_t *data32 = (uint32_t *)(void *)data.get();\n\n  if (!TIFFRGBAImageGet(&img, data32, img.width, img.height))\n    throw std::runtime_error(\"Failed to copy TIFF data\");\n\n  return UncompressedImage(UncompressedImage::Format::RGBA, img.width * 4,\n                           img.width, img.height, std::move(data), true);\n}",
    "PVOID ReadTIFF(LPCTSTR lpszPath)\n{\n    void *pDIB = 0;\n    TIFFErrorHandler wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath))\n    {\n        TIFF *tif = TIFFOpen(lpszPath, \"r\");\n        if (tif)\n        {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg))\n            {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg))\n                {\n                    size_t npixels;\n                    uint32_t *raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster =\n                        (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n                    if (raster != NULL)\n                    {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width,\n                                             img.tif.height))\n                        {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else\n            {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg);\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}",
    "RGBAImage* RGBAImage::ReadTiff(char *filename)\n{\n\tRGBAImage *fimg = 0;\n\t\n    TIFF* tif = TIFFOpen(filename, \"r\");\n    char emsg[1024];\n    if (tif) {\n\t\tTIFFRGBAImage img;\n\t\t\n\t\tif (TIFFRGBAImageBegin(&img, tif, 0, emsg)) {\n\t\t\tsize_t npixels;\n\t\t\tuint32* raster;\n\n\t\t\tnpixels = img.width * img.height;\n\t\t\traster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n\t\t\tif (raster != NULL) {\n\t\t\t\tif (TIFFRGBAImageGet(&img, raster, img.width, img.height)) {\n\t\t\t\t\t// result is in ABGR\n\t\t\t\t\tfimg = new RGBAImage(img.width, img.height);\n\t\t\t\t\tfor (int y = 0; y < img.height; y++) {\n\t\t\t\t\t\tfor (int x = 0; x < img.width; x++) {\n\t\t\t\t\t\t   fimg->Set(x,y, raster[x + y * img.width]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t_TIFFfree(raster);\n\t\t\t}\n\t    }\n\t    TIFFRGBAImageEnd(&img);\n\t} else {\n\t    TIFFError(filename, emsg);\n\t}\n\treturn fimg;\n}",
    "PVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}",
    "PVOID ReadTIFF ( LPCTSTR lpszPath )\r\n{\r\n    void*             pDIB = 0;\r\n    TIFFErrorHandler  wh;\r\n\r\n    wh = TIFFSetWarningHandler(MyWarningHandler);\r\n\r\n    if (ChkTIFF(lpszPath)) {\r\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\r\n        if (tif) {\r\n            char emsg[1024];\r\n\r\n            if (TIFFRGBAImageOK(tif, emsg)) {\r\n                TIFFDibImage img;\r\n                char emsg[1024];\r\n\r\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\r\n                    size_t npixels;\r\n                    uint32_t* raster;\r\n\r\n                    DibInstallHack(&img);\r\n\r\n                    npixels = img.tif.width * img.tif.height;\r\n                    raster = (uint32_t*) _TIFFmalloc(npixels * sizeof (uint32_t));\r\n                    if (raster != NULL) {\r\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\r\n                            pDIB = TIFFRGBA2DIB(&img, raster);\r\n                        }\r\n                    }\r\n                    _TIFFfree(raster);\r\n                }\r\n                TIFFRGBAImageEnd(&img.tif);\r\n            }\r\n            else {\r\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\r\n            }\r\n            TIFFClose(tif);\r\n        }\r\n    }\r\n\r\n    TIFFSetWarningHandler(wh);\r\n\r\n    return pDIB;\r\n}",
    "bool TIFRaster::Data::FetchPage()\r\n{\r\n\tif(page_error)\r\n\t\treturn false;\r\n\tif(page_fetched)\r\n\t\treturn true;\r\n\r\n\tcache_size = 0;\r\n\trows.Clear();\r\n\tint64 bytes = row_bytes * (int64)height;\r\n\timagebuf.SetCount(size.cy * row_bytes, 0);\r\n\treq_orientation = pages[page_index].orientation;\r\n\r\n\tbool res = TIFFRGBAImageGet(this, 0, width, height);\r\n\tTIFFRGBAImageEnd(this);\r\n\tpage_open = false;\r\n\r\n\tpage_fetched = true;\r\n\treturn true;\r\n}",
    "bool IFD::read(const TIFF* tiff,\n               const cucim::io::format::ImageMetadataDesc* metadata,\n               const cucim::io::format::ImageReaderRegionRequestDesc* request,\n               cucim::io::format::ImageDataDesc* out_image_data)\n{\n    PROF_SCOPED_RANGE(PROF_EVENT(ifd_read));\n    ::TIFF* tif = tiff->tiff_client_;\n\n    uint16_t ifd_index = ifd_index_;\n\n    std::string device_name(request->device);\n\n    if (request->shm_name)\n    {\n        device_name = device_name + fmt::format(\"[{}]\", request->shm_name); // TODO: check performance\n    }\n    cucim::io::Device out_device(device_name);\n\n    int64_t sx = request->location[0];\n    int64_t sy = request->location[1];\n    uint32_t batch_size = request->batch_size;\n    int64_t w = request->size[0];\n    int64_t h = request->size[1];\n    int32_t n_ch = samples_per_pixel_; // number of channels\n    int ndim = 3;\n\n    size_t raster_size = w * h * samples_per_pixel_;\n    void* raster = nullptr;\n    auto raster_type = cucim::io::DeviceType::kCPU;\n\n    DLTensor* out_buf = request->buf;\n    bool is_buf_available = out_buf && out_buf->data;\n\n    if (is_buf_available)\n    {\n        // TODO: memory size check if out_buf->data has high-enough memory (>= tjBufSize())\n        raster = out_buf->data;\n    }\n\n    if (is_read_optimizable())\n    {\n        if (batch_size > 1)\n        {\n            ndim = 4;\n        }\n        int64_t* location = request->location;\n        uint64_t location_len = request->location_len;\n        const uint32_t num_workers = request->num_workers;\n        const bool drop_last = request->drop_last;\n        uint32_t prefetch_factor = request->prefetch_factor;\n        const bool shuffle = request->shuffle;\n        const uint64_t seed = request->seed;\n\n        if (num_workers == 0 && location_len > 1)\n        {\n            throw std::runtime_error(\"Cannot read multiple locations with zero workers!\");\n        }\n\n        // Shuffle data\n        if (shuffle)\n        {\n            auto rng = std::default_random_engine{ seed };\n            struct position\n            {\n                int64_t x;\n                int64_t y;\n            };\n            std::shuffle(reinterpret_cast<position*>(&location[0]),\n                         reinterpret_cast<position*>(&location[location_len * 2]), rng);\n        }\n\n        // Adjust location length based on 'drop_last'\n        const uint32_t remaining_len = location_len % batch_size;\n        if (drop_last)\n        {\n            location_len -= remaining_len;\n        }\n\n        // Do not use prefetch if the image is too small\n        if (1 + prefetch_factor > location_len)\n        {\n            prefetch_factor = location_len - 1;\n        }\n\n        size_t one_raster_size = raster_size;\n        raster_size *= batch_size;\n\n        const IFD* ifd = this;\n\n        if (location_len > 1 || batch_size > 1 || num_workers > 0)\n        {\n            // Reconstruct location\n            std::unique_ptr<std::vector<int64_t>>* location_unique =\n                reinterpret_cast<std::unique_ptr<std::vector<int64_t>>*>(request->location_unique);\n            std::unique_ptr<std::vector<int64_t>> request_location = std::move(*location_unique);\n            delete location_unique;\n\n            // Reconstruct size\n            std::unique_ptr<std::vector<int64_t>>* size_unique =\n                reinterpret_cast<std::unique_ptr<std::vector<int64_t>>*>(request->size_unique);\n            std::unique_ptr<std::vector<int64_t>> request_size = std::move(*size_unique);\n            delete size_unique;\n\n            auto load_func = [tiff, ifd, location, w, h, out_device](\n                                 cucim::loader::ThreadBatchDataLoader* loader_ptr, uint64_t location_index) {\n                uint8_t* raster_ptr = loader_ptr->raster_pointer(location_index);\n\n                if (!read_region_tiles(tiff, ifd, location, location_index, w, h,\n                                       raster_ptr, out_device, loader_ptr))\n                {\n                    fmt::print(stderr, \"[Error] Failed to read region!\\n\");\n                }\n            };\n\n            uint32_t maximum_tile_count = 0;\n\n            std::unique_ptr<cucim::loader::BatchDataProcessor> batch_processor;\n\n            // Set raster_type to CUDA because loader will handle this with nvjpeg\n            if (out_device.type() == cucim::io::DeviceType::kCUDA)\n            {\n                raster_type = cucim::io::DeviceType::kCUDA;\n\n                // The maximal number of tiles (x-axis) overapped with the given patch\n                uint32_t tile_across_count = std::min(static_cast<uint64_t>(ifd->width_) + (ifd->tile_width_ - 1),\n                                                      static_cast<uint64_t>(w) + (ifd->tile_width_ - 1)) /\n                                                 ifd->tile_width_ +\n                                             1;\n                // The maximal number of tiles (y-axis) overapped with the given patch\n                uint32_t tile_down_count = std::min(static_cast<uint64_t>(ifd->height_) + (ifd->tile_height_ - 1),\n                                                    static_cast<uint64_t>(h) + (ifd->tile_height_ - 1)) /\n                                               ifd->tile_height_ +\n                                           1;\n                // The maximal number of possible tiles (# of tasks) to load for the given image batch\n                maximum_tile_count = tile_across_count * tile_down_count * batch_size;\n\n                // Create NvJpegProcessor\n                auto& jpegtable = ifd->jpegtable_;\n                const void* jpegtable_data = jpegtable.data();\n                uint32_t jpegtable_size = jpegtable.size();\n\n                auto nvjpeg_processor = std::make_unique<cuslide::loader::NvJpegProcessor>(\n                    tiff->file_handle_, ifd, request_location->data(), request_size->data(), location_len, batch_size,\n                    maximum_tile_count, static_cast<const uint8_t*>(jpegtable_data), jpegtable_size);\n\n                // Update prefetch_factor\n                prefetch_factor = nvjpeg_processor->preferred_loader_prefetch_factor();\n\n                batch_processor = std::move(nvjpeg_processor);\n            }\n\n            auto loader = std::make_unique<cucim::loader::ThreadBatchDataLoader>(\n                load_func, std::move(batch_processor), out_device, std::move(request_location), std::move(request_size),\n                location_len, one_raster_size, batch_size, prefetch_factor, num_workers);\n\n            const uint32_t load_size = std::min(static_cast<uint64_t>(batch_size) * (1 + prefetch_factor), location_len);\n\n            loader->request(load_size);\n\n            // If it reads entire image with multi threads (using loader), fetch the next item.\n            if (location_len == 1 && batch_size == 1)\n            {\n                raster = loader->next_data();\n            }\n\n            out_image_data->loader = loader.release(); // set loader to out_image_data\n        }\n        else\n        {\n            if (!raster)\n            {\n                raster = cucim_malloc(one_raster_size);\n            }\n\n            if (!read_region_tiles(tiff, ifd, location, 0, w, h, raster, out_device, nullptr))\n            {\n                fmt::print(stderr, \"[Error] Failed to read region!\\n\");\n            }\n        }\n    }\n    else\n    {\n        PROF_SCOPED_RANGE(PROF_EVENT(ifd_read_slowpath));\n        // Print a warning message for the slow path\n        std::call_once(\n            tiff->slow_path_warning_flag_,\n            [](const std::string& file_path) {\n                fmt::print(\n                    stderr,\n                    \"[Warning] Loading image('{}') with a slow-path. The pixel format of the loaded image would be RGBA (4 channels) instead of RGB!\\n\",\n                    file_path);\n            },\n            tiff->file_path());\n        // Handle out-of-boundary case\n        int64_t ex = sx + w - 1;\n        int64_t ey = sy + h - 1;\n        if (sx < 0 || sy < 0 || sx >= width_ || sy >= height_ || ex < 0 || ey < 0 || ex >= width_ || ey >= height_)\n        {\n            throw std::invalid_argument(fmt::format(\"Cannot handle the out-of-boundary cases.\"));\n        }\n\n        // Check if the image format is supported or not\n        if (!is_format_supported())\n        {\n            throw std::runtime_error(fmt::format(\n                \"This format (compression: {}, sample_per_pixel: {}, planar_config: {}, photometric: {}) is not supported yet!.\",\n                compression_, samples_per_pixel_, planar_config_, photometric_));\n        }\n\n        if (tif->tif_curdir != ifd_index)\n        {\n            TIFFSetDirectory(tif, ifd_index);\n        }\n        // RGBA -> 4 channels\n        n_ch = 4;\n\n        char emsg[1024];\n        if (TIFFRGBAImageOK(tif, emsg))\n        {\n            TIFFRGBAImage img;\n            if (TIFFRGBAImageBegin(&img, tif, -1, emsg))\n            {\n                size_t npixels;\n                npixels = w * h;\n                raster_size = npixels * 4;\n                if (!raster)\n                {\n                    raster = cucim_malloc(raster_size);\n                }\n                img.col_offset = sx;\n                img.row_offset = sy;\n                img.req_orientation = ORIENTATION_TOPLEFT;\n\n                if (raster != nullptr)\n                {\n                    if (!TIFFRGBAImageGet(&img, (uint32_t*)raster, w, h))\n                    {\n                        memset(raster, 0, raster_size);\n                    }\n                }\n            }\n            else\n            {\n                throw std::runtime_error(fmt::format(\n                    \"This format (compression: {}, sample_per_pixel: {}, planar_config: {}, photometric: {}) is not supported yet!: {}\",\n                    compression_, samples_per_pixel_, planar_config_, photometric_, emsg));\n            }\n            TIFFRGBAImageEnd(&img);\n        }\n        else\n        {\n            throw std::runtime_error(fmt::format(\n                \"This format (compression: {}, sample_per_pixel: {}, planar_config: {}, photometric: {}) is not supported yet!: {}\",\n                compression_, samples_per_pixel_, planar_config_, photometric_, emsg));\n        }\n    }\n\n    int64_t* shape = static_cast<int64_t*>(cucim_malloc(sizeof(int64_t) * ndim));\n    if (ndim == 3)\n    {\n        shape[0] = h;\n        shape[1] = w;\n        shape[2] = n_ch;\n    }\n    else // ndim == 4\n    {\n        shape[0] = batch_size;\n        shape[1] = h;\n        shape[2] = w;\n        shape[3] = n_ch;\n    }\n\n    // Copy the raster memory and free it if needed.\n    if (!is_buf_available && raster && raster_type == cucim::io::DeviceType::kCPU)\n    {\n        cucim::memory::move_raster_from_host(&raster, raster_size, out_device);\n    }\n\n    auto& out_image_container = out_image_data->container;\n    out_image_container.data = raster;\n    out_image_container.device = DLDevice{ static_cast<DLDeviceType>(out_device.type()), out_device.index() };\n    out_image_container.ndim = ndim;\n    out_image_container.dtype = metadata->dtype;\n    out_image_container.shape = shape;\n    out_image_container.strides = nullptr; // Tensor is compact and row-majored\n    out_image_container.byte_offset = 0;\n    auto& shm_name = out_device.shm_name();\n    size_t shm_name_len = shm_name.size();\n    if (shm_name_len != 0)\n    {\n        out_image_data->shm_name = static_cast<char*>(cucim_malloc(shm_name_len + 1));\n        memcpy(out_image_data->shm_name, shm_name.c_str(), shm_name_len + 1);\n    }\n    else\n    {\n        out_image_data->shm_name = nullptr;\n    }\n\n    return true;\n}",
    "PayloadWithMetaData<QImage> readTiffFile(const QString &filename)\n{\n    QFile inFile(filename);\n    if(!inFile.open(QIODevice::ReadOnly))\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't open\" << filename;\n        return QImage();\n    }\n\n#if defined (TIFFLIB_VERSION) && (TIFFLIB_VERSION >= 20221213) && (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))\n    TIFFOpenOptions *opts = TIFFOpenOptionsAlloc();\n    TIFFOpenOptionsSetErrorHandlerExtR(opts, errorHandlerProc, Q_NULLPTR);\n    TIFFOpenOptionsSetWarningHandlerExtR(opts, &warningHandlerProc, Q_NULLPTR);\n    TIFF *tiff = TIFFClientOpenExt(\"DecoderLibTiff\", \"r\", &inFile, readProc, writeProc, seekProc, closeProc, sizeProc, mapProc, unmapProc, opts);\n    TIFFOpenOptionsFree(opts);\n#else\n    TIFF *tiff = TIFFClientOpen(\"DecoderLibTiff\", \"r\", &inFile, readProc, writeProc, seekProc, closeProc, sizeProc, mapProc, unmapProc);\n#endif\n    if(!tiff)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't TIFFClientOpen for\" << filename;\n        return QImage();\n    }\n\n    if(!TIFFSetDirectory(tiff, 0))\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't TIFFSetDirectory for\" << filename;\n        TIFFClose(tiff);\n        return QImage();\n    }\n\n    quint32 width = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_IMAGEWIDTH, &width) || width <= 0)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't get TIFFTAG_IMAGEWIDTH for\" << filename;\n        TIFFClose(tiff);\n        return QImage();\n    }\n\n    quint32 height = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_IMAGELENGTH, &height) || height <= 0)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't get TIFFTAG_IMAGELENGTH for\" << filename;\n        TIFFClose(tiff);\n        return QImage();\n    }\n\n    quint16 compression = 0;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_COMPRESSION, &compression);\n\n    /// @todo LibTIFF-4.6.0: Looks like samples layout for subsampled YCbCr data\n    /// for JPEG compression is differ from samples layout for other compression\n    /// types. So we will enforce built-in YCbCr to RGB converter. Despite tag\n    /// name, non-YCbCr colorspaces like CMYK or RGB are not affected\n    if(compression == COMPRESSION_JPEG)\n        TIFFSetField(tiff, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\n    quint16 samplesPerPixel = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel) || samplesPerPixel <= 0)\n        samplesPerPixel = 1;\n\n    int alphaIndex = -1;\n    quint16 extrasamplesCount = 0;\n    const quint16 *extrasamples = Q_NULLPTR;\n    if(TIFFGetFieldDefaulted(tiff, TIFFTAG_EXTRASAMPLES, &extrasamplesCount, &extrasamples))\n    {\n        for(quint16 i = 0; i < extrasamplesCount && alphaIndex < 0; ++i)\n        {\n            if(extrasamples[i] == EXTRASAMPLE_ASSOCALPHA)\n                alphaIndex = static_cast<int>(i);\n        }\n        for(quint16 i = 0; i < extrasamplesCount && alphaIndex < 0; ++i)\n        {\n            if(extrasamples[i] == EXTRASAMPLE_UNASSALPHA)\n                alphaIndex = static_cast<int>(i);\n        }\n    }\n    const quint16 primarysamplesCount = samplesPerPixel > extrasamplesCount ? samplesPerPixel - extrasamplesCount : 0;\n\n    quint16 photometric = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_PHOTOMETRIC, &photometric))\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't get TIFFTAG_PHOTOMETRIC for\" << filename;\n        if(primarysamplesCount == 1)\n        {\n            photometric = PHOTOMETRIC_MINISWHITE;\n            LOG_WARNING() << LOGGING_CTX << \"Assuming PHOTOMETRIC_MINISWHITE\";\n        }\n        else if(primarysamplesCount == 3)\n        {\n            photometric = PHOTOMETRIC_RGB;\n            LOG_WARNING() << LOGGING_CTX << \"Assuming PHOTOMETRIC_RGB\";\n        }\n        else\n        {\n            TIFFClose(tiff);\n            return QImage();\n        }\n    }\n\n    /// @note Enable converting PHOTOMETRIC_LOGL and PHOTOMETRIC_LOGLUV to 8 bit\n    /// RGB and grayscale values respective\n    if(IsOneOf(photometric, PHOTOMETRIC_LOGL, PHOTOMETRIC_LOGLUV))\n        TIFFSetField(tiff, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n\n    quint16 orientation = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_ORIENTATION, &orientation) || orientation <= 0)\n        orientation = ORIENTATION_TOPLEFT;\n\n    quint16 bitsPerSample = 0;\n    if(!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample) || bitsPerSample <= 0)\n        bitsPerSample = 1;\n\n    quint16 sampleFormat = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat) || sampleFormat <= 0)\n        sampleFormat = SAMPLEFORMAT_VOID;\n\n    quint16 inkSet = 0;\n    if(photometric == PHOTOMETRIC_SEPARATED)\n    {\n        if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_INKSET, &inkSet) || inkSet <= 0)\n            inkSet = INKSET_CMYK;\n    }\n\n    quint16 planarConfig = 0;\n    TIFFGetField(tiff, TIFFTAG_PLANARCONFIG, &planarConfig);\n\n    const float *ycbcrcoeffs = Q_NULLPTR;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_YCBCRCOEFFICIENTS, &ycbcrcoeffs);\n\n    quint16 subsamplinghor = 0, subsamplingver = 0;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver);\n\n    quint16 ycbcrpositioning = 0;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_YCBCRPOSITIONING, &ycbcrpositioning);\n\n    const quint16 *redTable = Q_NULLPTR;\n    const quint16 *greenTable = Q_NULLPTR;\n    const quint16 *blueTable = Q_NULLPTR;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_COLORMAP, &redTable, &greenTable, &blueTable);\n\n    QScopedPointer<ICCProfile> iccProfile(readICCProfile(tiff));\n    if((!iccProfile || !iccProfile->isValid()) && photometric == PHOTOMETRIC_SEPARATED && inkSet == INKSET_CMYK)\n        iccProfile.reset(new ICCProfile(ICCProfile::defaultCmykProfileData()));\n\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_IMAGEWIDTH =\" << width;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_IMAGELENGTH =\" << height;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_PHOTOMETRIC =\" << photometricToString(photometric).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_INKSET =\" << inkSetToString(inkSet).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_ORIENTATION =\" << orientationToString(orientation).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_BITSPERSAMPLE =\" << bitsPerSample;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_SAMPLESPERPIXEL =\" << samplesPerPixel;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_SAMPLEFORMAT =\" << sampleFormatToString(sampleFormat).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_EXTRASAMPLES =\" << extrasamplesToString(extrasamplesCount, extrasamples).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_PLANARCONFIG =\" << planarConfigToString(planarConfig).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_COMPRESSION =\" << compressionToString(compression).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_YCBCRSUBSAMPLING =\" << subsamplinghor << subsamplingver;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_YCBCRPOSITIONING =\" << ycbcrpositioningToString(ycbcrpositioning).toLatin1().data();\n\n    const bool isSupportedInt = IsOneOf(sampleFormat, SAMPLEFORMAT_UINT, SAMPLEFORMAT_VOID, SAMPLEFORMAT_INT) && bitsPerSample <= 64;\n    const bool isSupportedFp = sampleFormat == SAMPLEFORMAT_IEEEFP && IsOneOf(bitsPerSample, 16, 24, 32, 64);\n    bool isReadingSupported = false;\n    switch(photometric)\n    {\n    case PHOTOMETRIC_MINISWHITE:\n    case PHOTOMETRIC_MINISBLACK:\n    case PHOTOMETRIC_LOGL:\n        isReadingSupported = (isSupportedInt || isSupportedFp) && primarysamplesCount >= 1;\n        break;\n    case PHOTOMETRIC_RGB:\n    case PHOTOMETRIC_YCBCR:\n    case PHOTOMETRIC_LOGLUV:\n        isReadingSupported = (isSupportedInt || isSupportedFp) && primarysamplesCount >= 3;\n        break;\n    case PHOTOMETRIC_SEPARATED:\n        isReadingSupported = (isSupportedInt || isSupportedFp) && primarysamplesCount >= 4;\n        break;\n    case PHOTOMETRIC_CIELAB:\n    case PHOTOMETRIC_ICCLAB:\n    case PHOTOMETRIC_ITULAB:\n        isReadingSupported = (isSupportedInt || isSupportedFp) && primarysamplesCount >= 1;\n        break;\n    case PHOTOMETRIC_PALETTE:\n        isReadingSupported = redTable && greenTable && blueTable && bitsPerSample <= 16 && primarysamplesCount >= 1;\n        break;\n    // case PHOTOMETRIC_MASK:\n    // case PHOTOMETRIC_CFA:\n    default:\n        break;\n    }\n\n    QImage result;\n    if(isReadingSupported)\n    {\n        Context ctx;\n        memset(&ctx, 0, sizeof(ctx));\n        ctx.tiff = tiff;\n        ctx.width = static_cast<qint64>(width);\n        ctx.height = static_cast<qint64>(height);\n        ctx.compression = compression;\n        ctx.photometric = compression == COMPRESSION_JPEG && photometric == PHOTOMETRIC_YCBCR ? PHOTOMETRIC_RGB : photometric;\n        ctx.samplesPerPixel = static_cast<qint64>(samplesPerPixel);\n        ctx.bitsPerSample = static_cast<qint64>(bitsPerSample);\n        ctx.sampleFormat = sampleFormat;\n        ctx.inkSet = inkSet;\n        ctx.iccProfile = iccProfile.data();\n        ctx.ycbcrcoeffs = ycbcrcoeffs;\n        ctx.subsamplinghor = static_cast<qint64>(subsamplinghor);\n        ctx.subsamplingver = static_cast<qint64>(subsamplingver);\n        ctx.ycbcrpositioning = ycbcrpositioning;\n        ctx.extrasamplesCount = static_cast<qint64>(extrasamplesCount);\n        ctx.primarysamplesCount = static_cast<qint64>(primarysamplesCount);\n        ctx.alphaIndex = alphaIndex;\n        ctx.alphaPremultiplied = alphaIndex >= 0 ? extrasamples[alphaIndex] == EXTRASAMPLE_ASSOCALPHA : false;\n        ctx.redTable = redTable;\n        ctx.greenTable = greenTable;\n        ctx.blueTable = blueTable;\n        ctx.colorTablesIs16Bit = false;\n\n        if(photometric == PHOTOMETRIC_PALETTE && redTable && greenTable && blueTable)\n        {\n            /// @note See buildMap and checkcmap in tif_getimage.c\n            for(quint64 i = 0, count = (1ull << bitsPerSample); i < count && !ctx.colorTablesIs16Bit; ++i)\n                if(redTable[i] >= 256 || greenTable[i] >= 256 || blueTable[i] >= 256)\n                    ctx.colorTablesIs16Bit = true;\n        }\n\n        if(TIFFIsTiled(tiff))\n            result = readTiffFileTiled(&ctx);\n        else\n            result = readTiffFileStriped(&ctx);\n    }\n\n    /// @todo LibTIFF-4.6.0: TIFFRGBA* has bad errors handling and reports OK\n    /// sometimes even if no data was decoded. So we will disable it for all\n    /// supported formats\n    if(result.isNull() && !isReadingSupported)\n    {\n        TIFFRGBAImage img;\n        char emsg[1024];\n        if(!TIFFRGBAImageBegin(&img, tiff, 0, emsg))\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Can't TIFFRGBAImageBegin for\" << filename;\n            LOG_WARNING() << LOGGING_CTX << \"Reason:\" << emsg;\n            TIFFClose(tiff);\n            return QImage();\n        }\n\n        result = QImage(static_cast<int>(img.width), static_cast<int>(img.height),\n#if (USE_RGBA_8888)\n                      QImage::Format_RGBA8888);\n#else\n                      QImage::Format_ARGB32);\n#endif\n        if(result.isNull())\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n            TIFFClose(tiff);\n            return QImage();\n        }\n\n        img.req_orientation = img.orientation;\n\n#if defined (TIFFLIB_VERSION) && (TIFFLIB_VERSION >= 20210416)\n        typedef uint32_t TiffImageBitsType;\n#else\n        typedef uint32 TiffImageBitsType;\n#endif\n\n        if(!TIFFRGBAImageGet(&img, reinterpret_cast<TiffImageBitsType*>(result.bits()), img.width, img.height))\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Can't TIFFRGBAImageGet for\" << filename;\n            TIFFClose(tiff);\n            return QImage();\n        }\n\n#if (!USE_RGBA_8888)\n        QImage_rgbSwap(result);\n#endif\n\n#undef USE_RGBA_8888\n\n        TIFFRGBAImageEnd(&img);\n\n        if(iccProfile)\n            iccProfile->applyToImage(&result);\n    }\n\n    // Some image formats can't be rendered successfully\n    if(!IsOneOf(result.format(), QImage::Format_RGB32, QImage::Format_ARGB32))\n        QImage_convertTo(result, result.hasAlphaChannel() ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n\n    ImageMetaData *metaData = ImageMetaData::createMetaData(filename);\n    if(!metaData)\n        metaData = readExifMetaData(tiff);\n    if(!metaData)\n        metaData = new ImageMetaData;\n\n    metaData->addCustomOrientation(orientation);\n    metaData->applyExifOrientation(&result);\n\n    quint16 resUnit = 0;\n    if(!TIFFGetField(tiff, TIFFTAG_RESOLUTIONUNIT, &resUnit))\n        resUnit = RESUNIT_INCH;\n    float resX = 0.0f, resY = 0.0f;\n    if(TIFFGetField(tiff, TIFFTAG_XRESOLUTION, &resX) && TIFFGetField(tiff, TIFFTAG_YRESOLUTION, &resY))\n    {\n        if(resUnit == RESUNIT_CENTIMETER)\n            metaData->addCustomDpi(static_cast<qreal>(resX * 2.54f), static_cast<qreal>(resY * 2.54f));\n        else if(resUnit == RESUNIT_INCH)\n            metaData->addCustomDpi(static_cast<qreal>(resX), static_cast<qreal>(resY));\n    }\n\n    TIFFClose(tiff);\n\n    return PayloadWithMetaData<QImage>(result, metaData);\n}"
]