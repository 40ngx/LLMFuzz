{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "file:\\.(c|cpp|cc)$ lang:c++ count:all TIFFRGBAImageGet",
  "Site": {
    "BuildVersion": "316984_2025-03-18_6.1-1f1695fa27f5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "761fac6e54c265d9011eaf7abfcac4952261d510"
        },
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Copyright The XCSoar Project\n\n#include \"LibTiff.hpp\"\n#include \"UncompressedImage.hpp\"\n#include \"system/Path.hpp\"\n#include \"util/ScopeExit.hxx\"\n\n#include \u003cstdexcept\u003e\n\n#include \u003ctiffio.h\u003e\n\n#ifdef USE_GEOTIFF\n#include \"Geo/Quadrilateral.hpp\"\n\n#include \u003cgeotiff.h\u003e\n#include \u003cgeo_normalize.h\u003e\n#include \u003cgeovalues.h\u003e\n#include \u003cxtiffio.h\u003e\n#endif\n\nstatic TIFF *\nTiffOpen(Path path, const char *mode)\n{\n#ifdef USE_GEOTIFF\n  XTIFFInitialize();\n#endif\n\n#ifdef _UNICODE\n  return TIFFOpenW(path.c_str(), mode);\n#else\n  return TIFFOpen(path.c_str(), mode);\n#endif\n}\n\nclass TiffLoader {\n  TIFF *const tiff;\n\npublic:\n  explicit TiffLoader(Path path)\n    :tiff(TiffOpen(path, \"r\")) {\n    if (tiff == nullptr)\n      throw std::runtime_error(\"Failed to open TIFF file\");\n  }\n\n  ~TiffLoader() {\n    TIFFClose(tiff);\n  }\n\n  TIFF *Get() {\n    return tiff;\n  }\n\n  void GetField(uint32_t tag, int \u0026value_r) {\n    TIFFGetField(tiff, tag, \u0026value_r);\n  }\n\n  void RGBAImageBegin(TIFFRGBAImage \u0026img) {\n    char emsg[1024];\n    if (!TIFFRGBAImageBegin(\u0026img, tiff, 0, emsg))\n      throw std::runtime_error(emsg);\n  }\n};\n\nstatic UncompressedImage\nLoadTiff(TIFFRGBAImage \u0026img)\n{\n  if (img.width \u003e 8192 || img.height \u003e 8192)\n    throw std::runtime_error(\"TIFF file is too large\");\n\n  std::unique_ptr\u003cuint8_t[]\u003e data(new uint8_t[img.width * img.height * 4]);\n  uint32_t *data32 = (uint32_t *)(void *)data.get();\n\n  if (!TIFFRGBAImageGet(\u0026img, data32, img.width, img.height))\n    throw std::runtime_error(\"Failed to copy TIFF data\");\n\n  return UncompressedImage(UncompressedImage::Format::RGBA, img.width * 4,\n                           img.width, img.height, std::move(data), true);\n}\n\nstatic UncompressedImage\nLoadTiff(TiffLoader \u0026tiff)\n{\n  TIFFRGBAImage img;\n  tiff.RGBAImageBegin(img);\n\n  AtScopeExit(\u0026img) { TIFFRGBAImageEnd(\u0026img); };\n\n  return LoadTiff(img);\n}\n\nUncompressedImage\nLoadTiff(Path path)\n{\n  TiffLoader tiff(path);\n  return LoadTiff(tiff);\n}\n\n#ifdef USE_GEOTIFF\n\nstatic GeoPoint\nTiffPixelToGeoPoint(GTIF \u0026gtif, GTIFDefn \u0026defn, double x, double y)\n{\n  if (!GTIFImageToPCS(\u0026gtif, \u0026x, \u0026y))\n    return GeoPoint::Invalid();\n\n  if (defn.Model != ModelTypeGeographic \u0026\u0026\n      !GTIFProj4ToLatLong(\u0026defn, 1, \u0026x, \u0026y))\n    return GeoPoint::Invalid();\n\n  return GeoPoint(Angle::Degrees(x), Angle::Degrees(y));\n}\n\nstd::pair\u003cUncompressedImage, GeoQuadrilateral\u003e\nLoadGeoTiff(Path path)\n{\n  TiffLoader tiff(path);\n\n  GeoQuadrilateral bounds;\n\n  {\n    auto gtif = GTIFNew(tiff.Get());\n    if (gtif == nullptr)\n      throw std::runtime_error(\"Not a GeoTIFF file\");\n\n    AtScopeExit(gtif) { GTIFFree(gtif); };\n\n    GTIFDefn defn;\n    if (!GTIFGetDefn(gtif, \u0026defn))\n      throw std::runtime_error(\"Failed to parse GeoTIFF metadata\");\n\n    int width, height;\n    tiff.GetField(TIFFTAG_IMAGEWIDTH, width);\n    tiff.GetField(TIFFTAG_IMAGELENGTH, height);\n\n    bounds.top_left = TiffPixelToGeoPoint(*gtif, defn, 0, 0);\n    bounds.top_right = TiffPixelToGeoPoint(*gtif, defn, width, 0);\n    bounds.bottom_left = TiffPixelToGeoPoint(*gtif, defn, 0, height);\n    bounds.bottom_right = TiffPixelToGeoPoint(*gtif, defn, width, height);\n\n    if (!bounds.Check())\n      throw std::runtime_error(\"Invalid GeoTIFF bounds\");\n  }\n\n  return std::make_pair(LoadTiff(tiff), bounds);\n}\n\n#endif\n",
        "name": "LibTiff.cpp",
        "path": "src/ui/canvas/custom/LibTiff.cpp",
        "url": "/github.com/XCSoar/XCSoar/-/blob/src/ui/canvas/custom/LibTiff.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 73,
          "offsetAndLengths": [
            [
              7,
              16
            ]
          ],
          "preview": "  if (!TIFFRGBAImageGet(\u0026img, data32, img.width, img.height))"
        }
      ],
      "repository": {
        "name": "github.com/XCSoar/XCSoar",
        "url": "/github.com/XCSoar/XCSoar"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "c15ace4a9bb90693e1e9aaa55969b51859ec2633"
        },
        "content": "#include \"FDSan.h\"\n#include \u003ctiffio.hxx\u003e\n#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n#include \u003cstdint.h\u003e\n#include \u003cvector\u003e\n#include \u003cfstream\u003e\n#include \u003ciostream\u003e\n#include \u003csstream\u003e\n//\u003cID\u003e 220\n//\u003cPrompt\u003e [\"TIFFStripSize64\",\"TIFFReadRGBAImageOriented\",\"TIFFIsByteSwapped\",\"TIFFSetTagExtender\",\"TIFFFlushData\",\"LogL16toY\",\"TIFFReadRGBAStripExt\",\"LogLuv24fromXYZ\"]\n/*\u003cCombination\u003e: [uint64_t TIFFStripSize64(TIFF * tif),\n    int TIFFReadRGBAImageOriented(TIFF * , uint32_t , uint32_t , uint32_t * , int , int ),\n    int TIFFIsByteSwapped(TIFF * ),\n    TIFFExtendProc TIFFSetTagExtender(TIFFExtendProc ),\n    int TIFFFlushData(TIFF * tif),\n    double LogL16toY(int ),\n    int TIFFReadRGBAStripExt(TIFF * , uint32_t , uint32_t * , int stop_on_error),\n    uint32_t LogLuv24fromXYZ(float * , int )\n*/\n//\u003cscore\u003e 184.6, nr_unique_branch: 965\n//\u003cQuality\u003e {\"density\":13,\"unique_branches\":{\"CLAMPw\":[[222,9,222,17,0,0,4,0],[222,9,222,17,0,0,4,1],[227,9,227,17,0,0,4,0],[227,9,227,17,0,0,4,1]],\"TIFFYCbCrToRGBInit\":[[265,17,265,24,0,0,4,0],[265,17,265,24,0,0,4,1],[296,31,296,38,0,0,4,0],[296,31,296,38,0,0,4,1],[189,28,189,29,3,0,4,1],[189,28,189,29,3,0,4,0],[189,28,189,29,3,0,4,1],[189,28,189,29,6,0,4,1],[189,28,189,29,6,0,4,0],[189,28,189,29,6,0,4,1],[189,28,189,29,8,0,4,1],[189,28,189,29,8,0,4,0],[189,28,189,29,8,0,4,1],[189,28,189,29,11,0,4,1],[189,28,189,29,11,0,4,0],[189,28,189,29,11,0,4,1],[193,14,193,32,12,0,4,0],[193,14,193,32,12,0,4,1],[193,14,193,32,13,0,4,0],[193,14,193,32,13,0,4,1],[193,14,193,32,19,0,4,0],[193,14,193,32,19,0,4,1]],\"TIFFReadRGBAImageOriented\":[[617,9,617,35,0,0,4,0],[617,9,617,35,0,0,4,1],[617,39,617,80,0,0,4,0],[617,39,617,80,0,0,4,1]],\"_TIFFReadTileAndAllocBuffer\":[[986,9,986,31,0,0,4,1],[986,35,986,66,0,0,4,1]],\"Fax3DecodeRLE\":[[117,21,117,31,57,0,4,0]],\"LogLuv24fromXYZ\":[[1054,9,1054,12,0,0,4,1],[1054,16,1054,23,0,0,4,1],[1065,9,1065,15,0,0,4,1]],\"TIFFRGBAImageOK\":[[89,9,89,31,0,0,4,1],[97,9,97,15,0,0,4,0],[97,9,97,15,0,0,4,1],[98,9,98,15,0,0,4,0],[98,9,98,15,0,0,4,1],[99,9,99,15,0,0,4,0],[99,9,99,15,0,0,4,1],[100,9,100,15,0,0,4,0],[100,9,100,15,0,0,4,1],[101,9,101,16,0,0,4,0],[101,9,101,16,0,0,4,1],[103,9,103,16,0,0,4,0],[103,9,103,16,0,0,4,1],[110,9,110,51,0,0,4,0],[110,9,110,51,0,0,4,1],[118,9,118,62,0,0,4,0],[118,9,118,62,0,0,4,1],[122,13,122,19,0,0,4,0],[122,13,122,19,0,0,4,1],[125,13,125,19,0,0,4,1],[128,13,128,20,0,0,4,0],[128,13,128,20,0,0,4,1],[136,9,136,36,0,0,4,0],[136,9,136,36,0,0,4,1],[137,9,137,36,0,0,4,0],[137,9,137,36,0,0,4,1],[138,9,138,33,0,0,4,0],[138,9,138,33,0,0,4,1],[139,17,139,59,0,0,4,0],[139,17,139,59,0,0,4,1],[140,17,140,44,0,0,4,0],[140,17,140,44,0,0,4,1],[140,48,140,72,0,0,4,0],[140,48,140,72,0,0,4,1],[157,9,157,31,0,0,4,0],[157,9,157,31,0,0,4,1],[165,9,165,29,0,0,4,0],[165,9,165,29,0,0,4,1],[166,17,166,34,0,0,4,0],[166,17,166,34,0,0,4,1],[174,9,174,35,0,0,4,0],[174,9,174,35,0,0,4,1],[178,17,178,38,0,0,4,0],[178,17,178,38,0,0,4,1],[185,17,185,43,0,0,4,0],[185,17,185,43,0,0,4,1],[195,9,195,30,0,0,4,0],[195,9,195,30,0,0,4,1],[196,17,196,57,0,0,4,0],[204,9,204,32,0,0,4,0],[204,9,204,32,0,0,4,1],[205,17,205,57,0,0,4,0],[206,17,206,59,0,0,4,0],[231,9,231,32,0,0,4,0],[231,9,231,32,0,0,4,1],[232,17,232,44,0,0,4,0],[232,17,232,44,0,0,4,1],[232,48,232,66,0,0,4,1],[233,18,233,43,0,0,4,0],[233,18,233,43,0,0,4,1],[233,47,233,73,0,0,4,0],[244,9,244,16,0,0,4,0],[244,9,244,16,0,0,4,1]],\"initCIELabConversion\":[[2618,9,2618,30,0,0,4,1],[2624,9,2624,21,0,0,4,0],[2628,13,2628,25,0,0,4,1],[2640,9,2640,70,0,0,4,1],[2648,9,2648,32,0,0,4,0]],\"gtStripSeparate\":[[1182,33,1182,38,0,0,4,0],[1182,33,1182,38,0,0,4,1],[1183,9,1183,21,0,0,4,1],[1189,9,1189,31,0,0,4,0],[1189,9,1189,31,0,0,4,1],[1191,13,1191,24,0,0,4,1],[1207,9,1207,36,0,0,4,0],[1207,9,1207,36,0,0,4,1],[1208,9,1208,36,0,0,4,0],[1208,9,1208,36,0,0,4,1],[1209,9,1209,33,0,0,4,1],[1213,9,1213,16,0,0,4,0],[1213,9,1213,16,0,0,4,1],[1220,17,1220,31,0,0,4,1],[1221,19,1221,26,0,0,4,0],[1221,19,1221,26,0,0,4,1],[1225,17,1225,37,0,0,4,0],[1225,17,1225,37,0,0,4,1],[1228,13,1228,25,0,0,4,0],[1228,29,1228,74,0,0,4,1],[1234,13,1234,24,0,0,4,0],[1234,13,1234,24,0,0,4,1],[1236,17,1238,64,0,0,4,0],[1236,17,1238,64,0,0,4,1],[1239,18,1239,29,0,0,4,0],[1239,18,1239,29,0,0,4,1],[1239,33,1239,47,0,0,4,0],[1245,17,1245,35,0,0,4,0],[1245,17,1245,35,0,0,4,1],[1248,23,1248,28,0,0,4,0],[1248,23,1248,28,0,0,4,1],[1254,23,1254,28,0,0,4,0],[1257,18,1258,77,0,0,4,0],[1257,18,1258,77,0,0,4,1],[1259,18,1259,32,0,0,4,0],[1264,13,1264,30,0,0,4,0],[1264,13,1264,30,0,0,4,1],[1265,13,1266,68,0,0,4,1],[1272,13,1272,30,0,0,4,0],[1272,13,1272,30,0,0,4,1],[1273,13,1274,68,0,0,4,1],[1280,13,1280,18,0,0,4,0],[1280,13,1280,18,0,0,4,1],[1282,17,1284,55,0,0,4,0],[1282,17,1284,55,0,0,4,1],[1285,17,1285,31,0,0,4,0],[1296,37,1296,42,0,0,4,0],[1296,37,1296,42,0,0,4,1],[1297,15,1297,39,0,0,4,0],[1297,15,1297,39,0,0,4,1],[1300,9,1300,33,0,0,4,0],[1300,9,1300,33,0,0,4,1],[1304,24,1304,32,0,0,4,0],[1304,24,1304,32,0,0,4,1],[1309,20,1309,32,0,0,4,0],[1309,20,1309,32,0,0,4,1]],\"putRGBAAcontig8bittile\":[[1682,12,1682,17,0,0,4,0],[1682,12,1682,17,0,0,4,1],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1344,13,1344,14,3,0,4,1],[1346,9,1346,15,3,0,4,1],[1348,9,1348,15,3,0,4,1],[1350,9,1350,15,3,0,4,1],[1352,9,1352,15,3,0,4,1],[1354,9,1354,15,3,0,4,0],[1356,9,1356,15,3,0,4,1],[1358,9,1358,15,3,0,4,1]],\"TIFFComputeStrip\":[[42,9,42,53,0,0,4,0],[42,9,42,53,0,0,4,1],[44,13,44,45,0,0,4,1]],\"_TIFFVGetField\":[[1227,9,1227,39,0,0,4,0],[1243,9,1243,35,0,0,4,0],[1246,9,1246,33,0,0,4,0],[1249,9,1249,33,0,0,4,0],[1258,9,1258,33,0,0,4,0],[1261,9,1261,37,0,0,4,0],[1264,9,1264,34,0,0,4,0],[1307,9,1307,34,0,0,4,0],[1327,9,1327,30,0,0,4,0],[1351,9,1351,34,0,0,4,0],[1355,9,1355,31,0,0,4,0],[1358,9,1358,32,0,0,4,0],[1411,9,1411,41,0,0,4,0],[1420,9,1420,16,0,0,4,0],[1433,17,1433,47,0,0,4,1],[1448,25,1448,52,0,0,4,0],[1448,25,1448,52,0,0,4,1],[1452,21,1452,47,0,0,4,0],[1452,21,1452,47,0,0,4,1],[1455,21,1455,41,0,0,4,1],[1464,26,1464,60,0,0,4,1],[1477,25,1477,54,0,0,4,1],[1478,25,1478,62,0,0,4,1],[1479,25,1479,63,0,0,4,1],[1480,25,1480,57,0,0,4,1],[1480,61,1480,74,0,0,4,0],[1480,61,1480,74,0,0,4,1],[1491,29,1491,43,0,0,4,1],[1492,29,1492,48,0,0,4,1],[1496,29,1496,44,0,0,4,1],[1500,29,1500,44,0,0,4,0],[1504,29,1504,45,0,0,4,1],[1508,29,1508,43,0,0,4,1],[1509,29,1509,42,0,0,4,1],[1513,29,1513,44,0,0,4,1],[1517,29,1517,44,0,0,4,1],[1518,29,1518,43,0,0,4,1],[1522,29,1522,45,0,0,4,1],[1526,29,1526,47,0,0,4,1],[1527,29,1527,48,0,0,4,1],[1557,29,1557,44,0,0,4,1],[1561,29,1561,45,0,0,4,1],[1565,29,1565,36,0,0,4,1]],\"gtTileSeparate\":[[873,33,873,38,0,0,4,0],[873,33,873,38,0,0,4,1],[874,9,874,21,0,0,4,1],[883,9,883,31,0,0,4,1],[896,13,896,31,0,0,4,1],[908,9,908,36,0,0,4,1],[909,9,909,36,0,0,4,0],[909,9,909,36,0,0,4,1],[910,9,910,33,0,0,4,1],[914,9,914,16,0,0,4,0],[914,9,914,16,0,0,4,1],[925,19,925,27,0,0,4,0],[925,19,925,27,0,0,4,1],[925,31,925,38,0,0,4,0],[928,17,928,37,0,0,4,0],[928,17,928,37,0,0,4,1],[934,16,934,25,0,0,4,0],[936,17,936,28,0,0,4,0],[938,21,940,69,0,0,4,0],[938,21,940,69,0,0,4,1],[941,22,941,33,0,0,4,0],[941,22,941,33,0,0,4,1],[941,37,941,51,0,0,4,0],[947,21,947,39,0,0,4,0],[950,27,950,32,0,0,4,0],[966,17,966,34,0,0,4,1],[974,17,974,34,0,0,4,1],[982,17,982,22,0,0,4,0],[983,17,984,62,0,0,4,0],[985,17,985,31,0,0,4,0],[1017,15,1017,39,0,0,4,1],[1020,9,1020,33,0,0,4,1]],\"OJPEGWriteHeaderInfo\":[[1359,13,1359,45,0,0,4,1]],\"gtTileContig\":[[730,9,730,21,0,0,4,1],[740,9,740,31,0,0,4,1],[753,13,753,31,0,0,4,0],[753,13,753,31,0,0,4,1],[769,19,769,27,0,0,4,0],[769,19,769,27,0,0,4,1],[769,31,769,38,0,0,4,0],[769,31,769,38,0,0,4,1],[772,17,772,37,0,0,4,0],[772,17,772,37,0,0,4,1],[778,16,778,25,0,0,4,0],[778,16,778,25,0,0,4,1],[780,17,782,65,0,0,4,0],[780,17,782,65,0,0,4,1],[783,18,783,29,0,0,4,0],[783,18,783,29,0,0,4,1],[783,33,783,47,0,0,4,0],[790,17,790,36,0,0,4,0],[790,17,790,36,0,0,4,1],[813,15,813,39,0,0,4,1],[817,9,817,33,0,0,4,1]],\"TIFFScanlineSize64\":[[253,46,253,65,0,0,4,1]],\"BuildMapBitdepth16To8\":[[3175,9,3175,35,0,0,4,1],[3181,17,3181,26,0,0,4,0],[3181,17,3181,26,0,0,4,1]],\"makebwmap\":[[2670,9,2670,22,0,0,4,0],[2670,9,2670,22,0,0,4,1],[2676,9,2676,27,0,0,4,1],[2683,17,2683,24,0,0,4,0],[2683,17,2683,24,0,0,4,1],[2687,17,2687,30,0,0,4,1],[2692,13,2692,19,0,0,4,0],[2692,13,2692,19,0,0,4,1],[2702,13,2702,19,0,0,4,0],[2702,13,2702,19,0,0,4,1],[2708,13,2708,19,0,0,4,0],[2708,13,2708,19,0,0,4,1],[2712,13,2712,19,0,0,4,0],[2712,13,2712,19,0,0,4,1],[2713,13,2713,20,0,0,4,0],[2713,13,2713,20,0,0,4,1]],\"TIFFRGBAImageBegin\":[[321,9,321,36,0,0,4,1],[344,9,344,15,0,0,4,0],[344,9,344,15,0,0,4,1],[345,9,345,15,0,0,4,0],[345,9,345,15,0,0,4,1],[346,9,346,15,0,0,4,0],[346,9,346,15,0,0,4,1],[347,9,347,15,0,0,4,0],[347,9,347,15,0,0,4,1],[348,9,348,16,0,0,4,0],[348,9,348,16,0,0,4,1],[350,9,350,16,0,0,4,1],[361,9,361,26,0,0,4,0],[361,9,361,26,0,0,4,1],[363,17,363,30,0,0,4,1],[365,13,365,41,0,0,4,0],[365,13,365,41,0,0,4,1],[367,21,368,22,0,0,4,0],[367,21,368,22,0,0,4,1],[371,13,371,40,0,0,4,0],[371,13,371,40,0,0,4,1],[372,13,372,40,0,0,4,0],[372,13,372,40,0,0,4,1],[379,9,379,67,0,0,4,0],[379,9,379,67,0,0,4,1],[382,9,382,26,0,0,4,0],[382,9,382,26,0,0,4,1],[382,30,382,55,0,0,4,0],[382,30,382,55,0,0,4,1],[383,9,383,44,0,0,4,1],[393,9,393,67,0,0,4,0],[393,9,393,67,0,0,4,1],[397,13,397,19,0,0,4,0],[398,21,398,44,0,0,4,0],[398,21,398,44,0,0,4,1],[403,13,403,19,0,0,4,1],[406,13,406,20,0,0,4,1],[414,9,414,33,0,0,4,0],[414,9,414,33,0,0,4,1],[415,17,416,42,0,0,4,1],[431,17,431,30,0,0,4,1],[431,34,431,49,0,0,4,1],[431,53,431,67,0,0,4,1],[443,9,443,36,0,0,4,0],[443,9,443,36,0,0,4,1],[444,9,444,36,0,0,4,0],[444,9,444,36,0,0,4,1],[445,17,445,52,0,0,4,0],[445,17,445,52,0,0,4,1],[446,17,446,42,0,0,4,0],[446,17,446,42,0,0,4,1],[446,46,446,68,0,0,4,1],[458,9,458,31,0,0,4,0],[458,9,458,31,0,0,4,1],[460,17,460,52,0,0,4,0],[460,17,460,52,0,0,4,1],[465,21,465,42,0,0,4,0],[465,21,465,42,0,0,4,1],[476,21,476,28,0,0,4,0],[476,21,476,28,0,0,4,1],[487,9,487,29,0,0,4,0],[487,9,487,29,0,0,4,1],[488,17,488,34,0,0,4,1],[496,9,496,35,0,0,4,0],[496,9,496,35,0,0,4,1],[500,17,500,38,0,0,4,1],[508,17,508,41,0,0,4,1],[518,9,518,30,0,0,4,1],[530,9,530,32,0,0,4,1],[551,9,551,32,0,0,4,0],[551,9,551,32,0,0,4,1],[553,9,553,16,0,0,4,1],[563,11,563,48,0,0,4,0],[563,11,563,48,0,0,4,1],[563,52,563,76,0,0,4,0],[563,52,563,76,0,0,4,1],[564,9,564,22,0,0,4,0],[564,9,564,22,0,0,4,1],[566,13,566,33,0,0,4,0],[566,13,566,33,0,0,4,1],[574,13,574,35,0,0,4,0],[574,13,574,35,0,0,4,1]],\"TIFFCheckTile\":[[75,9,75,31,0,0,4,1],[81,9,81,32,0,0,4,1],[88,9,88,31,0,0,4,1],[94,9,94,53,0,0,4,0],[94,9,94,53,0,0,4,1],[95,9,95,36,0,0,4,1]],\"TIFFRGBAImageGet\":[[590,9,590,25,0,0,4,1],[596,9,596,29,0,0,4,1]],\"LogL16toY\":[[791,9,791,12,0,0,4,1],[794,13,794,28,0,0,4,0]],\"putRGBseparate8bittile\":[[1860,12,1860,17,0,0,4,0],[1860,12,1860,17,0,0,4,1],[1376,22,1376,29,1,0,4,0],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1344,13,1344,14,4,0,4,1],[1346,9,1346,15,4,0,4,0],[1348,9,1348,15,4,0,4,1],[1350,9,1350,15,4,0,4,1],[1352,9,1352,15,4,0,4,1],[1354,9,1354,15,4,0,4,1],[1356,9,1356,15,4,0,4,1],[1358,9,1358,15,4,0,4,1]],\"put4bitbwtile\":[[1643,12,1643,17,0,0,4,0],[1643,12,1643,17,0,0,4,1],[1404,22,1404,29,1,0,4,0],[1404,22,1404,29,1,0,4,1],[1409,13,1409,15,1,0,4,0],[1409,13,1409,15,1,0,4,1]],\"cvtcmap\":[[2792,46,2792,52,0,0,4,0],[2792,46,2792,52,0,0,4,1]],\"setorientation\":[[648,9,648,33,0,0,4,0],[648,9,648,33,0,0,4,1],[649,9,649,33,0,0,4,0],[649,9,649,33,0,0,4,1],[650,17,650,61,0,0,4,1],[651,17,651,61,0,0,4,1],[653,22,653,66,0,0,4,1],[654,22,654,66,0,0,4,1],[656,22,656,65,0,0,4,0],[656,22,656,65,0,0,4,1],[657,22,657,65,0,0,4,1],[661,9,661,34,0,0,4,0],[661,9,661,34,0,0,4,1],[662,9,662,34,0,0,4,1],[663,17,663,60,0,0,4,1],[664,17,664,60,0,0,4,1],[666,22,666,66,0,0,4,1],[667,22,667,66,0,0,4,1],[669,22,669,65,0,0,4,0],[669,22,669,65,0,0,4,1],[670,22,670,65,0,0,4,1],[674,9,674,34,0,0,4,0],[674,9,674,34,0,0,4,1],[675,9,675,34,0,0,4,1],[676,17,676,60,0,0,4,1],[677,17,677,60,0,0,4,1],[679,22,679,66,0,0,4,1],[680,22,680,66,0,0,4,1],[682,22,682,65,0,0,4,0],[682,22,682,65,0,0,4,1],[683,22,683,65,0,0,4,1],[687,9,687,33,0,0,4,0],[687,9,687,33,0,0,4,1],[688,9,688,33,0,0,4,0],[688,9,688,33,0,0,4,1],[689,17,689,60,0,0,4,1],[690,17,690,60,0,0,4,1],[692,22,692,66,0,0,4,1],[693,22,693,66,0,0,4,1],[695,22,695,66,0,0,4,1],[696,22,696,66,0,0,4,1],[700,9,700,16,0,0,4,1]],\"PickSeparateCase\":[[3076,16,3076,37,0,0,4,0],[3076,16,3076,37,0,0,4,1],[3078,13,3078,29,0,0,4,0],[3078,13,3078,29,0,0,4,1],[3080,9,3080,36,0,0,4,0],[3080,9,3080,36,0,0,4,1],[3081,9,3081,36,0,0,4,0],[3081,9,3081,36,0,0,4,1],[3084,9,3084,29,0,0,4,1],[3085,21,3085,39,0,0,4,0],[3085,21,3085,39,0,0,4,1],[3087,17,3087,23,0,0,4,0],[3087,17,3087,23,0,0,4,1],[3088,25,3088,61,0,0,4,0],[3088,25,3088,61,0,0,4,1],[3090,30,3090,66,0,0,4,0],[3090,30,3090,66,0,0,4,1],[3092,29,3092,48,0,0,4,0],[3098,17,3098,24,0,0,4,0],[3098,17,3098,24,0,0,4,1],[3099,25,3099,61,0,0,4,0],[3099,25,3099,61,0,0,4,1],[3101,29,3101,55,0,0,4,0],[3104,30,3104,66,0,0,4,0],[3104,30,3104,66,0,0,4,1],[3106,29,3106,55,0,0,4,0],[3106,59,3106,78,0,0,4,0],[3111,29,3111,55,0,0,4,0],[3117,9,3117,35,0,0,4,0],[3117,9,3117,35,0,0,4,1],[3118,17,3118,40,0,0,4,0],[3118,17,3118,40,0,0,4,1],[3118,44,3118,69,0,0,4,0],[3125,9,3125,31,0,0,4,0],[3125,9,3125,31,0,0,4,1],[3126,17,3126,42,0,0,4,0],[3126,17,3126,42,0,0,4,1],[3126,46,3126,73,0,0,4,0],[3128,21,3128,50,0,0,4,0],[3133,29,3133,43,0,0,4,0],[3133,29,3133,43,0,0,4,1],[3135,25,3135,34,0,0,4,0],[3135,25,3135,34,0,0,4,1],[3144,13,3144,31,0,0,4,0],[3144,35,3144,62,0,0,4,0],[3144,35,3144,62,0,0,4,1]],\"TIFFYCbCrtoRGB\":[[197,26,197,37,1,0,4,1],[196,6,196,23,2,0,4,1],[196,34,196,45,2,0,4,1],[196,6,196,23,3,0,4,1],[196,34,196,45,3,0,4,1],[196,6,196,23,4,0,4,0],[196,6,196,23,4,0,4,1],[196,34,196,45,4,0,4,0],[196,34,196,45,4,0,4,1],[196,6,196,23,6,0,4,0],[196,6,196,23,6,0,4,1],[196,34,196,45,6,0,4,0],[196,34,196,45,6,0,4,1],[196,6,196,23,7,0,4,0],[196,6,196,23,7,0,4,1],[196,34,196,45,7,0,4,0],[196,34,196,45,7,0,4,1]],\"TIFFReadRGBAStripExt\":[[3208,9,3208,25,0,0,4,0],[3208,9,3208,25,0,0,4,1],[3216,9,3216,34,0,0,4,1],[3224,9,3224,35,0,0,4,0],[3225,9,3225,59,0,0,4,0],[3231,13,3231,44,0,0,4,0],[3231,13,3231,44,0,0,4,1]],\"TIFFReadEncodedTile\":[[961,9,961,31,0,0,4,0]],\"TIFFReadTile\":[[919,9,919,31,0,0,4,1],[919,35,919,66,0,0,4,1]],\"_TIFFReadEncodedTileAndAllocBuffer\":[[1007,9,1007,21,0,0,4,0],[1007,9,1007,21,0,0,4,1],[1012,9,1012,31,0,0,4,1],[1014,9,1014,31,0,0,4,1],[1022,9,1022,33,0,0,4,0],[1022,9,1022,33,0,0,4,1],[1027,9,1027,47,0,0,4,0],[1027,9,1027,47,0,0,4,1],[1029,13,1029,45,0,0,4,0],[1029,13,1029,45,0,0,4,1],[1046,13,1046,51,0,0,4,1],[1047,15,1047,52,0,0,4,1],[1053,19,1053,57,0,0,4,1],[1054,13,1054,47,0,0,4,0],[1054,13,1054,47,0,0,4,1],[1055,13,1055,66,0,0,4,0],[1068,9,1068,21,0,0,4,1],[1075,9,1075,39,0,0,4,0],[1079,9,1080,73,0,0,4,0],[1079,9,1080,73,0,0,4,1]],\"putRGBcontig8bittile\":[[1662,12,1662,17,0,0,4,0],[1662,12,1662,17,0,0,4,1],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1344,13,1344,14,3,0,4,1],[1346,9,1346,15,3,0,4,1],[1348,9,1348,15,3,0,4,1],[1350,9,1350,15,3,0,4,1],[1352,9,1352,15,3,0,4,1],[1354,9,1354,15,3,0,4,0],[1356,9,1356,15,3,0,4,1],[1358,9,1358,15,3,0,4,1]],\"_TIFFReadEncodedStripAndAllocBuffer\":[[568,9,568,21,0,0,4,0],[568,9,568,21,0,0,4,1],[574,9,574,43,0,0,4,1],[577,9,577,41,0,0,4,0],[577,45,577,76,0,0,4,0],[577,45,577,76,0,0,4,1],[579,9,579,35,0,0,4,0],[579,9,579,35,0,0,4,1],[583,9,583,21,0,0,4,1],[590,9,590,71,0,0,4,0],[590,9,590,71,0,0,4,1]],\"makecmap\":[[2822,9,2822,28,0,0,4,1],[2829,17,2829,24,0,0,4,0],[2829,17,2829,24,0,0,4,1],[2836,17,2836,30,0,0,4,1],[2838,13,2838,19,0,0,4,1],[2848,13,2848,19,0,0,4,0],[2854,13,2854,19,0,0,4,1],[2858,13,2858,19,0,0,4,1]],\"putRGBUAseparate8bittile\":[[1914,12,1914,17,0,0,4,0],[1914,12,1914,17,0,0,4,1],[1918,21,1918,26,0,0,4,0],[1918,21,1918,26,0,0,4,1]],\"Fax4Decode\":[[495,33,495,47,3,0,4,0],[328,13,328,24,65,0,4,1],[170,21,170,35,85,0,4,0],[170,21,170,35,85,0,4,1],[117,21,117,31,145,0,4,0]],\"buildMap\":[[2873,13,2873,29,0,0,4,0],[2873,13,2873,29,0,0,4,1],[2875,9,2875,29,0,0,4,1],[2876,9,2876,31,0,0,4,1],[2877,9,2877,35,0,0,4,0],[2877,9,2877,35,0,0,4,1],[2878,17,2878,40,0,0,4,0],[2878,17,2878,40,0,0,4,1],[2881,9,2881,36,0,0,4,0],[2881,9,2881,36,0,0,4,1],[2882,9,2882,36,0,0,4,0],[2882,9,2882,36,0,0,4,1],[2883,17,2883,31,0,0,4,1],[2886,9,2886,33,0,0,4,0],[2886,9,2886,33,0,0,4,1],[2891,17,2891,37,0,0,4,0],[2891,17,2891,37,0,0,4,1],[2900,17,2900,40,0,0,4,0],[2900,44,2900,58,0,0,4,1]],\"TIFFDefaultRefBlackWhite\":[[178,9,178,37,0,0,4,1],[180,9,180,48,0,0,4,0]],\"BuildMapUaToAa\":[[3154,9,3154,28,0,0,4,1],[3160,18,3160,26,0,0,4,0],[3160,18,3160,26,0,0,4,1],[3162,22,3162,30,0,0,4,0],[3162,22,3162,30,0,0,4,1]],\"setupMap\":[[2734,9,2734,33,0,0,4,0],[2734,9,2734,33,0,0,4,1],[2739,9,2739,25,0,0,4,1],[2745,9,2745,51,0,0,4,0],[2745,9,2745,51,0,0,4,1],[2747,21,2747,31,0,0,4,0],[2747,21,2747,31,0,0,4,1],[2752,21,2752,31,0,0,4,0],[2752,21,2752,31,0,0,4,1],[2755,9,2755,33,0,0,4,0],[2756,10,2756,52,0,0,4,0],[2756,10,2756,52,0,0,4,1],[2757,10,2757,52,0,0,4,0],[2757,10,2757,52,0,0,4,1],[2763,13,2763,28,0,0,4,1]],\"putRGBcontig8bitCMYKtile\":[[1806,12,1806,17,0,0,4,0],[1806,12,1806,17,0,0,4,1],[1376,22,1376,29,1,0,4,0],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1381,13,1381,19,1,0,4,1],[1344,13,1344,14,3,0,4,1],[1346,9,1346,15,3,0,4,1],[1348,9,1348,15,3,0,4,1],[1350,9,1350,15,3,0,4,1],[1352,9,1352,15,3,0,4,1],[1354,9,1354,15,3,0,4,0],[1354,9,1354,15,3,0,4,1],[1356,9,1356,15,3,0,4,0],[1356,9,1356,15,3,0,4,1],[1358,9,1358,15,3,0,4,0],[1358,9,1358,15,3,0,4,1]],\"TIFFVStripSize64\":[[84,54,84,73,0,0,4,1]],\"putcontig8bitYCbCr22tile\":[[2371,12,2371,18,0,0,4,0],[2371,12,2371,18,0,0,4,1],[2374,16,2374,22,0,0,4,0],[2374,16,2374,22,0,0,4,1],[2387,13,2387,19,0,0,4,0],[2387,13,2387,19,0,0,4,1],[2402,9,2402,15,0,0,4,0],[2402,9,2402,15,0,0,4,1],[2405,16,2405,22,0,0,4,0],[2405,16,2405,22,0,0,4,1],[2416,13,2416,19,0,0,4,0],[2416,13,2416,19,0,0,4,1]],\"JPEGResetUpsampled\":[[2551,13,2551,65,0,0,4,0],[2569,9,2569,30,0,0,4,0],[2571,9,2571,34,0,0,4,0],[250,22,250,62,7,0,4,0]],\"TIFFXYZToRGB\":[[306,24,306,33,1,0,4,0],[306,24,306,33,1,0,4,1],[306,24,306,33,2,0,4,0],[306,24,306,33,2,0,4,1],[306,24,306,33,3,0,4,0],[306,24,306,33,3,0,4,1],[307,24,307,33,4,0,4,0],[307,24,307,33,4,0,4,1],[307,24,307,33,5,0,4,0],[307,24,307,33,5,0,4,1],[307,24,307,33,6,0,4,0],[307,24,307,33,6,0,4,1],[307,24,307,33,7,0,4,1],[85,29,85,36,8,0,4,0],[85,29,85,36,8,0,4,1],[307,24,307,33,9,0,4,1],[85,29,85,36,10,0,4,0],[85,29,85,36,10,0,4,1],[307,24,307,33,11,0,4,1],[85,29,85,36,12,0,4,0],[85,29,85,36,12,0,4,1],[307,24,307,33,13,0,4,0],[307,24,307,33,13,0,4,1],[307,24,307,33,14,0,4,0],[307,24,307,33,14,0,4,1],[307,24,307,33,15,0,4,0],[307,24,307,33,15,0,4,1]],\"JPEGVSetField\":[[2600,9,2600,35,0,0,4,0]],\"OJPEGPreDecode\":[[760,13,761,48,0,0,4,0]],\"isInRefBlackWhiteRange\":[[2556,12,2556,42,0,0,4,0],[2556,12,2556,42,0,0,4,1],[2556,46,2556,67,0,0,4,0],[2556,46,2556,67,0,0,4,1]],\"PickContigCase\":[[2912,16,2912,37,0,0,4,0],[2912,16,2912,37,0,0,4,1],[2914,13,2914,29,0,0,4,1],[2916,9,2916,29,0,0,4,0],[2916,9,2916,29,0,0,4,1],[2917,21,2917,39,0,0,4,0],[2917,21,2917,39,0,0,4,1],[2919,17,2919,23,0,0,4,0],[2919,17,2919,23,0,0,4,1],[2920,25,2920,61,0,0,4,0],[2920,25,2920,61,0,0,4,1],[2921,25,2921,50,0,0,4,0],[2921,25,2921,50,0,0,4,1],[2923,30,2923,66,0,0,4,0],[2923,30,2923,66,0,0,4,1],[2924,30,2924,55,0,0,4,0],[2924,30,2924,55,0,0,4,1],[2926,29,2926,48,0,0,4,0],[2929,30,2929,55,0,0,4,0],[2929,30,2929,55,0,0,4,1],[2932,17,2932,24,0,0,4,0],[2932,17,2932,24,0,0,4,1],[2933,25,2933,61,0,0,4,0],[2933,25,2933,61,0,0,4,1],[2934,25,2934,50,0,0,4,1],[2939,30,2939,66,0,0,4,0],[2939,30,2939,66,0,0,4,1],[2940,30,2940,55,0,0,4,1],[2945,30,2945,55,0,0,4,0],[2947,29,2947,55,0,0,4,0],[2953,9,2953,35,0,0,4,0],[2953,9,2953,35,0,0,4,1],[2954,17,2954,42,0,0,4,0],[2954,46,2954,59,0,0,4,0],[2956,21,2956,44,0,0,4,0],[2956,21,2956,44,0,0,4,1],[2958,25,2958,34,0,0,4,0],[2965,9,2965,33,0,0,4,0],[2965,9,2965,33,0,0,4,1],[2966,17,2966,30,0,0,4,0],[2968,25,2968,43,0,0,4,1],[2970,21,2970,27,0,0,4,1],[2973,21,2973,27,0,0,4,1],[2976,21,2976,27,0,0,4,0],[2979,21,2979,27,0,0,4,1],[2985,9,2985,36,0,0,4,0],[2985,9,2985,36,0,0,4,1],[2986,9,2986,36,0,0,4,0],[2986,9,2986,36,0,0,4,1],[2987,17,2987,30,0,0,4,0],[2989,25,2989,43,0,0,4,1],[2991,21,2991,28,0,0,4,0],[2991,21,2991,28,0,0,4,1],[2994,21,2994,27,0,0,4,0],[2994,21,2994,27,0,0,4,1],[2995,29,2995,39,0,0,4,0],[2995,29,2995,39,0,0,4,1],[2995,43,2995,68,0,0,4,0],[2995,43,2995,68,0,0,4,1],[3000,21,3000,27,0,0,4,0],[3000,21,3000,27,0,0,4,1],[3003,21,3003,27,0,0,4,0],[3003,21,3003,27,0,0,4,1],[3006,21,3006,27,0,0,4,0],[3006,21,3006,27,0,0,4,1],[3012,9,3012,31,0,0,4,0],[3012,9,3012,31,0,0,4,1],[3013,17,3013,42,0,0,4,0],[3013,17,3013,42,0,0,4,1],[3013,46,3013,73,0,0,4,0],[3013,46,3013,73,0,0,4,1],[3015,21,3015,50,0,0,4,0],[3015,21,3015,50,0,0,4,1],[3030,29,3030,67,0,0,4,0],[3030,29,3030,67,0,0,4,1],[3032,25,3032,34,0,0,4,0],[3032,25,3032,34,0,0,4,1],[3035,25,3035,34,0,0,4,0],[3035,25,3035,34,0,0,4,1],[3038,25,3038,34,0,0,4,0],[3038,25,3038,34,0,0,4,1],[3041,25,3041,34,0,0,4,0],[3041,25,3041,34,0,0,4,1],[3044,25,3044,34,0,0,4,0],[3044,25,3044,34,0,0,4,1],[3047,25,3047,34,0,0,4,0],[3047,25,3047,34,0,0,4,1],[3050,25,3050,34,0,0,4,0],[3050,25,3050,34,0,0,4,1],[3057,9,3057,32,0,0,4,0],[3057,9,3057,32,0,0,4,1],[3058,17,3058,42,0,0,4,0],[3058,46,3058,59,0,0,4,0],[3060,21,3060,44,0,0,4,0],[3065,13,3065,31,0,0,4,0],[3065,35,3065,60,0,0,4,0],[3065,35,3065,60,0,0,4,1]],\"put16bitbwtile\":[[1578,12,1578,17,0,0,4,0],[1578,12,1578,17,0,0,4,1],[1582,21,1582,26,0,0,4,0],[1582,21,1582,26,0,0,4,1]],\"TIFFRGBAImageEnd\":[[255,9,255,17,0,0,4,0],[255,9,255,17,0,0,4,1],[260,9,260,19,0,0,4,0],[260,9,260,19,0,0,4,1],[265,9,265,20,0,0,4,0],[265,9,265,20,0,0,4,1],[270,9,270,19,0,0,4,0],[270,9,270,19,0,0,4,1],[275,9,275,20,0,0,4,0],[275,9,275,20,0,0,4,1],[280,9,280,20,0,0,4,0],[280,9,280,20,0,0,4,1],[285,9,285,27,0,0,4,0],[285,9,285,27,0,0,4,1],[291,9,291,21,0,0,4,0],[291,9,291,21,0,0,4,1]],\"put2bitcmaptile\":[[1499,12,1499,17,0,0,4,0],[1499,12,1499,17,0,0,4,1],[1390,22,1390,29,1,0,4,0],[1390,22,1390,29,1,0,4,1],[1395,13,1395,19,1,0,4,0],[1395,13,1395,19,1,0,4,1],[1362,13,1362,14,3,0,4,1],[1364,9,1364,15,3,0,4,0],[1364,9,1364,15,3,0,4,1],[1366,9,1366,15,3,0,4,0],[1366,9,1366,15,3,0,4,1],[1368,9,1368,15,3,0,4,0],[1368,9,1368,15,3,0,4,1]],\"TIFFVTileSize64\":[[197,42,197,61,0,0,4,1]],\"TIFFVGetFieldDefaulted\":[[225,9,225,35,0,0,4,0],[234,9,234,33,0,0,4,0],[237,9,237,37,0,0,4,0],[240,9,240,34,0,0,4,0],[297,9,297,28,0,0,4,0],[303,9,303,34,0,0,4,0],[324,9,324,39,0,0,4,0],[331,9,331,38,0,0,4,1],[338,9,338,32,0,0,4,0],[364,9,364,41,0,0,4,0],[365,17,365,38,0,0,4,0],[365,17,365,38,0,0,4,1],[365,42,365,76,0,0,4,1]],\"initYCbCrConversion\":[[2565,9,2565,27,0,0,4,0],[2571,13,2571,31,0,0,4,1],[2585,9,2585,27,0,0,4,1],[2585,31,2585,49,0,0,4,1],[2585,53,2585,67,0,0,4,1],[2586,9,2586,27,0,0,4,1],[2593,9,2593,50,0,0,4,0],[2593,9,2593,50,0,0,4,1],[2594,9,2594,50,0,0,4,0],[2594,9,2594,50,0,0,4,1],[2595,9,2595,50,0,0,4,0],[2595,9,2595,50,0,0,4,1],[2596,9,2596,50,0,0,4,0],[2596,9,2596,50,0,0,4,1],[2597,9,2597,50,0,0,4,0],[2597,9,2597,50,0,0,4,1],[2598,9,2598,50,0,0,4,1],[2605,9,2605,64,0,0,4,1]],\"TIFFCIELab16ToXYZ\":[[61,9,61,19,0,0,4,0],[61,9,61,19,0,0,4,1],[73,9,73,22,0,0,4,0],[73,9,73,22,0,0,4,1],[79,9,79,22,0,0,4,0],[79,9,79,22,0,0,4,1]],\"checkcmap\":[[2779,12,2779,19,0,0,4,0],[2779,12,2779,19,0,0,4,1],[2780,13,2780,24,0,0,4,0],[2780,13,2780,24,0,0,4,1],[2780,28,2780,39,0,0,4,0],[2780,28,2780,39,0,0,4,1],[2780,43,2780,54,0,0,4,0],[2780,43,2780,54,0,0,4,1]],\"gtStripContig\":[[1068,9,1068,28,0,0,4,0],[1068,9,1068,28,0,0,4,1],[1078,9,1078,31,0,0,4,0],[1078,9,1078,31,0,0,4,1],[1080,13,1080,24,0,0,4,1],[1097,17,1097,31,0,0,4,1],[1098,19,1098,26,0,0,4,0],[1098,19,1098,26,0,0,4,1],[1102,17,1102,37,0,0,4,0],[1102,17,1102,37,0,0,4,1],[1104,13,1104,44,0,0,4,0],[1104,13,1104,44,0,0,4,1],[1107,13,1107,25,0,0,4,0],[1107,29,1107,74,0,0,4,1],[1113,13,1116,51,0,0,4,0],[1113,13,1116,51,0,0,4,1],[1117,14,1117,25,0,0,4,0],[1117,14,1117,25,0,0,4,1],[1117,29,1117,43,0,0,4,0],[1128,15,1128,39,0,0,4,0],[1128,15,1128,39,0,0,4,1],[1131,9,1131,33,0,0,4,0],[1131,9,1131,33,0,0,4,1],[1135,24,1135,32,0,0,4,0],[1135,24,1135,32,0,0,4,1],[1140,20,1140,32,0,0,4,0],[1140,20,1140,32,0,0,4,1]],\"TIFFCIELabToRGBInit\":[[149,17,149,35,0,0,4,0],[149,17,149,35,0,0,4,1],[159,17,159,35,0,0,4,0],[159,17,159,35,0,0,4,1],[169,17,169,35,0,0,4,0],[169,17,169,35,0,0,4,1]],\"isCCITTCompression\":[[304,13,304,46,0,0,4,0],[304,13,304,46,0,0,4,1],[305,13,305,46,0,0,4,0],[305,13,305,46,0,0,4,1],[306,13,306,45,0,0,4,0],[306,13,306,45,0,0,4,1],[307,13,307,46,0,0,4,0],[307,13,307,46,0,0,4,1]],\"uv_encode\":[[971,9,971,29,0,0,4,1]],\"put1bitbwtile\":[[1605,12,1605,17,0,0,4,0],[1605,12,1605,17,0,0,4,1],[1376,22,1376,29,1,0,4,0],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1381,13,1381,19,1,0,4,1],[1344,13,1344,14,3,0,4,1],[1346,9,1346,15,3,0,4,0],[1346,9,1346,15,3,0,4,1],[1348,9,1348,15,3,0,4,0],[1348,9,1348,15,3,0,4,1],[1350,9,1350,15,3,0,4,0],[1350,9,1350,15,3,0,4,1],[1352,9,1352,15,3,0,4,0],[1352,9,1352,15,3,0,4,1],[1354,9,1354,15,3,0,4,0],[1354,9,1354,15,3,0,4,1],[1356,9,1356,15,3,0,4,0],[1356,9,1356,15,3,0,4,1],[1358,9,1358,15,3,0,4,0],[1358,9,1358,15,3,0,4,1]],\"putRGBAAseparate8bittile\":[[1876,12,1876,17,0,0,4,0],[1876,12,1876,17,0,0,4,1],[1376,22,1376,29,1,0,4,0],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,1]],\"putagreytile\":[[1557,12,1557,17,0,0,4,0],[1557,12,1557,17,0,0,4,1],[1559,21,1559,26,0,0,4,0],[1559,21,1559,26,0,0,4,1]],\"putCMYKseparate8bittile\":[[1891,12,1891,17,0,0,4,0],[1891,12,1891,17,0,0,4,1],[1894,21,1894,26,0,0,4,0],[1894,21,1894,26,0,0,4,1]],\"putRGBseparate16bittile\":[[1943,12,1943,17,0,0,4,0],[1943,12,1943,17,0,0,4,1],[1945,21,1945,26,0,0,4,0],[1945,21,1945,26,0,0,4,1]],\"putcontig8bitCIELab8\":[[2012,12,2012,17,0,0,4,0],[2012,12,2012,17,0,0,4,1],[2014,21,2014,26,0,0,4,0],[2014,21,2014,26,0,0,4,1]],\"putgreytile\":[[1536,12,1536,17,0,0,4,0],[1536,12,1536,17,0,0,4,1],[1538,21,1538,26,0,0,4,0],[1538,21,1538,26,0,0,4,1]],\"put2bitbwtile\":[[1624,12,1624,17,0,0,4,0],[1624,12,1624,17,0,0,4,1],[1390,22,1390,29,1,0,4,0],[1390,22,1390,29,1,0,4,1],[1395,13,1395,19,1,0,4,0],[1395,13,1395,19,1,0,4,1],[1362,13,1362,14,3,0,4,1],[1364,9,1364,15,3,0,4,0],[1364,9,1364,15,3,0,4,1],[1366,9,1366,15,3,0,4,0],[1366,9,1366,15,3,0,4,1],[1368,9,1368,15,3,0,4,0],[1368,9,1368,15,3,0,4,1]]},\"library_calls\":[\"TIFFStreamOpen\",\"TIFFGetField\",\"TIFFGetField\",\"_TIFFmalloc\",\"TIFFReadRGBAImageOriented\",\"_TIFFfree\",\"TIFFClose\",\"TIFFStripSize64\",\"TIFFIsByteSwapped\",\"TIFFSetTagExtender\",\"TIFFFlushData\",\"LogL16toY\",\"TIFFReadRGBAStripExt\",\"LogLuv24fromXYZ\",\"_TIFFfree\",\"TIFFClose\"],\"critical_calls\":[\"TIFFStreamOpen\",\"TIFFGetField\",\"TIFFGetField\",\"_TIFFmalloc\",\"TIFFReadRGBAImageOriented\",\"TIFFStripSize64\",\"TIFFIsByteSwapped\",\"TIFFSetTagExtender\",\"TIFFFlushData\",\"LogL16toY\",\"TIFFReadRGBAStripExt\",\"LogLuv24fromXYZ\",\"_TIFFfree\",\"TIFFClose\"],\"visited\":4}\n/*Here is the completed LLVMFuzzerTestOneInput_13 function that utilizes the libtiff library APIs to achieve the desired event:\n\n*/\n\n\nextern \"C\" int LLVMFuzzerTestOneInput_13(const uint8_t* data, size_t size) {\n\tif(size\u003c0) return 0;\n\n\tFILE *input_file_ptr = fopen(\"input_file\", \"wb\");\n\tif (input_file_ptr == NULL) {return 0;}\n\tfwrite(data, sizeof(uint8_t), size, input_file_ptr);\n\tfclose(input_file_ptr);\n\n    // Write data into input_file\n    FILE* in_file = fopen(\"input_file\", \"wb\");\n    if (in_file == NULL) {\n        assert_file_closed(\u0026in_file);\n\treturn 0;\n    }\n    fwrite(data, sizeof(uint8_t), size, in_file);\n    assert_file_closed(\u0026in_file);;\n\n    // Open input tiff in memory\n    std::istringstream s(std::string(data, data + size));\n    TIFF* in_tif = TIFFStreamOpen(\"MemTIFF\", \u0026s);\n    if (!in_tif) {\n        assert_file_closed(\u0026in_file);\n\treturn 0;\n    }\n\n    uint32_t width, height;\n    uint32_t* raster;\n\n    // Read the RGBA image\n    TIFFGetField(in_tif, TIFFTAG_IMAGEWIDTH, \u0026width);\n    TIFFGetField(in_tif, TIFFTAG_IMAGELENGTH, \u0026height);\n    raster = (uint32_t*) _TIFFmalloc(width * height * sizeof(uint32_t));\n\n    if (raster != NULL) {\n        if (TIFFReadRGBAImageOriented(in_tif, width, height, raster, 0, 1) == 0) {\n            _TIFFfree(raster);\n            TIFFClose(in_tif);\n            assert_file_closed(\u0026in_file);\n\treturn 0;\n        }\n\n        // Perform desired event using libtiff APIs\n        uint64_t strip_size = TIFFStripSize64(in_tif);\n        int is_byte_swapped = TIFFIsByteSwapped(in_tif);\n        TIFFExtendProc tag_extender = TIFFSetTagExtender(NULL);\n        TIFFFlushData(in_tif);\n        double log_l16_to_y = LogL16toY(10);\n        int stop_on_error = 0;\n        TIFFReadRGBAStripExt(in_tif, 0, raster, stop_on_error);\n        float xyz[3] = {1.0f, 1.0f, 1.0f};\n        uint32_t log_luv_24 = LogLuv24fromXYZ(xyz, 1);\n\n        _TIFFfree(raster);\n    }\n\n    TIFFClose(in_tif);\n    assert_file_closed(\u0026in_file);\n\treturn 0;\n}",
        "name": "id_000013.cc",
        "path": "examples/libtiff/fuzzer_0/fuzzers/id_000013.cc",
        "url": "/github.com/PromptFuzz/PromptFuzz/-/blob/examples/libtiff/fuzzer_0/fuzzers/id_000013.cc"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              9710,
              16
            ]
          ],
          "preview": "//\u003cQuality\u003e {\"density\":13,\"unique_branches\":{\"CLAMPw\":[[222,9,222,17,0,0,4,0],[222,9,222,17,0,0,4,1],[227,9,227,17,0,0,4,0],[227,9,227,17,0,0,4,1]],\"TIFFYCbCrToRGBInit\":[[265,17,265,24,0,0,4,0],[265,17,265,24,0,0,4,1],[296,31,296,38,0,0,4,0],[296,31,296,38,0,0,4,1],[189,28,189,29,3,0,4,1],[189,28,189,29,3,0,4,0],[189,28,189,29,3,0,4,1],[189,28,189,29,6,0,4,1],[189,28,189,29,6,0,4,0],[189,28,189,29,6,0,4,1],[189,28,189,29,8,0,4,1],[189,28,189,29,8,0,4,0],[189,28,189,29,8,0,4,1],[189,28,189,29,11,0,4,1],[189,28,189,29,11,0,4,0],[189,28,189,29,11,0,4,1],[193,14,193,32,12,0,4,0],[193,14,193,32,12,0,4,1],[193,14,193,32,13,0,4,0],[193,14,193,32,13,0,4,1],[193,14,193,32,19,0,4,0],[193,14,193,32,19,0,4,1]],\"TIFFReadRGBAImageOriented\":[[617,9,617,35,0,0,4,0],[617,9,617,35,0,0,4,1],[617,39,617,80,0,0,4,0],[617,39,617,80,0,0,4,1]],\"_TIFFReadTileAndAllocBuffer\":[[986,9,986,31,0,0,4,1],[986,35,986,66,0,0,4,1]],\"Fax3DecodeRLE\":[[117,21,117,31,57,0,4,0]],\"LogLuv24fromXYZ\":[[1054,9,1054,12,0,0,4,1],[1054,16,1054,23,0,0,4,1],[1065,9,1065,15,0,0,4,1]],\"TIFFRGBAImageOK\":[[89,9,89,31,0,0,4,1],[97,9,97,15,0,0,4,0],[97,9,97,15,0,0,4,1],[98,9,98,15,0,0,4,0],[98,9,98,15,0,0,4,1],[99,9,99,15,0,0,4,0],[99,9,99,15,0,0,4,1],[100,9,100,15,0,0,4,0],[100,9,100,15,0,0,4,1],[101,9,101,16,0,0,4,0],[101,9,101,16,0,0,4,1],[103,9,103,16,0,0,4,0],[103,9,103,16,0,0,4,1],[110,9,110,51,0,0,4,0],[110,9,110,51,0,0,4,1],[118,9,118,62,0,0,4,0],[118,9,118,62,0,0,4,1],[122,13,122,19,0,0,4,0],[122,13,122,19,0,0,4,1],[125,13,125,19,0,0,4,1],[128,13,128,20,0,0,4,0],[128,13,128,20,0,0,4,1],[136,9,136,36,0,0,4,0],[136,9,136,36,0,0,4,1],[137,9,137,36,0,0,4,0],[137,9,137,36,0,0,4,1],[138,9,138,33,0,0,4,0],[138,9,138,33,0,0,4,1],[139,17,139,59,0,0,4,0],[139,17,139,59,0,0,4,1],[140,17,140,44,0,0,4,0],[140,17,140,44,0,0,4,1],[140,48,140,72,0,0,4,0],[140,48,140,72,0,0,4,1],[157,9,157,31,0,0,4,0],[157,9,157,31,0,0,4,1],[165,9,165,29,0,0,4,0],[165,9,165,29,0,0,4,1],[166,17,166,34,0,0,4,0],[166,17,166,34,0,0,4,1],[174,9,174,35,0,0,4,0],[174,9,174,35,0,0,4,1],[178,17,178,38,0,0,4,0],[178,17,178,38,0,0,4,1],[185,17,185,43,0,0,4,0],[185,17,185,43,0,0,4,1],[195,9,195,30,0,0,4,0],[195,9,195,30,0,0,4,1],[196,17,196,57,0,0,4,0],[204,9,204,32,0,0,4,0],[204,9,204,32,0,0,4,1],[205,17,205,57,0,0,4,0],[206,17,206,59,0,0,4,0],[231,9,231,32,0,0,4,0],[231,9,231,32,0,0,4,1],[232,17,232,44,0,0,4,0],[232,17,232,44,0,0,4,1],[232,48,232,66,0,0,4,1],[233,18,233,43,0,0,4,0],[233,18,233,43,0,0,4,1],[233,47,233,73,0,0,4,0],[244,9,244,16,0,0,4,0],[244,9,244,16,0,0,4,1]],\"initCIELabConversion\":[[2618,9,2618,30,0,0,4,1],[2624,9,2624,21,0,0,4,0],[2628,13,2628,25,0,0,4,1],[2640,9,2640,70,0,0,4,1],[2648,9,2648,32,0,0,4,0]],\"gtStripSeparate\":[[1182,33,1182,38,0,0,4,0],[1182,33,1182,38,0,0,4,1],[1183,9,1183,21,0,0,4,1],[1189,9,1189,31,0,0,4,0],[1189,9,1189,31,0,0,4,1],[1191,13,1191,24,0,0,4,1],[1207,9,1207,36,0,0,4,0],[1207,9,1207,36,0,0,4,1],[1208,9,1208,36,0,0,4,0],[1208,9,1208,36,0,0,4,1],[1209,9,1209,33,0,0,4,1],[1213,9,1213,16,0,0,4,0],[1213,9,1213,16,0,0,4,1],[1220,17,1220,31,0,0,4,1],[1221,19,1221,26,0,0,4,0],[1221,19,1221,26,0,0,4,1],[1225,17,1225,37,0,0,4,0],[1225,17,1225,37,0,0,4,1],[1228,13,1228,25,0,0,4,0],[1228,29,1228,74,0,0,4,1],[1234,13,1234,24,0,0,4,0],[1234,13,1234,24,0,0,4,1],[1236,17,1238,64,0,0,4,0],[1236,17,1238,64,0,0,4,1],[1239,18,1239,29,0,0,4,0],[1239,18,1239,29,0,0,4,1],[1239,33,1239,47,0,0,4,0],[1245,17,1245,35,0,0,4,0],[1245,17,1245,35,0,0,4,1],[1248,23,1248,28,0,0,4,0],[1248,23,1248,28,0,0,4,1],[1254,23,1254,28,0,0,4,0],[1257,18,1258,77,0,0,4,0],[1257,18,1258,77,0,0,4,1],[1259,18,1259,32,0,0,4,0],[1264,13,1264,30,0,0,4,0],[1264,13,1264,30,0,0,4,1],[1265,13,1266,68,0,0,4,1],[1272,13,1272,30,0,0,4,0],[1272,13,1272,30,0,0,4,1],[1273,13,1274,68,0,0,4,1],[1280,13,1280,18,0,0,4,0],[1280,13,1280,18,0,0,4,1],[1282,17,1284,55,0,0,4,0],[1282,17,1284,55,0,0,4,1],[1285,17,1285,31,0,0,4,0],[1296,37,1296,42,0,0,4,0],[1296,37,1296,42,0,0,4,1],[1297,15,1297,39,0,0,4,0],[1297,15,1297,39,0,0,4,1],[1300,9,1300,33,0,0,4,0],[1300,9,1300,33,0,0,4,1],[1304,24,1304,32,0,0,4,0],[1304,24,1304,32,0,0,4,1],[1309,20,1309,32,0,0,4,0],[1309,20,1309,32,0,0,4,1]],\"putRGBAAcontig8bittile\":[[1682,12,1682,17,0,0,4,0],[1682,12,1682,17,0,0,4,1],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1344,13,1344,14,3,0,4,1],[1346,9,1346,15,3,0,4,1],[1348,9,1348,15,3,0,4,1],[1350,9,1350,15,3,0,4,1],[1352,9,1352,15,3,0,4,1],[1354,9,1354,15,3,0,4,0],[1356,9,1356,15,3,0,4,1],[1358,9,1358,15,3,0,4,1]],\"TIFFComputeStrip\":[[42,9,42,53,0,0,4,0],[42,9,42,53,0,0,4,1],[44,13,44,45,0,0,4,1]],\"_TIFFVGetField\":[[1227,9,1227,39,0,0,4,0],[1243,9,1243,35,0,0,4,0],[1246,9,1246,33,0,0,4,0],[1249,9,1249,33,0,0,4,0],[1258,9,1258,33,0,0,4,0],[1261,9,1261,37,0,0,4,0],[1264,9,1264,34,0,0,4,0],[1307,9,1307,34,0,0,4,0],[1327,9,1327,30,0,0,4,0],[1351,9,1351,34,0,0,4,0],[1355,9,1355,31,0,0,4,0],[1358,9,1358,32,0,0,4,0],[1411,9,1411,41,0,0,4,0],[1420,9,1420,16,0,0,4,0],[1433,17,1433,47,0,0,4,1],[1448,25,1448,52,0,0,4,0],[1448,25,1448,52,0,0,4,1],[1452,21,1452,47,0,0,4,0],[1452,21,1452,47,0,0,4,1],[1455,21,1455,41,0,0,4,1],[1464,26,1464,60,0,0,4,1],[1477,25,1477,54,0,0,4,1],[1478,25,1478,62,0,0,4,1],[1479,25,1479,63,0,0,4,1],[1480,25,1480,57,0,0,4,1],[1480,61,1480,74,0,0,4,0],[1480,61,1480,74,0,0,4,1],[1491,29,1491,43,0,0,4,1],[1492,29,1492,48,0,0,4,1],[1496,29,1496,44,0,0,4,1],[1500,29,1500,44,0,0,4,0],[1504,29,1504,45,0,0,4,1],[1508,29,1508,43,0,0,4,1],[1509,29,1509,42,0,0,4,1],[1513,29,1513,44,0,0,4,1],[1517,29,1517,44,0,0,4,1],[1518,29,1518,43,0,0,4,1],[1522,29,1522,45,0,0,4,1],[1526,29,1526,47,0,0,4,1],[1527,29,1527,48,0,0,4,1],[1557,29,1557,44,0,0,4,1],[1561,29,1561,45,0,0,4,1],[1565,29,1565,36,0,0,4,1]],\"gtTileSeparate\":[[873,33,873,38,0,0,4,0],[873,33,873,38,0,0,4,1],[874,9,874,21,0,0,4,1],[883,9,883,31,0,0,4,1],[896,13,896,31,0,0,4,1],[908,9,908,36,0,0,4,1],[909,9,909,36,0,0,4,0],[909,9,909,36,0,0,4,1],[910,9,910,33,0,0,4,1],[914,9,914,16,0,0,4,0],[914,9,914,16,0,0,4,1],[925,19,925,27,0,0,4,0],[925,19,925,27,0,0,4,1],[925,31,925,38,0,0,4,0],[928,17,928,37,0,0,4,0],[928,17,928,37,0,0,4,1],[934,16,934,25,0,0,4,0],[936,17,936,28,0,0,4,0],[938,21,940,69,0,0,4,0],[938,21,940,69,0,0,4,1],[941,22,941,33,0,0,4,0],[941,22,941,33,0,0,4,1],[941,37,941,51,0,0,4,0],[947,21,947,39,0,0,4,0],[950,27,950,32,0,0,4,0],[966,17,966,34,0,0,4,1],[974,17,974,34,0,0,4,1],[982,17,982,22,0,0,4,0],[983,17,984,62,0,0,4,0],[985,17,985,31,0,0,4,0],[1017,15,1017,39,0,0,4,1],[1020,9,1020,33,0,0,4,1]],\"OJPEGWriteHeaderInfo\":[[1359,13,1359,45,0,0,4,1]],\"gtTileContig\":[[730,9,730,21,0,0,4,1],[740,9,740,31,0,0,4,1],[753,13,753,31,0,0,4,0],[753,13,753,31,0,0,4,1],[769,19,769,27,0,0,4,0],[769,19,769,27,0,0,4,1],[769,31,769,38,0,0,4,0],[769,31,769,38,0,0,4,1],[772,17,772,37,0,0,4,0],[772,17,772,37,0,0,4,1],[778,16,778,25,0,0,4,0],[778,16,778,25,0,0,4,1],[780,17,782,65,0,0,4,0],[780,17,782,65,0,0,4,1],[783,18,783,29,0,0,4,0],[783,18,783,29,0,0,4,1],[783,33,783,47,0,0,4,0],[790,17,790,36,0,0,4,0],[790,17,790,36,0,0,4,1],[813,15,813,39,0,0,4,1],[817,9,817,33,0,0,4,1]],\"TIFFScanlineSize64\":[[253,46,253,65,0,0,4,1]],\"BuildMapBitdepth16To8\":[[3175,9,3175,35,0,0,4,1],[3181,17,3181,26,0,0,4,0],[3181,17,3181,26,0,0,4,1]],\"makebwmap\":[[2670,9,2670,22,0,0,4,0],[2670,9,2670,22,0,0,4,1],[2676,9,2676,27,0,0,4,1],[2683,17,2683,24,0,0,4,0],[2683,17,2683,24,0,0,4,1],[2687,17,2687,30,0,0,4,1],[2692,13,2692,19,0,0,4,0],[2692,13,2692,19,0,0,4,1],[2702,13,2702,19,0,0,4,0],[2702,13,2702,19,0,0,4,1],[2708,13,2708,19,0,0,4,0],[2708,13,2708,19,0,0,4,1],[2712,13,2712,19,0,0,4,0],[2712,13,2712,19,0,0,4,1],[2713,13,2713,20,0,0,4,0],[2713,13,2713,20,0,0,4,1]],\"TIFFRGBAImageBegin\":[[321,9,321,36,0,0,4,1],[344,9,344,15,0,0,4,0],[344,9,344,15,0,0,4,1],[345,9,345,15,0,0,4,0],[345,9,345,15,0,0,4,1],[346,9,346,15,0,0,4,0],[346,9,346,15,0,0,4,1],[347,9,347,15,0,0,4,0],[347,9,347,15,0,0,4,1],[348,9,348,16,0,0,4,0],[348,9,348,16,0,0,4,1],[350,9,350,16,0,0,4,1],[361,9,361,26,0,0,4,0],[361,9,361,26,0,0,4,1],[363,17,363,30,0,0,4,1],[365,13,365,41,0,0,4,0],[365,13,365,41,0,0,4,1],[367,21,368,22,0,0,4,0],[367,21,368,22,0,0,4,1],[371,13,371,40,0,0,4,0],[371,13,371,40,0,0,4,1],[372,13,372,40,0,0,4,0],[372,13,372,40,0,0,4,1],[379,9,379,67,0,0,4,0],[379,9,379,67,0,0,4,1],[382,9,382,26,0,0,4,0],[382,9,382,26,0,0,4,1],[382,30,382,55,0,0,4,0],[382,30,382,55,0,0,4,1],[383,9,383,44,0,0,4,1],[393,9,393,67,0,0,4,0],[393,9,393,67,0,0,4,1],[397,13,397,19,0,0,4,0],[398,21,398,44,0,0,4,0],[398,21,398,44,0,0,4,1],[403,13,403,19,0,0,4,1],[406,13,406,20,0,0,4,1],[414,9,414,33,0,0,4,0],[414,9,414,33,0,0,4,1],[415,17,416,42,0,0,4,1],[431,17,431,30,0,0,4,1],[431,34,431,49,0,0,4,1],[431,53,431,67,0,0,4,1],[443,9,443,36,0,0,4,0],[443,9,443,36,0,0,4,1],[444,9,444,36,0,0,4,0],[444,9,444,36,0,0,4,1],[445,17,445,52,0,0,4,0],[445,17,445,52,0,0,4,1],[446,17,446,42,0,0,4,0],[446,17,446,42,0,0,4,1],[446,46,446,68,0,0,4,1],[458,9,458,31,0,0,4,0],[458,9,458,31,0,0,4,1],[460,17,460,52,0,0,4,0],[460,17,460,52,0,0,4,1],[465,21,465,42,0,0,4,0],[465,21,465,42,0,0,4,1],[476,21,476,28,0,0,4,0],[476,21,476,28,0,0,4,1],[487,9,487,29,0,0,4,0],[487,9,487,29,0,0,4,1],[488,17,488,34,0,0,4,1],[496,9,496,35,0,0,4,0],[496,9,496,35,0,0,4,1],[500,17,500,38,0,0,4,1],[508,17,508,41,0,0,4,1],[518,9,518,30,0,0,4,1],[530,9,530,32,0,0,4,1],[551,9,551,32,0,0,4,0],[551,9,551,32,0,0,4,1],[553,9,553,16,0,0,4,1],[563,11,563,48,0,0,4,0],[563,11,563,48,0,0,4,1],[563,52,563,76,0,0,4,0],[563,52,563,76,0,0,4,1],[564,9,564,22,0,0,4,0],[564,9,564,22,0,0,4,1],[566,13,566,33,0,0,4,0],[566,13,566,33,0,0,4,1],[574,13,574,35,0,0,4,0],[574,13,574,35,0,0,4,1]],\"TIFFCheckTile\":[[75,9,75,31,0,0,4,1],[81,9,81,32,0,0,4,1],[88,9,88,31,0,0,4,1],[94,9,94,53,0,0,4,0],[94,9,94,53,0,0,4,1],[95,9,95,36,0,0,4,1]],\"TIFFRGBAImageGet\":[[590,9,590,25,0,0,4,1],[596,9,596,29,0,0,4,1]],\"LogL16toY\":[[791,9,791,12,0,0,4,1],[794,13,794,28,0,0,4,0]],\"putRGBseparate8bittile\":[[1860,12,1860,17,0,0,4,0],[1860,12,1860,17,0,0,4,1],[1376,22,1376,29,1,0,4,0],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1344,13,1344,14,4,0,4,1],[1346,9,1346,15,4,0,4,0],[1348,9,1348,15,4,0,4,1],[1350,9,1350,15,4,0,4,1],[1352,9,1352,15,4,0,4,1],[1354,9,1354,15,4,0,4,1],[1356,9,1356,15,4,0,4,1],[1358,9,1358,15,4,0,4,1]],\"put4bitbwtile\":[[1643,12,1643,17,0,0,4,0],[1643,12,1643,17,0,0,4,1],[1404,22,1404,29,1,0,4,0],[1404,22,1404,29,1,0,4,1],[1409,13,1409,15,1,0,4,0],[1409,13,1409,15,1,0,4,1]],\"cvtcmap\":[[2792,46,2792,52,0,0,4,0],[2792,46,2792,52,0,0,4,1]],\"setorientation\":[[648,9,648,33,0,0,4,0],[648,9,648,33,0,0,4,1],[649,9,649,33,0,0,4,0],[649,9,649,33,0,0,4,1],[650,17,650,61,0,0,4,1],[651,17,651,61,0,0,4,1],[653,22,653,66,0,0,4,1],[654,22,654,66,0,0,4,1],[656,22,656,65,0,0,4,0],[656,22,656,65,0,0,4,1],[657,22,657,65,0,0,4,1],[661,9,661,34,0,0,4,0],[661,9,661,34,0,0,4,1],[662,9,662,34,0,0,4,1],[663,17,663,60,0,0,4,1],[664,17,664,60,0,0,4,1],[666,22,666,66,0,0,4,1],[667,22,667,66,0,0,4,1],[669,22,669,65,0,0,4,0],[669,22,669,65,0,0,4,1],[670,22,670,65,0,0,4,1],[674,9,674,34,0,0,4,0],[674,9,674,34,0,0,4,1],[675,9,675,34,0,0,4,1],[676,17,676,60,0,0,4,1],[677,17,677,60,0,0,4,1],[679,22,679,66,0,0,4,1],[680,22,680,66,0,0,4,1],[682,22,682,65,0,0,4,0],[682,22,682,65,0,0,4,1],[683,22,683,65,0,0,4,1],[687,9,687,33,0,0,4,0],[687,9,687,33,0,0,4,1],[688,9,688,33,0,0,4,0],[688,9,688,33,0,0,4,1],[689,17,689,60,0,0,4,1],[690,17,690,60,0,0,4,1],[692,22,692,66,0,0,4,1],[693,22,693,66,0,0,4,1],[695,22,695,66,0,0,4,1],[696,22,696,66,0,0,4,1],[700,9,700,16,0,0,4,1]],\"PickSeparateCase\":[[3076,16,3076,37,0,0,4,0],[3076,16,3076,37,0,0,4,1],[3078,13,3078,29,0,0,4,0],[3078,13,3078,29,0,0,4,1],[3080,9,3080,36,0,0,4,0],[3080,9,3080,36,0,0,4,1],[3081,9,3081,36,0,0,4,0],[3081,9,3081,36,0,0,4,1],[3084,9,3084,29,0,0,4,1],[3085,21,3085,39,0,0,4,0],[3085,21,3085,39,0,0,4,1],[3087,17,3087,23,0,0,4,0],[3087,17,3087,23,0,0,4,1],[3088,25,3088,61,0,0,4,0],[3088,25,3088,61,0,0,4,1],[3090,30,3090,66,0,0,4,0],[3090,30,3090,66,0,0,4,1],[3092,29,3092,48,0,0,4,0],[3098,17,3098,24,0,0,4,0],[3098,17,3098,24,0,0,4,1],[3099,25,3099,61,0,0,4,0],[3099,25,3099,61,0,0,4,1],[3101,29,3101,55,0,0,4,0],[3104,30,3104,66,0,0,4,0],[3104,30,3104,66,0,0,4,1],[3106,29,3106,55,0,0,4,0],[3106,59,3106,78,0,0,4,0],[3111,29,3111,55,0,0,4,0],[3117,9,3117,35,0,0,4,0],[3117,9,3117,35,0,0,4,1],[3118,17,3118,40,0,0,4,0],[3118,17,3118,40,0,0,4,1],[3118,44,3118,69,0,0,4,0],[3125,9,3125,31,0,0,4,0],[3125,9,3125,31,0,0,4,1],[3126,17,3126,42,0,0,4,0],[3126,17,3126,42,0,0,4,1],[3126,46,3126,73,0,0,4,0],[3128,21,3128,50,0,0,4,0],[3133,29,3133,43,0,0,4,0],[3133,29,3133,43,0,0,4,1],[3135,25,3135,34,0,0,4,0],[3135,25,3135,34,0,0,4,1],[3144,13,3144,31,0,0,4,0],[3144,35,3144,62,0,0,4,0],[3144,35,3144,62,0,0,4,1]],\"TIFFYCbCrtoRGB\":[[197,26,197,37,1,0,4,1],[196,6,196,23,2,0,4,1],[196,34,196,45,2,0,4,1],[196,6,196,23,3,0,4,1],[196,34,196,45,3,0,4,1],[196,6,196,23,4,0,4,0],[196,6,196,23,4,0,4,1],[196,34,196,45,4,0,4,0],[196,34,196,45,4,0,4,1],[196,6,196,23,6,0,4,0],[196,6,196,23,6,0,4,1],[196,34,196,45,6,0,4,0],[196,34,196,45,6,0,4,1],[196,6,196,23,7,0,4,0],[196,6,196,23,7,0,4,1],[196,34,196,45,7,0,4,0],[196,34,196,45,7,0,4,1]],\"TIFFReadRGBAStripExt\":[[3208,9,3208,25,0,0,4,0],[3208,9,3208,25,0,0,4,1],[3216,9,3216,34,0,0,4,1],[3224,9,3224,35,0,0,4,0],[3225,9,3225,59,0,0,4,0],[3231,13,3231,44,0,0,4,0],[3231,13,3231,44,0,0,4,1]],\"TIFFReadEncodedTile\":[[961,9,961,31,0,0,4,0]],\"TIFFReadTile\":[[919,9,919,31,0,0,4,1],[919,35,919,66,0,0,4,1]],\"_TIFFReadEncodedTileAndAllocBuffer\":[[1007,9,1007,21,0,0,4,0],[1007,9,1007,21,0,0,4,1],[1012,9,1012,31,0,0,4,1],[1014,9,1014,31,0,0,4,1],[1022,9,1022,33,0,0,4,0],[1022,9,1022,33,0,0,4,1],[1027,9,1027,47,0,0,4,0],[1027,9,1027,47,0,0,4,1],[1029,13,1029,45,0,0,4,0],[1029,13,1029,45,0,0,4,1],[1046,13,1046,51,0,0,4,1],[1047,15,1047,52,0,0,4,1],[1053,19,1053,57,0,0,4,1],[1054,13,1054,47,0,0,4,0],[1054,13,1054,47,0,0,4,1],[1055,13,1055,66,0,0,4,0],[1068,9,1068,21,0,0,4,1],[1075,9,1075,39,0,0,4,0],[1079,9,1080,73,0,0,4,0],[1079,9,1080,73,0,0,4,1]],\"putRGBcontig8bittile\":[[1662,12,1662,17,0,0,4,0],[1662,12,1662,17,0,0,4,1],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1344,13,1344,14,3,0,4,1],[1346,9,1346,15,3,0,4,1],[1348,9,1348,15,3,0,4,1],[1350,9,1350,15,3,0,4,1],[1352,9,1352,15,3,0,4,1],[1354,9,1354,15,3,0,4,0],[1356,9,1356,15,3,0,4,1],[1358,9,1358,15,3,0,4,1]],\"_TIFFReadEncodedStripAndAllocBuffer\":[[568,9,568,21,0,0,4,0],[568,9,568,21,0,0,4,1],[574,9,574,43,0,0,4,1],[577,9,577,41,0,0,4,0],[577,45,577,76,0,0,4,0],[577,45,577,76,0,0,4,1],[579,9,579,35,0,0,4,0],[579,9,579,35,0,0,4,1],[583,9,583,21,0,0,4,1],[590,9,590,71,0,0,4,0],[590,9,590,71,0,0,4,1]],\"makecmap\":[[2822,9,2822,28,0,0,4,1],[2829,17,2829,24,0,0,4,0],[2829,17,2829,24,0,0,4,1],[2836,17,2836,30,0,0,4,1],[2838,13,2838,19,0,0,4,1],[2848,13,2848,19,0,0,4,0],[2854,13,2854,19,0,0,4,1],[2858,13,2858,19,0,0,4,1]],\"putRGBUAseparate8bittile\":[[1914,12,1914,17,0,0,4,0],[1914,12,1914,17,0,0,4,1],[1918,21,1918,26,0,0,4,0],[1918,21,1918,26,0,0,4,1]],\"Fax4Decode\":[[495,33,495,47,3,0,4,0],[328,13,328,24,65,0,4,1],[170,21,170,35,85,0,4,0],[170,21,170,35,85,0,4,1],[117,21,117,31,145,0,4,0]],\"buildMap\":[[2873,13,2873,29,0,0,4,0],[2873,13,2873,29,0,0,4,1],[2875,9,2875,29,0,0,4,1],[2876,9,2876,31,0,0,4,1],[2877,9,2877,35,0,0,4,0],[2877,9,2877,35,0,0,4,1],[2878,17,2878,40,0,0,4,0],[2878,17,2878,40,0,0,4,1],[2881,9,2881,36,0,0,4,0],[2881,9,2881,36,0,0,4,1],[2882,9,2882,36,0,0,4,0],[2882,9,2882,36,0,0,4,1],[2883,17,2883,31,0,0,4,1],[2886,9,2886,33,0,0,4,0],[2886,9,2886,33,0,0,4,1],[2891,17,2891,37,0,0,4,0],[2891,17,2891,37,0,0,4,1],[2900,17,2900,40,0,0,4,0],[2900,44,2900,58,0,0,4,1]],\"TIFFDefaultRefBlackWhite\":[[178,9,178,37,0,0,4,1],[180,9,180,48,0,0,4,0]],\"BuildMapUaToAa\":[[3154,9,3154,28,0,0,4,1],[3160,18,3160,26,0,0,4,0],[3160,18,3160,26,0,0,4,1],[3162,22,3162,30,0,0,4,0],[3162,22,3162,30,0,0,4,1]],\"setupMap\":[[2734,9,2734,33,0,0,4,0],[2734,9,2734,33,0,0,4,1],[2739,9,2739,25,0,0,4,1],[2745,9,2745,51,0,0,4,0],[2745,9,2745,51,0,0,4,1],[2747,21,2747,31,0,0,4,0],[2747,21,2747,31,0,0,4,1],[2752,21,2752,31,0,0,4,0],[2752,21,2752,31,0,0,4,1],[2755,9,2755,33,0,0,4,0],[2756,10,2756,52,0,0,4,0],[2756,10,2756,52,0,0,4,1],[2757,10,2757,52,0,0,4,0],[2757,10,2757,52,0,0,4,1],[2763,13,2763,28,0,0,4,1]],\"putRGBcontig8bitCMYKtile\":[[1806,12,1806,17,0,0,4,0],[1806,12,1806,17,0,0,4,1],[1376,22,1376,29,1,0,4,0],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1381,13,1381,19,1,0,4,1],[1344,13,1344,14,3,0,4,1],[1346,9,1346,15,3,0,4,1],[1348,9,1348,15,3,0,4,1],[1350,9,1350,15,3,0,4,1],[1352,9,1352,15,3,0,4,1],[1354,9,1354,15,3,0,4,0],[1354,9,1354,15,3,0,4,1],[1356,9,1356,15,3,0,4,0],[1356,9,1356,15,3,0,4,1],[1358,9,1358,15,3,0,4,0],[1358,9,1358,15,3,0,4,1]],\"TIFFVStripSize64\":[[84,54,84,73,0,0,4,1]],\"putcontig8bitYCbCr22tile\":[[2371,12,2371,18,0,0,4,0],[2371,12,2371,18,0,0,4,1],[2374,16,2374,22,0,0,4,0],[2374,16,2374,22,0,0,4,1],[2387,13,2387,19,0,0,4,0],[2387,13,2387,19,0,0,4,1],[2402,9,2402,15,0,0,4,0],[2402,9,2402,15,0,0,4,1],[2405,16,2405,22,0,0,4,0],[2405,16,2405,22,0,0,4,1],[2416,13,2416,19,0,0,4,0],[2416,13,2416,19,0,0,4,1]],\"JPEGResetUpsampled\":[[2551,13,2551,65,0,0,4,0],[2569,9,2569,30,0,0,4,0],[2571,9,2571,34,0,0,4,0],[250,22,250,62,7,0,4,0]],\"TIFFXYZToRGB\":[[306,24,306,33,1,0,4,0],[306,24,306,33,1,0,4,1],[306,24,306,33,2,0,4,0],[306,24,306,33,2,0,4,1],[306,24,306,33,3,0,4,0],[306,24,306,33,3,0,4,1],[307,24,307,33,4,0,4,0],[307,24,307,33,4,0,4,1],[307,24,307,33,5,0,4,0],[307,24,307,33,5,0,4,1],[307,24,307,33,6,0,4,0],[307,24,307,33,6,0,4,1],[307,24,307,33,7,0,4,1],[85,29,85,36,8,0,4,0],[85,29,85,36,8,0,4,1],[307,24,307,33,9,0,4,1],[85,29,85,36,10,0,4,0],[85,29,85,36,10,0,4,1],[307,24,307,33,11,0,4,1],[85,29,85,36,12,0,4,0],[85,29,85,36,12,0,4,1],[307,24,307,33,13,0,4,0],[307,24,307,33,13,0,4,1],[307,24,307,33,14,0,4,0],[307,24,307,33,14,0,4,1],[307,24,307,33,15,0,4,0],[307,24,307,33,15,0,4,1]],\"JPEGVSetField\":[[2600,9,2600,35,0,0,4,0]],\"OJPEGPreDecode\":[[760,13,761,48,0,0,4,0]],\"isInRefBlackWhiteRange\":[[2556,12,2556,42,0,0,4,0],[2556,12,2556,42,0,0,4,1],[2556,46,2556,67,0,0,4,0],[2556,46,2556,67,0,0,4,1]],\"PickContigCase\":[[2912,16,2912,37,0,0,4,0],[2912,16,2912,37,0,0,4,1],[2914,13,2914,29,0,0,4,1],[2916,9,2916,29,0,0,4,0],[2916,9,2916,29,0,0,4,1],[2917,21,2917,39,0,0,4,0],[2917,21,2917,39,0,0,4,1],[2919,17,2919,23,0,0,4,0],[2919,17,2919,23,0,0,4,1],[2920,25,2920,61,0,0,4,0],[2920,25,2920,61,0,0,4,1],[2921,25,2921,50,0,0,4,0],[2921,25,2921,50,0,0,4,1],[2923,30,2923,66,0,0,4,0],[2923,30,2923,66,0,0,4,1],[2924,30,2924,55,0,0,4,0],[2924,30,2924,55,0,0,4,1],[2926,29,2926,48,0,0,4,0],[2929,30,2929,55,0,0,4,0],[2929,30,2929,55,0,0,4,1],[2932,17,2932,24,0,0,4,0],[2932,17,2932,24,0,0,4,1],[2933,25,2933,61,0,0,4,0],[2933,25,2933,61,0,0,4,1],[2934,25,2934,50,0,0,4,1],[2939,30,2939,66,0,0,4,0],[2939,30,2939,66,0,0,4,1],[2940,30,2940,55,0,0,4,1],[2945,30,2945,55,0,0,4,0],[2947,29,2947,55,0,0,4,0],[2953,9,2953,35,0,0,4,0],[2953,9,2953,35,0,0,4,1],[2954,17,2954,42,0,0,4,0],[2954,46,2954,59,0,0,4,0],[2956,21,2956,44,0,0,4,0],[2956,21,2956,44,0,0,4,1],[2958,25,2958,34,0,0,4,0],[2965,9,2965,33,0,0,4,0],[2965,9,2965,33,0,0,4,1],[2966,17,2966,30,0,0,4,0],[2968,25,2968,43,0,0,4,1],[2970,21,2970,27,0,0,4,1],[2973,21,2973,27,0,0,4,1],[2976,21,2976,27,0,0,4,0],[2979,21,2979,27,0,0,4,1],[2985,9,2985,36,0,0,4,0],[2985,9,2985,36,0,0,4,1],[2986,9,2986,36,0,0,4,0],[2986,9,2986,36,0,0,4,1],[2987,17,2987,30,0,0,4,0],[2989,25,2989,43,0,0,4,1],[2991,21,2991,28,0,0,4,0],[2991,21,2991,28,0,0,4,1],[2994,21,2994,27,0,0,4,0],[2994,21,2994,27,0,0,4,1],[2995,29,2995,39,0,0,4,0],[2995,29,2995,39,0,0,4,1],[2995,43,2995,68,0,0,4,0],[2995,43,2995,68,0,0,4,1],[3000,21,3000,27,0,0,4,0],[3000,21,3000,27,0,0,4,1],[3003,21,3003,27,0,0,4,0],[3003,21,3003,27,0,0,4,1],[3006,21,3006,27,0,0,4,0],[3006,21,3006,27,0,0,4,1],[3012,9,3012,31,0,0,4,0],[3012,9,3012,31,0,0,4,1],[3013,17,3013,42,0,0,4,0],[3013,17,3013,42,0,0,4,1],[3013,46,3013,73,0,0,4,0],[3013,46,3013,73,0,0,4,1],[3015,21,3015,50,0,0,4,0],[3015,21,3015,50,0,0,4,1],[3030,29,3030,67,0,0,4,0],[3030,29,3030,67,0,0,4,1],[3032,25,3032,34,0,0,4,0],[3032,25,3032,34,0,0,4,1],[3035,25,3035,34,0,0,4,0],[3035,25,3035,34,0,0,4,1],[3038,25,3038,34,0,0,4,0],[3038,25,3038,34,0,0,4,1],[3041,25,3041,34,0,0,4,0],[3041,25,3041,34,0,0,4,1],[3044,25,3044,34,0,0,4,0],[3044,25,3044,34,0,0,4,1],[3047,25,3047,34,0,0,4,0],[3047,25,3047,34,0,0,4,1],[3050,25,3050,34,0,0,4,0],[3050,25,3050,34,0,0,4,1],[3057,9,3057,32,0,0,4,0],[3057,9,3057,32,0,0,4,1],[3058,17,3058,42,0,0,4,0],[3058,46,3058,59,0,0,4,0],[3060,21,3060,44,0,0,4,0],[3065,13,3065,31,0,0,4,0],[3065,35,3065,60,0,0,4,0],[3065,35,3065,60,0,0,4,1]],\"put16bitbwtile\":[[1578,12,1578,17,0,0,4,0],[1578,12,1578,17,0,0,4,1],[1582,21,1582,26,0,0,4,0],[1582,21,1582,26,0,0,4,1]],\"TIFFRGBAImageEnd\":[[255,9,255,17,0,0,4,0],[255,9,255,17,0,0,4,1],[260,9,260,19,0,0,4,0],[260,9,260,19,0,0,4,1],[265,9,265,20,0,0,4,0],[265,9,265,20,0,0,4,1],[270,9,270,19,0,0,4,0],[270,9,270,19,0,0,4,1],[275,9,275,20,0,0,4,0],[275,9,275,20,0,0,4,1],[280,9,280,20,0,0,4,0],[280,9,280,20,0,0,4,1],[285,9,285,27,0,0,4,0],[285,9,285,27,0,0,4,1],[291,9,291,21,0,0,4,0],[291,9,291,21,0,0,4,1]],\"put2bitcmaptile\":[[1499,12,1499,17,0,0,4,0],[1499,12,1499,17,0,0,4,1],[1390,22,1390,29,1,0,4,0],[1390,22,1390,29,1,0,4,1],[1395,13,1395,19,1,0,4,0],[1395,13,1395,19,1,0,4,1],[1362,13,1362,14,3,0,4,1],[1364,9,1364,15,3,0,4,0],[1364,9,1364,15,3,0,4,1],[1366,9,1366,15,3,0,4,0],[1366,9,1366,15,3,0,4,1],[1368,9,1368,15,3,0,4,0],[1368,9,1368,15,3,0,4,1]],\"TIFFVTileSize64\":[[197,42,197,61,0,0,4,1]],\"TIFFVGetFieldDefaulted\":[[225,9,225,35,0,0,4,0],[234,9,234,33,0,0,4,0],[237,9,237,37,0,0,4,0],[240,9,240,34,0,0,4,0],[297,9,297,28,0,0,4,0],[303,9,303,34,0,0,4,0],[324,9,324,39,0,0,4,0],[331,9,331,38,0,0,4,1],[338,9,338,32,0,0,4,0],[364,9,364,41,0,0,4,0],[365,17,365,38,0,0,4,0],[365,17,365,38,0,0,4,1],[365,42,365,76,0,0,4,1]],\"initYCbCrConversion\":[[2565,9,2565,27,0,0,4,0],[2571,13,2571,31,0,0,4,1],[2585,9,2585,27,0,0,4,1],[2585,31,2585,49,0,0,4,1],[2585,53,2585,67,0,0,4,1],[2586,9,2586,27,0,0,4,1],[2593,9,2593,50,0,0,4,0],[2593,9,2593,50,0,0,4,1],[2594,9,2594,50,0,0,4,0],[2594,9,2594,50,0,0,4,1],[2595,9,2595,50,0,0,4,0],[2595,9,2595,50,0,0,4,1],[2596,9,2596,50,0,0,4,0],[2596,9,2596,50,0,0,4,1],[2597,9,2597,50,0,0,4,0],[2597,9,2597,50,0,0,4,1],[2598,9,2598,50,0,0,4,1],[2605,9,2605,64,0,0,4,1]],\"TIFFCIELab16ToXYZ\":[[61,9,61,19,0,0,4,0],[61,9,61,19,0,0,4,1],[73,9,73,22,0,0,4,0],[73,9,73,22,0,0,4,1],[79,9,79,22,0,0,4,0],[79,9,79,22,0,0,4,1]],\"checkcmap\":[[2779,12,2779,19,0,0,4,0],[2779,12,2779,19,0,0,4,1],[2780,13,2780,24,0,0,4,0],[2780,13,2780,24,0,0,4,1],[2780,28,2780,39,0,0,4,0],[2780,28,2780,39,0,0,4,1],[2780,43,2780,54,0,0,4,0],[2780,43,2780,54,0,0,4,1]],\"gtStripContig\":[[1068,9,1068,28,0,0,4,0],[1068,9,1068,28,0,0,4,1],[1078,9,1078,31,0,0,4,0],[1078,9,1078,31,0,0,4,1],[1080,13,1080,24,0,0,4,1],[1097,17,1097,31,0,0,4,1],[1098,19,1098,26,0,0,4,0],[1098,19,1098,26,0,0,4,1],[1102,17,1102,37,0,0,4,0],[1102,17,1102,37,0,0,4,1],[1104,13,1104,44,0,0,4,0],[1104,13,1104,44,0,0,4,1],[1107,13,1107,25,0,0,4,0],[1107,29,1107,74,0,0,4,1],[1113,13,1116,51,0,0,4,0],[1113,13,1116,51,0,0,4,1],[1117,14,1117,25,0,0,4,0],[1117,14,1117,25,0,0,4,1],[1117,29,1117,43,0,0,4,0],[1128,15,1128,39,0,0,4,0],[1128,15,1128,39,0,0,4,1],[1131,9,1131,33,0,0,4,0],[1131,9,1131,33,0,0,4,1],[1135,24,1135,32,0,0,4,0],[1135,24,1135,32,0,0,4,1],[1140,20,1140,32,0,0,4,0],[1140,20,1140,32,0,0,4,1]],\"TIFFCIELabToRGBInit\":[[149,17,149,35,0,0,4,0],[149,17,149,35,0,0,4,1],[159,17,159,35,0,0,4,0],[159,17,159,35,0,0,4,1],[169,17,169,35,0,0,4,0],[169,17,169,35,0,0,4,1]],\"isCCITTCompression\":[[304,13,304,46,0,0,4,0],[304,13,304,46,0,0,4,1],[305,13,305,46,0,0,4,0],[305,13,305,46,0,0,4,1],[306,13,306,45,0,0,4,0],[306,13,306,45,0,0,4,1],[307,13,307,46,0,0,4,0],[307,13,307,46,0,0,4,1]],\"uv_encode\":[[971,9,971,29,0,0,4,1]],\"put1bitbwtile\":[[1605,12,1605,17,0,0,4,0],[1605,12,1605,17,0,0,4,1],[1376,22,1376,29,1,0,4,0],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1381,13,1381,19,1,0,4,1],[1344,13,1344,14,3,0,4,1],[1346,9,1346,15,3,0,4,0],[1346,9,1346,15,3,0,4,1],[1348,9,1348,15,3,0,4,0],[1348,9,1348,15,3,0,4,1],[1350,9,1350,15,3,0,4,0],[1350,9,1350,15,3,0,4,1],[1352,9,1352,15,3,0,4,0],[1352,9,1352,15,3,0,4,1],[1354,9,1354,15,3,0,4,0],[1354,9,1354,15,3,0,4,1],[1356,9,1356,15,3,0,4,0],[1356,9,1356,15,3,0,4,1],[1358,9,1358,15,3,0,4,0],[1358,9,1358,15,3,0,4,1]],\"putRGBAAseparate8bittile\":[[1876,12,1876,17,0,0,4,0],[1876,12,1876,17,0,0,4,1],[1376,22,1376,29,1,0,4,0],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,1]],\"putagreytile\":[[1557,12,1557,17,0,0,4,0],[1557,12,1557,17,0,0,4,1],[1559,21,1559,26,0,0,4,0],[1559,21,1559,26,0,0,4,1]],\"putCMYKseparate8bittile\":[[1891,12,1891,17,0,0,4,0],[1891,12,1891,17,0,0,4,1],[1894,21,1894,26,0,0,4,0],[1894,21,1894,26,0,0,4,1]],\"putRGBseparate16bittile\":[[1943,12,1943,17,0,0,4,0],[1943,12,1943,17,0,0,4,1],[1945,21,1945,26,0,0,4,0],[1945,21,1945,26,0,0,4,1]],\"putcontig8bitCIELab8\":[[2012,12,2012,17,0,0,4,0],[2012,12,2012,17,0,0,4,1],[2014,21,2014,26,0,0,4,0],[2014,21,2014,26,0,0,4,1]],\"putgreytile\":[[1536,12,1536,17,0,0,4,0],[1536,12,1536,17,0,0,4,1],[1538,21,1538,26,0,0,4,0],[1538,21,1538,26,0,0,4,1]],\"put2bitbwtile\":[[1624,12,1624,17,0,0,4,0],[1624,12,1624,17,0,0,4,1],[1390,22,1390,29,1,0,4,0],[1390,22,1390,29,1,0,4,1],[1395,13,1395,19,1,0,4,0],[1395,13,1395,19,1,0,4,1],[1362,13,1362,14,3,0,4,1],[1364,9,1364,15,3,0,4,0],[1364,9,1364,15,3,0,4,1],[1366,9,1366,15,3,0,4,0],[1366,9,1366,15,3,0,4,1],[1368,9,1368,15,3,0,4,0],[1368,9,1368,15,3,0,4,1]]},\"library_calls\":[\"TIFFStreamOpen\",\"TIFFGetField\",\"TIFFGetField\",\"_TIFFmalloc\",\"TIFFReadRGBAImageOriented\",\"_TIFFfree\",\"TIFFClose\",\"TIFFStripSize64\",\"TIFFIsByteSwapped\",\"TIFFSetTagExtender\",\"TIFFFlushData\",\"LogL16toY\",\"TIFFReadRGBAStripExt\",\"LogLuv24fromXYZ\",\"_TIFFfree\",\"TIFFClose\"],\"critical_calls\":[\"TIFFStreamOpen\",\"TIFFGetField\",\"TIFFGetField\",\"_TIFFmalloc\",\"TIFFReadRGBAImageOriented\",\"TIFFStripSize64\",\"TIFFIsByteSwapped\",\"TIFFSetTagExtender\",\"TIFFFlushData\",\"LogL16toY\",\"TIFFReadRGBAStripExt\",\"LogLuv24fromXYZ\",\"_TIFFfree\",\"TIFFClose\"],\"visited\":4}"
        }
      ],
      "repository": {
        "name": "github.com/PromptFuzz/PromptFuzz",
        "url": "/github.com/PromptFuzz/PromptFuzz"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "c15ace4a9bb90693e1e9aaa55969b51859ec2633"
        },
        "content": "#include \"FDSan.h\"\n#include \"FuzzedDataProvider.h\"\n#include \u003ctiffio.hxx\u003e\n#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n#include \u003cstdint.h\u003e\n#include \u003cvector\u003e\n#include \u003cfstream\u003e\n#include \u003ciostream\u003e\n#include \u003csstream\u003e\n//\u003cID\u003e 220\n//\u003cPrompt\u003e [\"TIFFStripSize64\",\"TIFFReadRGBAImageOriented\",\"TIFFIsByteSwapped\",\"TIFFSetTagExtender\",\"TIFFFlushData\",\"LogL16toY\",\"TIFFReadRGBAStripExt\",\"LogLuv24fromXYZ\"]\n/*\u003cCombination\u003e: [uint64_t TIFFStripSize64(TIFF * tif),\n    int TIFFReadRGBAImageOriented(TIFF * , uint32_t , uint32_t , uint32_t * , int , int ),\n    int TIFFIsByteSwapped(TIFF * ),\n    TIFFExtendProc TIFFSetTagExtender(TIFFExtendProc ),\n    int TIFFFlushData(TIFF * tif),\n    double LogL16toY(int ),\n    int TIFFReadRGBAStripExt(TIFF * , uint32_t , uint32_t * , int stop_on_error),\n    uint32_t LogLuv24fromXYZ(float * , int )\n*/\n//\u003cscore\u003e 184.6, nr_unique_branch: 965\n//\u003cQuality\u003e {\"density\":13,\"unique_branches\":{\"CLAMPw\":[[222,9,222,17,0,0,4,0],[222,9,222,17,0,0,4,1],[227,9,227,17,0,0,4,0],[227,9,227,17,0,0,4,1]],\"TIFFYCbCrToRGBInit\":[[265,17,265,24,0,0,4,0],[265,17,265,24,0,0,4,1],[296,31,296,38,0,0,4,0],[296,31,296,38,0,0,4,1],[189,28,189,29,3,0,4,1],[189,28,189,29,3,0,4,0],[189,28,189,29,3,0,4,1],[189,28,189,29,6,0,4,1],[189,28,189,29,6,0,4,0],[189,28,189,29,6,0,4,1],[189,28,189,29,8,0,4,1],[189,28,189,29,8,0,4,0],[189,28,189,29,8,0,4,1],[189,28,189,29,11,0,4,1],[189,28,189,29,11,0,4,0],[189,28,189,29,11,0,4,1],[193,14,193,32,12,0,4,0],[193,14,193,32,12,0,4,1],[193,14,193,32,13,0,4,0],[193,14,193,32,13,0,4,1],[193,14,193,32,19,0,4,0],[193,14,193,32,19,0,4,1]],\"TIFFReadRGBAImageOriented\":[[617,9,617,35,0,0,4,0],[617,9,617,35,0,0,4,1],[617,39,617,80,0,0,4,0],[617,39,617,80,0,0,4,1]],\"_TIFFReadTileAndAllocBuffer\":[[986,9,986,31,0,0,4,1],[986,35,986,66,0,0,4,1]],\"Fax3DecodeRLE\":[[117,21,117,31,57,0,4,0]],\"LogLuv24fromXYZ\":[[1054,9,1054,12,0,0,4,1],[1054,16,1054,23,0,0,4,1],[1065,9,1065,15,0,0,4,1]],\"TIFFRGBAImageOK\":[[89,9,89,31,0,0,4,1],[97,9,97,15,0,0,4,0],[97,9,97,15,0,0,4,1],[98,9,98,15,0,0,4,0],[98,9,98,15,0,0,4,1],[99,9,99,15,0,0,4,0],[99,9,99,15,0,0,4,1],[100,9,100,15,0,0,4,0],[100,9,100,15,0,0,4,1],[101,9,101,16,0,0,4,0],[101,9,101,16,0,0,4,1],[103,9,103,16,0,0,4,0],[103,9,103,16,0,0,4,1],[110,9,110,51,0,0,4,0],[110,9,110,51,0,0,4,1],[118,9,118,62,0,0,4,0],[118,9,118,62,0,0,4,1],[122,13,122,19,0,0,4,0],[122,13,122,19,0,0,4,1],[125,13,125,19,0,0,4,1],[128,13,128,20,0,0,4,0],[128,13,128,20,0,0,4,1],[136,9,136,36,0,0,4,0],[136,9,136,36,0,0,4,1],[137,9,137,36,0,0,4,0],[137,9,137,36,0,0,4,1],[138,9,138,33,0,0,4,0],[138,9,138,33,0,0,4,1],[139,17,139,59,0,0,4,0],[139,17,139,59,0,0,4,1],[140,17,140,44,0,0,4,0],[140,17,140,44,0,0,4,1],[140,48,140,72,0,0,4,0],[140,48,140,72,0,0,4,1],[157,9,157,31,0,0,4,0],[157,9,157,31,0,0,4,1],[165,9,165,29,0,0,4,0],[165,9,165,29,0,0,4,1],[166,17,166,34,0,0,4,0],[166,17,166,34,0,0,4,1],[174,9,174,35,0,0,4,0],[174,9,174,35,0,0,4,1],[178,17,178,38,0,0,4,0],[178,17,178,38,0,0,4,1],[185,17,185,43,0,0,4,0],[185,17,185,43,0,0,4,1],[195,9,195,30,0,0,4,0],[195,9,195,30,0,0,4,1],[196,17,196,57,0,0,4,0],[204,9,204,32,0,0,4,0],[204,9,204,32,0,0,4,1],[205,17,205,57,0,0,4,0],[206,17,206,59,0,0,4,0],[231,9,231,32,0,0,4,0],[231,9,231,32,0,0,4,1],[232,17,232,44,0,0,4,0],[232,17,232,44,0,0,4,1],[232,48,232,66,0,0,4,1],[233,18,233,43,0,0,4,0],[233,18,233,43,0,0,4,1],[233,47,233,73,0,0,4,0],[244,9,244,16,0,0,4,0],[244,9,244,16,0,0,4,1]],\"initCIELabConversion\":[[2618,9,2618,30,0,0,4,1],[2624,9,2624,21,0,0,4,0],[2628,13,2628,25,0,0,4,1],[2640,9,2640,70,0,0,4,1],[2648,9,2648,32,0,0,4,0]],\"gtStripSeparate\":[[1182,33,1182,38,0,0,4,0],[1182,33,1182,38,0,0,4,1],[1183,9,1183,21,0,0,4,1],[1189,9,1189,31,0,0,4,0],[1189,9,1189,31,0,0,4,1],[1191,13,1191,24,0,0,4,1],[1207,9,1207,36,0,0,4,0],[1207,9,1207,36,0,0,4,1],[1208,9,1208,36,0,0,4,0],[1208,9,1208,36,0,0,4,1],[1209,9,1209,33,0,0,4,1],[1213,9,1213,16,0,0,4,0],[1213,9,1213,16,0,0,4,1],[1220,17,1220,31,0,0,4,1],[1221,19,1221,26,0,0,4,0],[1221,19,1221,26,0,0,4,1],[1225,17,1225,37,0,0,4,0],[1225,17,1225,37,0,0,4,1],[1228,13,1228,25,0,0,4,0],[1228,29,1228,74,0,0,4,1],[1234,13,1234,24,0,0,4,0],[1234,13,1234,24,0,0,4,1],[1236,17,1238,64,0,0,4,0],[1236,17,1238,64,0,0,4,1],[1239,18,1239,29,0,0,4,0],[1239,18,1239,29,0,0,4,1],[1239,33,1239,47,0,0,4,0],[1245,17,1245,35,0,0,4,0],[1245,17,1245,35,0,0,4,1],[1248,23,1248,28,0,0,4,0],[1248,23,1248,28,0,0,4,1],[1254,23,1254,28,0,0,4,0],[1257,18,1258,77,0,0,4,0],[1257,18,1258,77,0,0,4,1],[1259,18,1259,32,0,0,4,0],[1264,13,1264,30,0,0,4,0],[1264,13,1264,30,0,0,4,1],[1265,13,1266,68,0,0,4,1],[1272,13,1272,30,0,0,4,0],[1272,13,1272,30,0,0,4,1],[1273,13,1274,68,0,0,4,1],[1280,13,1280,18,0,0,4,0],[1280,13,1280,18,0,0,4,1],[1282,17,1284,55,0,0,4,0],[1282,17,1284,55,0,0,4,1],[1285,17,1285,31,0,0,4,0],[1296,37,1296,42,0,0,4,0],[1296,37,1296,42,0,0,4,1],[1297,15,1297,39,0,0,4,0],[1297,15,1297,39,0,0,4,1],[1300,9,1300,33,0,0,4,0],[1300,9,1300,33,0,0,4,1],[1304,24,1304,32,0,0,4,0],[1304,24,1304,32,0,0,4,1],[1309,20,1309,32,0,0,4,0],[1309,20,1309,32,0,0,4,1]],\"putRGBAAcontig8bittile\":[[1682,12,1682,17,0,0,4,0],[1682,12,1682,17,0,0,4,1],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1344,13,1344,14,3,0,4,1],[1346,9,1346,15,3,0,4,1],[1348,9,1348,15,3,0,4,1],[1350,9,1350,15,3,0,4,1],[1352,9,1352,15,3,0,4,1],[1354,9,1354,15,3,0,4,0],[1356,9,1356,15,3,0,4,1],[1358,9,1358,15,3,0,4,1]],\"TIFFComputeStrip\":[[42,9,42,53,0,0,4,0],[42,9,42,53,0,0,4,1],[44,13,44,45,0,0,4,1]],\"_TIFFVGetField\":[[1227,9,1227,39,0,0,4,0],[1243,9,1243,35,0,0,4,0],[1246,9,1246,33,0,0,4,0],[1249,9,1249,33,0,0,4,0],[1258,9,1258,33,0,0,4,0],[1261,9,1261,37,0,0,4,0],[1264,9,1264,34,0,0,4,0],[1307,9,1307,34,0,0,4,0],[1327,9,1327,30,0,0,4,0],[1351,9,1351,34,0,0,4,0],[1355,9,1355,31,0,0,4,0],[1358,9,1358,32,0,0,4,0],[1411,9,1411,41,0,0,4,0],[1420,9,1420,16,0,0,4,0],[1433,17,1433,47,0,0,4,1],[1448,25,1448,52,0,0,4,0],[1448,25,1448,52,0,0,4,1],[1452,21,1452,47,0,0,4,0],[1452,21,1452,47,0,0,4,1],[1455,21,1455,41,0,0,4,1],[1464,26,1464,60,0,0,4,1],[1477,25,1477,54,0,0,4,1],[1478,25,1478,62,0,0,4,1],[1479,25,1479,63,0,0,4,1],[1480,25,1480,57,0,0,4,1],[1480,61,1480,74,0,0,4,0],[1480,61,1480,74,0,0,4,1],[1491,29,1491,43,0,0,4,1],[1492,29,1492,48,0,0,4,1],[1496,29,1496,44,0,0,4,1],[1500,29,1500,44,0,0,4,0],[1504,29,1504,45,0,0,4,1],[1508,29,1508,43,0,0,4,1],[1509,29,1509,42,0,0,4,1],[1513,29,1513,44,0,0,4,1],[1517,29,1517,44,0,0,4,1],[1518,29,1518,43,0,0,4,1],[1522,29,1522,45,0,0,4,1],[1526,29,1526,47,0,0,4,1],[1527,29,1527,48,0,0,4,1],[1557,29,1557,44,0,0,4,1],[1561,29,1561,45,0,0,4,1],[1565,29,1565,36,0,0,4,1]],\"gtTileSeparate\":[[873,33,873,38,0,0,4,0],[873,33,873,38,0,0,4,1],[874,9,874,21,0,0,4,1],[883,9,883,31,0,0,4,1],[896,13,896,31,0,0,4,1],[908,9,908,36,0,0,4,1],[909,9,909,36,0,0,4,0],[909,9,909,36,0,0,4,1],[910,9,910,33,0,0,4,1],[914,9,914,16,0,0,4,0],[914,9,914,16,0,0,4,1],[925,19,925,27,0,0,4,0],[925,19,925,27,0,0,4,1],[925,31,925,38,0,0,4,0],[928,17,928,37,0,0,4,0],[928,17,928,37,0,0,4,1],[934,16,934,25,0,0,4,0],[936,17,936,28,0,0,4,0],[938,21,940,69,0,0,4,0],[938,21,940,69,0,0,4,1],[941,22,941,33,0,0,4,0],[941,22,941,33,0,0,4,1],[941,37,941,51,0,0,4,0],[947,21,947,39,0,0,4,0],[950,27,950,32,0,0,4,0],[966,17,966,34,0,0,4,1],[974,17,974,34,0,0,4,1],[982,17,982,22,0,0,4,0],[983,17,984,62,0,0,4,0],[985,17,985,31,0,0,4,0],[1017,15,1017,39,0,0,4,1],[1020,9,1020,33,0,0,4,1]],\"OJPEGWriteHeaderInfo\":[[1359,13,1359,45,0,0,4,1]],\"gtTileContig\":[[730,9,730,21,0,0,4,1],[740,9,740,31,0,0,4,1],[753,13,753,31,0,0,4,0],[753,13,753,31,0,0,4,1],[769,19,769,27,0,0,4,0],[769,19,769,27,0,0,4,1],[769,31,769,38,0,0,4,0],[769,31,769,38,0,0,4,1],[772,17,772,37,0,0,4,0],[772,17,772,37,0,0,4,1],[778,16,778,25,0,0,4,0],[778,16,778,25,0,0,4,1],[780,17,782,65,0,0,4,0],[780,17,782,65,0,0,4,1],[783,18,783,29,0,0,4,0],[783,18,783,29,0,0,4,1],[783,33,783,47,0,0,4,0],[790,17,790,36,0,0,4,0],[790,17,790,36,0,0,4,1],[813,15,813,39,0,0,4,1],[817,9,817,33,0,0,4,1]],\"TIFFScanlineSize64\":[[253,46,253,65,0,0,4,1]],\"BuildMapBitdepth16To8\":[[3175,9,3175,35,0,0,4,1],[3181,17,3181,26,0,0,4,0],[3181,17,3181,26,0,0,4,1]],\"makebwmap\":[[2670,9,2670,22,0,0,4,0],[2670,9,2670,22,0,0,4,1],[2676,9,2676,27,0,0,4,1],[2683,17,2683,24,0,0,4,0],[2683,17,2683,24,0,0,4,1],[2687,17,2687,30,0,0,4,1],[2692,13,2692,19,0,0,4,0],[2692,13,2692,19,0,0,4,1],[2702,13,2702,19,0,0,4,0],[2702,13,2702,19,0,0,4,1],[2708,13,2708,19,0,0,4,0],[2708,13,2708,19,0,0,4,1],[2712,13,2712,19,0,0,4,0],[2712,13,2712,19,0,0,4,1],[2713,13,2713,20,0,0,4,0],[2713,13,2713,20,0,0,4,1]],\"TIFFRGBAImageBegin\":[[321,9,321,36,0,0,4,1],[344,9,344,15,0,0,4,0],[344,9,344,15,0,0,4,1],[345,9,345,15,0,0,4,0],[345,9,345,15,0,0,4,1],[346,9,346,15,0,0,4,0],[346,9,346,15,0,0,4,1],[347,9,347,15,0,0,4,0],[347,9,347,15,0,0,4,1],[348,9,348,16,0,0,4,0],[348,9,348,16,0,0,4,1],[350,9,350,16,0,0,4,1],[361,9,361,26,0,0,4,0],[361,9,361,26,0,0,4,1],[363,17,363,30,0,0,4,1],[365,13,365,41,0,0,4,0],[365,13,365,41,0,0,4,1],[367,21,368,22,0,0,4,0],[367,21,368,22,0,0,4,1],[371,13,371,40,0,0,4,0],[371,13,371,40,0,0,4,1],[372,13,372,40,0,0,4,0],[372,13,372,40,0,0,4,1],[379,9,379,67,0,0,4,0],[379,9,379,67,0,0,4,1],[382,9,382,26,0,0,4,0],[382,9,382,26,0,0,4,1],[382,30,382,55,0,0,4,0],[382,30,382,55,0,0,4,1],[383,9,383,44,0,0,4,1],[393,9,393,67,0,0,4,0],[393,9,393,67,0,0,4,1],[397,13,397,19,0,0,4,0],[398,21,398,44,0,0,4,0],[398,21,398,44,0,0,4,1],[403,13,403,19,0,0,4,1],[406,13,406,20,0,0,4,1],[414,9,414,33,0,0,4,0],[414,9,414,33,0,0,4,1],[415,17,416,42,0,0,4,1],[431,17,431,30,0,0,4,1],[431,34,431,49,0,0,4,1],[431,53,431,67,0,0,4,1],[443,9,443,36,0,0,4,0],[443,9,443,36,0,0,4,1],[444,9,444,36,0,0,4,0],[444,9,444,36,0,0,4,1],[445,17,445,52,0,0,4,0],[445,17,445,52,0,0,4,1],[446,17,446,42,0,0,4,0],[446,17,446,42,0,0,4,1],[446,46,446,68,0,0,4,1],[458,9,458,31,0,0,4,0],[458,9,458,31,0,0,4,1],[460,17,460,52,0,0,4,0],[460,17,460,52,0,0,4,1],[465,21,465,42,0,0,4,0],[465,21,465,42,0,0,4,1],[476,21,476,28,0,0,4,0],[476,21,476,28,0,0,4,1],[487,9,487,29,0,0,4,0],[487,9,487,29,0,0,4,1],[488,17,488,34,0,0,4,1],[496,9,496,35,0,0,4,0],[496,9,496,35,0,0,4,1],[500,17,500,38,0,0,4,1],[508,17,508,41,0,0,4,1],[518,9,518,30,0,0,4,1],[530,9,530,32,0,0,4,1],[551,9,551,32,0,0,4,0],[551,9,551,32,0,0,4,1],[553,9,553,16,0,0,4,1],[563,11,563,48,0,0,4,0],[563,11,563,48,0,0,4,1],[563,52,563,76,0,0,4,0],[563,52,563,76,0,0,4,1],[564,9,564,22,0,0,4,0],[564,9,564,22,0,0,4,1],[566,13,566,33,0,0,4,0],[566,13,566,33,0,0,4,1],[574,13,574,35,0,0,4,0],[574,13,574,35,0,0,4,1]],\"TIFFCheckTile\":[[75,9,75,31,0,0,4,1],[81,9,81,32,0,0,4,1],[88,9,88,31,0,0,4,1],[94,9,94,53,0,0,4,0],[94,9,94,53,0,0,4,1],[95,9,95,36,0,0,4,1]],\"TIFFRGBAImageGet\":[[590,9,590,25,0,0,4,1],[596,9,596,29,0,0,4,1]],\"LogL16toY\":[[791,9,791,12,0,0,4,1],[794,13,794,28,0,0,4,0]],\"putRGBseparate8bittile\":[[1860,12,1860,17,0,0,4,0],[1860,12,1860,17,0,0,4,1],[1376,22,1376,29,1,0,4,0],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1344,13,1344,14,4,0,4,1],[1346,9,1346,15,4,0,4,0],[1348,9,1348,15,4,0,4,1],[1350,9,1350,15,4,0,4,1],[1352,9,1352,15,4,0,4,1],[1354,9,1354,15,4,0,4,1],[1356,9,1356,15,4,0,4,1],[1358,9,1358,15,4,0,4,1]],\"put4bitbwtile\":[[1643,12,1643,17,0,0,4,0],[1643,12,1643,17,0,0,4,1],[1404,22,1404,29,1,0,4,0],[1404,22,1404,29,1,0,4,1],[1409,13,1409,15,1,0,4,0],[1409,13,1409,15,1,0,4,1]],\"cvtcmap\":[[2792,46,2792,52,0,0,4,0],[2792,46,2792,52,0,0,4,1]],\"setorientation\":[[648,9,648,33,0,0,4,0],[648,9,648,33,0,0,4,1],[649,9,649,33,0,0,4,0],[649,9,649,33,0,0,4,1],[650,17,650,61,0,0,4,1],[651,17,651,61,0,0,4,1],[653,22,653,66,0,0,4,1],[654,22,654,66,0,0,4,1],[656,22,656,65,0,0,4,0],[656,22,656,65,0,0,4,1],[657,22,657,65,0,0,4,1],[661,9,661,34,0,0,4,0],[661,9,661,34,0,0,4,1],[662,9,662,34,0,0,4,1],[663,17,663,60,0,0,4,1],[664,17,664,60,0,0,4,1],[666,22,666,66,0,0,4,1],[667,22,667,66,0,0,4,1],[669,22,669,65,0,0,4,0],[669,22,669,65,0,0,4,1],[670,22,670,65,0,0,4,1],[674,9,674,34,0,0,4,0],[674,9,674,34,0,0,4,1],[675,9,675,34,0,0,4,1],[676,17,676,60,0,0,4,1],[677,17,677,60,0,0,4,1],[679,22,679,66,0,0,4,1],[680,22,680,66,0,0,4,1],[682,22,682,65,0,0,4,0],[682,22,682,65,0,0,4,1],[683,22,683,65,0,0,4,1],[687,9,687,33,0,0,4,0],[687,9,687,33,0,0,4,1],[688,9,688,33,0,0,4,0],[688,9,688,33,0,0,4,1],[689,17,689,60,0,0,4,1],[690,17,690,60,0,0,4,1],[692,22,692,66,0,0,4,1],[693,22,693,66,0,0,4,1],[695,22,695,66,0,0,4,1],[696,22,696,66,0,0,4,1],[700,9,700,16,0,0,4,1]],\"PickSeparateCase\":[[3076,16,3076,37,0,0,4,0],[3076,16,3076,37,0,0,4,1],[3078,13,3078,29,0,0,4,0],[3078,13,3078,29,0,0,4,1],[3080,9,3080,36,0,0,4,0],[3080,9,3080,36,0,0,4,1],[3081,9,3081,36,0,0,4,0],[3081,9,3081,36,0,0,4,1],[3084,9,3084,29,0,0,4,1],[3085,21,3085,39,0,0,4,0],[3085,21,3085,39,0,0,4,1],[3087,17,3087,23,0,0,4,0],[3087,17,3087,23,0,0,4,1],[3088,25,3088,61,0,0,4,0],[3088,25,3088,61,0,0,4,1],[3090,30,3090,66,0,0,4,0],[3090,30,3090,66,0,0,4,1],[3092,29,3092,48,0,0,4,0],[3098,17,3098,24,0,0,4,0],[3098,17,3098,24,0,0,4,1],[3099,25,3099,61,0,0,4,0],[3099,25,3099,61,0,0,4,1],[3101,29,3101,55,0,0,4,0],[3104,30,3104,66,0,0,4,0],[3104,30,3104,66,0,0,4,1],[3106,29,3106,55,0,0,4,0],[3106,59,3106,78,0,0,4,0],[3111,29,3111,55,0,0,4,0],[3117,9,3117,35,0,0,4,0],[3117,9,3117,35,0,0,4,1],[3118,17,3118,40,0,0,4,0],[3118,17,3118,40,0,0,4,1],[3118,44,3118,69,0,0,4,0],[3125,9,3125,31,0,0,4,0],[3125,9,3125,31,0,0,4,1],[3126,17,3126,42,0,0,4,0],[3126,17,3126,42,0,0,4,1],[3126,46,3126,73,0,0,4,0],[3128,21,3128,50,0,0,4,0],[3133,29,3133,43,0,0,4,0],[3133,29,3133,43,0,0,4,1],[3135,25,3135,34,0,0,4,0],[3135,25,3135,34,0,0,4,1],[3144,13,3144,31,0,0,4,0],[3144,35,3144,62,0,0,4,0],[3144,35,3144,62,0,0,4,1]],\"TIFFYCbCrtoRGB\":[[197,26,197,37,1,0,4,1],[196,6,196,23,2,0,4,1],[196,34,196,45,2,0,4,1],[196,6,196,23,3,0,4,1],[196,34,196,45,3,0,4,1],[196,6,196,23,4,0,4,0],[196,6,196,23,4,0,4,1],[196,34,196,45,4,0,4,0],[196,34,196,45,4,0,4,1],[196,6,196,23,6,0,4,0],[196,6,196,23,6,0,4,1],[196,34,196,45,6,0,4,0],[196,34,196,45,6,0,4,1],[196,6,196,23,7,0,4,0],[196,6,196,23,7,0,4,1],[196,34,196,45,7,0,4,0],[196,34,196,45,7,0,4,1]],\"TIFFReadRGBAStripExt\":[[3208,9,3208,25,0,0,4,0],[3208,9,3208,25,0,0,4,1],[3216,9,3216,34,0,0,4,1],[3224,9,3224,35,0,0,4,0],[3225,9,3225,59,0,0,4,0],[3231,13,3231,44,0,0,4,0],[3231,13,3231,44,0,0,4,1]],\"TIFFReadEncodedTile\":[[961,9,961,31,0,0,4,0]],\"TIFFReadTile\":[[919,9,919,31,0,0,4,1],[919,35,919,66,0,0,4,1]],\"_TIFFReadEncodedTileAndAllocBuffer\":[[1007,9,1007,21,0,0,4,0],[1007,9,1007,21,0,0,4,1],[1012,9,1012,31,0,0,4,1],[1014,9,1014,31,0,0,4,1],[1022,9,1022,33,0,0,4,0],[1022,9,1022,33,0,0,4,1],[1027,9,1027,47,0,0,4,0],[1027,9,1027,47,0,0,4,1],[1029,13,1029,45,0,0,4,0],[1029,13,1029,45,0,0,4,1],[1046,13,1046,51,0,0,4,1],[1047,15,1047,52,0,0,4,1],[1053,19,1053,57,0,0,4,1],[1054,13,1054,47,0,0,4,0],[1054,13,1054,47,0,0,4,1],[1055,13,1055,66,0,0,4,0],[1068,9,1068,21,0,0,4,1],[1075,9,1075,39,0,0,4,0],[1079,9,1080,73,0,0,4,0],[1079,9,1080,73,0,0,4,1]],\"putRGBcontig8bittile\":[[1662,12,1662,17,0,0,4,0],[1662,12,1662,17,0,0,4,1],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1344,13,1344,14,3,0,4,1],[1346,9,1346,15,3,0,4,1],[1348,9,1348,15,3,0,4,1],[1350,9,1350,15,3,0,4,1],[1352,9,1352,15,3,0,4,1],[1354,9,1354,15,3,0,4,0],[1356,9,1356,15,3,0,4,1],[1358,9,1358,15,3,0,4,1]],\"_TIFFReadEncodedStripAndAllocBuffer\":[[568,9,568,21,0,0,4,0],[568,9,568,21,0,0,4,1],[574,9,574,43,0,0,4,1],[577,9,577,41,0,0,4,0],[577,45,577,76,0,0,4,0],[577,45,577,76,0,0,4,1],[579,9,579,35,0,0,4,0],[579,9,579,35,0,0,4,1],[583,9,583,21,0,0,4,1],[590,9,590,71,0,0,4,0],[590,9,590,71,0,0,4,1]],\"makecmap\":[[2822,9,2822,28,0,0,4,1],[2829,17,2829,24,0,0,4,0],[2829,17,2829,24,0,0,4,1],[2836,17,2836,30,0,0,4,1],[2838,13,2838,19,0,0,4,1],[2848,13,2848,19,0,0,4,0],[2854,13,2854,19,0,0,4,1],[2858,13,2858,19,0,0,4,1]],\"putRGBUAseparate8bittile\":[[1914,12,1914,17,0,0,4,0],[1914,12,1914,17,0,0,4,1],[1918,21,1918,26,0,0,4,0],[1918,21,1918,26,0,0,4,1]],\"Fax4Decode\":[[495,33,495,47,3,0,4,0],[328,13,328,24,65,0,4,1],[170,21,170,35,85,0,4,0],[170,21,170,35,85,0,4,1],[117,21,117,31,145,0,4,0]],\"buildMap\":[[2873,13,2873,29,0,0,4,0],[2873,13,2873,29,0,0,4,1],[2875,9,2875,29,0,0,4,1],[2876,9,2876,31,0,0,4,1],[2877,9,2877,35,0,0,4,0],[2877,9,2877,35,0,0,4,1],[2878,17,2878,40,0,0,4,0],[2878,17,2878,40,0,0,4,1],[2881,9,2881,36,0,0,4,0],[2881,9,2881,36,0,0,4,1],[2882,9,2882,36,0,0,4,0],[2882,9,2882,36,0,0,4,1],[2883,17,2883,31,0,0,4,1],[2886,9,2886,33,0,0,4,0],[2886,9,2886,33,0,0,4,1],[2891,17,2891,37,0,0,4,0],[2891,17,2891,37,0,0,4,1],[2900,17,2900,40,0,0,4,0],[2900,44,2900,58,0,0,4,1]],\"TIFFDefaultRefBlackWhite\":[[178,9,178,37,0,0,4,1],[180,9,180,48,0,0,4,0]],\"BuildMapUaToAa\":[[3154,9,3154,28,0,0,4,1],[3160,18,3160,26,0,0,4,0],[3160,18,3160,26,0,0,4,1],[3162,22,3162,30,0,0,4,0],[3162,22,3162,30,0,0,4,1]],\"setupMap\":[[2734,9,2734,33,0,0,4,0],[2734,9,2734,33,0,0,4,1],[2739,9,2739,25,0,0,4,1],[2745,9,2745,51,0,0,4,0],[2745,9,2745,51,0,0,4,1],[2747,21,2747,31,0,0,4,0],[2747,21,2747,31,0,0,4,1],[2752,21,2752,31,0,0,4,0],[2752,21,2752,31,0,0,4,1],[2755,9,2755,33,0,0,4,0],[2756,10,2756,52,0,0,4,0],[2756,10,2756,52,0,0,4,1],[2757,10,2757,52,0,0,4,0],[2757,10,2757,52,0,0,4,1],[2763,13,2763,28,0,0,4,1]],\"putRGBcontig8bitCMYKtile\":[[1806,12,1806,17,0,0,4,0],[1806,12,1806,17,0,0,4,1],[1376,22,1376,29,1,0,4,0],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1381,13,1381,19,1,0,4,1],[1344,13,1344,14,3,0,4,1],[1346,9,1346,15,3,0,4,1],[1348,9,1348,15,3,0,4,1],[1350,9,1350,15,3,0,4,1],[1352,9,1352,15,3,0,4,1],[1354,9,1354,15,3,0,4,0],[1354,9,1354,15,3,0,4,1],[1356,9,1356,15,3,0,4,0],[1356,9,1356,15,3,0,4,1],[1358,9,1358,15,3,0,4,0],[1358,9,1358,15,3,0,4,1]],\"TIFFVStripSize64\":[[84,54,84,73,0,0,4,1]],\"putcontig8bitYCbCr22tile\":[[2371,12,2371,18,0,0,4,0],[2371,12,2371,18,0,0,4,1],[2374,16,2374,22,0,0,4,0],[2374,16,2374,22,0,0,4,1],[2387,13,2387,19,0,0,4,0],[2387,13,2387,19,0,0,4,1],[2402,9,2402,15,0,0,4,0],[2402,9,2402,15,0,0,4,1],[2405,16,2405,22,0,0,4,0],[2405,16,2405,22,0,0,4,1],[2416,13,2416,19,0,0,4,0],[2416,13,2416,19,0,0,4,1]],\"JPEGResetUpsampled\":[[2551,13,2551,65,0,0,4,0],[2569,9,2569,30,0,0,4,0],[2571,9,2571,34,0,0,4,0],[250,22,250,62,7,0,4,0]],\"TIFFXYZToRGB\":[[306,24,306,33,1,0,4,0],[306,24,306,33,1,0,4,1],[306,24,306,33,2,0,4,0],[306,24,306,33,2,0,4,1],[306,24,306,33,3,0,4,0],[306,24,306,33,3,0,4,1],[307,24,307,33,4,0,4,0],[307,24,307,33,4,0,4,1],[307,24,307,33,5,0,4,0],[307,24,307,33,5,0,4,1],[307,24,307,33,6,0,4,0],[307,24,307,33,6,0,4,1],[307,24,307,33,7,0,4,1],[85,29,85,36,8,0,4,0],[85,29,85,36,8,0,4,1],[307,24,307,33,9,0,4,1],[85,29,85,36,10,0,4,0],[85,29,85,36,10,0,4,1],[307,24,307,33,11,0,4,1],[85,29,85,36,12,0,4,0],[85,29,85,36,12,0,4,1],[307,24,307,33,13,0,4,0],[307,24,307,33,13,0,4,1],[307,24,307,33,14,0,4,0],[307,24,307,33,14,0,4,1],[307,24,307,33,15,0,4,0],[307,24,307,33,15,0,4,1]],\"JPEGVSetField\":[[2600,9,2600,35,0,0,4,0]],\"OJPEGPreDecode\":[[760,13,761,48,0,0,4,0]],\"isInRefBlackWhiteRange\":[[2556,12,2556,42,0,0,4,0],[2556,12,2556,42,0,0,4,1],[2556,46,2556,67,0,0,4,0],[2556,46,2556,67,0,0,4,1]],\"PickContigCase\":[[2912,16,2912,37,0,0,4,0],[2912,16,2912,37,0,0,4,1],[2914,13,2914,29,0,0,4,1],[2916,9,2916,29,0,0,4,0],[2916,9,2916,29,0,0,4,1],[2917,21,2917,39,0,0,4,0],[2917,21,2917,39,0,0,4,1],[2919,17,2919,23,0,0,4,0],[2919,17,2919,23,0,0,4,1],[2920,25,2920,61,0,0,4,0],[2920,25,2920,61,0,0,4,1],[2921,25,2921,50,0,0,4,0],[2921,25,2921,50,0,0,4,1],[2923,30,2923,66,0,0,4,0],[2923,30,2923,66,0,0,4,1],[2924,30,2924,55,0,0,4,0],[2924,30,2924,55,0,0,4,1],[2926,29,2926,48,0,0,4,0],[2929,30,2929,55,0,0,4,0],[2929,30,2929,55,0,0,4,1],[2932,17,2932,24,0,0,4,0],[2932,17,2932,24,0,0,4,1],[2933,25,2933,61,0,0,4,0],[2933,25,2933,61,0,0,4,1],[2934,25,2934,50,0,0,4,1],[2939,30,2939,66,0,0,4,0],[2939,30,2939,66,0,0,4,1],[2940,30,2940,55,0,0,4,1],[2945,30,2945,55,0,0,4,0],[2947,29,2947,55,0,0,4,0],[2953,9,2953,35,0,0,4,0],[2953,9,2953,35,0,0,4,1],[2954,17,2954,42,0,0,4,0],[2954,46,2954,59,0,0,4,0],[2956,21,2956,44,0,0,4,0],[2956,21,2956,44,0,0,4,1],[2958,25,2958,34,0,0,4,0],[2965,9,2965,33,0,0,4,0],[2965,9,2965,33,0,0,4,1],[2966,17,2966,30,0,0,4,0],[2968,25,2968,43,0,0,4,1],[2970,21,2970,27,0,0,4,1],[2973,21,2973,27,0,0,4,1],[2976,21,2976,27,0,0,4,0],[2979,21,2979,27,0,0,4,1],[2985,9,2985,36,0,0,4,0],[2985,9,2985,36,0,0,4,1],[2986,9,2986,36,0,0,4,0],[2986,9,2986,36,0,0,4,1],[2987,17,2987,30,0,0,4,0],[2989,25,2989,43,0,0,4,1],[2991,21,2991,28,0,0,4,0],[2991,21,2991,28,0,0,4,1],[2994,21,2994,27,0,0,4,0],[2994,21,2994,27,0,0,4,1],[2995,29,2995,39,0,0,4,0],[2995,29,2995,39,0,0,4,1],[2995,43,2995,68,0,0,4,0],[2995,43,2995,68,0,0,4,1],[3000,21,3000,27,0,0,4,0],[3000,21,3000,27,0,0,4,1],[3003,21,3003,27,0,0,4,0],[3003,21,3003,27,0,0,4,1],[3006,21,3006,27,0,0,4,0],[3006,21,3006,27,0,0,4,1],[3012,9,3012,31,0,0,4,0],[3012,9,3012,31,0,0,4,1],[3013,17,3013,42,0,0,4,0],[3013,17,3013,42,0,0,4,1],[3013,46,3013,73,0,0,4,0],[3013,46,3013,73,0,0,4,1],[3015,21,3015,50,0,0,4,0],[3015,21,3015,50,0,0,4,1],[3030,29,3030,67,0,0,4,0],[3030,29,3030,67,0,0,4,1],[3032,25,3032,34,0,0,4,0],[3032,25,3032,34,0,0,4,1],[3035,25,3035,34,0,0,4,0],[3035,25,3035,34,0,0,4,1],[3038,25,3038,34,0,0,4,0],[3038,25,3038,34,0,0,4,1],[3041,25,3041,34,0,0,4,0],[3041,25,3041,34,0,0,4,1],[3044,25,3044,34,0,0,4,0],[3044,25,3044,34,0,0,4,1],[3047,25,3047,34,0,0,4,0],[3047,25,3047,34,0,0,4,1],[3050,25,3050,34,0,0,4,0],[3050,25,3050,34,0,0,4,1],[3057,9,3057,32,0,0,4,0],[3057,9,3057,32,0,0,4,1],[3058,17,3058,42,0,0,4,0],[3058,46,3058,59,0,0,4,0],[3060,21,3060,44,0,0,4,0],[3065,13,3065,31,0,0,4,0],[3065,35,3065,60,0,0,4,0],[3065,35,3065,60,0,0,4,1]],\"put16bitbwtile\":[[1578,12,1578,17,0,0,4,0],[1578,12,1578,17,0,0,4,1],[1582,21,1582,26,0,0,4,0],[1582,21,1582,26,0,0,4,1]],\"TIFFRGBAImageEnd\":[[255,9,255,17,0,0,4,0],[255,9,255,17,0,0,4,1],[260,9,260,19,0,0,4,0],[260,9,260,19,0,0,4,1],[265,9,265,20,0,0,4,0],[265,9,265,20,0,0,4,1],[270,9,270,19,0,0,4,0],[270,9,270,19,0,0,4,1],[275,9,275,20,0,0,4,0],[275,9,275,20,0,0,4,1],[280,9,280,20,0,0,4,0],[280,9,280,20,0,0,4,1],[285,9,285,27,0,0,4,0],[285,9,285,27,0,0,4,1],[291,9,291,21,0,0,4,0],[291,9,291,21,0,0,4,1]],\"put2bitcmaptile\":[[1499,12,1499,17,0,0,4,0],[1499,12,1499,17,0,0,4,1],[1390,22,1390,29,1,0,4,0],[1390,22,1390,29,1,0,4,1],[1395,13,1395,19,1,0,4,0],[1395,13,1395,19,1,0,4,1],[1362,13,1362,14,3,0,4,1],[1364,9,1364,15,3,0,4,0],[1364,9,1364,15,3,0,4,1],[1366,9,1366,15,3,0,4,0],[1366,9,1366,15,3,0,4,1],[1368,9,1368,15,3,0,4,0],[1368,9,1368,15,3,0,4,1]],\"TIFFVTileSize64\":[[197,42,197,61,0,0,4,1]],\"TIFFVGetFieldDefaulted\":[[225,9,225,35,0,0,4,0],[234,9,234,33,0,0,4,0],[237,9,237,37,0,0,4,0],[240,9,240,34,0,0,4,0],[297,9,297,28,0,0,4,0],[303,9,303,34,0,0,4,0],[324,9,324,39,0,0,4,0],[331,9,331,38,0,0,4,1],[338,9,338,32,0,0,4,0],[364,9,364,41,0,0,4,0],[365,17,365,38,0,0,4,0],[365,17,365,38,0,0,4,1],[365,42,365,76,0,0,4,1]],\"initYCbCrConversion\":[[2565,9,2565,27,0,0,4,0],[2571,13,2571,31,0,0,4,1],[2585,9,2585,27,0,0,4,1],[2585,31,2585,49,0,0,4,1],[2585,53,2585,67,0,0,4,1],[2586,9,2586,27,0,0,4,1],[2593,9,2593,50,0,0,4,0],[2593,9,2593,50,0,0,4,1],[2594,9,2594,50,0,0,4,0],[2594,9,2594,50,0,0,4,1],[2595,9,2595,50,0,0,4,0],[2595,9,2595,50,0,0,4,1],[2596,9,2596,50,0,0,4,0],[2596,9,2596,50,0,0,4,1],[2597,9,2597,50,0,0,4,0],[2597,9,2597,50,0,0,4,1],[2598,9,2598,50,0,0,4,1],[2605,9,2605,64,0,0,4,1]],\"TIFFCIELab16ToXYZ\":[[61,9,61,19,0,0,4,0],[61,9,61,19,0,0,4,1],[73,9,73,22,0,0,4,0],[73,9,73,22,0,0,4,1],[79,9,79,22,0,0,4,0],[79,9,79,22,0,0,4,1]],\"checkcmap\":[[2779,12,2779,19,0,0,4,0],[2779,12,2779,19,0,0,4,1],[2780,13,2780,24,0,0,4,0],[2780,13,2780,24,0,0,4,1],[2780,28,2780,39,0,0,4,0],[2780,28,2780,39,0,0,4,1],[2780,43,2780,54,0,0,4,0],[2780,43,2780,54,0,0,4,1]],\"gtStripContig\":[[1068,9,1068,28,0,0,4,0],[1068,9,1068,28,0,0,4,1],[1078,9,1078,31,0,0,4,0],[1078,9,1078,31,0,0,4,1],[1080,13,1080,24,0,0,4,1],[1097,17,1097,31,0,0,4,1],[1098,19,1098,26,0,0,4,0],[1098,19,1098,26,0,0,4,1],[1102,17,1102,37,0,0,4,0],[1102,17,1102,37,0,0,4,1],[1104,13,1104,44,0,0,4,0],[1104,13,1104,44,0,0,4,1],[1107,13,1107,25,0,0,4,0],[1107,29,1107,74,0,0,4,1],[1113,13,1116,51,0,0,4,0],[1113,13,1116,51,0,0,4,1],[1117,14,1117,25,0,0,4,0],[1117,14,1117,25,0,0,4,1],[1117,29,1117,43,0,0,4,0],[1128,15,1128,39,0,0,4,0],[1128,15,1128,39,0,0,4,1],[1131,9,1131,33,0,0,4,0],[1131,9,1131,33,0,0,4,1],[1135,24,1135,32,0,0,4,0],[1135,24,1135,32,0,0,4,1],[1140,20,1140,32,0,0,4,0],[1140,20,1140,32,0,0,4,1]],\"TIFFCIELabToRGBInit\":[[149,17,149,35,0,0,4,0],[149,17,149,35,0,0,4,1],[159,17,159,35,0,0,4,0],[159,17,159,35,0,0,4,1],[169,17,169,35,0,0,4,0],[169,17,169,35,0,0,4,1]],\"isCCITTCompression\":[[304,13,304,46,0,0,4,0],[304,13,304,46,0,0,4,1],[305,13,305,46,0,0,4,0],[305,13,305,46,0,0,4,1],[306,13,306,45,0,0,4,0],[306,13,306,45,0,0,4,1],[307,13,307,46,0,0,4,0],[307,13,307,46,0,0,4,1]],\"uv_encode\":[[971,9,971,29,0,0,4,1]],\"put1bitbwtile\":[[1605,12,1605,17,0,0,4,0],[1605,12,1605,17,0,0,4,1],[1376,22,1376,29,1,0,4,0],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1381,13,1381,19,1,0,4,1],[1344,13,1344,14,3,0,4,1],[1346,9,1346,15,3,0,4,0],[1346,9,1346,15,3,0,4,1],[1348,9,1348,15,3,0,4,0],[1348,9,1348,15,3,0,4,1],[1350,9,1350,15,3,0,4,0],[1350,9,1350,15,3,0,4,1],[1352,9,1352,15,3,0,4,0],[1352,9,1352,15,3,0,4,1],[1354,9,1354,15,3,0,4,0],[1354,9,1354,15,3,0,4,1],[1356,9,1356,15,3,0,4,0],[1356,9,1356,15,3,0,4,1],[1358,9,1358,15,3,0,4,0],[1358,9,1358,15,3,0,4,1]],\"putRGBAAseparate8bittile\":[[1876,12,1876,17,0,0,4,0],[1876,12,1876,17,0,0,4,1],[1376,22,1376,29,1,0,4,0],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,1]],\"putagreytile\":[[1557,12,1557,17,0,0,4,0],[1557,12,1557,17,0,0,4,1],[1559,21,1559,26,0,0,4,0],[1559,21,1559,26,0,0,4,1]],\"putCMYKseparate8bittile\":[[1891,12,1891,17,0,0,4,0],[1891,12,1891,17,0,0,4,1],[1894,21,1894,26,0,0,4,0],[1894,21,1894,26,0,0,4,1]],\"putRGBseparate16bittile\":[[1943,12,1943,17,0,0,4,0],[1943,12,1943,17,0,0,4,1],[1945,21,1945,26,0,0,4,0],[1945,21,1945,26,0,0,4,1]],\"putcontig8bitCIELab8\":[[2012,12,2012,17,0,0,4,0],[2012,12,2012,17,0,0,4,1],[2014,21,2014,26,0,0,4,0],[2014,21,2014,26,0,0,4,1]],\"putgreytile\":[[1536,12,1536,17,0,0,4,0],[1536,12,1536,17,0,0,4,1],[1538,21,1538,26,0,0,4,0],[1538,21,1538,26,0,0,4,1]],\"put2bitbwtile\":[[1624,12,1624,17,0,0,4,0],[1624,12,1624,17,0,0,4,1],[1390,22,1390,29,1,0,4,0],[1390,22,1390,29,1,0,4,1],[1395,13,1395,19,1,0,4,0],[1395,13,1395,19,1,0,4,1],[1362,13,1362,14,3,0,4,1],[1364,9,1364,15,3,0,4,0],[1364,9,1364,15,3,0,4,1],[1366,9,1366,15,3,0,4,0],[1366,9,1366,15,3,0,4,1],[1368,9,1368,15,3,0,4,0],[1368,9,1368,15,3,0,4,1]]},\"library_calls\":[\"TIFFStreamOpen\",\"TIFFGetField\",\"TIFFGetField\",\"_TIFFmalloc\",\"TIFFReadRGBAImageOriented\",\"_TIFFfree\",\"TIFFClose\",\"TIFFStripSize64\",\"TIFFIsByteSwapped\",\"TIFFSetTagExtender\",\"TIFFFlushData\",\"LogL16toY\",\"TIFFReadRGBAStripExt\",\"LogLuv24fromXYZ\",\"_TIFFfree\",\"TIFFClose\"],\"critical_calls\":[\"TIFFStreamOpen\",\"TIFFGetField\",\"TIFFGetField\",\"_TIFFmalloc\",\"TIFFReadRGBAImageOriented\",\"TIFFStripSize64\",\"TIFFIsByteSwapped\",\"TIFFSetTagExtender\",\"TIFFFlushData\",\"LogL16toY\",\"TIFFReadRGBAStripExt\",\"LogLuv24fromXYZ\",\"_TIFFfree\",\"TIFFClose\"],\"visited\":4}\n/*Here is the completed LLVMFuzzerTestOneInput_13 function that utilizes the libtiff library APIs to achieve the desired event:\n\n*/\n\n\nextern \"C\" int LLVMFuzzerTestOneInput_13(const uint8_t* f_data, size_t f_size) {\n\tif(f_size\u003c30) return 0;\n\n\t\n\t//fuzzer vars shim {\n\t\tFuzzedDataProvider fdp(f_data, f_size);\n\t\tFDPConsumeRawBytes(const uint8_t *, data, size, fdp)\n\t\tFDPConsumeRandomLengthString(char, fuzz_str_1, fuzz_str_sz_1, fdp);\n\t\tFDPConsumeIntegral(int32_t, fuzz_int32_t_2, fdp);\n\t\tFDPConsumeIntegral(int32_t, fuzz_int32_t_3, fdp);\n\t\tFDPConsumeIntegral(int32_t, fuzz_int32_t_4, fdp);\n\t\tFDPConsumeIntegral(uint32_t, fuzz_uint32_t_5, fdp);\n\t\tFDPConsumeIntegral(int32_t, fuzz_int32_t_6, fdp);\n\t//fuzzer shim end}\n\n\n\n\n    // Write data into input_file\n    FILE* in_file = fopen(\"input_file\", \"wb\");\n    if (in_file == NULL) {\n        assert_file_closed(\u0026in_file);\n\treturn 0;\n    }\n    fwrite(data, sizeof(uint8_t), size, in_file);\n    assert_file_closed(\u0026in_file);;\n\n    // Open input tiff in memory\n    std::istringstream s(std::string(data, data + size));\n    TIFF* in_tif = TIFFStreamOpen(fuzz_str_1, \u0026s);\n    if (!in_tif) {\n        assert_file_closed(\u0026in_file);\n\treturn 0;\n    }\n\n    uint32_t width, height;\n    uint32_t* raster;\n\n    // Read the RGBA image\n    TIFFGetField(in_tif, TIFFTAG_IMAGEWIDTH, \u0026width);\n    TIFFGetField(in_tif, TIFFTAG_IMAGELENGTH, \u0026height);\n    raster = (uint32_t*) _TIFFmalloc(width * height * sizeof(uint32_t));\n\n    if (raster != NULL) {\n        if (TIFFReadRGBAImageOriented(in_tif, width, height, raster, fuzz_int32_t_2, fuzz_int32_t_3) == 0) {\n            _TIFFfree(raster);\n            TIFFClose(in_tif);\n            assert_file_closed(\u0026in_file);\n\treturn 0;\n        }\n\n        // Perform desired event using libtiff APIs\n        uint64_t strip_size = TIFFStripSize64(in_tif);\n        int is_byte_swapped = TIFFIsByteSwapped(in_tif);\n        TIFFExtendProc tag_extender = TIFFSetTagExtender(NULL);\n        TIFFFlushData(in_tif);\n        double log_l16_to_y = LogL16toY(fuzz_int32_t_4);\n        int stop_on_error = 0;\n        TIFFReadRGBAStripExt(in_tif, fuzz_uint32_t_5, raster, fuzz_int32_t_6);\n        float xyz[3] = {1.0f, 1.0f, 1.0f};\n        uint32_t log_luv_24 = LogLuv24fromXYZ(xyz, 1);\n\n        _TIFFfree(raster);\n    }\n\n    TIFFClose(in_tif);\n    assert_file_closed(\u0026in_file);\n\treturn 0;\n}",
        "name": "id_000013.cc",
        "path": "examples/libtiff/fuzzer_1/fuzzers/id_000013.cc",
        "url": "/github.com/PromptFuzz/PromptFuzz/-/blob/examples/libtiff/fuzzer_1/fuzzers/id_000013.cc"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              9710,
              16
            ]
          ],
          "preview": "//\u003cQuality\u003e {\"density\":13,\"unique_branches\":{\"CLAMPw\":[[222,9,222,17,0,0,4,0],[222,9,222,17,0,0,4,1],[227,9,227,17,0,0,4,0],[227,9,227,17,0,0,4,1]],\"TIFFYCbCrToRGBInit\":[[265,17,265,24,0,0,4,0],[265,17,265,24,0,0,4,1],[296,31,296,38,0,0,4,0],[296,31,296,38,0,0,4,1],[189,28,189,29,3,0,4,1],[189,28,189,29,3,0,4,0],[189,28,189,29,3,0,4,1],[189,28,189,29,6,0,4,1],[189,28,189,29,6,0,4,0],[189,28,189,29,6,0,4,1],[189,28,189,29,8,0,4,1],[189,28,189,29,8,0,4,0],[189,28,189,29,8,0,4,1],[189,28,189,29,11,0,4,1],[189,28,189,29,11,0,4,0],[189,28,189,29,11,0,4,1],[193,14,193,32,12,0,4,0],[193,14,193,32,12,0,4,1],[193,14,193,32,13,0,4,0],[193,14,193,32,13,0,4,1],[193,14,193,32,19,0,4,0],[193,14,193,32,19,0,4,1]],\"TIFFReadRGBAImageOriented\":[[617,9,617,35,0,0,4,0],[617,9,617,35,0,0,4,1],[617,39,617,80,0,0,4,0],[617,39,617,80,0,0,4,1]],\"_TIFFReadTileAndAllocBuffer\":[[986,9,986,31,0,0,4,1],[986,35,986,66,0,0,4,1]],\"Fax3DecodeRLE\":[[117,21,117,31,57,0,4,0]],\"LogLuv24fromXYZ\":[[1054,9,1054,12,0,0,4,1],[1054,16,1054,23,0,0,4,1],[1065,9,1065,15,0,0,4,1]],\"TIFFRGBAImageOK\":[[89,9,89,31,0,0,4,1],[97,9,97,15,0,0,4,0],[97,9,97,15,0,0,4,1],[98,9,98,15,0,0,4,0],[98,9,98,15,0,0,4,1],[99,9,99,15,0,0,4,0],[99,9,99,15,0,0,4,1],[100,9,100,15,0,0,4,0],[100,9,100,15,0,0,4,1],[101,9,101,16,0,0,4,0],[101,9,101,16,0,0,4,1],[103,9,103,16,0,0,4,0],[103,9,103,16,0,0,4,1],[110,9,110,51,0,0,4,0],[110,9,110,51,0,0,4,1],[118,9,118,62,0,0,4,0],[118,9,118,62,0,0,4,1],[122,13,122,19,0,0,4,0],[122,13,122,19,0,0,4,1],[125,13,125,19,0,0,4,1],[128,13,128,20,0,0,4,0],[128,13,128,20,0,0,4,1],[136,9,136,36,0,0,4,0],[136,9,136,36,0,0,4,1],[137,9,137,36,0,0,4,0],[137,9,137,36,0,0,4,1],[138,9,138,33,0,0,4,0],[138,9,138,33,0,0,4,1],[139,17,139,59,0,0,4,0],[139,17,139,59,0,0,4,1],[140,17,140,44,0,0,4,0],[140,17,140,44,0,0,4,1],[140,48,140,72,0,0,4,0],[140,48,140,72,0,0,4,1],[157,9,157,31,0,0,4,0],[157,9,157,31,0,0,4,1],[165,9,165,29,0,0,4,0],[165,9,165,29,0,0,4,1],[166,17,166,34,0,0,4,0],[166,17,166,34,0,0,4,1],[174,9,174,35,0,0,4,0],[174,9,174,35,0,0,4,1],[178,17,178,38,0,0,4,0],[178,17,178,38,0,0,4,1],[185,17,185,43,0,0,4,0],[185,17,185,43,0,0,4,1],[195,9,195,30,0,0,4,0],[195,9,195,30,0,0,4,1],[196,17,196,57,0,0,4,0],[204,9,204,32,0,0,4,0],[204,9,204,32,0,0,4,1],[205,17,205,57,0,0,4,0],[206,17,206,59,0,0,4,0],[231,9,231,32,0,0,4,0],[231,9,231,32,0,0,4,1],[232,17,232,44,0,0,4,0],[232,17,232,44,0,0,4,1],[232,48,232,66,0,0,4,1],[233,18,233,43,0,0,4,0],[233,18,233,43,0,0,4,1],[233,47,233,73,0,0,4,0],[244,9,244,16,0,0,4,0],[244,9,244,16,0,0,4,1]],\"initCIELabConversion\":[[2618,9,2618,30,0,0,4,1],[2624,9,2624,21,0,0,4,0],[2628,13,2628,25,0,0,4,1],[2640,9,2640,70,0,0,4,1],[2648,9,2648,32,0,0,4,0]],\"gtStripSeparate\":[[1182,33,1182,38,0,0,4,0],[1182,33,1182,38,0,0,4,1],[1183,9,1183,21,0,0,4,1],[1189,9,1189,31,0,0,4,0],[1189,9,1189,31,0,0,4,1],[1191,13,1191,24,0,0,4,1],[1207,9,1207,36,0,0,4,0],[1207,9,1207,36,0,0,4,1],[1208,9,1208,36,0,0,4,0],[1208,9,1208,36,0,0,4,1],[1209,9,1209,33,0,0,4,1],[1213,9,1213,16,0,0,4,0],[1213,9,1213,16,0,0,4,1],[1220,17,1220,31,0,0,4,1],[1221,19,1221,26,0,0,4,0],[1221,19,1221,26,0,0,4,1],[1225,17,1225,37,0,0,4,0],[1225,17,1225,37,0,0,4,1],[1228,13,1228,25,0,0,4,0],[1228,29,1228,74,0,0,4,1],[1234,13,1234,24,0,0,4,0],[1234,13,1234,24,0,0,4,1],[1236,17,1238,64,0,0,4,0],[1236,17,1238,64,0,0,4,1],[1239,18,1239,29,0,0,4,0],[1239,18,1239,29,0,0,4,1],[1239,33,1239,47,0,0,4,0],[1245,17,1245,35,0,0,4,0],[1245,17,1245,35,0,0,4,1],[1248,23,1248,28,0,0,4,0],[1248,23,1248,28,0,0,4,1],[1254,23,1254,28,0,0,4,0],[1257,18,1258,77,0,0,4,0],[1257,18,1258,77,0,0,4,1],[1259,18,1259,32,0,0,4,0],[1264,13,1264,30,0,0,4,0],[1264,13,1264,30,0,0,4,1],[1265,13,1266,68,0,0,4,1],[1272,13,1272,30,0,0,4,0],[1272,13,1272,30,0,0,4,1],[1273,13,1274,68,0,0,4,1],[1280,13,1280,18,0,0,4,0],[1280,13,1280,18,0,0,4,1],[1282,17,1284,55,0,0,4,0],[1282,17,1284,55,0,0,4,1],[1285,17,1285,31,0,0,4,0],[1296,37,1296,42,0,0,4,0],[1296,37,1296,42,0,0,4,1],[1297,15,1297,39,0,0,4,0],[1297,15,1297,39,0,0,4,1],[1300,9,1300,33,0,0,4,0],[1300,9,1300,33,0,0,4,1],[1304,24,1304,32,0,0,4,0],[1304,24,1304,32,0,0,4,1],[1309,20,1309,32,0,0,4,0],[1309,20,1309,32,0,0,4,1]],\"putRGBAAcontig8bittile\":[[1682,12,1682,17,0,0,4,0],[1682,12,1682,17,0,0,4,1],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1344,13,1344,14,3,0,4,1],[1346,9,1346,15,3,0,4,1],[1348,9,1348,15,3,0,4,1],[1350,9,1350,15,3,0,4,1],[1352,9,1352,15,3,0,4,1],[1354,9,1354,15,3,0,4,0],[1356,9,1356,15,3,0,4,1],[1358,9,1358,15,3,0,4,1]],\"TIFFComputeStrip\":[[42,9,42,53,0,0,4,0],[42,9,42,53,0,0,4,1],[44,13,44,45,0,0,4,1]],\"_TIFFVGetField\":[[1227,9,1227,39,0,0,4,0],[1243,9,1243,35,0,0,4,0],[1246,9,1246,33,0,0,4,0],[1249,9,1249,33,0,0,4,0],[1258,9,1258,33,0,0,4,0],[1261,9,1261,37,0,0,4,0],[1264,9,1264,34,0,0,4,0],[1307,9,1307,34,0,0,4,0],[1327,9,1327,30,0,0,4,0],[1351,9,1351,34,0,0,4,0],[1355,9,1355,31,0,0,4,0],[1358,9,1358,32,0,0,4,0],[1411,9,1411,41,0,0,4,0],[1420,9,1420,16,0,0,4,0],[1433,17,1433,47,0,0,4,1],[1448,25,1448,52,0,0,4,0],[1448,25,1448,52,0,0,4,1],[1452,21,1452,47,0,0,4,0],[1452,21,1452,47,0,0,4,1],[1455,21,1455,41,0,0,4,1],[1464,26,1464,60,0,0,4,1],[1477,25,1477,54,0,0,4,1],[1478,25,1478,62,0,0,4,1],[1479,25,1479,63,0,0,4,1],[1480,25,1480,57,0,0,4,1],[1480,61,1480,74,0,0,4,0],[1480,61,1480,74,0,0,4,1],[1491,29,1491,43,0,0,4,1],[1492,29,1492,48,0,0,4,1],[1496,29,1496,44,0,0,4,1],[1500,29,1500,44,0,0,4,0],[1504,29,1504,45,0,0,4,1],[1508,29,1508,43,0,0,4,1],[1509,29,1509,42,0,0,4,1],[1513,29,1513,44,0,0,4,1],[1517,29,1517,44,0,0,4,1],[1518,29,1518,43,0,0,4,1],[1522,29,1522,45,0,0,4,1],[1526,29,1526,47,0,0,4,1],[1527,29,1527,48,0,0,4,1],[1557,29,1557,44,0,0,4,1],[1561,29,1561,45,0,0,4,1],[1565,29,1565,36,0,0,4,1]],\"gtTileSeparate\":[[873,33,873,38,0,0,4,0],[873,33,873,38,0,0,4,1],[874,9,874,21,0,0,4,1],[883,9,883,31,0,0,4,1],[896,13,896,31,0,0,4,1],[908,9,908,36,0,0,4,1],[909,9,909,36,0,0,4,0],[909,9,909,36,0,0,4,1],[910,9,910,33,0,0,4,1],[914,9,914,16,0,0,4,0],[914,9,914,16,0,0,4,1],[925,19,925,27,0,0,4,0],[925,19,925,27,0,0,4,1],[925,31,925,38,0,0,4,0],[928,17,928,37,0,0,4,0],[928,17,928,37,0,0,4,1],[934,16,934,25,0,0,4,0],[936,17,936,28,0,0,4,0],[938,21,940,69,0,0,4,0],[938,21,940,69,0,0,4,1],[941,22,941,33,0,0,4,0],[941,22,941,33,0,0,4,1],[941,37,941,51,0,0,4,0],[947,21,947,39,0,0,4,0],[950,27,950,32,0,0,4,0],[966,17,966,34,0,0,4,1],[974,17,974,34,0,0,4,1],[982,17,982,22,0,0,4,0],[983,17,984,62,0,0,4,0],[985,17,985,31,0,0,4,0],[1017,15,1017,39,0,0,4,1],[1020,9,1020,33,0,0,4,1]],\"OJPEGWriteHeaderInfo\":[[1359,13,1359,45,0,0,4,1]],\"gtTileContig\":[[730,9,730,21,0,0,4,1],[740,9,740,31,0,0,4,1],[753,13,753,31,0,0,4,0],[753,13,753,31,0,0,4,1],[769,19,769,27,0,0,4,0],[769,19,769,27,0,0,4,1],[769,31,769,38,0,0,4,0],[769,31,769,38,0,0,4,1],[772,17,772,37,0,0,4,0],[772,17,772,37,0,0,4,1],[778,16,778,25,0,0,4,0],[778,16,778,25,0,0,4,1],[780,17,782,65,0,0,4,0],[780,17,782,65,0,0,4,1],[783,18,783,29,0,0,4,0],[783,18,783,29,0,0,4,1],[783,33,783,47,0,0,4,0],[790,17,790,36,0,0,4,0],[790,17,790,36,0,0,4,1],[813,15,813,39,0,0,4,1],[817,9,817,33,0,0,4,1]],\"TIFFScanlineSize64\":[[253,46,253,65,0,0,4,1]],\"BuildMapBitdepth16To8\":[[3175,9,3175,35,0,0,4,1],[3181,17,3181,26,0,0,4,0],[3181,17,3181,26,0,0,4,1]],\"makebwmap\":[[2670,9,2670,22,0,0,4,0],[2670,9,2670,22,0,0,4,1],[2676,9,2676,27,0,0,4,1],[2683,17,2683,24,0,0,4,0],[2683,17,2683,24,0,0,4,1],[2687,17,2687,30,0,0,4,1],[2692,13,2692,19,0,0,4,0],[2692,13,2692,19,0,0,4,1],[2702,13,2702,19,0,0,4,0],[2702,13,2702,19,0,0,4,1],[2708,13,2708,19,0,0,4,0],[2708,13,2708,19,0,0,4,1],[2712,13,2712,19,0,0,4,0],[2712,13,2712,19,0,0,4,1],[2713,13,2713,20,0,0,4,0],[2713,13,2713,20,0,0,4,1]],\"TIFFRGBAImageBegin\":[[321,9,321,36,0,0,4,1],[344,9,344,15,0,0,4,0],[344,9,344,15,0,0,4,1],[345,9,345,15,0,0,4,0],[345,9,345,15,0,0,4,1],[346,9,346,15,0,0,4,0],[346,9,346,15,0,0,4,1],[347,9,347,15,0,0,4,0],[347,9,347,15,0,0,4,1],[348,9,348,16,0,0,4,0],[348,9,348,16,0,0,4,1],[350,9,350,16,0,0,4,1],[361,9,361,26,0,0,4,0],[361,9,361,26,0,0,4,1],[363,17,363,30,0,0,4,1],[365,13,365,41,0,0,4,0],[365,13,365,41,0,0,4,1],[367,21,368,22,0,0,4,0],[367,21,368,22,0,0,4,1],[371,13,371,40,0,0,4,0],[371,13,371,40,0,0,4,1],[372,13,372,40,0,0,4,0],[372,13,372,40,0,0,4,1],[379,9,379,67,0,0,4,0],[379,9,379,67,0,0,4,1],[382,9,382,26,0,0,4,0],[382,9,382,26,0,0,4,1],[382,30,382,55,0,0,4,0],[382,30,382,55,0,0,4,1],[383,9,383,44,0,0,4,1],[393,9,393,67,0,0,4,0],[393,9,393,67,0,0,4,1],[397,13,397,19,0,0,4,0],[398,21,398,44,0,0,4,0],[398,21,398,44,0,0,4,1],[403,13,403,19,0,0,4,1],[406,13,406,20,0,0,4,1],[414,9,414,33,0,0,4,0],[414,9,414,33,0,0,4,1],[415,17,416,42,0,0,4,1],[431,17,431,30,0,0,4,1],[431,34,431,49,0,0,4,1],[431,53,431,67,0,0,4,1],[443,9,443,36,0,0,4,0],[443,9,443,36,0,0,4,1],[444,9,444,36,0,0,4,0],[444,9,444,36,0,0,4,1],[445,17,445,52,0,0,4,0],[445,17,445,52,0,0,4,1],[446,17,446,42,0,0,4,0],[446,17,446,42,0,0,4,1],[446,46,446,68,0,0,4,1],[458,9,458,31,0,0,4,0],[458,9,458,31,0,0,4,1],[460,17,460,52,0,0,4,0],[460,17,460,52,0,0,4,1],[465,21,465,42,0,0,4,0],[465,21,465,42,0,0,4,1],[476,21,476,28,0,0,4,0],[476,21,476,28,0,0,4,1],[487,9,487,29,0,0,4,0],[487,9,487,29,0,0,4,1],[488,17,488,34,0,0,4,1],[496,9,496,35,0,0,4,0],[496,9,496,35,0,0,4,1],[500,17,500,38,0,0,4,1],[508,17,508,41,0,0,4,1],[518,9,518,30,0,0,4,1],[530,9,530,32,0,0,4,1],[551,9,551,32,0,0,4,0],[551,9,551,32,0,0,4,1],[553,9,553,16,0,0,4,1],[563,11,563,48,0,0,4,0],[563,11,563,48,0,0,4,1],[563,52,563,76,0,0,4,0],[563,52,563,76,0,0,4,1],[564,9,564,22,0,0,4,0],[564,9,564,22,0,0,4,1],[566,13,566,33,0,0,4,0],[566,13,566,33,0,0,4,1],[574,13,574,35,0,0,4,0],[574,13,574,35,0,0,4,1]],\"TIFFCheckTile\":[[75,9,75,31,0,0,4,1],[81,9,81,32,0,0,4,1],[88,9,88,31,0,0,4,1],[94,9,94,53,0,0,4,0],[94,9,94,53,0,0,4,1],[95,9,95,36,0,0,4,1]],\"TIFFRGBAImageGet\":[[590,9,590,25,0,0,4,1],[596,9,596,29,0,0,4,1]],\"LogL16toY\":[[791,9,791,12,0,0,4,1],[794,13,794,28,0,0,4,0]],\"putRGBseparate8bittile\":[[1860,12,1860,17,0,0,4,0],[1860,12,1860,17,0,0,4,1],[1376,22,1376,29,1,0,4,0],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1344,13,1344,14,4,0,4,1],[1346,9,1346,15,4,0,4,0],[1348,9,1348,15,4,0,4,1],[1350,9,1350,15,4,0,4,1],[1352,9,1352,15,4,0,4,1],[1354,9,1354,15,4,0,4,1],[1356,9,1356,15,4,0,4,1],[1358,9,1358,15,4,0,4,1]],\"put4bitbwtile\":[[1643,12,1643,17,0,0,4,0],[1643,12,1643,17,0,0,4,1],[1404,22,1404,29,1,0,4,0],[1404,22,1404,29,1,0,4,1],[1409,13,1409,15,1,0,4,0],[1409,13,1409,15,1,0,4,1]],\"cvtcmap\":[[2792,46,2792,52,0,0,4,0],[2792,46,2792,52,0,0,4,1]],\"setorientation\":[[648,9,648,33,0,0,4,0],[648,9,648,33,0,0,4,1],[649,9,649,33,0,0,4,0],[649,9,649,33,0,0,4,1],[650,17,650,61,0,0,4,1],[651,17,651,61,0,0,4,1],[653,22,653,66,0,0,4,1],[654,22,654,66,0,0,4,1],[656,22,656,65,0,0,4,0],[656,22,656,65,0,0,4,1],[657,22,657,65,0,0,4,1],[661,9,661,34,0,0,4,0],[661,9,661,34,0,0,4,1],[662,9,662,34,0,0,4,1],[663,17,663,60,0,0,4,1],[664,17,664,60,0,0,4,1],[666,22,666,66,0,0,4,1],[667,22,667,66,0,0,4,1],[669,22,669,65,0,0,4,0],[669,22,669,65,0,0,4,1],[670,22,670,65,0,0,4,1],[674,9,674,34,0,0,4,0],[674,9,674,34,0,0,4,1],[675,9,675,34,0,0,4,1],[676,17,676,60,0,0,4,1],[677,17,677,60,0,0,4,1],[679,22,679,66,0,0,4,1],[680,22,680,66,0,0,4,1],[682,22,682,65,0,0,4,0],[682,22,682,65,0,0,4,1],[683,22,683,65,0,0,4,1],[687,9,687,33,0,0,4,0],[687,9,687,33,0,0,4,1],[688,9,688,33,0,0,4,0],[688,9,688,33,0,0,4,1],[689,17,689,60,0,0,4,1],[690,17,690,60,0,0,4,1],[692,22,692,66,0,0,4,1],[693,22,693,66,0,0,4,1],[695,22,695,66,0,0,4,1],[696,22,696,66,0,0,4,1],[700,9,700,16,0,0,4,1]],\"PickSeparateCase\":[[3076,16,3076,37,0,0,4,0],[3076,16,3076,37,0,0,4,1],[3078,13,3078,29,0,0,4,0],[3078,13,3078,29,0,0,4,1],[3080,9,3080,36,0,0,4,0],[3080,9,3080,36,0,0,4,1],[3081,9,3081,36,0,0,4,0],[3081,9,3081,36,0,0,4,1],[3084,9,3084,29,0,0,4,1],[3085,21,3085,39,0,0,4,0],[3085,21,3085,39,0,0,4,1],[3087,17,3087,23,0,0,4,0],[3087,17,3087,23,0,0,4,1],[3088,25,3088,61,0,0,4,0],[3088,25,3088,61,0,0,4,1],[3090,30,3090,66,0,0,4,0],[3090,30,3090,66,0,0,4,1],[3092,29,3092,48,0,0,4,0],[3098,17,3098,24,0,0,4,0],[3098,17,3098,24,0,0,4,1],[3099,25,3099,61,0,0,4,0],[3099,25,3099,61,0,0,4,1],[3101,29,3101,55,0,0,4,0],[3104,30,3104,66,0,0,4,0],[3104,30,3104,66,0,0,4,1],[3106,29,3106,55,0,0,4,0],[3106,59,3106,78,0,0,4,0],[3111,29,3111,55,0,0,4,0],[3117,9,3117,35,0,0,4,0],[3117,9,3117,35,0,0,4,1],[3118,17,3118,40,0,0,4,0],[3118,17,3118,40,0,0,4,1],[3118,44,3118,69,0,0,4,0],[3125,9,3125,31,0,0,4,0],[3125,9,3125,31,0,0,4,1],[3126,17,3126,42,0,0,4,0],[3126,17,3126,42,0,0,4,1],[3126,46,3126,73,0,0,4,0],[3128,21,3128,50,0,0,4,0],[3133,29,3133,43,0,0,4,0],[3133,29,3133,43,0,0,4,1],[3135,25,3135,34,0,0,4,0],[3135,25,3135,34,0,0,4,1],[3144,13,3144,31,0,0,4,0],[3144,35,3144,62,0,0,4,0],[3144,35,3144,62,0,0,4,1]],\"TIFFYCbCrtoRGB\":[[197,26,197,37,1,0,4,1],[196,6,196,23,2,0,4,1],[196,34,196,45,2,0,4,1],[196,6,196,23,3,0,4,1],[196,34,196,45,3,0,4,1],[196,6,196,23,4,0,4,0],[196,6,196,23,4,0,4,1],[196,34,196,45,4,0,4,0],[196,34,196,45,4,0,4,1],[196,6,196,23,6,0,4,0],[196,6,196,23,6,0,4,1],[196,34,196,45,6,0,4,0],[196,34,196,45,6,0,4,1],[196,6,196,23,7,0,4,0],[196,6,196,23,7,0,4,1],[196,34,196,45,7,0,4,0],[196,34,196,45,7,0,4,1]],\"TIFFReadRGBAStripExt\":[[3208,9,3208,25,0,0,4,0],[3208,9,3208,25,0,0,4,1],[3216,9,3216,34,0,0,4,1],[3224,9,3224,35,0,0,4,0],[3225,9,3225,59,0,0,4,0],[3231,13,3231,44,0,0,4,0],[3231,13,3231,44,0,0,4,1]],\"TIFFReadEncodedTile\":[[961,9,961,31,0,0,4,0]],\"TIFFReadTile\":[[919,9,919,31,0,0,4,1],[919,35,919,66,0,0,4,1]],\"_TIFFReadEncodedTileAndAllocBuffer\":[[1007,9,1007,21,0,0,4,0],[1007,9,1007,21,0,0,4,1],[1012,9,1012,31,0,0,4,1],[1014,9,1014,31,0,0,4,1],[1022,9,1022,33,0,0,4,0],[1022,9,1022,33,0,0,4,1],[1027,9,1027,47,0,0,4,0],[1027,9,1027,47,0,0,4,1],[1029,13,1029,45,0,0,4,0],[1029,13,1029,45,0,0,4,1],[1046,13,1046,51,0,0,4,1],[1047,15,1047,52,0,0,4,1],[1053,19,1053,57,0,0,4,1],[1054,13,1054,47,0,0,4,0],[1054,13,1054,47,0,0,4,1],[1055,13,1055,66,0,0,4,0],[1068,9,1068,21,0,0,4,1],[1075,9,1075,39,0,0,4,0],[1079,9,1080,73,0,0,4,0],[1079,9,1080,73,0,0,4,1]],\"putRGBcontig8bittile\":[[1662,12,1662,17,0,0,4,0],[1662,12,1662,17,0,0,4,1],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1344,13,1344,14,3,0,4,1],[1346,9,1346,15,3,0,4,1],[1348,9,1348,15,3,0,4,1],[1350,9,1350,15,3,0,4,1],[1352,9,1352,15,3,0,4,1],[1354,9,1354,15,3,0,4,0],[1356,9,1356,15,3,0,4,1],[1358,9,1358,15,3,0,4,1]],\"_TIFFReadEncodedStripAndAllocBuffer\":[[568,9,568,21,0,0,4,0],[568,9,568,21,0,0,4,1],[574,9,574,43,0,0,4,1],[577,9,577,41,0,0,4,0],[577,45,577,76,0,0,4,0],[577,45,577,76,0,0,4,1],[579,9,579,35,0,0,4,0],[579,9,579,35,0,0,4,1],[583,9,583,21,0,0,4,1],[590,9,590,71,0,0,4,0],[590,9,590,71,0,0,4,1]],\"makecmap\":[[2822,9,2822,28,0,0,4,1],[2829,17,2829,24,0,0,4,0],[2829,17,2829,24,0,0,4,1],[2836,17,2836,30,0,0,4,1],[2838,13,2838,19,0,0,4,1],[2848,13,2848,19,0,0,4,0],[2854,13,2854,19,0,0,4,1],[2858,13,2858,19,0,0,4,1]],\"putRGBUAseparate8bittile\":[[1914,12,1914,17,0,0,4,0],[1914,12,1914,17,0,0,4,1],[1918,21,1918,26,0,0,4,0],[1918,21,1918,26,0,0,4,1]],\"Fax4Decode\":[[495,33,495,47,3,0,4,0],[328,13,328,24,65,0,4,1],[170,21,170,35,85,0,4,0],[170,21,170,35,85,0,4,1],[117,21,117,31,145,0,4,0]],\"buildMap\":[[2873,13,2873,29,0,0,4,0],[2873,13,2873,29,0,0,4,1],[2875,9,2875,29,0,0,4,1],[2876,9,2876,31,0,0,4,1],[2877,9,2877,35,0,0,4,0],[2877,9,2877,35,0,0,4,1],[2878,17,2878,40,0,0,4,0],[2878,17,2878,40,0,0,4,1],[2881,9,2881,36,0,0,4,0],[2881,9,2881,36,0,0,4,1],[2882,9,2882,36,0,0,4,0],[2882,9,2882,36,0,0,4,1],[2883,17,2883,31,0,0,4,1],[2886,9,2886,33,0,0,4,0],[2886,9,2886,33,0,0,4,1],[2891,17,2891,37,0,0,4,0],[2891,17,2891,37,0,0,4,1],[2900,17,2900,40,0,0,4,0],[2900,44,2900,58,0,0,4,1]],\"TIFFDefaultRefBlackWhite\":[[178,9,178,37,0,0,4,1],[180,9,180,48,0,0,4,0]],\"BuildMapUaToAa\":[[3154,9,3154,28,0,0,4,1],[3160,18,3160,26,0,0,4,0],[3160,18,3160,26,0,0,4,1],[3162,22,3162,30,0,0,4,0],[3162,22,3162,30,0,0,4,1]],\"setupMap\":[[2734,9,2734,33,0,0,4,0],[2734,9,2734,33,0,0,4,1],[2739,9,2739,25,0,0,4,1],[2745,9,2745,51,0,0,4,0],[2745,9,2745,51,0,0,4,1],[2747,21,2747,31,0,0,4,0],[2747,21,2747,31,0,0,4,1],[2752,21,2752,31,0,0,4,0],[2752,21,2752,31,0,0,4,1],[2755,9,2755,33,0,0,4,0],[2756,10,2756,52,0,0,4,0],[2756,10,2756,52,0,0,4,1],[2757,10,2757,52,0,0,4,0],[2757,10,2757,52,0,0,4,1],[2763,13,2763,28,0,0,4,1]],\"putRGBcontig8bitCMYKtile\":[[1806,12,1806,17,0,0,4,0],[1806,12,1806,17,0,0,4,1],[1376,22,1376,29,1,0,4,0],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1381,13,1381,19,1,0,4,1],[1344,13,1344,14,3,0,4,1],[1346,9,1346,15,3,0,4,1],[1348,9,1348,15,3,0,4,1],[1350,9,1350,15,3,0,4,1],[1352,9,1352,15,3,0,4,1],[1354,9,1354,15,3,0,4,0],[1354,9,1354,15,3,0,4,1],[1356,9,1356,15,3,0,4,0],[1356,9,1356,15,3,0,4,1],[1358,9,1358,15,3,0,4,0],[1358,9,1358,15,3,0,4,1]],\"TIFFVStripSize64\":[[84,54,84,73,0,0,4,1]],\"putcontig8bitYCbCr22tile\":[[2371,12,2371,18,0,0,4,0],[2371,12,2371,18,0,0,4,1],[2374,16,2374,22,0,0,4,0],[2374,16,2374,22,0,0,4,1],[2387,13,2387,19,0,0,4,0],[2387,13,2387,19,0,0,4,1],[2402,9,2402,15,0,0,4,0],[2402,9,2402,15,0,0,4,1],[2405,16,2405,22,0,0,4,0],[2405,16,2405,22,0,0,4,1],[2416,13,2416,19,0,0,4,0],[2416,13,2416,19,0,0,4,1]],\"JPEGResetUpsampled\":[[2551,13,2551,65,0,0,4,0],[2569,9,2569,30,0,0,4,0],[2571,9,2571,34,0,0,4,0],[250,22,250,62,7,0,4,0]],\"TIFFXYZToRGB\":[[306,24,306,33,1,0,4,0],[306,24,306,33,1,0,4,1],[306,24,306,33,2,0,4,0],[306,24,306,33,2,0,4,1],[306,24,306,33,3,0,4,0],[306,24,306,33,3,0,4,1],[307,24,307,33,4,0,4,0],[307,24,307,33,4,0,4,1],[307,24,307,33,5,0,4,0],[307,24,307,33,5,0,4,1],[307,24,307,33,6,0,4,0],[307,24,307,33,6,0,4,1],[307,24,307,33,7,0,4,1],[85,29,85,36,8,0,4,0],[85,29,85,36,8,0,4,1],[307,24,307,33,9,0,4,1],[85,29,85,36,10,0,4,0],[85,29,85,36,10,0,4,1],[307,24,307,33,11,0,4,1],[85,29,85,36,12,0,4,0],[85,29,85,36,12,0,4,1],[307,24,307,33,13,0,4,0],[307,24,307,33,13,0,4,1],[307,24,307,33,14,0,4,0],[307,24,307,33,14,0,4,1],[307,24,307,33,15,0,4,0],[307,24,307,33,15,0,4,1]],\"JPEGVSetField\":[[2600,9,2600,35,0,0,4,0]],\"OJPEGPreDecode\":[[760,13,761,48,0,0,4,0]],\"isInRefBlackWhiteRange\":[[2556,12,2556,42,0,0,4,0],[2556,12,2556,42,0,0,4,1],[2556,46,2556,67,0,0,4,0],[2556,46,2556,67,0,0,4,1]],\"PickContigCase\":[[2912,16,2912,37,0,0,4,0],[2912,16,2912,37,0,0,4,1],[2914,13,2914,29,0,0,4,1],[2916,9,2916,29,0,0,4,0],[2916,9,2916,29,0,0,4,1],[2917,21,2917,39,0,0,4,0],[2917,21,2917,39,0,0,4,1],[2919,17,2919,23,0,0,4,0],[2919,17,2919,23,0,0,4,1],[2920,25,2920,61,0,0,4,0],[2920,25,2920,61,0,0,4,1],[2921,25,2921,50,0,0,4,0],[2921,25,2921,50,0,0,4,1],[2923,30,2923,66,0,0,4,0],[2923,30,2923,66,0,0,4,1],[2924,30,2924,55,0,0,4,0],[2924,30,2924,55,0,0,4,1],[2926,29,2926,48,0,0,4,0],[2929,30,2929,55,0,0,4,0],[2929,30,2929,55,0,0,4,1],[2932,17,2932,24,0,0,4,0],[2932,17,2932,24,0,0,4,1],[2933,25,2933,61,0,0,4,0],[2933,25,2933,61,0,0,4,1],[2934,25,2934,50,0,0,4,1],[2939,30,2939,66,0,0,4,0],[2939,30,2939,66,0,0,4,1],[2940,30,2940,55,0,0,4,1],[2945,30,2945,55,0,0,4,0],[2947,29,2947,55,0,0,4,0],[2953,9,2953,35,0,0,4,0],[2953,9,2953,35,0,0,4,1],[2954,17,2954,42,0,0,4,0],[2954,46,2954,59,0,0,4,0],[2956,21,2956,44,0,0,4,0],[2956,21,2956,44,0,0,4,1],[2958,25,2958,34,0,0,4,0],[2965,9,2965,33,0,0,4,0],[2965,9,2965,33,0,0,4,1],[2966,17,2966,30,0,0,4,0],[2968,25,2968,43,0,0,4,1],[2970,21,2970,27,0,0,4,1],[2973,21,2973,27,0,0,4,1],[2976,21,2976,27,0,0,4,0],[2979,21,2979,27,0,0,4,1],[2985,9,2985,36,0,0,4,0],[2985,9,2985,36,0,0,4,1],[2986,9,2986,36,0,0,4,0],[2986,9,2986,36,0,0,4,1],[2987,17,2987,30,0,0,4,0],[2989,25,2989,43,0,0,4,1],[2991,21,2991,28,0,0,4,0],[2991,21,2991,28,0,0,4,1],[2994,21,2994,27,0,0,4,0],[2994,21,2994,27,0,0,4,1],[2995,29,2995,39,0,0,4,0],[2995,29,2995,39,0,0,4,1],[2995,43,2995,68,0,0,4,0],[2995,43,2995,68,0,0,4,1],[3000,21,3000,27,0,0,4,0],[3000,21,3000,27,0,0,4,1],[3003,21,3003,27,0,0,4,0],[3003,21,3003,27,0,0,4,1],[3006,21,3006,27,0,0,4,0],[3006,21,3006,27,0,0,4,1],[3012,9,3012,31,0,0,4,0],[3012,9,3012,31,0,0,4,1],[3013,17,3013,42,0,0,4,0],[3013,17,3013,42,0,0,4,1],[3013,46,3013,73,0,0,4,0],[3013,46,3013,73,0,0,4,1],[3015,21,3015,50,0,0,4,0],[3015,21,3015,50,0,0,4,1],[3030,29,3030,67,0,0,4,0],[3030,29,3030,67,0,0,4,1],[3032,25,3032,34,0,0,4,0],[3032,25,3032,34,0,0,4,1],[3035,25,3035,34,0,0,4,0],[3035,25,3035,34,0,0,4,1],[3038,25,3038,34,0,0,4,0],[3038,25,3038,34,0,0,4,1],[3041,25,3041,34,0,0,4,0],[3041,25,3041,34,0,0,4,1],[3044,25,3044,34,0,0,4,0],[3044,25,3044,34,0,0,4,1],[3047,25,3047,34,0,0,4,0],[3047,25,3047,34,0,0,4,1],[3050,25,3050,34,0,0,4,0],[3050,25,3050,34,0,0,4,1],[3057,9,3057,32,0,0,4,0],[3057,9,3057,32,0,0,4,1],[3058,17,3058,42,0,0,4,0],[3058,46,3058,59,0,0,4,0],[3060,21,3060,44,0,0,4,0],[3065,13,3065,31,0,0,4,0],[3065,35,3065,60,0,0,4,0],[3065,35,3065,60,0,0,4,1]],\"put16bitbwtile\":[[1578,12,1578,17,0,0,4,0],[1578,12,1578,17,0,0,4,1],[1582,21,1582,26,0,0,4,0],[1582,21,1582,26,0,0,4,1]],\"TIFFRGBAImageEnd\":[[255,9,255,17,0,0,4,0],[255,9,255,17,0,0,4,1],[260,9,260,19,0,0,4,0],[260,9,260,19,0,0,4,1],[265,9,265,20,0,0,4,0],[265,9,265,20,0,0,4,1],[270,9,270,19,0,0,4,0],[270,9,270,19,0,0,4,1],[275,9,275,20,0,0,4,0],[275,9,275,20,0,0,4,1],[280,9,280,20,0,0,4,0],[280,9,280,20,0,0,4,1],[285,9,285,27,0,0,4,0],[285,9,285,27,0,0,4,1],[291,9,291,21,0,0,4,0],[291,9,291,21,0,0,4,1]],\"put2bitcmaptile\":[[1499,12,1499,17,0,0,4,0],[1499,12,1499,17,0,0,4,1],[1390,22,1390,29,1,0,4,0],[1390,22,1390,29,1,0,4,1],[1395,13,1395,19,1,0,4,0],[1395,13,1395,19,1,0,4,1],[1362,13,1362,14,3,0,4,1],[1364,9,1364,15,3,0,4,0],[1364,9,1364,15,3,0,4,1],[1366,9,1366,15,3,0,4,0],[1366,9,1366,15,3,0,4,1],[1368,9,1368,15,3,0,4,0],[1368,9,1368,15,3,0,4,1]],\"TIFFVTileSize64\":[[197,42,197,61,0,0,4,1]],\"TIFFVGetFieldDefaulted\":[[225,9,225,35,0,0,4,0],[234,9,234,33,0,0,4,0],[237,9,237,37,0,0,4,0],[240,9,240,34,0,0,4,0],[297,9,297,28,0,0,4,0],[303,9,303,34,0,0,4,0],[324,9,324,39,0,0,4,0],[331,9,331,38,0,0,4,1],[338,9,338,32,0,0,4,0],[364,9,364,41,0,0,4,0],[365,17,365,38,0,0,4,0],[365,17,365,38,0,0,4,1],[365,42,365,76,0,0,4,1]],\"initYCbCrConversion\":[[2565,9,2565,27,0,0,4,0],[2571,13,2571,31,0,0,4,1],[2585,9,2585,27,0,0,4,1],[2585,31,2585,49,0,0,4,1],[2585,53,2585,67,0,0,4,1],[2586,9,2586,27,0,0,4,1],[2593,9,2593,50,0,0,4,0],[2593,9,2593,50,0,0,4,1],[2594,9,2594,50,0,0,4,0],[2594,9,2594,50,0,0,4,1],[2595,9,2595,50,0,0,4,0],[2595,9,2595,50,0,0,4,1],[2596,9,2596,50,0,0,4,0],[2596,9,2596,50,0,0,4,1],[2597,9,2597,50,0,0,4,0],[2597,9,2597,50,0,0,4,1],[2598,9,2598,50,0,0,4,1],[2605,9,2605,64,0,0,4,1]],\"TIFFCIELab16ToXYZ\":[[61,9,61,19,0,0,4,0],[61,9,61,19,0,0,4,1],[73,9,73,22,0,0,4,0],[73,9,73,22,0,0,4,1],[79,9,79,22,0,0,4,0],[79,9,79,22,0,0,4,1]],\"checkcmap\":[[2779,12,2779,19,0,0,4,0],[2779,12,2779,19,0,0,4,1],[2780,13,2780,24,0,0,4,0],[2780,13,2780,24,0,0,4,1],[2780,28,2780,39,0,0,4,0],[2780,28,2780,39,0,0,4,1],[2780,43,2780,54,0,0,4,0],[2780,43,2780,54,0,0,4,1]],\"gtStripContig\":[[1068,9,1068,28,0,0,4,0],[1068,9,1068,28,0,0,4,1],[1078,9,1078,31,0,0,4,0],[1078,9,1078,31,0,0,4,1],[1080,13,1080,24,0,0,4,1],[1097,17,1097,31,0,0,4,1],[1098,19,1098,26,0,0,4,0],[1098,19,1098,26,0,0,4,1],[1102,17,1102,37,0,0,4,0],[1102,17,1102,37,0,0,4,1],[1104,13,1104,44,0,0,4,0],[1104,13,1104,44,0,0,4,1],[1107,13,1107,25,0,0,4,0],[1107,29,1107,74,0,0,4,1],[1113,13,1116,51,0,0,4,0],[1113,13,1116,51,0,0,4,1],[1117,14,1117,25,0,0,4,0],[1117,14,1117,25,0,0,4,1],[1117,29,1117,43,0,0,4,0],[1128,15,1128,39,0,0,4,0],[1128,15,1128,39,0,0,4,1],[1131,9,1131,33,0,0,4,0],[1131,9,1131,33,0,0,4,1],[1135,24,1135,32,0,0,4,0],[1135,24,1135,32,0,0,4,1],[1140,20,1140,32,0,0,4,0],[1140,20,1140,32,0,0,4,1]],\"TIFFCIELabToRGBInit\":[[149,17,149,35,0,0,4,0],[149,17,149,35,0,0,4,1],[159,17,159,35,0,0,4,0],[159,17,159,35,0,0,4,1],[169,17,169,35,0,0,4,0],[169,17,169,35,0,0,4,1]],\"isCCITTCompression\":[[304,13,304,46,0,0,4,0],[304,13,304,46,0,0,4,1],[305,13,305,46,0,0,4,0],[305,13,305,46,0,0,4,1],[306,13,306,45,0,0,4,0],[306,13,306,45,0,0,4,1],[307,13,307,46,0,0,4,0],[307,13,307,46,0,0,4,1]],\"uv_encode\":[[971,9,971,29,0,0,4,1]],\"put1bitbwtile\":[[1605,12,1605,17,0,0,4,0],[1605,12,1605,17,0,0,4,1],[1376,22,1376,29,1,0,4,0],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,0],[1381,13,1381,19,1,0,4,1],[1344,13,1344,14,3,0,4,1],[1346,9,1346,15,3,0,4,0],[1346,9,1346,15,3,0,4,1],[1348,9,1348,15,3,0,4,0],[1348,9,1348,15,3,0,4,1],[1350,9,1350,15,3,0,4,0],[1350,9,1350,15,3,0,4,1],[1352,9,1352,15,3,0,4,0],[1352,9,1352,15,3,0,4,1],[1354,9,1354,15,3,0,4,0],[1354,9,1354,15,3,0,4,1],[1356,9,1356,15,3,0,4,0],[1356,9,1356,15,3,0,4,1],[1358,9,1358,15,3,0,4,0],[1358,9,1358,15,3,0,4,1]],\"putRGBAAseparate8bittile\":[[1876,12,1876,17,0,0,4,0],[1876,12,1876,17,0,0,4,1],[1376,22,1376,29,1,0,4,0],[1376,22,1376,29,1,0,4,1],[1381,13,1381,19,1,0,4,1]],\"putagreytile\":[[1557,12,1557,17,0,0,4,0],[1557,12,1557,17,0,0,4,1],[1559,21,1559,26,0,0,4,0],[1559,21,1559,26,0,0,4,1]],\"putCMYKseparate8bittile\":[[1891,12,1891,17,0,0,4,0],[1891,12,1891,17,0,0,4,1],[1894,21,1894,26,0,0,4,0],[1894,21,1894,26,0,0,4,1]],\"putRGBseparate16bittile\":[[1943,12,1943,17,0,0,4,0],[1943,12,1943,17,0,0,4,1],[1945,21,1945,26,0,0,4,0],[1945,21,1945,26,0,0,4,1]],\"putcontig8bitCIELab8\":[[2012,12,2012,17,0,0,4,0],[2012,12,2012,17,0,0,4,1],[2014,21,2014,26,0,0,4,0],[2014,21,2014,26,0,0,4,1]],\"putgreytile\":[[1536,12,1536,17,0,0,4,0],[1536,12,1536,17,0,0,4,1],[1538,21,1538,26,0,0,4,0],[1538,21,1538,26,0,0,4,1]],\"put2bitbwtile\":[[1624,12,1624,17,0,0,4,0],[1624,12,1624,17,0,0,4,1],[1390,22,1390,29,1,0,4,0],[1390,22,1390,29,1,0,4,1],[1395,13,1395,19,1,0,4,0],[1395,13,1395,19,1,0,4,1],[1362,13,1362,14,3,0,4,1],[1364,9,1364,15,3,0,4,0],[1364,9,1364,15,3,0,4,1],[1366,9,1366,15,3,0,4,0],[1366,9,1366,15,3,0,4,1],[1368,9,1368,15,3,0,4,0],[1368,9,1368,15,3,0,4,1]]},\"library_calls\":[\"TIFFStreamOpen\",\"TIFFGetField\",\"TIFFGetField\",\"_TIFFmalloc\",\"TIFFReadRGBAImageOriented\",\"_TIFFfree\",\"TIFFClose\",\"TIFFStripSize64\",\"TIFFIsByteSwapped\",\"TIFFSetTagExtender\",\"TIFFFlushData\",\"LogL16toY\",\"TIFFReadRGBAStripExt\",\"LogLuv24fromXYZ\",\"_TIFFfree\",\"TIFFClose\"],\"critical_calls\":[\"TIFFStreamOpen\",\"TIFFGetField\",\"TIFFGetField\",\"_TIFFmalloc\",\"TIFFReadRGBAImageOriented\",\"TIFFStripSize64\",\"TIFFIsByteSwapped\",\"TIFFSetTagExtender\",\"TIFFFlushData\",\"LogL16toY\",\"TIFFReadRGBAStripExt\",\"LogLuv24fromXYZ\",\"_TIFFfree\",\"TIFFClose\"],\"visited\":4}"
        }
      ],
      "repository": {
        "name": "github.com/PromptFuzz/PromptFuzz",
        "url": "/github.com/PromptFuzz/PromptFuzz"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "22c32e3cb711eeb92fd412b0df3cbeef1680be04"
        },
        "content": "#include \"StdAfx.h\"\n\n// #define STRICT\n#include \"diblib.h\"\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e // MAX_ constants\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage\n{\n    TIFFRGBAImage tif;\n    int dibinstalled;\n};\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster);\n\nstatic void MyWarningHandler(const char *module, const char *fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void MyErrorHandler(const char *module, const char *fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF(LPCTSTR lpszPath)\n{\n    int rtn = 0;\n\n    TIFFErrorHandler eh;\n    TIFFErrorHandler wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF *tif = TIFFOpen(lpszPath, \"r\");\n    if (tif)\n    {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage *img);\n\nPVOID ReadTIFF(LPCTSTR lpszPath)\n{\n    void *pDIB = 0;\n    TIFFErrorHandler wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath))\n    {\n        TIFF *tif = TIFFOpen(lpszPath, \"r\");\n        if (tif)\n        {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg))\n            {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg))\n                {\n                    size_t npixels;\n                    uint32_t *raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster =\n                        (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n                    if (raster != NULL)\n                    {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width,\n                                             img.tif.height))\n                        {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else\n            {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg);\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster)\n{\n    void *pDIB = 0;\n    TIFFRGBAImage *img = \u0026dib-\u003etif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER bi;\n    int dwDIBSize;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if (BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled)\n    { // bilevel\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 1;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(\u0026bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed = 0;\n        pRgbq[0].rgbBlue = 0;\n        pRgbq[0].rgbGreen = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed = 255;\n        pRgbq[1].rgbBlue = 255;\n        pRgbq[1].rgbGreen = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr(\n            (BITMAPINFOHEADER *)pDIB); //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n    //  For now just always default to the RGB 32 bit form. // save as 32 bit\n    //  for simplicity\n    else if (true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/)\n    { // 24 bit color\n\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 32;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(\u0026bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        // Swap the byte order while copying\n        for (int i = 0; i \u003c sizeWords; ++i)\n        {\n            rgbDib[i].rgbRed = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n#define DECLAREContigPutFunc(name)                                             \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *pp)\n\n#define DECLARESepPutFunc(name)                                                \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *r, u_char *g, u_char *b, u_char *a)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *uraster, uint32_t w,\n                              uint32_t h);\n\n// typdef struct TIFFDibImage {\n//     TIFFRGBAImage tif;\n//     dibinstalled;\n// } TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage *dib)\n{\n    TIFFRGBAImage *img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric)\n    {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n            switch (img-\u003ebitspersample)\n            {\n                case 1:\n                    img-\u003eput.contig = putContig1bitTile;\n                    img-\u003eget = getStripContig1Bit;\n                    dib-\u003edibinstalled = true;\n                    break;\n            }\n            break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void)y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char *ucp = (u_char *)cp;\n\n    /* Convert 'w' to bytes from pixels (rounded up) */\n    w = (w + 7) / 8;\n\n    while (h-- \u003e 0)\n    {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32_t setorientation(TIFFRGBAImage *img, uint32_t h)\n{\n    TIFF *tif = img-\u003etif;\n    uint32_t y;\n\n    switch (img-\u003eorientation)\n    {\n        case ORIENTATION_BOTRIGHT:\n        case ORIENTATION_RIGHTBOT: /* XXX */\n        case ORIENTATION_LEFTBOT:  /* XXX */\n            TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n            img-\u003eorientation = ORIENTATION_BOTLEFT;\n        /* fall through... */\n        case ORIENTATION_BOTLEFT:\n            y = 0;\n            break;\n        case ORIENTATION_TOPRIGHT:\n        case ORIENTATION_RIGHTTOP: /* XXX */\n        case ORIENTATION_LEFTTOP:  /* XXX */\n        default:\n            TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n            img-\u003eorientation = ORIENTATION_TOPLEFT;\n        /* fall through... */\n        case ORIENTATION_TOPLEFT:\n            y = h - 1;\n            break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *raster, uint32_t w,\n                              uint32_t h)\n{\n    TIFF *tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16_t orientation;\n    uint32_t row, y, nrow, rowstoread;\n    uint32_t pos;\n    u_char *buf;\n    uint32_t rowsperstrip;\n    uint32_t imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32_t fromskew, toskew;\n    tstrip_t strip;\n    tsize_t stripsize;\n    u_char *braster = (u_char *)raster; // byte wide raster\n    uint32_t wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char *)_TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32_t)(orientation == ORIENTATION_TOPLEFT ? wb + wb : wb - wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0) / 8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif, row + img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset) % rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize) \u003c 0 \u0026\u0026\n            img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32_t *)(braster + y * wb), 0, y, w, nrow, fromskew,\n               toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ? -(int32_t)nrow\n                                                 : (int32_t)nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n",
        "name": "Tiffile.cpp",
        "path": "thirdparty/libtiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/GrokImageCompression/grok/-/blob/thirdparty/libtiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 112,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width,"
        }
      ],
      "repository": {
        "name": "github.com/GrokImageCompression/grok",
        "url": "/github.com/GrokImageCompression/grok"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "98dfd34c245528db3d0f1b9944da32904538d295"
        },
        "content": "// Aqsis\n// Copyright (C) 2001, Paul C. Gregory and the other authors and contributors\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// * Redistributions of source code must retain the above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// * Neither the name of the software's owners nor the names of its\n//   contributors may be used to endorse or promote products derived from this\n//   software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n//\n// (This is the New BSD license)\n\n/** \\file\n *\n * \\brief Scanline-oriented pixel access for TIFF input - implementation.\n *\n * \\author Chris Foster  chris42f _at_ gmail.com\n *\n */\n\n#include \"tiffinputfile.h\"\n\n#include \"boost/scoped_array.hpp\"\n\n#include \"tiffdirhandle.h\"\n\nnamespace Aqsis {\n\n//------------------------------------------------------------------------------\n// CqTiffInputFile - implementation\n\nCqTiffInputFile::CqTiffInputFile(const boostfs::path\u0026 fileName)\n\t: m_header(),\n\tm_fileHandle(new CqTiffFileHandle(fileName, \"r\")),\n\tm_imageIndex(0)\n{\n\tsetDirectory(m_imageIndex);\n}\n\nCqTiffInputFile::CqTiffInputFile(std::istream\u0026 inStream)\n\t: m_header(),\n\tm_fileHandle(new CqTiffFileHandle(inStream)),\n\tm_imageIndex(0)\n{\n\tsetDirectory(m_imageIndex);\n}\n\nboostfs::path CqTiffInputFile::fileName() const\n{\n\treturn m_fileHandle-\u003efileName();\n}\n\nvoid CqTiffInputFile::setImageIndex(TqInt newIndex)\n{\n\tif(newIndex \u003c 0)\n\t\tAQSIS_THROW_XQERROR(XqInternal, EqE_Bug, \"Cannot set negative image index.\");\n\tsetDirectory(newIndex);\n}\n\n// Warning: don't use this function from another member which already has a\n// lock on the underlying file handle.\nTqInt CqTiffInputFile::numSubImages() const\n{\n\treturn m_fileHandle-\u003enumDirectories();\n}\n\nvoid CqTiffInputFile::readPixelsImpl(TqUint8* buffer,\n\t\tTqInt startLine, TqInt numScanlines) const\n{\n\tif(m_header.find\u003cAttr::TiffUseGenericRGBA\u003e())\n\t{\n\t\t// Use generic libtiff RGBA when we encounter unusual TIFF formats.\n\t\treadPixelsRGBA(buffer, startLine, numScanlines);\n\t}\n\telse\n\t{\n\t\t// The usual case - use aqsistex native pixel input\n\t\tif(m_header.findPtr\u003cAttr::TileInfo\u003e())\n\t\t\treadPixelsTiled(buffer, startLine, numScanlines);\n\t\telse\n\t\t\treadPixelsStripped(buffer, startLine, numScanlines);\n\t}\n}\n\nvoid CqTiffInputFile::readPixelsStripped(TqUint8* buffer, TqInt startLine,\n\t\tTqInt numScanlines) const\n{\n\tCqTiffDirHandle dirHandle(m_fileHandle, m_imageIndex);\n\tconst tsize_t bytesPerRow = TIFFScanlineSize(dirHandle.tiffPtr());\n\t// Implement simplest possible version for now - read in scanlines\n\t// sequentially...  Looking at the source code for libtiff, this should be\n\t// reasonably efficient.\n\t//\n\t// In the unlikely event that it turns out to be a problem, we should look\n\t// at using the strip-based interface via TIFFReadEncodedStrip \u0026 friends.\n\tfor(TqInt line = startLine; line \u003c startLine + numScanlines; ++line)\n\t{\n\t\tTIFFReadScanline(dirHandle.tiffPtr(), reinterpret_cast\u003ctdata_t\u003e(buffer),\n\t\t\t\tstatic_cast\u003cuint32\u003e(line));\n\t\tbuffer += bytesPerRow;\n\t}\n}\n\nvoid CqTiffInputFile::readPixelsTiled(TqUint8* buffer, TqInt startLine,\n\t\tTqInt numScanlines) const\n{\n\t// Load in relevant tiles; discard the excess.  At this stage, we don't do\n\t// any caching, under the assumption that the user will want to load a\n\t// bunch of scanlines at once.  If they load a single scanline at a time,\n\t// this will be very inefficient.\n\tCqTiffDirHandle dirHandle(m_fileHandle, m_imageIndex);\n\n\t// lines of interest will be startLine to endLine (exclusive)\n\tTqInt endLine = startLine + numScanlines;\n\n\tSqTileInfo tileInfo = m_header.find\u003cAttr::TileInfo\u003e();\n\t// Compute the boundaries of the smallest tiled region containing the\n\t// scanlines we're interested in.\n\tTqInt startTileLine = (startLine/tileInfo.height) * tileInfo.height;\n\t// endTileLine is the start line of the row of tiles coming *after* the\n\t// last row we want to load.\n\tTqInt endTileLine = ((endLine-1)/tileInfo.height + 1) * tileInfo.height;\n\n\tTqInt width = m_header.width();\n\tTqInt bytesPerPixel = m_header.channelList().bytesPerPixel();\n\tTqInt lineSize = bytesPerPixel*width;\n\tTqInt tileLineSize = bytesPerPixel*tileInfo.width;\n\tTqInt tileSize = tileLineSize*tileInfo.height;\n\n\t// Buffer to hold tiles read using libtiff.\n\tboost::shared_array\u003cTqUint8\u003e tempTileBuf(\n\t\t\tstatic_cast\u003cTqUint8*\u003e(_TIFFmalloc(tileSize)),\n\t\t\t_TIFFfree);\n\n\tfor(TqInt y = startTileLine; y \u003c endTileLine; y += tileInfo.height)\n\t{\n\t\t// Determine how much of the beginning and end of the current strip\n\t\t// should be skipped due to the tiles falling off the range of\n\t\t// relevant scanlines.\n\t\tTqInt outStripSkipStart =\n\t\t\t(y == startTileLine) ? startLine - startTileLine : 0;\n\t\tTqInt outStripSkipEnd =\n\t\t\t(y + tileInfo.height == endTileLine) ? endTileLine - endLine : 0;\n\t\t// The output \"Strip height\" for the current line of tiles might be\n\t\t// smaller than the tile height; take this into account here.\n\t\tTqInt stripHeightOut = tileInfo.height - outStripSkipStart - outStripSkipEnd;\n\n\t\tfor(TqInt x = 0; x \u003c width; x += tileInfo.width)\n\t\t{\n\t\t\t// Grab the tile using libtiff\n\t\t\tTIFFReadTile(dirHandle.tiffPtr(),\n\t\t\t\t\tstatic_cast\u003ctdata_t\u003e(tempTileBuf.get()), x, y, 0, 0);\n\t\t\t// The width of the tile in the output image is smaller when it\n\t\t\t// falls of the RHS of the image.\n\t\t\tTqInt tileLineSizeOut = min(tileLineSize, bytesPerPixel*(width-x));\n\t\t\t// Copy the tile into the output buffer.\n\t\t\tTqUint8* lineBuf = buffer + x*bytesPerPixel;\n\t\t\tTqUint8* tileLineBuf = static_cast\u003cTqUint8*\u003e(tempTileBuf.get())\n\t\t\t\t+ outStripSkipStart*tileLineSize;\n\t\t\tfor(TqInt tileLine = 0; tileLine \u003c stripHeightOut; ++tileLine)\n\t\t\t{\n\t\t\t\t_TIFFmemcpy(lineBuf, tileLineBuf, tileLineSizeOut);\n\t\t\t\ttileLineBuf += tileLineSize;\n\t\t\t\tlineBuf += lineSize;\n\t\t\t}\n\t\t}\n\t\tbuffer += lineSize*stripHeightOut;\n\t}\n}\n\nvoid CqTiffInputFile::readPixelsRGBA(TqUint8* buffer, TqInt startLine,\n\t\tTqInt numScanlines) const\n{\n\tCqTiffDirHandle dirHandle(m_fileHandle, m_imageIndex);\n\t// Support odd tiff formats using the generic RGBA tiff functionality.\n\t//\n\t// We read in the entire image each time readPixelsRGBA() is called; this\n\t// *will* cause a performance bottleneck if the user calls readPixels() on\n\t// only a small number of scanlines at a time.\n\tboost::scoped_array\u003cuint32\u003e inBuf(\n\t\t\tnew uint32[m_header.width()*m_header.height()]);\n\tTIFFReadRGBAImageOriented(dirHandle.tiffPtr(), m_header.width(),\n\t\t\tm_header.height(), inBuf.get(), ORIENTATION_TOPLEFT, 0);\n\n\t// Unfortunately, the RGBA format which libtiff uses puts the RGBA bytes in\n\t// the opposite order which we'd like, so we need to swap them.  It's\n\t// possible to get around this using TIFFRGBAImageGet() but it's extra work\n\t// which somewhat defeats the purpose of using the RGBA functionality as a\n\t// catchall fallback anyway.\n\tTqInt width = m_header.width();\n\tTqInt bytesPerPixel = m_header.channelList().bytesPerPixel();\n\tassert(bytesPerPixel == 4);\n\tconst uint32* inPtr = inBuf.get() + width*startLine;\n\tfor(TqInt line = 0; line \u003c numScanlines; ++line)\n\t{\n\t\tfor(TqInt col = 0; col \u003c width; ++col)\n\t\t{\n\t\t\tbuffer[col*bytesPerPixel] = TIFFGetR(inPtr[col]);\n\t\t\tbuffer[col*bytesPerPixel + 1] = TIFFGetG(inPtr[col]);\n\t\t\tbuffer[col*bytesPerPixel + 2] = TIFFGetB(inPtr[col]);\n\t\t\tbuffer[col*bytesPerPixel + 3] = TIFFGetA(inPtr[col]);\n\t\t}\n\t\tbuffer += width*bytesPerPixel;\n\t\tinPtr += width;\n\t}\n}\n\nvoid CqTiffInputFile::setDirectory(tdir_t newDir)\n{\n\tconst tdir_t numDirs = numSubImages();\n\tif(newDir \u003e= numDirs)\n\t{\n\t\tAQSIS_THROW_XQERROR(XqInternal, EqE_Bug, \"TIFF directory \"\n\t\t\t\u003c\u003c newDir \u003c\u003c \" out of range [0,\" \u003c\u003c numDirs-1 \u003c\u003c \"]\");\n\t}\n\tm_imageIndex = newDir;\n\n\tCqTiffDirHandle dirHandle(m_fileHandle, m_imageIndex);\n\tdirHandle.fillHeader(m_header);\n}\n\n} // namespace Aqsis\n",
        "name": "tiffinputfile.cpp",
        "path": "libs/tex/io/tiffinputfile.cpp",
        "url": "/github.com/aqsis/aqsis/-/blob/libs/tex/io/tiffinputfile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 204,
          "offsetAndLengths": [
            [
              38,
              16
            ]
          ],
          "preview": "\t// possible to get around this using TIFFRGBAImageGet() but it's extra work"
        }
      ],
      "repository": {
        "name": "github.com/aqsis/aqsis",
        "url": "/github.com/aqsis/aqsis"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "98dfd34c245528db3d0f1b9944da32904538d295"
        },
        "content": "/*\nRGBAImage.cpp\nCopyright (C) 2006 Yangli Hector Yee\n\nThis program is free software; you can redistribute it and/or modify it under the terms of the\nGNU General Public License as published by the Free Software Foundation; either version 2 of the License,\nor (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\nwithout even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\nSee the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program;\nif not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n#include \"RGBAImage.h\"\n#include \"tiff.h\"\n#include \"tiffio.h\"\n\n\n// Reads Tiff Images\nRGBAImage* RGBAImage::ReadTiff(char *filename)\n{\n\tRGBAImage *fimg = 0;\n\t\n    TIFF* tif = TIFFOpen(filename, \"r\");\n    char emsg[1024];\n    if (tif) {\n\t\tTIFFRGBAImage img;\n\t\t\n\t\tif (TIFFRGBAImageBegin(\u0026img, tif, 0, emsg)) {\n\t\t\tsize_t npixels;\n\t\t\tuint32* raster;\n\n\t\t\tnpixels = img.width * img.height;\n\t\t\traster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n\t\t\tif (raster != NULL) {\n\t\t\t\tif (TIFFRGBAImageGet(\u0026img, raster, img.width, img.height)) {\n\t\t\t\t\t// result is in ABGR\n\t\t\t\t\tfimg = new RGBAImage(img.width, img.height);\n\t\t\t\t\tfor (int y = 0; y \u003c img.height; y++) {\n\t\t\t\t\t\tfor (int x = 0; x \u003c img.width; x++) {\n\t\t\t\t\t\t   fimg-\u003eSet(x,y, raster[x + y * img.width]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t_TIFFfree(raster);\n\t\t\t}\n\t    }\n\t    TIFFRGBAImageEnd(\u0026img);\n\t} else {\n\t    TIFFError(filename, emsg);\n\t}\n\treturn fimg;\n}",
        "name": "RGBAImage.cpp",
        "path": "thirdparty/pdiff/RGBAImage.cpp",
        "url": "/github.com/aqsis/aqsis/-/blob/thirdparty/pdiff/RGBAImage.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              8,
              16
            ]
          ],
          "preview": "\t\t\t\tif (TIFFRGBAImageGet(\u0026img, raster, img.width, img.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/aqsis/aqsis",
        "url": "/github.com/aqsis/aqsis"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "6f89d11490fe516478b9a477657de7403d12bece"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "exercise-4/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/epi052/fuzzing-101-solutions/-/blob/exercise-4/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/epi052/fuzzing-101-solutions",
        "url": "/github.com/epi052/fuzzing-101-solutions"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "598c43dabd5364d44afa429b4d837086c8fe5e53"
        },
        "content": "#include \"StdAfx.h\"\n\n// #define STRICT\n#include \"diblib.h\"\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e // MAX_ constants\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage\n{\n    TIFFRGBAImage tif;\n    int dibinstalled;\n};\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster);\n\nstatic void MyWarningHandler(const char *module, const char *fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void MyErrorHandler(const char *module, const char *fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF(LPCTSTR lpszPath)\n{\n    int rtn = 0;\n\n    TIFFErrorHandler eh;\n    TIFFErrorHandler wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF *tif = TIFFOpen(lpszPath, \"r\");\n    if (tif)\n    {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage *img);\n\nPVOID ReadTIFF(LPCTSTR lpszPath)\n{\n    void *pDIB = 0;\n    TIFFErrorHandler wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath))\n    {\n        TIFF *tif = TIFFOpen(lpszPath, \"r\");\n        if (tif)\n        {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg))\n            {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg))\n                {\n                    size_t npixels;\n                    uint32_t *raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster =\n                        (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n                    if (raster != NULL)\n                    {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width,\n                                             img.tif.height))\n                        {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else\n            {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg);\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster)\n{\n    void *pDIB = 0;\n    TIFFRGBAImage *img = \u0026dib-\u003etif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER bi;\n    int dwDIBSize;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if (BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled)\n    { // bilevel\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 1;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(\u0026bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed = 0;\n        pRgbq[0].rgbBlue = 0;\n        pRgbq[0].rgbGreen = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed = 255;\n        pRgbq[1].rgbBlue = 255;\n        pRgbq[1].rgbGreen = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr(\n            (BITMAPINFOHEADER *)pDIB); //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n    //  For now just always default to the RGB 32 bit form. // save as 32 bit\n    //  for simplicity\n    else if (true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/)\n    { // 24 bit color\n\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 32;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(\u0026bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        // Swap the byte order while copying\n        for (int i = 0; i \u003c sizeWords; ++i)\n        {\n            rgbDib[i].rgbRed = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n#define DECLAREContigPutFunc(name)                                             \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *pp)\n\n#define DECLARESepPutFunc(name)                                                \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *r, u_char *g, u_char *b, u_char *a)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *uraster, uint32_t w,\n                              uint32_t h);\n\n// typdef struct TIFFDibImage {\n//     TIFFRGBAImage tif;\n//     dibinstalled;\n// } TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage *dib)\n{\n    TIFFRGBAImage *img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric)\n    {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n            switch (img-\u003ebitspersample)\n            {\n                case 1:\n                    img-\u003eput.contig = putContig1bitTile;\n                    img-\u003eget = getStripContig1Bit;\n                    dib-\u003edibinstalled = true;\n                    break;\n            }\n            break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void)y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char *ucp = (u_char *)cp;\n\n    /* Convert 'w' to bytes from pixels (rounded up) */\n    w = (w + 7) / 8;\n\n    while (h-- \u003e 0)\n    {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32_t setorientation(TIFFRGBAImage *img, uint32_t h)\n{\n    TIFF *tif = img-\u003etif;\n    uint32_t y;\n\n    switch (img-\u003eorientation)\n    {\n        case ORIENTATION_BOTRIGHT:\n        case ORIENTATION_RIGHTBOT: /* XXX */\n        case ORIENTATION_LEFTBOT:  /* XXX */\n            TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n            img-\u003eorientation = ORIENTATION_BOTLEFT;\n        /* fall through... */\n        case ORIENTATION_BOTLEFT:\n            y = 0;\n            break;\n        case ORIENTATION_TOPRIGHT:\n        case ORIENTATION_RIGHTTOP: /* XXX */\n        case ORIENTATION_LEFTTOP:  /* XXX */\n        default:\n            TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n            img-\u003eorientation = ORIENTATION_TOPLEFT;\n        /* fall through... */\n        case ORIENTATION_TOPLEFT:\n            y = h - 1;\n            break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *raster, uint32_t w,\n                              uint32_t h)\n{\n    TIFF *tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16_t orientation;\n    uint32_t row, y, nrow, rowstoread;\n    uint32_t pos;\n    u_char *buf;\n    uint32_t rowsperstrip;\n    uint32_t imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32_t fromskew, toskew;\n    tstrip_t strip;\n    tsize_t stripsize;\n    u_char *braster = (u_char *)raster; // byte wide raster\n    uint32_t wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char *)_TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32_t)(orientation == ORIENTATION_TOPLEFT ? wb + wb : wb - wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0) / 8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif, row + img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset) % rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize) \u003c 0 \u0026\u0026\n            img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32_t *)(braster + y * wb), 0, y, w, nrow, fromskew,\n               toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ? -(int32_t)nrow\n                                                 : (int32_t)nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n",
        "name": "Tiffile.cpp",
        "path": "3rdparty/tiff-4.6.0/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/SuperIlu/DosView/-/blob/3rdparty/tiff-4.6.0/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 112,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width,"
        }
      ],
      "repository": {
        "name": "github.com/SuperIlu/DosView",
        "url": "/github.com/SuperIlu/DosView"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "6dd2dcab2464c1739940a7c7b42eb00b5a82feb1"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n",
        "name": "Tiffile.cpp",
        "path": "libraries/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/POV-Ray/povray/-/blob/libraries/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/POV-Ray/povray",
        "url": "/github.com/POV-Ray/povray"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "464b028c0380183859f1b0bd6b94a6e954772ddf"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "libs/cross_platform/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/Kigs-framework/kigs/-/blob/libs/cross_platform/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/Kigs-framework/kigs",
        "url": "/github.com/Kigs-framework/kigs"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "193c3f4765770ada31ba4ff1e219364f59f4e60f"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "Projects/Android/jni/SupportLibs/SDL2/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/DrBeef/Doom3Quest/-/blob/Projects/Android/jni/SupportLibs/SDL2/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/DrBeef/Doom3Quest",
        "url": "/github.com/DrBeef/Doom3Quest"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "aca0b69befb13a72dae848e110b2bd1cc9007516"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n",
        "name": "Tiffile.cpp",
        "path": "src/main/jni/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/Beyka/Android-TiffBitmapFactory/-/blob/src/main/jni/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/Beyka/Android-TiffBitmapFactory",
        "url": "/github.com/Beyka/Android-TiffBitmapFactory"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "38ade005555056cc7ba454a600d6392ac11a0428"
        },
        "content": "#include \"StdAfx.h\"\r\n\r\n//#define STRICT\r\n#include \u003cwindows.h\u003e\r\n#include \u003cwindowsx.h\u003e\r\n#include \u003ccommdlg.h\u003e\r\n#include \u003cstdlib.h\u003e                     // MAX_ constants\r\n#include \"diblib.h\"\r\n\r\n/*--------------------------------------------------------------------\r\n        READ TIFF\r\n        Load the TIFF data from the file into memory.  Return\r\n        a pointer to a valid DIB (or NULL for errors).\r\n        Uses the TIFFRGBA interface to libtiff.lib to convert\r\n        most file formats to a useable form.  We just keep the 32 bit\r\n        form of the data to display, rather than optimizing for the\r\n        display.\r\n\r\n        Main entry points:\r\n\r\n            int ChkTIFF ( LPCTSTR lpszPath )\r\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\r\n\r\n        RETURN\r\n            A valid DIB pointer for success; NULL for failure.\r\n\r\n  --------------------------------------------------------------------*/\r\n\r\n#include \"TiffLib/tiff.h\"\r\n#include \"TiffLib/tiffio.h\"\r\n#include \u003cassert.h\u003e\r\n#include \u003cstdio.h\u003e\r\n\r\n\r\n// piggyback some data on top of the RGBA Image\r\nstruct TIFFDibImage {\r\n    TIFFRGBAImage tif;\r\n    int  dibinstalled;\r\n} ;\r\n\r\n\r\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\r\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32_t* raster)  ;\r\n\r\nstatic void\r\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\r\n{\r\n    // ignore all warnings (unused tags, etc)\r\n    return;\r\n}\r\n\r\nstatic void\r\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\r\n{\r\n    return;\r\n}\r\n\r\n//  Turn off the error and warning handlers to check if a valid file.\r\n//  Necessary because of the way that the Doc loads images and restart files.\r\nint ChkTIFF ( LPCTSTR lpszPath )\r\n{\r\n    int rtn = 0;\r\n\r\n    TIFFErrorHandler  eh;\r\n    TIFFErrorHandler  wh;\r\n\r\n    eh = TIFFSetErrorHandler(NULL);\r\n    wh = TIFFSetWarningHandler(NULL);\r\n\r\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\r\n    if (tif) {\r\n        rtn = 1;\r\n        TIFFClose(tif);\r\n    }\r\n\r\n    TIFFSetErrorHandler(eh);\r\n    TIFFSetWarningHandler(wh);\r\n\r\n    return rtn;\r\n}\r\n\r\nvoid DibInstallHack(TIFFDibImage* img) ;\r\n\r\nPVOID ReadTIFF ( LPCTSTR lpszPath )\r\n{\r\n    void*             pDIB = 0;\r\n    TIFFErrorHandler  wh;\r\n\r\n    wh = TIFFSetWarningHandler(MyWarningHandler);\r\n\r\n    if (ChkTIFF(lpszPath)) {\r\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\r\n        if (tif) {\r\n            char emsg[1024];\r\n\r\n            if (TIFFRGBAImageOK(tif, emsg)) {\r\n                TIFFDibImage img;\r\n                char emsg[1024];\r\n\r\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\r\n                    size_t npixels;\r\n                    uint32_t* raster;\r\n\r\n                    DibInstallHack(\u0026img);\r\n\r\n                    npixels = img.tif.width * img.tif.height;\r\n                    raster = (uint32_t*) _TIFFmalloc(npixels * sizeof (uint32_t));\r\n                    if (raster != NULL) {\r\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\r\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\r\n                        }\r\n                    }\r\n                    _TIFFfree(raster);\r\n                }\r\n                TIFFRGBAImageEnd(\u0026img.tif);\r\n            }\r\n            else {\r\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\r\n            }\r\n            TIFFClose(tif);\r\n        }\r\n    }\r\n\r\n    TIFFSetWarningHandler(wh);\r\n\r\n    return pDIB;\r\n}\r\n\r\n\r\n\r\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32_t* raster)\r\n{\r\n    void*   pDIB = 0;\r\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\r\n\r\n    uint32_t imageLength;\r\n    uint32_t imageWidth;\r\n    uint16_t BitsPerSample;\r\n    uint16_t SamplePerPixel;\r\n    uint32_t RowsPerStrip;\r\n    uint16_t PhotometricInterpretation;\r\n\r\n    BITMAPINFOHEADER   bi;\r\n    int                dwDIBSize ;\r\n\r\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\r\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\r\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\r\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\r\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\r\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\r\n\r\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\r\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\r\n        bi.biWidth          = imageWidth;\r\n        bi.biHeight         = imageLength;\r\n        bi.biPlanes         = 1;  // always\r\n        bi.biBitCount       = 1;\r\n        bi.biCompression    = BI_RGB;\r\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\r\n        bi.biXPelsPerMeter  = 0;\r\n        bi.biYPelsPerMeter  = 0;\r\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\r\n        bi.biClrImportant   = 0;  // always\r\n\r\n        // Get the size of the DIB\r\n        dwDIBSize = GetDIBSize( \u0026bi );\r\n\r\n        // Allocate for the BITMAPINFO structure and the color table.\r\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\r\n        if (pDIB == 0) {\r\n            return( NULL );\r\n        }\r\n\r\n        // Copy the header info\r\n        *((BITMAPINFOHEADER*)pDIB) = bi;\r\n\r\n        // Get a pointer to the color table\r\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\r\n\r\n        pRgbq[0].rgbRed      = 0;\r\n        pRgbq[0].rgbBlue     = 0;\r\n        pRgbq[0].rgbGreen    = 0;\r\n        pRgbq[0].rgbReserved = 0;\r\n        pRgbq[1].rgbRed      = 255;\r\n        pRgbq[1].rgbBlue     = 255;\r\n        pRgbq[1].rgbGreen    = 255;\r\n        pRgbq[1].rgbReserved = 255;\r\n\r\n        // Pointers to the bits\r\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\r\n        //\r\n        // In the BITMAPINFOHEADER documentation, it appears that\r\n        // there should be no color table for 32 bit images, but\r\n        // experience shows that the image is off by 3 words if it\r\n        // is not included.  So here it is.\r\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\r\n\r\n        int       sizeWords = bi.biSizeImage/4;\r\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\r\n        long*     rgbTif = (long*)raster;\r\n\r\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\r\n    }\r\n\r\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\r\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\r\n\r\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\r\n        bi.biWidth          = imageWidth;\r\n        bi.biHeight         = imageLength;\r\n        bi.biPlanes         = 1;  // always\r\n        bi.biBitCount       = 32;\r\n        bi.biCompression    = BI_RGB;\r\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\r\n        bi.biXPelsPerMeter  = 0;\r\n        bi.biYPelsPerMeter  = 0;\r\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\r\n        bi.biClrImportant   = 0;  // always\r\n\r\n        // Get the size of the DIB\r\n        dwDIBSize = GetDIBSize( \u0026bi );\r\n\r\n        // Allocate for the BITMAPINFO structure and the color table.\r\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\r\n        if (pDIB == 0) {\r\n            return( NULL );\r\n        }\r\n\r\n        // Copy the header info\r\n        *((BITMAPINFOHEADER*)pDIB) = bi;\r\n\r\n        // Get a pointer to the color table\r\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\r\n\r\n        // Pointers to the bits\r\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\r\n        //\r\n        // In the BITMAPINFOHEADER documentation, it appears that\r\n        // there should be no color table for 32 bit images, but\r\n        // experience shows that the image is off by 3 words if it\r\n        // is not included.  So here it is.\r\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\r\n\r\n        int       sizeWords = bi.biSizeImage/4;\r\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\r\n        long*     rgbTif = (long*)raster;\r\n\r\n        // Swap the byte order while copying\r\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\r\n        {\r\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\r\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\r\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\r\n            rgbDib[i].rgbReserved = 0;\r\n        }\r\n    }\r\n\r\n    return pDIB;\r\n}\r\n\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////\r\n//\r\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\r\n//\r\n//\r\ntypedef unsigned char u_char;\r\n\r\n\r\n#define DECLAREContigPutFunc(name) \\\r\nstatic void name(\\\r\n    TIFFRGBAImage* img, \\\r\n    uint32_t* cp, \\\r\n    uint32_t x, uint32_t y, \\\r\n    uint32_t w, uint32_t h, \\\r\n    int32_t fromskew, int32_t toskew, \\\r\n    u_char* pp \\\r\n)\r\n\r\n#define DECLARESepPutFunc(name) \\\r\nstatic void name(\\\r\n    TIFFRGBAImage* img,\\\r\n    uint32_t* cp,\\\r\n    uint32_t x, uint32_t y, \\\r\n    uint32_t w, uint32_t h,\\\r\n    int32_t fromskew, int32_t toskew,\\\r\n    u_char* r, u_char* g, u_char* b, u_char* a\\\r\n)\r\n\r\nDECLAREContigPutFunc(putContig1bitTile);\r\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32_t* uraster, uint32_t w, uint32_t h);\r\n\r\n//typdef struct TIFFDibImage {\r\n//    TIFFRGBAImage tif;\r\n//    dibinstalled;\r\n//} TIFFDibImage ;\r\n\r\nvoid DibInstallHack(TIFFDibImage* dib) {\r\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\r\n    dib-\u003edibinstalled = false;\r\n    switch (img-\u003ephotometric) {\r\n        case PHOTOMETRIC_MINISWHITE:\r\n        case PHOTOMETRIC_MINISBLACK:\r\n        switch (img-\u003ebitspersample) {\r\n            case 1:\r\n                img-\u003eput.contig = putContig1bitTile;\r\n                img-\u003eget = getStripContig1Bit;\r\n                dib-\u003edibinstalled = true;\r\n                break;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\n/*\r\n * 1-bit packed samples =\u003e 1-bit\r\n *\r\n *   Override to just copy the data\r\n */\r\nDECLAREContigPutFunc(putContig1bitTile)\r\n{\r\n    int samplesperpixel = img-\u003esamplesperpixel;\r\n\r\n    (void) y;\r\n    fromskew *= samplesperpixel;\r\n    int wb = WIDTHBYTES(w);\r\n    u_char*  ucp = (u_char*)cp;\r\n\r\n    /* Convert 'w' to bytes from pixels (rounded up) */\r\n    w = (w+7)/8;\r\n\r\n    while (h-- \u003e 0) {\r\n        _TIFFmemcpy(ucp, pp, w);\r\n        /*\r\n        for (x = wb; x-- \u003e 0;) {\r\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\r\n            pp += samplesperpixel;\r\n        }\r\n        */\r\n        ucp += (wb + toskew);\r\n        pp += (w + fromskew);\r\n    }\r\n}\r\n\r\n/*\r\n *  Hacked from the tif_getimage.c file.\r\n */\r\nstatic uint32_t\r\nsetorientation(TIFFRGBAImage* img, uint32_t h)\r\n{\r\n    TIFF* tif = img-\u003etif;\r\n    uint32_t y;\r\n\r\n    switch (img-\u003eorientation) {\r\n    case ORIENTATION_BOTRIGHT:\r\n    case ORIENTATION_RIGHTBOT:  /* XXX */\r\n    case ORIENTATION_LEFTBOT:   /* XXX */\r\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\r\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\r\n    /* fall through... */\r\n    case ORIENTATION_BOTLEFT:\r\n    y = 0;\r\n    break;\r\n    case ORIENTATION_TOPRIGHT:\r\n    case ORIENTATION_RIGHTTOP:  /* XXX */\r\n    case ORIENTATION_LEFTTOP:   /* XXX */\r\n    default:\r\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\r\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\r\n    /* fall through... */\r\n    case ORIENTATION_TOPLEFT:\r\n    y = h-1;\r\n    break;\r\n    }\r\n    return (y);\r\n}\r\n\r\n/*\r\n * Get a strip-organized image that has\r\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\r\n * or\r\n *  SamplesPerPixel == 1\r\n *\r\n *  Hacked from the tif_getimage.c file.\r\n *\r\n *    This is set up to allow us to just copy the data to the raster\r\n *    for 1-bit bitmaps\r\n */\r\nstatic int\r\ngetStripContig1Bit(TIFFRGBAImage* img, uint32_t* raster, uint32_t w, uint32_t h)\r\n{\r\n    TIFF* tif = img-\u003etif;\r\n    tileContigRoutine put = img-\u003eput.contig;\r\n    uint16_t orientation;\r\n    uint32_t row, y, nrow, rowstoread;\r\n    uint32_t pos;\r\n    u_char* buf;\r\n    uint32_t rowsperstrip;\r\n    uint32_t imagewidth = img-\u003ewidth;\r\n    tsize_t scanline;\r\n    int32_t fromskew, toskew;\r\n    tstrip_t strip;\r\n    tsize_t  stripsize;\r\n    u_char* braster = (u_char*)raster; // byte wide raster\r\n    uint32_t  wb = WIDTHBYTES(w);\r\n    int ret = 1;\r\n\r\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\r\n    if (buf == 0) {\r\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\r\n        return (0);\r\n    }\r\n    y = setorientation(img, h);\r\n    orientation = img-\u003eorientation;\r\n    toskew = -(int32_t) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\r\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\r\n    scanline = TIFFScanlineSize(tif);\r\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\r\n    for (row = 0; row \u003c h; row += nrow)\r\n    {\r\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\r\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\r\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\r\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\r\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\r\n            \u0026\u0026 img-\u003estoponerr)\r\n        {\r\n            ret = 0;\r\n            break;\r\n        }\r\n\r\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\r\n        (*put)(img, (uint32_t*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\r\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32_t) nrow : (int32_t) nrow);\r\n    }\r\n    _TIFFfree(buf);\r\n    return (ret);\r\n}\r\n\r\n/*\r\n * Local Variables:\r\n * mode: c++\r\n * c-basic-offset: 8\r\n * fill-column: 78\r\n * End:\r\n */\r\n",
        "name": "Tiffile.cpp",
        "path": "thirdparty/libtiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/lizabelos/libCML/-/blob/thirdparty/libtiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\r"
        }
      ],
      "repository": {
        "name": "github.com/lizabelos/libCML",
        "url": "/github.com/lizabelos/libCML"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "7e0844e0887634cb7f0d61eed8a9a573e8806f2d"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "extern/SDL_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/wheybags/freeablo/-/blob/extern/SDL_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/wheybags/freeablo",
        "url": "/github.com/wheybags/freeablo"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "60682b2a086988f291725f8c9866a41350abda91"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "app/src/main/jni/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/KillerInk/FreeDcam/-/blob/app/src/main/jni/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/KillerInk/FreeDcam",
        "url": "/github.com/KillerInk/FreeDcam"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "4a6de1675eab8a9e6ab7f70415a27d73277ea911"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/lisanet/Argyll-macos-arm/-/blob/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/lisanet/Argyll-macos-arm",
        "url": "/github.com/lisanet/Argyll-macos-arm"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "81dfe67f5683526006545519766979e5eafba4a6"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "wxwidgets/src/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/arturasn/mdb2sqlite/-/blob/wxwidgets/src/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/arturasn/mdb2sqlite",
        "url": "/github.com/arturasn/mdb2sqlite"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "b77414bc4829cddf2e2f5278da0365c26626332b"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "data/cve/tiff-asan/tiff-4.0.7/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/SanRazor-repo/SanRazor/-/blob/data/cve/tiff-asan/tiff-4.0.7/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/SanRazor-repo/SanRazor",
        "url": "/github.com/SanRazor-repo/SanRazor"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "674bd96d3b917c85ba451ddd902ee46f93179355"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "dependencies/sdl2-image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/ludamad/lanarts/-/blob/dependencies/sdl2-image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/ludamad/lanarts",
        "url": "/github.com/ludamad/lanarts"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "55fff2ecde00c09132e981a8756e824c465f18e6"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "jni/tiff-3.9.5/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/paulasiimwe/Android-ImageMagick/-/blob/jni/tiff-3.9.5/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/paulasiimwe/Android-ImageMagick",
        "url": "/github.com/paulasiimwe/Android-ImageMagick"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a3b1082519c8526855ec862af3378e46de335f93"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "src/3rdparty/libtiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/Froser/gamemachine/-/blob/src/3rdparty/libtiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/Froser/gamemachine",
        "url": "/github.com/Froser/gamemachine"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "4835cd8c24af2081877184c0ac800f4a3c1106dc"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "src/libtiff/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/fengbingchun/OCR_Test/-/blob/src/libtiff/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/fengbingchun/OCR_Test",
        "url": "/github.com/fengbingchun/OCR_Test"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "943df4fb11980d0b5a30b9115d3bce7f860e31c6"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n",
        "name": "Tiffile.cpp",
        "path": "libtiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/AngusHardie/TesseractOCR-For-Mac/-/blob/libtiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/AngusHardie/TesseractOCR-For-Mac",
        "url": "/github.com/AngusHardie/TesseractOCR-For-Mac"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "7e4212dcc6aeddc3eed76254e7ed1b48bbc53ec4"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n",
        "name": "Tiffile.cpp",
        "path": "lightcrafts/jnisrc/tiff/libtiff/tiff-3.8.2/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/AntonKast/LightZone/-/blob/lightcrafts/jnisrc/tiff/libtiff/tiff-3.8.2/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/AntonKast/LightZone",
        "url": "/github.com/AntonKast/LightZone"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "813fb45dc0652e8803fe32da7acd1c9512ff4902"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "jni/tiff-3.9.5/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/hagish/love-native-android/-/blob/jni/tiff-3.9.5/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/hagish/love-native-android",
        "url": "/github.com/hagish/love-native-android"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f1c8b5334f72be0b9bc096ae959556c77338cfb"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "ndk-modules/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/lilac/Android-ImageMagick/-/blob/ndk-modules/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/lilac/Android-ImageMagick",
        "url": "/github.com/lilac/Android-ImageMagick"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "f4be81662b96a074e3dbd1b642b1dd5cc8bdcf2c"
        },
        "content": "#include \u003cDraw/Draw.h\u003e\r\n#include \"tif.h\"\r\n#include \u003cPainter/Painter.h\u003e\r\n\r\n#define\ttif_int32 int32_t\r\n#define\ttif_uint32 uint32_t\r\n\r\n#define LLOG(x)  // LOG(x)\r\n\r\n// #define DBGALLOC 1\r\n\r\nnamespace Upp {\r\n\r\n#if DBGALLOC\r\ndouble total_allocated = 0, total_freed = 0;\r\nunsigned alloc_calls = 0, free_calls = 0, realloc_calls = 0;\r\nIndex\u003ctsize_t\u003e size_index;\r\nVector\u003cint\u003e size_alloc_calls, size_free_calls;\r\nint op_id;\r\n\r\nvoid dbgAddAlloc(void *p, tsize_t s)\r\n{\r\n\t++op_id;\r\n\ttotal_allocated += s;\r\n\tint i = size_index.Find(s);\r\n\tif(i \u003e= 0)\r\n\t\tsize_alloc_calls[i]++;\r\n\telse\r\n\t{\r\n\t\tsize_index.Add(s);\r\n\t\tsize_alloc_calls.Add(1);\r\n\t\tsize_free_calls.Add(0);\r\n\t}\r\n\tLLOG(op_id \u003c\u003c \" tAlloc(\" \u003c\u003c s \u003c\u003c \") = \" \u003c\u003c p \u003c\u003c \": blks: \" \u003c\u003c alloc_calls - free_calls \u003c\u003c \", alloc = \" \u003c\u003c total_allocated \u003c\u003c \", free = \" \u003c\u003c total_freed \u003c\u003c \", diff = \" \u003c\u003c (total_allocated - total_freed));\r\n}\r\n\r\nvoid dbgAddFree(void *p, tsize_t s)\r\n{\r\n\t++op_id;\r\n\ttotal_freed += s;\r\n\tint i = size_index.Find(s);\r\n\tif(i \u003e= 0)\r\n\t\tsize_free_calls[i]++;\r\n\telse\r\n\t{\r\n\t\tsize_index.Add(s);\r\n\t\tsize_alloc_calls.Add(0);\r\n\t\tsize_free_calls.Add(1);\r\n\t}\r\n\tLLOG(op_id \u003c\u003c \" tFree(\" \u003c\u003c p \u003c\u003c \") = \" \u003c\u003c s \u003c\u003c \": blks: \" \u003c\u003c alloc_calls - free_calls \u003c\u003c \", alloc = \" \u003c\u003c total_allocated \u003c\u003c \", free = \" \u003c\u003c total_freed \u003c\u003c \", diff = \" \u003c\u003c (total_allocated - total_freed));\r\n}\r\n\r\nvoid TiffAllocStat()\r\n{\r\n\tfor(int i = 0; i \u003c size_index.GetCount(); i++)\r\n\t\tif(size_alloc_calls[i] != size_free_calls[i])\r\n\t\t\tLOG(\"Alloc/free mismatch: size = \" \u003c\u003c size_index[i]\r\n\t\t\t\u003c\u003c \", alloc = \" \u003c\u003c size_alloc_calls[i] \u003c\u003c \", frees = \" \u003c\u003c size_free_calls[i]);\r\n}\r\n#endif\r\n\r\nextern \"C\" tdata_t _TIFFmalloc(tsize_t s)\r\n{\r\n\tbyte *p = new byte[s + 16];\r\n\tPoke32le(p, s);\r\n#if DBGALLOC\r\n\talloc_calls++;\r\n\tdbgAddAlloc(p, s);\r\n#endif\r\n\treturn (tdata_t)(p + 16);\r\n}\r\n\r\nextern \"C\" void* _TIFFcalloc(tmsize_t nmemb, tmsize_t siz)\r\n{\r\n    if( nmemb == 0 || siz == 0 )\r\n        return ((void *) NULL);\r\n\r\n    return _TIFFmalloc(nmemb * siz);\r\n}\r\n\r\nextern \"C\" void    _TIFFfree(tdata_t p)\r\n{\r\n\tif(p) {\r\n\t\tbyte *rawp = (byte *)p - 16;\r\n#if DBGALLOC\r\n\t\tfree_calls++;\r\n\t\tdbgAddFree(p, Peek32le(rawp));\r\n#endif\r\n\t\tdelete[] (rawp);\r\n\t}\r\n}\r\n\r\nextern \"C\" tdata_t _TIFFrealloc(tdata_t p, tsize_t s)\r\n{\r\n\tint oldsize = (p ? Peek32le((const byte *)p - 16) : 0);\r\n\tbyte *newptr = new byte[s + 16];\r\n#if DBGALLOC\r\n\talloc_calls++;\r\n\tdbgAddAlloc(newptr, s);\r\n#endif\r\n\tif(oldsize) {\r\n\t\tmemcpy(newptr + 16, p, min\u003cint\u003e(oldsize, s));\r\n#if DBGALLOC\r\n\t\tfree_calls++;\r\n\t\tdbgAddFree(newptr, oldsize);\r\n#endif\r\n\t\tdelete[] ((byte *)p - 16);\r\n\t}\r\n\tPoke32le(newptr, s);\r\n\treturn (tdata_t)(newptr + 16);\r\n}\r\n\r\nextern \"C\" void _TIFFmemset(void* p, int v, tmsize_t c)           { memset(p, v, c); }\r\nextern \"C\" void _TIFFmemcpy(void* d, const void *s, tmsize_t c) { memcpy(d, s, c); }\r\nextern \"C\" int  _TIFFmemcmp(const void *p1, const void *p2, tmsize_t c) { return memcmp(p1, p2, c); }\r\n\r\n/*\r\nstatic void Blt2to4(byte *dest, const byte *src, unsigned count)\r\n{\r\n\tbyte b;\r\n\r\n#define BLT2_4_4(o) \\\r\n\tb = src[(o)]; \\\r\n\tdest[2 * (o) + 0] = ((b \u003e\u003e 2) \u0026 0x30) | ((b \u003e\u003e 4) \u0026 0x03); \\\r\n\tdest[2 * (o) + 1] = ((b \u003c\u003c 2) \u0026 0x30) | (b \u0026 0x03);\r\n\r\n\tfor(unsigned rep = count \u003e\u003e 5; rep; rep--) {\r\n\t\tBLT2_4_4(0) BLT2_4_4(1) BLT2_4_4(2) BLT2_4_4(3)\r\n\t\tBLT2_4_4(4) BLT2_4_4(5) BLT2_4_4(6) BLT2_4_4(7)\r\n\t\tdest += 8 * 2;\r\n\t\tsrc += 8;\r\n\t}\r\n\tif(count \u0026 16) {\r\n\t\tBLT2_4_4(0) BLT2_4_4(1) BLT2_4_4(2) BLT2_4_4(3)\r\n\t\tdest += 4 * 2;\r\n\t\tsrc += 4;\r\n\t}\r\n\tif(count \u0026 8) {\r\n\t\tBLT2_4_4(0) BLT2_4_4(1)\r\n\t\tdest += 2 * 2;\r\n\t\tsrc += 2;\r\n\t}\r\n\tif(count \u0026 4) {\r\n\t\tBLT2_4_4(0)\r\n\t\tdest += 2;\r\n\t\tsrc++;\r\n\t}\r\n\tswitch(count \u0026 3) {\r\n\tcase 0:\r\n\t\tbreak;\r\n\r\n\tcase 1:\r\n\t\t*dest = ((*src \u003e\u003e 2) \u0026 0x30);\r\n\t\tbreak;\r\n\r\n\tcase 2:\r\n\t\t*dest = ((*src \u003e\u003e 2) \u0026 0x30) | ((*src \u003e\u003e 4) \u0026 0x03);\r\n\t\tbreak;\r\n\r\n\tcase 3:\r\n\t\t*dest++ = ((*src \u003e\u003e 2) \u0026 0x30) | ((*src \u003e\u003e 4) \u0026 0x03);\r\n\t\t*dest = (*src \u003c\u003c 2) \u0026 0x30;\r\n\t\tbreak;\r\n\t}\r\n}\r\n*/\r\nstatic void BltPack11(byte *dest, const byte *src, byte bit_shift, unsigned count)\r\n{\r\n\tif(bit_shift == 0)\r\n\t{ // simple case\r\n#if defined(CPU_IA32)\r\n#define BLT_PACK_11_4(o) *(unsigned *)(dest + (o)) = *(const unsigned *)(src + (o));\r\n#else\r\n#define BLT_PACK_11_4(o) dest[(o) + 0] = src[(o) + 0]; dest[(o) + 1] = src[(o) + 1]; \\\r\n\tdest[(o) + 2] = src[(o) + 2]; dest[(o) + 3] = src[(o) + 3];\r\n#endif\r\n\t\tfor(unsigned rep = count \u003e\u003e 7; rep; rep--)\r\n\t\t{\r\n\t\t\tBLT_PACK_11_4(0) BLT_PACK_11_4(4) BLT_PACK_11_4(8) BLT_PACK_11_4(12)\r\n\t\t\tdest += 16;\r\n\t\t\tsrc += 16;\r\n\t\t}\r\n\t\tif(count \u0026 0x40)\r\n\t\t{\r\n\t\t\tBLT_PACK_11_4(0) BLT_PACK_11_4(4)\r\n\t\t\tdest += 8;\r\n\t\t\tsrc += 8;\r\n\t\t}\r\n\t\tif(count \u0026 0x20)\r\n\t\t{\r\n\t\t\tBLT_PACK_11_4(0)\r\n\t\t\tdest += 4;\r\n\t\t\tsrc += 4;\r\n\t\t}\r\n\t\tif(count \u0026 0x10)\r\n\t\t{\r\n\t\t\tdest[0] = src[0]; dest[1] = src[1];\r\n\t\t\tdest += 2;\r\n\t\t\tsrc += 2;\r\n\t\t}\r\n\t\tif(count \u0026 8)\r\n\t\t\t*dest++ = *src++;\r\n\t\tswitch(count \u0026 7)\r\n\t\t{\r\n\t\tcase 0: break;\r\n\t\tcase 1: *dest = (*src \u0026 0x80) | (*dest | 0x7f); break;\r\n\t\tcase 2: *dest = (*src \u0026 0xc0) | (*dest | 0x3f); break;\r\n\t\tcase 3: *dest = (*src \u0026 0xe0) | (*dest | 0x1f); break;\r\n\t\tcase 4: *dest = (*src \u0026 0xf0) | (*dest | 0x0f); break;\r\n\t\tcase 5: *dest = (*src \u0026 0xf8) | (*dest | 0x07); break;\r\n\t\tcase 6: *dest = (*src \u0026 0xfc) | (*dest | 0x03); break;\r\n\t\tcase 7: *dest = (*src \u0026 0xfe) | (*dest | 0x01); break;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tconst byte shift1 = bit_shift, shift2 = 8 - bit_shift;\r\n\t\tbyte mask;\r\n\t\tif(count + shift1 \u003c= 8)\r\n\t\t{ // touch just 1 byte\r\n\t\t\tmask = ((1 \u003c\u003c count) - 1) \u003c\u003c (8 - count - shift1);\r\n\t\t\t*dest = (*dest \u0026 ~mask) | ((*src \u003e\u003e shift1) \u0026 mask);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tmask = 0xff00 \u003e\u003e shift1;\r\n\t\t*dest = (*dest \u0026 ~mask) | ((*src \u003e\u003e shift1) \u0026 mask);\r\n\t\tdest++;\r\n\t\tcount -= shift2;\r\n#define BLT_SHIFT_11_1(o) dest[(o)] = (src[(o)] \u003c\u003c shift2) | (src[(o) + 1] \u003e\u003e shift1);\r\n#define BLT_SHIFT_11_4(o) BLT_SHIFT_11_1((o)) BLT_SHIFT_11_1((o) + 1) BLT_SHIFT_11_1((o) + 2) BLT_SHIFT_11_1((o) + 3)\r\n\t\tfor(unsigned rep = count \u003e\u003e 6; rep; rep--)\r\n\t\t{\r\n\t\t\tBLT_SHIFT_11_4(0) BLT_SHIFT_11_4(4)\r\n\t\t\tdest += 8;\r\n\t\t\tsrc += 8;\r\n\t\t}\r\n\t\tif(count \u0026 0x20)\r\n\t\t{\r\n\t\t\tBLT_SHIFT_11_4(0)\r\n\t\t\tdest += 4;\r\n\t\t\tsrc += 4;\r\n\t\t}\r\n\t\tif(count \u0026 0x10)\r\n\t\t{\r\n\t\t\tBLT_SHIFT_11_1(0) BLT_SHIFT_11_1(1)\r\n\t\t\tdest += 2;\r\n\t\t\tsrc += 2;\r\n\t\t}\r\n\t\tif(count \u0026 8)\r\n\t\t{\r\n\t\t\tBLT_SHIFT_11_1(0)\r\n\t\t\tdest++;\r\n\t\t\tsrc++;\r\n\t\t}\r\n\t\tif(count \u0026= 7)\r\n\t\t{\r\n\t\t\tbyte data = (count \u003c= shift1 ? src[1] \u003c\u003c shift2 : (src[1] \u003c\u003c shift2) | (src[2] \u003e\u003e shift1));\r\n\t\t\tmask = 0xff00 \u003e\u003e count;\r\n\t\t\t*dest = (*dest \u0026 ~mask) | (data \u0026 mask);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// add support for 2 bpp tif - Massimo Del Fedele\r\n// un-optimized way....\r\n// bit_shift should be shift on destination, NOT source\r\nstatic void BltPack22(byte *dest, const byte *src, byte bit_shift, unsigned count)\r\n{\r\n\tunsigned c2 = count \u003e\u003e 2;\r\n\tcount \u0026= 0x03;\r\n\tbyte shift1, shift2;\r\n\tbyte sMask1, sMask2;\r\n\tbyte dMask1, dMask2;\r\n\r\n\tif(!bit_shift) // fast path\r\n\t{\r\n\t\tif(c2)\r\n\t\t{\r\n\t\t\tmemcpy(dest, src, c2);\r\n\t\t\tdest += c2;\r\n\t\t\tsrc += c2;\r\n\t\t}\r\n\t\tswitch(count)\r\n\t\t{\r\n\t\t\tdefault:\r\n\t\t\tcase 0:\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\t*dest = (*dest \u0026 0x3f) | (*src \u0026 0x3f);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\r\n\t\t\t\t*dest = (*dest \u0026 0x0f) | (*src \u0026 0x0f);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 3:\r\n\t\t\t\t*dest = (*dest \u0026 0x03) | (*src \u0026 0x03);\r\n\t\t\t\tbreak;\r\n\t\t} // switch(count)\r\n\t}\r\n\telse // slow path\r\n\t{\r\n\t\tbit_shift \u003c\u003c= 1;\r\n\t\tshift1 = bit_shift;\r\n\t\tshift2 = (8 - bit_shift);\r\n\t\tsMask1 = 0xff \u003c\u003c shift1;\r\n\t\tdMask1 = 0xff \u003c\u003c shift2;\r\n\t\tsMask2 = 0xff \u003e\u003e shift2;\r\n\t\tdMask2 = 0xff \u003e\u003e shift1;\r\n\t\twhile(c2--)\r\n\t\t{\r\n\t\t\t*dest = (*dest \u0026 dMask1) | ((*src \u0026 sMask1) \u003e\u003e shift1);\r\n\t\t\tdest++;\r\n\t\t\t*dest = (*dest \u0026 dMask2) | ((*src \u0026 sMask2) \u003c\u003c shift2);\r\n\t\t\tsrc++;\r\n\t\t}\r\n\t\tswitch(count)\r\n\t\t{\r\n\t\t\tcase 0:\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\t*dest = (*dest \u0026 ~(0xc0 \u003e\u003e bit_shift)) | ((*src \u0026 0xc0) \u003e\u003e bit_shift);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\r\n\t\t\t\tif(bit_shift \u003c= 4)\r\n\t\t\t\t{\r\n\t\t\t\t\t*dest = (*dest \u0026 ~(0xf0 \u003e\u003e bit_shift)) | ((*src \u0026 0xf0) \u003e\u003e bit_shift);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t*dest = (*dest \u0026 ~(0xc0 \u003e\u003e bit_shift)) | ((*src \u0026 0xc0) \u003e\u003e bit_shift);\r\n\t\t\t\t\tdest++;\r\n\t\t\t\t\t*dest = (*dest \u0026 0x3f) | ((*src \u0026 0x30) \u003c\u003c 2);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 3:\r\n\t\t\t\tif(bit_shift \u003c= 2)\r\n\t\t\t\t{\r\n\t\t\t\t\t*dest = (*dest \u0026 ~(0xfc \u003e\u003e bit_shift)) | ((*src \u0026 0xfc) \u003e\u003e bit_shift);\r\n\t\t\t\t}\r\n\t\t\t\telse if(bit_shift \u003c= 4)\r\n\t\t\t\t{\r\n\t\t\t\t\t*dest = (*dest \u0026 ~(0xf0 \u003e\u003e bit_shift)) | ((*src \u0026 0xf0) \u003e\u003e bit_shift);\r\n\t\t\t\t\tdest++;\r\n\t\t\t\t\t*dest = (*dest \u0026 0x3f) | ((*src \u0026 0x0c) \u003c\u003c 4);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t*dest = (*dest \u0026 0xfc) | ((*src \u0026 0xc0) \u003e\u003e 6);\r\n\t\t\t\t\tdest++;\r\n\t\t\t\t\t*dest = (*dest \u0026 0x0f) | ((*src \u0026 0x3c) \u003c\u003c 2);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t} // switch(count)\r\n\t} // end slow path\r\n\r\n}\r\n\r\nstatic void BltPack44(byte *dest, const byte *src, bool shift, unsigned count)\r\n{\r\n//\tRTIMING(\"BltPack44\");\r\n\tASSERT(count \u003e 0);\r\n\tif(shift)\r\n\t{\r\n\t\tbyte c = *src++, d;\r\n\t\t*dest = (*dest \u0026 0xF0) | (c \u003e\u003e 4);\r\n\t\tdest++;\r\n\t\tcount--;\r\n\t\twhile(count \u003e= 8)\r\n\t\t{\r\n\t\t\td = src[0]; dest[0] = (c \u003c\u003c 4) | (d \u003e\u003e 4);\r\n\t\t\tc = src[1]; dest[1] = (d \u003c\u003c 4) | (c \u003e\u003e 4);\r\n\t\t\td = src[2]; dest[2] = (c \u003c\u003c 4) | (d \u003e\u003e 4);\r\n\t\t\tc = src[3]; dest[3] = (d \u003c\u003c 4) | (c \u003e\u003e 4);\r\n\t\t\tsrc += 4;\r\n\t\t\tdest += 4;\r\n\t\t\tcount -= 8;\r\n\t\t}\r\n\t\tif(count \u0026 4)\r\n\t\t{\r\n\t\t\td = src[0]; dest[0] = (c \u003c\u003c 4) | (d \u003e\u003e 4);\r\n\t\t\tc = src[1]; dest[1] = (d \u003c\u003c 4) | (c \u003e\u003e 4);\r\n\t\t\tsrc += 2;\r\n\t\t\tdest += 2;\r\n\t\t}\r\n\t\tif(count \u0026 2)\r\n\t\t{\r\n\t\t\td = src[0]; dest[0] = (c \u003c\u003c 4) | (d \u003e\u003e 4);\r\n\t\t\tc = d;\r\n\t\t\tsrc++;\r\n\t\t\tdest++;\r\n\t\t}\r\n\t\tif(count \u0026 1)\r\n\t\t\tdest[0] = (dest[0] \u0026 15) | (c \u003c\u003c 4);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tunsigned c2 = count \u003e\u003e 1;\r\n\t\tif(c2)\r\n\t\t\tmemcpy(dest, src, c2);\r\n\t\tif(count \u0026 1)\r\n\t\t\tdest[c2] = (dest[c2] \u0026 15) | (src[c2] \u0026 0xF0);\r\n\t}\r\n}\r\n/*\r\nstatic void BltPack4(byte *dest, const byte *src, unsigned count)\r\n{\r\n#define BLT_PACK_4_4(o) dest[(o)] = src[4 * (o)]; dest[(o) + 1] = src[4 * (o) + 4]; \\\r\n\tdest[(o) + 2] = src[4 * (o) + 8]; dest[(o) + 3] = src[4 * (o) + 12];\r\n\tfor(unsigned rep = count \u003e\u003e 4; rep; rep--)\r\n\t{\r\n\t\tBLT_PACK_4_4(0) BLT_PACK_4_4(4) BLT_PACK_4_4(8) BLT_PACK_4_4(12)\r\n\t\tdest += 16;\r\n\t\tsrc += 4 * 16;\r\n\t}\r\n\tif(count \u0026 8)\r\n\t{\r\n\t\tBLT_PACK_4_4(0) BLT_PACK_4_4(4)\r\n\t\tdest += 8;\r\n\t\tsrc += 4 * 8;\r\n\t}\r\n\tif(count \u0026 4)\r\n\t{\r\n\t\tBLT_PACK_4_4(0)\r\n\t\tdest += 4;\r\n\t\tsrc += 4 * 4;\r\n\t}\r\n\tif(count \u0026 2)\r\n\t{\r\n\t\tdest[0] = src[0]; dest[1] = src[4];\r\n\t\tdest += 2;\r\n\t\tsrc += 4 * 2;\r\n\t}\r\n\tif(count \u0026 1)\r\n\t\tdest[0] = src[0];\r\n}\r\n*/\r\nstatic tsize_t ReadStream(thandle_t fd, tdata_t buf, tsize_t size)\r\n{\r\n\tStream *stream = reinterpret_cast\u003cStream *\u003e(fd);\r\n\tif(!stream-\u003eIsOpen())\r\n\t\treturn 0;\r\n//\tRLOG(\"TiffStream::TIFRaster::Data \u0026 \" \u003c\u003c (int)wrapper.stream.GetPos() \u003c\u003c \", count = \" \u003c\u003c size\r\n//\t\t\u003c\u003c \", end = \" \u003c\u003c (int)(wrapper.stream.GetPos() + size));\r\n\treturn stream-\u003eGet(buf, size);\r\n}\r\n\r\nstatic tsize_t WriteStream(thandle_t fd, tdata_t buf, tsize_t size)\r\n{\r\n\tStream *stream = reinterpret_cast\u003cStream *\u003e(fd);\r\n\tASSERT(stream-\u003eIsOpen());\r\n\tstream-\u003ePut(buf, size);\r\n\treturn stream-\u003eIsError() ? 0 : size;\r\n}\r\n\r\nstatic toff_t SeekStream(thandle_t fd, toff_t off, int whence)\r\n{\r\n\tStream *stream = reinterpret_cast\u003cStream *\u003e(fd);\r\n\tASSERT(stream-\u003eIsOpen());\r\n\ttoff_t size = (toff_t)stream-\u003eGetSize();\r\n\ttoff_t destpos = (toff_t)(off + (whence == 1 ? stream-\u003eGetPos() : whence == 2 ? size : 0));\r\n\tstream-\u003eSeek(destpos);\r\n//\tRLOG(\"TIFRaster::Data::SeekStream -\u003e \" \u003c\u003c (int)off \u003c\u003c \", whence = \" \u003c\u003c whence \u003c\u003c \" -\u003e pos = \" \u003c\u003c (int)wrapper.stream.GetPos());\r\n\treturn (toff_t)stream-\u003eGetPos();\r\n}\r\n\r\nstatic int CloseStream(thandle_t fd)\r\n{\r\n\treturn 0;\r\n}\r\n\r\nstatic int CloseOwnedStream(thandle_t fd)\r\n{\r\n\tdelete reinterpret_cast\u003cStream *\u003e(fd);\r\n\treturn 0;\r\n}\r\n\r\nstatic toff_t SizeStream(thandle_t fd)\r\n{\r\n\tStream *stream = reinterpret_cast\u003cStream *\u003e(fd);\r\n\tASSERT(stream-\u003eIsOpen());\r\n//\tRLOG(\"TIFRaster::Data::SizeStream -\u003e \" \u003c\u003c (int)wrapper.stream.GetSize());\r\n\treturn (toff_t)stream-\u003eGetSize();\r\n}\r\n\r\nstatic int MapStream(thandle_t fd, tdata_t *pbase, toff_t *psize)\r\n{\r\n\treturn 0;\r\n}\r\n\r\nstatic void UnmapStream(thandle_t fd, tdata_t base, toff_t size)\r\n{\r\n}\r\n\r\nstruct ::tiff *TIFFFileStreamOpen(const char *filename, const char *mode)\r\n{\r\n\tOne\u003cFileStream\u003e fs = new FileStream;\r\n\tint m = _TIFFgetMode(NULL, NULL, mode, \"TIFFOpen\");\r\n\tdword fmode = FileStream::READ;\r\n\r\n\tswitch(m) {\r\n\t\tcase O_RDONLY: {\r\n\t\t\tfmode = FileStream::READ;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase O_RDWR: {\r\n\t\t\tfmode = FileStream::READWRITE;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase O_RDWR|O_CREAT:\r\n\t\tcase O_RDWR|O_TRUNC:\r\n\t\tcase O_RDWR|O_CREAT|O_TRUNC: {\r\n\t\t\tfmode = FileStream::CREATE;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif(!fs-\u003eOpen(filename, fmode))\r\n\t\treturn NULL;\r\n\treturn TIFFStreamOpen(filename, mode, fs.Detach(), true);\r\n}\r\n/*\r\n\r\nstruct ::tiff* TIFFWrapOpen(const char *filename, const char *mode){\r\n\treturn ::TIFFOpen(filename, mode);\r\n}\r\n\r\nint TIFFWrapGetField(::tiff* tif_data, uint32 tag, ...){\r\n\tva_list ap;\r\n\treturn ::TIFFGetField(tif_data, tag, ap);\r\n}\r\n*/\r\n\r\nstruct ::tiff *TIFFStreamOpen(const char *filename, const char *mode, Stream *stream, bool destruct)\r\n{\r\n\treturn TIFFClientOpen(filename, mode, reinterpret_cast\u003cthandle_t\u003e(stream),\r\n\t\t\u0026ReadStream, \u0026WriteStream,\r\n\t\t\u0026SeekStream,\r\n\t\tdestruct ? \u0026CloseOwnedStream : \u0026CloseStream,\r\n\t\t\u0026SizeStream,\r\n\t\t\u0026MapStream, \u0026UnmapStream);\r\n}\r\n\r\n\r\nstruct TIFRaster::Data : public TIFFRGBAImage {\r\n\tData(Stream\u0026 stream);\r\n\t~Data();\r\n\r\n\tbool             Create();\r\n\tRaster::Info     GetInfo();\r\n\tRaster::Line     GetLine(int i, Raster *owner);\r\n\tbool             SeekPage(int page);\r\n\tbool             FetchPage();\r\n\r\n\tstatic void      Warning(const char* module, const char* fmt, va_list ap);\r\n\tstatic void      Error(const char* module, const char* fmt, va_list ap);\r\n\r\n\tRasterFormat     format;\r\n\r\n\tStream\u0026          stream;\r\n\tTIFF             *tiff;\r\n\r\n\tstruct Page {\r\n\t\tuint32       width, height;\r\n\t\tuint16       bits_per_sample;\r\n\t\tuint16       samples_per_pixel;\r\n\t\tuint16       photometric;\r\n\t\tuint16       orientation;\r\n\t\tSize         dot_size;\r\n\t\tbool         alpha;\r\n\t};\r\n\tArray\u003cPage\u003e      pages;\r\n\tint              page_index;\r\n\r\n\tVectorMap\u003cString, Value\u003e attr;\r\n\r\n\tbyte *MapDown(int x, int y, int count);\r\n\tbyte *MapUp(int x, int y, int count);\r\n\r\n\tSize size;\r\n\tint bpp;\r\n\tint row_bytes;\r\n\tint cache_size;\r\n\tbool alpha;\r\n\tbool page_open;\r\n\tbool page_fetched;\r\n\tbool page_error;\r\n\tVector\u003cbyte\u003e imagebuf;\r\n\tstruct Row {\r\n\t\tRow() {}\r\n\r\n\t\tBuffer\u003cbyte\u003e mapping;\r\n\t};\r\n\tenum { MAX_CACHE_SIZE = 50000000 };\r\n\tRGBA palette[256];\r\n\tint palette_count;\r\n\tBuffer\u003cRow\u003e rows;\r\n\tint64 mapping_offset;\r\n\tint mapping_size;\r\n\tVector\u003cuint32_t\u003e buffer;\r\n\ttileContigRoutine contig;\r\n\ttileSeparateRoutine separate;\r\n\tint skewfac;\r\n//\tvoid (*pack)(TIFFImageHelper *helper, uint32 x, uint32 y, uint32 w, uint32 h);\r\n//\tString warnings;\r\n//\tString errors;\r\n};\r\n\r\nextern \"C\" {\r\n\r\nTIFFErrorHandler _TIFFwarningHandler = TIFRaster::Data::Warning;\r\nTIFFErrorHandler _TIFFerrorHandler   = TIFRaster::Data::Error;\r\n\r\n};\r\n\r\nstatic void packTileRGB(TIFRaster::Data *helper, uint32 x, uint32 y, uint32 w, uint32 h)\r\n{\r\n\tif(helper-\u003ealpha) {\r\n\t\tint x4 = 4 * x, w4 = 4 * w;\r\n\t//\tbyte *dest = helper-\u003edest.GetUpScan(y) + 3 * x;\r\n\t\tconst byte *src = (const byte *)helper-\u003ebuffer.Begin();\r\n\t//\tunsigned srow = sizeof(uint32) * w; //, drow = helper-\u003edest.GetUpRowBytes();\r\n\t\tfor(; h; h--, /*src += srow,*/ /*dest += drow*/ y++) {\r\n\t\t\tfor(byte *dest = helper-\u003eMapUp(x4, y, w4), *end = dest + w4; dest \u003c end; dest += 4, src += 4) {\r\n\t\t\t\tdest[0] = src[2];\r\n\t\t\t\tdest[1] = src[1];\r\n\t\t\t\tdest[2] = src[0];\r\n\t\t\t\tdest[3] = src[3];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tint x3 = 3 * x, w3 = 3 * w;\r\n\t//\tbyte *dest = helper-\u003edest.GetUpScan(y) + 3 * x;\r\n\t\tconst byte *src = (const byte *)helper-\u003ebuffer.Begin();\r\n\t//\tunsigned srow = sizeof(uint32) * w; //, drow = helper-\u003edest.GetUpRowBytes();\r\n\t\tfor(; h; h--, /*src += srow,*/ /*dest += drow*/ y++) {\r\n\t\t\tfor(byte *dest = helper-\u003eMapUp(x3, y, w3), *end = dest + w3; dest \u003c end; dest += 3, src += 4) {\r\n\t\t\t\tdest[0] = src[2];\r\n\t\t\t\tdest[1] = src[1];\r\n\t\t\t\tdest[2] = src[0];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic void putContig1(TIFFRGBAImage *img, tif_uint32 *cp,\r\n\ttif_uint32 x, tif_uint32 y, tif_uint32 w, tif_uint32 h,\r\n\ttif_int32 fromskew, tif_int32 toskew, byte *pp)\r\n{\r\n\tTIFRaster::Data *helper = (TIFRaster::Data *)img;\r\n//\tSize size = helper-\u003esize;\r\n\tint iw = toskew + w;\r\n\tbool keep_y = (iw \u003e= 0);\r\n\tint x8 = x \u003e\u003e 3;\r\n\tint w8 = ((x + w + 7) \u003e\u003e 3) - x8;\r\n\tbool read = !!((x | w) \u0026 7) \u0026\u0026 (int)w \u003c helper-\u003esize.cx;\r\n//\tbyte *dest = helper-\u003edest.GetUpScan(y) + (x \u003e\u003e 3);\r\n//\tint drow = (keep_y ? helper-\u003edest.GetUpRowBytes() : -helper-\u003edest.GetUpRowBytes());\r\n\tint drow = keep_y ? 1 : -1;\r\n\tconst byte *src = pp;\r\n\tint srow = (fromskew + w - 1) / helper-\u003eskewfac + 1;\r\n\tfor(; h; h--, y += drow /*dest += drow*/, src += srow)\r\n\t\tBltPack11(helper-\u003eMapUp(x8, y, w8), src, (byte)(x \u0026 7), w);\r\n}\r\n\r\nstatic void putContig2(TIFFRGBAImage *img, tif_uint32 *cp,\r\n\ttif_uint32 x, tif_uint32 y, tif_uint32 w, tif_uint32 h,\r\n\ttif_int32 fromskew, tif_int32 toskew, byte *pp)\r\n{\r\n\tTIFRaster::Data *helper = (TIFRaster::Data *)img;\r\n//\tSize size = helper-\u003esize;\r\n\tint iw = toskew + w;\r\n\tbool keep_y = (iw \u003e= 0);\r\n\tint x4 = x \u003e\u003e 2;\r\n\tint w4 = ((x + w + 3) \u003e\u003e 2) - x4;\r\n\tbool read = !!((x | w) \u0026 3) \u0026\u0026 (int)w \u003c helper-\u003esize.cx;\r\n//\tbyte *dest = helper-\u003edest.GetUpScan(y) + (x \u003e\u003e 3);\r\n//\tint drow = (keep_y ? helper-\u003edest.GetUpRowBytes() : -helper-\u003edest.GetUpRowBytes());\r\n\tint drow = keep_y ? 1 : -1;\r\n\tconst byte *src = pp;\r\n\tint srow = (fromskew + w - 1) / helper-\u003eskewfac + 1;\r\n\tfor(; h; h--, y += drow /*dest += drow*/, src += srow)\r\n\t\tBltPack22(helper-\u003eMapUp(x4, y, w4), src, (byte)(x \u0026 3), w);\r\n}\r\n\r\nstatic void putContig4(TIFFRGBAImage *img, tif_uint32 *cp,\r\n\ttif_uint32 x, tif_uint32 y, tif_uint32 w, tif_uint32 h,\r\n\ttif_int32 fromskew, tif_int32 toskew, byte *pp)\r\n{\r\n\tTIFRaster::Data *helper = (TIFRaster::Data *)img;\r\n//\tSize size = helper-\u003esize; //dest.GetSize();\r\n\tint iw = toskew + w;\r\n\tbool keep_y = (iw \u003e= 0);\r\n\tint x2 = x \u003e\u003e 1;\r\n\tint w2 = ((x + w + 1) \u003e\u003e 1) - x2;\r\n\tbool read = !!((x | w) \u0026 1) \u0026\u0026 (int)w \u003c helper-\u003esize.cx;\r\n//\tbyte *dest = helper-\u003edest.GetUpScan(y) + (x \u003e\u003e 1);\r\n\tbool shift = (x \u0026 1);\r\n//\tint drow = (keep_y ? helper-\u003edest.GetUpRowBytes() : -helper-\u003edest.GetUpRowBytes());\r\n\tint drow = (keep_y ? 1 : -1);\r\n\tconst byte *src = pp;\r\n\tint srow = (fromskew + w - 1) / helper-\u003eskewfac + 1;\r\n\tfor(; h; h--, y /*dest*/ += drow, src += srow)\r\n\t\tBltPack44(helper-\u003eMapUp(x2, y, w2), src, shift, w);\r\n}\r\n\r\nstatic void putContig8(TIFFRGBAImage *img, tif_uint32 *cp,\r\n\ttif_uint32 x, tif_uint32 y, tif_uint32 w, tif_uint32 h,\r\n\ttif_int32 fromskew, tif_int32 toskew, byte *pp)\r\n{\r\n\tTIFRaster::Data *helper = (TIFRaster::Data *)img;\r\n//\tSize size = helper-\u003esize;\r\n\tint iw = toskew + w;\r\n\tbool keep_y = (iw \u003e= 0);\r\n//\tbyte *dest = helper-\u003edest.GetUpScan(y) + x;\r\n//\tint drow = (keep_y ? helper-\u003edest.GetUpRowBytes() : -helper-\u003edest.GetUpRowBytes());\r\n\tint drow = (keep_y ? 1 : -1);\r\n\tconst byte *src = pp;\r\n\tint srow = (fromskew + w - 1) / helper-\u003eskewfac + 1;\r\n\tfor(; h; h--, y /*dest*/ += drow, src += srow)\r\n\t\tmemcpy(helper-\u003eMapUp(x, y, w), src, w);\r\n}\r\n\r\nstatic void putContigRGB(TIFFRGBAImage *img, tif_uint32 *cp, tif_uint32 x, tif_uint32 y, tif_uint32 w, tif_uint32 h,\r\n\ttif_int32 fromskew, tif_int32 toskew, byte *pp)\r\n{\r\n\tTIFRaster::Data *helper = (TIFRaster::Data *)img;\r\n//\tSize size = helper-\u003esize;\r\n\tint iw = toskew + w;\r\n\tint wh = w * h;\r\n\tif(wh \u003e helper-\u003ebuffer.GetCount())\r\n\t\thelper-\u003ebuffer.SetCount(wh);\r\n\tbool keep_y = (iw \u003e= 0);\r\n\thelper-\u003econtig(img, (tif_uint32 *)(keep_y ? \u0026helper-\u003ebuffer[0] : \u0026helper-\u003ebuffer[0] + w * (h - 1)),\r\n\t\t0, 0, w, h, fromskew, keep_y ? 0 : -2 * (int)w, pp);\r\n\tpackTileRGB(helper, x, keep_y ? y : y - h + 1, w, h);\r\n}\r\n\r\nstatic void putSeparate(TIFFRGBAImage *img, tif_uint32 *cp,\r\n\ttif_uint32 x, tif_uint32 y, tif_uint32 w, tif_uint32 h,\r\n\ttif_int32 fromskew, tif_int32 toskew, byte *r, byte *g, byte *b, byte *a)\r\n{\r\n\tTIFRaster::Data *helper = (TIFRaster::Data *)img;\r\n//\tSize size = helper-\u003esize;\r\n\tint wh = w * h;\r\n\tif(wh \u003e helper-\u003ebuffer.GetCount())\r\n\t\thelper-\u003ebuffer.SetCount(wh);\r\n\tint iw = toskew + w;\r\n\tbool keep_y = (iw \u003e= 0);\r\n\thelper-\u003eseparate(img, (tif_uint32 *)(keep_y ? \u0026helper-\u003ebuffer[0] : \u0026helper-\u003ebuffer[0] + w * (h - 1)),\r\n\t\t0, 0, w, h, fromskew, keep_y ? 0 : -2 * (int)w, r, g, b, a);\r\n\tpackTileRGB(helper, x, keep_y ? y : y - h + 1, w, h);\r\n}\r\n\r\nbyte *TIFRaster::Data::MapUp(int x, int y, int count)\r\n{\r\n\treturn MapDown(x, size.cy - 1 - y, count);\r\n}\r\n\r\nbyte *TIFRaster::Data::MapDown(int x, int y, int count)\r\n{\r\n\treturn \u0026imagebuf[row_bytes * y] + x;\r\n}\r\n\r\nvoid TIFRaster::Data::Warning(const char *fn, const char *fmt, va_list ap)\r\n{\r\n\tif(!memcmp(fn, \"tiff@\", 5) \u0026\u0026 IsDigit(fn[5])) {\r\n\t\tint addr = stou(fn + 5);\r\n\t\tif(addr != -1 \u0026\u0026 addr != 0) {\r\n//\t\t\tTIFRaster::Data\u0026 wrapper = *reinterpret_cast\u003cTIFRaster::Data *\u003e(addr);\r\n\t\t\tLLOG(\"TIF warning: \" \u003c\u003c VFormat(fmt, ap));\r\n//\t\t\tRLOG(\"TiffWrapper::Warning: \" \u003c\u003c wrapper.errors);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid TIFRaster::Data::Error(const char *fn, const char *fmt, va_list ap)\r\n{\r\n\tif(!memcmp(fn, \"tiff@\", 5) \u0026\u0026 IsDigit(fn[5])) {\r\n\t\tint addr = stou(fn + 5);\r\n\t\tif(addr != -1 \u0026\u0026 addr != 0) {\r\n//\t\t\tData\u0026 wrapper = *reinterpret_cast\u003cData *\u003e(addr);\r\n\t\t\tLLOG(\"TIF error: \" \u003c\u003c VFormat(fmt, ap));\r\n//\t\t\tRLOG(\"TiffWrapper::Error: \" \u003c\u003c wrapper.errors);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nTIFRaster::Data::Data(Stream\u0026 stream)\r\n: stream(stream)\r\n{\r\n\ttiff = NULL;\r\n\tpage_index = 0;\r\n\tcache_size = 0;\r\n\tpage_open = false;\r\n\tpage_fetched = false;\r\n\tpage_error = false;\r\n}\r\n\r\nTIFRaster::Data::~Data()\r\n{\r\n\tif(tiff) {\r\n\t\tif(page_open)\r\n\t\t\tTIFFRGBAImageEnd(this);\r\n\t\tTIFFClose(tiff);\r\n\t}\r\n}\r\n\r\nbool TIFRaster::Data::Create()\r\n{\r\n\tTIFFSetErrorHandler(NULL);\r\n\tTIFFSetErrorHandlerExt(NULL);\r\n\tTIFFSetWarningHandler(NULL);\r\n\tTIFFSetWarningHandlerExt(NULL);\r\n\r\n\ttiff = TIFFStreamOpen(\"tiff@\" + Format64((intptr_t)this), \"r\", \u0026stream);\r\n\tif(!tiff)\r\n\t\treturn false;\r\n\r\n\tint count = TIFFNumberOfDirectories(tiff);\r\n\tif(count \u003c= 0)\r\n\t\treturn false;\r\n\tfor(int i = 0; i \u003c count; i++) {\r\n\t\tPage\u0026 page = pages.Add();\r\n\t\tTIFFSetDirectory(tiff, i);\r\n\t\tTIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, \u0026page.width);\r\n\t\tTIFFGetField(tiff, TIFFTAG_IMAGELENGTH, \u0026page.height);\r\n\t\tfloat xres, yres;\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_XRESOLUTION, \u0026xres);\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_YRESOLUTION, \u0026yres);\r\n\t\tuint16 resunit;\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_RESOLUTIONUNIT, \u0026resunit);\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_BITSPERSAMPLE, \u0026page.bits_per_sample);\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLESPERPIXEL, \u0026page.samples_per_pixel);\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_PHOTOMETRIC, \u0026page.photometric);\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_ORIENTATION, \u0026page.orientation);\r\n\t\tdouble dots_per_unit = (resunit == RESUNIT_INCH ? 600.0 : resunit == RESUNIT_CENTIMETER\r\n\t\t\t? 600.0 / 2.54 : 0);\r\n\t\tpage.dot_size.cx = (xres ? fround(page.width * dots_per_unit / xres) : 0);\r\n\t\tpage.dot_size.cy = (yres ? fround(page.height * dots_per_unit / yres) : 0);\r\n\t\tpage.alpha = false;\r\n\t\tuint16 extrasamples, *sampletypes;\r\n\t\tTIFFGetFieldDefaulted(tiff, TIFFTAG_EXTRASAMPLES, \u0026extrasamples, \u0026sampletypes);\r\n\t\tfor(int e = 0; e \u003c extrasamples; e++)\r\n\t\t\tif(sampletypes[e] == EXTRASAMPLE_ASSOCALPHA) {\r\n\t\t\t\tpage.alpha = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\r\n\t\tif(i == 0) {\r\n\t\t\tconst word TIFFTAG_GEOPIXELSCALE = 33550,\r\n\t\t\t           TIFFTAG_GEOTIEPOINTS = 33922,\r\n\t\t\t           TIFFTAG_GEOTRANSMATRIX = 34264,\r\n\t\t\t           TIFFTAG_GEOKEYDIRECTORY = 34735,\r\n\t\t\t           TIFFTAG_GEODOUBLEPARAMS = 34736,\r\n\t\t\t           TIFFTAG_GEOASCIIPARAMS = 34737;\r\n\r\n\t\t\tword count = 0;\r\n\t\t\tword *geokeys = nullptr;\r\n\t\t\tbool pixel_is_area = true; // Default is true, usually only DTM/DEM use 'RasterPixelIsPoint' and generally include the GeoKey in such case\r\n\r\n\t\t\tint dpc = 0;\r\n\t\t\tdouble *doubleparams = 0;\r\n\r\n\t\t\tint apc = 0;\r\n\t\t\tchar *asciiparams = 0;\r\n\r\n\t\t\tTIFFGetField(tiff, TIFFTAG_GEODOUBLEPARAMS, \u0026dpc, \u0026doubleparams);\r\n\t\t\tTIFFGetField(tiff, TIFFTAG_GEOASCIIPARAMS, \u0026apc, \u0026asciiparams);\r\n\r\n\t\t\tif(TIFFGetField(tiff, TIFFTAG_GEOKEYDIRECTORY, \u0026count, \u0026geokeys) \u0026\u0026\r\n\t\t\t\tcount \u003e= 4 \u0026\u0026 (count % 4) == 0 \u0026\u0026 geokeys[0] == 1)\r\n\t\t\t\tfor(int i = 4; i + 3 \u003c count; i += 4) {\r\n\t\t\t\t\tconst word GTRasterTypeGeoKey = 1025,\r\n\t\t\t\t\t           RasterPixelIsArea = 1,\r\n\t\t\t\t\t           GeographicTypeGeoKey = 2048,\r\n\t\t\t\t\t           ProjectedCSTypeGeoKey = 3072;\r\n\r\n\t\t\t\t\tword value = geokeys[i + 3];\r\n\r\n\t\t\t\t\tswitch(geokeys[i]) {\r\n\t\t\t\t\tcase GTRasterTypeGeoKey:\r\n\t\t\t\t\t\tpixel_is_area = value == RasterPixelIsArea;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase GeographicTypeGeoKey:\r\n\t\t\t\t\tcase ProjectedCSTypeGeoKey:\r\n\t\t\t\t\t\tattr.GetAdd(\"epsg\") = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tswitch(geokeys[i+1]){ // by type\r\n\t\t\t\t\t\tcase TIFFTAG_GEOASCIIPARAMS:\r\n\t\t\t\t\t\t\tif(geokeys[i+3]\u003c=apc) attr.GetAdd(Format(\"GK%d\",geokeys[i])) = Value(String(\u0026asciiparams[geokeys[i+3]],geokeys[i+2]));\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase TIFFTAG_GEODOUBLEPARAMS:\r\n\t\t\t\t\t\t\tif(geokeys[i+3]\u003c=dpc) attr.GetAdd(Format(\"GK%d\",geokeys[i])) = Value(doubleparams[geokeys[i+3]]);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tattr.GetAdd(Format(\"GK%d\",geokeys[i])) = Value(geokeys[i+3]);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\tdouble geomatrix[6];\r\n\t        geomatrix[0] = 0.0;\r\n\t        geomatrix[1] = 1.0;\r\n\t        geomatrix[2] = 0.0;\r\n\t        geomatrix[3] = 0.0;\r\n\t        geomatrix[4] = 0.0;\r\n\t        geomatrix[5] = 1.0;\r\n\t        \r\n\t        auto AdjustMatrixOrientation = [\u0026](double dx, double dy) {\r\n\t\t\t\tgeomatrix[0] += (geomatrix[1] * dx + geomatrix[2] * dy);\r\n\t\t\t\tgeomatrix[3] += (geomatrix[4] * dx + geomatrix[5] * dy);\r\n\t\t\t\tif(dx!=0){\r\n\t\t\t\t\tgeomatrix[1] = -geomatrix[1];\r\n\t\t\t\t\tgeomatrix[4] = -geomatrix[4];\r\n\t\t\t\t}\r\n\t\t\t\tif(dy!=0){\r\n\t\t\t\t\tgeomatrix[2] = -geomatrix[2];\r\n\t\t\t\t\tgeomatrix[5] = -geomatrix[5];\r\n\t\t\t\t}\r\n\t        };\r\n\t        \r\n\t\t\tauto NormalizeOrientation = [\u0026] {\r\n\t\t\t\tif(!pixel_is_area) {\r\n\t\t\t\t\tgeomatrix[0] -= (geomatrix[1] * 0.5 + geomatrix[2] * 0.5);\r\n\t\t\t\t\tgeomatrix[3] -= (geomatrix[4] * 0.5 + geomatrix[5] * 0.5);\r\n\t\t\t\t}\r\n\t\t\t\tif(page.orientation\u003e=5){\r\n\t\t\t\t\tSwap(geomatrix[1],geomatrix[2]);\r\n\t\t\t\t\tSwap(geomatrix[4],geomatrix[5]);\r\n\t\t\t\t}\r\n\t\t\t\tswitch(page.orientation){\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(page.width, 0);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(page.width, page.height);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(0, page.height);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 6:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(page.height, 0);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 7:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(page.height, page.width);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 8:\r\n\t\t\t\t\t\tAdjustMatrixOrientation(0, page.width);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t// TIFF orientations:\r\n\t\t\t\t// 1 = FLIP_MIRROR_VERT,\r\n\t\t\t\t// 2 = FLIP_ROTATE_180,\r\n\t\t\t\t// 3 = FLIP_MIRROR_HORZ,\r\n\t\t\t\t// 4 = FLIP_NONE,\r\n\t\t\t\t// 5 = FLIP_ROTATE_CLOCKWISE,\r\n\t\t\t\t// 6 = FLIP_TRANSPOSE,\r\n\t\t\t\t// 7 = FLIP_ROTATE_ANTICLOCKWISE,\r\n\t\t\t\t// 8 = FLIP_TRANSVERSE,\r\n\t\t\t};\r\n\t    \r\n\t        double  *data;\r\n\t        auto FinishMatrix = [\u0026] {\r\n\t\t\t\tValueArray va;\r\n\t\t\t\tfor(int i = 0; i \u003c 6; i++)\r\n\t\t\t\t\tva \u003c\u003c geomatrix[i];\r\n\t\t\t\tattr.GetAdd(\"geo_matrix\") = va;\r\n\t        };\r\n\t        \r\n\t\t\tif(TIFFGetField(tiff, TIFFTAG_GEOTRANSMATRIX, \u0026count, \u0026data) \u0026\u0026 count == 16) {\r\n\t\t\t\tgeomatrix[0] = data[3];\r\n\t\t\t\tgeomatrix[1] = data[0];\r\n\t\t\t\tgeomatrix[2] = data[1];\r\n\t\t\t\tgeomatrix[3] = data[7];\r\n\t\t\t\tgeomatrix[4] = data[4];\r\n\t\t\t\tgeomatrix[5] = data[5];\r\n\r\n\t\t\t\tNormalizeOrientation();\r\n\t\t\t\tFinishMatrix();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\tif(TIFFGetField(tiff, TIFFTAG_GEOTIEPOINTS, \u0026count, \u0026data) \u0026\u0026 count \u003e= 6) {\r\n\t\t\t\tif(count\u003e=18){ // 3 tiepoints needed for Xform2D::Map()\r\n\t\t\t\t\tfor(int t=0; t\u003ccount; t+=6){\r\n\t\t\t\t\t\tif(page.orientation\u003e=5) Swap(data[t + 0], data[t + 1]);\r\n\t\t\t\t\t\tswitch(page.orientation){\r\n\t\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\t\tdata[t + 0] = page.width - data[t + 0];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\t\tdata[t + 0] = page.width - data[t + 0];\r\n\t\t\t\t\t\t\t\tdata[t + 1] = page.height - data[t + 1];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\t\tdata[t + 1] = page.height - data[t + 1];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 5:\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 6:\r\n\t\t\t\t\t\t\t\tdata[t + 0] = page.height - data[t + 0];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 7:\r\n\t\t\t\t\t\t\t\tdata[t + 0] = page.height - data[t + 0];\r\n\t\t\t\t\t\t\t\tdata[t + 1] = page.width - data[t + 1];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 8:\r\n\t\t\t\t\t\t\t\tdata[t + 1] = page.width - data[t + 1];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tXform2D xf = Xform2D::Map(Pointf(data[0],data[1]),Pointf(data[6+0],data[6+1]),Pointf(data[12+0],data[12+1]),\r\n\t\t\t\t\t\t\t\t\t\t\t\tPointf(data[3],data[4]),Pointf(data[6+3],data[6+4]),Pointf(data[12+3],data[12+4]));\r\n\r\n\t\t\t\t\tgeomatrix[0] = xf.t.x;\r\n\t\t\t\t\tgeomatrix[1] = xf.x.x;\r\n\t\t\t\t\tgeomatrix[2] = xf.y.x;\r\n\t\t\t\t\tgeomatrix[3] = xf.t.y;\r\n\t\t\t\t\tgeomatrix[4] = xf.x.y;\r\n\t\t\t\t\tgeomatrix[5] = xf.y.y;\r\n\r\n\t\t\t\t\tif(!pixel_is_area) {\r\n\t\t\t\t\t\tgeomatrix[0] -= (geomatrix[1] * 0.5 + geomatrix[2] * 0.5);\r\n\t\t\t\t\t\tgeomatrix[3] -= (geomatrix[4] * 0.5 + geomatrix[5] * 0.5);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tFinishMatrix();\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tdouble x = data[0];\r\n\t\t\t\t\tdouble y = data[1];\r\n\t\t\t\t\tdouble e = data[3];\r\n\t\t\t\t\tdouble n = data[4];\r\n\r\n\t\t\t\t\tif(TIFFGetField(tiff, TIFFTAG_GEOPIXELSCALE, \u0026count, \u0026data) \u0026\u0026 count \u003e= 2 \u0026\u0026 data[0] \u0026\u0026 data[1]) {\r\n\t\t\t\t\t\tdouble dx = data[0];\r\n\t\t\t\t\t\tdouble dy = -abs(data[1]);\r\n\r\n\t\t\t\t\t\tgeomatrix[0] = e - x * dx;\r\n\t\t\t\t\t\tgeomatrix[1] = dx;\r\n\t\t\t\t\t\tgeomatrix[2] = 0;\r\n\t\t\t\t\t\tgeomatrix[3] = n - y * dy;\r\n\t\t\t\t\t\tgeomatrix[4] = 0;\r\n\t\t\t\t\t\tgeomatrix[5] = dy;\r\n\r\n\t\t\t\t\t\tNormalizeOrientation();\r\n\t\t\t\t\t\tFinishMatrix();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(TIFFGetField(tiff, 42113, \u0026count, \u0026data) \u0026\u0026 // TIFFTAG_GDAL_NODATA = 42113\r\n\t\t\t\tcount \u003e= 1){\r\n\t\t\t\t\tattr.GetAdd(\"nodata\") = String((const char*)data, count);\r\n\t\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\treturn SeekPage(0);\r\n}\r\n\r\nbool TIFRaster::Data::SeekPage(int pgx)\r\n{\r\n\tif(page_open) {\r\n\t\tTIFFRGBAImageEnd(this);\r\n\t\tpage_open = false;\r\n\t}\r\n\r\n\tASSERT(pgx \u003e= 0 \u0026\u0026 pgx \u003c pages.GetCount());\r\n\tpage_index = pgx;\r\n\tpage_error = false;\r\n\tTIFFSetDirectory(tiff, page_index);\r\n\r\n\tchar emsg[1024];\r\n\tif(!TIFFRGBAImageBegin(this, tiff, 0, emsg)) {\r\n\t\tTIFFError(TIFFFileName(tiff), \"%s\", emsg);\r\n\t\tpage_error = true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tpage_open = true;\r\n\tconst Page\u0026 page = pages[page_index];\r\n\r\n\tsize = Size(page.width, page.height);\r\n\tif(isContig) {\r\n\t\tcontig = put.contig;\r\n\t\tput.contig = putContigRGB;\r\n\t}\r\n\telse {\r\n\t\tseparate = put.separate;\r\n\t\tput.separate = putSeparate;\r\n\t}\r\n\t\r\n\tattr.GetAdd(\"BITSPERSAMPLE\") = page.bits_per_sample;\r\n\tattr.GetAdd(\"SAMPLESPERPIXEL\") = page.samples_per_pixel;\r\n\tattr.GetAdd(\"PHOTOMETRIC\") = page.photometric;\r\n\tattr.GetAdd(\"tiff_orientation\") = Value((int)page.orientation);\r\n\r\n\talpha = page.alpha;\r\n\tif(alpha) {\r\n\t\tformat.Set32le(0xFF \u003c\u003c 16, 0xFF \u003c\u003c 8, 0xFF, 0xFF \u003c\u003c 24);\r\n\t\tbpp = 32;\r\n\t}\r\n\telse {\r\n\t\tformat.Set24le(0xFF \u003c\u003c 16, 0xFF \u003c\u003c 8, 0xFF);\r\n\t\tbpp = 24;\r\n\t}\r\n\tpalette_count = 0;\r\n\tif(isContig\t\u0026\u0026 (photometric == PHOTOMETRIC_PALETTE\r\n\t|| photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK)\r\n\t\u0026\u0026 (bitspersample == 1 || bitspersample == 2 || bitspersample == 4 || bitspersample == 8)) {\r\n\t\tbpp = 8;\r\n\t\ttif_uint32 **ppal = (photometric == PHOTOMETRIC_PALETTE ? PALmap : BWmap);\r\n\t\tASSERT(ppal);\r\n//\t\tbyte rshift = 8 - img.bitspersample;\r\n\t\tpalette_count = 1 \u003c\u003c min\u003cint\u003e(bitspersample, 8);\r\n\t\tbyte mask = (1 \u003c\u003c bitspersample) - 1;\r\n\t\tint part_last = 8 / bitspersample - 1;\r\n\t\tint i;\r\n\t\tfor(i = 0; i \u003c= mask; i++) {\r\n\t\t\tuint32 rgba = ppal[i][part_last];\r\n\t\t\tpalette[i].r = (byte)TIFFGetR(rgba);\r\n\t\t\tpalette[i].g = (byte)TIFFGetG(rgba);\r\n\t\t\tpalette[i].b = (byte)TIFFGetB(rgba);\r\n\t\t\tpalette[i].a = 255;\r\n\t\t}\r\n\t\tput.contig = putContig8;\r\n\t\tswitch(bitspersample) {\r\n\t\tcase 1: bpp = 1; put.contig = putContig1; format.Set1mf(); break;\r\n\t\tcase 2: bpp = 2; put.contig = putContig2; format.Set2mf(); break;\r\n\t\tcase 4: bpp = 4; put.contig = putContig4; format.Set4mf(); break;\r\n\t\tcase 8: format.Set8(); break;\r\n\t\tdefault: NEVER();\r\n\t\t}\r\n\t\tskewfac = 8 / bitspersample;\r\n\t}\r\n\trow_bytes = (bpp * width + 31) \u003e\u003e 5 \u003c\u003c 2;\r\n\r\n\tpage_fetched = false;\r\n\treturn true;\r\n}\r\n\r\nbool TIFRaster::Data::FetchPage()\r\n{\r\n\tif(page_error)\r\n\t\treturn false;\r\n\tif(page_fetched)\r\n\t\treturn true;\r\n\r\n\tcache_size = 0;\r\n\trows.Clear();\r\n\tint64 bytes = row_bytes * (int64)height;\r\n\timagebuf.SetCount(size.cy * row_bytes, 0);\r\n\treq_orientation = pages[page_index].orientation;\r\n\r\n\tbool res = TIFFRGBAImageGet(this, 0, width, height);\r\n\tTIFFRGBAImageEnd(this);\r\n\tpage_open = false;\r\n\r\n\tpage_fetched = true;\r\n\treturn true;\r\n}\r\n\r\nRaster::Info TIFRaster::Data::GetInfo()\r\n{\r\n\tconst Page\u0026 page = pages[page_index];\r\n\tRaster::Info out;\r\n\tout.kind = (page.alpha ? IMAGE_ALPHA : IMAGE_OPAQUE);\r\n\tout.bpp = bpp;\r\n\tout.colors = 0;\r\n\tout.dots = page.dot_size;\r\n\tout.hotspot = Null;\r\n\tconst int info_orientation[] = { FLIP_NONE, FLIP_MIRROR_VERT, FLIP_ROTATE_180, FLIP_MIRROR_HORZ, FLIP_NONE, FLIP_ROTATE_CLOCKWISE, FLIP_TRANSPOSE, FLIP_ROTATE_ANTICLOCKWISE, FLIP_TRANSVERSE, FLIP_NONE}; // Map from TIFFTAG_ORIENTATION to U++ orientation\r\n\tout.orientation = info_orientation[min((int)page.orientation,9)];\r\n\treturn out;\r\n}\r\n\r\nRaster::Line TIFRaster::Data::GetLine(int line, Raster *raster)\r\n{\r\n\tif(!page_error \u0026\u0026 !page_fetched)\r\n\t\tFetchPage();\r\n\tif(page_error) {\r\n\t\tbyte *tmp = new byte[row_bytes];\r\n\t\tmemset(tmp, 0, row_bytes);\r\n\t\treturn Raster::Line(tmp, raster, true);\r\n\t}\r\n\tif(!imagebuf.IsEmpty())\r\n\t\treturn Raster::Line(\u0026imagebuf[row_bytes * line], raster, false);\r\n\tconst byte *data = MapDown(0, line, row_bytes);\r\n\tbyte *tmp = new byte[row_bytes];\r\n\tmemcpy(tmp, data, row_bytes);\r\n\treturn Raster::Line(tmp, raster, true);\r\n}\r\n\r\nTIFRaster::TIFRaster()\r\n{\r\n}\r\n\r\nTIFRaster::~TIFRaster()\r\n{\r\n}\r\n\r\nbool TIFRaster::Create()\r\n{\r\n\tdata = new Data(GetStream());\r\n\treturn data-\u003eCreate();\r\n}\r\n\r\nSize TIFRaster::GetSize()\r\n{\r\n\treturn data-\u003esize;\r\n}\r\n\r\nRaster::Info TIFRaster::GetInfo()\r\n{\r\n\treturn data-\u003eGetInfo();\r\n}\r\n\r\nRaster::Line TIFRaster::GetLine(int line)\r\n{\r\n\treturn data-\u003eGetLine(line, this);\r\n}\r\n\r\nint TIFRaster::GetPaletteCount()\r\n{\r\n\treturn data-\u003epalette_count;\r\n}\r\n\r\nconst RGBA *TIFRaster::GetPalette()\r\n{\r\n\treturn data-\u003epalette;\r\n}\r\n\r\nconst RasterFormat *TIFRaster::GetFormat()\r\n{\r\n\treturn \u0026data-\u003eformat;\r\n}\r\n\r\nint TIFRaster::GetPageCount()\r\n{\r\n\treturn data-\u003epages.GetCount();\r\n}\r\n\r\nint TIFRaster::GetActivePage() const\r\n{\r\n\treturn data-\u003epage_index;\r\n}\r\n\r\nvoid TIFRaster::SeekPage(int n)\r\n{\r\n\tdata-\u003eSeekPage(n);\r\n}\r\n\r\nValue TIFRaster::GetMetaData(String id)\r\n{\r\n\treturn data-\u003eattr.Get(id, Value());\r\n}\r\n\r\nvoid TIFRaster::EnumMetaData(Vector\u003cString\u003e\u0026 id_list)\r\n{\r\n\tid_list = clone(data-\u003eattr.GetKeys());\r\n}\r\n\r\nclass TIFEncoder::Data {\r\npublic:\r\n\tData(Stream\u0026 stream, RasterFormat\u0026 format);\r\n\t~Data();\r\n\r\n\tvoid             Start(Size size, Size dots, int bpp, const RGBA *palette);\r\n\tvoid             WriteLineRaw(const byte *line);\r\n\r\nprivate:\r\n\tStream\u0026          stream;\r\n\tTIFF             *tiff;\r\n\tSize             size;\r\n\tint              bpp;\r\n\tconst RGBA       *palette;\r\n\tVector\u003cbyte\u003e     rowbuf;\r\n\tint              linebytes;\r\n\tRasterFormat\u0026    format;\r\n\tint              line;\r\n\r\n\tstatic tsize_t   ReadStream(thandle_t fd, tdata_t buf, tsize_t size);\r\n\tstatic tsize_t   WriteStream(thandle_t fd, tdata_t buf, tsize_t size);\r\n\tstatic toff_t    SeekStream(thandle_t fd, toff_t off, int whence);\r\n\tstatic int       CloseStream(thandle_t fd);\r\n\tstatic toff_t    SizeStream(thandle_t fd);\r\n\tstatic int       MapStream(thandle_t fd, tdata_t *pbase, toff_t *psize);\r\n\tstatic void      UnmapStream(thandle_t fd, tdata_t base, toff_t size);\r\n};\r\n\r\nTIFEncoder::Data::Data(Stream\u0026 stream, RasterFormat\u0026 format)\r\n: stream(stream), format(format)\r\n{\r\n\ttiff = NULL;\r\n}\r\n\r\nTIFEncoder::Data::~Data()\r\n{\r\n\tif(tiff) TIFFClose(tiff);\r\n}\r\n\r\ntsize_t TIFEncoder::Data::ReadStream(thandle_t fd, tdata_t buf, tsize_t size)\r\n{\r\n\tData\u0026 wrapper = *reinterpret_cast\u003cData *\u003e(fd);\r\n\tASSERT(wrapper.stream.IsOpen());\r\n//\tRLOG(\"TiffStream::ReadStream \u0026 \" \u003c\u003c (int)wrapper.stream.GetPos() \u003c\u003c \", count = \" \u003c\u003c size\r\n//\t\t\u003c\u003c \", end = \" \u003c\u003c (int)(wrapper.stream.GetPos() + size));\r\n\treturn wrapper.stream.Get(buf, size);\r\n\treturn 0;\r\n}\r\n\r\ntsize_t TIFEncoder::Data::WriteStream(thandle_t fd, tdata_t buf, tsize_t size)\r\n{\r\n\tData\u0026 wrapper = *reinterpret_cast\u003cData *\u003e(fd);\r\n\tASSERT(wrapper.stream.IsOpen());\r\n//\tRLOG(\"TIFRaster::Data::WriteStream \u0026 \" \u003c\u003c (int)wrapper.stream.GetPos() \u003c\u003c \", count = \" \u003c\u003c (int)size\r\n//\t\t\u003c\u003c \", end = \" \u003c\u003c (int)(wrapper.stream.GetPos() + size));\r\n\twrapper.stream.Put(buf, size);\r\n\treturn size;\r\n}\r\n\r\ntoff_t TIFEncoder::Data::SeekStream(thandle_t fd, toff_t off, int whence)\r\n{\r\n\tData\u0026 wrapper = *reinterpret_cast\u003cData *\u003e(fd);\r\n\tASSERT(wrapper.stream.IsOpen());\r\n\ttoff_t size = (toff_t)wrapper.stream.GetSize();\r\n\ttoff_t destpos = (toff_t)(off + (whence == 1 ? wrapper.stream.GetPos() : whence == 2 ? size : 0));\r\n\tif(destpos \u003e size) {\r\n\t\twrapper.stream.Seek(size);\r\n\t\twrapper.stream.Put((int)0, (int)(destpos - size));\r\n\t}\r\n\telse\r\n\t\twrapper.stream.Seek(destpos);\r\n//\tRLOG(\"TIFRaster::Data::SeekStream -\u003e \" \u003c\u003c (int)off \u003c\u003c \", whence = \" \u003c\u003c whence \u003c\u003c \" -\u003e pos = \" \u003c\u003c (int)wrapper.stream.GetPos());\r\n\treturn (toff_t)wrapper.stream.GetPos();\r\n}\r\n\r\nint TIFEncoder::Data::CloseStream(thandle_t fd)\r\n{\r\n\treturn 0;\r\n}\r\n\r\ntoff_t TIFEncoder::Data::SizeStream(thandle_t fd)\r\n{\r\n\tData\u0026 wrapper = *reinterpret_cast\u003cData *\u003e(fd);\r\n\tASSERT(wrapper.stream.IsOpen());\r\n//\tRLOG(\"TIFRaster::Data::SizeStream -\u003e \" \u003c\u003c (int)wrapper.stream.GetSize());\r\n\treturn (toff_t)wrapper.stream.GetSize();\r\n}\r\n\r\nint TIFEncoder::Data::MapStream(thandle_t fd, tdata_t *pbase, toff_t *psize)\r\n{\r\n\treturn 0;\r\n}\r\n\r\nvoid TIFEncoder::Data::UnmapStream(thandle_t fd, tdata_t base, toff_t size)\r\n{\r\n}\r\n\r\nvoid TIFEncoder::Data::Start(Size sz, Size dots, int bpp_, const RGBA *palette)\r\n{\r\n\tsize = sz;\r\n\tbpp = bpp_;\r\n\tline = 0;\r\n\r\n\ttiff = TIFFClientOpen(\"tiff@\" + Format64((intptr_t)this), \"w\", reinterpret_cast\u003cthandle_t\u003e(this),\r\n\t\tReadStream, WriteStream, SeekStream, CloseStream, SizeStream, MapStream, UnmapStream);\r\n\r\n\tTIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, size.cx);\r\n\tTIFFSetField(tiff, TIFFTAG_IMAGELENGTH, size.cy);\r\n\tTIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, min\u003cint\u003e(bpp, 8));\r\n\tTIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\tTIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, bpp \u003c= 8 ? PHOTOMETRIC_PALETTE : PHOTOMETRIC_RGB);\r\n\tTIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, bpp \u003c= 8 ? 1 : bpp != 32 ? 3 : 4);\r\n\tTIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\r\n\tTIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n\tif(bpp == 32) {\r\n\t\tuint16 es = EXTRASAMPLE_ASSOCALPHA;\r\n\t\tTIFFSetField(tiff, TIFFTAG_EXTRASAMPLES, 1, \u0026es);\r\n\t}\r\n//\tTIFFSetField(tiff, TIFFTAG_REFERENCEBLACKWHITE, refblackwhite);\r\n//\tTIFFSetField(tiff, TIFFTAG_TRANSFERFUNCTION, gray);\r\n\tif(dots.cx \u0026\u0026 dots.cy) {\r\n\t\tTIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, (uint16)RESUNIT_INCH);\r\n\t\tfloat xres = float(sz.cx * 600.0 / dots.cx);\r\n\t\tTIFFSetField(tiff, TIFFTAG_XRESOLUTION, xres);\r\n\t\tfloat yres = float(sz.cy * 600.0 / dots.cy);\r\n\t\tTIFFSetField(tiff, TIFFTAG_YRESOLUTION, yres);\r\n\t}\r\n\tswitch(bpp) {\r\n\t\tcase 1: format.Set1mf(); break;\r\n\t\tcase 2: format.Set2mf(); break;\r\n\t\tcase 4: format.Set4mf(); break;\r\n\t\tcase 8: format.Set8(); break;\r\n\t\tdefault: NEVER();\r\n\t\tcase 24: format.Set24le(0xFF, 0xFF \u003c\u003c 8, 0xFF \u003c\u003c 16); break;\r\n\t\tcase 32: format.Set32le(0xFF, 0xFF \u003c\u003c 8, 0xFF \u003c\u003c 16, 0xFF \u003c\u003c 24); break;\r\n\t}\r\n\tif(bpp \u003c= 8) {\r\n\t\tuint16 rpal[256], gpal[256], bpal[256];\r\n\t\tint c = 1 \u003c\u003c bpp;\r\n\t\tmemset(rpal, 0, sizeof(uint16) * c);\r\n\t\tmemset(gpal, 0, sizeof(uint16) * c);\r\n\t\tmemset(bpal, 0, sizeof(uint16) * c);\r\n\t\tfor(int i = 0; i \u003c c; i++) {\r\n\t\t\trpal[i] = palette[i].r \u003c\u003c 8;\r\n\t\t\tgpal[i] = palette[i].g \u003c\u003c 8;\r\n\t\t\tbpal[i] = palette[i].b \u003c\u003c 8;\r\n\t\t}\r\n\t\tTIFFSetField(tiff, TIFFTAG_COLORMAP, rpal, gpal, bpal);\r\n\t}\r\n\tint rowbytes = (bpp * size.cx + 31) \u003e\u003e 5 \u003c\u003c 2;\r\n\trowbuf.SetCount(rowbytes);\r\n\tlinebytes = format.GetByteCount(size.cx);\r\n}\r\n\r\nvoid TIFEncoder::Data::WriteLineRaw(const byte *s)\r\n{\r\n\tmemcpy(rowbuf.Begin(), s, linebytes);\r\n\tTIFFWriteScanline(tiff, rowbuf.Begin(), line, 0);\r\n\tif(++line \u003e= size.cy) {\r\n\t\tTIFFClose(tiff);\r\n\t\ttiff = NULL;\r\n\t}\r\n}\r\n\r\nTIFEncoder::TIFEncoder(int bpp)\r\n: bpp(bpp)\r\n{\r\n}\r\n\r\nTIFEncoder::~TIFEncoder()\r\n{\r\n}\r\n\r\nint TIFEncoder::GetPaletteCount()\r\n{\r\n\treturn (bpp \u003e 8 ? 0 : 1 \u003c\u003c bpp);\r\n}\r\n\r\nvoid TIFEncoder::Start(Size sz)\r\n{\r\n\tdata = new Data(GetStream(), format);\r\n\tdata-\u003eStart(sz, GetDots(), bpp, bpp \u003c= 8 ? GetPalette() : NULL);\r\n}\r\n\r\nvoid TIFEncoder::WriteLineRaw(const byte *s)\r\n{\r\n\tdata-\u003eWriteLineRaw(s);\r\n}\r\n\r\n\r\nINITIALIZER(TIFRaster) {\r\n\tStreamRaster::Register\u003cTIFRaster\u003e();\r\n}\r\n\r\n}",
        "name": "tifupp.cpp",
        "path": "uppsrc/plugin/tif/tifupp.cpp",
        "url": "/github.com/ultimatepp/ultimatepp/-/blob/uppsrc/plugin/tif/tifupp.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 1164,
          "offsetAndLengths": [
            [
              12,
              16
            ]
          ],
          "preview": "\tbool res = TIFFRGBAImageGet(this, 0, width, height);\r"
        }
      ],
      "repository": {
        "name": "github.com/ultimatepp/ultimatepp",
        "url": "/github.com/ultimatepp/ultimatepp"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "6b3d261b24de290f5a80ff71b1b130210ddef3b2"
        },
        "content": "#include \"StdAfx.h\"\n\n// #define STRICT\n#include \"diblib.h\"\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e // MAX_ constants\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage\n{\n    TIFFRGBAImage tif;\n    int dibinstalled;\n};\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster);\n\nstatic void MyWarningHandler(const char *module, const char *fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void MyErrorHandler(const char *module, const char *fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF(LPCTSTR lpszPath)\n{\n    int rtn = 0;\n\n    TIFFErrorHandler eh;\n    TIFFErrorHandler wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF *tif = TIFFOpen(lpszPath, \"r\");\n    if (tif)\n    {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage *img);\n\nPVOID ReadTIFF(LPCTSTR lpszPath)\n{\n    void *pDIB = 0;\n    TIFFErrorHandler wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath))\n    {\n        TIFF *tif = TIFFOpen(lpszPath, \"r\");\n        if (tif)\n        {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg))\n            {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg))\n                {\n                    size_t npixels;\n                    uint32_t *raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster =\n                        (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n                    if (raster != NULL)\n                    {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width,\n                                             img.tif.height))\n                        {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else\n            {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg);\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster)\n{\n    void *pDIB = 0;\n    TIFFRGBAImage *img = \u0026dib-\u003etif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER bi;\n    int dwDIBSize;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if (BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled)\n    { // bilevel\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 1;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(\u0026bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed = 0;\n        pRgbq[0].rgbBlue = 0;\n        pRgbq[0].rgbGreen = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed = 255;\n        pRgbq[1].rgbBlue = 255;\n        pRgbq[1].rgbGreen = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr(\n            (BITMAPINFOHEADER *)pDIB); //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n    //  For now just always default to the RGB 32 bit form. // save as 32 bit\n    //  for simplicity\n    else if (true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/)\n    { // 24 bit color\n\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 32;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(\u0026bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        // Swap the byte order while copying\n        for (int i = 0; i \u003c sizeWords; ++i)\n        {\n            rgbDib[i].rgbRed = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n#define DECLAREContigPutFunc(name)                                             \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *pp)\n\n#define DECLARESepPutFunc(name)                                                \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *r, u_char *g, u_char *b, u_char *a)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *uraster, uint32_t w,\n                              uint32_t h);\n\n// typdef struct TIFFDibImage {\n//     TIFFRGBAImage tif;\n//     dibinstalled;\n// } TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage *dib)\n{\n    TIFFRGBAImage *img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric)\n    {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n            switch (img-\u003ebitspersample)\n            {\n                case 1:\n                    img-\u003eput.contig = putContig1bitTile;\n                    img-\u003eget = getStripContig1Bit;\n                    dib-\u003edibinstalled = true;\n                    break;\n            }\n            break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void)y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char *ucp = (u_char *)cp;\n\n    /* Convert 'w' to bytes from pixels (rounded up) */\n    w = (w + 7) / 8;\n\n    while (h-- \u003e 0)\n    {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32_t setorientation(TIFFRGBAImage *img, uint32_t h)\n{\n    TIFF *tif = img-\u003etif;\n    uint32_t y;\n\n    switch (img-\u003eorientation)\n    {\n        case ORIENTATION_BOTRIGHT:\n        case ORIENTATION_RIGHTBOT: /* XXX */\n        case ORIENTATION_LEFTBOT:  /* XXX */\n            TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n            img-\u003eorientation = ORIENTATION_BOTLEFT;\n        /* fall through... */\n        case ORIENTATION_BOTLEFT:\n            y = 0;\n            break;\n        case ORIENTATION_TOPRIGHT:\n        case ORIENTATION_RIGHTTOP: /* XXX */\n        case ORIENTATION_LEFTTOP:  /* XXX */\n        default:\n            TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n            img-\u003eorientation = ORIENTATION_TOPLEFT;\n        /* fall through... */\n        case ORIENTATION_TOPLEFT:\n            y = h - 1;\n            break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *raster, uint32_t w,\n                              uint32_t h)\n{\n    TIFF *tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16_t orientation;\n    uint32_t row, y, nrow, rowstoread;\n    uint32_t pos;\n    u_char *buf;\n    uint32_t rowsperstrip;\n    uint32_t imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32_t fromskew, toskew;\n    tstrip_t strip;\n    tsize_t stripsize;\n    u_char *braster = (u_char *)raster; // byte wide raster\n    uint32_t wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char *)_TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32_t)(orientation == ORIENTATION_TOPLEFT ? wb + wb : wb - wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0) / 8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif, row + img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset) % rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize) \u003c 0 \u0026\u0026\n            img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32_t *)(braster + y * wb), 0, y, w, nrow, fromskew,\n               toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ? -(int32_t)nrow\n                                                 : (int32_t)nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n",
        "name": "Tiffile.cpp",
        "path": "external/tiff-4.7.0/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/cnr-isti-vclab/relight/-/blob/external/tiff-4.7.0/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 112,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width,"
        }
      ],
      "repository": {
        "name": "github.com/cnr-isti-vclab/relight",
        "url": "/github.com/cnr-isti-vclab/relight"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "92089a6fff7bd5cb1bc79308359d990c1de39f5c"
        },
        "content": "////////////////////////////////////////////////////////\n//\n// GEM - Graphics Environment for Multimedia\n//\n// zmoelnig@iem.at\n//\n// Implementation file\n//\n//    Copyright (c) 1997-1999 Mark Danks.\n//    Copyright (c) Gnther Geiger.\n//    Copyright (c) 2001-2011 IOhannes m zmlnig. forum::fr::umlute. IEM. zmoelnig@iem.at\n//    For information on usage and redistribution, and for a DISCLAIMER OF ALL\n//    WARRANTIES, see the file, \"GEM.LICENSE.TERMS\" in this distribution.\n//\n/////////////////////////////////////////////////////////\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#ifdef _WIN32\n#include \u003cstdio.h\u003e // AV : in windows, this should be included before tiffio.h\n#endif /* WINVER */\n\n#ifdef HAVE_LIBTIFF\nextern \"C\"\n{\n# include \"tiffio.h\"\n}\n\n#include \u003cstring.h\u003e\n#include \"imageTIFF.h\"\n#include \"plugins/PluginFactory.h\"\n\n#include \"Gem/RTE.h\"\n\n\nusing namespace gem::plugins;\n\nREGISTER_IMAGELOADERFACTORY(\"tiff\", imageTIFF);\nREGISTER_IMAGESAVERFACTORY(\"tiff\", imageTIFF);\n\n\n#ifdef _MSC_VER\n# define vsnprintf _vsnprintf\n#endif\n\nnamespace\n{\nstatic void imageTIFF_verbosehandler(const int verbosity,\n                                     const char*module, const char*fmt, va_list ap)\n{\n  std::string result = \"[GEM:imageTIFF] \";\n  char buf[MAXPDSTRING];\n  if(module) {\n    result+=module;\n    result+=\" \";\n  }\n  vsnprintf(buf, MAXPDSTRING, fmt, ap);\n  buf[MAXPDSTRING-1]=0;\n  result+=buf;\n  logpost(0, 3+verbosity, \"%s\", result.c_str());\n}\nstatic void imageTIFF_errorhandler(const char*module, const char*fmt,\n                                   va_list ap)\n{\n  imageTIFF_verbosehandler(-2, module, fmt, ap);\n}\nstatic void imageTIFF_warnhandler(const char*module, const char*fmt,\n                                  va_list ap)\n{\n  imageTIFF_verbosehandler(0, module, fmt, ap);\n}\ntypedef struct _imageTIFF_handlers {\n  TIFFErrorHandler error, warning;\n} t_imageTIFF_handlers;\nstatic t_imageTIFF_handlers imageTIFF_sethandlers(t_imageTIFF_handlers\u0026handlers)\n{\n  t_imageTIFF_handlers newhandlers;\n  newhandlers.error = TIFFSetErrorHandler(handlers.error);\n  newhandlers.warning = TIFFSetWarningHandler(handlers.warning);\n  return newhandlers;\n}\nstatic t_imageTIFF_handlers imageTIFF_sethandlers(void)\n{\n  t_imageTIFF_handlers handlers;\n  handlers.error = TIFFSetErrorHandler(imageTIFF_errorhandler);\n  handlers.warning = TIFFSetWarningHandler(imageTIFF_warnhandler);\n  return handlers;\n}\n#define tiffhandlers_init()   t_imageTIFF_handlers tiffhandler = imageTIFF_sethandlers()\n#define tiffhandlers_cleanup() imageTIFF_sethandlers(tiffhandler)\n\n\n};\n\n/////////////////////////////////////////////////////////\n//\n// imageTIFF\n//\n/////////////////////////////////////////////////////////\n// Constructor\n//\n/////////////////////////////////////////////////////////\n\nimageTIFF :: imageTIFF(void)\n{\n  static bool firsttime=true;\n  if(firsttime) {\n    TIFFSetErrorHandler(imageTIFF_errorhandler);\n    TIFFSetWarningHandler(imageTIFF_warnhandler);\n  }\n  firsttime=false;\n}\nimageTIFF :: ~imageTIFF(void)\n{\n}\n\n/////////////////////////////////////////////////////////\n// really open the file ! (OS dependent)\n//\n/////////////////////////////////////////////////////////\nbool imageTIFF :: load(std::string filename, imageStruct\u0026result,\n                       gem::Properties\u0026props)\n{\n  tiffhandlers_init();\n  TIFF *tif = TIFFOpen(filename.c_str(), \"r\");\n  if (tif == NULL) {\n    tiffhandlers_cleanup();\n    return false;\n  }\n\n  uint32_t width, height;\n  uint16_t orientation;\n  short bits, samps;\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, \u0026width);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, \u0026height);\n  TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, \u0026bits);\n  TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, \u0026samps);\n  TIFFGetField(tif, TIFFTAG_ORIENTATION, \u0026orientation);\n\n  int npixels = width * height;\n\n  result.xsize=width;\n  result.ysize=height;\n  result.upsidedown=(ORIENTATION_BOTLEFT != orientation);\n\n  bool knownFormat = false;\n  // Is it a gray8 image?\n  if (bits == 8 \u0026\u0026 samps == 1) {\n    result.setFormat(GEM_GRAY);\n    knownFormat = true;\n  }\n  // Is it an RGB image?\n  else if (bits == 8 \u0026\u0026 samps == 3) {\n    result.setFormat(GEM_RGBA);\n    knownFormat = true;\n  }\n  // Is it an RGBA image?\n  else if (bits == 8 \u0026\u0026 samps == 4) {\n    result.setFormat(GEM_RGBA);\n    knownFormat = true;\n  }\n\n  // can we handle the raw data?\n  if (knownFormat) {\n    unsigned char *buf = new unsigned char [TIFFScanlineSize(tif)];\n    if (buf == NULL) {\n      pd_error(0, \"[GEM:imageTIFF] can't allocate memory for scanline buffer: %s\",\n               filename.c_str());\n      TIFFClose(tif);\n      tiffhandlers_cleanup();\n      return false;\n    }\n\n    result.reallocate();\n    unsigned char *dstLine = result.data;\n    int yStride = result.xsize * result.csize;\n    for (uint32_t row = 0; row \u003c height; row++) {\n      unsigned char *pixels = dstLine;\n      if (TIFFReadScanline(tif, buf, row, 0) \u003c 0) {\n        logpost(0, 3+1, \"[GEM:imageTIFF] bad image data read on line: %d: %s\", row,\n                filename.c_str());\n        TIFFClose(tif);\n        return false;\n      }\n      unsigned char *inp = buf;\n      if (samps == 1) {\n        for (uint32_t i = 0; i \u003c width; i++) {\n          *pixels++ = *inp++;         // Gray8\n        }\n      } else if (samps == 3)  {\n        for (uint32_t i = 0; i \u003c width; i++) {\n          pixels[chRed]   = inp[0];   // Red\n          pixels[chGreen] = inp[1];   // Green\n          pixels[chBlue]  = inp[2];   // Blue\n          pixels[chAlpha] = 255;      // Alpha\n          pixels += 4;\n          inp += 3;\n        }\n      } else {\n        for (uint32_t i = 0; i \u003c width; i++) {\n          pixels[chRed]   = inp[0];   // Red\n          pixels[chGreen] = inp[1];   // Green\n          pixels[chBlue]  = inp[2];   // Blue\n          pixels[chAlpha] = inp[3];   // Alpha\n          pixels += 4;\n          inp += 4;\n        }\n      }\n      dstLine += yStride;\n    }\n    delete [] buf;\n  }\n  // nope, so use the automatic conversion\n  else {\n    char emsg[1024];\n    TIFFRGBAImage img;\n    if (TIFFRGBAImageBegin(\u0026img, tif, 0, emsg) == 0) {\n      logpost(0, 3+0, \"[GEM:imageTIFF] Error reading in image file '%s': %s\",\n              filename.c_str(), emsg);\n      TIFFClose(tif);\n      tiffhandlers_cleanup();\n      return false;\n    }\n\n    uint32_t*raster = reinterpret_cast\u003cuint32_t*\u003e(_TIFFmalloc(npixels * sizeof(\n                      uint32_t)));\n    if (raster == NULL) {\n      pd_error(0, \"[GEM:imageTIFF] Unable to allocate memory for image '%s'\",\n               filename.c_str());\n      TIFFClose(tif);\n      tiffhandlers_cleanup();\n      return false;\n    }\n\n    if (TIFFRGBAImageGet(\u0026img, raster, width, height) == 0) {\n      logpost(0, 3+0, \"[GEM:imageTIFF] Error getting image data in file '%s': %s\",\n              filename.c_str(), emsg);\n      _TIFFfree(raster);\n      TIFFClose(tif);\n      tiffhandlers_cleanup();\n      return false;\n    }\n\n    TIFFRGBAImageEnd(\u0026img);\n    result.setFormat(GEM_RGBA);\n    result.reallocate();\n\n    unsigned char *dstLine = result.data;\n    int yStride = result.xsize * result.csize;\n    // transfer everything over\n    int k = 0;\n    for (uint32_t i = 0; i \u003c height; i++) {\n      unsigned char *pixels = dstLine;\n      for (uint32_t j = 0; j \u003c width; j++) {\n        pixels[chRed]   = static_cast\u003cunsigned char\u003e(TIFFGetR(raster[k])); // Red\n        pixels[chGreen] = static_cast\u003cunsigned char\u003e(TIFFGetG(raster[k])); // Green\n        pixels[chBlue]  = static_cast\u003cunsigned char\u003e(TIFFGetB(raster[k])); // Blue\n        pixels[chAlpha] = static_cast\u003cunsigned char\u003e(TIFFGetA(raster[k])); // Alpha\n        k++;\n        pixels += 4;\n      }\n      dstLine += yStride;\n    }\n    _TIFFfree(raster);\n  }\n\n  result.fixUpDown();\n\n  double value_d;\n  short value_i16;\n  char value_s[MAXPDSTRING];\n  if(TIFFGetField(tif, TIFFTAG_XRESOLUTION, \u0026value_d)) {\n    props.set(\"xresolution\", value_d);\n  }\n  if(TIFFGetField(tif, TIFFTAG_YRESOLUTION, \u0026value_d)) {\n    props.set(\"yresolution\", value_d);\n  }\n  if(TIFFGetField(tif, TIFFTAG_XRESOLUTION, \u0026value_d)) {\n    props.set(\"xresolution\", value_d);\n  }\n  if(TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, \u0026value_i16)) {\n    std::string resunit;\n    switch(value_i16) {\n    case RESUNIT_INCH:\n      resunit=\"inch\";\n      break;\n    case RESUNIT_CENTIMETER:\n      resunit=\"centimeter\";\n      break;\n    default:\n      resunit=\"none\";\n      break;\n    }\n    props.set(\"resolutionunit\", resunit);\n  }\n  if(TIFFGetField(tif, TIFFTAG_SOFTWARE, \u0026value_s)) {\n    props.set(\"software\", std::string(value_s));\n  }\n  if(TIFFGetField(tif, TIFFTAG_ARTIST, \u0026value_s)) {\n    props.set(\"artist\", std::string(value_s));\n  }\n  if(TIFFGetField(tif, TIFFTAG_HOSTCOMPUTER, \u0026value_s)) {\n    props.set(\"hostcomputer\", std::string(value_s));\n  }\n\n  TIFFClose(tif);\n\n  const char*orient=0;\n  switch(orientation) {\n  case ORIENTATION_TOPLEFT:\n  case ORIENTATION_BOTLEFT:\n    break;\n  case ORIENTATION_TOPRIGHT:\n    orient = \"top right\"; break;\n  case ORIENTATION_BOTRIGHT:\n    orient = \"bottom right\"; break;\n  case ORIENTATION_LEFTTOP:\n    orient = \"left top\"; break;\n  case ORIENTATION_RIGHTTOP:\n    orient = \"right top\"; break;\n  case ORIENTATION_RIGHTBOT:\n    orient = \"right bottom\"; break;\n  case ORIENTATION_LEFTBOT:\n    orient = \"left bottom\"; break;\n  default:\n    orient = \"unknown\"; break;\n  }\n  if(orient) {\n    logpost(0, 3+0, \"[GEM:imageTIFF] unhandled orientation '%s' (%d)\", orient, orientation);\n  }\n  return true;\n}\nbool imageTIFF::save(const imageStruct\u0026constimage,\n                     const std::string\u0026filename, const std::string\u0026mimetype,\n                     const gem::Properties\u0026props)\n{\n  tiffhandlers_init();\n  TIFF *tif = NULL;\n  imageStruct image;\n\n  tif=TIFFOpen(filename.c_str(), \"w\");\n  if (tif == NULL) {\n      tiffhandlers_cleanup();\n      return false;\n  }\n  image.convertFrom(\u0026constimage, GEM_RAW_RGBA);\n  image.fixUpDown();\n\n  uint32_t width=image.xsize, height = image.ysize;\n  short bits=8, samps=image.csize;\n  int npixels = width * height;\n  //int planar_conf = PLANARCONFIG_CONTIG;\n  std::string software = \"PD/GEM\";\n  std::string artist;\n  std::string hostcomputer;\n\n  double xresolution = 72., yresolution=72.;\n  short resunit = RESUNIT_INCH;\n\n  props.get(\"xresolution\", xresolution);\n  props.get(\"yresolution\", yresolution);\n  std::string resunit_s;\n  if(props.get(\"resolutionunit\", resunit_s)) {\n    if((\"inch\"==resunit_s) || (\"english\"==resunit_s)\n        || (\"imperial\"==resunit_s)) {\n      resunit=RESUNIT_INCH;\n    } else if((\"centimeter\"==resunit_s) || (\"metric\"==resunit_s)) {\n      resunit=RESUNIT_CENTIMETER;\n    } else {\n      resunit=RESUNIT_NONE;\n    }\n  }\n  props.get(\"software\", software);\n  props.get(\"artist\", artist);\n  props.get(\"hostcomputer\", hostcomputer);\n\n\n  TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n  TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bits);\n  TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, samps);\n  TIFFSetField(tif, TIFFTAG_PLANARCONFIG, 1);\n  TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\n  TIFFSetField(tif, TIFFTAG_XRESOLUTION, xresolution); // RATIONAL\n  TIFFSetField(tif, TIFFTAG_YRESOLUTION, yresolution); // RATIONAL\n  TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resunit);\n\n  uint16_t extra_samples[1] = { EXTRASAMPLE_UNASSALPHA };\n  TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, 1, extra_samples);\n\n  if(!software.empty()) {\n    TIFFSetField(tif, TIFFTAG_SOFTWARE, software.c_str());\n  }\n  if(!artist.empty()) {\n    TIFFSetField(tif, TIFFTAG_ARTIST, artist.c_str());\n  }\n  if(!hostcomputer.empty()) {\n    TIFFSetField(tif, TIFFTAG_HOSTCOMPUTER, hostcomputer.c_str());\n  }\n\n  int yStride = image.xsize * image.csize;\n  unsigned char *srcLine = image.data;\n\n  for (uint32_t row = 0; row \u003c height; row++) {\n    if (TIFFWriteScanline(tif, srcLine, row, 0) \u003c 0) {\n      logpost(0, 3+0, \"[GEM:imageTIFF] could not write line %d to image '%s'\", row,\n              filename.c_str());\n      TIFFClose(tif);\n      tiffhandlers_cleanup();\n      return false;\n    }\n    srcLine += yStride;\n  }\n  TIFFClose(tif);\n\n  tiffhandlers_cleanup();\n  return true;\n}\n\n\nfloat imageTIFF::estimateSave(const imageStruct\u0026img,\n                              const std::string\u0026filename, const std::string\u0026mimetype,\n                              const gem::Properties\u0026props)\n{\n  float result=0;\n  if(mimetype == \"image/tiff\" || mimetype == \"image/x-tiff\") {\n    result += 100;\n  }\n\n  if(gem::Properties::UNSET != props.type(\"xresolution\")) {\n    result+=1.;\n  }\n  if(gem::Properties::UNSET != props.type(\"yresolution\")) {\n    result+=1.;\n  }\n  if(gem::Properties::UNSET != props.type(\"resolutionunit\")) {\n    result+=1.;\n  }\n  if(gem::Properties::UNSET != props.type(\"software\")) {\n    result+=1.;\n  }\n  if(gem::Properties::UNSET != props.type(\"artist\")) {\n    result+=1.;\n  }\n  if(gem::Properties::UNSET != props.type(\"hostcomputer\")) {\n    result+=1.;\n  }\n\n  return result;\n}\n\n\nvoid imageTIFF::getWriteCapabilities(std::vector\u003cstd::string\u003e\u0026mimetypes,\n                                     gem::Properties\u0026props)\n{\n  mimetypes.clear();\n  props.clear();\n\n  mimetypes.push_back(\"image/tiff\");\n  mimetypes.push_back(\"image/x-tiff\");\n\n  gem::any value;\n\n\n  value=72.f;\n  props.set(\"xresolution\", value);\n  props.set(\"yresolution\", value);\n\n  value=std::string(\"inch\");\n  props.set(\"resolutionunit\", value);\n  value=std::string(\"PD/GEM\");\n  props.set(\"software\", value);\n  value=std::string(\"\");\n  props.set(\"artist\", value);\n  props.set(\"hostcomputer\", value);\n}\n#endif\n",
        "name": "imageTIFF.cpp",
        "path": "plugins/TIFF/imageTIFF.cpp",
        "url": "/github.com/umlaeute/Gem/-/blob/plugins/TIFF/imageTIFF.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 235,
          "offsetAndLengths": [
            [
              8,
              16
            ]
          ],
          "preview": "    if (TIFFRGBAImageGet(\u0026img, raster, width, height) == 0) {"
        }
      ],
      "repository": {
        "name": "github.com/umlaeute/Gem",
        "url": "/github.com/umlaeute/Gem"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "61d8a3923d2f6c87da136676e64754796f379826"
        },
        "content": "/*\n * Copyright (c) 2020-2022, NVIDIA CORPORATION.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#define CUCIM_EXPORTS\n\n#include \"cuslide.h\"\n\n#include \"cucim/core/framework.h\"\n#include \"cucim/core/plugin_util.h\"\n#include \"cucim/io/format/image_format.h\"\n#include \"tiff/tiff.h\"\n\n#include \u003cfmt/format.h\u003e\n#include \u003cnlohmann/json.hpp\u003e\n\n#include \u003carray\u003e\n#include \u003ccassert\u003e\n#include \u003ccstring\u003e\n#include \u003cfcntl.h\u003e\n#include \u003cfilesystem\u003e\n#include \u003cmemory\u003e\n\nusing json = nlohmann::json;\n\nconst struct cucim::PluginImplDesc kPluginImpl = {\n    \"cucim.kit.cuslide\", // name\n    { 0, 1, 0 }, // version\n    \"dev\", // build\n    \"clara team\", // author\n    \"cuslide\", // description\n    \"cuslide plugin\", // long_description\n    \"Apache-2.0\", // license\n    \"https://github.com/rapidsai/cucim\", // url\n    \"linux\", // platforms,\n    cucim::PluginHotReload::kDisabled, // hot_reload\n};\n\n// Using CARB_PLUGIN_IMPL_MINIMAL instead of CARB_PLUGIN_IMPL\n// This minimal macro doesn't define global variables for logging, profiler, crash reporting,\n// and also doesn't call for the client registration for those systems\nCUCIM_PLUGIN_IMPL_MINIMAL(kPluginImpl, cucim::io::format::IImageFormat)\nCUCIM_PLUGIN_IMPL_NO_DEPS()\n\n\nstatic void set_enabled(bool val)\n{\n    (void)val;\n}\n\nstatic bool is_enabled()\n{\n    return true;\n}\n\nstatic const char* get_format_name()\n{\n    return \"Generic TIFF\";\n}\n\nstatic bool CUCIM_ABI checker_is_valid(const char* file_name, const char* buf, size_t size)\n{\n    (void)buf;\n    (void)size;\n    auto file = std::filesystem::path(file_name);\n    auto extension = file.extension().string();\n    if (extension.compare(\".tif\") == 0 || extension.compare(\".tiff\") == 0 || extension.compare(\".svs\") == 0)\n    {\n        return true;\n    }\n    return false;\n}\n\nstatic CuCIMFileHandle_share CUCIM_ABI parser_open(const char* file_path)\n{\n    auto tif = new cuslide::tiff::TIFF(file_path, O_RDONLY);\n    tif-\u003econstruct_ifds();\n    // Move the ownership of the file handle object to the caller (CuImage).\n    auto handle_t = tif-\u003efile_handle();\n    tif-\u003efile_handle() = nullptr;\n    CuCIMFileHandle_share handle = new std::shared_ptr\u003cCuCIMFileHandle\u003e(handle_t);\n    return handle;\n}\n\nstatic bool CUCIM_ABI parser_parse(CuCIMFileHandle_ptr handle_ptr, cucim::io::format::ImageMetadataDesc* out_metadata_desc)\n{\n    CuCIMFileHandle* handle = reinterpret_cast\u003cCuCIMFileHandle*\u003e(handle_ptr);\n    if (!out_metadata_desc || !out_metadata_desc-\u003ehandle)\n    {\n        throw std::runtime_error(\"out_metadata_desc shouldn't be nullptr!\");\n    }\n    cucim::io::format::ImageMetadata\u0026 out_metadata =\n        *reinterpret_cast\u003ccucim::io::format::ImageMetadata*\u003e(out_metadata_desc-\u003ehandle);\n\n    auto tif = static_cast\u003ccuslide::tiff::TIFF*\u003e(handle-\u003eclient_data);\n\n    size_t ifd_count = tif-\u003eifd_count();\n    size_t level_count = tif-\u003elevel_count();\n\n    // If not Aperio SVS format (== Ordinary Pyramid TIFF image)\n    if (tif-\u003eifd(0)-\u003eimage_description().rfind(\"Aperio\", 0) != 0)\n    {\n        std::vector\u003csize_t\u003e main_ifd_list;\n        for (size_t i = 0; i \u003c ifd_count; i++)\n        {\n            const std::shared_ptr\u003ccuslide::tiff::IFD\u003e\u0026 ifd = tif-\u003eifd(i);\n            uint64_t subfile_type = ifd-\u003esubfile_type();\n            if (subfile_type == 0)\n            {\n                main_ifd_list.push_back(i);\n            }\n        }\n\n        // Assume that the image has only one main (high resolution) image.\n        if (main_ifd_list.size() != 1)\n        {\n            throw std::runtime_error(\n                fmt::format(\"This format has more than one image with Subfile Type 0 so cannot be loaded!\"));\n        }\n    }\n\n    //\n    // Metadata Setup\n    //\n\n    // Note: int-\u003e uint16_t due to type differences between ImageMetadataDesc.ndim and DLTensor.ndim\n    const uint16_t ndim = 3;\n    auto\u0026 resource = out_metadata.get_resource();\n\n    std::string_view dims{ \"YXC\" };\n\n    const auto\u0026 level0_ifd = tif-\u003elevel_ifd(0);\n    std::pmr::vector\u003cint64_t\u003e shape(\n        { level0_ifd-\u003eheight(), level0_ifd-\u003ewidth(), level0_ifd-\u003esamples_per_pixel() }, \u0026resource);\n\n    DLDataType dtype{ kDLUInt, 8, 1 };\n\n    // TODO: Fill correct values for cucim::io::format::ImageMetadataDesc\n    uint8_t n_ch = level0_ifd-\u003esamples_per_pixel();\n    if (n_ch != 3)\n    {\n        // Image loaded by a slow-path(libtiff) always will have 4 channel\n        // (by TIFFRGBAImageGet() method in libtiff)\n        n_ch = 4;\n        shape[2] = 4;\n    }\n    std::pmr::vector\u003cstd::string_view\u003e channel_names(\u0026resource);\n    channel_names.reserve(n_ch);\n    if (n_ch == 3)\n    {\n        channel_names.emplace_back(std::string_view{ \"R\" });\n        channel_names.emplace_back(std::string_view{ \"G\" });\n        channel_names.emplace_back(std::string_view{ \"B\" });\n    }\n    else\n    {\n        channel_names.emplace_back(std::string_view{ \"R\" });\n        channel_names.emplace_back(std::string_view{ \"G\" });\n        channel_names.emplace_back(std::string_view{ \"B\" });\n        channel_names.emplace_back(std::string_view{ \"A\" });\n    }\n\n    // Spacing units\n    std::pmr::vector\u003cstd::string_view\u003e spacing_units(\u0026resource);\n    spacing_units.reserve(ndim);\n\n    std::pmr::vector\u003cfloat\u003e spacing(\u0026resource);\n    spacing.reserve(ndim);\n    const auto resolution_unit = level0_ifd-\u003eresolution_unit();\n    const auto x_resolution = level0_ifd-\u003ex_resolution();\n    const auto y_resolution = level0_ifd-\u003ey_resolution();\n\n    switch (resolution_unit)\n    {\n    case 1: // no absolute unit of measurement\n        spacing.emplace_back(y_resolution);\n        spacing.emplace_back(x_resolution);\n        spacing.emplace_back(1.0f);\n\n        spacing_units.emplace_back(std::string_view{ \"\" });\n        spacing_units.emplace_back(std::string_view{ \"\" });\n        break;\n    case 2: // inch\n        spacing.emplace_back(y_resolution != 0 ? 25400 / y_resolution : 1.0f);\n        spacing.emplace_back(x_resolution != 0 ? 25400 / x_resolution : 1.0f);\n        spacing.emplace_back(1.0f);\n\n        spacing_units.emplace_back(std::string_view{ \"micrometer\" });\n        spacing_units.emplace_back(std::string_view{ \"micrometer\" });\n        break;\n    case 3: // centimeter\n        spacing.emplace_back(y_resolution != 0 ? 10000 / y_resolution : 1.0f);\n        spacing.emplace_back(x_resolution != 0 ? 10000 / x_resolution : 1.0f);\n        spacing.emplace_back(1.0f);\n\n        spacing_units.emplace_back(std::string_view{ \"micrometer\" });\n        spacing_units.emplace_back(std::string_view{ \"micrometer\" });\n        break;\n    default:\n        spacing.insert(spacing.end(), ndim, 1.0f);\n    }\n\n    spacing_units.emplace_back(std::string_view{ \"color\" });\n\n    std::pmr::vector\u003cfloat\u003e origin({ 0.0, 0.0, 0.0 }, \u0026resource);\n    // Direction cosines (size is always 3x3)\n    // clang-format off\n    std::pmr::vector\u003cfloat\u003e direction({ 1.0, 0.0, 0.0,\n                                        0.0, 1.0, 0.0,\n                                        0.0, 0.0, 1.0}, \u0026resource);\n    // clang-format on\n\n    // The coordinate frame in which the direction cosines are measured (either 'LPS'(ITK/DICOM) or 'RAS'(NIfTI/3D\n    // Slicer))\n    std::string_view coord_sys{ \"LPS\" };\n\n    const uint16_t level_ndim = 2;\n    std::pmr::vector\u003cint64_t\u003e level_dimensions(\u0026resource);\n    level_dimensions.reserve(level_count * 2);\n    for (size_t i = 0; i \u003c level_count; ++i)\n    {\n        const auto\u0026 level_ifd = tif-\u003elevel_ifd(i);\n        level_dimensions.emplace_back(level_ifd-\u003ewidth());\n        level_dimensions.emplace_back(level_ifd-\u003eheight());\n    }\n\n    std::pmr::vector\u003cfloat\u003e level_downsamples(\u0026resource);\n    float orig_width = static_cast\u003cfloat\u003e(shape[1]);\n    float orig_height = static_cast\u003cfloat\u003e(shape[0]);\n    for (size_t i = 0; i \u003c level_count; ++i)\n    {\n        const auto\u0026 level_ifd = tif-\u003elevel_ifd(i);\n        level_downsamples.emplace_back(((orig_width / level_ifd-\u003ewidth()) + (orig_height / level_ifd-\u003eheight())) / 2);\n    }\n\n    std::pmr::vector\u003cuint32_t\u003e level_tile_sizes(\u0026resource);\n    level_tile_sizes.reserve(level_count * 2);\n    for (size_t i = 0; i \u003c level_count; ++i)\n    {\n        const auto\u0026 level_ifd = tif-\u003elevel_ifd(i);\n        level_tile_sizes.emplace_back(level_ifd-\u003etile_width());\n        level_tile_sizes.emplace_back(level_ifd-\u003etile_height());\n    }\n\n    const size_t associated_image_count = tif-\u003eassociated_image_count();\n    std::pmr::vector\u003cstd::string_view\u003e associated_image_names(\u0026resource);\n    for (const auto\u0026 associated_image : tif-\u003eassociated_images())\n    {\n        associated_image_names.emplace_back(std::string_view{ associated_image.first.c_str() });\n    }\n\n    auto\u0026 image_description = level0_ifd-\u003eimage_description();\n    std::string_view raw_data{ image_description.empty() ? \"\" : image_description.c_str() };\n\n    // Dynamically allocate memory for json_data (need to be freed manually);\n    const std::string\u0026 json_str = tif-\u003emetadata();\n    char* json_data_ptr = static_cast\u003cchar*\u003e(cucim_malloc(json_str.size() + 1));\n    memcpy(json_data_ptr, json_str.data(), json_str.size() + 1);\n    std::string_view json_data{ json_data_ptr, json_str.size() };\n\n    out_metadata.ndim(ndim);\n    out_metadata.dims(std::move(dims));\n    out_metadata.shape(std::move(shape));\n    out_metadata.dtype(dtype);\n    out_metadata.channel_names(std::move(channel_names));\n    out_metadata.spacing(std::move(spacing));\n    out_metadata.spacing_units(std::move(spacing_units));\n    out_metadata.origin(std::move(origin));\n    out_metadata.direction(std::move(direction));\n    out_metadata.coord_sys(std::move(coord_sys));\n    out_metadata.level_count(level_count);\n    out_metadata.level_ndim(level_ndim);\n    out_metadata.level_dimensions(std::move(level_dimensions));\n    out_metadata.level_downsamples(std::move(level_downsamples));\n    out_metadata.level_tile_sizes(std::move(level_tile_sizes));\n    out_metadata.image_count(associated_image_count);\n    out_metadata.image_names(std::move(associated_image_names));\n    out_metadata.raw_data(raw_data);\n    out_metadata.json_data(json_data);\n\n    return true;\n}\n\nstatic bool CUCIM_ABI parser_close(CuCIMFileHandle_ptr handle_ptr)\n{\n    CuCIMFileHandle* handle = reinterpret_cast\u003cCuCIMFileHandle*\u003e(handle_ptr);\n\n    auto tif = static_cast\u003ccuslide::tiff::TIFF*\u003e(handle-\u003eclient_data);\n    delete tif;\n    handle-\u003eclient_data = nullptr;\n    return true;\n}\n\nstatic bool CUCIM_ABI reader_read(const CuCIMFileHandle_ptr handle_ptr,\n                                  const cucim::io::format::ImageMetadataDesc* metadata,\n                                  const cucim::io::format::ImageReaderRegionRequestDesc* request,\n                                  cucim::io::format::ImageDataDesc* out_image_data,\n                                  cucim::io::format::ImageMetadataDesc* out_metadata = nullptr)\n{\n    CuCIMFileHandle* handle = reinterpret_cast\u003cCuCIMFileHandle*\u003e(handle_ptr);\n    auto tif = static_cast\u003ccuslide::tiff::TIFF*\u003e(handle-\u003eclient_data);\n    bool result = tif-\u003eread(metadata, request, out_image_data, out_metadata);\n\n    return result;\n}\n\nstatic bool CUCIM_ABI writer_write(const CuCIMFileHandle_ptr handle_ptr,\n                                   const cucim::io::format::ImageMetadataDesc* metadata,\n                                   const cucim::io::format::ImageDataDesc* image_data)\n{\n    CuCIMFileHandle* handle = reinterpret_cast\u003cCuCIMFileHandle*\u003e(handle_ptr);\n    (void)handle;\n    (void)metadata;\n    (void)image_data;\n\n    return true;\n}\n\nvoid fill_interface(cucim::io::format::IImageFormat\u0026 iface)\n{\n    static cucim::io::format::ImageCheckerDesc image_checker = { 0, 0, checker_is_valid };\n    static cucim::io::format::ImageParserDesc image_parser = { parser_open, parser_parse, parser_close };\n\n    static cucim::io::format::ImageReaderDesc image_reader = { reader_read };\n    static cucim::io::format::ImageWriterDesc image_writer = { writer_write };\n\n    // clang-format off\n    static cucim::io::format::ImageFormatDesc image_format_desc = {\n        set_enabled,\n        is_enabled,\n        get_format_name,\n        image_checker,\n        image_parser,\n        image_reader,\n        image_writer\n    };\n    // clang-format on\n\n    // clang-format off\n    iface =\n    {\n        \u0026image_format_desc,\n        1\n    };\n    // clang-format on\n}\n",
        "name": "cuslide.cpp",
        "path": "cpp/plugins/cucim.kit.cuslide/src/cuslide/cuslide.cpp",
        "url": "/github.com/rapidsai/cucim/-/blob/cpp/plugins/cucim.kit.cuslide/src/cuslide/cuslide.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 153,
          "offsetAndLengths": [
            [
              15,
              16
            ]
          ],
          "preview": "        // (by TIFFRGBAImageGet() method in libtiff)"
        }
      ],
      "repository": {
        "name": "github.com/rapidsai/cucim",
        "url": "/github.com/rapidsai/cucim"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "f44e853beacb141a718b37118a1cc72404a43bd3"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "dependencies/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/fegennari/3DWorld/-/blob/dependencies/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/fegennari/3DWorld",
        "url": "/github.com/fegennari/3DWorld"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "f44e853beacb141a718b37118a1cc72404a43bd3"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32_t* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32_t* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32_t*) _TIFFmalloc(npixels * sizeof (uint32_t));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32_t* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32_t* cp, \\\n    uint32_t x, uint32_t y, \\\n    uint32_t w, uint32_t h, \\\n    int32_t fromskew, int32_t toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32_t* cp,\\\n    uint32_t x, uint32_t y, \\\n    uint32_t w, uint32_t h,\\\n    int32_t fromskew, int32_t toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32_t* uraster, uint32_t w, uint32_t h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Convert 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32_t\nsetorientation(TIFFRGBAImage* img, uint32_t h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32_t y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32_t* raster, uint32_t w, uint32_t h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16_t orientation;\n    uint32_t row, y, nrow, rowstoread;\n    uint32_t pos;\n    u_char* buf;\n    uint32_t rowsperstrip;\n    uint32_t imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32_t fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32_t  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32_t) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32_t*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32_t) nrow : (int32_t) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "dependencies/tiff-4.3.0/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/fegennari/3DWorld/-/blob/dependencies/tiff-4.3.0/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/fegennari/3DWorld",
        "url": "/github.com/fegennari/3DWorld"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "61d8a3923d2f6c87da136676e64754796f379826"
        },
        "content": "/*\n * Copyright (c) 2020-2021, NVIDIA CORPORATION.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"ifd.h\"\n\n#include \u003csys/types.h\u003e\n#include \u003cunistd.h\u003e\n\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003crandom\u003e\n#include \u003cthread\u003e\n\n#include \u003cfmt/format.h\u003e\n#include \u003ctiffio.h\u003e\n#include \u003ctiffiop.h\u003e // this is not included in the released library\n#include \u003cturbojpeg.h\u003e\n\n#include \u003ccucim/codec/hash_function.h\u003e\n#include \u003ccucim/cuimage.h\u003e\n#include \u003ccucim/logger/timer.h\u003e\n#include \u003ccucim/memory/memory_manager.h\u003e\n#include \u003ccucim/profiler/nvtx3.h\u003e\n#include \u003ccucim/util/cuda.h\u003e\n\n#include \"cuslide/deflate/deflate.h\"\n#include \"cuslide/jpeg/libjpeg_turbo.h\"\n#include \"cuslide/jpeg2k/libopenjpeg.h\"\n#include \"cuslide/loader/nvjpeg_processor.h\"\n#include \"cuslide/lzw/lzw.h\"\n#include \"cuslide/raw/raw.h\"\n#include \"tiff.h\"\n\n\nnamespace cuslide::tiff\n{\n\nIFD::IFD(TIFF* tiff, uint16_t index, ifd_offset_t offset) : tiff_(tiff), ifd_index_(index), ifd_offset_(offset)\n{\n    PROF_SCOPED_RANGE(PROF_EVENT(ifd_ifd));\n    auto tif = tiff-\u003eclient();\n\n    char* software_char_ptr = nullptr;\n    char* model_char_ptr = nullptr;\n\n    // TODO: error handling\n    TIFFGetField(tif, TIFFTAG_SOFTWARE, \u0026software_char_ptr);\n    software_ = std::string(software_char_ptr ? software_char_ptr : \"\");\n    TIFFGetField(tif, TIFFTAG_MODEL, \u0026model_char_ptr);\n    model_ = std::string(model_char_ptr ? model_char_ptr : \"\");\n    TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, \u0026model_char_ptr);\n    image_description_ = std::string(model_char_ptr ? model_char_ptr : \"\");\n    TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, \u0026resolution_unit_);\n    TIFFGetField(tif, TIFFTAG_XRESOLUTION, \u0026x_resolution_);\n    TIFFGetField(tif, TIFFTAG_YRESOLUTION, \u0026y_resolution_);\n\n    TIFFDirectory\u0026 tif_dir = tif-\u003etif_dir;\n    flags_ = tif-\u003etif_flags;\n\n    width_ = tif_dir.td_imagewidth;\n    height_ = tif_dir.td_imagelength;\n    if ((flags_ \u0026 TIFF_ISTILED) != 0)\n    {\n        tile_width_ = tif_dir.td_tilewidth;\n        tile_height_ = tif_dir.td_tilelength;\n    }\n    else\n    {\n        rows_per_strip_ = tif_dir.td_rowsperstrip;\n    }\n    bits_per_sample_ = tif_dir.td_bitspersample;\n    samples_per_pixel_ = tif_dir.td_samplesperpixel;\n    subfile_type_ = tif_dir.td_subfiletype;\n    planar_config_ = tif_dir.td_planarconfig;\n    photometric_ = tif_dir.td_photometric;\n    compression_ = tif_dir.td_compression;\n    TIFFGetField(tif, TIFFTAG_PREDICTOR, \u0026predictor_);\n    subifd_count_ = tif_dir.td_nsubifd;\n    uint64_t* subifd_offsets = tif_dir.td_subifd;\n    if (subifd_count_)\n    {\n        subifd_offsets_.resize(subifd_count_);\n        subifd_offsets_.insert(subifd_offsets_.end(), \u0026subifd_offsets[0], \u0026subifd_offsets[subifd_count_]);\n    }\n\n    if (compression_ == COMPRESSION_JPEG)\n    {\n        uint8_t* jpegtable_data = nullptr;\n        uint32_t jpegtable_count = 0;\n\n        TIFFGetField(tif, TIFFTAG_JPEGTABLES, \u0026jpegtable_count, \u0026jpegtable_data);\n        jpegtable_.reserve(jpegtable_count);\n        jpegtable_.insert(jpegtable_.end(), jpegtable_data, jpegtable_data + jpegtable_count);\n\n        if (photometric_ == PHOTOMETRIC_RGB)\n        {\n            jpeg_color_space_ = 2; // JCS_RGB\n        }\n        else if (photometric_ == PHOTOMETRIC_YCBCR)\n        {\n            jpeg_color_space_ = 3; // JCS_YCbCr\n        }\n    }\n\n    image_piece_count_ = tif_dir.td_stripoffset_entry.tdir_count;\n\n    image_piece_offsets_.reserve(image_piece_count_);\n    uint64* td_stripoffset_p = tif_dir.td_stripoffset_p;\n    uint64* td_stripbytecount_p = tif_dir.td_stripbytecount_p;\n\n    // Copy data to vector\n    image_piece_offsets_.insert(image_piece_offsets_.end(), \u0026td_stripoffset_p[0], \u0026td_stripoffset_p[image_piece_count_]);\n    image_piece_bytecounts_.insert(\n        image_piece_bytecounts_.end(), \u0026td_stripbytecount_p[0], \u0026td_stripbytecount_p[image_piece_count_]);\n\n    // Calculate hash value with IFD index\n    hash_value_ = tiff-\u003efile_handle_-\u003ehash_value ^ cucim::codec::splitmix64(index);\n\n    //    TIFFPrintDirectory(tif, stdout, TIFFPRINT_STRIPS);\n}\n\nbool IFD::read(const TIFF* tiff,\n               const cucim::io::format::ImageMetadataDesc* metadata,\n               const cucim::io::format::ImageReaderRegionRequestDesc* request,\n               cucim::io::format::ImageDataDesc* out_image_data)\n{\n    PROF_SCOPED_RANGE(PROF_EVENT(ifd_read));\n    ::TIFF* tif = tiff-\u003etiff_client_;\n\n    uint16_t ifd_index = ifd_index_;\n\n    std::string device_name(request-\u003edevice);\n\n    if (request-\u003eshm_name)\n    {\n        device_name = device_name + fmt::format(\"[{}]\", request-\u003eshm_name); // TODO: check performance\n    }\n    cucim::io::Device out_device(device_name);\n\n    int64_t sx = request-\u003elocation[0];\n    int64_t sy = request-\u003elocation[1];\n    uint32_t batch_size = request-\u003ebatch_size;\n    int64_t w = request-\u003esize[0];\n    int64_t h = request-\u003esize[1];\n    int32_t n_ch = samples_per_pixel_; // number of channels\n    int ndim = 3;\n\n    size_t raster_size = w * h * samples_per_pixel_;\n    void* raster = nullptr;\n    auto raster_type = cucim::io::DeviceType::kCPU;\n\n    DLTensor* out_buf = request-\u003ebuf;\n    bool is_buf_available = out_buf \u0026\u0026 out_buf-\u003edata;\n\n    if (is_buf_available)\n    {\n        // TODO: memory size check if out_buf-\u003edata has high-enough memory (\u003e= tjBufSize())\n        raster = out_buf-\u003edata;\n    }\n\n    if (is_read_optimizable())\n    {\n        if (batch_size \u003e 1)\n        {\n            ndim = 4;\n        }\n        int64_t* location = request-\u003elocation;\n        uint64_t location_len = request-\u003elocation_len;\n        const uint32_t num_workers = request-\u003enum_workers;\n        const bool drop_last = request-\u003edrop_last;\n        uint32_t prefetch_factor = request-\u003eprefetch_factor;\n        const bool shuffle = request-\u003eshuffle;\n        const uint64_t seed = request-\u003eseed;\n\n        if (num_workers == 0 \u0026\u0026 location_len \u003e 1)\n        {\n            throw std::runtime_error(\"Cannot read multiple locations with zero workers!\");\n        }\n\n        // Shuffle data\n        if (shuffle)\n        {\n            auto rng = std::default_random_engine{ seed };\n            struct position\n            {\n                int64_t x;\n                int64_t y;\n            };\n            std::shuffle(reinterpret_cast\u003cposition*\u003e(\u0026location[0]),\n                         reinterpret_cast\u003cposition*\u003e(\u0026location[location_len * 2]), rng);\n        }\n\n        // Adjust location length based on 'drop_last'\n        const uint32_t remaining_len = location_len % batch_size;\n        if (drop_last)\n        {\n            location_len -= remaining_len;\n        }\n\n        // Do not use prefetch if the image is too small\n        if (1 + prefetch_factor \u003e location_len)\n        {\n            prefetch_factor = location_len - 1;\n        }\n\n        size_t one_raster_size = raster_size;\n        raster_size *= batch_size;\n\n        const IFD* ifd = this;\n\n        if (location_len \u003e 1 || batch_size \u003e 1 || num_workers \u003e 0)\n        {\n            // Reconstruct location\n            std::unique_ptr\u003cstd::vector\u003cint64_t\u003e\u003e* location_unique =\n                reinterpret_cast\u003cstd::unique_ptr\u003cstd::vector\u003cint64_t\u003e\u003e*\u003e(request-\u003elocation_unique);\n            std::unique_ptr\u003cstd::vector\u003cint64_t\u003e\u003e request_location = std::move(*location_unique);\n            delete location_unique;\n\n            // Reconstruct size\n            std::unique_ptr\u003cstd::vector\u003cint64_t\u003e\u003e* size_unique =\n                reinterpret_cast\u003cstd::unique_ptr\u003cstd::vector\u003cint64_t\u003e\u003e*\u003e(request-\u003esize_unique);\n            std::unique_ptr\u003cstd::vector\u003cint64_t\u003e\u003e request_size = std::move(*size_unique);\n            delete size_unique;\n\n            auto load_func = [tiff, ifd, location, w, h, out_device](\n                                 cucim::loader::ThreadBatchDataLoader* loader_ptr, uint64_t location_index) {\n                uint8_t* raster_ptr = loader_ptr-\u003eraster_pointer(location_index);\n\n                if (!read_region_tiles(tiff, ifd, location, location_index, w, h,\n                                       raster_ptr, out_device, loader_ptr))\n                {\n                    fmt::print(stderr, \"[Error] Failed to read region!\\n\");\n                }\n            };\n\n            uint32_t maximum_tile_count = 0;\n\n            std::unique_ptr\u003ccucim::loader::BatchDataProcessor\u003e batch_processor;\n\n            // Set raster_type to CUDA because loader will handle this with nvjpeg\n            if (out_device.type() == cucim::io::DeviceType::kCUDA)\n            {\n                raster_type = cucim::io::DeviceType::kCUDA;\n\n                // The maximal number of tiles (x-axis) overapped with the given patch\n                uint32_t tile_across_count = std::min(static_cast\u003cuint64_t\u003e(ifd-\u003ewidth_) + (ifd-\u003etile_width_ - 1),\n                                                      static_cast\u003cuint64_t\u003e(w) + (ifd-\u003etile_width_ - 1)) /\n                                                 ifd-\u003etile_width_ +\n                                             1;\n                // The maximal number of tiles (y-axis) overapped with the given patch\n                uint32_t tile_down_count = std::min(static_cast\u003cuint64_t\u003e(ifd-\u003eheight_) + (ifd-\u003etile_height_ - 1),\n                                                    static_cast\u003cuint64_t\u003e(h) + (ifd-\u003etile_height_ - 1)) /\n                                               ifd-\u003etile_height_ +\n                                           1;\n                // The maximal number of possible tiles (# of tasks) to load for the given image batch\n                maximum_tile_count = tile_across_count * tile_down_count * batch_size;\n\n                // Create NvJpegProcessor\n                auto\u0026 jpegtable = ifd-\u003ejpegtable_;\n                const void* jpegtable_data = jpegtable.data();\n                uint32_t jpegtable_size = jpegtable.size();\n\n                auto nvjpeg_processor = std::make_unique\u003ccuslide::loader::NvJpegProcessor\u003e(\n                    tiff-\u003efile_handle_, ifd, request_location-\u003edata(), request_size-\u003edata(), location_len, batch_size,\n                    maximum_tile_count, static_cast\u003cconst uint8_t*\u003e(jpegtable_data), jpegtable_size);\n\n                // Update prefetch_factor\n                prefetch_factor = nvjpeg_processor-\u003epreferred_loader_prefetch_factor();\n\n                batch_processor = std::move(nvjpeg_processor);\n            }\n\n            auto loader = std::make_unique\u003ccucim::loader::ThreadBatchDataLoader\u003e(\n                load_func, std::move(batch_processor), out_device, std::move(request_location), std::move(request_size),\n                location_len, one_raster_size, batch_size, prefetch_factor, num_workers);\n\n            const uint32_t load_size = std::min(static_cast\u003cuint64_t\u003e(batch_size) * (1 + prefetch_factor), location_len);\n\n            loader-\u003erequest(load_size);\n\n            // If it reads entire image with multi threads (using loader), fetch the next item.\n            if (location_len == 1 \u0026\u0026 batch_size == 1)\n            {\n                raster = loader-\u003enext_data();\n            }\n\n            out_image_data-\u003eloader = loader.release(); // set loader to out_image_data\n        }\n        else\n        {\n            if (!raster)\n            {\n                raster = cucim_malloc(one_raster_size);\n            }\n\n            if (!read_region_tiles(tiff, ifd, location, 0, w, h, raster, out_device, nullptr))\n            {\n                fmt::print(stderr, \"[Error] Failed to read region!\\n\");\n            }\n        }\n    }\n    else\n    {\n        PROF_SCOPED_RANGE(PROF_EVENT(ifd_read_slowpath));\n        // Print a warning message for the slow path\n        std::call_once(\n            tiff-\u003eslow_path_warning_flag_,\n            [](const std::string\u0026 file_path) {\n                fmt::print(\n                    stderr,\n                    \"[Warning] Loading image('{}') with a slow-path. The pixel format of the loaded image would be RGBA (4 channels) instead of RGB!\\n\",\n                    file_path);\n            },\n            tiff-\u003efile_path());\n        // Handle out-of-boundary case\n        int64_t ex = sx + w - 1;\n        int64_t ey = sy + h - 1;\n        if (sx \u003c 0 || sy \u003c 0 || sx \u003e= width_ || sy \u003e= height_ || ex \u003c 0 || ey \u003c 0 || ex \u003e= width_ || ey \u003e= height_)\n        {\n            throw std::invalid_argument(fmt::format(\"Cannot handle the out-of-boundary cases.\"));\n        }\n\n        // Check if the image format is supported or not\n        if (!is_format_supported())\n        {\n            throw std::runtime_error(fmt::format(\n                \"This format (compression: {}, sample_per_pixel: {}, planar_config: {}, photometric: {}) is not supported yet!.\",\n                compression_, samples_per_pixel_, planar_config_, photometric_));\n        }\n\n        if (tif-\u003etif_curdir != ifd_index)\n        {\n            TIFFSetDirectory(tif, ifd_index);\n        }\n        // RGBA -\u003e 4 channels\n        n_ch = 4;\n\n        char emsg[1024];\n        if (TIFFRGBAImageOK(tif, emsg))\n        {\n            TIFFRGBAImage img;\n            if (TIFFRGBAImageBegin(\u0026img, tif, -1, emsg))\n            {\n                size_t npixels;\n                npixels = w * h;\n                raster_size = npixels * 4;\n                if (!raster)\n                {\n                    raster = cucim_malloc(raster_size);\n                }\n                img.col_offset = sx;\n                img.row_offset = sy;\n                img.req_orientation = ORIENTATION_TOPLEFT;\n\n                if (raster != nullptr)\n                {\n                    if (!TIFFRGBAImageGet(\u0026img, (uint32_t*)raster, w, h))\n                    {\n                        memset(raster, 0, raster_size);\n                    }\n                }\n            }\n            else\n            {\n                throw std::runtime_error(fmt::format(\n                    \"This format (compression: {}, sample_per_pixel: {}, planar_config: {}, photometric: {}) is not supported yet!: {}\",\n                    compression_, samples_per_pixel_, planar_config_, photometric_, emsg));\n            }\n            TIFFRGBAImageEnd(\u0026img);\n        }\n        else\n        {\n            throw std::runtime_error(fmt::format(\n                \"This format (compression: {}, sample_per_pixel: {}, planar_config: {}, photometric: {}) is not supported yet!: {}\",\n                compression_, samples_per_pixel_, planar_config_, photometric_, emsg));\n        }\n    }\n\n    int64_t* shape = static_cast\u003cint64_t*\u003e(cucim_malloc(sizeof(int64_t) * ndim));\n    if (ndim == 3)\n    {\n        shape[0] = h;\n        shape[1] = w;\n        shape[2] = n_ch;\n    }\n    else // ndim == 4\n    {\n        shape[0] = batch_size;\n        shape[1] = h;\n        shape[2] = w;\n        shape[3] = n_ch;\n    }\n\n    // Copy the raster memory and free it if needed.\n    if (!is_buf_available \u0026\u0026 raster \u0026\u0026 raster_type == cucim::io::DeviceType::kCPU)\n    {\n        cucim::memory::move_raster_from_host(\u0026raster, raster_size, out_device);\n    }\n\n    auto\u0026 out_image_container = out_image_data-\u003econtainer;\n    out_image_container.data = raster;\n    out_image_container.device = DLDevice{ static_cast\u003cDLDeviceType\u003e(out_device.type()), out_device.index() };\n    out_image_container.ndim = ndim;\n    out_image_container.dtype = metadata-\u003edtype;\n    out_image_container.shape = shape;\n    out_image_container.strides = nullptr; // Tensor is compact and row-majored\n    out_image_container.byte_offset = 0;\n    auto\u0026 shm_name = out_device.shm_name();\n    size_t shm_name_len = shm_name.size();\n    if (shm_name_len != 0)\n    {\n        out_image_data-\u003eshm_name = static_cast\u003cchar*\u003e(cucim_malloc(shm_name_len + 1));\n        memcpy(out_image_data-\u003eshm_name, shm_name.c_str(), shm_name_len + 1);\n    }\n    else\n    {\n        out_image_data-\u003eshm_name = nullptr;\n    }\n\n    return true;\n}\n\nuint32_t IFD::index() const\n{\n    return ifd_index_;\n}\nifd_offset_t IFD::offset() const\n{\n    return ifd_offset_;\n}\n\nstd::string\u0026 IFD::software()\n{\n    return software_;\n}\nstd::string\u0026 IFD::model()\n{\n    return model_;\n}\nstd::string\u0026 IFD::image_description()\n{\n    return image_description_;\n}\nuint16_t IFD::resolution_unit() const\n{\n    return resolution_unit_;\n}\nfloat IFD::x_resolution() const\n{\n    return x_resolution_;\n}\nfloat IFD::y_resolution() const\n{\n    return y_resolution_;\n}\nuint32_t IFD::width() const\n{\n    return width_;\n}\nuint32_t IFD::height() const\n{\n    return height_;\n}\nuint32_t IFD::tile_width() const\n{\n    return tile_width_;\n}\nuint32_t IFD::tile_height() const\n{\n    return tile_height_;\n}\nuint32_t IFD::rows_per_strip() const\n{\n    return rows_per_strip_;\n}\nuint32_t IFD::bits_per_sample() const\n{\n    return bits_per_sample_;\n}\nuint32_t IFD::samples_per_pixel() const\n{\n    return samples_per_pixel_;\n}\nuint64_t IFD::subfile_type() const\n{\n    return subfile_type_;\n}\nuint16_t IFD::planar_config() const\n{\n    return planar_config_;\n}\nuint16_t IFD::photometric() const\n{\n    return photometric_;\n}\nuint16_t IFD::compression() const\n{\n    return compression_;\n}\nuint16_t IFD::predictor() const\n{\n    return predictor_;\n}\n\nuint16_t IFD::subifd_count() const\n{\n    return subifd_count_;\n}\nstd::vector\u003cuint64_t\u003e\u0026 IFD::subifd_offsets()\n{\n    return subifd_offsets_;\n}\nuint32_t IFD::image_piece_count() const\n{\n    return image_piece_count_;\n}\nconst std::vector\u003cuint64_t\u003e\u0026 IFD::image_piece_offsets() const\n{\n    return image_piece_offsets_;\n}\nconst std::vector\u003cuint64_t\u003e\u0026 IFD::image_piece_bytecounts() const\n{\n    return image_piece_bytecounts_;\n}\n\nsize_t IFD::pixel_size_nbytes() const\n{\n    const int pixel_format = TJPF_RGB; // TODO: support other pixel format\n    const int nbytes = tjPixelSize[pixel_format];\n    return nbytes;\n}\n\nsize_t IFD::tile_raster_size_nbytes() const\n{\n    const size_t nbytes = tile_width_ * tile_height_ * pixel_size_nbytes();\n    return nbytes;\n}\n\nbool IFD::is_compression_supported() const\n{\n    switch (compression_)\n    {\n    case COMPRESSION_NONE:\n    case COMPRESSION_JPEG:\n    case COMPRESSION_ADOBE_DEFLATE:\n    case COMPRESSION_DEFLATE:\n    case cuslide::jpeg2k::kAperioJpeg2kYCbCr: // 33003: Jpeg 2000 with YCbCr format, possibly with a chroma subsampling\n                                              // of 4:2:2\n    case cuslide::jpeg2k::kAperioJpeg2kRGB: // 33005: Jpeg 2000 with RGB\n    case COMPRESSION_LZW:\n        return true;\n    default:\n        return false;\n    }\n}\n\nbool IFD::is_read_optimizable() const\n{\n    return is_compression_supported() \u0026\u0026 bits_per_sample_ == 8 \u0026\u0026 samples_per_pixel_ == 3 \u0026\u0026\n           (tile_width_ != 0 \u0026\u0026 tile_height_ != 0) \u0026\u0026 planar_config_ == PLANARCONFIG_CONTIG \u0026\u0026\n           (photometric_ == PHOTOMETRIC_RGB || photometric_ == PHOTOMETRIC_YCBCR) \u0026\u0026\n           !tiff_-\u003eis_in_read_config(TIFF::kUseLibTiff);\n}\n\nbool IFD::is_format_supported() const\n{\n    return is_compression_supported();\n}\n\nbool IFD::read_region_tiles(const TIFF* tiff,\n                            const IFD* ifd,\n                            const int64_t* location,\n                            const int64_t location_index,\n                            const int64_t w,\n                            const int64_t h,\n                            void* raster,\n                            const cucim::io::Device\u0026 out_device,\n                            cucim::loader::ThreadBatchDataLoader* loader)\n{\n    PROF_SCOPED_RANGE(PROF_EVENT(ifd_read_region_tiles));\n    // Reference code: https://github.com/libjpeg-turbo/libjpeg-turbo/blob/master/tjexample.c\n\n    int64_t sx = location[location_index * 2];\n    int64_t sy = location[location_index * 2 + 1];\n    int64_t ex = sx + w - 1;\n    int64_t ey = sy + h - 1;\n\n    uint32_t width = ifd-\u003ewidth_;\n    uint32_t height = ifd-\u003eheight_;\n\n    // Handle out-of-boundary case\n    if (sx \u003c 0 || sy \u003c 0 || sx \u003e= width || sy \u003e= height || ex \u003c 0 || ey \u003c 0 || ex \u003e= width || ey \u003e= height)\n    {\n        return read_region_tiles_boundary(tiff, ifd, location, location_index, w, h, raster, out_device, loader);\n    }\n    cucim::cache::ImageCache\u0026 image_cache = cucim::CuImage::cache_manager().cache();\n    cucim::cache::CacheType cache_type = image_cache.type();\n\n    uint8_t background_value = tiff-\u003ebackground_value_;\n    uint16_t compression_method = ifd-\u003ecompression_;\n    int jpeg_color_space = ifd-\u003ejpeg_color_space_;\n    int predictor = ifd-\u003epredictor_;\n\n    // TODO: revert this once we can get RGB data instead of RGBA\n    uint32_t samples_per_pixel = 3; // ifd-\u003esamples_per_pixel();\n\n    const void* jpegtable_data = ifd-\u003ejpegtable_.data();\n    uint32_t jpegtable_count = ifd-\u003ejpegtable_.size();\n\n    uint32_t tw = ifd-\u003etile_width_;\n    uint32_t th = ifd-\u003etile_height_;\n\n    uint32_t offset_sx = static_cast\u003cuint32_t\u003e(sx / tw); // x-axis start offset for the requested region in the ifd tile\n                                                         // array as grid\n    uint32_t offset_ex = static_cast\u003cuint32_t\u003e(ex / tw); // x-axis end  offset for the requested region in the ifd tile\n                                                         // array as grid\n    uint32_t offset_sy = static_cast\u003cuint32_t\u003e(sy / th); // y-axis start offset for the requested region in the ifd tile\n                                                         // array as grid\n    uint32_t offset_ey = static_cast\u003cuint32_t\u003e(ey / th); // y-axis end offset for the requested region in the ifd tile\n                                                         // array as grid\n\n    uint32_t pixel_offset_sx = static_cast\u003cuint32_t\u003e(sx % tw);\n    uint32_t pixel_offset_ex = static_cast\u003cuint32_t\u003e(ex % tw);\n    uint32_t pixel_offset_sy = static_cast\u003cuint32_t\u003e(sy % th);\n    uint32_t pixel_offset_ey = static_cast\u003cuint32_t\u003e(ey % th);\n\n    uint32_t stride_y = width / tw + !!(width % tw); // # of tiles in a row(y) in the ifd tile array as grid\n\n    uint32_t start_index_y = offset_sy * stride_y;\n    uint32_t end_index_y = offset_ey * stride_y;\n\n    const size_t tile_raster_nbytes = ifd-\u003etile_raster_size_nbytes();\n\n    int tiff_file = tiff-\u003efile_handle_-\u003efd;\n    uint64_t ifd_hash_value = ifd-\u003ehash_value_;\n    uint32_t dest_pixel_step_y = w * samples_per_pixel;\n\n    uint32_t nbytes_tw = tw * samples_per_pixel;\n    auto dest_start_ptr = static_cast\u003cuint8_t*\u003e(raster);\n\n    // TODO: Current implementation doesn't consider endianness so need to consider later\n    // TODO: Consider tile's depth tag.\n    for (uint32_t index_y = start_index_y; index_y \u003c= end_index_y; index_y += stride_y)\n    {\n        uint32_t tile_pixel_offset_sy = (index_y == start_index_y) ? pixel_offset_sy : 0;\n        uint32_t tile_pixel_offset_ey = (index_y == end_index_y) ? pixel_offset_ey : (th - 1);\n        uint32_t dest_pixel_offset_len_y = tile_pixel_offset_ey - tile_pixel_offset_sy + 1;\n\n        uint32_t dest_pixel_index_x = 0;\n\n        uint32_t index = index_y + offset_sx;\n        for (uint32_t offset_x = offset_sx; offset_x \u003c= offset_ex; ++offset_x, ++index)\n        {\n            PROF_SCOPED_RANGE(PROF_EVENT_P(ifd_read_region_tiles_iter, index));\n            auto tiledata_offset = static_cast\u003cuint64_t\u003e(ifd-\u003eimage_piece_offsets_[index]);\n            auto tiledata_size = static_cast\u003cuint64_t\u003e(ifd-\u003eimage_piece_bytecounts_[index]);\n\n            // Calculate a simple hash value for the tile index\n            uint64_t index_hash = ifd_hash_value ^ (static_cast\u003cuint64_t\u003e(index) | (static_cast\u003cuint64_t\u003e(index) \u003c\u003c 32));\n\n            uint32_t tile_pixel_offset_x = (offset_x == offset_sx) ? pixel_offset_sx : 0;\n            uint32_t nbytes_tile_pixel_size_x = (offset_x == offset_ex) ?\n                                                    (pixel_offset_ex - tile_pixel_offset_x + 1) * samples_per_pixel :\n                                                    (tw - tile_pixel_offset_x) * samples_per_pixel;\n            auto decode_func = [=, \u0026image_cache]() {\n                PROF_SCOPED_RANGE(PROF_EVENT_P(ifd_read_region_tiles_task, index_hash));\n                uint32_t nbytes_tile_index = (tile_pixel_offset_sy * tw + tile_pixel_offset_x) * samples_per_pixel;\n                uint32_t dest_pixel_index = dest_pixel_index_x;\n                uint8_t* tile_data = nullptr;\n                if (tiledata_size \u003e 0)\n                {\n                    std::unique_ptr\u003cuint8_t, decltype(cucim_free)*\u003e tile_raster =\n                        std::unique_ptr\u003cuint8_t, decltype(cucim_free)*\u003e(nullptr, cucim_free);\n\n                    if (loader \u0026\u0026 loader-\u003ebatch_data_processor())\n                    {\n                        switch (compression_method)\n                        {\n                        case COMPRESSION_JPEG:\n                            break;\n                        default:\n                            throw std::runtime_error(\"Unsupported compression method\");\n                        }\n                        auto value = loader-\u003ewait_for_processing(index);\n                        if (!value) // if shutdown\n                        {\n                            return;\n                        }\n                        tile_data = static_cast\u003cuint8_t*\u003e(value-\u003edata);\n\n                        cudaError_t cuda_status;\n                        CUDA_ERROR(cudaMemcpy2D(dest_start_ptr + dest_pixel_index, dest_pixel_step_y,\n                                                tile_data + nbytes_tile_index, nbytes_tw, nbytes_tile_pixel_size_x,\n                                                tile_pixel_offset_ey - tile_pixel_offset_sy + 1,\n                                                cudaMemcpyDeviceToDevice));\n                    }\n                    else\n                    {\n                        auto key = image_cache.create_key(ifd_hash_value, index);\n                        image_cache.lock(index_hash);\n                        auto value = image_cache.find(key);\n                        if (value)\n                        {\n                            image_cache.unlock(index_hash);\n                            tile_data = static_cast\u003cuint8_t*\u003e(value-\u003edata);\n                        }\n                        else\n                        {\n                            // Lifetime of tile_data is same with `value`\n                            // : do not access this data when `value` is not accessible.\n                            if (cache_type != cucim::cache::CacheType::kNoCache)\n                            {\n                                tile_data = static_cast\u003cuint8_t*\u003e(image_cache.allocate(tile_raster_nbytes));\n                            }\n                            else\n                            {\n                                // Allocate temporary buffer for tile data\n                                tile_raster = std::unique_ptr\u003cuint8_t, decltype(cucim_free)*\u003e(\n                                    reinterpret_cast\u003cuint8_t*\u003e(cucim_malloc(tile_raster_nbytes)), cucim_free);\n                                tile_data = tile_raster.get();\n                            }\n                            {\n                                PROF_SCOPED_RANGE(PROF_EVENT(ifd_decompression));\n                                switch (compression_method)\n                                {\n                                case COMPRESSION_NONE:\n                                    cuslide::raw::decode_raw(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                             \u0026tile_data, tile_raster_nbytes, out_device);\n                                    break;\n                                case COMPRESSION_JPEG:\n                                    cuslide::jpeg::decode_libjpeg(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                                  jpegtable_data, jpegtable_count, \u0026tile_data,\n                                                                  out_device, jpeg_color_space);\n                                    break;\n                                case COMPRESSION_ADOBE_DEFLATE:\n                                case COMPRESSION_DEFLATE:\n                                    cuslide::deflate::decode_deflate(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                                     \u0026tile_data, tile_raster_nbytes, out_device);\n                                    break;\n                                case cuslide::jpeg2k::kAperioJpeg2kYCbCr: // 33003\n                                    cuslide::jpeg2k::decode_libopenjpeg(tiff_file, nullptr, tiledata_offset,\n                                                                        tiledata_size, \u0026tile_data, tile_raster_nbytes,\n                                                                        out_device, cuslide::jpeg2k::ColorSpace::kSYCC);\n                                    break;\n                                case cuslide::jpeg2k::kAperioJpeg2kRGB: // 33005\n                                    cuslide::jpeg2k::decode_libopenjpeg(tiff_file, nullptr, tiledata_offset,\n                                                                        tiledata_size, \u0026tile_data, tile_raster_nbytes,\n                                                                        out_device, cuslide::jpeg2k::ColorSpace::kRGB);\n                                    break;\n                                case COMPRESSION_LZW:\n                                    cuslide::lzw::decode_lzw(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                             \u0026tile_data, tile_raster_nbytes, out_device);\n                                    // Apply unpredictor\n                                    //   1: none, 2: horizontal differencing, 3: floating point predictor\n                                    //   https://www.adobe.io/content/dam/udp/en/open/standards/tiff/TIFF6.pdf\n                                    if (predictor == 2)\n                                    {\n                                        cuslide::lzw::horAcc8(tile_data, tile_raster_nbytes, nbytes_tw);\n                                    }\n                                    break;\n                                default:\n                                    throw std::runtime_error(\"Unsupported compression method\");\n                                }\n                            }\n\n                            value = image_cache.create_value(tile_data, tile_raster_nbytes);\n                            image_cache.insert(key, value);\n                            image_cache.unlock(index_hash);\n                        }\n\n                        for (uint32_t ty = tile_pixel_offset_sy; ty \u003c= tile_pixel_offset_ey;\n                             ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                        {\n                            memcpy(dest_start_ptr + dest_pixel_index, tile_data + nbytes_tile_index,\n                                   nbytes_tile_pixel_size_x);\n                        }\n                    }\n                }\n                else\n                {\n                    if (out_device.type() == cucim::io::DeviceType::kCPU)\n                    {\n                        for (uint32_t ty = tile_pixel_offset_sy; ty \u003c= tile_pixel_offset_ey;\n                             ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                        {\n                            // Set background value such as (255,255,255)\n                            memset(dest_start_ptr + dest_pixel_index, background_value, nbytes_tile_pixel_size_x);\n                        }\n                    }\n                    else\n                    {\n                        cudaError_t cuda_status;\n                        CUDA_ERROR(cudaMemset2D(dest_start_ptr + dest_pixel_index, dest_pixel_step_y, background_value,\n                                                nbytes_tile_pixel_size_x,\n                                                tile_pixel_offset_ey - tile_pixel_offset_sy + 1));\n                    }\n                }\n            };\n\n            if (loader \u0026\u0026 *loader)\n            {\n                loader-\u003eenqueue(std::move(decode_func),\n                                cucim::loader::TileInfo{ location_index, index, tiledata_offset, tiledata_size });\n            }\n            else\n            {\n                decode_func();\n            }\n\n            dest_pixel_index_x += nbytes_tile_pixel_size_x;\n        }\n        dest_start_ptr += dest_pixel_step_y * dest_pixel_offset_len_y;\n    }\n\n    return true;\n}\n\nbool IFD::read_region_tiles_boundary(const TIFF* tiff,\n                                     const IFD* ifd,\n                                     const int64_t* location,\n                                     const int64_t location_index,\n                                     const int64_t w,\n                                     const int64_t h,\n                                     void* raster,\n                                     const cucim::io::Device\u0026 out_device,\n                                     cucim::loader::ThreadBatchDataLoader* loader)\n{\n    PROF_SCOPED_RANGE(PROF_EVENT(ifd_read_region_tiles_boundary));\n    (void)out_device;\n    // Reference code: https://github.com/libjpeg-turbo/libjpeg-turbo/blob/master/tjexample.c\n    int64_t sx = location[location_index * 2];\n    int64_t sy = location[location_index * 2 + 1];\n\n    uint8_t background_value = tiff-\u003ebackground_value_;\n    uint16_t compression_method = ifd-\u003ecompression_;\n    int jpeg_color_space = ifd-\u003ejpeg_color_space_;\n    int predictor = ifd-\u003epredictor_;\n\n    int64_t ex = sx + w - 1;\n    int64_t ey = sy + h - 1;\n\n    uint32_t width = ifd-\u003ewidth_;\n    uint32_t height = ifd-\u003eheight_;\n\n    // Memory for tile_raster would be manually allocated here, instead of using decode_libjpeg().\n    // Need to free the manually. Usually it is set to nullptr and memory is created by decode_libjpeg() by using\n    // tjAlloc() (Also need to free with tjFree() after use. See the documentation of tjAlloc() for the detail.)\n    const int pixel_size_nbytes = ifd-\u003epixel_size_nbytes();\n    auto dest_start_ptr = static_cast\u003cuint8_t*\u003e(raster);\n\n    bool is_out_of_image = (ex \u003c 0 || width \u003c= sx || ey \u003c 0 || height \u003c= sy);\n    if (is_out_of_image)\n    {\n        // Fill background color(255,255,255) and return\n        memset(dest_start_ptr, background_value, w * h * pixel_size_nbytes);\n        return true;\n    }\n    cucim::cache::ImageCache\u0026 image_cache = cucim::CuImage::cache_manager().cache();\n    cucim::cache::CacheType cache_type = image_cache.type();\n\n    uint32_t tw = ifd-\u003etile_width_;\n    uint32_t th = ifd-\u003etile_height_;\n\n    const size_t tile_raster_nbytes = tw * th * pixel_size_nbytes;\n\n    // TODO: revert this once we can get RGB data instead of RGBA\n    uint32_t samples_per_pixel = 3; // ifd-\u003esamples_per_pixel();\n\n    const void* jpegtable_data = ifd-\u003ejpegtable_.data();\n    uint32_t jpegtable_count = ifd-\u003ejpegtable_.size();\n\n    bool sx_in_range = (sx \u003e= 0 \u0026\u0026 sx \u003c width);\n    bool ex_in_range = (ex \u003e= 0 \u0026\u0026 ex \u003c width);\n    bool sy_in_range = (sy \u003e= 0 \u0026\u0026 sy \u003c height);\n    bool ey_in_range = (ey \u003e= 0 \u0026\u0026 ey \u003c height);\n\n    int64_t offset_boundary_x = (static_cast\u003cint64_t\u003e(width) - 1) / tw;\n    int64_t offset_boundary_y = (static_cast\u003cint64_t\u003e(height) - 1) / th;\n\n    int64_t offset_sx = sx / tw; // x-axis start offset for the requested region in the\n                                 // ifd tile array as grid\n\n    int64_t offset_ex = ex / tw; // x-axis end  offset for the requested region in the\n                                 // ifd tile array as grid\n\n    int64_t offset_sy = sy / th; // y-axis start offset for the requested region in the\n                                 // ifd tile array as grid\n    int64_t offset_ey = ey / th; // y-axis end offset for the requested region in the\n                                 // ifd tile array as grid\n    int64_t pixel_offset_sx = (sx % tw);\n    int64_t pixel_offset_ex = (ex % tw);\n    int64_t pixel_offset_sy = (sy % th);\n    int64_t pixel_offset_ey = (ey % th);\n    int64_t pixel_offset_boundary_x = ((width - 1) % tw);\n    int64_t pixel_offset_boundary_y = ((height - 1) % th);\n\n    // Make sure that division and modulo has same value with Python's one (e.g., making -1 / 3 == -1 instead of 0)\n    if (pixel_offset_sx \u003c 0)\n    {\n        pixel_offset_sx += tw;\n        --offset_sx;\n    }\n    if (pixel_offset_ex \u003c 0)\n    {\n        pixel_offset_ex += tw;\n        --offset_ex;\n    }\n    if (pixel_offset_sy \u003c 0)\n    {\n        pixel_offset_sy += th;\n        --offset_sy;\n    }\n    if (pixel_offset_ey \u003c 0)\n    {\n        pixel_offset_ey += th;\n        --offset_ey;\n    }\n    int64_t offset_min_x = sx_in_range ? offset_sx : 0;\n    int64_t offset_max_x = ex_in_range ? offset_ex : offset_boundary_x;\n    int64_t offset_min_y = sy_in_range ? offset_sy : 0;\n    int64_t offset_max_y = ey_in_range ? offset_ey : offset_boundary_y;\n\n    uint32_t stride_y = width / tw + !!(width % tw); // # of tiles in a row(y) in the ifd tile array as grid\n\n    int64_t start_index_y = offset_sy * stride_y;\n    int64_t start_index_min_y = offset_min_y * stride_y;\n    int64_t end_index_y = offset_ey * stride_y;\n    int64_t end_index_max_y = offset_max_y * stride_y;\n    int64_t boundary_index_y = offset_boundary_y * stride_y;\n\n\n    int tiff_file = tiff-\u003efile_handle_-\u003efd;\n    uint64_t ifd_hash_value = ifd-\u003ehash_value_;\n\n    uint32_t dest_pixel_step_y = w * samples_per_pixel;\n    uint32_t nbytes_tw = tw * samples_per_pixel;\n\n\n    // TODO: Current implementation doesn't consider endianness so need to consider later\n    // TODO: Consider tile's depth tag.\n    // TODO: update the type of variables (index, index_y) : other function uses uint32_t\n    for (int64_t index_y = start_index_y; index_y \u003c= end_index_y; index_y += stride_y)\n    {\n        uint32_t tile_pixel_offset_sy = (index_y == start_index_y) ? pixel_offset_sy : 0;\n        uint32_t tile_pixel_offset_ey = (index_y == end_index_y) ? pixel_offset_ey : (th - 1);\n        uint32_t dest_pixel_offset_len_y = tile_pixel_offset_ey - tile_pixel_offset_sy + 1;\n\n        uint32_t dest_pixel_index_x = 0;\n\n        int64_t index = index_y + offset_sx;\n        for (int64_t offset_x = offset_sx; offset_x \u003c= offset_ex; ++offset_x, ++index)\n        {\n            PROF_SCOPED_RANGE(PROF_EVENT_P(ifd_read_region_tiles_boundary_iter, index));\n            uint64_t tiledata_offset = 0;\n            uint64_t tiledata_size = 0;\n\n            // Calculate a simple hash value for the tile index\n            uint64_t index_hash = ifd_hash_value ^ (static_cast\u003cuint64_t\u003e(index) | (static_cast\u003cuint64_t\u003e(index) \u003c\u003c 32));\n\n            if (offset_x \u003e= offset_min_x \u0026\u0026 offset_x \u003c= offset_max_x \u0026\u0026 index_y \u003e= start_index_min_y \u0026\u0026\n                index_y \u003c= end_index_max_y)\n            {\n                tiledata_offset = static_cast\u003cuint64_t\u003e(ifd-\u003eimage_piece_offsets_[index]);\n                tiledata_size = static_cast\u003cuint64_t\u003e(ifd-\u003eimage_piece_bytecounts_[index]);\n            }\n\n            uint32_t tile_pixel_offset_x = (offset_x == offset_sx) ? pixel_offset_sx : 0;\n            uint32_t nbytes_tile_pixel_size_x = (offset_x == offset_ex) ?\n                                                    (pixel_offset_ex - tile_pixel_offset_x + 1) * samples_per_pixel :\n                                                    (tw - tile_pixel_offset_x) * samples_per_pixel;\n\n            uint32_t nbytes_tile_index_orig = (tile_pixel_offset_sy * tw + tile_pixel_offset_x) * samples_per_pixel;\n            uint32_t dest_pixel_index_orig = dest_pixel_index_x;\n\n            auto decode_func = [=, \u0026image_cache]() {\n                PROF_SCOPED_RANGE(PROF_EVENT_P(ifd_read_region_tiles_boundary_task, index_hash));\n                uint32_t nbytes_tile_index = nbytes_tile_index_orig;\n                uint32_t dest_pixel_index = dest_pixel_index_orig;\n\n                if (tiledata_size \u003e 0)\n                {\n                    bool copy_partial = false;\n                    uint32_t fixed_nbytes_tile_pixel_size_x = nbytes_tile_pixel_size_x;\n                    uint32_t fixed_tile_pixel_offset_ey = tile_pixel_offset_ey;\n\n                    if (offset_x == offset_boundary_x)\n                    {\n                        copy_partial = true;\n                        if (offset_x != offset_ex)\n                        {\n                            fixed_nbytes_tile_pixel_size_x =\n                                (pixel_offset_boundary_x - tile_pixel_offset_x + 1) * samples_per_pixel;\n                        }\n                        else\n                        {\n                            fixed_nbytes_tile_pixel_size_x =\n                                (std::min(pixel_offset_boundary_x, pixel_offset_ex) - tile_pixel_offset_x + 1) *\n                                samples_per_pixel;\n                        }\n                    }\n                    if (index_y == boundary_index_y)\n                    {\n                        copy_partial = true;\n                        if (index_y != end_index_y)\n                        {\n                            fixed_tile_pixel_offset_ey = pixel_offset_boundary_y;\n                        }\n                        else\n                        {\n                            fixed_tile_pixel_offset_ey = std::min(pixel_offset_boundary_y, pixel_offset_ey);\n                        }\n                    }\n\n                    uint8_t* tile_data = nullptr;\n                    std::unique_ptr\u003cuint8_t, decltype(cucim_free)*\u003e tile_raster =\n                        std::unique_ptr\u003cuint8_t, decltype(cucim_free)*\u003e(nullptr, cucim_free);\n\n                    if (loader \u0026\u0026 loader-\u003ebatch_data_processor())\n                    {\n                        switch (compression_method)\n                        {\n                        case COMPRESSION_JPEG:\n                            break;\n                        default:\n                            throw std::runtime_error(\"Unsupported compression method\");\n                        }\n                        auto value = loader-\u003ewait_for_processing(index);\n                        if (!value) // if shutdown\n                        {\n                            return;\n                        }\n\n                        tile_data = static_cast\u003cuint8_t*\u003e(value-\u003edata);\n\n                        cudaError_t cuda_status;\n                        if (copy_partial)\n                        {\n                            uint32_t fill_gap_x = nbytes_tile_pixel_size_x - fixed_nbytes_tile_pixel_size_x;\n                            // Fill original, then fill white for remaining\n                            if (fill_gap_x \u003e 0)\n                            {\n                                CUDA_ERROR(cudaMemcpy2D(\n                                    dest_start_ptr + dest_pixel_index, dest_pixel_step_y, tile_data + nbytes_tile_index,\n                                    nbytes_tw, fixed_nbytes_tile_pixel_size_x,\n                                    fixed_tile_pixel_offset_ey - tile_pixel_offset_sy + 1, cudaMemcpyDeviceToDevice));\n                                CUDA_ERROR(cudaMemset2D(dest_start_ptr + dest_pixel_index + fixed_nbytes_tile_pixel_size_x,\n                                                        dest_pixel_step_y, background_value, fill_gap_x,\n                                                        fixed_tile_pixel_offset_ey - tile_pixel_offset_sy + 1));\n                                dest_pixel_index +=\n                                    dest_pixel_step_y * (fixed_tile_pixel_offset_ey - tile_pixel_offset_sy + 1);\n                            }\n                            else\n                            {\n                                CUDA_ERROR(cudaMemcpy2D(\n                                    dest_start_ptr + dest_pixel_index, dest_pixel_step_y, tile_data + nbytes_tile_index,\n                                    nbytes_tw, fixed_nbytes_tile_pixel_size_x,\n                                    fixed_tile_pixel_offset_ey - tile_pixel_offset_sy + 1, cudaMemcpyDeviceToDevice));\n                                dest_pixel_index +=\n                                    dest_pixel_step_y * (fixed_tile_pixel_offset_ey - tile_pixel_offset_sy + 1);\n                            }\n\n                            CUDA_ERROR(cudaMemset2D(dest_start_ptr + dest_pixel_index, dest_pixel_step_y,\n                                                    background_value, nbytes_tile_pixel_size_x,\n                                                    tile_pixel_offset_ey - (fixed_tile_pixel_offset_ey + 1) + 1));\n                        }\n                        else\n                        {\n                            CUDA_ERROR(cudaMemcpy2D(dest_start_ptr + dest_pixel_index, dest_pixel_step_y,\n                                                    tile_data + nbytes_tile_index, nbytes_tw, nbytes_tile_pixel_size_x,\n                                                    tile_pixel_offset_ey - tile_pixel_offset_sy + 1,\n                                                    cudaMemcpyDeviceToDevice));\n                        }\n                    }\n                    else\n                    {\n                        auto key = image_cache.create_key(ifd_hash_value, index);\n                        image_cache.lock(index_hash);\n                        auto value = image_cache.find(key);\n                        if (value)\n                        {\n                            image_cache.unlock(index_hash);\n                            tile_data = static_cast\u003cuint8_t*\u003e(value-\u003edata);\n                        }\n                        else\n                        {\n                            // Lifetime of tile_data is same with `value`\n                            // : do not access this data when `value` is not accessible.\n                            if (cache_type != cucim::cache::CacheType::kNoCache)\n                            {\n                                tile_data = static_cast\u003cuint8_t*\u003e(image_cache.allocate(tile_raster_nbytes));\n                            }\n                            else\n                            {\n                                // Allocate temporary buffer for tile data\n                                tile_raster = std::unique_ptr\u003cuint8_t, decltype(cucim_free)*\u003e(\n                                    reinterpret_cast\u003cuint8_t*\u003e(cucim_malloc(tile_raster_nbytes)), cucim_free);\n                                tile_data = tile_raster.get();\n                            }\n                            {\n                                PROF_SCOPED_RANGE(PROF_EVENT(ifd_decompression));\n                                switch (compression_method)\n                                {\n                                case COMPRESSION_NONE:\n                                    cuslide::raw::decode_raw(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                             \u0026tile_data, tile_raster_nbytes, out_device);\n                                    break;\n                                case COMPRESSION_JPEG:\n                                    cuslide::jpeg::decode_libjpeg(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                                  jpegtable_data, jpegtable_count, \u0026tile_data,\n                                                                  out_device, jpeg_color_space);\n                                    break;\n                                case COMPRESSION_ADOBE_DEFLATE:\n                                case COMPRESSION_DEFLATE:\n                                    cuslide::deflate::decode_deflate(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                                     \u0026tile_data, tile_raster_nbytes, out_device);\n                                    break;\n                                case cuslide::jpeg2k::kAperioJpeg2kYCbCr: // 33003\n                                    cuslide::jpeg2k::decode_libopenjpeg(tiff_file, nullptr, tiledata_offset,\n                                                                        tiledata_size, \u0026tile_data, tile_raster_nbytes,\n                                                                        out_device, cuslide::jpeg2k::ColorSpace::kSYCC);\n                                    break;\n                                case cuslide::jpeg2k::kAperioJpeg2kRGB: // 33005\n                                    cuslide::jpeg2k::decode_libopenjpeg(tiff_file, nullptr, tiledata_offset,\n                                                                        tiledata_size, \u0026tile_data, tile_raster_nbytes,\n                                                                        out_device, cuslide::jpeg2k::ColorSpace::kRGB);\n                                    break;\n                                case COMPRESSION_LZW:\n                                    cuslide::lzw::decode_lzw(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                             \u0026tile_data, tile_raster_nbytes, out_device);\n                                    // Apply unpredictor\n                                    //   1: none, 2: horizontal differencing, 3: floating point predictor\n                                    //   https://www.adobe.io/content/dam/udp/en/open/standards/tiff/TIFF6.pdf\n                                    if (predictor == 2)\n                                    {\n                                        cuslide::lzw::horAcc8(tile_data, tile_raster_nbytes, nbytes_tw);\n                                    }\n                                    break;\n                                default:\n                                    throw std::runtime_error(\"Unsupported compression method\");\n                                }\n                            }\n                            value = image_cache.create_value(tile_data, tile_raster_nbytes);\n                            image_cache.insert(key, value);\n                            image_cache.unlock(index_hash);\n                        }\n                        if (copy_partial)\n                        {\n                            uint32_t fill_gap_x = nbytes_tile_pixel_size_x - fixed_nbytes_tile_pixel_size_x;\n                            // Fill original, then fill white for remaining\n                            if (fill_gap_x \u003e 0)\n                            {\n                                for (uint32_t ty = tile_pixel_offset_sy; ty \u003c= fixed_tile_pixel_offset_ey;\n                                     ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                                {\n                                    memcpy(dest_start_ptr + dest_pixel_index, tile_data + nbytes_tile_index,\n                                           fixed_nbytes_tile_pixel_size_x);\n                                    memset(dest_start_ptr + dest_pixel_index + fixed_nbytes_tile_pixel_size_x,\n                                           background_value, fill_gap_x);\n                                }\n                            }\n                            else\n                            {\n                                for (uint32_t ty = tile_pixel_offset_sy; ty \u003c= fixed_tile_pixel_offset_ey;\n                                     ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                                {\n                                    memcpy(dest_start_ptr + dest_pixel_index, tile_data + nbytes_tile_index,\n                                           fixed_nbytes_tile_pixel_size_x);\n                                }\n                            }\n\n                            for (uint32_t ty = fixed_tile_pixel_offset_ey + 1; ty \u003c= tile_pixel_offset_ey;\n                                 ++ty, dest_pixel_index += dest_pixel_step_y)\n                            {\n                                memset(dest_start_ptr + dest_pixel_index, background_value, nbytes_tile_pixel_size_x);\n                            }\n                        }\n                        else\n                        {\n                            for (uint32_t ty = tile_pixel_offset_sy; ty \u003c= tile_pixel_offset_ey;\n                                 ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                            {\n                                memcpy(dest_start_ptr + dest_pixel_index, tile_data + nbytes_tile_index,\n                                       nbytes_tile_pixel_size_x);\n                            }\n                        }\n                    }\n                }\n                else\n                {\n\n                    if (out_device.type() == cucim::io::DeviceType::kCPU)\n                    {\n                        for (uint32_t ty = tile_pixel_offset_sy; ty \u003c= tile_pixel_offset_ey;\n                             ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                        {\n                            // Set (255,255,255)\n                            memset(dest_start_ptr + dest_pixel_index, background_value, nbytes_tile_pixel_size_x);\n                        }\n                    }\n                    else\n                    {\n                        cudaError_t cuda_status;\n                        CUDA_ERROR(cudaMemset2D(dest_start_ptr + dest_pixel_index, dest_pixel_step_y, background_value,\n                                                nbytes_tile_pixel_size_x, tile_pixel_offset_ey - tile_pixel_offset_sy));\n                    }\n                }\n            };\n\n            if (loader \u0026\u0026 *loader)\n            {\n                loader-\u003eenqueue(std::move(decode_func),\n                                cucim::loader::TileInfo{ location_index, index, tiledata_offset, tiledata_size });\n            }\n            else\n            {\n                decode_func();\n            }\n\n            dest_pixel_index_x += nbytes_tile_pixel_size_x;\n        }\n        dest_start_ptr += dest_pixel_step_y * dest_pixel_offset_len_y;\n    }\n    return true;\n}\n\n} // namespace cuslide::tiff\n\n\n// Hidden methods for benchmarking.\n\n#include \u003cfmt/format.h\u003e\n#include \u003clanginfo.h\u003e\n#include \u003ciostream\u003e\n#include \u003cfstream\u003e\n\nnamespace cuslide::tiff\n{\nvoid IFD::write_offsets_(const char* file_path)\n{\n    std::ofstream offsets(fmt::format(\"{}.offsets\", file_path), std::ios::out | std::ios::binary | std::ios::trunc);\n    std::ofstream bytecounts(fmt::format(\"{}.bytecounts\", file_path), std::ios::out | std::ios::binary | std::ios::trunc);\n\n    offsets.write(reinterpret_cast\u003cchar*\u003e(\u0026image_piece_count_), sizeof(image_piece_count_));\n    bytecounts.write(reinterpret_cast\u003cchar*\u003e(\u0026image_piece_count_), sizeof(image_piece_count_));\n    for (uint32_t i = 0; i \u003c image_piece_count_; i++)\n    {\n        offsets.write(reinterpret_cast\u003cchar*\u003e(\u0026image_piece_offsets_[i]), sizeof(image_piece_offsets_[i]));\n        bytecounts.write(reinterpret_cast\u003cchar*\u003e(\u0026image_piece_bytecounts_[i]), sizeof(image_piece_bytecounts_[i]));\n    }\n    bytecounts.close();\n    offsets.close();\n}\n\n} // namespace cuslide::tiff\n",
        "name": "ifd.cpp",
        "path": "cpp/plugins/cucim.kit.cuslide/src/cuslide/tiff/ifd.cpp",
        "url": "/github.com/rapidsai/cucim/-/blob/cpp/plugins/cucim.kit.cuslide/src/cuslide/tiff/ifd.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 369,
          "offsetAndLengths": [
            [
              25,
              16
            ]
          ],
          "preview": "                    if (!TIFFRGBAImageGet(\u0026img, (uint32_t*)raster, w, h))"
        }
      ],
      "repository": {
        "name": "github.com/rapidsai/cucim",
        "url": "/github.com/rapidsai/cucim"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23b9043a2bd576e90bb542f1f76be2d6bfb5fd3c"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "thirdparty/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/opentoonz/opentoonz/-/blob/thirdparty/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/opentoonz/opentoonz",
        "url": "/github.com/opentoonz/opentoonz"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "b6715ba10ccc73bcdd51b221e3d05e393d14ede4"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "thirdparty/tiff-4.2.0/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/tahoma2d/tahoma2d/-/blob/thirdparty/tiff-4.2.0/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/tahoma2d/tahoma2d",
        "url": "/github.com/tahoma2d/tahoma2d"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a09a46246168a6bb8e8e32a5eb8256440690f6bc"
        },
        "content": "#include \"StdAfx.h\"\n\n// #define STRICT\n#include \"diblib.h\"\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e // MAX_ constants\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage\n{\n    TIFFRGBAImage tif;\n    int dibinstalled;\n};\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster);\n\nstatic void MyWarningHandler(const char *module, const char *fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void MyErrorHandler(const char *module, const char *fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF(LPCTSTR lpszPath)\n{\n    int rtn = 0;\n\n    TIFFErrorHandler eh;\n    TIFFErrorHandler wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF *tif = TIFFOpen(lpszPath, \"r\");\n    if (tif)\n    {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage *img);\n\nPVOID ReadTIFF(LPCTSTR lpszPath)\n{\n    void *pDIB = 0;\n    TIFFErrorHandler wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath))\n    {\n        TIFF *tif = TIFFOpen(lpszPath, \"r\");\n        if (tif)\n        {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg))\n            {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg))\n                {\n                    size_t npixels;\n                    uint32_t *raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster =\n                        (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n                    if (raster != NULL)\n                    {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width,\n                                             img.tif.height))\n                        {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else\n            {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg);\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster)\n{\n    void *pDIB = 0;\n    TIFFRGBAImage *img = \u0026dib-\u003etif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER bi;\n    int dwDIBSize;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if (BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled)\n    { // bilevel\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 1;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(\u0026bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed = 0;\n        pRgbq[0].rgbBlue = 0;\n        pRgbq[0].rgbGreen = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed = 255;\n        pRgbq[1].rgbBlue = 255;\n        pRgbq[1].rgbGreen = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr(\n            (BITMAPINFOHEADER *)pDIB); //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n    //  For now just always default to the RGB 32 bit form. // save as 32 bit\n    //  for simplicity\n    else if (true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/)\n    { // 24 bit color\n\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 32;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(\u0026bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        // Swap the byte order while copying\n        for (int i = 0; i \u003c sizeWords; ++i)\n        {\n            rgbDib[i].rgbRed = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n#define DECLAREContigPutFunc(name)                                             \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *pp)\n\n#define DECLARESepPutFunc(name)                                                \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *r, u_char *g, u_char *b, u_char *a)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *uraster, uint32_t w,\n                              uint32_t h);\n\n// typdef struct TIFFDibImage {\n//     TIFFRGBAImage tif;\n//     dibinstalled;\n// } TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage *dib)\n{\n    TIFFRGBAImage *img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric)\n    {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n            switch (img-\u003ebitspersample)\n            {\n                case 1:\n                    img-\u003eput.contig = putContig1bitTile;\n                    img-\u003eget = getStripContig1Bit;\n                    dib-\u003edibinstalled = true;\n                    break;\n            }\n            break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void)y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char *ucp = (u_char *)cp;\n\n    /* Convert 'w' to bytes from pixels (rounded up) */\n    w = (w + 7) / 8;\n\n    while (h-- \u003e 0)\n    {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32_t setorientation(TIFFRGBAImage *img, uint32_t h)\n{\n    TIFF *tif = img-\u003etif;\n    uint32_t y;\n\n    switch (img-\u003eorientation)\n    {\n        case ORIENTATION_BOTRIGHT:\n        case ORIENTATION_RIGHTBOT: /* XXX */\n        case ORIENTATION_LEFTBOT:  /* XXX */\n            TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n            img-\u003eorientation = ORIENTATION_BOTLEFT;\n        /* fall through... */\n        case ORIENTATION_BOTLEFT:\n            y = 0;\n            break;\n        case ORIENTATION_TOPRIGHT:\n        case ORIENTATION_RIGHTTOP: /* XXX */\n        case ORIENTATION_LEFTTOP:  /* XXX */\n        default:\n            TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n            img-\u003eorientation = ORIENTATION_TOPLEFT;\n        /* fall through... */\n        case ORIENTATION_TOPLEFT:\n            y = h - 1;\n            break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *raster, uint32_t w,\n                              uint32_t h)\n{\n    TIFF *tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16_t orientation;\n    uint32_t row, y, nrow, rowstoread;\n    uint32_t pos;\n    u_char *buf;\n    uint32_t rowsperstrip;\n    uint32_t imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32_t fromskew, toskew;\n    tstrip_t strip;\n    tsize_t stripsize;\n    u_char *braster = (u_char *)raster; // byte wide raster\n    uint32_t wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char *)_TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32_t)(orientation == ORIENTATION_TOPLEFT ? wb + wb : wb - wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0) / 8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif, row + img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset) % rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize) \u003c 0 \u0026\u0026\n            img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32_t *)(braster + y * wb), 0, y, w, nrow, fromskew,\n               toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ? -(int32_t)nrow\n                                                 : (int32_t)nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n",
        "name": "Tiffile.cpp",
        "path": "tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/ArtifexSoftware/ghostpdl/-/blob/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 112,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width,"
        }
      ],
      "repository": {
        "name": "github.com/ArtifexSoftware/ghostpdl",
        "url": "/github.com/ArtifexSoftware/ghostpdl"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "24960575263e1c13c2234b1305eab90a7364ff82"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n",
        "name": "Tiffile.cpp",
        "path": "third_party/codecs/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/google/sagetv/-/blob/third_party/codecs/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/google/sagetv",
        "url": "/github.com/google/sagetv"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "8123ecb826d8bd1cfa990909cc64e70219f7d959"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "extensions/android/ringlibsdl/project/jni/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/ring-lang/ring/-/blob/extensions/android/ringlibsdl/project/jni/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/ring-lang/ring",
        "url": "/github.com/ring-lang/ring"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "62b4d098d1472c3534dd098ca2a0e0e10712f1c6"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "external/SDL2_image-2.0.6/external/tiff-4.0.9/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/ValveSoftware/steamlink-sdk/-/blob/external/SDL2_image-2.0.6/external/tiff-4.0.9/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/ValveSoftware/steamlink-sdk",
        "url": "/github.com/ValveSoftware/steamlink-sdk"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "268c102e8fbe59c377dfe542cd4bb728f5523a95"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "external/SDL2_image/external/tiff-4.0.9/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/SpaceManiac/HamSandwich/-/blob/external/SDL2_image/external/tiff-4.0.9/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/SpaceManiac/HamSandwich",
        "url": "/github.com/SpaceManiac/HamSandwich"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "126e4aad9f287a1496cd966018f5d7faa674523a"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "indigo_libs/externals/libtiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/indigo-astronomy/indigo/-/blob/indigo_libs/externals/libtiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/indigo-astronomy/indigo",
        "url": "/github.com/indigo-astronomy/indigo"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "8123ecb826d8bd1cfa990909cc64e70219f7d959"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "extensions/android/ringlibsdl/project/jni/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/ring-lang/ring/-/blob/extensions/android/ringlibsdl/project/jni/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/ring-lang/ring",
        "url": "/github.com/ring-lang/ring"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "0c0258c63055d8b2cd57109245bf2e206700cf07"
        },
        "content": "#include \"StdAfx.h\"\n\n// #define STRICT\n#include \"diblib.h\"\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e // MAX_ constants\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage\n{\n    TIFFRGBAImage tif;\n    int dibinstalled;\n};\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster);\n\nstatic void MyWarningHandler(const char *module, const char *fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void MyErrorHandler(const char *module, const char *fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF(LPCTSTR lpszPath)\n{\n    int rtn = 0;\n\n    TIFFErrorHandler eh;\n    TIFFErrorHandler wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF *tif = TIFFOpen(lpszPath, \"r\");\n    if (tif)\n    {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage *img);\n\nPVOID ReadTIFF(LPCTSTR lpszPath)\n{\n    void *pDIB = 0;\n    TIFFErrorHandler wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath))\n    {\n        TIFF *tif = TIFFOpen(lpszPath, \"r\");\n        if (tif)\n        {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg))\n            {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg))\n                {\n                    size_t npixels;\n                    uint32_t *raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster =\n                        (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n                    if (raster != NULL)\n                    {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width,\n                                             img.tif.height))\n                        {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else\n            {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg);\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster)\n{\n    void *pDIB = 0;\n    TIFFRGBAImage *img = \u0026dib-\u003etif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER bi;\n    int dwDIBSize;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if (BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled)\n    { // bilevel\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 1;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(\u0026bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed = 0;\n        pRgbq[0].rgbBlue = 0;\n        pRgbq[0].rgbGreen = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed = 255;\n        pRgbq[1].rgbBlue = 255;\n        pRgbq[1].rgbGreen = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr(\n            (BITMAPINFOHEADER *)pDIB); //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n    //  For now just always default to the RGB 32 bit form. // save as 32 bit\n    //  for simplicity\n    else if (true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/)\n    { // 24 bit color\n\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 32;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(\u0026bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        // Swap the byte order while copying\n        for (int i = 0; i \u003c sizeWords; ++i)\n        {\n            rgbDib[i].rgbRed = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n#define DECLAREContigPutFunc(name)                                             \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *pp)\n\n#define DECLARESepPutFunc(name)                                                \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *r, u_char *g, u_char *b, u_char *a)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *uraster, uint32_t w,\n                              uint32_t h);\n\n// typdef struct TIFFDibImage {\n//     TIFFRGBAImage tif;\n//     dibinstalled;\n// } TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage *dib)\n{\n    TIFFRGBAImage *img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric)\n    {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n            switch (img-\u003ebitspersample)\n            {\n                case 1:\n                    img-\u003eput.contig = putContig1bitTile;\n                    img-\u003eget = getStripContig1Bit;\n                    dib-\u003edibinstalled = true;\n                    break;\n            }\n            break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void)y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char *ucp = (u_char *)cp;\n\n    /* Convert 'w' to bytes from pixels (rounded up) */\n    w = (w + 7) / 8;\n\n    while (h-- \u003e 0)\n    {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32_t setorientation(TIFFRGBAImage *img, uint32_t h)\n{\n    TIFF *tif = img-\u003etif;\n    uint32_t y;\n\n    switch (img-\u003eorientation)\n    {\n        case ORIENTATION_BOTRIGHT:\n        case ORIENTATION_RIGHTBOT: /* XXX */\n        case ORIENTATION_LEFTBOT:  /* XXX */\n            TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n            img-\u003eorientation = ORIENTATION_BOTLEFT;\n        /* fall through... */\n        case ORIENTATION_BOTLEFT:\n            y = 0;\n            break;\n        case ORIENTATION_TOPRIGHT:\n        case ORIENTATION_RIGHTTOP: /* XXX */\n        case ORIENTATION_LEFTTOP:  /* XXX */\n        default:\n            TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n            img-\u003eorientation = ORIENTATION_TOPLEFT;\n        /* fall through... */\n        case ORIENTATION_TOPLEFT:\n            y = h - 1;\n            break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *raster, uint32_t w,\n                              uint32_t h)\n{\n    TIFF *tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16_t orientation;\n    uint32_t row, y, nrow, rowstoread;\n    uint32_t pos;\n    u_char *buf;\n    uint32_t rowsperstrip;\n    uint32_t imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32_t fromskew, toskew;\n    tstrip_t strip;\n    tsize_t stripsize;\n    u_char *braster = (u_char *)raster; // byte wide raster\n    uint32_t wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char *)_TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32_t)(orientation == ORIENTATION_TOPLEFT ? wb + wb : wb - wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0) / 8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif, row + img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset) % rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize) \u003c 0 \u0026\u0026\n            img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32_t *)(braster + y * wb), 0, y, w, nrow, fromskew,\n               toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ? -(int32_t)nrow\n                                                 : (int32_t)nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n",
        "name": "Tiffile.cpp",
        "path": "lib/libtiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/ravynsoft/ravynos/-/blob/lib/libtiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 112,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width,"
        }
      ],
      "repository": {
        "name": "github.com/ravynsoft/ravynos",
        "url": "/github.com/ravynsoft/ravynos"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "7c3e0a2b3dc1cee743f5d5cadf47ffdecdbfebfa"
        },
        "content": "#include \"StdAfx.h\"\r\n\r\n//#define STRICT\r\n#include \u003cwindows.h\u003e\r\n#include \u003cwindowsx.h\u003e\r\n#include \u003ccommdlg.h\u003e\r\n#include \u003cstdlib.h\u003e                     // MAX_ constants\r\n#include \"diblib.h\"\r\n\r\n/*--------------------------------------------------------------------\r\n        READ TIFF\r\n        Load the TIFF data from the file into memory.  Return\r\n        a pointer to a valid DIB (or NULL for errors).\r\n        Uses the TIFFRGBA interface to libtiff.lib to convert\r\n        most file formats to a useable form.  We just keep the 32 bit\r\n        form of the data to display, rather than optimizing for the\r\n        display.\r\n\r\n        Main entry points:\r\n\r\n            int ChkTIFF ( LPCTSTR lpszPath )\r\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\r\n\r\n        RETURN\r\n            A valid DIB pointer for success; NULL for failure.\r\n\r\n  --------------------------------------------------------------------*/\r\n\r\n#include \"TiffLib/tiff.h\"\r\n#include \"TiffLib/tiffio.h\"\r\n#include \u003cassert.h\u003e\r\n#include \u003cstdio.h\u003e\r\n\r\n\r\n// piggyback some data on top of the RGBA Image\r\nstruct TIFFDibImage {\r\n    TIFFRGBAImage tif;\r\n    int  dibinstalled;\r\n} ;\r\n\r\n\r\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\r\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\r\n\r\nstatic void\r\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\r\n{\r\n    // ignore all warnings (unused tags, etc)\r\n    return;\r\n}\r\n\r\nstatic void\r\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\r\n{\r\n    return;\r\n}\r\n\r\n//  Turn off the error and warning handlers to check if a valid file.\r\n//  Necessary because of the way that the Doc loads images and restart files.\r\nint ChkTIFF ( LPCTSTR lpszPath )\r\n{\r\n    int rtn = 0;\r\n\r\n    TIFFErrorHandler  eh;\r\n    TIFFErrorHandler  wh;\r\n\r\n    eh = TIFFSetErrorHandler(NULL);\r\n    wh = TIFFSetWarningHandler(NULL);\r\n\r\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\r\n    if (tif) {\r\n        rtn = 1;\r\n        TIFFClose(tif);\r\n    }\r\n\r\n    TIFFSetErrorHandler(eh);\r\n    TIFFSetWarningHandler(wh);\r\n\r\n    return rtn;\r\n}\r\n\r\nvoid DibInstallHack(TIFFDibImage* img) ;\r\n\r\nPVOID ReadTIFF ( LPCTSTR lpszPath )\r\n{\r\n    void*             pDIB = 0;\r\n    TIFFErrorHandler  wh;\r\n\r\n    wh = TIFFSetWarningHandler(MyWarningHandler);\r\n\r\n    if (ChkTIFF(lpszPath)) {\r\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\r\n        if (tif) {\r\n            char emsg[1024];\r\n\r\n            if (TIFFRGBAImageOK(tif, emsg)) {\r\n                TIFFDibImage img;\r\n                char emsg[1024];\r\n\r\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\r\n                    size_t npixels;\r\n                    uint32* raster;\r\n\r\n                    DibInstallHack(\u0026img);\r\n\r\n                    npixels = img.tif.width * img.tif.height;\r\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\r\n                    if (raster != NULL) {\r\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\r\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\r\n                        }\r\n                    }\r\n                    _TIFFfree(raster);\r\n                }\r\n                TIFFRGBAImageEnd(\u0026img.tif);\r\n            }\r\n            else {\r\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\r\n            }\r\n            TIFFClose(tif);\r\n        }\r\n    }\r\n\r\n    TIFFSetWarningHandler(wh);\r\n\r\n    return pDIB;\r\n}\r\n\r\n\r\n\r\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\r\n{\r\n    void*   pDIB = 0;\r\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\r\n\r\n    uint32 imageLength;\r\n    uint32 imageWidth;\r\n    uint16 BitsPerSample;\r\n    uint16 SamplePerPixel;\r\n    uint32 RowsPerStrip;\r\n    uint16 PhotometricInterpretation;\r\n\r\n    BITMAPINFOHEADER   bi;\r\n    int                dwDIBSize ;\r\n\r\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\r\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\r\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\r\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\r\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\r\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\r\n\r\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\r\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\r\n        bi.biWidth          = imageWidth;\r\n        bi.biHeight         = imageLength;\r\n        bi.biPlanes         = 1;  // always\r\n        bi.biBitCount       = 1;\r\n        bi.biCompression    = BI_RGB;\r\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\r\n        bi.biXPelsPerMeter  = 0;\r\n        bi.biYPelsPerMeter  = 0;\r\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\r\n        bi.biClrImportant   = 0;  // always\r\n\r\n        // Get the size of the DIB\r\n        dwDIBSize = GetDIBSize( \u0026bi );\r\n\r\n        // Allocate for the BITMAPINFO structure and the color table.\r\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\r\n        if (pDIB == 0) {\r\n            return( NULL );\r\n        }\r\n\r\n        // Copy the header info\r\n        *((BITMAPINFOHEADER*)pDIB) = bi;\r\n\r\n        // Get a pointer to the color table\r\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\r\n\r\n        pRgbq[0].rgbRed      = 0;\r\n        pRgbq[0].rgbBlue     = 0;\r\n        pRgbq[0].rgbGreen    = 0;\r\n        pRgbq[0].rgbReserved = 0;\r\n        pRgbq[1].rgbRed      = 255;\r\n        pRgbq[1].rgbBlue     = 255;\r\n        pRgbq[1].rgbGreen    = 255;\r\n        pRgbq[1].rgbReserved = 255;\r\n\r\n        // Pointers to the bits\r\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\r\n        //\r\n        // In the BITMAPINFOHEADER documentation, it appears that\r\n        // there should be no color table for 32 bit images, but\r\n        // experience shows that the image is off by 3 words if it\r\n        // is not included.  So here it is.\r\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\r\n\r\n        int       sizeWords = bi.biSizeImage/4;\r\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\r\n        long*     rgbTif = (long*)raster;\r\n\r\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\r\n    }\r\n\r\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\r\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\r\n\r\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\r\n        bi.biWidth          = imageWidth;\r\n        bi.biHeight         = imageLength;\r\n        bi.biPlanes         = 1;  // always\r\n        bi.biBitCount       = 32;\r\n        bi.biCompression    = BI_RGB;\r\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\r\n        bi.biXPelsPerMeter  = 0;\r\n        bi.biYPelsPerMeter  = 0;\r\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\r\n        bi.biClrImportant   = 0;  // always\r\n\r\n        // Get the size of the DIB\r\n        dwDIBSize = GetDIBSize( \u0026bi );\r\n\r\n        // Allocate for the BITMAPINFO structure and the color table.\r\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\r\n        if (pDIB == 0) {\r\n            return( NULL );\r\n        }\r\n\r\n        // Copy the header info\r\n        *((BITMAPINFOHEADER*)pDIB) = bi;\r\n\r\n        // Get a pointer to the color table\r\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\r\n\r\n        // Pointers to the bits\r\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\r\n        //\r\n        // In the BITMAPINFOHEADER documentation, it appears that\r\n        // there should be no color table for 32 bit images, but\r\n        // experience shows that the image is off by 3 words if it\r\n        // is not included.  So here it is.\r\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\r\n\r\n        int       sizeWords = bi.biSizeImage/4;\r\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\r\n        long*     rgbTif = (long*)raster;\r\n\r\n        // Swap the byte order while copying\r\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\r\n        {\r\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\r\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\r\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\r\n            rgbDib[i].rgbReserved = 0;\r\n        }\r\n    }\r\n\r\n    return pDIB;\r\n}\r\n\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////\r\n//\r\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\r\n//\r\n//\r\ntypedef unsigned char u_char;\r\n\r\n\r\n#define DECLAREContigPutFunc(name) \\\r\nstatic void name(\\\r\n    TIFFRGBAImage* img, \\\r\n    uint32* cp, \\\r\n    uint32 x, uint32 y, \\\r\n    uint32 w, uint32 h, \\\r\n    int32 fromskew, int32 toskew, \\\r\n    u_char* pp \\\r\n)\r\n\r\n#define DECLARESepPutFunc(name) \\\r\nstatic void name(\\\r\n    TIFFRGBAImage* img,\\\r\n    uint32* cp,\\\r\n    uint32 x, uint32 y, \\\r\n    uint32 w, uint32 h,\\\r\n    int32 fromskew, int32 toskew,\\\r\n    u_char* r, u_char* g, u_char* b, u_char* a\\\r\n)\r\n\r\nDECLAREContigPutFunc(putContig1bitTile);\r\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\r\n\r\n//typdef struct TIFFDibImage {\r\n//    TIFFRGBAImage tif;\r\n//    dibinstalled;\r\n//} TIFFDibImage ;\r\n\r\nvoid DibInstallHack(TIFFDibImage* dib) {\r\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\r\n    dib-\u003edibinstalled = false;\r\n    switch (img-\u003ephotometric) {\r\n        case PHOTOMETRIC_MINISWHITE:\r\n        case PHOTOMETRIC_MINISBLACK:\r\n        switch (img-\u003ebitspersample) {\r\n            case 1:\r\n                img-\u003eput.contig = putContig1bitTile;\r\n                img-\u003eget = getStripContig1Bit;\r\n                dib-\u003edibinstalled = true;\r\n                break;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\n/*\r\n * 1-bit packed samples =\u003e 1-bit\r\n *\r\n *   Override to just copy the data\r\n */\r\nDECLAREContigPutFunc(putContig1bitTile)\r\n{\r\n    int samplesperpixel = img-\u003esamplesperpixel;\r\n\r\n    (void) y;\r\n    fromskew *= samplesperpixel;\r\n    int wb = WIDTHBYTES(w);\r\n    u_char*  ucp = (u_char*)cp;\r\n\r\n    /* Conver 'w' to bytes from pixels (rounded up) */\r\n    w = (w+7)/8;\r\n\r\n    while (h-- \u003e 0) {\r\n        _TIFFmemcpy(ucp, pp, w);\r\n        /*\r\n        for (x = wb; x-- \u003e 0;) {\r\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\r\n            pp += samplesperpixel;\r\n        }\r\n        */\r\n        ucp += (wb + toskew);\r\n        pp += (w + fromskew);\r\n    }\r\n}\r\n\r\n/*\r\n *  Hacked from the tif_getimage.c file.\r\n */\r\nstatic uint32\r\nsetorientation(TIFFRGBAImage* img, uint32 h)\r\n{\r\n    TIFF* tif = img-\u003etif;\r\n    uint32 y;\r\n\r\n    switch (img-\u003eorientation) {\r\n    case ORIENTATION_BOTRIGHT:\r\n    case ORIENTATION_RIGHTBOT:  /* XXX */\r\n    case ORIENTATION_LEFTBOT:   /* XXX */\r\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\r\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\r\n    /* fall through... */\r\n    case ORIENTATION_BOTLEFT:\r\n    y = 0;\r\n    break;\r\n    case ORIENTATION_TOPRIGHT:\r\n    case ORIENTATION_RIGHTTOP:  /* XXX */\r\n    case ORIENTATION_LEFTTOP:   /* XXX */\r\n    default:\r\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\r\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\r\n    /* fall through... */\r\n    case ORIENTATION_TOPLEFT:\r\n    y = h-1;\r\n    break;\r\n    }\r\n    return (y);\r\n}\r\n\r\n/*\r\n * Get a strip-organized image that has\r\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\r\n * or\r\n *  SamplesPerPixel == 1\r\n *\r\n *  Hacked from the tif_getimage.c file.\r\n *\r\n *    This is set up to allow us to just copy the data to the raster\r\n *    for 1-bit bitmaps\r\n */\r\nstatic int\r\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\r\n{\r\n    TIFF* tif = img-\u003etif;\r\n    tileContigRoutine put = img-\u003eput.contig;\r\n    uint16 orientation;\r\n    uint32 row, y, nrow, rowstoread;\r\n    uint32 pos;\r\n    u_char* buf;\r\n    uint32 rowsperstrip;\r\n    uint32 imagewidth = img-\u003ewidth;\r\n    tsize_t scanline;\r\n    int32 fromskew, toskew;\r\n    tstrip_t strip;\r\n    tsize_t  stripsize;\r\n    u_char* braster = (u_char*)raster; // byte wide raster\r\n    uint32  wb = WIDTHBYTES(w);\r\n    int ret = 1;\r\n\r\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\r\n    if (buf == 0) {\r\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\r\n        return (0);\r\n    }\r\n    y = setorientation(img, h);\r\n    orientation = img-\u003eorientation;\r\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\r\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\r\n    scanline = TIFFScanlineSize(tif);\r\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\r\n    for (row = 0; row \u003c h; row += nrow)\r\n    {\r\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\r\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\r\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\r\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\r\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\r\n            \u0026\u0026 img-\u003estoponerr)\r\n        {\r\n            ret = 0;\r\n            break;\r\n        }\r\n\r\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\r\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\r\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\r\n    }\r\n    _TIFFfree(buf);\r\n    return (ret);\r\n}\r\n\r\n/*\r\n * Local Variables:\r\n * mode: c++\r\n * c-basic-offset: 8\r\n * fill-column: 78\r\n * End:\r\n */\r\n",
        "name": "Tiffile.cpp",
        "path": "tkimg/compat/libtiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/SAOImageDS9/SAOImageDS9/-/blob/tkimg/compat/libtiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\r"
        }
      ],
      "repository": {
        "name": "github.com/SAOImageDS9/SAOImageDS9",
        "url": "/github.com/SAOImageDS9/SAOImageDS9"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "7212bd40c743d703c17bdcac5239fc490dcf85ec"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "wxWidgets/src/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/Ravbug/UnityHubNative/-/blob/wxWidgets/src/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/Ravbug/UnityHubNative",
        "url": "/github.com/Ravbug/UnityHubNative"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "01f545b81fea715e32319582bfbbc8bb8b2109f4"
        },
        "content": "#include \"StdAfx.h\"\n\n// #define STRICT\n#include \"diblib.h\"\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e // MAX_ constants\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage\n{\n    TIFFRGBAImage tif;\n    int dibinstalled;\n};\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster);\n\nstatic void MyWarningHandler(const char *module, const char *fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void MyErrorHandler(const char *module, const char *fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF(LPCTSTR lpszPath)\n{\n    int rtn = 0;\n\n    TIFFErrorHandler eh;\n    TIFFErrorHandler wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF *tif = TIFFOpen(lpszPath, \"r\");\n    if (tif)\n    {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage *img);\n\nPVOID ReadTIFF(LPCTSTR lpszPath)\n{\n    void *pDIB = 0;\n    TIFFErrorHandler wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath))\n    {\n        TIFF *tif = TIFFOpen(lpszPath, \"r\");\n        if (tif)\n        {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg))\n            {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg))\n                {\n                    size_t npixels;\n                    uint32_t *raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster =\n                        (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n                    if (raster != NULL)\n                    {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width,\n                                             img.tif.height))\n                        {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else\n            {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg);\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster)\n{\n    void *pDIB = 0;\n    TIFFRGBAImage *img = \u0026dib-\u003etif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER bi;\n    int dwDIBSize;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if (BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled)\n    { // bilevel\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 1;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(\u0026bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed = 0;\n        pRgbq[0].rgbBlue = 0;\n        pRgbq[0].rgbGreen = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed = 255;\n        pRgbq[1].rgbBlue = 255;\n        pRgbq[1].rgbGreen = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr(\n            (BITMAPINFOHEADER *)pDIB); //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n    //  For now just always default to the RGB 32 bit form. // save as 32 bit\n    //  for simplicity\n    else if (true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/)\n    { // 24 bit color\n\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 32;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(\u0026bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        // Swap the byte order while copying\n        for (int i = 0; i \u003c sizeWords; ++i)\n        {\n            rgbDib[i].rgbRed = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n#define DECLAREContigPutFunc(name)                                             \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *pp)\n\n#define DECLARESepPutFunc(name)                                                \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *r, u_char *g, u_char *b, u_char *a)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *uraster, uint32_t w,\n                              uint32_t h);\n\n// typdef struct TIFFDibImage {\n//     TIFFRGBAImage tif;\n//     dibinstalled;\n// } TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage *dib)\n{\n    TIFFRGBAImage *img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric)\n    {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n            switch (img-\u003ebitspersample)\n            {\n                case 1:\n                    img-\u003eput.contig = putContig1bitTile;\n                    img-\u003eget = getStripContig1Bit;\n                    dib-\u003edibinstalled = true;\n                    break;\n            }\n            break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void)y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char *ucp = (u_char *)cp;\n\n    /* Convert 'w' to bytes from pixels (rounded up) */\n    w = (w + 7) / 8;\n\n    while (h-- \u003e 0)\n    {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32_t setorientation(TIFFRGBAImage *img, uint32_t h)\n{\n    TIFF *tif = img-\u003etif;\n    uint32_t y;\n\n    switch (img-\u003eorientation)\n    {\n        case ORIENTATION_BOTRIGHT:\n        case ORIENTATION_RIGHTBOT: /* XXX */\n        case ORIENTATION_LEFTBOT:  /* XXX */\n            TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n            img-\u003eorientation = ORIENTATION_BOTLEFT;\n        /* fall through... */\n        case ORIENTATION_BOTLEFT:\n            y = 0;\n            break;\n        case ORIENTATION_TOPRIGHT:\n        case ORIENTATION_RIGHTTOP: /* XXX */\n        case ORIENTATION_LEFTTOP:  /* XXX */\n        default:\n            TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n            img-\u003eorientation = ORIENTATION_TOPLEFT;\n        /* fall through... */\n        case ORIENTATION_TOPLEFT:\n            y = h - 1;\n            break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *raster, uint32_t w,\n                              uint32_t h)\n{\n    TIFF *tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16_t orientation;\n    uint32_t row, y, nrow, rowstoread;\n    uint32_t pos;\n    u_char *buf;\n    uint32_t rowsperstrip;\n    uint32_t imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32_t fromskew, toskew;\n    tstrip_t strip;\n    tsize_t stripsize;\n    u_char *braster = (u_char *)raster; // byte wide raster\n    uint32_t wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char *)_TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32_t)(orientation == ORIENTATION_TOPLEFT ? wb + wb : wb - wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0) / 8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif, row + img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset) % rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize) \u003c 0 \u0026\u0026\n            img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32_t *)(braster + y * wb), 0, y, w, nrow, fromskew,\n               toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ? -(int32_t)nrow\n                                                 : (int32_t)nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n",
        "name": "Tiffile.cpp",
        "path": "3rdparty/tiff-4.6.0/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/SuperIlu/DOjS/-/blob/3rdparty/tiff-4.6.0/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 112,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width,"
        }
      ],
      "repository": {
        "name": "github.com/SuperIlu/DOjS",
        "url": "/github.com/SuperIlu/DOjS"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "616b730d109b733fc7d71097ccddcb6e61858684"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "testcases/SanRazor/data/cve/tiff-asan/tiff-4.0.7/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/junxzm1990/ASAN--/-/blob/testcases/SanRazor/data/cve/tiff-asan/tiff-4.0.7/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/junxzm1990/ASAN--",
        "url": "/github.com/junxzm1990/ASAN--"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "e543e9ec583afbcd2535f1941f2af4cc44890a45"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "humble-video-captive/src/main/gnu/libtiff/csrc/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/artclarke/humble-video/-/blob/humble-video-captive/src/main/gnu/libtiff/csrc/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/artclarke/humble-video",
        "url": "/github.com/artclarke/humble-video"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "9e58aaf853fc5244ff77cab6bd579a10956e99a2"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n",
        "name": "Tiffile.cpp",
        "path": "Thirdparty/wxWidgets/src/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/bjakja/Kainote/-/blob/Thirdparty/wxWidgets/src/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/bjakja/Kainote",
        "url": "/github.com/bjakja/Kainote"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a33afddbf01ce91ae645416c2f903778c764349b"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "examples/pxScene2d/external/WinSparkle/3rdparty/wxWidgets/src/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/pxscene/pxCore2/-/blob/examples/pxScene2d/external/WinSparkle/3rdparty/wxWidgets/src/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/pxscene/pxCore2",
        "url": "/github.com/pxscene/pxCore2"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a99f20706f9c666903a12a205edce13263b1fadb"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "components/SDL2/src/image/external/tiff-4.0.9/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/alibaba/AliOS-Things/-/blob/components/SDL2/src/image/external/tiff-4.0.9/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/alibaba/AliOS-Things",
        "url": "/github.com/alibaba/AliOS-Things"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a5af9887ca6b829bcbf15bf401430d1621373c25"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "vendor/tiff-4.0.6/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/microsoft/microsoft-r-open/-/blob/vendor/tiff-4.0.6/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/microsoft/microsoft-r-open",
        "url": "/github.com/microsoft/microsoft-r-open"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "2d1b6f8369fc3ea8c0b688aac3004d0f8bc1bfbd"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "wxWidgets-3.2.0/src/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/fligger/FateInjector/-/blob/wxWidgets-3.2.0/src/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/fligger/FateInjector",
        "url": "/github.com/fligger/FateInjector"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "31bcfbf9c9a5803dc0ffb022b7e7abd76e5c3cfd"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "SDL2_image/external/tiff-4.0.8/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/mozeal/SDL_gui/-/blob/SDL2_image/external/tiff-4.0.8/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/mozeal/SDL_gui",
        "url": "/github.com/mozeal/SDL_gui"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "857e4e76e26f05d72400ae5d9f2a22cae88f3548"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "joycon-driver/full/wxWidgets-3.0.4/src/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/fossephate/JoyCon-Driver/-/blob/joycon-driver/full/wxWidgets-3.0.4/src/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/fossephate/JoyCon-Driver",
        "url": "/github.com/fossephate/JoyCon-Driver"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "857e4e76e26f05d72400ae5d9f2a22cae88f3548"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "joycon-driver/full/wxWidgets-3.0.3/src/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/fossephate/JoyCon-Driver/-/blob/joycon-driver/full/wxWidgets-3.0.3/src/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/fossephate/JoyCon-Driver",
        "url": "/github.com/fossephate/JoyCon-Driver"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "fa0a13f73d4e3b31dd3edc11bba1f33ea80d064f"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "Android/jni/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/a1studmuffin/Cataclysm-DDA-Android/-/blob/Android/jni/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/a1studmuffin/Cataclysm-DDA-Android",
        "url": "/github.com/a1studmuffin/Cataclysm-DDA-Android"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "6f21411884ca8de78014316abe2186cd6cbbba79"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "sdlplugin/src/main/jni/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/tranleduy2000/c_cpp_compiler/-/blob/sdlplugin/src/main/jni/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/tranleduy2000/c_cpp_compiler",
        "url": "/github.com/tranleduy2000/c_cpp_compiler"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "049d345b74f449bef0074af20d9b9e2e9bdf8b70"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "filezillaclient/wxWidgets-3.1.0/src/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/helloworldgnu/filezilla/-/blob/filezillaclient/wxWidgets-3.1.0/src/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/helloworldgnu/filezilla",
        "url": "/github.com/helloworldgnu/filezilla"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "049d345b74f449bef0074af20d9b9e2e9bdf8b70"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "filezillaclient/wxWidgets-3.0.2/src/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/helloworldgnu/filezilla/-/blob/filezillaclient/wxWidgets-3.0.2/src/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/helloworldgnu/filezilla",
        "url": "/github.com/helloworldgnu/filezilla"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "8d4f3e6d31def1547a7564a9104d2b9d913a785a"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "kingdom-src/SDL/SDL2_image-2.0.1/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/freeors/War-Of-Kingdom/-/blob/kingdom-src/SDL/SDL2_image-2.0.1/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/freeors/War-Of-Kingdom",
        "url": "/github.com/freeors/War-Of-Kingdom"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "3e8682f24fe223c7065671d0204de639a6d2ec05"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "opengames/src/main/jni/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/emileb/OpenGames/-/blob/opengames/src/main/jni/SDL2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/emileb/OpenGames",
        "url": "/github.com/emileb/OpenGames"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "74c896af5826ebe8fb72f2911015738f38ab7bb2"
        },
        "content": "#include \"StdAfx.h\"\r\n\r\n//#define STRICT\r\n#include \u003cwindows.h\u003e\r\n#include \u003cwindowsx.h\u003e\r\n#include \u003ccommdlg.h\u003e\r\n#include \u003cstdlib.h\u003e                     // MAX_ constants\r\n#include \"diblib.h\"\r\n\r\n/*--------------------------------------------------------------------\r\n        READ TIFF\r\n        Load the TIFF data from the file into memory.  Return\r\n        a pointer to a valid DIB (or NULL for errors).\r\n        Uses the TIFFRGBA interface to libtiff.lib to convert\r\n        most file formats to a useable form.  We just keep the 32 bit\r\n        form of the data to display, rather than optimizing for the\r\n        display.\r\n\r\n        Main entry points:\r\n\r\n            int ChkTIFF ( LPCTSTR lpszPath )\r\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\r\n\r\n        RETURN\r\n            A valid DIB pointer for success; NULL for failure.\r\n\r\n  --------------------------------------------------------------------*/\r\n\r\n#include \"TiffLib/tiff.h\"\r\n#include \"TiffLib/tiffio.h\"\r\n#include \u003cassert.h\u003e\r\n#include \u003cstdio.h\u003e\r\n\r\n\r\n// piggyback some data on top of the RGBA Image\r\nstruct TIFFDibImage {\r\n    TIFFRGBAImage tif;\r\n    int  dibinstalled;\r\n} ;\r\n\r\n\r\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\r\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\r\n\r\nstatic void\r\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\r\n{\r\n    // ignore all warnings (unused tags, etc)\r\n    return;\r\n}\r\n\r\nstatic void\r\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\r\n{\r\n    return;\r\n}\r\n\r\n//  Turn off the error and warning handlers to check if a valid file.\r\n//  Necessary because of the way that the Doc loads images and restart files.\r\nint ChkTIFF ( LPCTSTR lpszPath )\r\n{\r\n    int rtn = 0;\r\n\r\n    TIFFErrorHandler  eh;\r\n    TIFFErrorHandler  wh;\r\n\r\n    eh = TIFFSetErrorHandler(NULL);\r\n    wh = TIFFSetWarningHandler(NULL);\r\n\r\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\r\n    if (tif) {\r\n        rtn = 1;\r\n        TIFFClose(tif);\r\n    }\r\n\r\n    TIFFSetErrorHandler(eh);\r\n    TIFFSetWarningHandler(wh);\r\n\r\n    return rtn;\r\n}\r\n\r\nvoid DibInstallHack(TIFFDibImage* img) ;\r\n\r\nPVOID ReadTIFF ( LPCTSTR lpszPath )\r\n{\r\n    void*             pDIB = 0;\r\n    TIFFErrorHandler  wh;\r\n\r\n    wh = TIFFSetWarningHandler(MyWarningHandler);\r\n\r\n    if (ChkTIFF(lpszPath)) {\r\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\r\n        if (tif) {\r\n            char emsg[1024];\r\n\r\n            if (TIFFRGBAImageOK(tif, emsg)) {\r\n                TIFFDibImage img;\r\n                char emsg[1024];\r\n\r\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\r\n                    size_t npixels;\r\n                    uint32* raster;\r\n\r\n                    DibInstallHack(\u0026img);\r\n\r\n                    npixels = img.tif.width * img.tif.height;\r\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\r\n                    if (raster != NULL) {\r\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\r\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\r\n                        }\r\n                    }\r\n                    _TIFFfree(raster);\r\n                }\r\n                TIFFRGBAImageEnd(\u0026img.tif);\r\n            }\r\n            else {\r\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\r\n            }\r\n            TIFFClose(tif);\r\n        }\r\n    }\r\n\r\n    TIFFSetWarningHandler(wh);\r\n\r\n    return pDIB;\r\n}\r\n\r\n\r\n\r\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\r\n{\r\n    void*   pDIB = 0;\r\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\r\n\r\n    uint32 imageLength;\r\n    uint32 imageWidth;\r\n    uint16 BitsPerSample;\r\n    uint16 SamplePerPixel;\r\n    uint32 RowsPerStrip;\r\n    uint16 PhotometricInterpretation;\r\n\r\n    BITMAPINFOHEADER   bi;\r\n    int                dwDIBSize ;\r\n\r\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\r\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\r\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\r\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\r\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\r\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\r\n\r\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\r\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\r\n        bi.biWidth          = imageWidth;\r\n        bi.biHeight         = imageLength;\r\n        bi.biPlanes         = 1;  // always\r\n        bi.biBitCount       = 1;\r\n        bi.biCompression    = BI_RGB;\r\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\r\n        bi.biXPelsPerMeter  = 0;\r\n        bi.biYPelsPerMeter  = 0;\r\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\r\n        bi.biClrImportant   = 0;  // always\r\n\r\n        // Get the size of the DIB\r\n        dwDIBSize = GetDIBSize( \u0026bi );\r\n\r\n        // Allocate for the BITMAPINFO structure and the color table.\r\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\r\n        if (pDIB == 0) {\r\n            return( NULL );\r\n        }\r\n\r\n        // Copy the header info\r\n        *((BITMAPINFOHEADER*)pDIB) = bi;\r\n\r\n        // Get a pointer to the color table\r\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\r\n\r\n        pRgbq[0].rgbRed      = 0;\r\n        pRgbq[0].rgbBlue     = 0;\r\n        pRgbq[0].rgbGreen    = 0;\r\n        pRgbq[0].rgbReserved = 0;\r\n        pRgbq[1].rgbRed      = 255;\r\n        pRgbq[1].rgbBlue     = 255;\r\n        pRgbq[1].rgbGreen    = 255;\r\n        pRgbq[1].rgbReserved = 255;\r\n\r\n        // Pointers to the bits\r\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\r\n        //\r\n        // In the BITMAPINFOHEADER documentation, it appears that\r\n        // there should be no color table for 32 bit images, but\r\n        // experience shows that the image is off by 3 words if it\r\n        // is not included.  So here it is.\r\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\r\n\r\n        int       sizeWords = bi.biSizeImage/4;\r\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\r\n        long*     rgbTif = (long*)raster;\r\n\r\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\r\n    }\r\n\r\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\r\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\r\n\r\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\r\n        bi.biWidth          = imageWidth;\r\n        bi.biHeight         = imageLength;\r\n        bi.biPlanes         = 1;  // always\r\n        bi.biBitCount       = 32;\r\n        bi.biCompression    = BI_RGB;\r\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\r\n        bi.biXPelsPerMeter  = 0;\r\n        bi.biYPelsPerMeter  = 0;\r\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\r\n        bi.biClrImportant   = 0;  // always\r\n\r\n        // Get the size of the DIB\r\n        dwDIBSize = GetDIBSize( \u0026bi );\r\n\r\n        // Allocate for the BITMAPINFO structure and the color table.\r\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\r\n        if (pDIB == 0) {\r\n            return( NULL );\r\n        }\r\n\r\n        // Copy the header info\r\n        *((BITMAPINFOHEADER*)pDIB) = bi;\r\n\r\n        // Get a pointer to the color table\r\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\r\n\r\n        // Pointers to the bits\r\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\r\n        //\r\n        // In the BITMAPINFOHEADER documentation, it appears that\r\n        // there should be no color table for 32 bit images, but\r\n        // experience shows that the image is off by 3 words if it\r\n        // is not included.  So here it is.\r\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\r\n\r\n        int       sizeWords = bi.biSizeImage/4;\r\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\r\n        long*     rgbTif = (long*)raster;\r\n\r\n        // Swap the byte order while copying\r\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\r\n        {\r\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\r\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\r\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\r\n            rgbDib[i].rgbReserved = 0;\r\n        }\r\n    }\r\n\r\n    return pDIB;\r\n}\r\n\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////\r\n//\r\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\r\n//\r\n//\r\ntypedef unsigned char u_char;\r\n\r\n\r\n#define DECLAREContigPutFunc(name) \\\r\nstatic void name(\\\r\n    TIFFRGBAImage* img, \\\r\n    uint32* cp, \\\r\n    uint32 x, uint32 y, \\\r\n    uint32 w, uint32 h, \\\r\n    int32 fromskew, int32 toskew, \\\r\n    u_char* pp \\\r\n)\r\n\r\n#define DECLARESepPutFunc(name) \\\r\nstatic void name(\\\r\n    TIFFRGBAImage* img,\\\r\n    uint32* cp,\\\r\n    uint32 x, uint32 y, \\\r\n    uint32 w, uint32 h,\\\r\n    int32 fromskew, int32 toskew,\\\r\n    u_char* r, u_char* g, u_char* b, u_char* a\\\r\n)\r\n\r\nDECLAREContigPutFunc(putContig1bitTile);\r\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\r\n\r\n//typdef struct TIFFDibImage {\r\n//    TIFFRGBAImage tif;\r\n//    dibinstalled;\r\n//} TIFFDibImage ;\r\n\r\nvoid DibInstallHack(TIFFDibImage* dib) {\r\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\r\n    dib-\u003edibinstalled = false;\r\n    switch (img-\u003ephotometric) {\r\n        case PHOTOMETRIC_MINISWHITE:\r\n        case PHOTOMETRIC_MINISBLACK:\r\n        switch (img-\u003ebitspersample) {\r\n            case 1:\r\n                img-\u003eput.contig = putContig1bitTile;\r\n                img-\u003eget = getStripContig1Bit;\r\n                dib-\u003edibinstalled = true;\r\n                break;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\n/*\r\n * 1-bit packed samples =\u003e 1-bit\r\n *\r\n *   Override to just copy the data\r\n */\r\nDECLAREContigPutFunc(putContig1bitTile)\r\n{\r\n    int samplesperpixel = img-\u003esamplesperpixel;\r\n\r\n    (void) y;\r\n    fromskew *= samplesperpixel;\r\n    int wb = WIDTHBYTES(w);\r\n    u_char*  ucp = (u_char*)cp;\r\n\r\n    /* Conver 'w' to bytes from pixels (rounded up) */\r\n    w = (w+7)/8;\r\n\r\n    while (h-- \u003e 0) {\r\n        _TIFFmemcpy(ucp, pp, w);\r\n        /*\r\n        for (x = wb; x-- \u003e 0;) {\r\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\r\n            pp += samplesperpixel;\r\n        }\r\n        */\r\n        ucp += (wb + toskew);\r\n        pp += (w + fromskew);\r\n    }\r\n}\r\n\r\n/*\r\n *  Hacked from the tif_getimage.c file.\r\n */\r\nstatic uint32\r\nsetorientation(TIFFRGBAImage* img, uint32 h)\r\n{\r\n    TIFF* tif = img-\u003etif;\r\n    uint32 y;\r\n\r\n    switch (img-\u003eorientation) {\r\n    case ORIENTATION_BOTRIGHT:\r\n    case ORIENTATION_RIGHTBOT:  /* XXX */\r\n    case ORIENTATION_LEFTBOT:   /* XXX */\r\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\r\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\r\n    /* fall thru... */\r\n    case ORIENTATION_BOTLEFT:\r\n    y = 0;\r\n    break;\r\n    case ORIENTATION_TOPRIGHT:\r\n    case ORIENTATION_RIGHTTOP:  /* XXX */\r\n    case ORIENTATION_LEFTTOP:   /* XXX */\r\n    default:\r\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\r\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\r\n    /* fall thru... */\r\n    case ORIENTATION_TOPLEFT:\r\n    y = h-1;\r\n    break;\r\n    }\r\n    return (y);\r\n}\r\n\r\n/*\r\n * Get a strip-organized image that has\r\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\r\n * or\r\n *  SamplesPerPixel == 1\r\n *\r\n *  Hacked from the tif_getimage.c file.\r\n *\r\n *    This is set up to allow us to just copy the data to the raster\r\n *    for 1-bit bitmaps\r\n */\r\nstatic int\r\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\r\n{\r\n    TIFF* tif = img-\u003etif;\r\n    tileContigRoutine put = img-\u003eput.contig;\r\n    uint16 orientation;\r\n    uint32 row, y, nrow, rowstoread;\r\n    uint32 pos;\r\n    u_char* buf;\r\n    uint32 rowsperstrip;\r\n    uint32 imagewidth = img-\u003ewidth;\r\n    tsize_t scanline;\r\n    int32 fromskew, toskew;\r\n    tstrip_t strip;\r\n    tsize_t  stripsize;\r\n    u_char* braster = (u_char*)raster; // byte wide raster\r\n    uint32  wb = WIDTHBYTES(w);\r\n    int ret = 1;\r\n\r\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\r\n    if (buf == 0) {\r\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\r\n        return (0);\r\n    }\r\n    y = setorientation(img, h);\r\n    orientation = img-\u003eorientation;\r\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\r\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\r\n    scanline = TIFFScanlineSize(tif);\r\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\r\n    for (row = 0; row \u003c h; row += nrow)\r\n    {\r\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\r\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\r\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\r\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\r\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\r\n            \u0026\u0026 img-\u003estoponerr)\r\n        {\r\n            ret = 0;\r\n            break;\r\n        }\r\n\r\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\r\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\r\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\r\n    }\r\n    _TIFFfree(buf);\r\n    return (ret);\r\n}\r\n\r\n",
        "name": "Tiffile.cpp",
        "path": "wxWidgets-2.9.1/src/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/gamekit-developers/gamekit/-/blob/wxWidgets-2.9.1/src/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\r"
        }
      ],
      "repository": {
        "name": "github.com/gamekit-developers/gamekit",
        "url": "/github.com/gamekit-developers/gamekit"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "993c84e35658155228da86e992a2f69f94ac40e0"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "captive/libtiff/csrc/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/artclarke/xuggle-xuggler/-/blob/captive/libtiff/csrc/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/artclarke/xuggle-xuggler",
        "url": "/github.com/artclarke/xuggle-xuggler"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "eb0cf9617bd22b69ad625575a95cf4fa2c140d55"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n",
        "name": "Tiffile.cpp",
        "path": "lib/libtiff/tiff-4.0.0beta3/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/scs/uclinux/-/blob/lib/libtiff/tiff-4.0.0beta3/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/scs/uclinux",
        "url": "/github.com/scs/uclinux"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "34e34a6a539b5a822cda4074e56a7ced9b57da71"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "tcl-102/tcl_ext/tkimg/tkimg/compat/libtiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/st3fan/osx-10.9/-/blob/tcl-102/tcl_ext/tkimg/tkimg/compat/libtiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/st3fan/osx-10.9",
        "url": "/github.com/st3fan/osx-10.9"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "068586f28f5df67ed531de202343af0d1cc2f8c6"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n",
        "name": "Tiffile.cpp",
        "path": "libs/tiff-3.8.2/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/seven1240/FreeSWITCH-OLD/-/blob/libs/tiff-3.8.2/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/seven1240/FreeSWITCH-OLD",
        "url": "/github.com/seven1240/FreeSWITCH-OLD"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "05ae6bf6dfa41f81ecdd30b538d1a4df4f399dce"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "source/wxWidgets/src/tiff/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/dsp56300/dsp56300/-/blob/source/wxWidgets/src/tiff/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/dsp56300/dsp56300",
        "url": "/github.com/dsp56300/dsp56300"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "4e5531ea1a00f247f9f43bbf55cadbed698418cd"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "libs/SDL2_image/2.0.0/src/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/bfosterjr/windowsrtdev/-/blob/libs/SDL2_image/2.0.0/src/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/bfosterjr/windowsrtdev",
        "url": "/github.com/bfosterjr/windowsrtdev"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "e5f0f3e5b1183facee2dd0c723757e9033d89c61"
        },
        "content": "/*\n   Copyright (C) 2017-2024 Peter S. Zhigalov \u003cpeter.zhigalov@gmail.com\u003e\n\n   This file is part of the `ImageViewer' program.\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n*/\n\n#include \u003calgorithm\u003e\n#include \u003ccassert\u003e\n#include \u003ccmath\u003e\n#include \u003ccstring\u003e\n#include \u003climits\u003e\n\n#if !defined (TIFF_DISABLE_DEPRECATED)\n#define TIFF_DISABLE_DEPRECATED\n#endif\n#include \u003ctiffio.h\u003e\n\n#include \u003cQFileInfo\u003e\n#include \u003cQImage\u003e\n#include \u003cQFile\u003e\n#include \u003cQByteArray\u003e\n\n#include \"Utils/Global.h\"\n#include \"Utils/IsOneOf.h\"\n#include \"Utils/Logging.h\"\n#include \"Utils/ScopedPointer.h\"\n\n#include \"../IDecoder.h\"\n#include \"Internal/DecoderAutoRegistrator.h\"\n#include \"Internal/GraphicsItemsFactory.h\"\n#include \"Internal/ImageData.h\"\n#include \"Internal/ImageMetaData.h\"\n#include \"Internal/PayloadWithMetaData.h\"\n#include \"Internal/Utils/CmsUtils.h\"\n#include \"Internal/Utils/DataProcessing.h\"\n\n#define USE_RGBA_8888   (QT_VERSION \u003e= QT_VERSION_CHECK(5, 2, 0) \u0026\u0026 Q_BYTE_ORDER == Q_LITTLE_ENDIAN)\n#define USE_GRAYSCALE_8 (QT_VERSION \u003e= QT_VERSION_CHECK(5, 5, 0))\n#define USE_CMYK_8888   (QT_VERSION \u003e= QT_VERSION_CHECK(6, 8, 0))\n#define ALLOW_BUFFER_UNDERFLOW\n\n// #define DEBUG_FORCE_BIT_ACCESS\n// #define DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER\n// #define DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER\n\n/// @note Buffer is zero-filled since LibTIFF-4.7.0:\n/// https://gitlab.com/libtiff/libtiff/-/merge_requests/628/\n#define BUFFER_FILL_PATTERN 0\n#define BUFFER_MAX_SIZE (static_cast\u003cqint64\u003e(std::numeric_limits\u003cint\u003e::max()))\n\nnamespace\n{\n\n// ====================================================================================================\n\nstruct Context\n{\n    TIFF *tiff;\n    qint64 width;\n    qint64 height;\n    quint16 compression;\n    quint16 photometric;\n    qint64 samplesPerPixel;\n    qint64 bitsPerSample;\n    quint16 sampleFormat;\n    quint16 inkSet;\n    ICCProfile *iccProfile;\n    const float *ycbcrcoeffs;\n    qint64 subsamplinghor;\n    qint64 subsamplingver;\n    quint16 ycbcrpositioning;\n    qint64 extrasamplesCount;\n    qint64 primarysamplesCount;\n    int alphaIndex;\n    bool alphaPremultiplied;\n    const quint16 *redTable;\n    const quint16 *greenTable;\n    const quint16 *blueTable;\n    bool colorTablesIs16Bit;\n};\n\n// ====================================================================================================\n\nQString photometricToString(quint16 photometric)\n{\n    switch(photometric)\n    {\n#define ADD_CASE(X) case X: return QString::fromLatin1(#X)\n    ADD_CASE(PHOTOMETRIC_MINISWHITE);\n    ADD_CASE(PHOTOMETRIC_MINISBLACK);\n    ADD_CASE(PHOTOMETRIC_RGB);\n    ADD_CASE(PHOTOMETRIC_PALETTE);\n    ADD_CASE(PHOTOMETRIC_MASK);\n    ADD_CASE(PHOTOMETRIC_SEPARATED);\n    ADD_CASE(PHOTOMETRIC_YCBCR);\n    ADD_CASE(PHOTOMETRIC_CIELAB);\n    ADD_CASE(PHOTOMETRIC_ICCLAB);\n    ADD_CASE(PHOTOMETRIC_ITULAB);\n#if defined (PHOTOMETRIC_CFA)\n    ADD_CASE(PHOTOMETRIC_CFA);\n#endif\n    ADD_CASE(PHOTOMETRIC_LOGL);\n    ADD_CASE(PHOTOMETRIC_LOGLUV);\n#undef ADD_CASE\n    default:\n        break;\n    }\n    return QString::fromLatin1(\"%1\").arg(photometric);\n}\n\nQString inkSetToString(quint16 inkSet)\n{\n    switch(inkSet)\n    {\n#define ADD_CASE(X) case X: return QString::fromLatin1(#X)\n    ADD_CASE(INKSET_CMYK);\n    ADD_CASE(INKSET_MULTIINK);\n#undef ADD_CASE\n    default:\n        break;\n    }\n    return QString::fromLatin1(\"%1\").arg(inkSet);\n}\n\nQString orientationToString(quint16 orientation)\n{\n    switch(orientation)\n    {\n#define ADD_CASE(X) case X: return QString::fromLatin1(#X)\n    ADD_CASE(ORIENTATION_TOPLEFT);\n    ADD_CASE(ORIENTATION_TOPRIGHT);\n    ADD_CASE(ORIENTATION_BOTRIGHT);\n    ADD_CASE(ORIENTATION_BOTLEFT);\n    ADD_CASE(ORIENTATION_LEFTTOP);\n    ADD_CASE(ORIENTATION_RIGHTTOP);\n    ADD_CASE(ORIENTATION_RIGHTBOT);\n    ADD_CASE(ORIENTATION_LEFTBOT);\n#undef ADD_CASE\n    default:\n        break;\n    }\n    return QString::fromLatin1(\"%1\").arg(orientation);\n}\n\nQString sampleFormatToString(quint16 sampleFormat)\n{\n    switch(sampleFormat)\n    {\n#define ADD_CASE(X) case X: return QString::fromLatin1(#X)\n    ADD_CASE(SAMPLEFORMAT_UINT);\n    ADD_CASE(SAMPLEFORMAT_INT);\n    ADD_CASE(SAMPLEFORMAT_IEEEFP);\n    ADD_CASE(SAMPLEFORMAT_VOID);\n    ADD_CASE(SAMPLEFORMAT_COMPLEXINT);\n    ADD_CASE(SAMPLEFORMAT_COMPLEXIEEEFP);\n#undef ADD_CASE\n    default:\n        break;\n    }\n    return QString::fromLatin1(\"%1\").arg(sampleFormat);\n}\n\nQString extrasamplesToString(quint16 extrasamplesCount, const quint16 *extrasamples)\n{\n    QString result;\n    // Avoid too long string, it is not human-readable\n    if(extrasamplesCount \u003e 16)\n    {\n        quint16 unspecified = 0;\n        quint16 assocalpha = 0;\n        quint16 unassocalpha = 0;\n        quint16 other = 0;\n        for(quint16 i = 0; i \u003c extrasamplesCount; ++i)\n        {\n            switch(extrasamples[i])\n            {\n            case EXTRASAMPLE_UNSPECIFIED:\n                ++unspecified;\n                break;\n            case EXTRASAMPLE_ASSOCALPHA:\n                ++assocalpha;\n                break;\n            case EXTRASAMPLE_UNASSALPHA:\n                ++unassocalpha;\n                break;\n            default:\n                ++other;\n                break;\n            }\n        }\n#define APPEND_RESULT(S, C) if((C) \u003e 0) result = result + (result.isEmpty() ? QString() : QString::fromLatin1(\", \")) + QString::fromLatin1(\"%1x%2\").arg(C).arg(QString::fromLatin1(#S))\n        APPEND_RESULT(EXTRASAMPLE_UNSPECIFIED, unspecified);\n        APPEND_RESULT(EXTRASAMPLE_ASSOCALPHA, assocalpha);\n        APPEND_RESULT(EXTRASAMPLE_UNASSALPHA, unassocalpha);\n        APPEND_RESULT(Unknown, other);\n#undef APPEND_RESULT\n    }\n    else\n    {\n        for(quint16 i = 0; i \u003c extrasamplesCount; ++i)\n        {\n            switch(extrasamples[i])\n            {\n#define APPEND_RESULT(S) result = result + (result.isEmpty() ? QString() : QString::fromLatin1(\", \")) + (S)\n#define ADD_CASE(X) case X: APPEND_RESULT(QString::fromLatin1(#X)); break\n            ADD_CASE(EXTRASAMPLE_UNSPECIFIED);\n            ADD_CASE(EXTRASAMPLE_ASSOCALPHA);\n            ADD_CASE(EXTRASAMPLE_UNASSALPHA);\n#undef ADD_CASE\n            default:\n                APPEND_RESULT(QString::fromLatin1(\"%1\").arg(extrasamples[i]));\n                break;\n#undef APPEND_RESULT\n            }\n        }\n    }\n    return QString::fromLatin1(\"(%1)\").arg(result);\n}\n\nQString planarConfigToString(quint16 planarConfig)\n{\n    switch(planarConfig)\n    {\n#define ADD_CASE(X) case X: return QString::fromLatin1(#X)\n    ADD_CASE(PLANARCONFIG_CONTIG);\n    ADD_CASE(PLANARCONFIG_SEPARATE);\n#undef ADD_CASE\n    default:\n        break;\n    }\n    return QString::fromLatin1(\"%1\").arg(planarConfig);\n}\n\nQString compressionToString(quint16 compression)\n{\n    switch(compression)\n    {\n#define ADD_CASE(X) case X: return QString::fromLatin1(#X)\n#if defined (COMPRESSION_NONE)\n    ADD_CASE(COMPRESSION_NONE);\n#endif\n#if defined (COMPRESSION_CCITTRLE)\n    ADD_CASE(COMPRESSION_CCITTRLE);\n#endif\n#if defined (COMPRESSION_CCITTFAX3)\n    ADD_CASE(COMPRESSION_CCITTFAX3);\n#elif defined (COMPRESSION_CCITT_T4)\n    ADD_CASE(COMPRESSION_CCITT_T4);\n#endif\n#if defined (COMPRESSION_CCITTFAX4)\n    ADD_CASE(COMPRESSION_CCITTFAX4);\n#elif defined (COMPRESSION_CCITT_T6)\n    ADD_CASE(COMPRESSION_CCITT_T6);\n#endif\n#if defined (COMPRESSION_LZW)\n    ADD_CASE(COMPRESSION_LZW);\n#endif\n#if defined (COMPRESSION_OJPEG)\n    ADD_CASE(COMPRESSION_OJPEG);\n#endif\n#if defined (COMPRESSION_JPEG)\n    ADD_CASE(COMPRESSION_JPEG);\n#endif\n#if defined (COMPRESSION_T85)\n    ADD_CASE(COMPRESSION_T85);\n#endif\n#if defined (COMPRESSION_T43)\n    ADD_CASE(COMPRESSION_T43);\n#endif\n#if defined (COMPRESSION_NEXT)\n    ADD_CASE(COMPRESSION_NEXT);\n#endif\n#if defined (COMPRESSION_CCITTRLEW)\n    ADD_CASE(COMPRESSION_CCITTRLEW);\n#endif\n#if defined (COMPRESSION_PACKBITS)\n    ADD_CASE(COMPRESSION_PACKBITS);\n#endif\n#if defined (COMPRESSION_THUNDERSCAN)\n    ADD_CASE(COMPRESSION_THUNDERSCAN);\n#endif\n#if defined (COMPRESSION_IT8CTPAD)\n    ADD_CASE(COMPRESSION_IT8CTPAD);\n#endif\n#if defined (COMPRESSION_IT8LW)\n    ADD_CASE(COMPRESSION_IT8LW);\n#endif\n#if defined (COMPRESSION_IT8MP)\n    ADD_CASE(COMPRESSION_IT8MP);\n#endif\n#if defined (COMPRESSION_IT8BL)\n    ADD_CASE(COMPRESSION_IT8BL);\n#endif\n#if defined (COMPRESSION_PIXARFILM)\n    ADD_CASE(COMPRESSION_PIXARFILM);\n#endif\n#if defined (COMPRESSION_PIXARLOG)\n    ADD_CASE(COMPRESSION_PIXARLOG);\n#endif\n#if defined (COMPRESSION_DEFLATE)\n    ADD_CASE(COMPRESSION_DEFLATE);\n#endif\n#if defined (COMPRESSION_ADOBE_DEFLATE)\n    ADD_CASE(COMPRESSION_ADOBE_DEFLATE);\n#endif\n#if defined (COMPRESSION_DCS)\n    ADD_CASE(COMPRESSION_DCS);\n#endif\n#if defined (COMPRESSION_JBIG)\n    ADD_CASE(COMPRESSION_JBIG);\n#endif\n#if defined (COMPRESSION_SGILOG)\n    ADD_CASE(COMPRESSION_SGILOG);\n#endif\n#if defined (COMPRESSION_SGILOG24)\n    ADD_CASE(COMPRESSION_SGILOG24);\n#endif\n#if defined (COMPRESSION_JP2000)\n    ADD_CASE(COMPRESSION_JP2000);\n#endif\n#if defined (COMPRESSION_LERC)\n    ADD_CASE(COMPRESSION_LERC);\n#endif\n#if defined (COMPRESSION_LZMA)\n    ADD_CASE(COMPRESSION_LZMA);\n#endif\n#if defined (COMPRESSION_ZSTD)\n    ADD_CASE(COMPRESSION_ZSTD);\n#endif\n#if defined (COMPRESSION_WEBP)\n    ADD_CASE(COMPRESSION_WEBP);\n#endif\n#if defined (COMPRESSION_JXL)\n    ADD_CASE(COMPRESSION_JXL);\n#endif\n#undef ADD_CASE\n    default:\n        break;\n    }\n    return QString::fromLatin1(\"%1\").arg(compression);\n}\n\nQString ycbcrpositioningToString(quint16 ycbcrpositioning)\n{\n    switch(ycbcrpositioning)\n    {\n#define ADD_CASE(X) case X: return QString::fromLatin1(#X)\n        ADD_CASE(YCBCRPOSITION_CENTERED);\n        ADD_CASE(YCBCRPOSITION_COSITED);\n#undef ADD_CASE\n    default:\n        break;\n    }\n    return QString::fromLatin1(\"%1\").arg(ycbcrpositioning);\n}\n\n// ====================================================================================================\n\ntsize_t readProc(thandle_t fd, tdata_t buf, tsize_t size)\n{\n    QIODevice *device = static_cast\u003cQIODevice*\u003e(fd);\n    return device-\u003eisReadable() ? device-\u003eread(static_cast\u003cchar*\u003e(buf), size) : -1;\n}\n\ntsize_t writeProc(thandle_t fd, tdata_t buf, tsize_t size)\n{\n    QIODevice *device = static_cast\u003cQIODevice*\u003e(fd);\n    return device-\u003eisWritable() ? device-\u003ewrite(static_cast\u003cchar*\u003e(buf), size) : -1;\n}\n\ntoff_t seekProc(thandle_t fd, toff_t off, int whence)\n{\n    QIODevice *device = static_cast\u003cQIODevice*\u003e(fd);\n    const qint64 soff = static_cast\u003cqint64\u003e(off);\n    switch(whence)\n    {\n    case SEEK_SET:\n        device-\u003eseek(soff);\n        break;\n    case SEEK_CUR:\n        device-\u003eseek(device-\u003epos() + soff);\n        break;\n    case SEEK_END:\n        device-\u003eseek(device-\u003esize() + soff);\n        break;\n    }\n    return static_cast\u003ctoff_t\u003e(device-\u003epos());\n}\n\nint closeProc(thandle_t /*fd*/)\n{\n    return 0;\n}\n\ntoff_t sizeProc(thandle_t fd)\n{\n    QIODevice *device = static_cast\u003cQIODevice*\u003e(fd);\n    return static_cast\u003ctoff_t\u003e(device-\u003esize());\n}\n\nint mapProc(thandle_t /*fd*/, tdata_t* /*pbase*/, toff_t* /*psize*/)\n{\n    return 0;\n}\n\nvoid unmapProc(thandle_t /*fd*/, tdata_t /*base*/, toff_t /*size*/)\n{\n}\n\n#if defined (TIFFLIB_VERSION) \u0026\u0026 (TIFFLIB_VERSION \u003e= 20221213) \u0026\u0026 (QT_VERSION \u003e= QT_VERSION_CHECK(5, 5, 0))\nint errorHandlerProc(TIFF* /*tiff*/, void* /*user_data*/, const char *module, const char *fmt, va_list ap)\n{\n    LOG_WARNING() \u003c\u003c LOGGING_CTXS(module) \u003c\u003c  QString::vasprintf(fmt, ap).toLocal8Bit().data();\n    return 1;\n}\n\nint warningHandlerProc(TIFF* /*tiff*/, void* /*user_data*/, const char *module, const char *fmt, va_list ap)\n{\n    LOG_WARNING() \u003c\u003c LOGGING_CTXS(module) \u003c\u003c  QString::vasprintf(fmt, ap).toLocal8Bit().data();\n    return 1;\n}\n#endif\n\nICCProfile *readICCProfile(TIFF *tiff)\n{\n    unsigned iccProfileSize = 0;\n    void *iccProfileData = Q_NULLPTR;\n    if(TIFFGetField(tiff, TIFFTAG_ICCPROFILE, \u0026iccProfileSize, \u0026iccProfileData))\n    {\n        LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Found ICCP metadata (TIFFTAG_ICCPROFILE)\";\n        return new ICCProfile(QByteArray(reinterpret_cast\u003cconst char*\u003e(iccProfileData), static_cast\u003cint\u003e(iccProfileSize)));\n    }\n\n    quint16 samplesPerPixel = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLESPERPIXEL, \u0026samplesPerPixel))\n        return Q_NULLPTR;\n\n    quint16 bitsPerSample = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_BITSPERSAMPLE, \u0026bitsPerSample))\n        return Q_NULLPTR;\n\n    float *whitePoint = Q_NULLPTR, *primaryChromaticities = Q_NULLPTR;\n    unsigned short *transferFunctionRed = Q_NULLPTR, *transferFunctionGreen = Q_NULLPTR, *transferFunctionBlue = Q_NULLPTR;\n    if(!TIFFGetField(tiff, TIFFTAG_WHITEPOINT, \u0026whitePoint))\n        whitePoint = Q_NULLPTR;\n    if(!TIFFGetField(tiff, TIFFTAG_PRIMARYCHROMATICITIES, \u0026primaryChromaticities))\n        primaryChromaticities = Q_NULLPTR;\n    if(samplesPerPixel == 1)\n    {\n        if(!TIFFGetField(tiff, TIFFTAG_TRANSFERFUNCTION, \u0026transferFunctionRed, \u0026transferFunctionGreen, \u0026transferFunctionBlue))\n            transferFunctionRed = transferFunctionGreen = transferFunctionBlue = Q_NULLPTR;\n        else\n            transferFunctionGreen = transferFunctionBlue = transferFunctionRed;\n    }\n    else\n    {\n        if(!TIFFGetField(tiff, TIFFTAG_TRANSFERFUNCTION, \u0026transferFunctionRed, \u0026transferFunctionGreen, \u0026transferFunctionBlue))\n            transferFunctionRed = transferFunctionGreen = transferFunctionBlue = Q_NULLPTR;\n    }\n\n    if(whitePoint || primaryChromaticities || transferFunctionRed || transferFunctionGreen || transferFunctionBlue)\n    {\n        LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Found ICCP metadata (TIFFTAG_WHITEPOINT + TIFFTAG_PRIMARYCHROMATICITIES + TIFFTAG_TRANSFERFUNCTION)\";\n\n        /// @note TIFF defaults (CIE D50) does not match sRGB defaults (CIE D65)\n        if(!whitePoint \u0026\u0026 !TIFFGetFieldDefaulted(tiff, TIFFTAG_WHITEPOINT, \u0026whitePoint))\n            whitePoint = Q_NULLPTR;\n\n        const size_t transferFunctionSize = (static_cast\u003cstd::size_t\u003e(1) \u003c\u003c bitsPerSample);\n        return new ICCProfile(whitePoint, primaryChromaticities, transferFunctionRed, transferFunctionGreen, transferFunctionBlue, transferFunctionSize);\n    }\n\n    return Q_NULLPTR;\n}\n\n#if defined (TIFFLIB_VERSION) \u0026\u0026 (TIFFLIB_VERSION \u003e= 20120922)\n\n/// @note See https://learn.foundry.com/nuke/developers/63/ndkreference/examples/tiffReader.cpp\ntemplate\u003cclass T\u003e\nvoid addMetaData(TIFF *tiff, const TIFFField *field, ImageMetaData *metaData, const QString \u0026group, const QString \u0026tag)\n{\n    const int readCount = TIFFFieldReadCount(field);\n    if(readCount == TIFF_VARIABLE2 || readCount == TIFF_VARIABLE || readCount \u003e 1)\n    {\n        quint32 actualCount = 0;\n        T *data;\n        if(readCount == TIFF_VARIABLE)\n        {\n            quint16 gotCount = 0;\n            if(!TIFFGetField(tiff, TIFFFieldTag(field), \u0026gotCount, \u0026data))\n                return;\n            actualCount = gotCount;\n        }\n        else if(readCount == TIFF_VARIABLE2)\n        {\n            quint32 gotCount = 0;\n            if(!TIFFGetField(tiff, TIFFFieldTag(field), \u0026gotCount, \u0026data))\n                return;\n            actualCount = gotCount;\n        }\n        else\n        {\n            if(!TIFFGetField(tiff, TIFFFieldTag(field), \u0026data))\n                return;\n            actualCount = readCount;\n        }\n        if(TIFFFieldDataType(field) == TIFF_UNDEFINED)\n        {\n            const char *charData = reinterpret_cast\u003cconst char*\u003e(data);\n            const int charSize = static_cast\u003cint\u003e(actualCount * sizeof(T) / sizeof(char));\n            metaData-\u003eaddExifEntry(group, TIFFFieldTag(field), tag, QString::fromLatin1(QByteArray(charData, charSize).toHex().prepend(\"0x\")));\n        }\n        else\n        {\n            QStringList values;\n            for(quint32 i = 0; i \u003c actualCount; i++)\n                values.append(QString::fromLatin1(\"%1\").arg(data[i]));\n            metaData-\u003eaddExifEntry(group, TIFFFieldTag(field), tag, QString::fromLatin1(\"{ %1 }\").arg(values.join(QString::fromLatin1(\", \"))));\n        }\n    }\n    else if(readCount == 1)\n    {\n        T data;\n        TIFFGetField(tiff, TIFFFieldTag(field), \u0026data);\n        metaData-\u003eaddExifEntry(group, TIFFFieldTag(field), tag, QString::fromLatin1(\"%1\").arg(data));\n    }\n}\n\ntemplate\u003c\u003e\nvoid addMetaData\u003cQString\u003e(TIFF *tiff, const TIFFField *field, ImageMetaData *metaData, const QString \u0026group, const QString \u0026tag)\n{\n    if(TIFFFieldReadCount(field) \u003c= 1)\n        return;\n    char *data = Q_NULLPTR;\n    if(!TIFFGetField(tiff, TIFFFieldTag(field), \u0026data) || !data)\n        return;\n    metaData-\u003eaddExifEntry(group, TIFFFieldTag(field), tag, QString::fromUtf8(data));\n}\n\nvoid readTiffTagToMetaData(TIFF *tiff, ImageMetaData *\u0026metaData, quint32 tag, const QString \u0026tagDescription)\n{\n    const TIFFField *tagField = TIFFFindField(tiff, tag, TIFF_ANY);\n    if(!tagField)\n        return;\n    if(TIFFFieldDataType(tagField) != TIFF_IFD8)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFFieldDataType for tag (\" \u003c\u003c tagDescription \u003c\u003c \") is not TIFF_IFD8!\";\n        return;\n    }\n    quint64 exifOffset = 0;\n    if(!TIFFGetField(tiff, tag, \u0026exifOffset))\n        return;\n    if(!TIFFReadEXIFDirectory(tiff, exifOffset))\n        return;\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Found EXIF metadata (\" \u003c\u003c tagDescription \u003c\u003c \")\";\n    if(!metaData)\n        metaData = new ImageMetaData;\n    for(int i = 0, tagListCount = TIFFGetTagListCount(tiff); i \u003c tagListCount; i++)\n    {\n        ttag_t tag = TIFFGetTagListEntry(tiff, i);\n        const TIFFField *field = TIFFFieldWithTag(tiff, tag);\n        const QString exifName = QString::fromUtf8(TIFFFieldName(field));\n        /// @note See _TIFFVGetField in tif_dir.c\n        switch(TIFFFieldDataType(field))\n        {\n        case TIFF_BYTE:\n        case TIFF_UNDEFINED:\n            addMetaData\u003cquint8\u003e(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_ASCII:\n            addMetaData\u003cQString\u003e(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SHORT:\n            addMetaData\u003cquint16\u003e(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_LONG:\n            addMetaData\u003cquint32\u003e(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SBYTE:\n            addMetaData\u003cqint8\u003e(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SSHORT:\n            addMetaData\u003cqint16\u003e(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SLONG:\n            addMetaData\u003cqint32\u003e(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SRATIONAL:\n        case TIFF_RATIONAL:\n        case TIFF_FLOAT:\n            addMetaData\u003cfloat\u003e(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_DOUBLE:\n            addMetaData\u003cdouble\u003e(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_LONG8:\n            addMetaData\u003cquint64\u003e(tiff, field, metaData, tagDescription, exifName);\n            break;\n        case TIFF_SLONG8:\n            addMetaData\u003cqint64\u003e(tiff, field, metaData, tagDescription, exifName);\n            break;\n        default:\n            break;\n        }\n    }\n}\n\nImageMetaData *readExifMetaData(TIFF *tiff)\n{\n    ImageMetaData *metaData = Q_NULLPTR;\n    readTiffTagToMetaData(tiff, metaData, TIFFTAG_EXIFIFD, QString::fromLatin1(\"TIFFTAG_EXIFIFD\"));\n    readTiffTagToMetaData(tiff, metaData, TIFFTAG_GPSIFD, QString::fromLatin1(\"TIFFTAG_GPSIFD\"));\n    readTiffTagToMetaData(tiff, metaData, TIFFTAG_INTEROPERABILITYIFD, QString::fromLatin1(\"TIFFTAG_INTEROPERABILITYIFD\"));\n    return metaData;\n}\n\n#else\n\nImageMetaData *readExifMetaData(TIFF */*tiff*/)\n{\n    /// @todo LibTIFF-3.x: Add implementation?\n    return Q_NULLPTR;\n}\n\n#endif\n\n// ====================================================================================================\n\nquint64 getMaxValueUInt(quint64 bitsPerSample)\n{\n    assert(bitsPerSample \u003c= 64);\n    switch(bitsPerSample)\n    {\n    case 8:\n        return static_cast\u003cquint64\u003e(std::numeric_limits\u003cquint8\u003e::max());\n    case 16:\n        return static_cast\u003cquint64\u003e(std::numeric_limits\u003cquint16\u003e::max());\n    case 32:\n        return static_cast\u003cquint64\u003e(std::numeric_limits\u003cquint32\u003e::max());\n    case 64:\n        return static_cast\u003cquint64\u003e(std::numeric_limits\u003cquint64\u003e::max());\n    default:\n        break;\n    }\n    return static_cast\u003cquint64\u003e(0xffffffffffffffffull \u003e\u003e (64 - bitsPerSample));\n}\n\nquint64 getMinValueUInt(quint64 bitsPerSample)\n{\n    assert(bitsPerSample \u003c= 64);\n    Q_UNUSED(bitsPerSample);\n    return 0;\n}\n\nquint64 getValueUInt(const quint8 *buffer, quint64 bitsOffset, quint64 bitsPerSample)\n{\n    assert(buffer);\n    assert(bitsPerSample \u003c= 64);\n    switch(bitsPerSample)\n    {\n    case 8:\n        assert(bitsOffset % 8 == 0);\n        return static_cast\u003cquint64\u003e(*reinterpret_cast\u003cconst quint8*\u003e(buffer + bitsOffset / 8));\n    case 16:\n        assert(bitsOffset % 8 == 0);\n        return static_cast\u003cquint64\u003e(DataProcessing::extractFromUnalignedPtr\u003cquint16\u003e(buffer + bitsOffset / 8));\n    case 32:\n        assert(bitsOffset % 8 == 0);\n        return static_cast\u003cquint64\u003e(DataProcessing::extractFromUnalignedPtr\u003cquint32\u003e(buffer + bitsOffset / 8));\n    case 64:\n        assert(bitsOffset % 8 == 0);\n        return static_cast\u003cquint64\u003e(DataProcessing::extractFromUnalignedPtr\u003cquint64\u003e(buffer + bitsOffset / 8));\n    default:\n        break;\n    }\n    return static_cast\u003cquint64\u003e(DataProcessing::getBits(buffer, bitsOffset, bitsPerSample));\n}\n\nqint64 getMaxValueSInt(quint64 bitsPerSample)\n{\n    assert(bitsPerSample \u003c= 64);\n    switch(bitsPerSample)\n    {\n    case 8:\n        return static_cast\u003cqint64\u003e(std::numeric_limits\u003cqint8\u003e::max());\n    case 16:\n        return static_cast\u003cqint64\u003e(std::numeric_limits\u003cqint16\u003e::max());\n    case 32:\n        return static_cast\u003cqint64\u003e(std::numeric_limits\u003cqint32\u003e::max());\n    case 64:\n        return static_cast\u003cqint64\u003e(std::numeric_limits\u003cqint64\u003e::max());\n    default:\n        break;\n    }\n    return static_cast\u003cqint64\u003e(0x7fffffffffffffffull \u003e\u003e (64 - bitsPerSample));\n}\n\nqint64 getMinValueSInt(quint64 bitsPerSample)\n{\n    assert(bitsPerSample \u003c= 64);\n    switch(bitsPerSample)\n    {\n    case 8:\n        return static_cast\u003cqint64\u003e(std::numeric_limits\u003cqint8\u003e::min());\n    case 16:\n        return static_cast\u003cqint64\u003e(std::numeric_limits\u003cqint16\u003e::min());\n    case 32:\n        return static_cast\u003cqint64\u003e(std::numeric_limits\u003cqint32\u003e::min());\n    case 64:\n        return static_cast\u003cqint64\u003e(std::numeric_limits\u003cqint64\u003e::min());\n    default:\n        break;\n    }\n    return static_cast\u003cqint64\u003e(~0ull \u003c\u003c (bitsPerSample - 1));\n}\n\nqint64 getValueSInt(const quint8 *buffer, quint64 bitsOffset, quint64 bitsPerSample)\n{\n    assert(buffer);\n    assert(bitsPerSample \u003c= 64);\n    switch(bitsPerSample)\n    {\n    case 8:\n        assert(bitsOffset % 8 == 0);\n        return static_cast\u003cqint64\u003e(*reinterpret_cast\u003cconst qint8*\u003e(buffer + bitsOffset / 8));\n    case 16:\n        assert(bitsOffset % 8 == 0);\n        return static_cast\u003cqint64\u003e(DataProcessing::extractFromUnalignedPtr\u003cqint16\u003e(buffer + bitsOffset / 8));\n    case 32:\n        assert(bitsOffset % 8 == 0);\n        return static_cast\u003cqint64\u003e(DataProcessing::extractFromUnalignedPtr\u003cqint32\u003e(buffer + bitsOffset / 8));\n    case 64:\n        assert(bitsOffset % 8 == 0);\n        return static_cast\u003cqint64\u003e(DataProcessing::extractFromUnalignedPtr\u003cqint64\u003e(buffer + bitsOffset / 8));\n    default:\n        break;\n    }\n    quint64 rawValue = static_cast\u003cquint64\u003e(DataProcessing::getBits(buffer, bitsOffset, bitsPerSample));\n    const quint64 signBit = (rawValue \u003e\u003e (bitsPerSample - 1)) \u0026 0x1;\n    if(signBit)\n        rawValue |= static_cast\u003cquint64\u003e(~0ull \u003c\u003c (bitsPerSample - 1));\n    return static_cast\u003cqint64\u003e(rawValue);\n}\n\nfloat getValueFP(const quint8 *buffer, quint64 bitsOffset, quint64 bitsPerSample)\n{\n    assert(buffer);\n    assert(bitsPerSample \u003c= 64);\n    switch(bitsPerSample)\n    {\n    case 16:\n        return DataProcessing::float16ToFloat(buffer + bitsOffset / 8);\n    case 24:\n        return DataProcessing::float24ToFloat(buffer + bitsOffset / 8);\n    case 32:\n        return DataProcessing::extractFromUnalignedPtr\u003cfloat\u003e(buffer + bitsOffset / 8);\n    case 64:\n        return static_cast\u003cfloat\u003e(DataProcessing::extractFromUnalignedPtr\u003cdouble\u003e(buffer + bitsOffset / 8));\n    }\n    LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Unsupported floating bits per sample =\" \u003c\u003c bitsPerSample;\n    assert(false);\n    return static_cast\u003cfloat\u003e(nan(\"\"));\n}\n\nfloat convertValueToFP(const quint8 *buffer, quint64 bitsOffset, quint16 sampleFormat, quint64 bitsPerSample)\n{\n    assert(buffer);\n    assert(bitsPerSample \u003c= 64);\n    switch(sampleFormat)\n    {\n    case SAMPLEFORMAT_UINT:\n    case SAMPLEFORMAT_VOID:\n    {\n        bitsPerSample = std::min\u003cquint64\u003e(bitsPerSample, static_cast\u003cquint64\u003e(64));\n        const double minValue = static_cast\u003cdouble\u003e(getMinValueUInt(bitsPerSample));\n        const double maxValue = static_cast\u003cdouble\u003e(getMaxValueUInt(bitsPerSample));\n        const double value = (static_cast\u003cdouble\u003e(getValueUInt(buffer, bitsOffset, bitsPerSample)) - minValue) / (maxValue - minValue);\n        return static_cast\u003cfloat\u003e(value);\n    }\n    case SAMPLEFORMAT_INT:\n    {\n        bitsPerSample = std::min\u003cquint64\u003e(bitsPerSample, static_cast\u003cquint64\u003e(64));\n        const double minValue = static_cast\u003cdouble\u003e(getMinValueSInt(bitsPerSample));\n        const double maxValue = static_cast\u003cdouble\u003e(getMaxValueSInt(bitsPerSample));\n        const double value = (static_cast\u003cdouble\u003e(getValueSInt(buffer, bitsOffset, bitsPerSample)) - minValue) / (maxValue - minValue);\n        return static_cast\u003cfloat\u003e(value);\n    }\n    case SAMPLEFORMAT_IEEEFP:\n    {\n        const float value = getValueFP(buffer, bitsOffset, bitsPerSample);\n        return value;\n    }\n    case SAMPLEFORMAT_COMPLEXINT:\n    case SAMPLEFORMAT_COMPLEXIEEEFP:\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"SAMPLEFORMAT_COMPLEXINT and SAMPLEFORMAT_COMPLEXIEEEFP are not supported\";\n        assert(false);\n        break;\n    default:\n        break;\n    }\n    return static_cast\u003cfloat\u003e(nan(\"\"));\n}\n\nquint8 convertValueToU8(const quint8 *buffer, quint64 bitsOffset, quint16 sampleFormat, quint64 bitsPerSample)\n{\n    assert(buffer);\n    assert(bitsPerSample \u003c= 64);\n    switch(sampleFormat)\n    {\n    case SAMPLEFORMAT_UINT:\n    case SAMPLEFORMAT_VOID:\n    {\n        bitsPerSample = std::min\u003cquint64\u003e(bitsPerSample, static_cast\u003cquint64\u003e(64));\n        if(bitsPerSample == 8)\n        {\n            const quint64 value = getValueUInt(buffer, bitsOffset, bitsPerSample);\n            return DataProcessing::clampByte(value);\n        }\n        if(bitsPerSample \u003c 8 || bitsPerSample \u003e 62)\n        {\n            const float value = convertValueToFP(buffer, bitsOffset, sampleFormat, bitsPerSample);\n            return DataProcessing::clampByte(value * 255.0f);\n        }\n        const quint64 shift = bitsPerSample - 8;\n        const quint64 value = getValueUInt(buffer, bitsOffset, bitsPerSample);\n        return DataProcessing::clampByte(value \u003e\u003e shift);\n    }\n    case SAMPLEFORMAT_INT:\n    {\n        bitsPerSample = std::min\u003cquint64\u003e(bitsPerSample, static_cast\u003cquint64\u003e(64));\n        if(bitsPerSample == 8)\n        {\n            const qint64 minValue = getMinValueSInt(bitsPerSample);\n            const qint64 value = getValueSInt(buffer, bitsOffset, bitsPerSample);\n            return DataProcessing::clampByte(value - minValue);\n        }\n        if(bitsPerSample \u003c 8 || bitsPerSample \u003e 62)\n        {\n            const float value = convertValueToFP(buffer, bitsOffset, sampleFormat, bitsPerSample);\n            return DataProcessing::clampByte(value * 255.0f);\n        }\n        const quint64 shift = bitsPerSample - 8;\n        const qint64 minValue = getMinValueSInt(bitsPerSample);\n        const qint64 value = getValueSInt(buffer, bitsOffset, bitsPerSample);\n        return DataProcessing::clampByte((value - minValue) \u003e\u003e shift);\n    }\n    case SAMPLEFORMAT_IEEEFP:\n    {\n        const float value = getValueFP(buffer, bitsOffset, bitsPerSample);\n        return DataProcessing::clampByte(value * 255.0f);\n    }\n    case SAMPLEFORMAT_COMPLEXINT:\n    case SAMPLEFORMAT_COMPLEXIEEEFP:\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"SAMPLEFORMAT_COMPLEXINT and SAMPLEFORMAT_COMPLEXIEEEFP are not supported\";\n        assert(false);\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\n// ====================================================================================================\n\nQImage readFromRawBuffer(const quint8 *buffer, qint64 width, qint64 height, qint64 bufferLineSize, const Context *ctx)\n{\n    assert(buffer);\n    assert(ctx);\n\n    switch(ctx-\u003ephotometric)\n    {\n    case PHOTOMETRIC_MINISWHITE:\n    case PHOTOMETRIC_MINISBLACK:\n    case PHOTOMETRIC_LOGL: // TIFFTAG_SGILOGDATAFMT == SGILOGDATAFMT_8BIT is required\n    {\n        assert(ctx-\u003eprimarysamplesCount \u003e= 1);\n        const QImage::Format resultFormat = ctx-\u003ealphaIndex \u003e= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32;\n#if (USE_GRAYSCALE_8)\n        QImage result(width, height, QImage::Format_Grayscale8);\n        QImage alphaChannel;\n        if(ctx-\u003ealphaIndex \u003e= 0)\n            alphaChannel = QImage(width, height, QImage::Format_Alpha8);\n#else\n        QImage result(width, height, resultFormat);\n#endif\n        if(result.isNull())\n        {\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid image size\";\n            return result;\n        }\n        for(qint64 y = 0; y \u003c height; ++y)\n        {\n            QRgb *outPtr = reinterpret_cast\u003cQRgb*\u003e(result.scanLine(y));\n            const quint8 *inPtr = reinterpret_cast\u003cconst quint8*\u003e(buffer + bufferLineSize * y);\n            for(qint64 x = 0; x \u003c width; ++x)\n            {\n                const qint64 bitOffset = x * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample;\n                quint8 gray = convertValueToU8(inPtr, static_cast\u003cquint64\u003e(bitOffset), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                if(ctx-\u003ephotometric == PHOTOMETRIC_MINISWHITE)\n                    gray = 255 - gray;\n                quint8 alpha = 255;\n                if(ctx-\u003ealphaIndex \u003e= 0)\n                {\n                    alpha = convertValueToU8(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * (ctx-\u003eprimarysamplesCount + ctx-\u003ealphaIndex)), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                    if(ctx-\u003ephotometric == PHOTOMETRIC_MINISWHITE)\n                        alpha = 255 - alpha;\n                }\n\n#if (USE_GRAYSCALE_8)\n                if(ctx-\u003ealphaPremultiplied)\n                    reinterpret_cast\u003cquint8*\u003e(outPtr)[x] = qGray(DataProcessing::unpremultiply(qRgba(gray, gray, gray, alpha)));\n                else\n                    reinterpret_cast\u003cquint8*\u003e(outPtr)[x] = gray;\n                if(!alphaChannel.isNull())\n                    *reinterpret_cast\u003cquint8*\u003e(alphaChannel.scanLine(y) + x) = alpha;\n#else\n                if(ctx-\u003ealphaPremultiplied)\n                    outPtr[x] = DataProcessing::unpremultiply(qRgba(gray, gray, gray, alpha));\n                else\n                    outPtr[x] = qRgba(gray, gray, gray, alpha);\n#endif\n            }\n        }\n        if(ctx-\u003eiccProfile)\n            ctx-\u003eiccProfile-\u003eapplyToImage(\u0026result);\n#if (USE_GRAYSCALE_8)\n        if(!alphaChannel.isNull())\n        {\n            if(result.hasAlphaChannel())\n                QImage_convertTo(result, QImage::Format_RGB32);\n            QImage_convertTo(result, QImage::Format_ARGB32);\n            result.setAlphaChannel(alphaChannel);\n        }\n#endif\n        if(!IsOneOf(result.format(), resultFormat, QImage::Format_RGB32, QImage::Format_ARGB32))\n            QImage_convertTo(result, resultFormat);\n        return result;\n    }\n    case PHOTOMETRIC_RGB:\n    case PHOTOMETRIC_LOGLUV: // TIFFTAG_SGILOGDATAFMT == SGILOGDATAFMT_8BIT is required\n    {\n        assert(ctx-\u003eprimarysamplesCount \u003e= 3);\n        const QImage::Format resultFormat = ctx-\u003ealphaIndex \u003e= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32;\n        QImage result(width, height, resultFormat);\n        if(result.isNull())\n        {\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid image size\";\n            return result;\n        }\n        for(qint64 y = 0; y \u003c height; ++y)\n        {\n            QRgb *outPtr = reinterpret_cast\u003cQRgb*\u003e(result.scanLine(y));\n            const quint8 *inPtr = reinterpret_cast\u003cconst quint8*\u003e(buffer + bufferLineSize * y);\n            for(qint64 x = 0; x \u003c width; ++x)\n            {\n                const qint64 bitOffset = x * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample;\n                const quint8 red = convertValueToU8(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * 0), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                const quint8 green = convertValueToU8(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * 1), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                const quint8 blue = convertValueToU8(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * 2), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                const quint8 alpha = ctx-\u003ealphaIndex \u003e= 0\n                        ? convertValueToU8(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * (ctx-\u003eprimarysamplesCount + ctx-\u003ealphaIndex)), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample))\n                        : 255;\n                if(ctx-\u003ealphaPremultiplied)\n                    outPtr[x] = DataProcessing::unpremultiply(qRgba(red, green, blue, alpha));\n                else\n                    outPtr[x] = qRgba(red, green, blue, alpha);\n            }\n        }\n        if(ctx-\u003eiccProfile)\n            ctx-\u003eiccProfile-\u003eapplyToImage(\u0026result);\n        if(!IsOneOf(result.format(), resultFormat, QImage::Format_RGB32, QImage::Format_ARGB32))\n            QImage_convertTo(result, resultFormat);\n        return result;\n    }\n    case PHOTOMETRIC_SEPARATED:\n    {\n        assert(ctx-\u003eprimarysamplesCount \u003e= 4);\n        const QImage::Format resultFormat = ctx-\u003ealphaIndex \u003e= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32;\n#if (USE_CMYK_8888)\n        QImage result(width, height, QImage::Format_CMYK8888);\n        QImage alphaChannel;\n        if(ctx-\u003ealphaIndex \u003e= 0)\n            alphaChannel = QImage(width, height, QImage::Format_Alpha8);\n#else\n        QImage result(width, height, resultFormat);\n#endif\n        if(result.isNull())\n        {\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid image size\";\n            return result;\n        }\n        for(qint64 y = 0; y \u003c height; ++y)\n        {\n            QRgb *outPtr = reinterpret_cast\u003cQRgb*\u003e(result.scanLine(y));\n            const quint8 *inPtr = reinterpret_cast\u003cconst quint8*\u003e(buffer + bufferLineSize * y);\n            for(qint64 x = 0; x \u003c width; ++x)\n            {\n                const qint64 bitOffset = x * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample;\n                const quint8 cyan = convertValueToU8(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * 0), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                const quint8 magenta = convertValueToU8(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * 1), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                const quint8 yellow = convertValueToU8(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * 2), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                const quint8 key = convertValueToU8(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * 3), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                const quint8 alpha = ctx-\u003ealphaIndex \u003e= 0\n                        ? convertValueToU8(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * (ctx-\u003eprimarysamplesCount + ctx-\u003ealphaIndex)), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample))\n                        : 255;\n                /// @todo Why alpha is not premultiplied in CMYK images from Adobe Photoshop even for EXTRASAMPLE_ASSOCALPHA?\n#if (USE_CMYK_8888)\n                quint8 *outColor = reinterpret_cast\u003cquint8*\u003e(outPtr + x);\n                outColor[0] = cyan;\n                outColor[1] = magenta;\n                outColor[2] = yellow;\n                outColor[3] = key;\n                if(!alphaChannel.isNull())\n                    *reinterpret_cast\u003cquint8*\u003e(alphaChannel.scanLine(y) + x) = alpha;\n#else\n                outPtr[x] = DataProcessing::CMYK8ToRgba(cyan, magenta, yellow, key, alpha);\n#endif\n            }\n        }\n        if(ctx-\u003eiccProfile)\n            ctx-\u003eiccProfile-\u003eapplyToImage(\u0026result);\n#if (USE_CMYK_8888)\n        if(!alphaChannel.isNull())\n        {\n            if(result.hasAlphaChannel())\n                QImage_convertTo(result, QImage::Format_RGB32);\n            QImage_convertTo(result, QImage::Format_ARGB32);\n            result.setAlphaChannel(alphaChannel);\n        }\n#endif\n        if(!IsOneOf(result.format(), resultFormat, QImage::Format_RGB32, QImage::Format_ARGB32))\n            QImage_convertTo(result, resultFormat);\n        return result;\n    }\n    case PHOTOMETRIC_YCBCR:\n    {\n        assert(ctx-\u003eprimarysamplesCount == 3);\n        const QImage::Format resultFormat = ctx-\u003ealphaIndex \u003e= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32;\n        QImage result(width, height, resultFormat);\n        if(result.isNull())\n        {\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid image size\";\n            return result;\n        }\n        if(ctx-\u003esubsamplinghor \u003e 1 || ctx-\u003esubsamplingver \u003e 1)\n        {\n            QImage upsampledCbCr(result.width(), result.height(), QImage::Format_ARGB32);\n            if(upsampledCbCr.isNull())\n            {\n                LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid upsampled image size\";\n                goto NoUpsampling;\n            }\n            for(qint64 y = 0; y \u003c height; ++y)\n            {\n                quint8 *outPtr = reinterpret_cast\u003cquint8*\u003e(upsampledCbCr.scanLine(y));\n                const quint8 *inPtr = reinterpret_cast\u003cconst quint8*\u003e(buffer + bufferLineSize * y);\n                for(qint64 x = 0; x \u003c width; ++x)\n                {\n                    const qint64 bitOffset = x * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample;\n                    const quint8 Cb = convertValueToU8(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * 1), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                    const quint8 Cr = convertValueToU8(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * 2), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                    outPtr[x * 4 + 0] = outPtr[x * 4 + 2] = Cb;\n                    outPtr[x * 4 + 1] = outPtr[x * 4 + 3] = Cr;\n                }\n            }\n            if(ctx-\u003esubsamplinghor \u003e 1)\n            {\n                for(qint64 y = 0; y \u003c height; y += ctx-\u003esubsamplingver)\n                {\n                    quint8 *outPtr = reinterpret_cast\u003cquint8*\u003e(upsampledCbCr.scanLine(y));\n                    const quint8 *inPtr = reinterpret_cast\u003cconst quint8*\u003e(upsampledCbCr.scanLine(y));\n                    for(qint64 x = 0; x \u003c width; ++x)\n                    {\n                        qint64 leftIndex;\n                        float rightWeight;\n                        if(ctx-\u003eycbcrpositioning == YCBCRPOSITION_COSITED)\n                        {\n                            leftIndex = std::max\u003cqint64\u003e(0, x - (x % ctx-\u003esubsamplinghor));\n                            rightWeight = static_cast\u003cfloat\u003e(x - leftIndex) / static_cast\u003cfloat\u003e(ctx-\u003esubsamplinghor);\n                        }\n                        else\n                        {\n                            const float leftPos = static_cast\u003cfloat\u003e(x - (x % ctx-\u003esubsamplinghor) - (((x % ctx-\u003esubsamplinghor) \u003e= ctx-\u003esubsamplinghor / 2) ? 0 : ctx-\u003esubsamplinghor))\n                                    + static_cast\u003cfloat\u003e(ctx-\u003esubsamplinghor - 1) / 2.0f;\n                            leftIndex = std::max\u003cqint64\u003e(0, static_cast\u003cint\u003e(leftPos));\n                            rightWeight = (static_cast\u003cfloat\u003e(x) - leftPos) / static_cast\u003cfloat\u003e(ctx-\u003esubsamplinghor);\n                        }\n                        const qint64 rightIndex = std::min\u003cqint64\u003e(width - 1, leftIndex + ctx-\u003esubsamplinghor);\n                        const float leftWeight = 1.0f - rightWeight;\n                        for(qint64 c = 0; c \u003c 2; ++c)\n                        {\n                            const quint8 leftValue = inPtr[leftIndex * 4 + c];\n                            const quint8 rightValue = inPtr[rightIndex * 4 + c];\n                            const float newValue = static_cast\u003cfloat\u003e(leftValue) * leftWeight + static_cast\u003cfloat\u003e(rightValue) * rightWeight;\n                            outPtr[x * 4 + c + 2] = DataProcessing::clampByte(newValue);\n                        }\n                    }\n                    for(qint64 x = 0; x \u003c width; ++x)\n                    {\n                        for(qint64 c = 0; c \u003c 2; ++c)\n                            outPtr[x * 4 + c] = outPtr[x * 4 + c + 2];\n                    }\n                    for(qint64 i = 0; i \u003c ctx-\u003esubsamplingver \u0026\u0026 y + i \u003c height; ++i)\n                        memcpy(upsampledCbCr.scanLine(y + i), outPtr, width * 4);\n                }\n            }\n            if(ctx-\u003esubsamplingver \u003e 1)\n            {\n                for(qint64 y = 0; y \u003c height; ++y)\n                {\n                    qint64 upIndex;\n                    float downWeight;\n                    if(ctx-\u003eycbcrpositioning == YCBCRPOSITION_COSITED)\n                    {\n                        upIndex = std::max\u003cqint64\u003e(0, y - (y % ctx-\u003esubsamplingver));\n                        downWeight = static_cast\u003cfloat\u003e(y - upIndex) / static_cast\u003cfloat\u003e(ctx-\u003esubsamplingver);\n                    }\n                    else\n                    {\n                        const float upPos = static_cast\u003cfloat\u003e(y - (y % ctx-\u003esubsamplingver) - (((y % ctx-\u003esubsamplingver) \u003e= ctx-\u003esubsamplingver / 2) ? 0 : ctx-\u003esubsamplingver))\n                                + static_cast\u003cfloat\u003e(ctx-\u003esubsamplingver - 1) / 2.0f;\n                        upIndex = std::max\u003cqint64\u003e(0, static_cast\u003cint\u003e(upPos));\n                        downWeight = (static_cast\u003cfloat\u003e(y) - upPos) / static_cast\u003cfloat\u003e(ctx-\u003esubsamplingver);\n                    }\n                    const qint64 downIndex = std::min\u003cqint64\u003e(height - 1, upIndex + ctx-\u003esubsamplingver);\n                    const float upWeight = 1.0f - downWeight;\n                    const quint8 *upPtr = reinterpret_cast\u003cconst quint8*\u003e(upsampledCbCr.scanLine(upIndex));\n                    const quint8 *downPtr = reinterpret_cast\u003cconst quint8*\u003e(upsampledCbCr.scanLine(downIndex));\n                    quint8 *outPtr = reinterpret_cast\u003cquint8*\u003e(upsampledCbCr.scanLine(y));\n                    for(qint64 x = 0; x \u003c width; ++x)\n                    {\n                        for(qint64 c = 0; c \u003c 2; ++c)\n                        {\n                            const quint8 upValue = upPtr[x * 4 + c];\n                            const quint8 downValue = downPtr[x * 4 + c];\n                            const float newValue = static_cast\u003cfloat\u003e(upValue) * upWeight + static_cast\u003cfloat\u003e(downValue) * downWeight;\n                            outPtr[x * 4 + c + 2] = DataProcessing::clampByte(newValue);\n                        }\n                    }\n                }\n                for(qint64 y = 0; y \u003c height; ++y)\n                {\n                    quint8 *outPtr = reinterpret_cast\u003cquint8*\u003e(upsampledCbCr.scanLine(y));\n                    for(qint64 x = 0; x \u003c width; ++x)\n                    {\n                        for(qint64 c = 0; c \u003c 2; ++c)\n                            outPtr[x * 4 + c] = outPtr[x * 4 + c + 2];\n                    }\n                }\n            }\n            for(qint64 y = 0; y \u003c height; ++y)\n            {\n                QRgb *outPtr = reinterpret_cast\u003cQRgb*\u003e(result.scanLine(y));\n                const quint8 *inPtr = reinterpret_cast\u003cconst quint8*\u003e(buffer + bufferLineSize * y);\n                const quint8 *inCbCrPtr = reinterpret_cast\u003cconst quint8*\u003e(upsampledCbCr.scanLine(y));\n                for(qint64 x = 0; x \u003c width; ++x)\n                {\n                    const qint64 bitOffset = x * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample;\n                    float Y  = convertValueToFP(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * 0), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                    float Cb = inCbCrPtr[x * 4 + 0] / 255.0f;\n                    float Cr = inCbCrPtr[x * 4 + 1] / 255.0f;\n                    const float alpha = ctx-\u003ealphaIndex \u003e= 0\n                            ? convertValueToFP(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * (ctx-\u003eprimarysamplesCount + ctx-\u003ealphaIndex)), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample))\n                            : 1.0f;\n                    if(ctx-\u003ealphaPremultiplied)\n                    {\n                        const float alphaScale = alpha \u003e 0.0f ? (1.0f / alpha) : 1.0f;\n                        Y *= alphaScale;\n                        Cb *= alphaScale;\n                        Cr *= alphaScale;\n                    }\n                    Cb -= 0.5f;\n                    Cr -= 0.5f;\n                    outPtr[x] = DataProcessing::YCbCrToRgba(Y, Cb, Cr, alpha, ctx-\u003eycbcrcoeffs);\n                }\n            }\n        }\n        else\n        {\nNoUpsampling:\n            for(qint64 y = 0; y \u003c height; ++y)\n            {\n                QRgb *outPtr = reinterpret_cast\u003cQRgb*\u003e(result.scanLine(y));\n                const quint8 *inPtr = reinterpret_cast\u003cconst quint8*\u003e(buffer + bufferLineSize * y);\n                for(qint64 x = 0; x \u003c width; ++x)\n                {\n                    const qint64 bitOffset = x * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample;\n                    float Y  = convertValueToFP(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * 0), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                    float Cb = convertValueToFP(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * 1), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                    float Cr = convertValueToFP(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * 2), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                    const float alpha = ctx-\u003ealphaIndex \u003e= 0\n                            ? convertValueToFP(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * (ctx-\u003eprimarysamplesCount + ctx-\u003ealphaIndex)), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample))\n                            : 1.0f;\n                    if(ctx-\u003ealphaPremultiplied)\n                    {\n                        const float alphaScale = alpha \u003e 0.0f ? (1.0f / alpha) : 1.0f;\n                        Y *= alphaScale;\n                        Cb *= alphaScale;\n                        Cr *= alphaScale;\n                    }\n                    Cb -= 0.5f;\n                    Cr -= 0.5f;\n                    outPtr[x] = DataProcessing::YCbCrToRgba(Y, Cb, Cr, alpha, ctx-\u003eycbcrcoeffs);\n                }\n            }\n        }\n        if(ctx-\u003eiccProfile)\n            ctx-\u003eiccProfile-\u003eapplyToImage(\u0026result);\n        if(!IsOneOf(result.format(), resultFormat, QImage::Format_RGB32, QImage::Format_ARGB32))\n            QImage_convertTo(result, resultFormat);\n        return result;\n    }\n    case PHOTOMETRIC_CIELAB:\n    case PHOTOMETRIC_ICCLAB:\n    case PHOTOMETRIC_ITULAB:\n    {\n        assert(ctx-\u003eprimarysamplesCount \u003e= 1);\n        const QImage::Format resultFormat = ctx-\u003ealphaIndex \u003e= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32;\n        QImage result(width, height, resultFormat);\n        if(result.isNull())\n        {\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid image size\";\n            return result;\n        }\n        for(qint64 y = 0; y \u003c height; ++y)\n        {\n            QRgb *outPtr = reinterpret_cast\u003cQRgb*\u003e(result.scanLine(y));\n            const quint8 *inPtr = reinterpret_cast\u003cconst quint8*\u003e(buffer + bufferLineSize * y);\n            for(qint64 x = 0; x \u003c width; ++x)\n            {\n                quint16 abSampleFormat = ctx-\u003esampleFormat;\n                /// @note CIELAB is meaningless for unsigned input, as for ITULAB is meaningless for signed input.\n                /// But we will try to fix some ill-formed files with wrong sample format because it should be safe\n                if(ctx-\u003ephotometric == PHOTOMETRIC_CIELAB \u0026\u0026 IsOneOf(ctx-\u003esampleFormat, SAMPLEFORMAT_VOID, SAMPLEFORMAT_UINT))\n                    abSampleFormat = SAMPLEFORMAT_INT;\n                else if(IsOneOf(ctx-\u003ephotometric, PHOTOMETRIC_ITULAB, PHOTOMETRIC_ITULAB) \u0026\u0026 IsOneOf(ctx-\u003esampleFormat, SAMPLEFORMAT_VOID, SAMPLEFORMAT_INT))\n                    abSampleFormat = SAMPLEFORMAT_UINT;\n                const qint64 bitOffset = x * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample;\n                float L = convertValueToFP(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * 0), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                float a = ctx-\u003eprimarysamplesCount \u003e= 3\n                        ? convertValueToFP(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * 1), abSampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample))\n                        : 0.0f;\n                float b = ctx-\u003eprimarysamplesCount \u003e= 3\n                        ? convertValueToFP(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * 2), abSampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample))\n                        : 0.0f;\n                const float alpha = ctx-\u003ealphaIndex \u003e= 0\n                        ? convertValueToFP(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * (ctx-\u003eprimarysamplesCount + ctx-\u003ealphaIndex)), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample))\n                        : 1.0f;\n                if(ctx-\u003ealphaPremultiplied)\n                {\n                    const float alphaScale = alpha \u003e 0.0f ? (1.0f / alpha) : 1.0f;\n                    L *= alphaScale;\n                    a *= alphaScale;\n                    b *= alphaScale;\n                }\n                L *= 100.0f;\n                if(ctx-\u003eprimarysamplesCount \u003e= 3)\n                {\n                    if(ctx-\u003ephotometric == PHOTOMETRIC_ITULAB)\n                    {\n                        a = (-21760.0f / 255.0f) + a * ((21590.0f / 255.0f) - (-21760.0f / 255.0f));\n                        b = (-19200.0f / 255.0f) + b * ((31800.0f / 255.0f) - (-19200.0f / 255.0f));\n                    }\n                    else\n                    {\n                        a = a * 256.0f - 128.0f;\n                        b = b * 256.0f - 128.0f;\n                    }\n                }\n                outPtr[x] = DataProcessing::LabToRgba(L, a, b, alpha);\n            }\n        }\n        if(ctx-\u003eiccProfile)\n            ctx-\u003eiccProfile-\u003eapplyToImage(\u0026result);\n        if(!IsOneOf(result.format(), resultFormat, QImage::Format_RGB32, QImage::Format_ARGB32))\n            QImage_convertTo(result, resultFormat);\n        return result;\n    }\n    case PHOTOMETRIC_PALETTE:\n    {\n        assert(ctx-\u003eredTable);\n        assert(ctx-\u003egreenTable);\n        assert(ctx-\u003eblueTable);\n        assert(ctx-\u003eprimarysamplesCount \u003e= 1);\n        const QImage::Format resultFormat = ctx-\u003ealphaIndex \u003e= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32;\n        QImage result(width, height, resultFormat);\n        if(result.isNull())\n        {\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid image size\";\n            return result;\n        }\n        const quint16 shiftFor8BitColors = ctx-\u003ecolorTablesIs16Bit ? 8 : 0;\n        for(qint64 y = 0; y \u003c height; ++y)\n        {\n            QRgb *outPtr = reinterpret_cast\u003cQRgb*\u003e(result.scanLine(y));\n            const quint8 *inPtr = reinterpret_cast\u003cconst quint8*\u003e(buffer + bufferLineSize * y);\n            for(qint64 x = 0; x \u003c width; ++x)\n            {\n                const qint64 bitOffset = x * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample;\n                const quint64 colorIndex = getValueUInt(inPtr, static_cast\u003cquint64\u003e(bitOffset), static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                assert(colorIndex \u003c= getMaxValueUInt(static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample)));\n                const quint8 red = ctx-\u003eredTable[colorIndex] \u003e\u003e shiftFor8BitColors;\n                const quint8 green = ctx-\u003egreenTable[colorIndex] \u003e\u003e shiftFor8BitColors;\n                const quint8 blue = ctx-\u003eblueTable[colorIndex] \u003e\u003e shiftFor8BitColors;\n                const quint8 alpha = ctx-\u003ealphaIndex \u003e= 0\n                        ? convertValueToU8(inPtr, static_cast\u003cquint64\u003e(bitOffset + ctx-\u003ebitsPerSample * (ctx-\u003eprimarysamplesCount + ctx-\u003ealphaIndex)), ctx-\u003esampleFormat, static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample))\n                        : 255;\n                if(ctx-\u003ealphaPremultiplied)\n                    outPtr[x] = DataProcessing::unpremultiply(qRgba(red, green, blue, alpha));\n                else\n                    outPtr[x] = qRgba(red, green, blue, alpha);\n            }\n        }\n        if(ctx-\u003eiccProfile)\n            ctx-\u003eiccProfile-\u003eapplyToImage(\u0026result);\n        if(!IsOneOf(result.format(), resultFormat, QImage::Format_RGB32, QImage::Format_ARGB32))\n            QImage_convertTo(result, resultFormat);\n        return result;\n    }\n    default:\n        break;\n    }\n    return QImage();\n}\n\n// ====================================================================================================\n\nQImage readTiffFileTiledContig(const Context *ctx, qint64 nTiles, qint64 tileWidth, qint64 tileHeight)\n{\n    assert(ctx);\n    assert(ctx-\u003etiff);\n    assert(nTiles \u003e 0);\n    assert(tileWidth \u003e 0);\n    assert(tileHeight \u003e 0);\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Tiled data with single image plane of data detected\";\n\n    QImage result(ctx-\u003ewidth, ctx-\u003eheight, ctx-\u003ealphaIndex \u003e= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n    if(result.isNull())\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid image size\";\n        return QImage();\n    }\n    result.fill(ctx-\u003ealphaIndex \u003e= 0 ? Qt::transparent : Qt::white);\n\n    const qint64 bufferAllocSize = tileWidth * tileHeight * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample / 8;\n    if(bufferAllocSize \u003e BUFFER_MAX_SIZE)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't allocate buffer with size =\" \u003c\u003c bufferAllocSize \u003c\u003c \"due to allocation limit =\" \u003c\u003c BUFFER_MAX_SIZE;\n        return QImage();\n    }\n\n    QByteArray buffer;\n    buffer.resize(bufferAllocSize);\n\n    const qint64 leftX = ctx-\u003ewidth % tileWidth;\n    const qint64 leftY = ctx-\u003eheight % tileHeight;\n    const qint64 nTilesX = (ctx-\u003ewidth / tileWidth)   + (leftX == 0 ? 0 : 1);\n    const qint64 nTilesY = (ctx-\u003eheight / tileHeight) + (leftY == 0 ? 0 : 1);\n    const qint64 tileLineSize = tileWidth * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample / 8;\n\n    bool somethingReaded = false;\n    for(qint64 tile = 0; tile \u003c nTiles; ++tile)\n    {\n        memset(buffer.data(), BUFFER_FILL_PATTERN, static_cast\u003csize_t\u003e(buffer.size()));\n        const qint64 currTileX = tile % nTilesX;\n        const qint64 currTileY = tile / nTilesX;\n        const qint64 currTileWidth  = ((currTileX == nTilesX - 1) \u0026\u0026 leftX) ? leftX : tileWidth;\n        const qint64 currTileHeight = ((currTileY == nTilesY - 1) \u0026\u0026 leftY) ? leftY : tileHeight;\n        const qint64 expectedTileBufferSize = tileLineSize * tileHeight;\n        assert(bufferAllocSize \u003e= expectedTileBufferSize);\n#if !defined (DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER)\n        qint64 bufferSize = TIFFReadEncodedTile(ctx-\u003etiff, static_cast\u003cquint32\u003e(tile), buffer.data(), buffer.size());\n#else\n        qint64 bufferSize = -1;\n#endif\n#if defined (DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER)\n        bufferSize = -1;\n#endif\n        if(bufferSize \u003c= 0)\n        {\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFReadEncodedTile failed for tile\" \u003c\u003c tile;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n            /// @todo LibTIFF-4.6.0: Repeated read is not supported for some compression formats (e.g. OJPEG)\n            /// So let's check current buffer, it may be already filled with all available data\n            bool bufferIsEmpty = true;\n            for(qint64 i = 0; i \u003c buffer.size() \u0026\u0026 bufferIsEmpty; ++i)\n            {\n                if(*reinterpret_cast\u003cquint8*\u003e(buffer.data() + i) != BUFFER_FILL_PATTERN)\n                    bufferIsEmpty = false;\n            }\n            if(bufferIsEmpty)\n            {\n                for(qint64 row = currTileHeight; row \u003e= 1; --row)\n                {\n                    const qint64 newSize = TIFFReadEncodedTile(ctx-\u003etiff, static_cast\u003cquint32\u003e(tile), buffer.data(), row * tileLineSize);\n                    if(newSize \u003e 0)\n                    {\n                        LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Recovered rows:\" \u003c\u003c row \u003c\u003c \"of\" \u003c\u003c currTileHeight;\n                        bufferSize = std::max(expectedTileBufferSize, newSize);\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Buffer has some data, assume recovered\";\n                bufferSize = expectedTileBufferSize;\n            }\n#endif\n            if(bufferSize \u003c= 0)\n                continue;\n        }\n        if(bufferSize \u003c expectedTileBufferSize)\n        {\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFReadEncodedTile returns not enough data to decode tile\" \u003c\u003c tile \u003c\u003c \"got:\" \u003c\u003c bufferSize \u003c\u003c \"expected:\" \u003c\u003c expectedTileBufferSize;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n            bufferSize = expectedTileBufferSize;\n#else\n            continue;\n#endif\n        }\n\n        assert(tileLineSize * tileHeight \u003c= bufferSize);\n        const QImage tileRgb = readFromRawBuffer(reinterpret_cast\u003cconst quint8*\u003e(buffer.data()), tileWidth, tileHeight, tileLineSize, ctx);\n        if(tileRgb.isNull())\n            continue;\n\n        assert(IsOneOf(tileRgb.format(), QImage::Format_ARGB32, QImage::Format_RGB32));\n        for(qint64 y = 0; y \u003c currTileHeight; ++y)\n        {\n            const QRgb *inScanLine = reinterpret_cast\u003cconst QRgb*\u003e(tileRgb.scanLine(y));\n            QRgb *outScanLine = reinterpret_cast\u003cQRgb*\u003e(result.scanLine(currTileY * tileHeight + y)) + currTileX * tileWidth;\n            memcpy(outScanLine, inScanLine, static_cast\u003csize_t\u003e(currTileWidth * 4));\n        }\n        somethingReaded = true;\n    }\n\n    if(!somethingReaded)\n        return QImage();\n    return result;\n}\n\nQImage readTiffFileTiledContigSubsampled(const Context *ctx, qint64 nTiles, qint64 tileWidth, qint64 tileHeight)\n{\n    assert(ctx);\n    assert(ctx-\u003etiff);\n    assert(nTiles \u003e 0);\n    assert(tileWidth \u003e 0);\n    assert(tileHeight \u003e 0);\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Tiled data with single image plane of subsampled data detected\";\n\n    QImage result(ctx-\u003ewidth, ctx-\u003eheight, ctx-\u003ealphaIndex \u003e= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n    if(result.isNull())\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid image size\";\n        return QImage();\n    }\n    result.fill(ctx-\u003ealphaIndex \u003e= 0 ? Qt::transparent : Qt::white);\n\n    const qint64 bufferAllocSize = (tileWidth + 4) * (tileHeight + 4) * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample / 8;\n    if(bufferAllocSize \u003e BUFFER_MAX_SIZE)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't allocate buffer with size =\" \u003c\u003c bufferAllocSize \u003c\u003c \"due to allocation limit =\" \u003c\u003c BUFFER_MAX_SIZE;\n        return QImage();\n    }\n\n    QByteArray buffer;\n    buffer.resize(bufferAllocSize);\n\n    QByteArray tileBuffer;\n    tileBuffer.resize(bufferAllocSize);\n\n    const qint64 leftX = ctx-\u003ewidth % tileWidth;\n    const qint64 leftY = ctx-\u003eheight % tileHeight;\n    const qint64 nTilesX = (ctx-\u003ewidth / tileWidth)   + (leftX == 0 ? 0 : 1);\n    const qint64 nTilesY = (ctx-\u003eheight / tileHeight) + (leftY == 0 ? 0 : 1);\n    const qint64 tileLineBitSize = tileWidth * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample;\n    const qint64 tileLineSize = tileLineBitSize / 8;\n    const qint64 tileWidthAligned = tileWidth + (tileWidth % ctx-\u003esubsamplinghor \u003e 0 ? (ctx-\u003esubsamplinghor - tileWidth % ctx-\u003esubsamplinghor) : 0);\n    const qint64 tileHeightAligned = tileHeight + (tileHeight % ctx-\u003esubsamplingver \u003e 0 ? (ctx-\u003esubsamplingver - tileHeight % ctx-\u003esubsamplingver) : 0);\n\n    bool somethingReaded = false;\n    for(qint64 tile = 0; tile \u003c nTiles; ++tile)\n    {\n        memset(buffer.data(), BUFFER_FILL_PATTERN, static_cast\u003csize_t\u003e(buffer.size()));\n        memset(tileBuffer.data(), BUFFER_FILL_PATTERN, static_cast\u003csize_t\u003e(tileBuffer.size()));\n        const qint64 currTileX = tile % nTilesX;\n        const qint64 currTileY = tile / nTilesX;\n        const qint64 currTileWidth  = ((currTileX == nTilesX - 1) \u0026\u0026 leftX) ? leftX : tileWidth;\n        const qint64 currTileHeight = ((currTileY == nTilesY - 1) \u0026\u0026 leftY) ? leftY : tileHeight;\n        const qint64 expectedTileBufferSize = tileHeight * tileWidth * (ctx-\u003esamplesPerPixel - 2) * ctx-\u003ebitsPerSample / 8 + tileHeight / ctx-\u003esubsamplingver * tileWidth / ctx-\u003esubsamplinghor * 2 * ctx-\u003ebitsPerSample / 8;\n        const qint64 expectedTileBufferSizeAligned = expectedTileBufferSize * tileWidthAligned * tileHeightAligned / tileHeight / tileWidth;\n        assert(tileBuffer.size() \u003e= expectedTileBufferSizeAligned);\n#if !defined (DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER)\n        qint64 tileBufferSize = TIFFReadEncodedTile(ctx-\u003etiff, static_cast\u003cquint32\u003e(tile), tileBuffer.data(), tileBuffer.size());\n#else\n        qint64 tileBufferSize = -1;\n#endif\n#if defined (DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER)\n        tileBufferSize = -1;\n#endif\n        if(tileBufferSize \u003c= 0)\n        {\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFReadEncodedTile failed for tile\" \u003c\u003c tile;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n            /// @todo LibTIFF-4.6.0: Repeated read is not supported for some compression formats (e.g. OJPEG)\n            /// So let's check current buffer, it may be already filled with all available data\n            bool bufferIsEmpty = true;\n            for(qint64 i = 0; i \u003c tileBuffer.size() \u0026\u0026 bufferIsEmpty; ++i)\n            {\n                if(*reinterpret_cast\u003cquint8*\u003e(tileBuffer.data() + i) != BUFFER_FILL_PATTERN)\n                    bufferIsEmpty = false;\n            }\n            if(bufferIsEmpty)\n            {\n                const qint64 currTileHeightAligned = currTileHeight + (currTileHeight % ctx-\u003esubsamplingver \u003e 0 ? (ctx-\u003esubsamplingver - currTileHeight % ctx-\u003esubsamplingver) : 0);\n                for(qint64 row = currTileHeightAligned; row \u003e= ctx-\u003esubsamplingver; row -= ctx-\u003esubsamplingver)\n                {\n                    const qint64 newSize = TIFFReadEncodedTile(ctx-\u003etiff, static_cast\u003cquint32\u003e(tile), tileBuffer.data(), row * expectedTileBufferSize / tileHeight);\n                    if(newSize \u003e 0)\n                    {\n                        LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Recovered rows:\" \u003c\u003c row \u003c\u003c \"of\" \u003c\u003c currTileHeightAligned;\n                        tileBufferSize = std::max(expectedTileBufferSizeAligned, newSize);\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Buffer has some data, assume recovered\";\n                tileBufferSize = expectedTileBufferSize;\n            }\n#endif\n            if(tileBufferSize \u003c= 0)\n                continue;\n        }\n        if(tileBufferSize \u003c expectedTileBufferSize)\n        {\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFReadEncodedTile returns not enough data to decode tile\" \u003c\u003c tile \u003c\u003c \"got:\" \u003c\u003c tileBufferSize \u003c\u003c \"expected:\" \u003c\u003c expectedTileBufferSize;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n            tileBufferSize = expectedTileBufferSizeAligned;\n#else\n            Q_UNUSED(expectedTileBufferSizeAligned);\n            continue;\n#endif\n        }\n\n        const qint64 tileScanlineSize = tileBufferSize / ctx-\u003esubsamplinghor / tileHeight * ctx-\u003esubsamplingver;\n#if !defined (DEBUG_FORCE_BIT_ACCESS)\n        if(ctx-\u003ebitsPerSample % 8 == 0)\n#else\n        if(false)\n#endif\n        {\n            qint64 bufferLinePos = 0;\n            qint64 bufferOffset = bufferLinePos;\n            qint64 tileBufferLinePos = 0;\n            qint64 tileBufferOffset = tileBufferLinePos;\n\n            while(tileBufferOffset \u003c tileBufferSize \u0026\u0026 bufferOffset \u003c buffer.size())\n            {\n                for(qint64 c = 0; c \u003c ctx-\u003esamplesPerPixel; ++c)\n                {\n                    const bool isChroma = IsOneOf(c, 1, 2);\n                    if(!isChroma)\n                    {\n                        for(qint64 y = 0; y \u003c ctx-\u003esubsamplingver; ++y)\n                        {\n                            for(qint64 x = 0; x \u003c ctx-\u003esubsamplinghor; ++x)\n                            {\n                                const qint64 bufferCurrOffset = bufferOffset + y * tileLineSize + x * ctx-\u003ebitsPerSample / 8 * ctx-\u003esamplesPerPixel + c * ctx-\u003ebitsPerSample / 8;\n                                qint64 tileBufferCurrOffset = tileBufferOffset;\n                                assert(bufferCurrOffset + ctx-\u003ebitsPerSample / 8 \u003c= buffer.size());\n                                assert(tileBufferCurrOffset + ctx-\u003ebitsPerSample / 8 \u003c= tileBufferSize);\n                                memcpy(buffer.data() + bufferCurrOffset, tileBuffer.data() + tileBufferCurrOffset, static_cast\u003csize_t\u003e(ctx-\u003ebitsPerSample / 8));\n                                tileBufferOffset += ctx-\u003ebitsPerSample / 8;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        for(qint64 y = 0; y \u003c ctx-\u003esubsamplingver; ++y)\n                        {\n                            for(qint64 x = 0; x \u003c ctx-\u003esubsamplinghor; ++x)\n                            {\n                                const qint64 bufferCurrOffset = bufferOffset + y * tileLineSize + x * ctx-\u003ebitsPerSample / 8 * ctx-\u003esamplesPerPixel + c * ctx-\u003ebitsPerSample / 8;\n                                assert(bufferCurrOffset + ctx-\u003ebitsPerSample / 8 \u003c= buffer.size());\n                                assert(tileBufferOffset + ctx-\u003ebitsPerSample / 8 \u003c= tileBufferSize);\n                                memcpy(buffer.data() + bufferCurrOffset, tileBuffer.data() + tileBufferOffset, static_cast\u003csize_t\u003e(ctx-\u003ebitsPerSample / 8));\n                            }\n                        }\n                        tileBufferOffset += ctx-\u003ebitsPerSample / 8;\n                    }\n                }\n                bufferOffset += ctx-\u003ebitsPerSample / 8 * ctx-\u003esamplesPerPixel * ctx-\u003esubsamplinghor;\n                if(bufferLinePos + tileWidth * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample / 8 \u003c= bufferOffset)\n                {\n                    bufferLinePos += tileLineSize * ctx-\u003esubsamplingver;\n                    bufferOffset = bufferLinePos;\n                    tileBufferLinePos += tileScanlineSize * ctx-\u003esubsamplingver;\n                    tileBufferOffset = tileBufferLinePos;\n                }\n                if(bufferLinePos + tileLineSize \u003e tileLineSize * tileHeight)\n                    break;\n            }\n        }\n        else\n        {\n            qint64 bufferLineBitPos = 0;\n            qint64 bufferBitOffset = bufferLineBitPos;\n            qint64 tileBufferLineBitPos = 0;\n            qint64 tileBufferBitOffset = tileBufferLineBitPos;\n\n            while(tileBufferBitOffset \u003c tileBufferSize * 8 \u0026\u0026 bufferBitOffset \u003c buffer.size() * 8)\n            {\n                for(qint64 c = 0; c \u003c ctx-\u003esamplesPerPixel; ++c)\n                {\n                    const bool isChroma = IsOneOf(c, 1, 2);\n                    if(!isChroma)\n                    {\n                        for(qint64 y = 0; y \u003c ctx-\u003esubsamplingver; ++y)\n                        {\n                            for(qint64 x = 0; x \u003c ctx-\u003esubsamplinghor; ++x)\n                            {\n                                const qint64 bufferCurrBitOffset = bufferBitOffset + y * tileLineSize * 8 + x * ctx-\u003ebitsPerSample * ctx-\u003esamplesPerPixel + c * ctx-\u003ebitsPerSample;\n                                qint64 tileBufferCurrBitOffset = tileBufferBitOffset;\n                                assert(bufferCurrBitOffset + ctx-\u003ebitsPerSample \u003c= buffer.size() * 8);\n                                assert(tileBufferCurrBitOffset + ctx-\u003ebitsPerSample \u003c= tileBufferSize * 8);\n                                DataProcessing::memcpyBits(buffer.data(), static_cast\u003cquint64\u003e(bufferCurrBitOffset),\n                                                           tileBuffer.data(), static_cast\u003cquint64\u003e(tileBufferCurrBitOffset),\n                                                           static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                                tileBufferBitOffset += ctx-\u003ebitsPerSample;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        for(qint64 y = 0; y \u003c ctx-\u003esubsamplingver; ++y)\n                        {\n                            for(qint64 x = 0; x \u003c ctx-\u003esubsamplinghor; ++x)\n                            {\n                                const qint64 bufferCurrBitOffset = bufferBitOffset + y * tileLineSize * 8 + x * ctx-\u003ebitsPerSample * ctx-\u003esamplesPerPixel + c * ctx-\u003ebitsPerSample;\n                                assert(bufferCurrBitOffset + ctx-\u003ebitsPerSample \u003c= buffer.size() * 8);\n                                assert(tileBufferBitOffset + ctx-\u003ebitsPerSample \u003c= tileBufferSize * 8);\n                                DataProcessing::memcpyBits(buffer.data(), static_cast\u003cquint64\u003e(bufferCurrBitOffset),\n                                                           tileBuffer.data(), static_cast\u003cquint64\u003e(tileBufferBitOffset),\n                                                           static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                            }\n                        }\n                        tileBufferBitOffset += ctx-\u003ebitsPerSample;\n                    }\n                }\n                bufferBitOffset += ctx-\u003ebitsPerSample * ctx-\u003esamplesPerPixel * ctx-\u003esubsamplinghor;\n                if(bufferLineBitPos + currTileWidth * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample \u003c= bufferBitOffset)\n                {\n                    bufferLineBitPos += tileLineSize * ctx-\u003esubsamplingver * 8;\n                    bufferBitOffset = bufferLineBitPos;\n                    tileBufferLineBitPos += tileScanlineSize * ctx-\u003esubsamplingver * 8;\n                    tileBufferBitOffset = tileBufferLineBitPos;\n                }\n                if(bufferLineBitPos + tileLineSize * 8 \u003e tileLineSize * 8 * tileHeight)\n                    break;\n            }\n        }\n\n        assert(tileLineSize * tileHeight \u003c= buffer.size());\n        const QImage tileRgb = readFromRawBuffer(reinterpret_cast\u003cconst quint8*\u003e(buffer.data()), tileWidth, tileHeight, tileLineSize, ctx);\n        if(tileRgb.isNull())\n            continue;\n\n        assert(IsOneOf(tileRgb.format(), QImage::Format_ARGB32, QImage::Format_RGB32));\n        for(qint64 y = 0; y \u003c currTileHeight; ++y)\n        {\n            const QRgb *inScanLine = reinterpret_cast\u003cconst QRgb*\u003e(tileRgb.scanLine(y));\n            QRgb *outScanLine = reinterpret_cast\u003cQRgb*\u003e(result.scanLine(currTileY * tileHeight + y)) + currTileX * tileWidth;\n            memcpy(outScanLine, inScanLine, static_cast\u003csize_t\u003e(currTileWidth * 4));\n        }\n        somethingReaded = true;\n    }\n\n    if(!somethingReaded)\n        return QImage();\n    return result;\n}\n\nQImage readTiffFileTiledSeparate(const Context *ctx, qint64 nTiles, qint64 tileWidth, qint64 tileHeight)\n{\n    assert(ctx);\n    assert(ctx-\u003etiff);\n    assert(nTiles \u003e 0);\n    assert(tileWidth \u003e 0);\n    assert(tileHeight \u003e 0);\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Tiled data with separate planes of data detected\";\n\n    if(nTiles % ctx-\u003esamplesPerPixel != 0)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid tiles count,\" \u003c\u003c nTiles \u003c\u003c \"should be multiple of\" \u003c\u003c ctx-\u003esamplesPerPixel;\n        return QImage();\n    }\n\n    QImage result(ctx-\u003ewidth, ctx-\u003eheight, ctx-\u003ealphaIndex \u003e= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n    if(result.isNull())\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid image size\";\n        return QImage();\n    }\n    result.fill(ctx-\u003ealphaIndex \u003e= 0 ? Qt::transparent : Qt::white);\n\n    const qint64 bufferAllocSize = tileWidth * tileHeight * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample / 8;\n    if(bufferAllocSize \u003e BUFFER_MAX_SIZE)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't allocate buffer with size =\" \u003c\u003c bufferAllocSize \u003c\u003c \"due to allocation limit =\" \u003c\u003c BUFFER_MAX_SIZE;\n        return QImage();\n    }\n\n    QByteArray buffer;\n    buffer.resize(bufferAllocSize);\n\n    QByteArray tileBuffer;\n    tileBuffer.resize(tileWidth * tileHeight * ctx-\u003ebitsPerSample / 8);\n\n    const qint64 leftX = ctx-\u003ewidth % tileWidth;\n    const qint64 leftY = ctx-\u003eheight % tileHeight;\n    const qint64 nTilesX = (ctx-\u003ewidth / tileWidth)   + (leftX == 0 ? 0 : 1);\n    const qint64 nTilesY = (ctx-\u003eheight / tileHeight) + (leftY == 0 ? 0 : 1);\n    const qint64 tileLineBitSize = tileWidth * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample;\n    const qint64 tileLineSize = tileLineBitSize / 8;\n    const qint64 tilesPerSample = nTiles / ctx-\u003esamplesPerPixel;\n\n    bool somethingReaded = false;\n    for(qint64 tile = 0; tile \u003c tilesPerSample; ++tile)\n    {\n        memset(buffer.data(), BUFFER_FILL_PATTERN, static_cast\u003csize_t\u003e(buffer.size()));\n        const qint64 currTileX = tile % nTilesX;\n        const qint64 currTileY = tile / nTilesX;\n        const qint64 currTileWidth  = ((currTileX == nTilesX - 1) \u0026\u0026 leftX) ? leftX : tileWidth;\n        const qint64 currTileHeight = ((currTileY == nTilesY - 1) \u0026\u0026 leftY) ? leftY : tileHeight;\n\n        for(qint64 sample = 0; sample \u003c ctx-\u003esamplesPerPixel; ++sample)\n        {\n            memset(tileBuffer.data(), BUFFER_FILL_PATTERN, static_cast\u003csize_t\u003e(tileBuffer.size()));\n            const qint64 expectedTileBufferSize = tileHeight * tileWidth * ctx-\u003ebitsPerSample / 8;\n            assert(tileBuffer.size() \u003e= expectedTileBufferSize);\n#if !defined (DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER)\n            qint64 tileBufferSize = TIFFReadEncodedTile(ctx-\u003etiff, static_cast\u003cquint32\u003e(sample * tilesPerSample + tile), tileBuffer.data(), tileBuffer.size());\n#else\n            qint64 tileBufferSize = -1;\n#endif\n#if defined (DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER)\n            tileBufferSize = -1;\n#endif\n            if(tileBufferSize \u003c= 0)\n            {\n                LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFReadEncodedTile failed for tile\" \u003c\u003c tile;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n                /// @todo LibTIFF-4.6.0: Repeated read is not supported for some compression formats (e.g. OJPEG)\n                /// So let's check current buffer, it may be already filled with all available data\n                bool bufferIsEmpty = true;\n                for(qint64 i = 0; i \u003c tileBuffer.size() \u0026\u0026 bufferIsEmpty; ++i)\n                {\n                    if(*reinterpret_cast\u003cquint8*\u003e(tileBuffer.data() + i) != BUFFER_FILL_PATTERN)\n                        bufferIsEmpty = false;\n                }\n                if(bufferIsEmpty)\n                {\n                    for(qint64 row = currTileHeight; row \u003e= 1; --row)\n                    {\n                        const qint64 newSize = TIFFReadEncodedTile(ctx-\u003etiff, static_cast\u003cquint32\u003e(sample * tilesPerSample + tile), tileBuffer.data(), row * expectedTileBufferSize / tileHeight);\n                        if(newSize \u003e 0)\n                        {\n                            LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Recovered rows:\" \u003c\u003c row \u003c\u003c \"of\" \u003c\u003c currTileHeight;\n                            tileBufferSize = std::max(expectedTileBufferSize, newSize);\n                            break;\n                        }\n                    }\n                }\n                else\n                {\n                    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Buffer has some data, assume recovered\";\n                    tileBufferSize = expectedTileBufferSize;\n                }\n#endif\n                if(tileBufferSize \u003c= 0)\n                    continue;\n            }\n            if(tileBufferSize \u003c expectedTileBufferSize)\n            {\n                LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFReadEncodedTile returns not enough data to decode tile\" \u003c\u003c tile \u003c\u003c \"got:\" \u003c\u003c tileBufferSize \u003c\u003c \"expected:\" \u003c\u003c expectedTileBufferSize;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n                tileBufferSize = expectedTileBufferSize;\n#else\n                continue;\n#endif\n            }\n\n#if !defined (DEBUG_FORCE_BIT_ACCESS)\n            if(ctx-\u003ebitsPerSample % 8 == 0)\n#else\n            if(false)\n#endif\n            {\n                for(qint64 y = 0; y \u003c tileHeight; ++y)\n                {\n                    for(qint64 x = 0; x \u003c tileWidth; ++x)\n                    {\n                        const qint64 bufferOffset = ((y * tileWidth + x) * ctx-\u003esamplesPerPixel + sample) * ctx-\u003ebitsPerSample / 8;\n                        const qint64 tileBufferOffset = (y * tileWidth + x) * ctx-\u003ebitsPerSample / 8;\n                        assert(bufferOffset + ctx-\u003ebitsPerSample / 8 \u003c= buffer.size());\n                        assert(tileBufferOffset + ctx-\u003ebitsPerSample / 8 \u003c= tileBufferSize);\n                        memcpy(buffer.data() + bufferOffset, tileBuffer.data() + tileBufferOffset, static_cast\u003csize_t\u003e(ctx-\u003ebitsPerSample / 8));\n                    }\n                }\n            }\n            else\n            {\n                for(qint64 y = 0; y \u003c tileHeight; ++y)\n                {\n                    for(qint64 x = 0; x \u003c tileWidth; ++x)\n                    {\n                        const qint64 bufferBitOffset = ((y * tileWidth + x) * ctx-\u003esamplesPerPixel + sample) * ctx-\u003ebitsPerSample;\n                        const qint64 tileBufferBitOffset = (y * tileWidth + x) * ctx-\u003ebitsPerSample;\n                        assert(bufferBitOffset + ctx-\u003ebitsPerSample \u003c= buffer.size() * 8);\n                        assert(tileBufferBitOffset + ctx-\u003ebitsPerSample \u003c= tileBufferSize * 8);\n                        DataProcessing::memcpyBits(buffer.data(), static_cast\u003cquint64\u003e(bufferBitOffset),\n                                                   tileBuffer.data(), static_cast\u003cquint64\u003e(tileBufferBitOffset),\n                                                   static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                    }\n                }\n            }\n        }\n\n        assert(tileLineSize * tileHeight \u003c= buffer.size());\n        const QImage tileRgb = readFromRawBuffer(reinterpret_cast\u003cconst quint8*\u003e(buffer.data()), tileWidth, tileHeight, tileLineSize, ctx);\n        if(tileRgb.isNull())\n            continue;\n\n        assert(IsOneOf(tileRgb.format(), QImage::Format_ARGB32, QImage::Format_RGB32));\n        for(qint64 y = 0; y \u003c currTileHeight; ++y)\n        {\n            const QRgb *inScanLine = reinterpret_cast\u003cconst QRgb*\u003e(tileRgb.scanLine(y));\n            QRgb *outScanLine = reinterpret_cast\u003cQRgb*\u003e(result.scanLine(currTileY * tileHeight + y)) + currTileX * tileWidth;\n            memcpy(outScanLine, inScanLine, static_cast\u003csize_t\u003e(currTileWidth * 4));\n        }\n        somethingReaded = true;\n    }\n\n    if(!somethingReaded)\n        return QImage();\n    return result;\n}\n\nQImage readTiffFileTiledSeparateSubsampled(const Context *ctx, qint64 nTiles, qint64 tileWidth, qint64 tileHeight)\n{\n    /// @todo No known test samples for this layout\n    assert(ctx);\n    assert(ctx-\u003etiff);\n    assert(nTiles \u003e 0);\n    assert(tileWidth \u003e 0);\n    assert(tileHeight \u003e 0);\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Tiled data with separate planes of subsampled data detected\";\n\n    if(nTiles % ctx-\u003esamplesPerPixel != 0)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid tiles count,\" \u003c\u003c nTiles \u003c\u003c \"should be multiple of\" \u003c\u003c ctx-\u003esamplesPerPixel;\n        return QImage();\n    }\n\n    QImage result(ctx-\u003ewidth, ctx-\u003eheight, ctx-\u003ealphaIndex \u003e= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n    if(result.isNull())\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid image size\";\n        return QImage();\n    }\n    result.fill(ctx-\u003ealphaIndex \u003e= 0 ? Qt::transparent : Qt::white);\n\n    const qint64 bufferAllocSize = (tileWidth + 4) * (tileHeight + 4) * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample / 8;\n    if(bufferAllocSize \u003e BUFFER_MAX_SIZE)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't allocate buffer with size =\" \u003c\u003c bufferAllocSize \u003c\u003c \"due to allocation limit =\" \u003c\u003c BUFFER_MAX_SIZE;\n        return QImage();\n    }\n\n    QByteArray buffer;\n    buffer.resize(bufferAllocSize);\n\n    QByteArray tileBuffer;\n    tileBuffer.resize(tileWidth * tileHeight * ctx-\u003ebitsPerSample / 8);\n\n    const qint64 leftX = ctx-\u003ewidth % tileWidth;\n    const qint64 leftY = ctx-\u003eheight % tileHeight;\n    const qint64 nTilesX = (ctx-\u003ewidth / tileWidth)   + (leftX == 0 ? 0 : 1);\n    const qint64 nTilesY = (ctx-\u003eheight / tileHeight) + (leftY == 0 ? 0 : 1);\n    const qint64 tileLineBitSize = tileWidth * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample;\n    const qint64 tileLineSize = tileLineBitSize / 8;\n    const qint64 tilesPerSample = nTiles / ctx-\u003esamplesPerPixel;\n\n    bool somethingReaded = false;\n    for(qint64 tile = 0; tile \u003c tilesPerSample; ++tile)\n    {\n        memset(buffer.data(), BUFFER_FILL_PATTERN, static_cast\u003csize_t\u003e(buffer.size()));\n        const qint64 currTileX = tile % nTilesX;\n        const qint64 currTileY = tile / nTilesX;\n        const qint64 currTileWidth  = ((currTileX == nTilesX - 1) \u0026\u0026 leftX) ? leftX : tileWidth;\n        const qint64 currTileHeight = ((currTileY == nTilesY - 1) \u0026\u0026 leftY) ? leftY : tileHeight;\n\n        for(qint64 sample = 0; sample \u003c ctx-\u003esamplesPerPixel; ++sample)\n        {\n            memset(tileBuffer.data(), BUFFER_FILL_PATTERN, static_cast\u003csize_t\u003e(tileBuffer.size()));\n            const bool isSubsampledChroma = IsOneOf(sample, 1, 2);\n            const qint64 expectedTileBufferSize = tileHeight * tileWidth * ctx-\u003ebitsPerSample / 8 / (isSubsampledChroma ? (ctx-\u003esubsamplingver * ctx-\u003esubsamplinghor) : 1);\n#if !defined (DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER)\n            qint64 tileBufferSize = TIFFReadEncodedTile(ctx-\u003etiff, static_cast\u003cquint32\u003e(sample * tilesPerSample + tile), tileBuffer.data(), tileBuffer.size());\n#else\n            qint64 tileBufferSize = -1;\n#endif\n#if defined (DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER)\n            tileBufferSize = -1;\n#endif\n            if(tileBufferSize \u003c= 0)\n            {\n                LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFReadEncodedTile failed for tile\" \u003c\u003c tile;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n                /// @todo LibTIFF-4.6.0: Repeated read is not supported for some compression formats (e.g. OJPEG)\n                /// So let's check current buffer, it may be already filled with all available data\n                bool bufferIsEmpty = true;\n                for(qint64 i = 0; i \u003c tileBuffer.size() \u0026\u0026 bufferIsEmpty; ++i)\n                {\n                    if(*reinterpret_cast\u003cquint8*\u003e(tileBuffer.data() + i) != BUFFER_FILL_PATTERN)\n                        bufferIsEmpty = false;\n                }\n                if(bufferIsEmpty)\n                {\n                    const qint64 currTileHeightSubsampled = currTileHeight / (isSubsampledChroma ? ctx-\u003esubsamplingver : 1);\n                    for(qint64 row = currTileHeightSubsampled; row \u003e= 1; --row)\n                    {\n                        const qint64 newSize =  TIFFReadEncodedTile(ctx-\u003etiff, static_cast\u003cquint32\u003e(sample * tilesPerSample + tile), tileBuffer.data(), expectedTileBufferSize * row / currTileHeightSubsampled);\n                        if(newSize \u003e 0)\n                        {\n                            LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Recovered rows:\" \u003c\u003c row \u003c\u003c \"of\" \u003c\u003c currTileHeightSubsampled;\n                            tileBufferSize = std::max(expectedTileBufferSize, newSize);\n                            break;\n                        }\n                    }\n                }\n                else\n                {\n                    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Buffer has some data, assume recovered\";\n                    tileBufferSize = expectedTileBufferSize;\n                }\n#endif\n                if(tileBufferSize \u003c= 0)\n                    continue;\n            }\n\n            if(tileBufferSize \u003c expectedTileBufferSize)\n            {\n                LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFReadEncodedTile returns not enough data to decode tile\" \u003c\u003c tile \u003c\u003c \"got:\" \u003c\u003c tileBufferSize \u003c\u003c \"expected:\" \u003c\u003c expectedTileBufferSize;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n                tileBufferSize = expectedTileBufferSize;\n#else\n                continue;\n#endif\n            }\n\n            if(isSubsampledChroma)\n            {\n#if !defined (DEBUG_FORCE_BIT_ACCESS)\n                if(ctx-\u003ebitsPerSample % 8 == 0)\n#else\n                if(false)\n#endif\n                {\n                    for(qint64 y = 0; y \u003c tileHeight / ctx-\u003esubsamplingver; ++y)\n                    {\n                        for(qint64 x = 0; x \u003c tileWidth / ctx-\u003esubsamplinghor; ++x)\n                        {\n                            const qint64 tileBufferOffset = (y * tileWidth / ctx-\u003esubsamplinghor + x) * ctx-\u003ebitsPerSample / 8;\n                            assert(tileBufferOffset + ctx-\u003ebitsPerSample / 8 \u003c= tileBufferSize);\n                            for(qint64 yu = y * ctx-\u003esubsamplingver; yu \u003c (y + 1) * ctx-\u003esubsamplingver; ++yu)\n                            {\n                                for(qint64 xu = x * ctx-\u003esubsamplinghor; xu \u003c (x + 1) * ctx-\u003esubsamplinghor; ++xu)\n                                {\n                                    const qint64 bufferOffset = ((yu * tileWidth + xu) * ctx-\u003esamplesPerPixel + sample) * ctx-\u003ebitsPerSample / 8;\n                                    assert(bufferOffset + ctx-\u003ebitsPerSample / 8 \u003c= buffer.size());\n                                    memcpy(buffer.data() + bufferOffset, tileBuffer.data() + tileBufferOffset, static_cast\u003csize_t\u003e(ctx-\u003ebitsPerSample / 8));\n                                }\n                            }\n                        }\n                    }\n                }\n                else\n                {\n                    for(qint64 y = 0; y \u003c tileHeight / ctx-\u003esubsamplingver; ++y)\n                    {\n                        for(qint64 x = 0; x \u003c tileWidth / ctx-\u003esubsamplinghor; ++x)\n                        {\n                            const qint64 tileBufferBitOffset = (y * tileWidth / ctx-\u003esubsamplinghor + x) * ctx-\u003ebitsPerSample;\n                            assert(tileBufferBitOffset + ctx-\u003ebitsPerSample \u003c= tileBufferSize * 8);\n                            for(qint64 yu = y * ctx-\u003esubsamplingver; yu \u003c (y + 1) * ctx-\u003esubsamplingver; ++yu)\n                            {\n                                for(qint64 xu = x * ctx-\u003esubsamplinghor; xu \u003c (x + 1) * ctx-\u003esubsamplinghor; ++xu)\n                                {\n                                    const qint64 bufferBitOffset = ((yu * tileWidth + xu) * ctx-\u003esamplesPerPixel + sample) * ctx-\u003ebitsPerSample;\n                                    assert(bufferBitOffset + ctx-\u003ebitsPerSample \u003c= buffer.size() * 8);\n                                    DataProcessing::memcpyBits(buffer.data(), static_cast\u003cquint64\u003e(bufferBitOffset),\n                                                               tileBuffer.data(), static_cast\u003cquint64\u003e(tileBufferBitOffset),\n                                                               static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            else\n            {\n#if !defined (DEBUG_FORCE_BIT_ACCESS)\n                if(ctx-\u003ebitsPerSample % 8 == 0)\n#else\n                if(false)\n#endif\n                {\n                    for(qint64 y = 0; y \u003c tileHeight; ++y)\n                    {\n                        for(qint64 x = 0; x \u003c tileWidth; ++x)\n                        {\n                            const qint64 bufferOffset = ((y * tileWidth + x) * ctx-\u003esamplesPerPixel + sample) * ctx-\u003ebitsPerSample / 8;\n                            const qint64 tileBufferOffset = (y * tileWidth + x) * ctx-\u003ebitsPerSample / 8;\n                            assert(bufferOffset + ctx-\u003ebitsPerSample / 8 \u003c= buffer.size());\n                            assert(tileBufferOffset + ctx-\u003ebitsPerSample / 8 \u003c= tileBufferSize);\n                            memcpy(buffer.data() + bufferOffset, tileBuffer.data() + tileBufferOffset, static_cast\u003csize_t\u003e(ctx-\u003ebitsPerSample / 8));\n                        }\n                    }\n                }\n                else\n                {\n                    for(qint64 y = 0; y \u003c tileHeight; ++y)\n                    {\n                        for(qint64 x = 0; x \u003c tileWidth; ++x)\n                        {\n                            const qint64 bufferBitOffset = ((y * tileWidth + x) * ctx-\u003esamplesPerPixel + sample) * ctx-\u003ebitsPerSample;\n                            const qint64 tileBufferBitOffset = (y * tileWidth + x) * ctx-\u003ebitsPerSample;\n                            assert(bufferBitOffset + ctx-\u003ebitsPerSample \u003c= buffer.size() * 8);\n                            assert(tileBufferBitOffset + ctx-\u003ebitsPerSample \u003c= tileBufferSize * 8);\n                            DataProcessing::memcpyBits(buffer.data(), static_cast\u003cquint64\u003e(bufferBitOffset),\n                                                       tileBuffer.data(), static_cast\u003cquint64\u003e(tileBufferBitOffset),\n                                                       static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                        }\n                    }\n                }\n            }\n        }\n\n        assert(tileLineSize * tileHeight \u003c= buffer.size());\n        const QImage tileRgb = readFromRawBuffer(reinterpret_cast\u003cconst quint8*\u003e(buffer.data()), tileWidth, tileHeight, tileLineSize, ctx);\n        if(tileRgb.isNull())\n            continue;\n\n        assert(IsOneOf(tileRgb.format(), QImage::Format_ARGB32, QImage::Format_RGB32));\n        for(qint64 y = 0; y \u003c currTileHeight; ++y)\n        {\n            const QRgb *inScanLine = reinterpret_cast\u003cconst QRgb*\u003e(tileRgb.scanLine(y));\n            QRgb *outScanLine = reinterpret_cast\u003cQRgb*\u003e(result.scanLine(currTileY * tileHeight + y)) + currTileX * tileWidth;\n            memcpy(outScanLine, inScanLine, static_cast\u003csize_t\u003e(currTileWidth * 4));\n        }\n        somethingReaded = true;\n    }\n\n    if(!somethingReaded)\n        return QImage();\n    return result;\n}\n\nQImage readTiffFileTiled(const Context *ctx)\n{\n    assert(ctx);\n    assert(ctx-\u003etiff);\n\n    quint16 planarConfig = 0;\n    if(!TIFFGetFieldDefaulted(ctx-\u003etiff, TIFFTAG_PLANARCONFIG, \u0026planarConfig) || !IsOneOf(planarConfig, PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE))\n        planarConfig = PLANARCONFIG_CONTIG;\n\n    const qint64 nTiles = static_cast\u003cqint64\u003e(TIFFNumberOfTiles(ctx-\u003etiff));\n    if(nTiles \u003c= 0)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid TIFFNumberOfTiles =\" \u003c\u003c nTiles;\n        return QImage();\n    }\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFNumberOfTiles =\" \u003c\u003c nTiles;\n\n    quint32 tileWidth = 0;\n    if(!TIFFGetFieldDefaulted(ctx-\u003etiff, TIFFTAG_TILEWIDTH, \u0026tileWidth) || tileWidth == 0)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't get TIFFTAG_TILEWIDTH\";\n        return QImage();\n    }\n    const qint64 tileWidth64 = static_cast\u003cqint64\u003e(tileWidth);\n\n    quint32 tileHeight = 0;\n    if(!TIFFGetFieldDefaulted(ctx-\u003etiff, TIFFTAG_TILELENGTH, \u0026tileHeight) || tileHeight == 0)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't get TIFFTAG_TILELENGTH\";\n        return QImage();\n    }\n    const qint64 tileHeight64 = static_cast\u003cqint64\u003e(tileHeight);\n\n    const bool isValidSubsamplingH = IsOneOf(ctx-\u003esubsamplinghor, 1, 2, 4);\n    const bool isValidSubsamplingV = IsOneOf(ctx-\u003esubsamplingver, 1, 2, 4);\n    const bool isValidSubsampledYCbCr = ctx-\u003ephotometric == PHOTOMETRIC_YCBCR \u0026\u0026 ctx-\u003eprimarysamplesCount == 3 \u0026\u0026 isValidSubsamplingH \u0026\u0026 isValidSubsamplingV \u0026\u0026 (ctx-\u003esubsamplinghor \u003e 1 || ctx-\u003esubsamplingver \u003e 1);\n\n    if(planarConfig == PLANARCONFIG_CONTIG)\n    {\n        if(isValidSubsampledYCbCr)\n            return readTiffFileTiledContigSubsampled(ctx, nTiles, tileWidth64, tileHeight64);\n        else\n            return readTiffFileTiledContig(ctx, nTiles, tileWidth64, tileHeight64);\n    }\n    else if(planarConfig == PLANARCONFIG_SEPARATE)\n    {\n        if(isValidSubsampledYCbCr)\n            return readTiffFileTiledSeparateSubsampled(ctx, nTiles, tileWidth64, tileHeight64);\n        else\n            return readTiffFileTiledSeparate(ctx, nTiles, tileWidth64, tileHeight64);\n    }\n\n    assert(false);\n    return QImage();\n}\n\n// ====================================================================================================\n\nQImage readTiffFileStripedContig(const Context *ctx, qint64 numberOfStrips, qint64 stripSize, qint64 rowsperstrip, qint64 scanlineSize, qint64 rasterScanlineSize)\n{\n    assert(ctx);\n    assert(ctx-\u003etiff);\n    assert(numberOfStrips \u003e 0);\n    assert(stripSize \u003e 0);\n    assert(rowsperstrip \u003e 0);\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Striped data with single image plane of data detected\";\n\n    if(scanlineSize != rasterScanlineSize)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid scanline sizes: scanlineSize =\" \u003c\u003c scanlineSize \u003c\u003c \"rasterScanlineSize =\" \u003c\u003c rasterScanlineSize;\n        return QImage();\n    }\n\n    if(scanlineSize \u003c ctx-\u003ewidth * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample / 8)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid scanline size,\" \u003c\u003c scanlineSize \u003c\u003c \"should be great or equal\" \u003c\u003c ctx-\u003ewidth * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample / 8;\n        return QImage();\n    }\n\n    QImage result(ctx-\u003ewidth, ctx-\u003eheight, ctx-\u003ealphaIndex \u003e= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n    if(result.isNull())\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid image size\";\n        return QImage();\n    }\n    result.fill(ctx-\u003ealphaIndex \u003e= 0 ? Qt::transparent : Qt::white);\n\n    const qint64 bufferAllocSize = stripSize;\n    if(bufferAllocSize \u003e BUFFER_MAX_SIZE)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't allocate buffer with size =\" \u003c\u003c bufferAllocSize \u003c\u003c \"due to allocation limit =\" \u003c\u003c BUFFER_MAX_SIZE;\n        return QImage();\n    }\n\n    QByteArray buffer;\n    buffer.resize(bufferAllocSize);\n\n    const qint64 leftRows = ctx-\u003eheight % rowsperstrip;\n\n    bool somethingReaded = false;\n    for(qint64 strip = 0; strip \u003c numberOfStrips; ++strip)\n    {\n        memset(buffer.data(), BUFFER_FILL_PATTERN, static_cast\u003csize_t\u003e(buffer.size()));\n        const qint64 currStripHeight = ((strip == numberOfStrips - 1) \u0026\u0026 leftRows) ? leftRows : rowsperstrip;\n        const qint64 expectedStripBufferSize = currStripHeight * rasterScanlineSize;\n        assert(bufferAllocSize \u003e= expectedStripBufferSize);\n#if !defined (DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER)\n        qint64 stripBufferSize = TIFFReadEncodedStrip(ctx-\u003etiff, static_cast\u003cquint32\u003e(strip), buffer.data(), buffer.size());\n#else\n        qint64 stripBufferSize = -1;\n#endif\n#if defined (DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER)\n        stripBufferSize = -1;\n#endif\n        if(stripBufferSize \u003c= 0)\n        {\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFReadEncodedStrip failed for strip\" \u003c\u003c strip;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n            /// @todo LibTIFF-4.6.0: Repeated read is not supported for some compression formats (e.g. OJPEG)\n            /// So let's check current buffer, it may be already filled with all available data\n            bool bufferIsEmpty = true;\n            for(qint64 i = 0; i \u003c buffer.size() \u0026\u0026 bufferIsEmpty; ++i)\n            {\n                if(*reinterpret_cast\u003cquint8*\u003e(buffer.data() + i) != BUFFER_FILL_PATTERN)\n                    bufferIsEmpty = false;\n            }\n            if(bufferIsEmpty)\n            {\n                for(qint64 row = currStripHeight; row \u003e= 1; --row)\n                {\n                    const qint64 newSize = TIFFReadEncodedStrip(ctx-\u003etiff, static_cast\u003cquint32\u003e(strip), buffer.data(), row * scanlineSize);\n                    if(newSize \u003e 0)\n                    {\n                        LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Recovered rows:\" \u003c\u003c row \u003c\u003c \"of\" \u003c\u003c currStripHeight;\n                        stripBufferSize = std::max(expectedStripBufferSize, newSize);\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Buffer has some data, assume recovered\";\n                stripBufferSize = expectedStripBufferSize;\n            }\n#endif\n            if(stripBufferSize \u003c= 0)\n                continue;\n        }\n        if(stripBufferSize \u003c expectedStripBufferSize)\n        {\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFReadEncodedStrip returns not enough data to decode strip\" \u003c\u003c strip \u003c\u003c \"got:\" \u003c\u003c stripBufferSize \u003c\u003c \"expected:\" \u003c\u003c expectedStripBufferSize;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n            stripBufferSize = expectedStripBufferSize;\n#else\n            continue;\n#endif\n        }\n\n        assert(currStripHeight * rasterScanlineSize \u003c= stripBufferSize);\n        const QImage stripRgb = readFromRawBuffer(reinterpret_cast\u003cconst quint8*\u003e(buffer.data()), ctx-\u003ewidth, currStripHeight, rasterScanlineSize, ctx);\n        if(stripRgb.isNull())\n            continue;\n\n        assert(IsOneOf(stripRgb.format(), QImage::Format_ARGB32, QImage::Format_RGB32));\n        for(qint64 y = 0; y \u003c currStripHeight \u0026\u0026 strip * rowsperstrip + y \u003c ctx-\u003eheight; ++y)\n        {\n            const QRgb *inScanLine = reinterpret_cast\u003cconst QRgb*\u003e(stripRgb.scanLine(y));\n            QRgb *outScanLine = reinterpret_cast\u003cQRgb*\u003e(result.scanLine(strip * rowsperstrip + y));\n            memcpy(outScanLine, inScanLine, static_cast\u003csize_t\u003e(ctx-\u003ewidth * 4));\n        }\n\n        somethingReaded = true;\n    }\n\n    if(!somethingReaded)\n        return QImage();\n    return result;\n}\n\nQImage readTiffFileStripedContigSubsampled(const Context *ctx, qint64 numberOfStrips, qint64 stripSize, qint64 rowsperstrip, qint64 scanlineSize, qint64 rasterScanlineSize)\n{\n    assert(ctx);\n    assert(ctx-\u003etiff);\n    assert(numberOfStrips \u003e 0);\n    assert(stripSize \u003e 0);\n    assert(rowsperstrip \u003e 0);\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Striped data with single image plane of subsampled data detected\";\n\n    QImage result(ctx-\u003ewidth, ctx-\u003eheight, ctx-\u003ealphaIndex \u003e= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n    if(result.isNull())\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid image size\";\n        return QImage();\n    }\n    result.fill(ctx-\u003ealphaIndex \u003e= 0 ? Qt::transparent : Qt::white);\n\n    const qint64 bufferAllocSize = rasterScanlineSize * (ctx-\u003eheight + 4);\n    if(bufferAllocSize \u003e BUFFER_MAX_SIZE)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't allocate buffer with size =\" \u003c\u003c bufferAllocSize \u003c\u003c \"due to allocation limit =\" \u003c\u003c BUFFER_MAX_SIZE;\n        return QImage();\n    }\n\n    QByteArray buffer;\n    buffer.resize(bufferAllocSize);\n\n    QByteArray stripBuffer;\n    stripBuffer.resize(stripSize);\n\n    const qint64 leftRows = ctx-\u003eheight % rowsperstrip;\n    const qint64 minLineBitSize = ctx-\u003ewidth * ctx-\u003esamplesPerPixel * ctx-\u003ebitsPerSample;\n    const qint64 minLineSize = minLineBitSize / 8;\n\n    bool somethingReaded = false;\n    for(qint64 strip = 0; strip \u003c numberOfStrips; ++strip)\n    {\n        memset(buffer.data(), BUFFER_FILL_PATTERN, static_cast\u003csize_t\u003e(buffer.size()));\n        memset(stripBuffer.data(), BUFFER_FILL_PATTERN, static_cast\u003csize_t\u003e(stripBuffer.size()));\n        const qint64 currStripHeight = ((strip == numberOfStrips - 1) \u0026\u0026 leftRows) ? leftRows : rowsperstrip;\n        const qint64 currStripHeightAligned = currStripHeight + (currStripHeight % ctx-\u003esubsamplingver \u003e 0 ? (ctx-\u003esubsamplingver - currStripHeight % ctx-\u003esubsamplingver) : 0);\n        const qint64 expectedStripBufferSize = currStripHeight * ctx-\u003ewidth * (ctx-\u003esamplesPerPixel - 2) * ctx-\u003ebitsPerSample / 8 + currStripHeight / ctx-\u003esubsamplingver * ctx-\u003ewidth / ctx-\u003esubsamplinghor * 2 * ctx-\u003ebitsPerSample / 8;\n        const qint64 expectedStripBufferSizeAligned = expectedStripBufferSize * currStripHeightAligned / currStripHeight;\n        assert(stripSize \u003e= expectedStripBufferSizeAligned);\n#if !defined (DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER)\n        qint64 stripBufferSize = TIFFReadEncodedStrip(ctx-\u003etiff, static_cast\u003cquint32\u003e(strip), stripBuffer.data(), stripBuffer.size());\n#else\n        qint64 stripBufferSize = -1;\n#endif\n#if defined (DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER)\n        stripBufferSize = -1;\n#endif\n        if(stripBufferSize \u003c= 0)\n        {\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFReadEncodedStrip failed for strip\" \u003c\u003c strip;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n            /// @todo LibTIFF-4.6.0: Repeated read is not supported for some compression formats (e.g. OJPEG)\n            /// So let's check current buffer, it may be already filled with all available data\n            bool bufferIsEmpty = true;\n            for(qint64 i = 0; i \u003c stripBuffer.size() \u0026\u0026 bufferIsEmpty; ++i)\n            {\n                if(*reinterpret_cast\u003cquint8*\u003e(stripBuffer.data() + i) != BUFFER_FILL_PATTERN)\n                    bufferIsEmpty = false;\n            }\n            if(bufferIsEmpty)\n            {\n                for(qint64 row = currStripHeightAligned; row \u003e= ctx-\u003esubsamplingver; row -= ctx-\u003esubsamplingver)\n                {\n                    const qint64 newSize = TIFFReadEncodedStrip(ctx-\u003etiff, static_cast\u003cquint32\u003e(strip), stripBuffer.data(), row * scanlineSize);\n                    if(newSize \u003e 0)\n                    {\n                        LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Recovered rows:\" \u003c\u003c row \u003c\u003c \"of\" \u003c\u003c currStripHeightAligned;\n                        stripBufferSize = std::max(expectedStripBufferSizeAligned, newSize);\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Buffer has some data, assume recovered\";\n                stripBufferSize = expectedStripBufferSize;\n            }\n#endif\n            if(stripBufferSize \u003c= 0)\n                continue;\n        }\n        if(stripBufferSize \u003c expectedStripBufferSize)\n        {\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFReadEncodedStrip returns not enough data to decode strip\" \u003c\u003c strip \u003c\u003c \"got:\" \u003c\u003c stripBufferSize \u003c\u003c \"expected:\" \u003c\u003c expectedStripBufferSize;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n            stripBufferSize = expectedStripBufferSizeAligned;\n#else\n            Q_UNUSED(expectedStripBufferSizeAligned);\n            continue;\n#endif\n        }\n\n#if !defined (DEBUG_FORCE_BIT_ACCESS)\n        if(ctx-\u003ebitsPerSample % 8 == 0)\n#else\n        if(false)\n#endif\n        {\n            qint64 bufferLinePos = 0;\n            qint64 bufferOffset = bufferLinePos;\n            qint64 stripBufferLinePos = 0;\n            qint64 stripBufferOffset = stripBufferLinePos;\n\n            while(stripBufferOffset \u003c stripBufferSize \u0026\u0026 bufferOffset \u003c buffer.size())\n            {\n                for(qint64 c = 0; c \u003c ctx-\u003esamplesPerPixel; ++c)\n                {\n                    const bool isChroma = IsOneOf(c, 1, 2);\n                    if(!isChroma)\n                    {\n                        for(qint64 y = 0; y \u003c ctx-\u003esubsamplingver; ++y)\n                        {\n                            for(qint64 x = 0; x \u003c ctx-\u003esubsamplinghor; ++x)\n                            {\n                                const qint64 bufferCurrOffset = bufferOffset + y * rasterScanlineSize + x * ctx-\u003ebitsPerSample / 8 * ctx-\u003esamplesPerPixel + c * ctx-\u003ebitsPerSample / 8;\n                                qint64 stripBufferCurrOffset = stripBufferOffset;\n                                assert(bufferCurrOffset + ctx-\u003ebitsPerSample / 8 \u003c= buffer.size());\n                                assert(stripBufferCurrOffset + ctx-\u003ebitsPerSample / 8 \u003c= stripBufferSize);\n                                memcpy(buffer.data() + bufferCurrOffset, stripBuffer.data() + stripBufferCurrOffset, static_cast\u003csize_t\u003e(ctx-\u003ebitsPerSample / 8));\n                                stripBufferOffset += ctx-\u003ebitsPerSample / 8;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        for(qint64 y = 0; y \u003c ctx-\u003esubsamplingver; ++y)\n                        {\n                            for(qint64 x = 0; x \u003c ctx-\u003esubsamplinghor; ++x)\n                            {\n                                const qint64 bufferCurrOffset = bufferOffset + y * rasterScanlineSize + x * ctx-\u003ebitsPerSample / 8 * ctx-\u003esamplesPerPixel + c * ctx-\u003ebitsPerSample / 8;\n                                assert(bufferCurrOffset + ctx-\u003ebitsPerSample / 8 \u003c= buffer.size());\n                                assert(stripBufferOffset + ctx-\u003ebitsPerSample / 8 \u003c= stripBufferSize);\n                                memcpy(buffer.data() + bufferCurrOffset, stripBuffer.data() + stripBufferOffset, static_cast\u003csize_t\u003e(ctx-\u003ebitsPerSample / 8));\n                            }\n                        }\n                        stripBufferOffset += ctx-\u003ebitsPerSample / 8;\n                    }\n                }\n                bufferOffset += ctx-\u003ebitsPerSample / 8 * ctx-\u003esamplesPerPixel * ctx-\u003esubsamplinghor;\n                if(bufferLinePos + minLineSize \u003c= bufferOffset)\n                {\n                    bufferLinePos += rasterScanlineSize * ctx-\u003esubsamplingver;\n                    bufferOffset = bufferLinePos;\n                    stripBufferLinePos += scanlineSize * ctx-\u003esubsamplingver;\n                    stripBufferOffset = stripBufferLinePos;\n                }\n                if(bufferLinePos + rasterScanlineSize \u003e rasterScanlineSize * ctx-\u003eheight)\n                    break;\n            }\n        }\n        else\n        {\n            qint64 bufferLineBitPos = 0;\n            qint64 bufferBitOffset = bufferLineBitPos;\n            qint64 stripBufferLineBitPos = 0;\n            qint64 stripBufferBitOffset = stripBufferLineBitPos;\n\n            while(stripBufferBitOffset \u003c stripBufferSize * 8 \u0026\u0026 bufferBitOffset \u003c buffer.size() * 8)\n            {\n                for(qint64 c = 0; c \u003c ctx-\u003esamplesPerPixel; ++c)\n                {\n                    const bool isChroma = IsOneOf(c, 1, 2);\n                    if(!isChroma)\n                    {\n                        for(qint64 y = 0; y \u003c ctx-\u003esubsamplingver; ++y)\n                        {\n                            for(qint64 x = 0; x \u003c ctx-\u003esubsamplinghor; ++x)\n                            {\n                                const qint64 bufferCurrBitOffset = bufferBitOffset + y * rasterScanlineSize * 8 + x * ctx-\u003ebitsPerSample * ctx-\u003esamplesPerPixel + c * ctx-\u003ebitsPerSample;\n                                qint64 stripBufferCurrBitOffset = stripBufferBitOffset;\n                                assert(bufferCurrBitOffset + ctx-\u003ebitsPerSample \u003c= buffer.size() * 8);\n                                assert(stripBufferCurrBitOffset + ctx-\u003ebitsPerSample \u003c= stripBufferSize * 8);\n                                DataProcessing::memcpyBits(buffer.data(), static_cast\u003cquint64\u003e(bufferCurrBitOffset),\n                                                           stripBuffer.data(), static_cast\u003cquint64\u003e(stripBufferCurrBitOffset),\n                                                           static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                                stripBufferBitOffset += ctx-\u003ebitsPerSample;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        for(qint64 y = 0; y \u003c ctx-\u003esubsamplingver; ++y)\n                        {\n                            for(qint64 x = 0; x \u003c ctx-\u003esubsamplinghor; ++x)\n                            {\n                                const qint64 bufferCurrBitOffset = bufferBitOffset + y * rasterScanlineSize * 8 + x * ctx-\u003ebitsPerSample * ctx-\u003esamplesPerPixel + c * ctx-\u003ebitsPerSample;\n                                assert(bufferCurrBitOffset + ctx-\u003ebitsPerSample \u003c= buffer.size() * 8);\n                                assert(stripBufferBitOffset + ctx-\u003ebitsPerSample \u003c= stripBufferSize * 8);\n                                DataProcessing::memcpyBits(buffer.data(), static_cast\u003cquint64\u003e(bufferCurrBitOffset),\n                                                           stripBuffer.data(), static_cast\u003cquint64\u003e(stripBufferBitOffset),\n                                                           static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                            }\n                        }\n                        stripBufferBitOffset += ctx-\u003ebitsPerSample;\n                    }\n                }\n                bufferBitOffset += ctx-\u003ebitsPerSample * ctx-\u003esamplesPerPixel * ctx-\u003esubsamplinghor;\n                if(bufferLineBitPos + minLineBitSize \u003c= bufferBitOffset)\n                {\n                    bufferLineBitPos += rasterScanlineSize * 8 * ctx-\u003esubsamplingver;\n                    bufferBitOffset = bufferLineBitPos;\n                    stripBufferLineBitPos += scanlineSize * 8 * ctx-\u003esubsamplingver;\n                    stripBufferBitOffset = stripBufferLineBitPos;\n                }\n                if(bufferLineBitPos + rasterScanlineSize * 8 \u003e rasterScanlineSize * 8 * ctx-\u003eheight)\n                    break;\n            }\n        }\n\n        assert(currStripHeight * rasterScanlineSize \u003c= buffer.size());\n        const QImage stripRgb = readFromRawBuffer(reinterpret_cast\u003cconst quint8*\u003e(buffer.data()), ctx-\u003ewidth, currStripHeight, rasterScanlineSize, ctx);\n        if(stripRgb.isNull())\n            continue;\n\n        assert(IsOneOf(stripRgb.format(), QImage::Format_ARGB32, QImage::Format_RGB32));\n        for(qint64 y = 0; y \u003c currStripHeight \u0026\u0026 strip * rowsperstrip + y \u003c ctx-\u003eheight; ++y)\n        {\n            const QRgb *inScanLine = reinterpret_cast\u003cconst QRgb*\u003e(stripRgb.scanLine(y));\n            QRgb *outScanLine = reinterpret_cast\u003cQRgb*\u003e(result.scanLine(strip * rowsperstrip + y));\n            memcpy(outScanLine, inScanLine, static_cast\u003csize_t\u003e(ctx-\u003ewidth * 4));\n        }\n\n        somethingReaded = true;\n    }\n\n    if(!somethingReaded)\n        return QImage();\n    return result;\n}\n\nQImage readTiffFileStripedSeparate(const Context *ctx, qint64 numberOfStrips, qint64 stripSize, qint64 rowsperstrip, qint64 scanlineSize, qint64 rasterScanlineSize)\n{\n    assert(ctx);\n    assert(ctx-\u003etiff);\n    assert(numberOfStrips \u003e 0);\n    assert(stripSize \u003e 0);\n    assert(rowsperstrip \u003e 0);\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Striped data with separate planes of data detected\";\n\n    if(numberOfStrips % ctx-\u003esamplesPerPixel != 0)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid strips count,\" \u003c\u003c numberOfStrips \u003c\u003c \"should be multiple of\" \u003c\u003c ctx-\u003esamplesPerPixel;\n        return QImage();\n    }\n\n    if(scanlineSize \u003c ctx-\u003ewidth * ctx-\u003ebitsPerSample / 8)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid scanline size,\" \u003c\u003c scanlineSize \u003c\u003c \"should be great or equal\" \u003c\u003c ctx-\u003ewidth * ctx-\u003ebitsPerSample / 8;\n        return QImage();\n    }\n\n    QImage result(ctx-\u003ewidth, ctx-\u003eheight, ctx-\u003ealphaIndex \u003e= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n    if(result.isNull())\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid image size\";\n        return QImage();\n    }\n    result.fill(ctx-\u003ealphaIndex \u003e= 0 ? Qt::transparent : Qt::white);\n\n    const qint64 bufferAllocSize = rasterScanlineSize * (ctx-\u003eheight + 4);\n    if(bufferAllocSize \u003e BUFFER_MAX_SIZE)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't allocate buffer with size =\" \u003c\u003c bufferAllocSize \u003c\u003c \"due to allocation limit =\" \u003c\u003c BUFFER_MAX_SIZE;\n        return QImage();\n    }\n\n    QByteArray buffer;\n    buffer.resize(bufferAllocSize);\n\n    QByteArray stripBuffer;\n    stripBuffer.resize(stripSize);\n\n    const qint64 leftRows = ctx-\u003eheight % rowsperstrip;\n    const qint64 stripsPerSample = numberOfStrips / ctx-\u003esamplesPerPixel;\n\n    bool somethingReaded = false;\n    for(qint64 strip = 0; strip \u003c stripsPerSample; ++strip)\n    {\n        memset(buffer.data(), BUFFER_FILL_PATTERN, static_cast\u003csize_t\u003e(buffer.size()));\n        const qint64 currStripHeight = ((strip == stripsPerSample - 1) \u0026\u0026 leftRows) ? leftRows : rowsperstrip;\n\n        for(qint64 sample = 0; sample \u003c ctx-\u003esamplesPerPixel; ++sample)\n        {\n            memset(stripBuffer.data(), BUFFER_FILL_PATTERN, static_cast\u003csize_t\u003e(stripBuffer.size()));\n            const qint64 expectedStripBufferSize = currStripHeight * ctx-\u003ewidth * ctx-\u003ebitsPerSample / 8;\n            assert(stripSize \u003e= expectedStripBufferSize);\n#if !defined (DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER)\n            qint64 stripBufferSize = TIFFReadEncodedStrip(ctx-\u003etiff, static_cast\u003cquint32\u003e(sample * stripsPerSample + strip), stripBuffer.data(), stripBuffer.size());\n#else\n            qint64 stripBufferSize = -1;\n#endif\n#if defined (DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER)\n            stripBufferSize = -1;\n#endif\n            if(stripBufferSize \u003c= 0)\n            {\n                LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFReadEncodedStrip failed for strip\" \u003c\u003c strip;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n                /// @todo LibTIFF-4.6.0: Repeated read is not supported for some compression formats (e.g. OJPEG)\n                /// So let's check current buffer, it may be already filled with all available data\n                bool bufferIsEmpty = true;\n                for(qint64 i = 0; i \u003c stripBuffer.size() \u0026\u0026 bufferIsEmpty; ++i)\n                {\n                    if(*reinterpret_cast\u003cquint8*\u003e(stripBuffer.data() + i) != BUFFER_FILL_PATTERN)\n                        bufferIsEmpty = false;\n                }\n                if(bufferIsEmpty)\n                {\n                    for(qint64 row = currStripHeight; row \u003e= 1; --row)\n                    {\n                        const qint64 newSize = TIFFReadEncodedStrip(ctx-\u003etiff, static_cast\u003cquint32\u003e(sample * stripsPerSample + strip), stripBuffer.data(), row * scanlineSize);\n                        if(newSize \u003e 0)\n                        {\n                            LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Recovered rows:\" \u003c\u003c row \u003c\u003c \"of\" \u003c\u003c currStripHeight;\n                            stripBufferSize = std::max(expectedStripBufferSize, newSize);\n                            break;\n                        }\n                    }\n                }\n                else\n                {\n                    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Buffer has some data, assume recovered\";\n                    stripBufferSize = expectedStripBufferSize;\n                }\n#endif\n                if(stripBufferSize \u003c= 0)\n                    continue;\n            }\n            if(stripBufferSize \u003c expectedStripBufferSize)\n            {\n                LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFReadEncodedStrip returns not enough data to decode strip\" \u003c\u003c strip \u003c\u003c \"got:\" \u003c\u003c stripBufferSize \u003c\u003c \"expected:\" \u003c\u003c expectedStripBufferSize;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n                stripBufferSize = expectedStripBufferSize;\n#else\n                Q_UNUSED(expectedStripBufferSize);\n                continue;\n#endif\n            }\n\n#if !defined (DEBUG_FORCE_BIT_ACCESS)\n            if(ctx-\u003ebitsPerSample % 8 == 0)\n#else\n            if(false)\n#endif\n            {\n                for(qint64 y = 0; y \u003c currStripHeight; ++y)\n                {\n                    for(qint64 x = 0; x \u003c ctx-\u003ewidth; ++x)\n                    {\n                        const qint64 bufferOffset = y * rasterScanlineSize + (x * ctx-\u003esamplesPerPixel + sample) * ctx-\u003ebitsPerSample / 8;\n                        const qint64 stripBufferOffset = y * scanlineSize + x * ctx-\u003ebitsPerSample / 8;\n                        assert(bufferOffset + ctx-\u003ebitsPerSample / 8 \u003c= buffer.size());\n                        assert(stripBufferOffset + ctx-\u003ebitsPerSample / 8 \u003c= stripBufferSize);\n                        memcpy(buffer.data() + bufferOffset, stripBuffer.data() + stripBufferOffset, static_cast\u003csize_t\u003e(ctx-\u003ebitsPerSample / 8));\n                    }\n                }\n            }\n            else\n            {\n                for(qint64 y = 0; y \u003c currStripHeight; ++y)\n                {\n                    for(qint64 x = 0; x \u003c ctx-\u003ewidth; ++x)\n                    {\n                        const qint64 bufferBitOffset = y * rasterScanlineSize * 8 + (x * ctx-\u003esamplesPerPixel + sample) * ctx-\u003ebitsPerSample;\n                        const qint64 stripBufferBitOffset = y * scanlineSize * 8 + x * ctx-\u003ebitsPerSample;\n                        assert(bufferBitOffset + ctx-\u003ebitsPerSample \u003c= buffer.size() * 8);\n                        assert(stripBufferBitOffset + ctx-\u003ebitsPerSample \u003c= stripBufferSize * 8);\n                        DataProcessing::memcpyBits(buffer.data(), static_cast\u003cquint64\u003e(bufferBitOffset),\n                                                   stripBuffer.data(), static_cast\u003cquint64\u003e(stripBufferBitOffset),\n                                                   static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                    }\n                }\n            }\n        }\n\n        assert(currStripHeight * rasterScanlineSize \u003c= buffer.size());\n        const QImage stripRgb = readFromRawBuffer(reinterpret_cast\u003cconst quint8*\u003e(buffer.data()), ctx-\u003ewidth, currStripHeight, rasterScanlineSize, ctx);\n        if(stripRgb.isNull())\n            continue;\n\n        assert(IsOneOf(stripRgb.format(), QImage::Format_ARGB32, QImage::Format_RGB32));\n        for(qint64 y = 0; y \u003c currStripHeight \u0026\u0026 strip * rowsperstrip + y \u003c ctx-\u003eheight; ++y)\n        {\n            const QRgb *inScanLine = reinterpret_cast\u003cconst QRgb*\u003e(stripRgb.scanLine(y));\n            QRgb *outScanLine = reinterpret_cast\u003cQRgb*\u003e(result.scanLine(strip * rowsperstrip + y));\n            memcpy(outScanLine, inScanLine, static_cast\u003csize_t\u003e(ctx-\u003ewidth * 4));\n        }\n\n        somethingReaded = true;\n    }\n\n    if(!somethingReaded)\n        return QImage();\n    return result;\n}\n\nQImage readTiffFileStripedSeparateSubsampled(const Context *ctx, qint64 numberOfStrips, qint64 stripSize, qint64 rowsperstrip, qint64 scanlineSize, qint64 rasterScanlineSize)\n{\n    assert(ctx);\n    assert(ctx-\u003etiff);\n    assert(numberOfStrips \u003e 0);\n    assert(stripSize \u003e 0);\n    assert(rowsperstrip \u003e 0);\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Striped data with separate planes of subsampled data detected\";\n\n    if(numberOfStrips % ctx-\u003esamplesPerPixel != 0)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid strips count,\" \u003c\u003c numberOfStrips \u003c\u003c \"should be multiple of\" \u003c\u003c ctx-\u003esamplesPerPixel;\n        return QImage();\n    }\n\n    QImage result(ctx-\u003ewidth, ctx-\u003eheight, ctx-\u003ealphaIndex \u003e= 0 ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n    if(result.isNull())\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid image size\";\n        return QImage();\n    }\n    result.fill(ctx-\u003ealphaIndex \u003e= 0 ? Qt::transparent : Qt::white);\n\n    const qint64 bufferAllocSize = rasterScanlineSize * (ctx-\u003eheight + 4);\n    if(bufferAllocSize \u003e BUFFER_MAX_SIZE)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't allocate buffer with size =\" \u003c\u003c bufferAllocSize \u003c\u003c \"due to allocation limit =\" \u003c\u003c BUFFER_MAX_SIZE;\n        return QImage();\n    }\n\n    QByteArray buffer;\n    buffer.resize(bufferAllocSize);\n\n    QByteArray stripBuffer;\n    stripBuffer.resize(stripSize);\n\n    const qint64 leftRows = ctx-\u003eheight % rowsperstrip;\n    const qint64 stripsPerSample = numberOfStrips / ctx-\u003esamplesPerPixel;\n\n    bool somethingReaded = false;\n    for(qint64 strip = 0; strip \u003c stripsPerSample; ++strip)\n    {\n        memset(buffer.data(), BUFFER_FILL_PATTERN, static_cast\u003csize_t\u003e(buffer.size()));\n        const qint64 currStripHeight = ((strip == stripsPerSample - 1) \u0026\u0026 leftRows) ? leftRows : rowsperstrip;\n\n        for(qint64 sample = 0; sample \u003c ctx-\u003esamplesPerPixel; ++sample)\n        {\n            memset(stripBuffer.data(), BUFFER_FILL_PATTERN, static_cast\u003csize_t\u003e(stripBuffer.size()));\n            /// @todo LibTIFF-4.6.0: TIFFReadEncodedStrip can't handle subsampled YCbCr strips\n            /// directly for PLANARCONFIG_SEPARATE. Error example: \"TIFFReadEncodedStrip: Read\n            /// error at scanline 4294967295; got 8540 bytes, expected 16384.\". So we will try\n            /// to read strip with reduced buffer size\n            const bool isSubsampledChroma = IsOneOf(sample, 1, 2);\n            const qint64 expectedStripBufferSize = currStripHeight * ctx-\u003ewidth * ctx-\u003ebitsPerSample / 8 / (isSubsampledChroma ? (ctx-\u003esubsamplingver * ctx-\u003esubsamplinghor) : 1);\n            assert(stripSize \u003e= expectedStripBufferSize);\n#if !defined (DEBUG_FORCE_UNDERFLOW_EMPTY_BUFFER)\n            qint64 stripBufferSize = TIFFReadEncodedStrip(ctx-\u003etiff, static_cast\u003cquint32\u003e(sample * stripsPerSample + strip), stripBuffer.data(), expectedStripBufferSize);\n#else\n            qint64 stripBufferSize = -1;\n#endif\n#if defined (DEBUG_FORCE_UNDERFLOW_FILLED_BUFFER)\n            stripBufferSize = -1;\n#endif\n            if(stripBufferSize \u003c= 0)\n            {\n                LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFReadEncodedStrip failed for strip\" \u003c\u003c strip;\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n                /// @todo LibTIFF-4.6.0: Repeated read is not supported for some compression formats (e.g. OJPEG)\n                /// So let's check current buffer, it may be already filled with all available data\n                bool bufferIsEmpty = true;\n                for(qint64 i = 0; i \u003c stripBuffer.size() \u0026\u0026 bufferIsEmpty; ++i)\n                {\n                    if(*reinterpret_cast\u003cquint8*\u003e(stripBuffer.data() + i) != BUFFER_FILL_PATTERN)\n                        bufferIsEmpty = false;\n                }\n                if(bufferIsEmpty)\n                {\n                    const qint64 currStripHeightSubsampled = currStripHeight / (isSubsampledChroma ? ctx-\u003esubsamplingver : 1);\n                    for(qint64 row = currStripHeightSubsampled; row \u003e= 1; --row)\n                    {\n                        const qint64 newSize = TIFFReadEncodedStrip(ctx-\u003etiff, static_cast\u003cquint32\u003e(sample * stripsPerSample + strip), stripBuffer.data(), expectedStripBufferSize * row / currStripHeightSubsampled);\n                        if(newSize \u003e 0)\n                        {\n                            LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Recovered rows:\" \u003c\u003c row \u003c\u003c \"of\" \u003c\u003c currStripHeightSubsampled;\n                            stripBufferSize = std::max(expectedStripBufferSize, newSize);\n                            break;\n                        }\n                    }\n                }\n                else\n                {\n                    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"Buffer has some data, assume recovered\";\n                    stripBufferSize = expectedStripBufferSize;\n                }\n#endif\n                if(stripBufferSize \u003c= 0)\n                    continue;\n            }\n\n            if(stripBufferSize \u003c expectedStripBufferSize)\n            {\n#if defined (ALLOW_BUFFER_UNDERFLOW)\n                stripBufferSize = expectedStripBufferSize;\n#else\n                Q_UNUSED(expectedStripBufferSize);\n                continue;\n#endif\n            }\n\n            if(isSubsampledChroma)\n            {\n#if !defined (DEBUG_FORCE_BIT_ACCESS)\n                if(ctx-\u003ebitsPerSample % 8 == 0)\n#else\n                if(false)\n#endif\n                {\n                    for(qint64 y = 0; y \u003c currStripHeight / ctx-\u003esubsamplingver; ++y)\n                    {\n                        for(qint64 x = 0; x \u003c ctx-\u003ewidth / ctx-\u003esubsamplinghor; ++x)\n                        {\n                            const qint64 stripBufferOffset = y * scanlineSize / ctx-\u003esubsamplinghor + x * ctx-\u003ebitsPerSample / 8;\n                            // const qint64 stripBufferOffset = (y * ctx-\u003ewidth / ctx-\u003esubsamplinghor + x) * ctx-\u003ebitsPerSample / 8;\n                            assert(stripBufferOffset + ctx-\u003ebitsPerSample / 8 \u003c= stripBufferSize);\n                            for(qint64 yu = y * ctx-\u003esubsamplingver; yu \u003c (y + 1) * ctx-\u003esubsamplingver; ++yu)\n                            {\n                                for(qint64 xu = x * ctx-\u003esubsamplinghor; xu \u003c (x + 1) * ctx-\u003esubsamplinghor; ++xu)\n                                {\n                                    const qint64 bufferOffset = yu * rasterScanlineSize + (xu * ctx-\u003esamplesPerPixel + sample) * ctx-\u003ebitsPerSample / 8;\n                                    // const qint64 bufferOffset = ((yu * ctx-\u003ewidth + xu) * ctx-\u003esamplesPerPixel + sample) * ctx-\u003ebitsPerSample / 8;\n                                    assert(bufferOffset + ctx-\u003ebitsPerSample / 8 \u003c= buffer.size());\n                                    memcpy(buffer.data() + bufferOffset, stripBuffer.data() + stripBufferOffset, static_cast\u003csize_t\u003e(ctx-\u003ebitsPerSample / 8));\n                                }\n                            }\n                        }\n                    }\n                }\n                else\n                {\n                    for(qint64 y = 0; y \u003c currStripHeight / ctx-\u003esubsamplingver; ++y)\n                    {\n                        for(qint64 x = 0; x \u003c ctx-\u003ewidth / ctx-\u003esubsamplinghor; ++x)\n                        {\n                            const qint64 stripBufferBitOffset = y * scanlineSize / ctx-\u003esubsamplinghor * 8 + x * ctx-\u003ebitsPerSample;\n                            // const qint64 stripBufferBitOffset = (y * ctx-\u003ewidth / ctx-\u003esubsamplinghor + x) * ctx-\u003ebitsPerSample;\n                            assert(stripBufferBitOffset + ctx-\u003ebitsPerSample \u003c= stripBufferSize * 8);\n                            for(qint64 yu = y * ctx-\u003esubsamplingver; yu \u003c (y + 1) * ctx-\u003esubsamplingver; ++yu)\n                            {\n                                for(qint64 xu = x * ctx-\u003esubsamplinghor; xu \u003c (x + 1) * ctx-\u003esubsamplinghor; ++xu)\n                                {\n                                    const qint64 bufferBitOffset = yu * rasterScanlineSize * 8 + (xu * ctx-\u003esamplesPerPixel + sample) * ctx-\u003ebitsPerSample;\n                                    // const qint64 bufferBitOffset = ((yu * ctx-\u003ewidth + xu) * ctx-\u003esamplesPerPixel + sample) * ctx-\u003ebitsPerSample;\n                                    assert(bufferBitOffset + ctx-\u003ebitsPerSample \u003c= buffer.size() * 8);\n                                    DataProcessing::memcpyBits(buffer.data(), static_cast\u003cquint64\u003e(bufferBitOffset),\n                                                               stripBuffer.data(), static_cast\u003cquint64\u003e(stripBufferBitOffset),\n                                                               static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            else\n            {\n#if !defined (DEBUG_FORCE_BIT_ACCESS)\n                if(ctx-\u003ebitsPerSample % 8 == 0)\n#else\n                if(false)\n#endif\n                {\n                    for(qint64 y = 0; y \u003c currStripHeight; ++y)\n                    {\n                        for(qint64 x = 0; x \u003c ctx-\u003ewidth; ++x)\n                        {\n                            const qint64 bufferOffset = y * rasterScanlineSize + (x * ctx-\u003esamplesPerPixel + sample) * ctx-\u003ebitsPerSample / 8;\n                            const qint64 stripBufferOffset = y * scanlineSize + x * ctx-\u003ebitsPerSample / 8;\n                            // const qint64 bufferOffset = ((y * ctx-\u003ewidth + x) * ctx-\u003esamplesPerPixel + sample) * ctx-\u003ebitsPerSample / 8;\n                            // const qint64 stripBufferOffset = (y * ctx-\u003ewidth + x) * ctx-\u003ebitsPerSample / 8;\n                            assert(bufferOffset + ctx-\u003ebitsPerSample / 8 \u003c= buffer.size());\n                            assert(stripBufferOffset + ctx-\u003ebitsPerSample / 8 \u003c= stripBufferSize);\n                            memcpy(buffer.data() + bufferOffset, stripBuffer.data() + stripBufferOffset, static_cast\u003csize_t\u003e(ctx-\u003ebitsPerSample / 8));\n                        }\n                    }\n                }\n                else\n                {\n                    for(qint64 y = 0; y \u003c currStripHeight; ++y)\n                    {\n                        for(qint64 x = 0; x \u003c ctx-\u003ewidth; ++x)\n                        {\n                            const qint64 bufferBitOffset = y * rasterScanlineSize * 8 + (x * ctx-\u003esamplesPerPixel + sample) * ctx-\u003ebitsPerSample;\n                            const qint64 stripBufferBitOffset = y * scanlineSize * 8 + x * ctx-\u003ebitsPerSample;\n                            // const qint64 bufferBitOffset = ((y * ctx-\u003ewidth + x) * ctx-\u003esamplesPerPixel + sample) * ctx-\u003ebitsPerSample;\n                            // const qint64 stripBufferBitOffset = (y * ctx-\u003ewidth + x) * ctx-\u003ebitsPerSample;\n                            assert(bufferBitOffset + ctx-\u003ebitsPerSample \u003c= buffer.size() * 8);\n                            assert(stripBufferBitOffset + ctx-\u003ebitsPerSample \u003c= stripBufferSize * 8);\n                            DataProcessing::memcpyBits(buffer.data(), static_cast\u003cquint64\u003e(bufferBitOffset),\n                                                       stripBuffer.data(), static_cast\u003cquint64\u003e(stripBufferBitOffset),\n                                                       static_cast\u003cquint64\u003e(ctx-\u003ebitsPerSample));\n                        }\n                    }\n                }\n            }\n        }\n\n        assert(currStripHeight * rasterScanlineSize \u003c= buffer.size());\n        const QImage stripRgb = readFromRawBuffer(reinterpret_cast\u003cconst quint8*\u003e(buffer.data()), ctx-\u003ewidth, currStripHeight, rasterScanlineSize, ctx);\n        if(stripRgb.isNull())\n            continue;\n\n        assert(IsOneOf(stripRgb.format(), QImage::Format_ARGB32, QImage::Format_RGB32));\n        for(qint64 y = 0; y \u003c currStripHeight \u0026\u0026 strip * rowsperstrip + y \u003c ctx-\u003eheight; ++y)\n        {\n            const QRgb *inScanLine = reinterpret_cast\u003cconst QRgb*\u003e(stripRgb.scanLine(y));\n            QRgb *outScanLine = reinterpret_cast\u003cQRgb*\u003e(result.scanLine(strip * rowsperstrip + y));\n            memcpy(outScanLine, inScanLine, static_cast\u003csize_t\u003e(ctx-\u003ewidth * 4));\n        }\n\n        somethingReaded = true;\n    }\n\n    if(!somethingReaded)\n        return QImage();\n    return result;\n}\n\nQImage readTiffFileStriped(const Context *ctx)\n{\n    assert(ctx);\n    assert(ctx-\u003etiff);\n\n    quint16 planarConfig = 0;\n    if(!TIFFGetFieldDefaulted(ctx-\u003etiff, TIFFTAG_PLANARCONFIG, \u0026planarConfig) || !IsOneOf(planarConfig, PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE))\n        planarConfig = PLANARCONFIG_CONTIG;\n\n    quint32 rowsperstrip = 0;\n    if(!TIFFGetFieldDefaulted(ctx-\u003etiff, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip) || rowsperstrip \u003c= 0)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't get TIFFTAG_ROWSPERSTRIP\";\n        return QImage();\n    }\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFTAG_ROWSPERSTRIP =\" \u003c\u003c rowsperstrip;\n\n    const qint64 scanlineSize = static_cast\u003cqint64\u003e(TIFFScanlineSize(ctx-\u003etiff));\n    const qint64 rasterScanlineSize = static_cast\u003cqint64\u003e(TIFFRasterScanlineSize(ctx-\u003etiff));\n    const qint64 rowsperstrip64 = static_cast\u003cqint64\u003e(rowsperstrip);\n    const qint64 numberOfStrips = static_cast\u003cqint64\u003e(TIFFNumberOfStrips(ctx-\u003etiff));\n    const qint64 stripSize = static_cast\u003cqint64\u003e(TIFFStripSize(ctx-\u003etiff));\n\n    const bool isValidSubsamplingH = IsOneOf(ctx-\u003esubsamplinghor, 1, 2, 4);\n    const bool isValidSubsamplingV = IsOneOf(ctx-\u003esubsamplingver, 1, 2, 4);\n    const bool isValidSubsampledYCbCr = ctx-\u003ephotometric == PHOTOMETRIC_YCBCR \u0026\u0026 ctx-\u003eprimarysamplesCount == 3 \u0026\u0026 isValidSubsamplingH \u0026\u0026 isValidSubsamplingV \u0026\u0026 (ctx-\u003esubsamplinghor \u003e 1 || ctx-\u003esubsamplingver \u003e 1);\n\n    if(planarConfig == PLANARCONFIG_CONTIG)\n    {\n        if(isValidSubsampledYCbCr)\n            return readTiffFileStripedContigSubsampled(ctx, numberOfStrips, stripSize, rowsperstrip64, scanlineSize, rasterScanlineSize);\n        else\n            return readTiffFileStripedContig(ctx, numberOfStrips, stripSize, rowsperstrip64, scanlineSize, rasterScanlineSize);\n    }\n    else if(planarConfig == PLANARCONFIG_SEPARATE)\n    {\n        if(isValidSubsampledYCbCr)\n            return readTiffFileStripedSeparateSubsampled(ctx, numberOfStrips, stripSize, rowsperstrip64, scanlineSize, rasterScanlineSize);\n        else\n            return readTiffFileStripedSeparate(ctx, numberOfStrips, stripSize, rowsperstrip64, scanlineSize, rasterScanlineSize);\n    }\n\n    assert(false);\n    return QImage();\n}\n\n// ====================================================================================================\n\nPayloadWithMetaData\u003cQImage\u003e readTiffFile(const QString \u0026filename)\n{\n    QFile inFile(filename);\n    if(!inFile.open(QIODevice::ReadOnly))\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't open\" \u003c\u003c filename;\n        return QImage();\n    }\n\n#if defined (TIFFLIB_VERSION) \u0026\u0026 (TIFFLIB_VERSION \u003e= 20221213) \u0026\u0026 (QT_VERSION \u003e= QT_VERSION_CHECK(5, 5, 0))\n    TIFFOpenOptions *opts = TIFFOpenOptionsAlloc();\n    TIFFOpenOptionsSetErrorHandlerExtR(opts, errorHandlerProc, Q_NULLPTR);\n    TIFFOpenOptionsSetWarningHandlerExtR(opts, \u0026warningHandlerProc, Q_NULLPTR);\n    TIFF *tiff = TIFFClientOpenExt(\"DecoderLibTiff\", \"r\", \u0026inFile, readProc, writeProc, seekProc, closeProc, sizeProc, mapProc, unmapProc, opts);\n    TIFFOpenOptionsFree(opts);\n#else\n    TIFF *tiff = TIFFClientOpen(\"DecoderLibTiff\", \"r\", \u0026inFile, readProc, writeProc, seekProc, closeProc, sizeProc, mapProc, unmapProc);\n#endif\n    if(!tiff)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't TIFFClientOpen for\" \u003c\u003c filename;\n        return QImage();\n    }\n\n    if(!TIFFSetDirectory(tiff, 0))\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't TIFFSetDirectory for\" \u003c\u003c filename;\n        TIFFClose(tiff);\n        return QImage();\n    }\n\n    quint32 width = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_IMAGEWIDTH, \u0026width) || width \u003c= 0)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't get TIFFTAG_IMAGEWIDTH for\" \u003c\u003c filename;\n        TIFFClose(tiff);\n        return QImage();\n    }\n\n    quint32 height = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_IMAGELENGTH, \u0026height) || height \u003c= 0)\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't get TIFFTAG_IMAGELENGTH for\" \u003c\u003c filename;\n        TIFFClose(tiff);\n        return QImage();\n    }\n\n    quint16 compression = 0;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_COMPRESSION, \u0026compression);\n\n    /// @todo LibTIFF-4.6.0: Looks like samples layout for subsampled YCbCr data\n    /// for JPEG compression is differ from samples layout for other compression\n    /// types. So we will enforce built-in YCbCr to RGB converter. Despite tag\n    /// name, non-YCbCr colorspaces like CMYK or RGB are not affected\n    if(compression == COMPRESSION_JPEG)\n        TIFFSetField(tiff, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\n    quint16 samplesPerPixel = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLESPERPIXEL, \u0026samplesPerPixel) || samplesPerPixel \u003c= 0)\n        samplesPerPixel = 1;\n\n    int alphaIndex = -1;\n    quint16 extrasamplesCount = 0;\n    const quint16 *extrasamples = Q_NULLPTR;\n    if(TIFFGetFieldDefaulted(tiff, TIFFTAG_EXTRASAMPLES, \u0026extrasamplesCount, \u0026extrasamples))\n    {\n        for(quint16 i = 0; i \u003c extrasamplesCount \u0026\u0026 alphaIndex \u003c 0; ++i)\n        {\n            if(extrasamples[i] == EXTRASAMPLE_ASSOCALPHA)\n                alphaIndex = static_cast\u003cint\u003e(i);\n        }\n        for(quint16 i = 0; i \u003c extrasamplesCount \u0026\u0026 alphaIndex \u003c 0; ++i)\n        {\n            if(extrasamples[i] == EXTRASAMPLE_UNASSALPHA)\n                alphaIndex = static_cast\u003cint\u003e(i);\n        }\n    }\n    const quint16 primarysamplesCount = samplesPerPixel \u003e extrasamplesCount ? samplesPerPixel - extrasamplesCount : 0;\n\n    quint16 photometric = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_PHOTOMETRIC, \u0026photometric))\n    {\n        LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't get TIFFTAG_PHOTOMETRIC for\" \u003c\u003c filename;\n        if(primarysamplesCount == 1)\n        {\n            photometric = PHOTOMETRIC_MINISWHITE;\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Assuming PHOTOMETRIC_MINISWHITE\";\n        }\n        else if(primarysamplesCount == 3)\n        {\n            photometric = PHOTOMETRIC_RGB;\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Assuming PHOTOMETRIC_RGB\";\n        }\n        else\n        {\n            TIFFClose(tiff);\n            return QImage();\n        }\n    }\n\n    /// @note Enable converting PHOTOMETRIC_LOGL and PHOTOMETRIC_LOGLUV to 8 bit\n    /// RGB and grayscale values respective\n    if(IsOneOf(photometric, PHOTOMETRIC_LOGL, PHOTOMETRIC_LOGLUV))\n        TIFFSetField(tiff, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n\n    quint16 orientation = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_ORIENTATION, \u0026orientation) || orientation \u003c= 0)\n        orientation = ORIENTATION_TOPLEFT;\n\n    quint16 bitsPerSample = 0;\n    if(!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, \u0026bitsPerSample) || bitsPerSample \u003c= 0)\n        bitsPerSample = 1;\n\n    quint16 sampleFormat = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLEFORMAT, \u0026sampleFormat) || sampleFormat \u003c= 0)\n        sampleFormat = SAMPLEFORMAT_VOID;\n\n    quint16 inkSet = 0;\n    if(photometric == PHOTOMETRIC_SEPARATED)\n    {\n        if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_INKSET, \u0026inkSet) || inkSet \u003c= 0)\n            inkSet = INKSET_CMYK;\n    }\n\n    quint16 planarConfig = 0;\n    TIFFGetField(tiff, TIFFTAG_PLANARCONFIG, \u0026planarConfig);\n\n    const float *ycbcrcoeffs = Q_NULLPTR;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_YCBCRCOEFFICIENTS, \u0026ycbcrcoeffs);\n\n    quint16 subsamplinghor = 0, subsamplingver = 0;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_YCBCRSUBSAMPLING, \u0026subsamplinghor, \u0026subsamplingver);\n\n    quint16 ycbcrpositioning = 0;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_YCBCRPOSITIONING, \u0026ycbcrpositioning);\n\n    const quint16 *redTable = Q_NULLPTR;\n    const quint16 *greenTable = Q_NULLPTR;\n    const quint16 *blueTable = Q_NULLPTR;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_COLORMAP, \u0026redTable, \u0026greenTable, \u0026blueTable);\n\n    QScopedPointer\u003cICCProfile\u003e iccProfile(readICCProfile(tiff));\n    if((!iccProfile || !iccProfile-\u003eisValid()) \u0026\u0026 photometric == PHOTOMETRIC_SEPARATED \u0026\u0026 inkSet == INKSET_CMYK)\n        iccProfile.reset(new ICCProfile(ICCProfile::defaultCmykProfileData()));\n\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFTAG_IMAGEWIDTH =\" \u003c\u003c width;\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFTAG_IMAGELENGTH =\" \u003c\u003c height;\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFTAG_PHOTOMETRIC =\" \u003c\u003c photometricToString(photometric).toLatin1().data();\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFTAG_INKSET =\" \u003c\u003c inkSetToString(inkSet).toLatin1().data();\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFTAG_ORIENTATION =\" \u003c\u003c orientationToString(orientation).toLatin1().data();\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFTAG_BITSPERSAMPLE =\" \u003c\u003c bitsPerSample;\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFTAG_SAMPLESPERPIXEL =\" \u003c\u003c samplesPerPixel;\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFTAG_SAMPLEFORMAT =\" \u003c\u003c sampleFormatToString(sampleFormat).toLatin1().data();\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFTAG_EXTRASAMPLES =\" \u003c\u003c extrasamplesToString(extrasamplesCount, extrasamples).toLatin1().data();\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFTAG_PLANARCONFIG =\" \u003c\u003c planarConfigToString(planarConfig).toLatin1().data();\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFTAG_COMPRESSION =\" \u003c\u003c compressionToString(compression).toLatin1().data();\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFTAG_YCBCRSUBSAMPLING =\" \u003c\u003c subsamplinghor \u003c\u003c subsamplingver;\n    LOG_DEBUG() \u003c\u003c LOGGING_CTX \u003c\u003c \"TIFFTAG_YCBCRPOSITIONING =\" \u003c\u003c ycbcrpositioningToString(ycbcrpositioning).toLatin1().data();\n\n    const bool isSupportedInt = IsOneOf(sampleFormat, SAMPLEFORMAT_UINT, SAMPLEFORMAT_VOID, SAMPLEFORMAT_INT) \u0026\u0026 bitsPerSample \u003c= 64;\n    const bool isSupportedFp = sampleFormat == SAMPLEFORMAT_IEEEFP \u0026\u0026 IsOneOf(bitsPerSample, 16, 24, 32, 64);\n    bool isReadingSupported = false;\n    switch(photometric)\n    {\n    case PHOTOMETRIC_MINISWHITE:\n    case PHOTOMETRIC_MINISBLACK:\n    case PHOTOMETRIC_LOGL:\n        isReadingSupported = (isSupportedInt || isSupportedFp) \u0026\u0026 primarysamplesCount \u003e= 1;\n        break;\n    case PHOTOMETRIC_RGB:\n    case PHOTOMETRIC_YCBCR:\n    case PHOTOMETRIC_LOGLUV:\n        isReadingSupported = (isSupportedInt || isSupportedFp) \u0026\u0026 primarysamplesCount \u003e= 3;\n        break;\n    case PHOTOMETRIC_SEPARATED:\n        isReadingSupported = (isSupportedInt || isSupportedFp) \u0026\u0026 primarysamplesCount \u003e= 4;\n        break;\n    case PHOTOMETRIC_CIELAB:\n    case PHOTOMETRIC_ICCLAB:\n    case PHOTOMETRIC_ITULAB:\n        isReadingSupported = (isSupportedInt || isSupportedFp) \u0026\u0026 primarysamplesCount \u003e= 1;\n        break;\n    case PHOTOMETRIC_PALETTE:\n        isReadingSupported = redTable \u0026\u0026 greenTable \u0026\u0026 blueTable \u0026\u0026 bitsPerSample \u003c= 16 \u0026\u0026 primarysamplesCount \u003e= 1;\n        break;\n    // case PHOTOMETRIC_MASK:\n    // case PHOTOMETRIC_CFA:\n    default:\n        break;\n    }\n\n    QImage result;\n    if(isReadingSupported)\n    {\n        Context ctx;\n        memset(\u0026ctx, 0, sizeof(ctx));\n        ctx.tiff = tiff;\n        ctx.width = static_cast\u003cqint64\u003e(width);\n        ctx.height = static_cast\u003cqint64\u003e(height);\n        ctx.compression = compression;\n        ctx.photometric = compression == COMPRESSION_JPEG \u0026\u0026 photometric == PHOTOMETRIC_YCBCR ? PHOTOMETRIC_RGB : photometric;\n        ctx.samplesPerPixel = static_cast\u003cqint64\u003e(samplesPerPixel);\n        ctx.bitsPerSample = static_cast\u003cqint64\u003e(bitsPerSample);\n        ctx.sampleFormat = sampleFormat;\n        ctx.inkSet = inkSet;\n        ctx.iccProfile = iccProfile.data();\n        ctx.ycbcrcoeffs = ycbcrcoeffs;\n        ctx.subsamplinghor = static_cast\u003cqint64\u003e(subsamplinghor);\n        ctx.subsamplingver = static_cast\u003cqint64\u003e(subsamplingver);\n        ctx.ycbcrpositioning = ycbcrpositioning;\n        ctx.extrasamplesCount = static_cast\u003cqint64\u003e(extrasamplesCount);\n        ctx.primarysamplesCount = static_cast\u003cqint64\u003e(primarysamplesCount);\n        ctx.alphaIndex = alphaIndex;\n        ctx.alphaPremultiplied = alphaIndex \u003e= 0 ? extrasamples[alphaIndex] == EXTRASAMPLE_ASSOCALPHA : false;\n        ctx.redTable = redTable;\n        ctx.greenTable = greenTable;\n        ctx.blueTable = blueTable;\n        ctx.colorTablesIs16Bit = false;\n\n        if(photometric == PHOTOMETRIC_PALETTE \u0026\u0026 redTable \u0026\u0026 greenTable \u0026\u0026 blueTable)\n        {\n            /// @note See buildMap and checkcmap in tif_getimage.c\n            for(quint64 i = 0, count = (1ull \u003c\u003c bitsPerSample); i \u003c count \u0026\u0026 !ctx.colorTablesIs16Bit; ++i)\n                if(redTable[i] \u003e= 256 || greenTable[i] \u003e= 256 || blueTable[i] \u003e= 256)\n                    ctx.colorTablesIs16Bit = true;\n        }\n\n        if(TIFFIsTiled(tiff))\n            result = readTiffFileTiled(\u0026ctx);\n        else\n            result = readTiffFileStriped(\u0026ctx);\n    }\n\n    /// @todo LibTIFF-4.6.0: TIFFRGBA* has bad errors handling and reports OK\n    /// sometimes even if no data was decoded. So we will disable it for all\n    /// supported formats\n    if(result.isNull() \u0026\u0026 !isReadingSupported)\n    {\n        TIFFRGBAImage img;\n        char emsg[1024];\n        if(!TIFFRGBAImageBegin(\u0026img, tiff, 0, emsg))\n        {\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't TIFFRGBAImageBegin for\" \u003c\u003c filename;\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Reason:\" \u003c\u003c emsg;\n            TIFFClose(tiff);\n            return QImage();\n        }\n\n        result = QImage(static_cast\u003cint\u003e(img.width), static_cast\u003cint\u003e(img.height),\n#if (USE_RGBA_8888)\n                      QImage::Format_RGBA8888);\n#else\n                      QImage::Format_ARGB32);\n#endif\n        if(result.isNull())\n        {\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Invalid image size\";\n            TIFFClose(tiff);\n            return QImage();\n        }\n\n        img.req_orientation = img.orientation;\n\n#if defined (TIFFLIB_VERSION) \u0026\u0026 (TIFFLIB_VERSION \u003e= 20210416)\n        typedef uint32_t TiffImageBitsType;\n#else\n        typedef uint32 TiffImageBitsType;\n#endif\n\n        if(!TIFFRGBAImageGet(\u0026img, reinterpret_cast\u003cTiffImageBitsType*\u003e(result.bits()), img.width, img.height))\n        {\n            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't TIFFRGBAImageGet for\" \u003c\u003c filename;\n            TIFFClose(tiff);\n            return QImage();\n        }\n\n#if (!USE_RGBA_8888)\n        QImage_rgbSwap(result);\n#endif\n\n#undef USE_RGBA_8888\n\n        TIFFRGBAImageEnd(\u0026img);\n\n        if(iccProfile)\n            iccProfile-\u003eapplyToImage(\u0026result);\n    }\n\n    // Some image formats can't be rendered successfully\n    if(!IsOneOf(result.format(), QImage::Format_RGB32, QImage::Format_ARGB32))\n        QImage_convertTo(result, result.hasAlphaChannel() ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n\n    ImageMetaData *metaData = ImageMetaData::createMetaData(filename);\n    if(!metaData)\n        metaData = readExifMetaData(tiff);\n    if(!metaData)\n        metaData = new ImageMetaData;\n\n    metaData-\u003eaddCustomOrientation(orientation);\n    metaData-\u003eapplyExifOrientation(\u0026result);\n\n    quint16 resUnit = 0;\n    if(!TIFFGetField(tiff, TIFFTAG_RESOLUTIONUNIT, \u0026resUnit))\n        resUnit = RESUNIT_INCH;\n    float resX = 0.0f, resY = 0.0f;\n    if(TIFFGetField(tiff, TIFFTAG_XRESOLUTION, \u0026resX) \u0026\u0026 TIFFGetField(tiff, TIFFTAG_YRESOLUTION, \u0026resY))\n    {\n        if(resUnit == RESUNIT_CENTIMETER)\n            metaData-\u003eaddCustomDpi(static_cast\u003cqreal\u003e(resX * 2.54f), static_cast\u003cqreal\u003e(resY * 2.54f));\n        else if(resUnit == RESUNIT_INCH)\n            metaData-\u003eaddCustomDpi(static_cast\u003cqreal\u003e(resX), static_cast\u003cqreal\u003e(resY));\n    }\n\n    TIFFClose(tiff);\n\n    return PayloadWithMetaData\u003cQImage\u003e(result, metaData);\n}\n\n// ====================================================================================================\n\nclass DecoderLibTiff : public IDecoder\n{\npublic:\n    QString name() const Q_DECL_OVERRIDE\n    {\n        return QString::fromLatin1(\"DecoderLibTiff\");\n    }\n\n    QStringList supportedFormats() const Q_DECL_OVERRIDE\n    {\n        return QStringList()\n                \u003c\u003c QString::fromLatin1(\"tif\")\n                \u003c\u003c QString::fromLatin1(\"tiff\");\n    }\n\n    QStringList advancedFormats() const Q_DECL_OVERRIDE\n    {\n        return QStringList();\n    }\n\n    bool isAvailable() const Q_DECL_OVERRIDE\n    {\n        return true;\n    }\n\n    QSharedPointer\u003cIImageData\u003e loadImage(const QString \u0026filePath) Q_DECL_OVERRIDE\n    {\n        const QFileInfo fileInfo(filePath);\n        if(!fileInfo.exists() || !fileInfo.isReadable())\n            return QSharedPointer\u003cIImageData\u003e();\n        const PayloadWithMetaData\u003cQImage\u003e readData = readTiffFile(filePath);\n        QGraphicsItem *item = GraphicsItemsFactory::instance().createImageItem(readData);\n        return QSharedPointer\u003cIImageData\u003e(new ImageData(item, filePath, name(), readData.metaData()));\n    }\n};\n\nDecoderAutoRegistrator registrator(new DecoderLibTiff);\n\n// ====================================================================================================\n\n} // namespace\n",
        "name": "DecoderLibTiff.cpp",
        "path": "src/ImageViewer/src/Decoders/Impl/DecoderLibTiff.cpp",
        "url": "/github.com/AlienCowEatCake/ImageViewer/-/blob/src/ImageViewer/src/Decoders/Impl/DecoderLibTiff.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3208,
          "offsetAndLengths": [
            [
              12,
              16
            ]
          ],
          "preview": "        if(!TIFFRGBAImageGet(\u0026img, reinterpret_cast\u003cTiffImageBitsType*\u003e(result.bits()), img.width, img.height))"
        },
        {
          "limitHit": false,
          "lineNumber": 3210,
          "offsetAndLengths": [
            [
              51,
              16
            ]
          ],
          "preview": "            LOG_WARNING() \u003c\u003c LOGGING_CTX \u003c\u003c \"Can't TIFFRGBAImageGet for\" \u003c\u003c filename;"
        }
      ],
      "repository": {
        "name": "github.com/AlienCowEatCake/ImageViewer",
        "url": "/github.com/AlienCowEatCake/ImageViewer"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "e5f0f3e5b1183facee2dd0c723757e9033d89c61"
        },
        "content": "#include \"StdAfx.h\"\n\n// #define STRICT\n#include \"diblib.h\"\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e // MAX_ constants\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage\n{\n    TIFFRGBAImage tif;\n    int dibinstalled;\n};\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster);\n\nstatic void MyWarningHandler(const char *module, const char *fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void MyErrorHandler(const char *module, const char *fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF(LPCTSTR lpszPath)\n{\n    int rtn = 0;\n\n    TIFFErrorHandler eh;\n    TIFFErrorHandler wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF *tif = TIFFOpen(lpszPath, \"r\");\n    if (tif)\n    {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage *img);\n\nPVOID ReadTIFF(LPCTSTR lpszPath)\n{\n    void *pDIB = 0;\n    TIFFErrorHandler wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath))\n    {\n        TIFF *tif = TIFFOpen(lpszPath, \"r\");\n        if (tif)\n        {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg))\n            {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg))\n                {\n                    size_t npixels;\n                    uint32_t *raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster =\n                        (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n                    if (raster != NULL)\n                    {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width,\n                                             img.tif.height))\n                        {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else\n            {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg);\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster)\n{\n    void *pDIB = 0;\n    TIFFRGBAImage *img = \u0026dib-\u003etif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER bi;\n    int dwDIBSize;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if (BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled)\n    { // bilevel\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 1;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(\u0026bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed = 0;\n        pRgbq[0].rgbBlue = 0;\n        pRgbq[0].rgbGreen = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed = 255;\n        pRgbq[1].rgbBlue = 255;\n        pRgbq[1].rgbGreen = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr(\n            (BITMAPINFOHEADER *)pDIB); //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n    //  For now just always default to the RGB 32 bit form. // save as 32 bit\n    //  for simplicity\n    else if (true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/)\n    { // 24 bit color\n\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 32;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(\u0026bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        // Swap the byte order while copying\n        for (int i = 0; i \u003c sizeWords; ++i)\n        {\n            rgbDib[i].rgbRed = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n#define DECLAREContigPutFunc(name)                                             \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *pp)\n\n#define DECLARESepPutFunc(name)                                                \\\n    static void name(TIFFRGBAImage *img, uint32_t *cp, uint32_t x, uint32_t y, \\\n                     uint32_t w, uint32_t h, int32_t fromskew, int32_t toskew, \\\n                     u_char *r, u_char *g, u_char *b, u_char *a)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *uraster, uint32_t w,\n                              uint32_t h);\n\n// typdef struct TIFFDibImage {\n//     TIFFRGBAImage tif;\n//     dibinstalled;\n// } TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage *dib)\n{\n    TIFFRGBAImage *img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric)\n    {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n            switch (img-\u003ebitspersample)\n            {\n                case 1:\n                    img-\u003eput.contig = putContig1bitTile;\n                    img-\u003eget = getStripContig1Bit;\n                    dib-\u003edibinstalled = true;\n                    break;\n            }\n            break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void)y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char *ucp = (u_char *)cp;\n\n    /* Convert 'w' to bytes from pixels (rounded up) */\n    w = (w + 7) / 8;\n\n    while (h-- \u003e 0)\n    {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32_t setorientation(TIFFRGBAImage *img, uint32_t h)\n{\n    TIFF *tif = img-\u003etif;\n    uint32_t y;\n\n    switch (img-\u003eorientation)\n    {\n        case ORIENTATION_BOTRIGHT:\n        case ORIENTATION_RIGHTBOT: /* XXX */\n        case ORIENTATION_LEFTBOT:  /* XXX */\n            TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n            img-\u003eorientation = ORIENTATION_BOTLEFT;\n        /* fall through... */\n        case ORIENTATION_BOTLEFT:\n            y = 0;\n            break;\n        case ORIENTATION_TOPRIGHT:\n        case ORIENTATION_RIGHTTOP: /* XXX */\n        case ORIENTATION_LEFTTOP:  /* XXX */\n        default:\n            TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n            img-\u003eorientation = ORIENTATION_TOPLEFT;\n        /* fall through... */\n        case ORIENTATION_TOPLEFT:\n            y = h - 1;\n            break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int getStripContig1Bit(TIFFRGBAImage *img, uint32_t *raster, uint32_t w,\n                              uint32_t h)\n{\n    TIFF *tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16_t orientation;\n    uint32_t row, y, nrow, rowstoread;\n    uint32_t pos;\n    u_char *buf;\n    uint32_t rowsperstrip;\n    uint32_t imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32_t fromskew, toskew;\n    tstrip_t strip;\n    tsize_t stripsize;\n    u_char *braster = (u_char *)raster; // byte wide raster\n    uint32_t wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char *)_TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32_t)(orientation == ORIENTATION_TOPLEFT ? wb + wb : wb - wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0) / 8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif, row + img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset) % rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize) \u003c 0 \u0026\u0026\n            img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32_t *)(braster + y * wb), 0, y, w, nrow, fromskew,\n               toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ? -(int32_t)nrow\n                                                 : (int32_t)nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n",
        "name": "Tiffile.cpp",
        "path": "src/ThirdParty/libtiff/tiff-4.7.0/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/AlienCowEatCake/ImageViewer/-/blob/src/ThirdParty/libtiff/tiff-4.7.0/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 112,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width,"
        }
      ],
      "repository": {
        "name": "github.com/AlienCowEatCake/ImageViewer",
        "url": "/github.com/AlienCowEatCake/ImageViewer"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "f816c264cfa21b85f195d5ecb884254cebd42752"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "tiff-4.0.1/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/alexmac/alcextra/-/blob/tiff-4.0.1/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/alexmac/alcextra",
        "url": "/github.com/alexmac/alcextra"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "c0106bb5b14269696fab740437cf18dd2eb47986"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "src/jni/sdl2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/renpy/python-for-android/-/blob/src/jni/sdl2_image/external/tiff-4.0.3/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/renpy/python-for-android",
        "url": "/github.com/renpy/python-for-android"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "f9c15052c8f830e076838142ac65aca620396e63"
        },
        "content": "#include \"StdAfx.h\"\n\n//#define STRICT\n#include \u003cwindows.h\u003e\n#include \u003cwindowsx.h\u003e\n#include \u003ccommdlg.h\u003e\n#include \u003cstdlib.h\u003e                     // MAX_ constants\n#include \"diblib.h\"\n\n/*--------------------------------------------------------------------\n        READ TIFF\n        Load the TIFF data from the file into memory.  Return\n        a pointer to a valid DIB (or NULL for errors).\n        Uses the TIFFRGBA interface to libtiff.lib to convert\n        most file formats to a useable form.  We just keep the 32 bit\n        form of the data to display, rather than optimizing for the\n        display.\n\n        Main entry points:\n\n            int ChkTIFF ( LPCTSTR lpszPath )\n            PVOID ReadTIFF ( LPCTSTR lpszPath )\n\n        RETURN\n            A valid DIB pointer for success; NULL for failure.\n\n  --------------------------------------------------------------------*/\n\n#include \"TiffLib/tiff.h\"\n#include \"TiffLib/tiffio.h\"\n#include \u003cassert.h\u003e\n#include \u003cstdio.h\u003e\n\n\n// piggyback some data on top of the RGBA Image\nstruct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n} ;\n\n\nHANDLE LoadTIFFinDIB(LPCTSTR lpFileName);\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)  ;\n\nstatic void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}\n\nstatic void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}\n\n//  Turn off the error and warning handlers to check if a valid file.\n//  Necessary because of the way that the Doc loads images and restart files.\nint ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}\n\nvoid DibInstallHack(TIFFDibImage* img) ;\n\nPVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(\u0026img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(\u0026img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(\u0026img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(\u0026img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}\n\n\n\nHANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGEWIDTH, \u0026imageWidth);\n    TIFFGetField(img-\u003etif, TIFFTAG_IMAGELENGTH, \u0026imageLength);\n    TIFFGetField(img-\u003etif, TIFFTAG_BITSPERSAMPLE, \u0026BitsPerSample);\n    TIFFGetField(img-\u003etif, TIFFTAG_ROWSPERSTRIP, \u0026RowsPerStrip);\n    TIFFGetField(img-\u003etif, TIFFTAG_SAMPLESPERPIXEL, \u0026SamplePerPixel);\n    TIFFGetField(img-\u003etif, TIFFTAG_PHOTOMETRIC, \u0026PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 \u0026\u0026 SamplePerPixel == 1 \u0026\u0026 dib-\u003edibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 \u0026\u0026 SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( \u0026bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i \u003c sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}\n\n\n\n\n///////////////////////////////////////////////////////////////\n//\n//  Hacked from tif_getimage.c in libtiff in v3.5.7\n//\n//\ntypedef unsigned char u_char;\n\n\n#define DECLAREContigPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img, \\\n    uint32* cp, \\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h, \\\n    int32 fromskew, int32 toskew, \\\n    u_char* pp \\\n)\n\n#define DECLARESepPutFunc(name) \\\nstatic void name(\\\n    TIFFRGBAImage* img,\\\n    uint32* cp,\\\n    uint32 x, uint32 y, \\\n    uint32 w, uint32 h,\\\n    int32 fromskew, int32 toskew,\\\n    u_char* r, u_char* g, u_char* b, u_char* a\\\n)\n\nDECLAREContigPutFunc(putContig1bitTile);\nstatic int getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h);\n\n//typdef struct TIFFDibImage {\n//    TIFFRGBAImage tif;\n//    dibinstalled;\n//} TIFFDibImage ;\n\nvoid DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = \u0026dib-\u003etif;\n    dib-\u003edibinstalled = false;\n    switch (img-\u003ephotometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img-\u003ebitspersample) {\n            case 1:\n                img-\u003eput.contig = putContig1bitTile;\n                img-\u003eget = getStripContig1Bit;\n                dib-\u003edibinstalled = true;\n                break;\n        }\n        break;\n    }\n}\n\n/*\n * 1-bit packed samples =\u003e 1-bit\n *\n *   Override to just copy the data\n */\nDECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img-\u003esamplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- \u003e 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- \u003e 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}\n\n/*\n *  Hacked from the tif_getimage.c file.\n */\nstatic uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    uint32 y;\n\n    switch (img-\u003eorientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img-\u003eorientation = ORIENTATION_BOTLEFT;\n    /* fall thru... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img-\u003eorientation = ORIENTATION_TOPLEFT;\n    /* fall thru... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}\n\n/*\n * Get a strip-organized image that has\n *  PlanarConfiguration contiguous if SamplesPerPixel \u003e 1\n * or\n *  SamplesPerPixel == 1\n *\n *  Hacked from the tif_getimage.c file.\n *\n *    This is set up to allow us to just copy the data to the raster\n *    for 1-bit bitmaps\n */\nstatic int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img-\u003etif;\n    tileContigRoutine put = img-\u003eput.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img-\u003ewidth;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif-\u003etif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img-\u003eorientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, \u0026rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w \u003c imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row \u003c h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img-\u003erow_offset) % rowsperstrip;\n        nrow = (row + rowstoread \u003e h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img-\u003erow_offset, 0);\n        stripsize = ((row + img-\u003erow_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) \u003c 0\n            \u0026\u0026 img-\u003estoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img-\u003erow_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}\n\n/*\n * Local Variables:\n * mode: c++\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */\n",
        "name": "Tiffile.cpp",
        "path": "tools/dist/rcbasic_android/android-project/app/jni/SDL2_image/external/tiff-4.0.9/contrib/win_dib/Tiffile.cpp",
        "url": "/github.com/n00b87/RCBASIC3/-/blob/tools/dist/rcbasic_android/android-project/app/jni/SDL2_image/external/tiff-4.0.9/contrib/win_dib/Tiffile.cpp"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              28,
              16
            ]
          ],
          "preview": "                        if (TIFFRGBAImageGet(\u0026img.tif, raster, img.tif.width, img.tif.height)) {"
        }
      ],
      "repository": {
        "name": "github.com/n00b87/RCBASIC3",
        "url": "/github.com/n00b87/RCBASIC3"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 75,
  "ElapsedMilliseconds": 1424,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
