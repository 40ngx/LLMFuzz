{
    "SourcegraphEndpoint": "https://sourcegraph.com",
    "Query": "file:\\.(c|cpp|cc)$ lang:c++ count:all TIFFReadRGBATileExt",
    "Site": {
        "BuildVersion": "316984_2025-03-18_6.1-1f1695fa27f5"
    },
    "Results": [
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "c83e7858a9ec566cc91d65db74fd07b99789c0f0"
                },
                "content": "/******************************************************************************\n *\n * Project:  GeoTIFF Driver\n * Purpose:  GDAL GeoTIFF support.\n * Author:   Frank Warmerdam, warmerdam@pobox.com\n *\n ******************************************************************************\n * Copyright (c) 1998, 2002, Frank Warmerdam <warmerdam@pobox.com>\n * Copyright (c) 2007-2015, Even Rouault <even dot rouault at spatialys dot com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ****************************************************************************/\n\n// If we use sunpro compiler on linux. Weird idea indeed!\n#if defined(__SUNPRO_CC) && defined(__linux__)\n#define _GNU_SOURCE\n#elif defined(__GNUC__) && !defined(_GNU_SOURCE)\n// Required to use RTLD_DEFAULT of dlfcn.h.\n#define _GNU_SOURCE\n#endif\n\n#include \"cpl_port.h\"  // Must be first.\n#include \"gtiff.h\"\n\n#include <cassert>\n#include <cerrno>\n#include <climits>\n#include <cmath>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#if HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#if HAVE_SYS_STAT_H\n#  include <sys/stat.h>\n#endif\n\n#include <algorithm>\n#include <memory>\n#include <mutex>\n#include <set>\n#include <string>\n#include <vector>\n\n#include \"cpl_config.h\"\n#include \"cpl_conv.h\"\n#include \"cpl_csv.h\"\n#include \"cpl_error.h\"\n#include \"cpl_minixml.h\"\n#include \"cpl_multiproc.h\"\n#include \"cpl_port.h\"\n#include \"cpl_progress.h\"\n#include \"cpl_string.h\"\n#include \"cpl_virtualmem.h\"\n#include \"cpl_vsi.h\"\n#include \"cpl_vsi_virtual.h\"\n#include \"cpl_worker_thread_pool.h\"\n#include \"cplkeywordparser.h\"\n#include \"gdal.h\"\n#include \"gdal_csv.h\"\n#include \"gdal_frmts.h\"\n#include \"gdal_mdreader.h\"\n#include \"gdal_pam.h\"\n#include \"gdal_priv.h\"\n#include \"gdal_priv_templates.hpp\"\n#include \"geo_normalize.h\"\n#include \"geotiff.h\"\n#include \"geovalues.h\"\n#include \"gt_jpeg_copy.h\"\n#include \"gt_overview.h\"\n#include \"gt_wkt_srs.h\"\n#include \"gt_wkt_srs_priv.h\"\n#include \"ogr_spatialref.h\"\n#include \"tiff.h\"\n#include \"tif_float.h\"\n#include \"tiffio.h\"\n#ifdef INTERNAL_LIBTIFF\n#  include \"tiffiop.h\"\n#  include \"tif_lerc.h\"\n#    ifdef WEBP_SUPPORT\n#      include \"webp/encode.h\"\n#    endif\n#endif\n#include \"tiffvers.h\"\n#include \"tifvsi.h\"\n#include \"xtiffio.h\"\n\n\nCPL_CVSID(\"$Id: geotiff.cpp 327f91335ae848e9c94bac0c8451522410e5064e 2019-09-11 00:45:29 +0200 Even Rouault $\")\n\nstatic bool bGlobalInExternalOvr = false;\nstatic std::mutex gMutexThreadPool;\nCPLWorkerThreadPool *gpoCompressThreadPool = nullptr;\n\n// Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if TIFFLIB_VERSION >= 20120922\n#define SUPPORTS_MORE_THAN_32768_DIRECTORIES\n#endif\n\nconst char* const szJPEGGTiffDatasetTmpPrefix = \"/vsimem/gtiffdataset_jpg_tmp_\";\n\ntypedef enum\n{\n    GTIFFTAGTYPE_STRING,\n    GTIFFTAGTYPE_SHORT,\n    GTIFFTAGTYPE_FLOAT,\n    GTIFFTAGTYPE_BYTE_STRING\n} GTIFFTagTypes;\n\ntypedef struct\n{\n    const char    *pszTagName;\n    int            nTagVal;\n    GTIFFTagTypes  eType;\n} GTIFFTags;\n\nstatic const GTIFFTags asTIFFTags[] =\n{\n    { \"TIFFTAG_DOCUMENTNAME\", TIFFTAG_DOCUMENTNAME, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_IMAGEDESCRIPTION\", TIFFTAG_IMAGEDESCRIPTION,\n        GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_SOFTWARE\", TIFFTAG_SOFTWARE, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_DATETIME\", TIFFTAG_DATETIME, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_ARTIST\", TIFFTAG_ARTIST, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_HOSTCOMPUTER\", TIFFTAG_HOSTCOMPUTER, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_COPYRIGHT\", TIFFTAG_COPYRIGHT, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_XRESOLUTION\", TIFFTAG_XRESOLUTION, GTIFFTAGTYPE_FLOAT },\n    { \"TIFFTAG_YRESOLUTION\", TIFFTAG_YRESOLUTION, GTIFFTAGTYPE_FLOAT },\n    // Dealt as special case.\n    { \"TIFFTAG_RESOLUTIONUNIT\", TIFFTAG_RESOLUTIONUNIT, GTIFFTAGTYPE_SHORT },\n    { \"TIFFTAG_MINSAMPLEVALUE\", TIFFTAG_MINSAMPLEVALUE, GTIFFTAGTYPE_SHORT },\n    { \"TIFFTAG_MAXSAMPLEVALUE\", TIFFTAG_MAXSAMPLEVALUE, GTIFFTAGTYPE_SHORT },\n\n    // GeoTIFF DGIWG tags\n    { \"GEO_METADATA\", TIFFTAG_GEO_METADATA, GTIFFTAGTYPE_BYTE_STRING },\n    { \"TIFF_RSID\", TIFFTAG_TIFF_RSID, GTIFFTAGTYPE_STRING },\n};\n\nconst char szPROFILE_BASELINE[] = \"BASELINE\";\nconst char szPROFILE_GeoTIFF[] = \"GeoTIFF\";\nconst char szPROFILE_GDALGeoTIFF[] = \"GDALGeoTIFF\";\n\n/************************************************************************/\n/*                          GTIFFSetInExternalOvr()                     */\n/************************************************************************/\n\nvoid GTIFFSetInExternalOvr( bool b )\n{\n    bGlobalInExternalOvr = b;\n}\n\n/************************************************************************/\n/*                     GTIFFGetOverviewBlockSize()                      */\n/************************************************************************/\n\nvoid GTIFFGetOverviewBlockSize( int* pnBlockXSize, int* pnBlockYSize )\n{\n    const char* pszVal = CPLGetConfigOption(\"GDAL_TIFF_OVR_BLOCKSIZE\", \"128\");\n    int nOvrBlockSize = atoi(pszVal);\n    if( nOvrBlockSize < 64 || nOvrBlockSize > 4096 ||\n        !CPLIsPowerOfTwo(nOvrBlockSize) )\n    {\n        static bool bHasWarned = false;\n        if( !bHasWarned )\n        {\n            CPLError( CE_Warning, CPLE_NotSupported,\n                      \"Wrong value for GDAL_TIFF_OVR_BLOCKSIZE : %s. \"\n                      \"Should be a power of 2 between 64 and 4096. \"\n                      \"Defaulting to 128\",\n                      pszVal );\n            bHasWarned = true;\n        }\n        nOvrBlockSize = 128;\n    }\n\n    *pnBlockXSize = nOvrBlockSize;\n    *pnBlockYSize = nOvrBlockSize;\n}\n\nenum\n{\n    ENDIANNESS_NATIVE,\n    ENDIANNESS_LITTLE,\n    ENDIANNESS_BIG\n};\n\n/************************************************************************/\n/* ==================================================================== */\n/*                          GTiffDataset                                */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffBitmapBand;\nclass GTiffDataset;\nclass GTiffJPEGOverviewBand;\nclass GTiffJPEGOverviewDS;\nclass GTiffRasterBand;\nclass GTiffRGBABand;\n\ntypedef enum\n{\n    VIRTUAL_MEM_IO_NO,\n    VIRTUAL_MEM_IO_YES,\n    VIRTUAL_MEM_IO_IF_ENOUGH_RAM\n} VirtualMemIOEnum;\n\n#if !defined(__MINGW32__)\nnamespace {\n#endif\ntypedef struct\n{\n    GTiffDataset *poDS;\n    bool          bTIFFIsBigEndian;\n    char         *pszTmpFilename;\n    int           nHeight;\n    uint16        nPredictor;\n    GByte        *pabyBuffer;\n    int           nBufferSize;\n    int           nStripOrTile;\n\n    GByte        *pabyCompressedBuffer;  // Owned by pszTmpFilename.\n    int           nCompressedBufferSize;\n    bool          bReady;\n} GTiffCompressionJob;\n#if !defined(__MINGW32__)\n}\n#endif\n\nclass GTiffDataset final : public GDALPamDataset\n{\n    CPL_DISALLOW_COPY_ASSIGN(GTiffDataset)\n\n    friend class GTiffBitmapBand;\n    friend class GTiffJPEGOverviewDS;\n    friend class GTiffJPEGOverviewBand;\n    friend class GTiffOddBitsBand;\n    friend class GTiffRasterBand;\n    friend class GTiffRGBABand;\n    friend class GTiffSplitBand;\n    friend class GTiffSplitBitmapBand;\n\n    friend void  GTIFFSetJpegQuality( GDALDatasetH hGTIFFDS, int nJpegQuality );\n    friend void  GTIFFSetJpegTablesMode( GDALDatasetH hGTIFFDS, int nJpegTablesMode );\n\n    TIFF       *hTIFF;\n    VSILFILE   *fpL;\n#if defined(INTERNAL_LIBTIFF) && defined(DEFER_STRILE_LOAD)\n    uint32      nStripArrayAlloc;\n    vsi_l_offset m_nFileSize; // 0 when unknown, only valid in GA_ReadOnly mode\n#endif\n\n    bool        bStreamingIn;\n\n    bool        bStreamingOut;\n    CPLString   osTmpFilename{};\n    VSILFILE*   fpToWrite;\n    int         nLastWrittenBlockId;\n\n    GTiffDataset **ppoActiveDSRef;\n    GTiffDataset *poActiveDS;  // Only used in actual base.\n\n    bool        bScanDeferred;\n    void        ScanDirectories();\n\n    toff_t      nDirOffset;\n    bool        bBase;\n    // Useful for closing TIFF handle opened by GTIFF_DIR:\n    bool        bCloseTIFFHandle;\n\n    uint16      nPlanarConfig;\n    uint16      nSamplesPerPixel;\n    uint16      nBitsPerSample;\n    uint32      nRowsPerStrip;\n    uint16      nPhotometric;\n    uint16      nSampleFormat;\n    uint16      nCompression;\n\n    int         nBlocksPerBand;\n\n    int         nBlockXSize;\n    int         nBlockYSize;\n\n    int         nLoadedBlock;  // Or tile.\n    bool        bLoadedBlockDirty;\n    GByte       *pabyBlockBuf;\n\n    CPLErr      LoadBlockBuf( int nBlockId, bool bReadFromDisk = true );\n    CPLErr      FlushBlockBuf();\n    bool        bWriteErrorInFlushBlockBuf;\n\n    char        *pszProjection;\n    CPLString   m_osVertUnit{};\n    bool        bLookedForProjection;\n    bool        bLookedForMDAreaOrPoint;\n\n    void        LoadMDAreaOrPoint();\n    void        LookForProjection();\n#ifdef ESRI_BUILD\n    void        AdjustLinearUnit( short UOMLength );\n#endif\n\n    double      adfGeoTransform[6];\n    bool        bGeoTransformValid;\n\n    bool        bTreatAsRGBA;\n    bool        bCrystalized;\n\n    void        Crystalize();  // TODO: Spelling.\n    void        RestoreVolatileParameters(TIFF* l_hTIFF);\n\n    GDALColorTable *poColorTable;\n\n    void        WriteGeoTIFFInfo();\n    bool        SetDirectory( toff_t nDirOffset = 0 );\n\n    int         nOverviewCount;\n    GTiffDataset **papoOverviewDS;\n\n    // If > 0, the implicit JPEG overviews are visible through\n    // GetOverviewCount().\n    int         nJPEGOverviewVisibilityCounter;\n    // Currently visible overviews. Generally == nJPEGOverviewCountOri.\n    int         nJPEGOverviewCount;\n    int         nJPEGOverviewCountOri;  // Size of papoJPEGOverviewDS.\n    GTiffJPEGOverviewDS **papoJPEGOverviewDS;\n    int         GetJPEGOverviewCount();\n\n    int         nGCPCount;\n    GDAL_GCP    *pasGCPList;\n\n    bool        IsBlockAvailable( int nBlockId,\n                                  vsi_l_offset* pnOffset = nullptr,\n                                  vsi_l_offset* pnSize = nullptr,\n                                  bool *pbErrOccurred = nullptr );\n\n    bool        bGeoTIFFInfoChanged;\n    bool        bForceUnsetGTOrGCPs;\n    bool        bForceUnsetProjection;\n\n    bool        bNoDataChanged;\n    bool        bNoDataSet;\n    double      dfNoDataValue;\n\n    bool        bMetadataChanged;\n    bool        bColorProfileMetadataChanged;\n    bool        m_bForceUnsetRPC = false;\n\n    bool        bNeedsRewrite;\n\n    void        ApplyPamInfo();\n    void        PushMetadataToPam();\n\n    GDALMultiDomainMetadata oGTiffMDMD{};\n\n    CPLString   osProfile{};\n    char      **papszCreationOptions;\n\n    bool        bLoadingOtherBands;\n\n    void*        pabyTempWriteBuffer;\n    int          nTempWriteBufferSize;\n    bool         WriteEncodedTile( uint32 tile, GByte* pabyData,\n                                   int bPreserveDataBuffer );\n    bool         WriteEncodedStrip( uint32 strip, GByte* pabyData,\n                                    int bPreserveDataBuffer );\n    template<class T>\n    bool         HasOnlyNoDataT( const T* pBuffer, int nWidth, int nHeight,\n                                int nLineStride, int nComponents ) const;\n    bool         HasOnlyNoData( const void* pBuffer, int nWidth, int nHeight,\n                                int nLineStride, int nComponents );\n    inline bool  IsFirstPixelEqualToNoData( const void* pBuffer );\n\n    GTiffDataset* poMaskDS;\n    GTiffDataset* poBaseDS;\n    bool          bIsOverview_ = false;\n\n    CPLString    osFilename{};\n\n    bool         bWriteEmptyTiles;\n    bool         bFillEmptyTilesAtClosing;\n    void         FillEmptyTiles();\n\n    void         FlushDirectory();\n    CPLErr       CleanOverviews();\n\n    // Used for the all-in-on-strip case.\n    int           nLastLineRead;\n    int           nLastBandRead;\n    bool          bTreatAsSplit;\n    bool          bTreatAsSplitBitmap;\n\n    bool          bClipWarn;\n\n    bool          bIMDRPCMetadataLoaded;\n    char**        papszMetadataFiles;\n    void          LoadMetadata();\n\n    bool          bEXIFMetadataLoaded;\n    void          LoadEXIFMetadata();\n\n    bool          bICCMetadataLoaded;\n    void          LoadICCProfile();\n\n    bool          bHasWarnedDisableAggressiveBandCaching;\n\n    bool          bDontReloadFirstBlock;  // Hack for libtiff 3.X and #3633.\n\n    int           nZLevel;\n    int           nLZMAPreset;\n    int           nZSTDLevel;\n    int           nWebPLevel;\n    bool          bWebPLossless;\n    int           nJpegQuality;\n    int           nJpegTablesMode;\n#if HAVE_LERC\n    double        dfMaxZError = 0.0;\n    uint32        anLercAddCompressionAndVersion[2]{0,0};\n#endif\n\n    bool          bPromoteTo8Bits;\n\n    bool          bDebugDontWriteBlocks;\n\n    CPLErr        RegisterNewOverviewDataset( toff_t nOverviewOffset, int l_nJpegQuality );\n    CPLErr        CreateOverviewsFromSrcOverviews( GDALDataset* poSrcDS );\n    CPLErr        CreateInternalMaskOverviews( int nOvrBlockXSize,\n                                               int nOvrBlockYSize );\n\n    bool          bIsFinalized;\n    int           Finalize();\n\n    bool          bIgnoreReadErrors;\n\n    CPLString     osGeorefFilename{};\n\n    bool          bDirectIO;\n\n    VirtualMemIOEnum eVirtualMemIOUsage;\n    CPLVirtualMem* psVirtualMemIOMapping;\n\n    GTIFFKeysFlavorEnum eGeoTIFFKeysFlavor;\n\n    CPLVirtualMem *pBaseMapping;\n    int            nRefBaseMapping;\n\n    bool           bHasDiscardedLsb;\n    std::vector<int> anMaskLsb{};\n    std::vector<int> anOffsetLsb{};\n    void           DiscardLsb(GByte* pabyBuffer, int nBytes, int iBand) const;\n    void           GetDiscardLsbOption( char** papszOptions );\n\n    CPLWorkerThreadPool *poCompressThreadPool;\n    std::vector<GTiffCompressionJob> asCompressionJobs{};\n    CPLMutex      *hCompressThreadPoolMutex;\n    void           InitCompressionThreads( char** papszOptions );\n    void           InitCreationOrOpenOptions( char** papszOptions );\n    static void    ThreadCompressionFunc( void* pData );\n    void           WaitCompletionForBlock( int nBlockId );\n    void           WriteRawStripOrTile( int nStripOrTile,\n                                        GByte* pabyCompressedBuffer,\n                                        int nCompressedBufferSize );\n    bool           SubmitCompressionJob( int nStripOrTile, GByte* pabyData,\n                                         int cc, int nHeight) ;\n\n    int            GuessJPEGQuality( bool& bOutHasQuantizationTable,\n                                     bool& bOutHasHuffmanTable );\n\n    void           SetJPEGQualityAndTablesModeFromFile();\n\n    int            DirectIO( GDALRWFlag eRWFlag,\n                             int nXOff, int nYOff, int nXSize, int nYSize,\n                             void * pData, int nBufXSize, int nBufYSize,\n                             GDALDataType eBufType,\n                             int nBandCount, int *panBandMap,\n                             GSpacing nPixelSpace, GSpacing nLineSpace,\n                             GSpacing nBandSpace,\n                             GDALRasterIOExtraArg* psExtraArg );\n\n    int            VirtualMemIO( GDALRWFlag eRWFlag,\n                                 int nXOff, int nYOff, int nXSize, int nYSize,\n                                 void * pData, int nBufXSize, int nBufYSize,\n                                 GDALDataType eBufType,\n                                 int nBandCount, int *panBandMap,\n                                 GSpacing nPixelSpace, GSpacing nLineSpace,\n                                 GSpacing nBandSpace,\n                                 GDALRasterIOExtraArg* psExtraArg );\n\n    GByte          *m_pTempBufferForCommonDirectIO;\n    size_t          m_nTempBufferForCommonDirectIOSize;\n    template<class FetchBuffer> CPLErr CommonDirectIO(\n        FetchBuffer& oFetcher,\n        int nXOff, int nYOff, int nXSize, int nYSize,\n        void * pData, int nBufXSize, int nBufYSize,\n        GDALDataType eBufType,\n        int nBandCount, int *panBandMap,\n        GSpacing nPixelSpace, GSpacing nLineSpace,\n        GSpacing nBandSpace );\n\n    bool        m_bReadGeoTransform;\n    bool        m_bLoadPam;\n    void        LoadGeoreferencingAndPamIfNeeded();\n\n    bool        m_bHasGotSiblingFiles;\n    char      **GetSiblingFiles();\n\n    void        IdentifyAuthorizedGeoreferencingSources();\n    bool        m_bHasIdentifiedAuthorizedGeoreferencingSources;\n    int         m_nPAMGeorefSrcIndex;\n    int         m_nINTERNALGeorefSrcIndex;\n    int         m_nTABFILEGeorefSrcIndex;\n    int         m_nWORLDFILEGeorefSrcIndex;\n    int         m_nGeoTransformGeorefSrcIndex;\n\n    void        FlushCacheInternal( bool bFlushDirectory );\n\n    int         m_nHasOptimizedReadMultiRange = -1;\n    int         HasOptimizedReadMultiRange();\n\n  protected:\n    virtual int         CloseDependentDatasets() override;\n\n  public:\n             GTiffDataset();\n    virtual ~GTiffDataset();\n\n    virtual const char *GetProjectionRef() override;\n    virtual CPLErr SetProjection( const char * ) override;\n    virtual CPLErr GetGeoTransform( double * ) override;\n    virtual CPLErr SetGeoTransform( double * ) override;\n\n    virtual int    GetGCPCount() override;\n    virtual const char *GetGCPProjection() override;\n    virtual const GDAL_GCP *GetGCPs() override;\n    CPLErr         SetGCPs( int, const GDAL_GCP *, const char * ) override;\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              int nBandCount, int *panBandMap,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GSpacing nBandSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override;\n    virtual char **GetFileList() override;\n\n    virtual CPLErr IBuildOverviews( const char *, int, int *, int, int *,\n                                    GDALProgressFunc, void * ) override;\n\n    CPLErr         OpenOffset( TIFF *, GTiffDataset **ppoActiveDSRef,\n                               toff_t nDirOffset, bool bBaseIn, GDALAccess,\n                               bool bAllowRGBAInterface = true,\n                               bool bReadGeoTransform = false );\n\n    static GDALDataset *OpenDir( GDALOpenInfo * );\n    static GDALDataset *Open( GDALOpenInfo * );\n    static int          Identify( GDALOpenInfo * );\n    static GDALDataset *Create( const char * pszFilename,\n                                int nXSize, int nYSize, int nBands,\n                                GDALDataType eType, char ** papszParmList );\n    static GDALDataset *CreateCopy( const char * pszFilename,\n                                    GDALDataset *poSrcDS,\n                                    int bStrict, char ** papszOptions,\n                                    GDALProgressFunc pfnProgress,\n                                    void * pProgressData );\n    virtual void    FlushCache() override;\n\n    virtual char  **GetMetadataDomainList() override;\n    virtual CPLErr  SetMetadata( char **, const char * = \"\" ) override;\n    virtual char  **GetMetadata( const char * pszDomain = \"\" ) override;\n    virtual CPLErr  SetMetadataItem( const char*, const char*,\n                                     const char* = \"\" ) override;\n    virtual const char *GetMetadataItem( const char * pszName,\n                                         const char * pszDomain = \"\" ) override;\n    virtual void   *GetInternalHandle( const char * ) override;\n\n    virtual CPLErr          CreateMaskBand( int nFlags ) override;\n\n    // Only needed by createcopy and close code.\n    static void     WriteRPC( GDALDataset *, TIFF *, int, const char *,\n                              const char *, char **,\n                              bool bWriteOnlyInPAMIfNeeded = false );\n    static bool     WriteMetadata( GDALDataset *, TIFF *, bool, const char *,\n                                   const char *, char **,\n                                   bool bExcludeRPBandIMGFileWriting = false );\n    static void     WriteNoDataValue( TIFF *, double );\n    static void     UnsetNoDataValue( TIFF * );\n\n    static TIFF *   CreateLL( const char * pszFilename,\n                              int nXSize, int nYSize, int nBands,\n                              GDALDataType eType,\n                              double dfExtraSpaceForOverviews,\n                              char **papszParmList,\n                              VSILFILE** pfpL,\n                              CPLString& osTmpFilename );\n\n    CPLErr   WriteEncodedTileOrStrip( uint32 tile_or_strip, void* data,\n                                      int bPreserveDataBuffer );\n\n    static void SaveICCProfile( GTiffDataset *pDS, TIFF *hTIFF,\n                                char **papszParmList, uint32 nBitsPerSample );\n\n    static bool HasVerticalCS(const char* pszProjectionIn);\n};\n\n/************************************************************************/\n/* ==================================================================== */\n/*                        GTiffJPEGOverviewDS                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffJPEGOverviewDS final : public GDALDataset\n{\n    CPL_DISALLOW_COPY_ASSIGN(GTiffJPEGOverviewDS)\n\n    friend class GTiffJPEGOverviewBand;\n    GTiffDataset* poParentDS;\n    int nOverviewLevel;\n\n    int        nJPEGTableSize;\n    GByte     *pabyJPEGTable;\n    CPLString  osTmpFilenameJPEGTable{};\n\n    CPLString    osTmpFilename{};\n    GDALDataset* poJPEGDS;\n    // Valid block id of the parent DS that match poJPEGDS.\n    int          nBlockId;\n\n  public:\n    GTiffJPEGOverviewDS( GTiffDataset* poParentDS, int nOverviewLevel,\n                         const void* pJPEGTable, int nJPEGTableSize );\n    virtual ~GTiffJPEGOverviewDS();\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              int nBandCount, int *panBandMap,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GSpacing nBandSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override;\n};\n\nclass GTiffJPEGOverviewBand final : public GDALRasterBand\n{\n  public:\n    GTiffJPEGOverviewBand( GTiffJPEGOverviewDS* poDS, int nBand );\n    virtual ~GTiffJPEGOverviewBand() {}\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                        GTiffJPEGOverviewDS()                         */\n/************************************************************************/\n\nGTiffJPEGOverviewDS::GTiffJPEGOverviewDS( GTiffDataset* poParentDSIn,\n                                          int nOverviewLevelIn,\n                                          const void* pJPEGTable,\n                                          int nJPEGTableSizeIn ) :\n    poParentDS(poParentDSIn),\n    nOverviewLevel(nOverviewLevelIn),\n    nJPEGTableSize(nJPEGTableSizeIn),\n    pabyJPEGTable(nullptr),\n    poJPEGDS(nullptr),\n    nBlockId(-1)\n{\n    osTmpFilenameJPEGTable.Printf(\"/vsimem/jpegtable_%p\", this);\n\n    const GByte abyAdobeAPP14RGB[] = {\n        0xFF, 0xEE, 0x00, 0x0E, 0x41, 0x64, 0x6F, 0x62, 0x65, 0x00,\n        0x64, 0x00, 0x00, 0x00, 0x00, 0x00 };\n    const bool bAddAdobe =\n        poParentDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n        poParentDS->nPhotometric != PHOTOMETRIC_YCBCR &&\n        poParentDS->nBands == 3;\n    pabyJPEGTable =\n        static_cast<GByte*>( CPLMalloc(\n            nJPEGTableSize + (bAddAdobe ? sizeof(abyAdobeAPP14RGB) : 0)) );\n    memcpy(pabyJPEGTable, pJPEGTable, nJPEGTableSize);\n    if( bAddAdobe )\n    {\n        memcpy( pabyJPEGTable + nJPEGTableSize, abyAdobeAPP14RGB,\n                sizeof(abyAdobeAPP14RGB) );\n        nJPEGTableSize += sizeof(abyAdobeAPP14RGB);\n    }\n    CPL_IGNORE_RET_VAL(\n        VSIFCloseL(\n            VSIFileFromMemBuffer(\n                osTmpFilenameJPEGTable, pabyJPEGTable, nJPEGTableSize, TRUE )));\n\n    const int nScaleFactor = 1 << nOverviewLevel;\n    nRasterXSize = (poParentDS->nRasterXSize + nScaleFactor - 1) / nScaleFactor;\n    nRasterYSize = (poParentDS->nRasterYSize + nScaleFactor - 1) / nScaleFactor;\n\n    for( int i = 1; i <= poParentDS->nBands; ++i )\n        SetBand(i, new GTiffJPEGOverviewBand(this, i));\n\n    SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    if( poParentDS->nPhotometric == PHOTOMETRIC_YCBCR )\n        SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\", \"IMAGE_STRUCTURE\" );\n    else\n        SetMetadataItem( \"COMPRESSION\", \"JPEG\", \"IMAGE_STRUCTURE\" );\n}\n\n/************************************************************************/\n/*                       ~GTiffJPEGOverviewDS()                         */\n/************************************************************************/\n\nGTiffJPEGOverviewDS::~GTiffJPEGOverviewDS()\n{\n    if( poJPEGDS != nullptr )\n        GDALClose( poJPEGDS );\n    VSIUnlink(osTmpFilenameJPEGTable);\n    if( !osTmpFilename.empty() )\n        VSIUnlink(osTmpFilename);\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffJPEGOverviewDS::IRasterIO(\n    GDALRWFlag eRWFlag,\n    int nXOff, int nYOff, int nXSize, int nYSize,\n    void * pData, int nBufXSize, int nBufYSize,\n    GDALDataType eBufType,\n    int nBandCount, int *panBandMap,\n    GSpacing nPixelSpace, GSpacing nLineSpace,\n    GSpacing nBandSpace,\n    GDALRasterIOExtraArg* psExtraArg )\n\n{\n    // For non-single strip JPEG-IN-TIFF, the block based strategy will\n    // be the most efficient one, to avoid decompressing the JPEG content\n    // for each requested band.\n    if( nBandCount > 1 && poParentDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n        (poParentDS->nBlockXSize < poParentDS->nRasterXSize ||\n         poParentDS->nBlockYSize > 1) )\n    {\n        return BlockBasedRasterIO( eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                                   pData, nBufXSize, nBufYSize,\n                                   eBufType, nBandCount, panBandMap,\n                                   nPixelSpace, nLineSpace, nBandSpace,\n                                   psExtraArg );\n    }\n\n    return GDALDataset::IRasterIO(\n        eRWFlag, nXOff, nYOff, nXSize, nYSize,\n        pData, nBufXSize, nBufYSize, eBufType,\n        nBandCount, panBandMap, nPixelSpace, nLineSpace, nBandSpace,\n        psExtraArg );\n}\n\n/************************************************************************/\n/*                        GTiffJPEGOverviewBand()                       */\n/************************************************************************/\n\nGTiffJPEGOverviewBand::GTiffJPEGOverviewBand( GTiffJPEGOverviewDS* poDSIn,\n                                              int nBandIn )\n{\n    poDS = poDSIn;\n    nBand = nBandIn;\n    eDataType =\n        poDSIn->poParentDS->GetRasterBand(nBandIn)->GetRasterDataType();\n    poDSIn->poParentDS->GetRasterBand(nBandIn)->\n        GetBlockSize(&nBlockXSize, &nBlockYSize);\n    const int nScaleFactor = 1 << poDSIn->nOverviewLevel;\n    nBlockXSize = (nBlockXSize + nScaleFactor - 1) / nScaleFactor;\n    nBlockYSize = (nBlockYSize + nScaleFactor - 1) / nScaleFactor;\n}\n\n/************************************************************************/\n/*                          IReadBlock()                                */\n/************************************************************************/\n\nCPLErr GTiffJPEGOverviewBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                          void *pImage )\n{\n    GTiffJPEGOverviewDS* poGDS = cpl::down_cast<GTiffJPEGOverviewDS *>(poDS);\n\n    // Compute the source block ID.\n    int nBlockId = 0;\n    int nParentBlockXSize, nParentBlockYSize;\n    poGDS->poParentDS->GetRasterBand(1)->\n        GetBlockSize(&nParentBlockXSize, &nParentBlockYSize);\n    const bool bIsSingleStripAsSplit = (nParentBlockYSize == 1 &&\n                           poGDS->poParentDS->nBlockYSize != nParentBlockYSize);\n    if( !bIsSingleStripAsSplit )\n    {\n        int l_nBlocksPerRow = DIV_ROUND_UP(poGDS->poParentDS->nRasterXSize,\n                                               poGDS->poParentDS->nBlockXSize);\n        nBlockId = nBlockYOff * l_nBlocksPerRow + nBlockXOff;\n    }\n    if( poGDS->poParentDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        nBlockId += (nBand-1) * poGDS->poParentDS->nBlocksPerBand;\n    }\n\n    if( !poGDS->poParentDS->SetDirectory() )\n        return CE_Failure;\n\n    // Make sure it is available.\n    const int nDataTypeSize = GDALGetDataTypeSizeBytes(eDataType);\n    vsi_l_offset nOffset = 0;\n    vsi_l_offset nByteCount = 0;\n    bool bErrOccurred = false;\n    if( !poGDS->poParentDS->IsBlockAvailable(nBlockId, &nOffset, &nByteCount, &bErrOccurred) )\n    {\n        memset(pImage, 0, nBlockXSize * nBlockYSize * nDataTypeSize );\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n    const int nScaleFactor = 1 << poGDS->nOverviewLevel;\n    if( poGDS->poJPEGDS == nullptr || nBlockId != poGDS->nBlockId )\n    {\n        if( nByteCount < 2 )\n            return CE_Failure;\n        nOffset += 2;  // Skip leading 0xFF 0xF8.\n        nByteCount -= 2;\n\n        // Special case for last strip that might be smaller than other strips\n        // In which case we must invalidate the dataset.\n        TIFF* hTIFF = poGDS->poParentDS->hTIFF;\n        if( !TIFFIsTiled( hTIFF ) && !bIsSingleStripAsSplit &&\n            (nBlockYOff + 1 ==\n                 DIV_ROUND_UP( poGDS->poParentDS->nRasterYSize,\n                               poGDS->poParentDS->nBlockYSize ) ||\n             (poGDS->poJPEGDS != nullptr &&\n              poGDS->poJPEGDS->GetRasterYSize() !=\n              nBlockYSize * nScaleFactor)) )\n        {\n            if( poGDS->poJPEGDS != nullptr )\n                GDALClose( poGDS->poJPEGDS );\n            poGDS->poJPEGDS = nullptr;\n        }\n\n        CPLString osFileToOpen;\n        poGDS->osTmpFilename.Printf(\"/vsimem/sparse_%p\", poGDS);\n        VSILFILE* fp = VSIFOpenL(poGDS->osTmpFilename, \"wb+\");\n\n        // If the size of the JPEG strip/tile is small enough, we will\n        // read it from the TIFF file and forge a in-memory JPEG file with\n        // the JPEG table followed by the JPEG data.\n        const bool bInMemoryJPEGFile = nByteCount < 256 * 256;\n        if( bInMemoryJPEGFile )\n        {\n            // If the previous file was opened as a /vsisparse/, must re-open.\n            if( poGDS->poJPEGDS != nullptr &&\n                STARTS_WITH(poGDS->poJPEGDS->GetDescription(), \"/vsisparse/\") )\n            {\n                GDALClose( poGDS->poJPEGDS );\n                poGDS->poJPEGDS = nullptr;\n            }\n            osFileToOpen = poGDS->osTmpFilename;\n\n            bool bError = false;\n            if( VSIFSeekL(fp, poGDS->nJPEGTableSize + nByteCount - 1, SEEK_SET)\n                != 0 )\n                bError = true;\n            char ch = 0;\n            if( !bError && VSIFWriteL(&ch, 1, 1, fp) != 1 )\n                bError = true;\n            GByte* pabyBuffer =\n                VSIGetMemFileBuffer( poGDS->osTmpFilename, nullptr, FALSE);\n            memcpy(pabyBuffer, poGDS->pabyJPEGTable, poGDS->nJPEGTableSize);\n            VSILFILE* fpTIF = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n            if( !bError && VSIFSeekL(fpTIF, nOffset, SEEK_SET) != 0 )\n                bError = true;\n            if( VSIFReadL( pabyBuffer + poGDS->nJPEGTableSize,\n                           static_cast<size_t>(nByteCount), 1, fpTIF) != 1 )\n                bError = true;\n            if( bError )\n            {\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n                return CE_Failure;\n            }\n        }\n        else\n        {\n            // If the JPEG strip/tile is too big (e.g. a single-strip\n            // JPEG-in-TIFF), we will use /vsisparse mechanism to make a\n            // fake JPEG file.\n\n            // Always re-open.\n            GDALClose( poGDS->poJPEGDS );\n            poGDS->poJPEGDS = nullptr;\n\n            osFileToOpen =\n                CPLSPrintf(\"/vsisparse/%s\", poGDS->osTmpFilename.c_str());\n\n            if( VSIFPrintfL(\n                    fp,\n                    \"<VSISparseFile><SubfileRegion>\"\n                    \"<Filename relative='0'>%s</Filename>\"\n                    \"<DestinationOffset>0</DestinationOffset>\"\n                    \"<SourceOffset>0</SourceOffset>\"\n                    \"<RegionLength>%d</RegionLength>\"\n                    \"</SubfileRegion>\"\n                    \"<SubfileRegion>\"\n                    \"<Filename relative='0'>%s</Filename>\"\n                    \"<DestinationOffset>%d</DestinationOffset>\"\n                    \"<SourceOffset>\" CPL_FRMT_GUIB \"</SourceOffset>\"\n                    \"<RegionLength>\" CPL_FRMT_GUIB \"</RegionLength>\"\n                    \"</SubfileRegion></VSISparseFile>\",\n                    poGDS->osTmpFilenameJPEGTable.c_str(),\n                    static_cast<int>(poGDS->nJPEGTableSize),\n                    poGDS->poParentDS->GetDescription(),\n                    static_cast<int>(poGDS->nJPEGTableSize),\n                    nOffset,\n                    nByteCount) < 0 )\n            {\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n                return CE_Failure;\n            }\n        }\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n\n        if( poGDS->poJPEGDS == nullptr )\n        {\n            const char* apszDrivers[] = { \"JPEG\", nullptr };\n\n            CPLString osOldVal;\n            if( poGDS->poParentDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n                poGDS->nBands == 4 )\n            {\n                osOldVal =\n                    CPLGetThreadLocalConfigOption(\"GDAL_JPEG_TO_RGB\", \"\");\n                CPLSetThreadLocalConfigOption(\"GDAL_JPEG_TO_RGB\", \"NO\");\n            }\n\n            poGDS->poJPEGDS =\n                static_cast<GDALDataset *>( GDALOpenEx(\n                    osFileToOpen,\n                    GDAL_OF_RASTER | GDAL_OF_INTERNAL,\n                    apszDrivers, nullptr, nullptr) );\n\n            if( poGDS->poJPEGDS != nullptr )\n            {\n                // Force all implicit overviews to be available, even for\n                // small tiles.\n                CPLSetThreadLocalConfigOption( \"JPEG_FORCE_INTERNAL_OVERVIEWS\",\n                                               \"YES\");\n                GDALGetOverviewCount(GDALGetRasterBand(poGDS->poJPEGDS, 1));\n                CPLSetThreadLocalConfigOption( \"JPEG_FORCE_INTERNAL_OVERVIEWS\",\n                                               nullptr);\n\n                poGDS->nBlockId = nBlockId;\n            }\n\n            if( poGDS->poParentDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n                poGDS->nBands == 4 )\n            {\n                CPLSetThreadLocalConfigOption(\n                    \"GDAL_JPEG_TO_RGB\",\n                    !osOldVal.empty() ? osOldVal.c_str() : nullptr );\n            }\n        }\n        else\n        {\n            // Trick: we invalidate the JPEG dataset to force a reload\n            // of the new content.\n            CPLErrorReset();\n            poGDS->poJPEGDS->FlushCache();\n            if( CPLGetLastErrorNo() != 0 )\n            {\n                GDALClose( poGDS->poJPEGDS );\n                poGDS->poJPEGDS = nullptr;\n                return CE_Failure;\n            }\n            poGDS->nBlockId = nBlockId;\n        }\n    }\n\n    CPLErr eErr = CE_Failure;\n    if( poGDS->poJPEGDS )\n    {\n        GDALDataset* l_poDS = poGDS->poJPEGDS;\n\n        int nReqXOff = 0;\n        int nReqYOff = 0;\n        int nReqXSize = 0;\n        int nReqYSize = 0;\n        if( bIsSingleStripAsSplit )\n        {\n            nReqYOff = nBlockYOff * nScaleFactor;\n            nReqXSize = l_poDS->GetRasterXSize();\n            nReqYSize = nScaleFactor;\n        }\n        else\n        {\n            if( nBlockXSize == poGDS->GetRasterXSize() )\n            {\n                nReqXSize = l_poDS->GetRasterXSize();\n            }\n            else\n            {\n                nReqXSize = nBlockXSize * nScaleFactor;\n            }\n            nReqYSize = nBlockYSize * nScaleFactor;\n        }\n        int nBufXSize = nBlockXSize;\n        int nBufYSize = nBlockYSize;\n        if( nBlockXOff == DIV_ROUND_UP(poGDS->poParentDS->nRasterXSize,\n                                       poGDS->poParentDS->nBlockXSize) - 1 )\n        {\n            nReqXSize = poGDS->poParentDS->nRasterXSize -\n                                nBlockXOff * poGDS->poParentDS->nBlockXSize;\n        }\n        if( nReqXOff + nReqXSize > l_poDS->GetRasterXSize() )\n        {\n            nReqXSize = l_poDS->GetRasterXSize() - nReqXOff;\n        }\n        if( !bIsSingleStripAsSplit &&\n            nBlockYOff == DIV_ROUND_UP(poGDS->poParentDS->nRasterYSize,\n                                       poGDS->poParentDS->nBlockYSize) - 1 )\n        {\n            nReqYSize = poGDS->poParentDS->nRasterYSize -\n                                nBlockYOff * poGDS->poParentDS->nBlockYSize;\n        }\n        if( nReqYOff + nReqYSize > l_poDS->GetRasterYSize() )\n        {\n            nReqYSize = l_poDS->GetRasterYSize() - nReqYOff;\n        }\n        if( nBlockXOff * nBlockXSize > poGDS->GetRasterXSize() - nBufXSize )\n        {\n            memset(pImage, 0, nBlockXSize * nBlockYSize * nDataTypeSize);\n            nBufXSize = poGDS->GetRasterXSize() - nBlockXOff * nBlockXSize;\n        }\n        if( nBlockYOff * nBlockYSize > poGDS->GetRasterYSize() - nBufYSize )\n        {\n            memset(pImage, 0, nBlockXSize * nBlockYSize * nDataTypeSize);\n            nBufYSize = poGDS->GetRasterYSize() - nBlockYOff * nBlockYSize;\n        }\n\n        const int nSrcBand =\n            poGDS->poParentDS->nPlanarConfig == PLANARCONFIG_SEPARATE ?\n            1 : nBand;\n        if( nSrcBand <= l_poDS->GetRasterCount() )\n        {\n            eErr = l_poDS->GetRasterBand(nSrcBand)->RasterIO(GF_Read,\n                                 nReqXOff, nReqYOff, nReqXSize, nReqYSize,\n                                 pImage,\n                                 nBufXSize, nBufYSize, eDataType,\n                                 0, nBlockXSize * nDataTypeSize, nullptr );\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                        GTIFFSetJpegQuality()                         */\n/* Called by GTIFFBuildOverviews() to set the jpeg quality on the IFD   */\n/* of the .ovr file.                                                    */\n/************************************************************************/\n\nvoid GTIFFSetJpegQuality( GDALDatasetH hGTIFFDS, int nJpegQuality )\n{\n    CPLAssert(\n        EQUAL(GDALGetDriverShortName(GDALGetDatasetDriver(hGTIFFDS)), \"GTIFF\"));\n\n    GTiffDataset* const poDS = static_cast<GTiffDataset *>(hGTIFFDS);\n    poDS->nJpegQuality = nJpegQuality;\n\n    poDS->ScanDirectories();\n\n    for( int i = 0; i < poDS->nOverviewCount; ++i )\n        poDS->papoOverviewDS[i]->nJpegQuality = nJpegQuality;\n}\n\n/************************************************************************/\n/*                     GTIFFSetJpegTablesMode()                         */\n/* Called by GTIFFBuildOverviews() to set the jpeg tables mode on the   */\n/* of the .ovr file.                                                    */\n/************************************************************************/\n\nvoid GTIFFSetJpegTablesMode( GDALDatasetH hGTIFFDS, int nJpegTablesMode )\n{\n    CPLAssert(\n        EQUAL(GDALGetDriverShortName(GDALGetDatasetDriver(hGTIFFDS)), \"GTIFF\"));\n\n    GTiffDataset* const poDS = static_cast<GTiffDataset *>(hGTIFFDS);\n    poDS->nJpegTablesMode = nJpegTablesMode;\n\n    poDS->ScanDirectories();\n\n    for( int i = 0; i < poDS->nOverviewCount; ++i )\n        poDS->papoOverviewDS[i]->nJpegTablesMode = nJpegTablesMode;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                            GTiffRasterBand                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRasterBand : public GDALPamRasterBand\n{\n    CPL_DISALLOW_COPY_ASSIGN(GTiffRasterBand)\n\n    friend class GTiffDataset;\n\n    GDALColorInterp    eBandInterp;\n\n    bool               bHaveOffsetScale;\n    double             dfOffset;\n    double             dfScale;\n    CPLString          osUnitType{};\n    CPLString          osDescription{};\n\n    int                DirectIO( GDALRWFlag eRWFlag,\n                                 int nXOff, int nYOff, int nXSize, int nYSize,\n                                 void * pData, int nBufXSize, int nBufYSize,\n                                 GDALDataType eBufType,\n                                 GSpacing nPixelSpace, GSpacing nLineSpace,\n                                 GDALRasterIOExtraArg* psExtraArg );\n\n    std::set<GTiffRasterBand **> aSetPSelf{};\n    static void     DropReferenceVirtualMem( void* pUserData );\n    CPLVirtualMem * GetVirtualMemAutoInternal( GDALRWFlag eRWFlag,\n                                               int *pnPixelSpace,\n                                               GIntBig *pnLineSpace,\n                                               char **papszOptions );\n\n    void*           CacheMultiRange( int nXOff, int nYOff,\n                                     int nXSize, int nYSize,\n                                     int nBufXSize, int nBufYSize,\n                                     GDALRasterIOExtraArg* psExtraArg );\n\nprotected:\n    GTiffDataset       *poGDS;\n    GDALMultiDomainMetadata oGTiffMDMD{};\n\n    bool               bNoDataSet;\n    double             dfNoDataValue;\n\n    void NullBlock( void *pData );\n    CPLErr FillCacheForOtherBands( int nBlockXOff, int nBlockYOff );\n\npublic:\n             GTiffRasterBand( GTiffDataset *, int );\n    virtual ~GTiffRasterBand();\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override final;\n\n    virtual const char *GetDescription() const override final;\n    virtual void        SetDescription( const char * ) override final;\n\n    virtual GDALColorInterp GetColorInterpretation() override /*final*/;\n    virtual GDALColorTable *GetColorTable() override /*final*/;\n    virtual CPLErr          SetColorTable( GDALColorTable * ) override final;\n    virtual double          GetNoDataValue( int * ) override final;\n    virtual CPLErr          SetNoDataValue( double ) override final;\n    virtual CPLErr DeleteNoDataValue() override final;\n\n    virtual double GetOffset( int *pbSuccess = nullptr ) override final;\n    virtual CPLErr SetOffset( double dfNewValue ) override final;\n    virtual double GetScale( int *pbSuccess = nullptr ) override final;\n    virtual CPLErr SetScale( double dfNewValue ) override final;\n    virtual const char* GetUnitType() override final;\n    virtual CPLErr SetUnitType( const char *pszNewValue ) override final;\n    virtual CPLErr SetColorInterpretation( GDALColorInterp ) override final;\n\n    virtual char      **GetMetadataDomainList() override final;\n    virtual CPLErr  SetMetadata( char **, const char * = \"\" ) override final;\n    virtual char  **GetMetadata( const char * pszDomain = \"\" ) override final;\n    virtual CPLErr  SetMetadataItem( const char*, const char*,\n                                     const char* = \"\" ) override final;\n    virtual const char *GetMetadataItem(\n        const char * pszName, const char * pszDomain = \"\" ) override final;\n    virtual int    GetOverviewCount()  override final;\n    virtual GDALRasterBand *GetOverview( int ) override final;\n\n    virtual GDALRasterBand *GetMaskBand() override final;\n    virtual int             GetMaskFlags() override final;\n    virtual CPLErr          CreateMaskBand( int nFlags )  override final;\n\n    virtual CPLVirtualMem  *GetVirtualMemAuto( GDALRWFlag eRWFlag,\n                                               int *pnPixelSpace,\n                                               GIntBig *pnLineSpace,\n                                               char **papszOptions )  override final;\n\n    GDALRasterAttributeTable* GetDefaultRAT() override final;\n    virtual CPLErr  GetHistogram(\n        double dfMin, double dfMax,\n        int nBuckets, GUIntBig * panHistogram,\n        int bIncludeOutOfRange, int bApproxOK,\n        GDALProgressFunc, void *pProgressData )  override final;\n\n    virtual CPLErr GetDefaultHistogram( double *pdfMin, double *pdfMax,\n                                        int *pnBuckets,\n                                        GUIntBig ** ppanHistogram,\n                                        int bForce,\n                                        GDALProgressFunc,\n                                        void *pProgressData)  override final;\n};\n\n/************************************************************************/\n/*                           GTiffRasterBand()                          */\n/************************************************************************/\n\nGTiffRasterBand::GTiffRasterBand( GTiffDataset *poDSIn, int nBandIn ) :\n    eBandInterp(GCI_Undefined),\n    bHaveOffsetScale(false),\n    dfOffset(0.0),\n    dfScale(1.0),\n    poGDS(poDSIn),\n    bNoDataSet(false),\n    dfNoDataValue(-9999.0)\n{\n    poDS = poDSIn;\n    nBand = nBandIn;\n\n/* -------------------------------------------------------------------- */\n/*      Get the GDAL data type.                                         */\n/* -------------------------------------------------------------------- */\n    const uint16 nBitsPerSample = poGDS->nBitsPerSample;\n    const uint16 nSampleFormat = poGDS->nSampleFormat;\n\n    eDataType = GDT_Unknown;\n\n    if( nBitsPerSample <= 8 )\n    {\n        eDataType = GDT_Byte;\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            oGTiffMDMD.SetMetadataItem( \"PIXELTYPE\", \"SIGNEDBYTE\",\n                                        \"IMAGE_STRUCTURE\" );\n    }\n    else if( nBitsPerSample <= 16 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int16;\n        else\n            eDataType = GDT_UInt16;\n    }\n    else if( nBitsPerSample == 32 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt16;\n        else if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float32;\n        else if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int32;\n        else\n            eDataType = GDT_UInt32;\n    }\n    else if( nBitsPerSample == 64 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float64;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat32;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt32;\n    }\n    else if( nBitsPerSample == 128 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat64;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try to work out band color interpretation.                      */\n/* -------------------------------------------------------------------- */\n    bool bLookForExtraSamples = false;\n\n    if( poGDS->poColorTable != nullptr && nBand == 1 )\n    {\n        eBandInterp = GCI_PaletteIndex;\n    }\n    else if( poGDS->nPhotometric == PHOTOMETRIC_RGB\n             || (poGDS->nPhotometric == PHOTOMETRIC_YCBCR\n                 && poGDS->nCompression == COMPRESSION_JPEG\n                 && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                    \"YES\") )) )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_RedBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_GreenBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_BlueBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( poGDS->nPhotometric == PHOTOMETRIC_YCBCR )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_YCbCr_YBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_YCbCr_CbBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_YCbCr_CrBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( poGDS->nPhotometric == PHOTOMETRIC_SEPARATED )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_CyanBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_MagentaBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_YellowBand;\n        else if( nBand == 4 )\n            eBandInterp = GCI_BlackBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( poGDS->nPhotometric == PHOTOMETRIC_MINISBLACK && nBand == 1 )\n    {\n        eBandInterp = GCI_GrayIndex;\n    }\n    else\n    {\n        bLookForExtraSamples = true;\n    }\n\n    if( bLookForExtraSamples )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n\n        if( TIFFGetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            const int nBaseSamples = poGDS->nSamplesPerPixel - count;\n            const int nExpectedBaseSamples =\n                (poGDS->nPhotometric == PHOTOMETRIC_MINISBLACK) ? 1 :\n                (poGDS->nPhotometric == PHOTOMETRIC_MINISWHITE) ? 1 :\n                (poGDS->nPhotometric == PHOTOMETRIC_RGB) ? 3 :\n                (poGDS->nPhotometric == PHOTOMETRIC_YCBCR) ? 3 :\n                (poGDS->nPhotometric == PHOTOMETRIC_SEPARATED) ? 4 : 0;\n\n            if( nExpectedBaseSamples > 0 &&\n                nBand == nExpectedBaseSamples + 1 &&\n                nBaseSamples != nExpectedBaseSamples )\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"Wrong number of ExtraSamples : %d. %d were expected\",\n                         count, poGDS->nSamplesPerPixel - nExpectedBaseSamples);\n            }\n\n            if( nBand > nBaseSamples\n                && nBand-nBaseSamples-1 < count\n                && (v[nBand-nBaseSamples-1] == EXTRASAMPLE_ASSOCALPHA\n                    || v[nBand-nBaseSamples-1] == EXTRASAMPLE_UNASSALPHA) )\n                eBandInterp = GCI_AlphaBand;\n            else\n                eBandInterp = GCI_Undefined;\n        }\n        else\n        {\n            eBandInterp = GCI_Undefined;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Establish block size for strip or tiles.                        */\n/* -------------------------------------------------------------------- */\n    nBlockXSize = poGDS->nBlockXSize;\n    nBlockYSize = poGDS->nBlockYSize;\n}\n\n/************************************************************************/\n/*                          ~GTiffRasterBand()                          */\n/************************************************************************/\n\nGTiffRasterBand::~GTiffRasterBand()\n{\n    // So that any future DropReferenceVirtualMem() will not try to access the\n    // raster band object, but this would not conform to the advertised\n    // contract.\n    if( !aSetPSelf.empty() )\n    {\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"Virtual memory objects still exist at GTiffRasterBand \"\n                  \"destruction\" );\n        std::set<GTiffRasterBand**>::iterator oIter = aSetPSelf.begin();\n        for( ; oIter != aSetPSelf.end(); ++oIter )\n            *(*oIter) = nullptr;\n    }\n}\n\n/************************************************************************/\n/*                        FetchBufferDirectIO                           */\n/************************************************************************/\n\nclass FetchBufferDirectIO final\n{\n    VSILFILE*    fp;\n    GByte       *pTempBuffer;\n    size_t       nTempBufferSize;\n\npublic:\n            FetchBufferDirectIO( VSILFILE* fpIn,\n                                 GByte* pTempBufferIn,\n                                 size_t nTempBufferSizeIn ) :\n                fp(fpIn),\n                pTempBuffer(pTempBufferIn),\n                nTempBufferSize(nTempBufferSizeIn) {}\n\n    const GByte* FetchBytes( vsi_l_offset nOffset,\n                             int nPixels, int nDTSize,\n                             bool bIsByteSwapped, bool bIsComplex,\n                             int nBlockId )\n    {\n        if( !FetchBytes(pTempBuffer, nOffset, nPixels, nDTSize, bIsByteSwapped,\n                        bIsComplex, nBlockId) )\n        {\n            return nullptr;\n        }\n        return pTempBuffer;\n    }\n\n    bool FetchBytes( GByte* pabyDstBuffer,\n                     vsi_l_offset nOffset,\n                     int nPixels, int nDTSize,\n                     bool bIsByteSwapped, bool bIsComplex,\n                     int nBlockId )\n    {\n        vsi_l_offset nSeekForward = 0;\n        if( nOffset <= VSIFTellL(fp) ||\n            (nSeekForward = nOffset - VSIFTellL(fp)) > nTempBufferSize )\n        {\n            if( VSIFSeekL(fp, nOffset, SEEK_SET) != 0 )\n            {\n                CPLError(CE_Failure, CPLE_FileIO,\n                         \"Cannot seek to block %d\", nBlockId);\n                return false;\n            }\n        }\n        else\n        {\n            while( nSeekForward > 0 )\n            {\n                vsi_l_offset nToRead = nSeekForward;\n                if( nToRead > nTempBufferSize )\n                    nToRead = nTempBufferSize;\n                if( VSIFReadL(pTempBuffer, static_cast<size_t>(nToRead),\n                              1, fp) != 1 )\n                {\n                    CPLError(CE_Failure, CPLE_FileIO,\n                             \"Cannot seek to block %d\", nBlockId);\n                    return false;\n                }\n                nSeekForward -= nToRead;\n            }\n        }\n        if( VSIFReadL(pabyDstBuffer, nPixels * nDTSize, 1, fp) != 1 )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return false;\n        }\n\n        if( bIsByteSwapped )\n        {\n            if( bIsComplex )\n                GDALSwapWords( pabyDstBuffer, nDTSize / 2, 2 * nPixels,\n                               nDTSize / 2 );\n            else\n                GDALSwapWords( pabyDstBuffer, nDTSize, nPixels, nDTSize);\n        }\n        return true;\n    }\n\n    static const EMULATED_BOOL bMinimizeIO = true;\n};\n\n/************************************************************************/\n/*                           DirectIO()                                 */\n/************************************************************************/\n\n// Reads directly bytes from the file using ReadMultiRange(), and by-pass\n// block reading. Restricted to simple TIFF configurations\n// (uncompressed data, standard data types). Particularly useful to extract\n// sub-windows of data on a large /vsicurl dataset).\n// Returns -1 if DirectIO() can't be supported on that file.\n\nint GTiffRasterBand::DirectIO( GDALRWFlag eRWFlag,\n                               int nXOff, int nYOff, int nXSize, int nYSize,\n                               void * pData, int nBufXSize, int nBufYSize,\n                               GDALDataType eBufType,\n                               GSpacing nPixelSpace, GSpacing nLineSpace,\n                               GDALRasterIOExtraArg* psExtraArg )\n{\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(eRWFlag == GF_Read &&\n          poGDS->nCompression == COMPRESSION_NONE &&\n          (poGDS->nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           poGDS->nPhotometric == PHOTOMETRIC_RGB ||\n           poGDS->nPhotometric == PHOTOMETRIC_PALETTE) &&\n          poGDS->nBitsPerSample == nDTSizeBits &&\n          poGDS->SetDirectory() /* very important to make hTIFF uptodate! */) )\n    {\n        return -1;\n    }\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) &&\n        psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"DirectIO(%d,%d,%d,%d -> %dx%d)\",\n              nXOff, nYOff, nXSize, nYSize,\n              nBufXSize, nBufYSize );\n#endif\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( poGDS->GetAccess() == GA_Update )\n    {\n        poGDS->FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( poGDS->hTIFF ) );\n    }\n\n    if( TIFFIsTiled( poGDS->hTIFF ) )\n    {\n        if( poGDS->m_pTempBufferForCommonDirectIO == nullptr )\n        {\n            const int nDTSize = nDTSizeBits / 8;\n            poGDS->m_nTempBufferForCommonDirectIOSize =\n                static_cast<size_t>(\n                    nBlockXSize * nBlockYSize * nDTSize *\n                    (poGDS->nPlanarConfig == PLANARCONFIG_CONTIG ?\n                     poGDS->nBands : 1) );\n\n            poGDS->m_pTempBufferForCommonDirectIO =\n                static_cast<GByte *>( VSI_MALLOC_VERBOSE(\n                    poGDS->m_nTempBufferForCommonDirectIOSize ) );\n            if( poGDS->m_pTempBufferForCommonDirectIO == nullptr )\n                return CE_Failure;\n        }\n\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( poGDS->hTIFF ));\n        FetchBufferDirectIO oFetcher(fp, poGDS->m_pTempBufferForCommonDirectIO,\n                                     poGDS->m_nTempBufferForCommonDirectIOSize);\n\n        return poGDS->CommonDirectIO(\n            oFetcher,\n            nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize,\n            eBufType,\n            1, &nBand,\n            nPixelSpace, nLineSpace,\n            0 );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    // TODO(schwehr): Make ppData be GByte**.\n    void** ppData = static_cast<void **>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void*)) );\n    vsi_l_offset* panOffsets = static_cast<vsi_l_offset *>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)) );\n    size_t* panSizes = static_cast<size_t *>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)) );\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void* pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands =\n        poGDS->nPlanarConfig == PLANARCONFIG_CONTIG ? poGDS->nBands : 1;\n    int nSrcPixelSize = nDTSize * nContigBands;\n\n    if( ppData == nullptr || panOffsets == nullptr || panSizes == nullptr )\n        eErr = CE_Failure;\n    else if( nXSize != nBufXSize || nYSize != nBufYSize ||\n             eBufType != eDataType ||\n             nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n             nContigBands > 1 )\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC_VERBOSE(nReqXSize * nReqYSize * nSrcPixelSize);\n        if( pTmpBuffer == nullptr )\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    for( int iLine = 0; eErr == CE_None && iLine < nReqYSize; ++iLine )\n    {\n        if( pTmpBuffer == nullptr )\n            ppData[iLine] = static_cast<GByte *>(pData) + iLine * nLineSpace;\n        else\n            ppData[iLine] =\n                static_cast<GByte *>(pTmpBuffer) +\n                iLine * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if( nBufYSize < nYSize )  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast<int>((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n        if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            nBlockId += (nBand-1) * poGDS->nBlocksPerBand;\n        }\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if( panOffsets[iLine] == 0 )  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff + nYOffsetInBlock * nBlockXSize) * nSrcPixelSize;\n        panSizes[iLine] = nReqXSize * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if( eErr == CE_None )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( poGDS->hTIFF ));\n        const int nRet =\n            VSIFReadMultiRangeL( nReqYSize, ppData, panOffsets, panSizes, fp );\n        if( nRet != 0 )\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if( eErr == CE_None && TIFFIsByteSwapped(poGDS->hTIFF) )\n    {\n        for( int iLine = 0; iLine < nReqYSize; ++iLine )\n        {\n            if( GDALDataTypeIsComplex(eDataType) )\n                GDALSwapWords( ppData[iLine], nDTSize / 2,\n                               2 * nReqXSize * nContigBands, nDTSize / 2 );\n            else\n                GDALSwapWords( ppData[iLine], nDTSize,\n                               nReqXSize * nContigBands, nDTSize );\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    if( eErr == CE_None && pTmpBuffer != nullptr )\n    {\n        for( int iY=0; iY < nBufYSize; ++iY )\n        {\n            const int iSrcY =\n                nBufYSize <= nYSize ?\n                iY : static_cast<int>((iY + 0.5) * dfSrcYInc);\n\n            GByte* pabySrcData =\n                static_cast<GByte*>(ppData[iSrcY]) +\n                (nContigBands > 1 ? (nBand-1) : 0) * nDTSize;\n            GByte* pabyDstData =\n                static_cast<GByte *>(pData) + iY * nLineSpace;\n            if( nBufXSize == nXSize )\n            {\n                GDALCopyWords( pabySrcData,\n                               eDataType,\n                               nSrcPixelSize,\n                               pabyDstData,\n                               eBufType,\n                               static_cast<int>(nPixelSpace),\n                               nBufXSize );\n            }\n            else\n            {\n                if( eDataType == GDT_Byte && eBufType == GDT_Byte )\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for( int iX = 0; iX < nBufXSize; ++iX, dfSrcX += dfSrcXInc )\n                    {\n                        const int iSrcX = static_cast<int>(dfSrcX);\n                        pabyDstData[iX * nPixelSpace] =\n                            pabySrcData[iSrcX * nSrcPixelSize];\n                    }\n                }\n                else\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for( int iX = 0; iX < nBufXSize; ++iX, dfSrcX += dfSrcXInc )\n                    {\n                        const int iSrcX = static_cast<int>(dfSrcX);\n                        GDALCopyWords( pabySrcData + iSrcX * nSrcPixelSize,\n                                       eDataType, 0,\n                                       pabyDstData + iX * nPixelSpace,\n                                       eBufType, 0, 1 );\n                    }\n                }\n            }\n        }\n    }\n\n    // Cleanup.\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                           GetVirtualMemAuto()                        */\n/************************************************************************/\n\nCPLVirtualMem* GTiffRasterBand::GetVirtualMemAuto( GDALRWFlag eRWFlag,\n                                                   int *pnPixelSpace,\n                                                   GIntBig *pnLineSpace,\n                                                   char **papszOptions )\n{\n    const char* pszImpl = CSLFetchNameValueDef(\n            papszOptions, \"USE_DEFAULT_IMPLEMENTATION\", \"AUTO\");\n    if( EQUAL(pszImpl, \"YES\") || EQUAL(pszImpl, \"ON\") ||\n        EQUAL(pszImpl, \"1\") || EQUAL(pszImpl, \"TRUE\") )\n    {\n        return GDALRasterBand::GetVirtualMemAuto( eRWFlag, pnPixelSpace,\n                                                  pnLineSpace, papszOptions );\n    }\n\n    CPLVirtualMem *psRet =\n        GetVirtualMemAutoInternal( eRWFlag, pnPixelSpace, pnLineSpace,\n                                   papszOptions );\n    if( psRet != nullptr )\n    {\n        CPLDebug(\"GTiff\", \"GetVirtualMemAuto(): Using memory file mapping\");\n        return psRet;\n    }\n\n    if( EQUAL(pszImpl, \"NO\") || EQUAL(pszImpl, \"OFF\") ||\n        EQUAL(pszImpl, \"0\") || EQUAL(pszImpl, \"FALSE\") )\n    {\n        return nullptr;\n    }\n\n    CPLDebug(\"GTiff\", \"GetVirtualMemAuto(): Defaulting to base implementation\");\n    return GDALRasterBand::GetVirtualMemAuto( eRWFlag, pnPixelSpace,\n                                              pnLineSpace, papszOptions );\n}\n\n\n/************************************************************************/\n/*                           GetDefaultRAT()                            */\n/************************************************************************/\n\nGDALRasterAttributeTable *GTiffRasterBand::GetDefaultRAT()\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetDefaultRAT();\n}\n\n/************************************************************************/\n/*                           GetHistogram()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::GetHistogram(\n    double dfMin, double dfMax,\n    int nBuckets, GUIntBig * panHistogram,\n    int bIncludeOutOfRange, int bApproxOK,\n    GDALProgressFunc pfnProgress, void *pProgressData )\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetHistogram( dfMin, dfMax,\n                                            nBuckets, panHistogram,\n                                            bIncludeOutOfRange, bApproxOK,\n                                            pfnProgress, pProgressData );\n}\n\n/************************************************************************/\n/*                       GetDefaultHistogram()                          */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::GetDefaultHistogram( double *pdfMin, double *pdfMax,\n                                             int *pnBuckets,\n                                             GUIntBig ** ppanHistogram,\n                                             int bForce,\n                                             GDALProgressFunc pfnProgress,\n                                             void *pProgressData )\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetDefaultHistogram( pdfMin, pdfMax,\n                                                   pnBuckets, ppanHistogram,\n                                                   bForce,\n                                                   pfnProgress, pProgressData );\n}\n\n/************************************************************************/\n/*                     DropReferenceVirtualMem()                        */\n/************************************************************************/\n\nvoid GTiffRasterBand::DropReferenceVirtualMem( void* pUserData )\n{\n    // This function may also be called when the dataset and rasterband\n    // objects have been destroyed.\n    // If they are still alive, it updates the reference counter of the\n    // base mapping to invalidate the pointer to it if needed.\n\n    GTiffRasterBand** ppoSelf = static_cast<GTiffRasterBand **>( pUserData );\n    GTiffRasterBand* poSelf = *ppoSelf;\n\n    if( poSelf != nullptr )\n    {\n        if( --(poSelf->poGDS->nRefBaseMapping) == 0 )\n        {\n            poSelf->poGDS->pBaseMapping = nullptr;\n        }\n        poSelf->aSetPSelf.erase(ppoSelf);\n    }\n    CPLFree(pUserData);\n}\n\n/************************************************************************/\n/*                     GetVirtualMemAutoInternal()                      */\n/************************************************************************/\n\nCPLVirtualMem* GTiffRasterBand::GetVirtualMemAutoInternal( GDALRWFlag eRWFlag,\n                                                           int *pnPixelSpace,\n                                                           GIntBig *pnLineSpace,\n                                                           char **papszOptions )\n{\n    int nLineSize = nBlockXSize * GDALGetDataTypeSizeBytes(eDataType);\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        nLineSize *= poGDS->nBands;\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        // In case of a pixel interleaved file, we save virtual memory space\n        // by reusing a base mapping that embraces the whole imagery.\n        if( poGDS->pBaseMapping != nullptr )\n        {\n            // Offset between the base mapping and the requested mapping.\n            vsi_l_offset nOffset =\n                static_cast<vsi_l_offset>(nBand - 1) *\n                GDALGetDataTypeSizeBytes(eDataType);\n\n            GTiffRasterBand** ppoSelf =\n                static_cast<GTiffRasterBand** >(\n                    CPLCalloc(1, sizeof(GTiffRasterBand*)) );\n            *ppoSelf = this;\n\n            CPLVirtualMem* pVMem = CPLVirtualMemDerivedNew(\n                poGDS->pBaseMapping,\n                nOffset,\n                CPLVirtualMemGetSize(poGDS->pBaseMapping) - nOffset,\n                GTiffRasterBand::DropReferenceVirtualMem,\n                ppoSelf);\n            if( pVMem == nullptr )\n            {\n                CPLFree(ppoSelf);\n                return nullptr;\n            }\n\n            // Mechanism used so that the memory mapping object can be\n            // destroyed after the raster band.\n            aSetPSelf.insert(ppoSelf);\n            ++poGDS->nRefBaseMapping;\n            *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n            if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n                *pnPixelSpace *= poGDS->nBands;\n            *pnLineSpace = nLineSize;\n            return pVMem;\n        }\n    }\n\n    if( !poGDS->SetDirectory() )  // Very important to make hTIFF up-to-date.\n        return nullptr;\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( poGDS->hTIFF ));\n\n    vsi_l_offset nLength = static_cast<vsi_l_offset>(nRasterYSize) * nLineSize;\n\n    if( !(CPLIsVirtualMemFileMapAvailable() &&\n          VSIFGetNativeFileDescriptorL(fp) != nullptr &&\n#if SIZEOF_VOIDP == 4\n          nLength == static_cast<size_t>(nLength) &&\n#endif\n          poGDS->nCompression == COMPRESSION_NONE &&\n          (poGDS->nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           poGDS->nPhotometric == PHOTOMETRIC_RGB ||\n           poGDS->nPhotometric == PHOTOMETRIC_PALETTE) &&\n          poGDS->nBitsPerSample == GDALGetDataTypeSizeBits(eDataType) &&\n          !TIFFIsTiled( poGDS->hTIFF ) && !TIFFIsByteSwapped(poGDS->hTIFF)) )\n    {\n        return nullptr;\n    }\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( poGDS->GetAccess() == GA_Update )\n    {\n        poGDS->FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( poGDS->hTIFF ) );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return nullptr;\n    }\n\n    int nBlockSize =\n        nBlockXSize * nBlockYSize * GDALGetDataTypeSizeBytes(eDataType);\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        nBlockSize *= poGDS->nBands;\n\n    int nBlocks = poGDS->nBlocksPerBand;\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlocks *= poGDS->nBands;\n    int i = 0;  // Used after for.\n    for( ; i < nBlocks; ++i )\n    {\n        if( panTIFFOffsets[i] != 0 )\n            break;\n    }\n    if( i == nBlocks )\n    {\n        // All zeroes.\n        if( poGDS->eAccess == GA_Update )\n        {\n            // Initialize the file with empty blocks so that the file has\n            // the appropriate size.\n\n            toff_t* panByteCounts = nullptr;\n            if( !TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPBYTECOUNTS,\n                               &panByteCounts ) ||\n                panByteCounts == nullptr )\n            {\n                return nullptr;\n            }\n            if( VSIFSeekL(fp, 0, SEEK_END) != 0 )\n                return nullptr;\n            vsi_l_offset nBaseOffset = VSIFTellL(fp);\n\n            // Just write one tile with libtiff to put it in appropriate state.\n            GByte* pabyData =\n                static_cast<GByte*>(VSI_CALLOC_VERBOSE(1, nBlockSize));\n            if( pabyData == nullptr )\n            {\n                return nullptr;\n            }\n            int ret =\n                static_cast<int>(\n                    TIFFWriteEncodedStrip( poGDS->hTIFF, 0, pabyData,\n                                           nBlockSize ) );\n            VSI_TIFFFlushBufferedWrite( TIFFClientdata( poGDS->hTIFF ) );\n            VSIFree(pabyData);\n            if( ret != nBlockSize )\n            {\n                return nullptr;\n            }\n            CPLAssert(panTIFFOffsets[0] == nBaseOffset);\n            CPLAssert(panByteCounts[0] == static_cast<toff_t>(nBlockSize));\n\n            // Now simulate the writing of other blocks.\n            const vsi_l_offset nDataSize =\n                static_cast<vsi_l_offset>(nBlockSize) * nBlocks;\n            if( VSIFTruncateL(fp, nBaseOffset + nDataSize) != 0 )\n                return nullptr;\n\n            for( i = 1; i < nBlocks; ++i)\n            {\n                panTIFFOffsets[i] =\n                    nBaseOffset + i * static_cast<toff_t>(nBlockSize);\n                panByteCounts[i] = nBlockSize;\n            }\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"Sparse files not supported in file mapping\" );\n            return nullptr;\n        }\n    }\n\n    GIntBig nBlockSpacing = 0;\n    bool bCompatibleSpacing = true;\n    toff_t nPrevOffset = 0;\n    for( i = 0; i < poGDS->nBlocksPerBand; ++i )\n    {\n        toff_t nCurOffset = 0;\n        if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n            nCurOffset =\n                panTIFFOffsets[poGDS->nBlocksPerBand * (nBand - 1) + i];\n        else\n            nCurOffset = panTIFFOffsets[i];\n        if( nCurOffset == 0 )\n        {\n            bCompatibleSpacing = false;\n            break;\n        }\n        if( i > 0 )\n        {\n            const GIntBig nCurSpacing = nCurOffset - nPrevOffset;\n            if( i == 1 )\n            {\n                if( nCurSpacing !=\n                    static_cast<GIntBig>(nBlockYSize) * nLineSize )\n                {\n                    bCompatibleSpacing = false;\n                    break;\n                }\n                nBlockSpacing = nCurSpacing;\n            }\n            else if( nBlockSpacing != nCurSpacing )\n            {\n                bCompatibleSpacing = false;\n                break;\n            }\n        }\n        nPrevOffset = nCurOffset;\n    }\n\n    if( !bCompatibleSpacing )\n    {\n        return nullptr;\n    }\n\n    vsi_l_offset nOffset = 0;\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        CPLAssert( poGDS->pBaseMapping == nullptr );\n        nOffset = panTIFFOffsets[0];\n    }\n    else\n    {\n        nOffset = panTIFFOffsets[poGDS->nBlocksPerBand * (nBand - 1)];\n    }\n    CPLVirtualMem* pVMem = CPLVirtualMemFileMapNew(\n        fp, nOffset, nLength,\n        eRWFlag == GF_Write ? VIRTUALMEM_READWRITE : VIRTUALMEM_READONLY,\n        nullptr, nullptr);\n    if( pVMem == nullptr )\n    {\n        return nullptr;\n    }\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        // TODO(schwehr): Revisit this block.\n        poGDS->pBaseMapping = pVMem;\n        pVMem = GetVirtualMemAutoInternal( eRWFlag,\n                                           pnPixelSpace,\n                                           pnLineSpace,\n                                           papszOptions );\n        // Drop ref on base mapping.\n        CPLVirtualMemFree(poGDS->pBaseMapping);\n        if( pVMem == nullptr )\n            poGDS->pBaseMapping = nullptr;\n    }\n    else\n    {\n        *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n        if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n            *pnPixelSpace *= poGDS->nBands;\n        *pnLineSpace = nLineSize;\n    }\n    return pVMem;\n}\n\n/************************************************************************/\n/*                     HasOptimizedReadMultiRange()                     */\n/************************************************************************/\n\nint GTiffDataset::HasOptimizedReadMultiRange()\n{\n    if( m_nHasOptimizedReadMultiRange >= 0 )\n        return m_nHasOptimizedReadMultiRange;\n    m_nHasOptimizedReadMultiRange =\n        VSIHasOptimizedReadMultiRange(osFilename);\n    return m_nHasOptimizedReadMultiRange;\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffDataset::IRasterIO( GDALRWFlag eRWFlag,\n                                int nXOff, int nYOff, int nXSize, int nYSize,\n                                void * pData, int nBufXSize, int nBufYSize,\n                                GDALDataType eBufType,\n                                int nBandCount, int *panBandMap,\n                                GSpacing nPixelSpace, GSpacing nLineSpace,\n                                GSpacing nBandSpace,\n                                GDALRasterIOExtraArg* psExtraArg )\n\n{\n    // Try to pass the request to the most appropriate overview dataset.\n    if( nBufXSize < nXSize && nBufYSize < nYSize )\n    {\n        int bTried = FALSE;\n        ++nJPEGOverviewVisibilityCounter;\n        const CPLErr eErr =\n            TryOverviewRasterIO( eRWFlag,\n                                 nXOff, nYOff, nXSize, nYSize,\n                                 pData, nBufXSize, nBufYSize,\n                                 eBufType,\n                                 nBandCount, panBandMap,\n                                 nPixelSpace, nLineSpace,\n                                 nBandSpace,\n                                 psExtraArg,\n                                 &bTried );\n        --nJPEGOverviewVisibilityCounter;\n        if( bTried )\n            return eErr;\n    }\n\n    if( eVirtualMemIOUsage != VIRTUAL_MEM_IO_NO )\n    {\n        const int nErr = VirtualMemIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg );\n        if( nErr >= 0 )\n            return static_cast<CPLErr>(nErr);\n    }\n    if( bDirectIO )\n    {\n        const int nErr = DirectIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg );\n        if( nErr >= 0 )\n            return static_cast<CPLErr>(nErr);\n    }\n\n    void* pBufferedData = nullptr;\n    if( eAccess == GA_ReadOnly &&\n        eRWFlag == GF_Read &&\n        nPlanarConfig == PLANARCONFIG_CONTIG &&\n        HasOptimizedReadMultiRange() )\n    {\n        pBufferedData = cpl::down_cast<GTiffRasterBand *>(\n            GetRasterBand(1))->CacheMultiRange(nXOff, nYOff,\n                                               nXSize, nYSize,\n                                               nBufXSize, nBufYSize,\n                                               psExtraArg);\n    }\n\n    ++nJPEGOverviewVisibilityCounter;\n    const CPLErr eErr =\n        GDALPamDataset::IRasterIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg);\n    nJPEGOverviewVisibilityCounter--;\n\n    if( pBufferedData )\n    {\n        VSIFree( pBufferedData );\n        VSI_TIFFSetCachedRanges( TIFFClientdata( hTIFF ),\n                                 0, nullptr, nullptr, nullptr );\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                        FetchBufferVirtualMemIO                       */\n/************************************************************************/\n\nclass FetchBufferVirtualMemIO final\n{\n    const GByte* pabySrcData;\n    size_t       nMappingSize;\n    GByte       *pTempBuffer;\n\npublic:\n            FetchBufferVirtualMemIO( const GByte* pabySrcDataIn,\n                                     size_t nMappingSizeIn,\n                                     GByte* pTempBufferIn ) :\n                pabySrcData(pabySrcDataIn),\n                nMappingSize(nMappingSizeIn),\n                pTempBuffer(pTempBufferIn) {}\n\n    const GByte* FetchBytes( vsi_l_offset nOffset,\n                             int nPixels, int nDTSize,\n                             bool bIsByteSwapped, bool bIsComplex,\n                             int nBlockId )\n    {\n        if( nOffset + nPixels * nDTSize > nMappingSize )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return nullptr;\n        }\n        if( !bIsByteSwapped )\n            return pabySrcData + nOffset;\n        memcpy(pTempBuffer, pabySrcData + nOffset, nPixels * nDTSize);\n        if( bIsComplex )\n            GDALSwapWords( pTempBuffer, nDTSize / 2, 2 * nPixels, nDTSize / 2);\n        else\n            GDALSwapWords( pTempBuffer, nDTSize, nPixels, nDTSize);\n        return pTempBuffer;\n    }\n\n    bool FetchBytes( GByte* pabyDstBuffer,\n                     vsi_l_offset nOffset,\n                     int nPixels, int nDTSize,\n                     bool bIsByteSwapped, bool bIsComplex,\n                     int nBlockId )\n    {\n        if( nOffset + nPixels * nDTSize > nMappingSize )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return false;\n        }\n        memcpy(pabyDstBuffer, pabySrcData + nOffset, nPixels * nDTSize);\n        if( bIsByteSwapped )\n        {\n            if( bIsComplex )\n                GDALSwapWords( pabyDstBuffer, nDTSize / 2, 2 * nPixels,\n                               nDTSize / 2);\n            else\n                GDALSwapWords( pabyDstBuffer, nDTSize, nPixels, nDTSize);\n        }\n        return true;\n    }\n\n    static const EMULATED_BOOL bMinimizeIO = false;\n};\n\n/************************************************************************/\n/*                         VirtualMemIO()                               */\n/************************************************************************/\n\nint GTiffDataset::VirtualMemIO( GDALRWFlag eRWFlag,\n                                int nXOff, int nYOff, int nXSize, int nYSize,\n                                void * pData, int nBufXSize, int nBufYSize,\n                                GDALDataType eBufType,\n                                int nBandCount, int *panBandMap,\n                                GSpacing nPixelSpace, GSpacing nLineSpace,\n                                GSpacing nBandSpace,\n                                GDALRasterIOExtraArg* psExtraArg )\n{\n    if( eAccess == GA_Update || eRWFlag == GF_Write || bStreamingIn )\n        return -1;\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) &&\n        psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n    const GDALDataType eDataType = GetRasterBand(1)->GetRasterDataType();\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(nCompression == COMPRESSION_NONE &&\n        (nPhotometric == PHOTOMETRIC_MINISBLACK ||\n        nPhotometric == PHOTOMETRIC_RGB ||\n        nPhotometric == PHOTOMETRIC_PALETTE) &&\n        nBitsPerSample == nDTSizeBits) )\n    {\n        eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n        return -1;\n    }\n\n    size_t nMappingSize = 0;\n    GByte* pabySrcData = nullptr;\n    if( STARTS_WITH(osFilename, \"/vsimem/\") )\n    {\n        vsi_l_offset nDataLength = 0;\n        pabySrcData =\n            VSIGetMemFileBuffer(osFilename, &nDataLength, FALSE);\n        nMappingSize = static_cast<size_t>(nDataLength);\n        if( pabySrcData == nullptr )\n            return -1;\n    }\n    else if( psVirtualMemIOMapping == nullptr )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n        if( !CPLIsVirtualMemFileMapAvailable() ||\n            VSIFGetNativeFileDescriptorL(fp) == nullptr )\n        {\n            eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n            return -1;\n        }\n        if( VSIFSeekL(fp, 0, SEEK_END) != 0 )\n        {\n            eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n            return -1;\n        }\n        const vsi_l_offset nLength = VSIFTellL(fp);\n        if( static_cast<size_t>(nLength) != nLength )\n        {\n            eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n            return -1;\n        }\n        if( eVirtualMemIOUsage == VIRTUAL_MEM_IO_IF_ENOUGH_RAM )\n        {\n            GIntBig nRAM = CPLGetUsablePhysicalRAM();\n            if( static_cast<GIntBig>(nLength) > nRAM )\n            {\n                CPLDebug( \"GTiff\",\n                          \"Not enough RAM to map whole file into memory.\" );\n                eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n                return -1;\n            }\n        }\n        psVirtualMemIOMapping = CPLVirtualMemFileMapNew(\n            fp, 0, nLength, VIRTUALMEM_READONLY, nullptr, nullptr);\n        if( psVirtualMemIOMapping == nullptr )\n        {\n            eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n            return -1;\n        }\n        eVirtualMemIOUsage = VIRTUAL_MEM_IO_YES;\n    }\n\n    if( psVirtualMemIOMapping )\n    {\n#ifdef DEBUG\n        CPLDebug(\"GTiff\", \"Using VirtualMemIO\");\n#endif\n        nMappingSize = CPLVirtualMemGetSize(psVirtualMemIOMapping);\n        pabySrcData = static_cast<GByte *>(\n            CPLVirtualMemGetAddr(psVirtualMemIOMapping) );\n    }\n\n    if( TIFFIsByteSwapped(hTIFF) && m_pTempBufferForCommonDirectIO == nullptr )\n    {\n        const int nDTSize = nDTSizeBits / 8;\n        m_nTempBufferForCommonDirectIOSize =\n            static_cast<size_t>(nBlockXSize * nDTSize *\n                (nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1));\n        if( TIFFIsTiled(hTIFF) )\n            m_nTempBufferForCommonDirectIOSize *= nBlockYSize;\n\n        m_pTempBufferForCommonDirectIO =\n            static_cast<GByte *>(\n                VSI_MALLOC_VERBOSE(m_nTempBufferForCommonDirectIOSize) );\n        if( m_pTempBufferForCommonDirectIO == nullptr )\n            return CE_Failure;\n    }\n    FetchBufferVirtualMemIO oFetcher( pabySrcData, nMappingSize,\n                                      m_pTempBufferForCommonDirectIO );\n\n    return CommonDirectIO( oFetcher,\n                           nXOff, nYOff, nXSize, nYSize,\n                           pData, nBufXSize, nBufYSize,\n                           eBufType,\n                           nBandCount, panBandMap,\n                           nPixelSpace, nLineSpace,\n                           nBandSpace );\n}\n\n/************************************************************************/\n/*                   CopyContigByteMultiBand()                          */\n/************************************************************************/\n\nstatic inline void CopyContigByteMultiBand(\n    const GByte* CPL_RESTRICT pabySrc, int nSrcStride,\n    GByte* CPL_RESTRICT pabyDest, int nDestStride,\n    int nIters, int nBandCount )\n{\n    if( nBandCount == 3 )\n    {\n        if( nSrcStride == 3 && nDestStride == 4 )\n        {\n            while( nIters >= 8 )\n            {\n                pabyDest[4*0+0] = pabySrc[3*0+0];\n                pabyDest[4*0+1] = pabySrc[3*0+1];\n                pabyDest[4*0+2] = pabySrc[3*0+2];\n                pabyDest[4*1+0] = pabySrc[3*1+0];\n                pabyDest[4*1+1] = pabySrc[3*1+1];\n                pabyDest[4*1+2] = pabySrc[3*1+2];\n                pabyDest[4*2+0] = pabySrc[3*2+0];\n                pabyDest[4*2+1] = pabySrc[3*2+1];\n                pabyDest[4*2+2] = pabySrc[3*2+2];\n                pabyDest[4*3+0] = pabySrc[3*3+0];\n                pabyDest[4*3+1] = pabySrc[3*3+1];\n                pabyDest[4*3+2] = pabySrc[3*3+2];\n                pabyDest[4*4+0] = pabySrc[3*4+0];\n                pabyDest[4*4+1] = pabySrc[3*4+1];\n                pabyDest[4*4+2] = pabySrc[3*4+2];\n                pabyDest[4*5+0] = pabySrc[3*5+0];\n                pabyDest[4*5+1] = pabySrc[3*5+1];\n                pabyDest[4*5+2] = pabySrc[3*5+2];\n                pabyDest[4*6+0] = pabySrc[3*6+0];\n                pabyDest[4*6+1] = pabySrc[3*6+1];\n                pabyDest[4*6+2] = pabySrc[3*6+2];\n                pabyDest[4*7+0] = pabySrc[3*7+0];\n                pabyDest[4*7+1] = pabySrc[3*7+1];\n                pabyDest[4*7+2] = pabySrc[3*7+2];\n                pabySrc += 3 * 8;\n                pabyDest += 4 * 8;\n                nIters -= 8;\n            }\n            while( nIters-- > 0 )\n            {\n                pabyDest[0] = pabySrc[0];\n                pabyDest[1] = pabySrc[1];\n                pabyDest[2] = pabySrc[2];\n                pabySrc += 3;\n                pabyDest += 4;\n            }\n        }\n        else\n        {\n            while( nIters-- > 0 )\n            {\n                pabyDest[0] = pabySrc[0];\n                pabyDest[1] = pabySrc[1];\n                pabyDest[2] = pabySrc[2];\n                pabySrc += nSrcStride;\n                pabyDest += nDestStride;\n            }\n        }\n    }\n    else\n    {\n        while( nIters-- > 0 )\n        {\n            for( int iBand = 0; iBand < nBandCount; ++iBand )\n                pabyDest[iBand] = pabySrc[iBand];\n            pabySrc += nSrcStride;\n            pabyDest += nDestStride;\n        }\n    }\n}\n\n/************************************************************************/\n/*                         CommonDirectIO()                             */\n/************************************************************************/\n\n// #define DEBUG_REACHED_VIRTUAL_MEM_IO\n#ifdef DEBUG_REACHED_VIRTUAL_MEM_IO\nstatic int anReachedVirtualMemIO[52] = { 0 };\n#define REACHED(x) anReachedVirtualMemIO[x] = 1\n#else\n#define REACHED(x)\n#endif\n\ntemplate<class FetchBuffer> CPLErr GTiffDataset::CommonDirectIO(\n    FetchBuffer& oFetcher,\n    int nXOff, int nYOff, int nXSize, int nYSize,\n    void * pData, int nBufXSize, int nBufYSize,\n    GDALDataType eBufType,\n    int nBandCount, int *panBandMap,\n    GSpacing nPixelSpace, GSpacing nLineSpace,\n    GSpacing nBandSpace )\n{\n    const GDALDataType eDataType = GetRasterBand(1)->GetRasterDataType();\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    const bool bIsComplex = CPL_TO_BOOL(GDALDataTypeIsComplex(eDataType));\n    const int nBufDTSize = GDALGetDataTypeSizeBytes(eBufType);\n\n    // Get strip offsets.\n    toff_t *panOffsets = nullptr;\n    if( !TIFFGetField( hTIFF, (TIFFIsTiled( hTIFF )) ?\n                       TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                       &panOffsets ) ||\n        panOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    bool bUseContigImplementation =\n        nPlanarConfig == PLANARCONFIG_CONTIG &&\n        nBandCount > 1 &&\n        nBandSpace == nBufDTSize;\n    if( bUseContigImplementation )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            const int nBand = panBandMap[iBand];\n            if( nBand != iBand + 1 )\n            {\n                bUseContigImplementation = false;\n                break;\n            }\n        }\n    }\n\n    const int nBandsPerBlock =\n        nPlanarConfig == PLANARCONFIG_SEPARATE ? 1 : nBands;\n    const int nBandsPerBlockDTSize = nBandsPerBlock * nDTSize;\n    const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    const bool bNoTypeChange = (eDataType == eBufType);\n    const bool bNoXResampling = (nXSize == nBufXSize );\n    const bool bNoXResamplingNoTypeChange = (bNoTypeChange && bNoXResampling);\n    const bool bByteOnly = (bNoTypeChange && nDTSize == 1 );\n    const bool bByteNoXResampling = ( bByteOnly && bNoXResamplingNoTypeChange );\n    const bool bIsByteSwapped = CPL_TO_BOOL(TIFFIsByteSwapped(hTIFF));\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    int bNoDataSetIn = FALSE;\n    double dfNoData = GetRasterBand(1)->GetNoDataValue( &bNoDataSetIn );\n    GByte abyNoData = 0;\n    if( !bNoDataSetIn )\n        dfNoData = 0;\n    else if( dfNoData >= 0 && dfNoData <= 255 )\n        abyNoData = static_cast<GByte>(dfNoData + 0.5);\n\n    if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( hTIFF ) && bNoXResampling && (nYSize == nBufYSize ) &&\n             nPlanarConfig == PLANARCONFIG_CONTIG && nBandCount > 1 )\n    {\n        GByte* pabyData = static_cast<GByte *>(pData);\n        for( int y = 0; y < nBufYSize; )\n        {\n            const int nSrcLine = nYOff + y;\n            const int nBlockYOff = nSrcLine / nBlockYSize;\n            const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n            const int nUsedBlockHeight =\n                std::min( nBufYSize - y,\n                          nBlockYSize - nYOffsetInBlock );\n\n            int nBlockXOff = nXOff / nBlockXSize;\n            int nXOffsetInBlock = nXOff % nBlockXSize;\n            int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n            int x = 0;\n            while( x < nBufXSize )\n            {\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                const int nUsedBlockWidth =\n                    std::min( nBlockXSize - nXOffsetInBlock,\n                              nBufXSize - x );\n\n                if( nCurOffset == 0 )\n                {\n                    REACHED(30);\n                    for( int k = 0; k < nUsedBlockHeight; ++k )\n                    {\n                        GByte* pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for( int iBand = 0; iBand < nBandCount; ++iBand )\n                        {\n                            GByte* pabyLocalDataBand =\n                                pabyLocalData + iBand * nBandSpace;\n\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalDataBand, eBufType,\n                                static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth );\n                        }\n                    }\n                }\n                else\n                {\n                    const int nByteOffsetInBlock =\n                        nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n                    const GByte* pabyLocalSrcDataK0 = oFetcher.FetchBytes(\n                            nCurOffset + nByteOffsetInBlock,\n                            nBlockXSize *\n                            nUsedBlockHeight * nBandsPerBlock,\n                            nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                    if( pabyLocalSrcDataK0 == nullptr )\n                        return CE_Failure;\n\n                    for( int k = 0; k < nUsedBlockHeight; ++k )\n                    {\n                        GByte* pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        const GByte* pabyLocalSrcData =\n                            pabyLocalSrcDataK0 +\n                            (k * nBlockXSize + nXOffsetInBlock) *\n                            nBandsPerBlockDTSize;\n\n                        if( bUseContigImplementation && nBands == nBandCount &&\n                            nPixelSpace == nBandsPerBlockDTSize )\n                        {\n                            REACHED(31);\n                            GDALCopyWords( pabyLocalSrcData,\n                                           eDataType, nDTSize,\n                                           pabyLocalData,\n                                           eBufType, nBufDTSize,\n                                           nUsedBlockWidth * nBands );\n                        }\n                        else\n                        {\n                            REACHED(32);\n                            for( int iBand = 0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand]-1) * nDTSize;\n\n                                GDALCopyWords(\n                                    pabyLocalSrcDataBand,\n                                    eDataType, nBandsPerBlockDTSize,\n                                    pabyLocalDataBand,\n                                    eBufType, static_cast<int>(nPixelSpace),\n                                    nUsedBlockWidth );\n                            }\n                        }\n                    }\n                }\n\n                nXOffsetInBlock = 0;\n                ++nBlockXOff;\n                ++nBlockId;\n                x += nUsedBlockWidth;\n            }\n\n            y += nUsedBlockHeight;\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( hTIFF ) && bNoXResampling &&\n             (nYSize == nBufYSize ) )\n             // && (nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            GByte* pabyData = static_cast<GByte *>(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            for( int y = 0; y < nBufYSize; )\n            {\n                const int nSrcLine = nYOff + y;\n                const int nBlockYOff = nSrcLine / nBlockYSize;\n                const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                const int nUsedBlockHeight =\n                    std::min( nBufYSize - y,\n                              nBlockYSize - nYOffsetInBlock);\n\n                int nBlockXOff = nXOff / nBlockXSize;\n                int nXOffsetInBlock = nXOff % nBlockXSize;\n                int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n                if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                {\n                    REACHED(33);\n                    nBlockId += nBlocksPerBand * (nBand - 1);\n                }\n                else\n                {\n                    REACHED(34);\n                }\n\n                int x = 0;\n                while( x < nBufXSize )\n                {\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    const int nUsedBlockWidth =\n                        std::min(\n                            nBlockXSize - nXOffsetInBlock,\n                            nBufXSize - x);\n\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(35);\n                        for( int k = 0; k < nUsedBlockHeight; ++k )\n                        {\n                            GByte* pabyLocalData =\n                                pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData, eBufType,\n                                static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth );\n                        }\n                    }\n                    else\n                    {\n                        const int nByteOffsetInBlock =\n                            nYOffsetInBlock * nBlockXSize *\n                            nBandsPerBlockDTSize;\n                        const GByte* pabyLocalSrcDataK0 =\n                            oFetcher.FetchBytes(\n                                nCurOffset + nByteOffsetInBlock,\n                                nBlockXSize *\n                                nUsedBlockHeight * nBandsPerBlock,\n                                nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                        if( pabyLocalSrcDataK0 == nullptr )\n                            return CE_Failure;\n\n                        if( nPlanarConfig == PLANARCONFIG_CONTIG )\n                        {\n                            REACHED(36);\n                            pabyLocalSrcDataK0 += (nBand - 1) * nDTSize;\n                        }\n                        else\n                        {\n                            REACHED(37);\n                        }\n\n                        for( int k = 0; k < nUsedBlockHeight; ++k )\n                        {\n                            GByte* pabyLocalData =\n                                pabyData + (y + k) * nLineSpace +\n                                x * nPixelSpace;\n                            const GByte* pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (k * nBlockXSize + nXOffsetInBlock) *\n                                nBandsPerBlockDTSize;\n\n                            GDALCopyWords(\n                                pabyLocalSrcData,\n                                eDataType, nBandsPerBlockDTSize,\n                                pabyLocalData,\n                                eBufType, static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth);\n                        }\n                    }\n\n                    nXOffsetInBlock = 0;\n                    ++nBlockXOff;\n                    ++nBlockId;\n                    x += nUsedBlockWidth;\n                }\n\n                y += nUsedBlockHeight;\n            }\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( hTIFF ) &&\n             nPlanarConfig == PLANARCONFIG_CONTIG && nBandCount > 1 )\n    {\n        GByte* pabyData = static_cast<GByte *>(pData);\n        int anSrcYOffset[256] = { 0 };\n        for( int y = 0; y < nBufYSize; )\n        {\n            const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n            const int nSrcLine = static_cast<int>(dfYOffStart);\n            const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n            const int nBlockYOff = nSrcLine / nBlockYSize;\n            const int nBaseByteOffsetInBlock =\n                nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n            int ychunk = 1;\n            int nLastSrcLineK = nSrcLine;\n            anSrcYOffset[0] = 0;\n            for( int k = 1; k < nBufYSize - y; ++k )\n            {\n                int nSrcLineK =\n                    nYOff + static_cast<int>((y + k + 0.5) * dfSrcYInc);\n                const int nBlockYOffK = nSrcLineK / nBlockYSize;\n                if( k < 256)\n                    anSrcYOffset[k] =\n                        ((nSrcLineK % nBlockYSize) - nYOffsetInBlock) *\n                        nBlockXSize * nBandsPerBlockDTSize;\n                if( nBlockYOffK != nBlockYOff )\n                {\n                    break;\n                }\n                ++ychunk;\n                nLastSrcLineK = nSrcLineK;\n            }\n            const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n            // CPLAssert(nUsedBlockHeight <= nBlockYSize);\n\n            double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n            int nCurBlockXOff = 0;\n            int nNextBlockXOff = 0;\n            toff_t nCurOffset = 0;\n            const GByte* pabyLocalSrcDataStartLine = nullptr;\n            for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc)\n            {\n                const int nSrcPixel = static_cast<int>(dfSrcX);\n                if( nSrcPixel >= nNextBlockXOff )\n                {\n                    const int nBlockXOff = nSrcPixel / nBlockXSize;\n                    nCurBlockXOff = nBlockXOff * nBlockXSize;\n                    nNextBlockXOff = nCurBlockXOff + nBlockXSize;\n                    const int nBlockId =\n                        nBlockXOff + nBlockYOff * nBlocksPerRow;\n                    nCurOffset = panOffsets[nBlockId];\n                    if( nCurOffset != 0 )\n                    {\n                        pabyLocalSrcDataStartLine =\n                            oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetInBlock,\n                                nBlockXSize *\n                                nBandsPerBlock * nUsedBlockHeight,\n                                nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId);\n                        if( pabyLocalSrcDataStartLine == nullptr )\n                            return CE_Failure;\n                    }\n                }\n\n                if( nCurOffset == 0 )\n                {\n                    REACHED(38);\n\n                    for( int k = 0; k < ychunk; ++k )\n                    {\n                        GByte* const pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for( int iBand = 0; iBand < nBandCount; ++iBand )\n                        {\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData + nBandSpace * iBand, eBufType, 0,\n                                1);\n                        }\n                    }\n                }\n                else\n                {\n                    const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                    double dfYOff = dfYOffStart;\n                    const GByte* const pabyLocalSrcDataK0 =\n                        pabyLocalSrcDataStartLine +\n                        nXOffsetInBlock * nBandsPerBlockDTSize;\n                    GByte* pabyLocalData =\n                        pabyData + y * nLineSpace + x * nPixelSpace;\n                    for( int k = 0;\n                         k < ychunk;\n                         ++k, pabyLocalData += nLineSpace )\n                    {\n                        const GByte* pabyLocalSrcData = nullptr;\n                        if( ychunk <= 256 )\n                        {\n                            REACHED(39);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 + anSrcYOffset[k];\n                        }\n                        else\n                        {\n                            REACHED(40);\n                            const int nYOffsetInBlockK =\n                                static_cast<int>(dfYOff) % nBlockYSize;\n                            // CPLAssert(\n                            //     nYOffsetInBlockK - nYOffsetInBlock <=\n                            //     nUsedBlockHeight);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (nYOffsetInBlockK - nYOffsetInBlock) *\n                                nBlockXSize * nBandsPerBlockDTSize;\n                            dfYOff += dfSrcYInc;\n                        }\n\n                        if( bByteOnly )\n                        {\n                            REACHED(41);\n                            for( int iBand=0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData + (panBandMap[iBand]-1);\n                                *pabyLocalDataBand = *pabyLocalSrcDataBand;\n                            }\n                        }\n                        else\n                        {\n                            REACHED(42);\n                            for( int iBand = 0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand]-1) * nDTSize;\n\n                                GDALCopyWords( pabyLocalSrcDataBand,\n                                               eDataType, 0,\n                                               pabyLocalDataBand,\n                                               eBufType, 0,\n                                               1 );\n                            }\n                        }\n                    }\n                }\n            }\n\n            y += ychunk;\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( hTIFF ) )\n             // && (nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            GByte* pabyData = static_cast<GByte*>(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            int anSrcYOffset[256] = { 0 };\n            for( int y = 0; y < nBufYSize; )\n            {\n                const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n                const int nSrcLine = static_cast<int>(dfYOffStart);\n                const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                const int nBlockYOff = nSrcLine / nBlockYSize;\n                const int nBaseByteOffsetInBlock =\n                    nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n                int ychunk = 1;\n                int nLastSrcLineK = nSrcLine;\n                anSrcYOffset[0] = 0;\n                for( int k = 1; k < nBufYSize - y; ++k )\n                {\n                    const int nSrcLineK =\n                        nYOff + static_cast<int>((y + k + 0.5) * dfSrcYInc);\n                    const int nBlockYOffK = nSrcLineK / nBlockYSize;\n                    if( k < 256)\n                        anSrcYOffset[k] =\n                            ((nSrcLineK % nBlockYSize) - nYOffsetInBlock) *\n                            nBlockXSize * nBandsPerBlockDTSize;\n                    if( nBlockYOffK != nBlockYOff )\n                    {\n                        break;\n                    }\n                    ++ychunk;\n                    nLastSrcLineK = nSrcLineK;\n                }\n                const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n                // CPLAssert(nUsedBlockHeight <= nBlockYSize);\n\n                double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                int nCurBlockXOff = 0;\n                int nNextBlockXOff = 0;\n                toff_t nCurOffset = 0;\n                const GByte* pabyLocalSrcDataStartLine = nullptr;\n                for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc )\n                {\n                    int nSrcPixel = static_cast<int>(dfSrcX);\n                    if( nSrcPixel >= nNextBlockXOff )\n                    {\n                        const int nBlockXOff = nSrcPixel / nBlockXSize;\n                        nCurBlockXOff = nBlockXOff * nBlockXSize;\n                        nNextBlockXOff = nCurBlockXOff + nBlockXSize;\n                        int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n                        if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                        {\n                            REACHED(43);\n                            nBlockId += nBlocksPerBand * (nBand - 1);\n                        }\n                        else\n                        {\n                            REACHED(44);\n                        }\n                        nCurOffset = panOffsets[nBlockId];\n                        if( nCurOffset != 0 )\n                        {\n                            pabyLocalSrcDataStartLine =\n                                oFetcher.FetchBytes(\n                                    nCurOffset + nBaseByteOffsetInBlock,\n                                    nBlockXSize *\n                                    nBandsPerBlock * nUsedBlockHeight,\n                                    nDTSize,\n                                    bIsByteSwapped, bIsComplex, nBlockId);\n                            if( pabyLocalSrcDataStartLine == nullptr )\n                                return CE_Failure;\n\n                            if( nPlanarConfig == PLANARCONFIG_CONTIG )\n                            {\n                                REACHED(45);\n                                pabyLocalSrcDataStartLine +=\n                                    (nBand - 1) * nDTSize;\n                            }\n                            else\n                            {\n                                REACHED(46);\n                            }\n                        }\n                    }\n\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(47);\n\n                        for( int k = 0; k < ychunk; ++k )\n                        {\n                            GByte* const pabyLocalData =\n                                pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n\n                            GDALCopyWords( &dfNoData, GDT_Float64, 0,\n                                           pabyLocalData, eBufType, 0,\n                                           1 );\n                        }\n                    }\n                    else\n                    {\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                        double dfYOff = dfYOffStart;\n                        const GByte* const pabyLocalSrcDataK0 =\n                            pabyLocalSrcDataStartLine +\n                            nXOffsetInBlock * nBandsPerBlockDTSize;\n                        GByte* pabyLocalData =\n                            pabyData + y * nLineSpace + x * nPixelSpace;\n                        for( int k = 0;\n                             k < ychunk;\n                             ++k, pabyLocalData += nLineSpace )\n                        {\n                            const GByte* pabyLocalSrcData = nullptr;\n                            if( ychunk <= 256 )\n                            {\n                                REACHED(48);\n                                pabyLocalSrcData =\n                                    pabyLocalSrcDataK0 + anSrcYOffset[k];\n                            }\n                            else\n                            {\n                                REACHED(49);\n                                const int nYOffsetInBlockK =\n                                    static_cast<int>(dfYOff) % nBlockYSize;\n                                // CPLAssert(\n                                //     nYOffsetInBlockK - nYOffsetInBlock <=\n                                //     nUsedBlockHeight);\n                                pabyLocalSrcData = pabyLocalSrcDataK0 +\n                                    (nYOffsetInBlockK - nYOffsetInBlock) *\n                                    nBlockXSize * nBandsPerBlockDTSize;\n                                dfYOff += dfSrcYInc;\n                            }\n\n                            if( bByteOnly )\n                            {\n                                REACHED(50);\n\n                                *pabyLocalData = *pabyLocalSrcData;\n                            }\n                            else\n                            {\n                                REACHED(51);\n\n                                GDALCopyWords( pabyLocalSrcData,\n                                               eDataType, 0,\n                                               pabyLocalData,\n                                               eBufType, 0,\n                                               1 );\n                            }\n                        }\n                    }\n                }\n\n                y += ychunk;\n            }\n        }\n    }\n    else if( bUseContigImplementation )\n    {\n        if( !FetchBuffer::bMinimizeIO && TIFFIsTiled( hTIFF ) )\n        {\n            GByte* pabyData = static_cast<GByte *>(pData);\n            for( int y = 0; y < nBufYSize; ++y )\n            {\n                const int nSrcLine =\n                    nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                const int nBlockYOff = nSrcLine / nBlockYSize;\n                const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                const int nBaseByteOffsetInBlock =\n                    nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n\n                if( bNoXResampling )\n                {\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    int nBlockXOff = nXOff / nBlockXSize;\n                    int nXOffsetInBlock = nXOff % nBlockXSize;\n                    int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n                    int x = 0;\n                    while( x < nBufXSize )\n                    {\n                        const int nByteOffsetInBlock = nBaseByteOffsetInBlock +\n                                        nXOffsetInBlock * nBandsPerBlockDTSize;\n                        const toff_t nCurOffset = panOffsets[nBlockId];\n                        const int nUsedBlockWidth =\n                            std::min(\n                                nBlockXSize - nXOffsetInBlock,\n                                nBufXSize - x);\n\n                        int nIters = nUsedBlockWidth;\n                        if( nCurOffset == 0 )\n                        {\n                            if( bByteNoXResampling )\n                            {\n                                REACHED(0);\n                                while( nIters-- > 0 )\n                                {\n                                    for( int iBand = 0;\n                                         iBand < nBandCount;\n                                         ++iBand )\n                                    {\n                                        pabyLocalData[iBand] = abyNoData;\n                                    }\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                            else\n                            {\n                                REACHED(1);\n                                while( nIters-- > 0 )\n                                {\n                                    GDALCopyWords(\n                                        &dfNoData, GDT_Float64, 0,\n                                        pabyLocalData, eBufType,\n                                        static_cast<int>(nBandSpace),\n                                        nBandCount);\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if( bNoTypeChange && nBands == nBandCount &&\n                                nPixelSpace == nBandsPerBlockDTSize )\n                            {\n                                REACHED(2);\n                                if( !oFetcher.FetchBytes(\n                                        pabyLocalData,\n                                        nCurOffset + nByteOffsetInBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId) )\n                                {\n                                    return CE_Failure;\n                                }\n                                pabyLocalData +=\n                                    nIters * nBandsPerBlock * nDTSize;\n                            }\n                            else\n                            {\n                                const GByte* pabyLocalSrcData =\n                                    oFetcher.FetchBytes(\n                                        nCurOffset + nByteOffsetInBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId);\n                                if( pabyLocalSrcData == nullptr )\n                                    return CE_Failure;\n                                if( bByteNoXResampling )\n                                {\n                                    REACHED(3);\n                                    CopyContigByteMultiBand(\n                                        pabyLocalSrcData,\n                                        nBandsPerBlockDTSize,\n                                        pabyLocalData,\n                                        static_cast<int>(nPixelSpace),\n                                        nIters,\n                                        nBandCount);\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    REACHED(4);\n                                    while( nIters-- > 0 )\n                                    {\n                                        GDALCopyWords(\n                                            pabyLocalSrcData,\n                                            eDataType, nDTSize,\n                                            pabyLocalData,\n                                            eBufType,\n                                            static_cast<int>(nBandSpace),\n                                            nBandCount);\n                                        pabyLocalSrcData +=\n                                            nBandsPerBlockDTSize;\n                                        pabyLocalData += nPixelSpace;\n                                    }\n                                }\n                            }\n                        }\n\n                        nXOffsetInBlock = 0;\n                        ++nBlockXOff;\n                        ++nBlockId;\n                        x += nUsedBlockWidth;\n                    }\n                }\n                else  // Contig, tiled, potential resampling & data type change.\n                {\n                    const GByte* pabyLocalSrcDataStartLine = nullptr;\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                    int nCurBlockXOff = 0;\n                    int nNextBlockXOff = 0;\n                    toff_t nCurOffset = 0;\n                    for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc )\n                    {\n                        int nSrcPixel = static_cast<int>(dfSrcX);\n                        if( nSrcPixel >= nNextBlockXOff )\n                        {\n                            const int nBlockXOff = nSrcPixel / nBlockXSize;\n                            nCurBlockXOff = nBlockXOff * nBlockXSize;\n                            nNextBlockXOff = nCurBlockXOff + nBlockXSize;\n                            const int nBlockId =\n                                nBlockXOff + nBlockYOff * nBlocksPerRow;\n                            nCurOffset = panOffsets[nBlockId];\n                            if( nCurOffset != 0 )\n                            {\n                                pabyLocalSrcDataStartLine =\n                                    oFetcher.FetchBytes(\n                                        nCurOffset + nBaseByteOffsetInBlock,\n                                        nBlockXSize *\n                                        nBandsPerBlock,\n                                        nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId);\n                                if( pabyLocalSrcDataStartLine == nullptr )\n                                    return CE_Failure;\n                            }\n                        }\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n\n                        if( nCurOffset == 0 )\n                        {\n                            REACHED(5);\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData,\n                                eBufType,\n                                static_cast<int>(nBandSpace),\n                                nBandCount );\n                            pabyLocalData += nPixelSpace;\n                        }\n                        else\n                        {\n                            const GByte* pabyLocalSrcData =\n                                pabyLocalSrcDataStartLine +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                            REACHED(6);\n                            if( bByteOnly )\n                            {\n                                for( int iBand = 0; iBand < nBands; ++iBand )\n                                    pabyLocalData[iBand] =\n                                        pabyLocalSrcData[iBand];\n                            }\n                            else\n                            {\n                                GDALCopyWords(\n                                    pabyLocalSrcData,\n                                    eDataType, nDTSize,\n                                    pabyLocalData,\n                                    eBufType,\n                                    static_cast<int>(nBandSpace),\n                                    nBandCount );\n                            }\n                            pabyLocalData += nPixelSpace;\n                        }\n                    }\n                }\n            }\n        }\n        else  // Contig, stripped organized.\n        {\n            GByte* pabyData = static_cast<GByte*>(pData);\n            for( int y = 0; y < nBufYSize; ++y )\n            {\n                const int nSrcLine =\n                    nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                const int nBlockYOff = nSrcLine / nBlockYSize;\n                const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                const int nBlockId = nBlockYOff;\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                if( nCurOffset == 0 )\n                {\n                    REACHED(7);\n                    for( int x = 0; x < nBufXSize; ++x )\n                    {\n                        GDALCopyWords(\n                            &dfNoData, GDT_Float64, 0,\n                            pabyData + y * nLineSpace + x * nPixelSpace,\n                            eBufType, static_cast<int>(nBandSpace),\n                            nBandCount);\n                    }\n                }\n                else\n                {\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    const int nBaseByteOffsetInBlock =\n                        (nYOffsetInBlock * nBlockXSize + nXOff) *\n                        nBandsPerBlockDTSize;\n\n                    if( bNoXResamplingNoTypeChange && nBands == nBandCount &&\n                        nPixelSpace == nBandsPerBlockDTSize )\n                    {\n                        REACHED(8);\n                        if( !oFetcher.FetchBytes(\n                               pabyLocalData,\n                               nCurOffset + nBaseByteOffsetInBlock,\n                               nXSize * nBandsPerBlock, nDTSize, bIsByteSwapped,\n                               bIsComplex, nBlockId) )\n                        {\n                            return CE_Failure;\n                        }\n                    }\n                    else\n                    {\n                        const GByte* pabyLocalSrcData = oFetcher.FetchBytes(\n                            nCurOffset + nBaseByteOffsetInBlock,\n                            nXSize * nBandsPerBlock, nDTSize, bIsByteSwapped,\n                            bIsComplex, nBlockId);\n                        if( pabyLocalSrcData == nullptr )\n                            return CE_Failure;\n\n                        if( bByteNoXResampling )\n                        {\n                            REACHED(9);\n                            CopyContigByteMultiBand(\n                                pabyLocalSrcData,\n                                nBandsPerBlockDTSize,\n                                pabyLocalData,\n                                static_cast<int>(nPixelSpace),\n                                nBufXSize,\n                                nBandCount);\n                        }\n                        else if( bByteOnly )\n                        {\n                            REACHED(10);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for( int x = 0;\n                                 x < nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc )\n                            {\n                                const int nSrcPixelMinusXOff =\n                                    static_cast<int>(dfSrcX);\n                                for( int iBand = 0;\n                                     iBand < nBandCount;\n                                     ++iBand )\n                                {\n                                    pabyLocalData[x * nPixelSpace + iBand] =\n                                        pabyLocalSrcData[nSrcPixelMinusXOff *\n                                                         nBandsPerBlockDTSize +\n                                                         iBand];\n                                }\n                            }\n                        }\n                        else\n                        {\n                            REACHED(11);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for( int x = 0;\n                                 x < nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc )\n                            {\n                                int nSrcPixelMinusXOff =\n                                    static_cast<int>(dfSrcX);\n                                GDALCopyWords(\n                                    pabyLocalSrcData +\n                                    nSrcPixelMinusXOff * nBandsPerBlockDTSize,\n                                    eDataType, nDTSize,\n                                    pabyLocalData + x * nPixelSpace,\n                                    eBufType,\n                                    static_cast<int>(nBandSpace),\n                                    nBandCount );\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else  // Non-contig reading case.\n    {\n        if( !FetchBuffer::bMinimizeIO && TIFFIsTiled( hTIFF ) )\n        {\n            for( int iBand = 0; iBand < nBandCount; ++iBand )\n            {\n                const int nBand = panBandMap[iBand];\n                GByte* const pabyData =\n                    static_cast<GByte*>(pData) + iBand * nBandSpace;\n                for( int y = 0; y < nBufYSize; ++y )\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                    const int nBlockYOff = nSrcLine / nBlockYSize;\n                    const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n\n                    int nBaseByteOffsetInBlock =\n                        nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n                    if( nPlanarConfig == PLANARCONFIG_CONTIG )\n                    {\n                        REACHED(12);\n                        nBaseByteOffsetInBlock += (nBand - 1) * nDTSize;\n                    }\n                    else\n                    {\n                        REACHED(13);\n                    }\n\n                    if( bNoXResampling )\n                    {\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        int nBlockXOff = nXOff / nBlockXSize;\n                        int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n                        if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                        {\n                            REACHED(14);\n                            nBlockId += nBlocksPerBand * (nBand - 1);\n                        }\n                        else\n                        {\n                            REACHED(15);\n                        }\n                        int nXOffsetInBlock = nXOff % nBlockXSize;\n\n                        int x = 0;\n                        while( x < nBufXSize )\n                        {\n                            const int nByteOffsetInBlock =\n                                nBaseByteOffsetInBlock +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n                            const toff_t nCurOffset = panOffsets[nBlockId];\n                            const int nUsedBlockWidth =\n                                std::min(\n                                    nBlockXSize - nXOffsetInBlock,\n                                    nBufXSize - x );\n                            int nIters = nUsedBlockWidth;\n\n                            if( nCurOffset == 0 )\n                            {\n                                REACHED(16);\n                                GDALCopyWords(\n                                    &dfNoData, GDT_Float64, 0,\n                                    pabyLocalData, eBufType,\n                                    static_cast<int>(nPixelSpace),\n                                    nIters);\n                                pabyLocalData += nIters * nPixelSpace;\n                            }\n                            else\n                            {\n                                if( bNoTypeChange &&\n                                    nPixelSpace == nBandsPerBlockDTSize )\n                                {\n                                    REACHED(17);\n                                    if( !oFetcher.FetchBytes(\n                                           pabyLocalData,\n                                           nCurOffset + nByteOffsetInBlock,\n                                           (nIters - 1) * nBandsPerBlock + 1,\n                                           nDTSize,\n                                           bIsByteSwapped, bIsComplex,\n                                           nBlockId) )\n                                    {\n                                        return CE_Failure;\n                                    }\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    const GByte* pabyLocalSrcData =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset + nByteOffsetInBlock,\n                                            (nIters - 1) * nBandsPerBlock + 1,\n                                            nDTSize,\n                                            bIsByteSwapped,\n                                            bIsComplex,\n                                            nBlockId );\n                                    if( pabyLocalSrcData == nullptr )\n                                        return CE_Failure;\n\n                                    REACHED(18);\n                                    GDALCopyWords(\n                                        pabyLocalSrcData, eDataType,\n                                        nBandsPerBlockDTSize,\n                                        pabyLocalData, eBufType,\n                                        static_cast<int>(nPixelSpace),\n                                        nIters );\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                            }\n\n                            nXOffsetInBlock = 0;\n                            ++nBlockXOff;\n                            ++nBlockId;\n                            x += nUsedBlockWidth;\n                        }\n                    }\n                    else\n                    {\n                        // Non-contig reading, tiled, potential resampling and\n                        // data type change.\n\n                        const GByte* pabyLocalSrcDataStartLine = nullptr;\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                        int nCurBlockXOff = 0;\n                        int nNextBlockXOff = 0;\n                        toff_t nCurOffset = 0;\n                        for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc)\n                        {\n                            const int nSrcPixel = static_cast<int>(dfSrcX);\n                            if( nSrcPixel >= nNextBlockXOff )\n                            {\n                                const int nBlockXOff = nSrcPixel / nBlockXSize;\n                                nCurBlockXOff = nBlockXOff * nBlockXSize;\n                                nNextBlockXOff = nCurBlockXOff + nBlockXSize;\n                                int nBlockId =\n                                    nBlockXOff + nBlockYOff * nBlocksPerRow;\n                                if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                                {\n                                    REACHED(19);\n                                    nBlockId += nBlocksPerBand * (nBand - 1);\n                                }\n                                else\n                                {\n                                    REACHED(20);\n                                }\n                                nCurOffset = panOffsets[nBlockId];\n                                if( nCurOffset != 0 )\n                                {\n                                    pabyLocalSrcDataStartLine =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset + nBaseByteOffsetInBlock,\n                                            nBlockXSize * nBandsPerBlock,\n                                            nDTSize,\n                                            bIsByteSwapped,\n                                            bIsComplex,\n                                            nBlockId);\n                                    if( pabyLocalSrcDataStartLine == nullptr )\n                                        return CE_Failure;\n                                }\n                            }\n                            const int nXOffsetInBlock =\n                                nSrcPixel - nCurBlockXOff;\n\n                            if( nCurOffset == 0 )\n                            {\n                                REACHED(21);\n                                GDALCopyWords( &dfNoData, GDT_Float64, 0,\n                                               pabyLocalData,\n                                               eBufType, 0,\n                                               1 );\n                                pabyLocalData += nPixelSpace;\n                            }\n                            else\n                            {\n                                const GByte* pabyLocalSrcData =\n                                    pabyLocalSrcDataStartLine +\n                                    nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                                REACHED(22);\n                                if( bByteOnly )\n                                {\n                                    *pabyLocalData = *pabyLocalSrcData;\n                                }\n                                else\n                                {\n                                    GDALCopyWords(pabyLocalSrcData,\n                                                eDataType, 0,\n                                                pabyLocalData,\n                                                eBufType, 0,\n                                                1);\n                                }\n                                pabyLocalData += nPixelSpace;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else  // Non-contig reading, stripped.\n        {\n            for( int iBand = 0; iBand < nBandCount; ++iBand )\n            {\n                const int nBand = panBandMap[iBand];\n                GByte* pabyData =\n                    static_cast<GByte *>(pData) + iBand * nBandSpace;\n                for( int y = 0; y < nBufYSize; ++y )\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                    const int nBlockYOff = nSrcLine / nBlockYSize;\n                    const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                    int nBlockId = nBlockYOff;\n                    if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                    {\n                        REACHED(23);\n                        nBlockId += nBlocksPerBand * (nBand - 1);\n                    }\n                    else\n                    {\n                        REACHED(24);\n                    }\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(25);\n                        GDALCopyWords(\n                            &dfNoData, GDT_Float64, 0,\n                            pabyData + y * nLineSpace,\n                            eBufType,\n                            static_cast<int>(nPixelSpace),\n                            nBufXSize);\n                    }\n                    else\n                    {\n                        int nBaseByteOffsetInBlock =\n                            (nYOffsetInBlock * nBlockXSize + nXOff) *\n                            nBandsPerBlockDTSize;\n                        if( nPlanarConfig == PLANARCONFIG_CONTIG )\n                            nBaseByteOffsetInBlock += (nBand - 1) * nDTSize;\n\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        if( bNoXResamplingNoTypeChange &&\n                            nPixelSpace == nBandsPerBlockDTSize )\n                        {\n                            REACHED(26);\n                            if( !oFetcher.FetchBytes(\n                                pabyLocalData,\n                                nCurOffset + nBaseByteOffsetInBlock,\n                                (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId) )\n                            {\n                                return CE_Failure;\n                            }\n                        }\n                        else\n                        {\n                            const GByte* pabyLocalSrcData = oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetInBlock,\n                                (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId);\n                            if( pabyLocalSrcData == nullptr )\n                                return CE_Failure;\n\n                            if( bNoXResamplingNoTypeChange )\n                            {\n                                REACHED(27);\n                                GDALCopyWords(pabyLocalSrcData,\n                                              eDataType, nBandsPerBlockDTSize,\n                                              pabyLocalData, eBufType,\n                                              static_cast<int>(nPixelSpace),\n                                              nBufXSize);\n                            }\n                            else if( bByteOnly )\n                            {\n                                REACHED(28);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for( int x = 0;\n                                     x < nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc )\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast<int>(dfSrcX);\n                                    pabyLocalData[x * nPixelSpace] =\n                                        pabyLocalSrcData[nSrcPixelMinusXOff *\n                                                         nBandsPerBlockDTSize];\n                                }\n                            }\n                            else\n                            {\n                                REACHED(29);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for( int x = 0;\n                                     x < nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc )\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast<int>(dfSrcX);\n                                    GDALCopyWords(\n                                        pabyLocalSrcData +\n                                        nSrcPixelMinusXOff *\n                                        nBandsPerBlockDTSize,\n                                        eDataType, 0,\n                                        pabyLocalData + x * nPixelSpace,\n                                        eBufType, 0,\n                                        1 );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           DirectIO()                                 */\n/************************************************************************/\n\n// Reads directly bytes from the file using ReadMultiRange(), and by-pass\n// block reading. Restricted to simple TIFF configurations\n// (uncompressed data, standard data types). Particularly useful to extract\n// sub-windows of data on a large /vsicurl dataset).\n// Returns -1 if DirectIO() can't be supported on that file.\n\nint GTiffDataset::DirectIO( GDALRWFlag eRWFlag,\n                            int nXOff, int nYOff, int nXSize, int nYSize,\n                            void * pData, int nBufXSize, int nBufYSize,\n                            GDALDataType eBufType,\n                            int nBandCount, int *panBandMap,\n                            GSpacing nPixelSpace, GSpacing nLineSpace,\n                            GSpacing nBandSpace,\n                            GDALRasterIOExtraArg* psExtraArg )\n{\n    const GDALDataType eDataType = GetRasterBand(1)->GetRasterDataType();\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(eRWFlag == GF_Read &&\n          nCompression == COMPRESSION_NONE &&\n          (nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           nPhotometric == PHOTOMETRIC_RGB ||\n           nPhotometric == PHOTOMETRIC_PALETTE) &&\n          nBitsPerSample == nDTSizeBits &&\n          SetDirectory() /* Very important to make hTIFF uptodate! */ ) )\n    {\n        return -1;\n    }\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) &&\n        psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n    // If the file is band interleave or only one band is requested, then\n    // fallback to band DirectIO.\n    bool bUseBandRasterIO = false;\n    if( nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1 )\n    {\n        bUseBandRasterIO = true;\n    }\n    else\n    {\n        // For simplicity, only deals with \"naturally ordered\" bands.\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            if( panBandMap[iBand] != iBand + 1)\n            {\n                bUseBandRasterIO = true;\n                break;\n            }\n        }\n    }\n    if( bUseBandRasterIO )\n    {\n        CPLErr eErr = CE_None;\n        for( int iBand = 0; eErr == CE_None && iBand < nBandCount; ++iBand )\n        {\n            eErr = GetRasterBand(panBandMap[iBand])->RasterIO(\n                eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                static_cast<GByte *>(pData) + iBand * nBandSpace,\n                nBufXSize, nBufYSize,\n                eBufType,\n                nPixelSpace, nLineSpace,\n                psExtraArg );\n        }\n        return eErr;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"DirectIO(%d,%d,%d,%d -> %dx%d)\",\n              nXOff, nYOff, nXSize, nYSize,\n              nBufXSize, nBufYSize );\n#endif\n\n    // No need to look if overviews can satisfy the request as it has already */\n    // been done in GTiffDataset::IRasterIO().\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( GetAccess() == GA_Update )\n    {\n        FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( hTIFF ) );\n    }\n\n    if( TIFFIsTiled( hTIFF ) )\n    {\n        if( m_pTempBufferForCommonDirectIO == nullptr )\n        {\n            const int nDTSize = nDTSizeBits / 8;\n            m_nTempBufferForCommonDirectIOSize =\n                static_cast<size_t>(nBlockXSize * nBlockYSize * nDTSize *\n                ((nPlanarConfig == PLANARCONFIG_CONTIG) ? nBands : 1));\n\n            m_pTempBufferForCommonDirectIO =\n                static_cast<GByte *>(\n                    VSI_MALLOC_VERBOSE(m_nTempBufferForCommonDirectIOSize) );\n            if( m_pTempBufferForCommonDirectIO == nullptr )\n                return CE_Failure;\n        }\n\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n        FetchBufferDirectIO oFetcher(fp, m_pTempBufferForCommonDirectIO,\n                                     m_nTempBufferForCommonDirectIOSize);\n\n        return CommonDirectIO( oFetcher,\n                               nXOff, nYOff, nXSize, nYSize,\n                               pData, nBufXSize, nBufYSize,\n                               eBufType,\n                               nBandCount, panBandMap,\n                               nPixelSpace, nLineSpace,\n                              nBandSpace );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    void** ppData =\n        static_cast<void **>( VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void*)) );\n    vsi_l_offset* panOffsets =\n        static_cast<vsi_l_offset *>(\n            VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)) );\n    size_t* panSizes =\n        static_cast<size_t *>( VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)) );\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void* pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands = nBands;\n    const int nSrcPixelSize = nDTSize * nContigBands;\n\n    if( ppData == nullptr || panOffsets == nullptr || panSizes == nullptr )\n    {\n        eErr = CE_Failure;\n    }\n    // For now we always allocate a temp buffer as it is easier.\n    else\n        // if( nXSize != nBufXSize || nYSize != nBufYSize ||\n        //   eBufType != eDataType ||\n        //   nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n        //   check if the user buffer is large enough )\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC_VERBOSE(nReqXSize * nReqYSize * nSrcPixelSize);\n        if( pTmpBuffer == nullptr )\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    for( int iLine = 0; eErr == CE_None && iLine < nReqYSize; ++iLine )\n    {\n        ppData[iLine] =\n            static_cast<GByte *>(pTmpBuffer) +\n            iLine * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if( nBufYSize < nYSize )  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast<int>((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n        const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if( panOffsets[iLine] == 0)  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff + nYOffsetInBlock * nBlockXSize) * nSrcPixelSize;\n        panSizes[iLine] = nReqXSize * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if( eErr == CE_None )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n        const int nRet =\n            VSIFReadMultiRangeL(nReqYSize, ppData, panOffsets, panSizes, fp);\n        if( nRet != 0 )\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if( eErr == CE_None && TIFFIsByteSwapped(hTIFF) )\n    {\n        for( int iLine = 0; iLine < nReqYSize; ++iLine )\n        {\n            if( GDALDataTypeIsComplex(eDataType) )\n                GDALSwapWords( ppData[iLine], nDTSize / 2,\n                               2 * nReqXSize * nContigBands, nDTSize / 2);\n            else\n                GDALSwapWords( ppData[iLine], nDTSize,\n                               nReqXSize * nContigBands, nDTSize);\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    if( eErr == CE_None && pTmpBuffer != nullptr )\n    {\n        for( int iY = 0; iY < nBufYSize; ++iY )\n        {\n            const int iSrcY =\n                nBufYSize <= nYSize ?\n                iY : static_cast<int>((iY + 0.5) * dfSrcYInc);\n            // Optimization: no resampling, no data type change, number of\n            // bands requested == number of bands and buffer is packed\n            // pixel-interleaved.\n            if( nBufXSize == nXSize && nContigBands == nBandCount &&\n                eDataType == eBufType &&\n                nBandSpace == nDTSize &&\n                nPixelSpace == nBandCount * nBandSpace )\n            {\n                memcpy(\n                    static_cast<GByte *>(pData) + iY * nLineSpace,\n                    ppData[iSrcY],\n                    static_cast<size_t>(nReqXSize * nPixelSpace) );\n            }\n            // Other optimization: no resampling, no data type change,\n            // data type is Byte.\n            else if( nBufXSize == nXSize &&\n                     eDataType == eBufType && eDataType == GDT_Byte )\n            {\n                GByte* pabySrcData = static_cast<GByte *>(ppData[iSrcY]);\n                GByte* pabyDstData =\n                    static_cast<GByte *>(pData) + iY * nLineSpace;\n                if( nBandSpace == 1 && nPixelSpace > nBandCount )\n                {\n                    // Buffer is pixel-interleaved (with some stridding\n                    // between pixels).\n                    CopyContigByteMultiBand( pabySrcData, nSrcPixelSize,\n                                             pabyDstData,\n                                             static_cast<int>(nPixelSpace),\n                                             nBufXSize, nBandCount );\n                }\n                else\n                {\n                    for( int iBand = 0; iBand < nBandCount; ++iBand )\n                    {\n                        GDALCopyWords(\n                            pabySrcData + iBand, GDT_Byte, nSrcPixelSize,\n                            pabyDstData + iBand * nBandSpace,\n                            GDT_Byte, static_cast<int>(nPixelSpace),\n                            nBufXSize );\n                    }\n                }\n            }\n            else  // General case.\n            {\n                for( int iBand = 0; iBand < nBandCount; ++iBand )\n                {\n                    GByte* pabySrcData =\n                        static_cast<GByte *>(ppData[iSrcY]) + iBand * nDTSize;\n                    GByte* pabyDstData =\n                        static_cast<GByte *>(pData) +\n                        iBand * nBandSpace + iY * nLineSpace;\n                    if( eDataType == GDT_Byte && eBufType == GDT_Byte )\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for( int iX = 0;\n                             iX < nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast<int>(dfSrcX);\n                            pabyDstData[iX * nPixelSpace] =\n                                pabySrcData[iSrcX * nSrcPixelSize];\n                        }\n                    }\n                    else\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for( int iX = 0;\n                             iX < nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast<int>(dfSrcX);\n                            GDALCopyWords( pabySrcData + iSrcX * nSrcPixelSize,\n                                        eDataType, 0,\n                                        pabyDstData + iX * nPixelSpace,\n                                        eBufType, 0, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                         CacheMultiRange()                            */\n/************************************************************************/\n\nvoid* GTiffRasterBand::CacheMultiRange( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nBufXSize, int nBufYSize,\n                                        GDALRasterIOExtraArg* psExtraArg )\n{\n    void* pBufferedData = nullptr;\n    // Same logic as in GDALRasterBand::IRasterIO()\n    double dfXOff = nXOff;\n    double dfYOff = nYOff;\n    double dfXSize = nXSize;\n    double dfYSize = nYSize;\n    if( psExtraArg->bFloatingPointWindowValidity )\n    {\n        dfXOff = psExtraArg->dfXOff;\n        dfYOff = psExtraArg->dfYOff;\n        dfXSize = psExtraArg->dfXSize;\n        dfYSize = psExtraArg->dfYSize;\n    }\n    const double dfSrcXInc = dfXSize / static_cast<double>( nBufXSize );\n    const double dfSrcYInc = dfYSize / static_cast<double>( nBufYSize );\n    const double EPS = 1e-10;\n    const int nBlockX1 = static_cast<int>(std::max(0.0, (0+0.5) * dfSrcXInc + dfXOff + EPS)) / nBlockXSize;\n    const int nBlockY1 = static_cast<int>(std::max(0.0, (0+0.5) * dfSrcYInc + dfYOff + EPS)) / nBlockYSize;\n    const int nBlockX2 = static_cast<int>(std::min(static_cast<double>(nRasterXSize - 1), (nBufXSize-1+0.5) * dfSrcXInc + dfXOff + EPS)) / nBlockXSize;\n    const int nBlockY2 = static_cast<int>(std::min(static_cast<double>(nRasterYSize - 1), (nBufYSize-1+0.5) * dfSrcYInc + dfYOff + EPS)) / nBlockYSize;\n\n    thandle_t th = TIFFClientdata( poGDS->hTIFF );\n    if( poGDS->SetDirectory() && !VSI_TIFFHasCachedRanges(th) )\n    {\n        std::vector< std::pair<vsi_l_offset, size_t> > aOffsetSize;\n        size_t nTotalSize = 0;\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        const unsigned int nMaxRawBlockCacheSize =\n            atoi(CPLGetConfigOption(\"GDAL_MAX_RAW_BLOCK_CACHE_SIZE\",\n                                    \"10485760\"));\n        for( int iY = nBlockY1; iY <= nBlockY2; iY ++)\n        {\n            for( int iX = nBlockX1; iX <= nBlockX2; iX ++)\n            {\n                GDALRasterBlock* poBlock = TryGetLockedBlockRef(iX, iY);\n                if( poBlock != nullptr )\n                {\n                    poBlock->DropLock();\n                    continue;\n                }\n                int nBlockId = iX + iY * nBlocksPerRow;\n                if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n                    nBlockId += (nBand - 1) * poGDS->nBlocksPerBand;\n                vsi_l_offset nOffset = 0;\n                vsi_l_offset nSize = 0;\n                if( poGDS->IsBlockAvailable(nBlockId, &nOffset, &nSize) )\n                {\n                    if( nTotalSize + nSize < nMaxRawBlockCacheSize )\n                    {\n#ifdef DEBUG_VERBOSE\n                        CPLDebug(\"GTiff\",\n                                 \"Precaching for block (%d, %d), \"\n                                 CPL_FRMT_GUIB \"-\" CPL_FRMT_GUIB,\n                                 iX, iY,\n                                 nOffset,\n                                 nOffset + static_cast<size_t>(nSize) - 1);\n#endif\n                        aOffsetSize.push_back(\n                            std::pair<vsi_l_offset, size_t>\n                                (nOffset, static_cast<size_t>(nSize)) );\n                        nTotalSize += static_cast<size_t>(nSize);\n                    }\n                }\n            }\n        }\n\n        std::sort(aOffsetSize.begin(), aOffsetSize.end());\n\n        if( nTotalSize > 0 )\n        {\n            pBufferedData = VSI_MALLOC_VERBOSE(nTotalSize);\n            if( pBufferedData )\n            {\n                std::vector<vsi_l_offset> anOffsets;\n                std::vector<size_t> anSizes;\n                std::vector<void*> apData;\n                size_t nAccOffset = 0;\n                for( size_t i = 0; i < aOffsetSize.size(); i++ )\n                {\n                    anOffsets.push_back(aOffsetSize[i].first);\n                    anSizes.push_back(aOffsetSize[i].second);\n                    apData.push_back(static_cast<GByte*>(pBufferedData) + nAccOffset);\n                    nAccOffset += aOffsetSize[i].second;\n                }\n                VSILFILE* fp = VSI_TIFFGetVSILFile(th);\n                if( VSIFReadMultiRangeL(\n                                    static_cast<int>(aOffsetSize.size()),\n                                    &apData[0],\n                                    &anOffsets[0],\n                                    &anSizes[0],\n                                    fp ) == 0 )\n                {\n                    VSI_TIFFSetCachedRanges( th,\n                                             static_cast<int>(aOffsetSize.size()),\n                                             &apData[0],\n                                             &anOffsets[0],\n                                             &anSizes[0] );\n                }\n            }\n        }\n    }\n    return pBufferedData;\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IRasterIO( GDALRWFlag eRWFlag,\n                                   int nXOff, int nYOff, int nXSize, int nYSize,\n                                   void * pData, int nBufXSize, int nBufYSize,\n                                   GDALDataType eBufType,\n                                   GSpacing nPixelSpace, GSpacing nLineSpace,\n                                   GDALRasterIOExtraArg* psExtraArg )\n{\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"RasterIO(%d, %d, %d, %d, %d, %d)\",\n              nXOff, nYOff, nXSize, nYSize, nBufXSize, nBufYSize );\n#endif\n\n    // Try to pass the request to the most appropriate overview dataset.\n    if( nBufXSize < nXSize && nBufYSize < nYSize )\n    {\n        int bTried = FALSE;\n        ++poGDS->nJPEGOverviewVisibilityCounter;\n        const CPLErr eErr =\n            TryOverviewRasterIO( eRWFlag,\n                                 nXOff, nYOff, nXSize, nYSize,\n                                 pData, nBufXSize, nBufYSize,\n                                 eBufType,\n                                 nPixelSpace, nLineSpace,\n                                 psExtraArg,\n                                 &bTried );\n        --poGDS->nJPEGOverviewVisibilityCounter;\n        if( bTried )\n            return eErr;\n    }\n\n    if( poGDS->eVirtualMemIOUsage != VIRTUAL_MEM_IO_NO )\n    {\n        const int nErr = poGDS->VirtualMemIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            1, &nBand, nPixelSpace, nLineSpace, 0, psExtraArg);\n        if( nErr >= 0 )\n            return static_cast<CPLErr>(nErr);\n    }\n    if( poGDS->bDirectIO )\n    {\n        int nErr = DirectIO(eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                            pData, nBufXSize, nBufYSize, eBufType,\n                            nPixelSpace, nLineSpace, psExtraArg);\n        if( nErr >= 0 )\n            return static_cast<CPLErr>(nErr);\n    }\n\n    void* pBufferedData = nullptr;\n    if( poGDS->eAccess == GA_ReadOnly &&\n        eRWFlag == GF_Read &&\n        poGDS->HasOptimizedReadMultiRange() )\n    {\n        pBufferedData = CacheMultiRange(nXOff, nYOff, nXSize, nYSize,\n                                        nBufXSize, nBufYSize,\n                                        psExtraArg);\n    }\n\n    if( poGDS->nBands != 1 &&\n        poGDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n        eRWFlag == GF_Read &&\n        nXSize == nBufXSize && nYSize == nBufYSize )\n    {\n        const int nBlockX1 = nXOff / nBlockXSize;\n        const int nBlockY1 = nYOff / nBlockYSize;\n        const int nBlockX2 = (nXOff + nXSize - 1) / nBlockXSize;\n        const int nBlockY2 = (nYOff + nYSize - 1) / nBlockYSize;\n        const int nXBlocks = nBlockX2 - nBlockX1 + 1;\n        const int nYBlocks = nBlockY2 - nBlockY1 + 1;\n        const GIntBig nRequiredMem =\n            static_cast<GIntBig>(poGDS->nBands) * nXBlocks * nYBlocks *\n            nBlockXSize * nBlockYSize *\n            GDALGetDataTypeSizeBytes(eDataType);\n        if( nRequiredMem > GDALGetCacheMax64() )\n        {\n            if( !poGDS->bHasWarnedDisableAggressiveBandCaching )\n            {\n                CPLDebug( \"GTiff\",\n                          \"Disable aggressive band caching. \"\n                          \"Cache not big enough. \"\n                          \"At least \" CPL_FRMT_GIB \" bytes necessary\",\n                          nRequiredMem );\n                poGDS->bHasWarnedDisableAggressiveBandCaching = true;\n            }\n            poGDS->bLoadingOtherBands = true;\n        }\n    }\n\n    ++poGDS->nJPEGOverviewVisibilityCounter;\n    const CPLErr eErr =\n        GDALPamRasterBand::IRasterIO( eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                                      pData, nBufXSize, nBufYSize, eBufType,\n                                      nPixelSpace, nLineSpace, psExtraArg );\n    --poGDS->nJPEGOverviewVisibilityCounter;\n\n    poGDS->bLoadingOtherBands = false;\n\n    if( pBufferedData )\n    {\n        VSIFree( pBufferedData );\n        VSI_TIFFSetCachedRanges( TIFFClientdata( poGDS->hTIFF ),\n                                 0, nullptr, nullptr, nullptr );\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRasterBand::IGetDataCoverageStatus( int nXOff, int nYOff,\n                                             int nXSize, int nYSize,\n                                             int nMaskFlagStop,\n                                             double* pdfDataPct)\n{\n    if( eAccess == GA_Update )\n        poGDS->FlushCache();\n\n    if( !poGDS->SetDirectory() )\n    {\n        return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n               GDAL_DATA_COVERAGE_STATUS_DATA;\n    }\n\n    const int iXBlockStart = nXOff / nBlockXSize;\n    const int iXBlockEnd = (nXOff + nXSize - 1) / nBlockXSize;\n    const int iYBlockStart = nYOff / nBlockYSize;\n    const int iYBlockEnd = (nYOff + nYSize - 1) / nBlockYSize;\n    int nStatus = 0;\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( poGDS->hTIFF ));\n    GIntBig nPixelsData = 0;\n    // We need to compute this here as it might not have been computed\n    // previously (which sucks...)\n    nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    for( int iY = iYBlockStart; iY <= iYBlockEnd; ++iY )\n    {\n        for( int iX = iXBlockStart; iX <= iXBlockEnd; ++iX )\n        {\n            const int nBlockIdBand0 =\n                iX + iY * nBlocksPerRow;\n            int nBlockId = nBlockIdBand0;\n            if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n                nBlockId = nBlockIdBand0 + (nBand - 1) * poGDS->nBlocksPerBand;\n            vsi_l_offset nOffset = 0;\n            vsi_l_offset nLength = 0;\n            bool bHasData = false;\n            if( !poGDS->IsBlockAvailable(nBlockId,&nOffset,&nLength) )\n            {\n                nStatus |= GDAL_DATA_COVERAGE_STATUS_EMPTY;\n            }\n            else\n            {\n                if( poGDS->nCompression == COMPRESSION_NONE &&\n                    poGDS->eAccess == GA_ReadOnly &&\n                    (!bNoDataSet || dfNoDataValue == 0.0) )\n                {\n                    VSIRangeStatus eStatus =\n                          VSIFGetRangeStatusL( fp, nOffset, nLength );\n                    if( eStatus == VSI_RANGE_STATUS_HOLE )\n                    {\n                        nStatus |= GDAL_DATA_COVERAGE_STATUS_EMPTY;\n                    }\n                    else\n                    {\n                        bHasData = true;\n                    }\n                }\n                else\n                {\n                    bHasData = true;\n                }\n            }\n            if( bHasData )\n            {\n                const int nXBlockRight =\n                    ( iX * nBlockXSize > INT_MAX - nBlockXSize ) ? INT_MAX :\n                    (iX + 1) * nBlockXSize;\n                const int nYBlockBottom =\n                    ( iY * nBlockYSize > INT_MAX - nBlockYSize ) ? INT_MAX :\n                    (iY + 1) * nBlockYSize;\n\n                nPixelsData +=\n                    (std::min( nXBlockRight, nXOff + nXSize ) -\n                     std::max( iX * nBlockXSize, nXOff )) *\n                    (std::min( nYBlockBottom, nYOff + nYSize ) -\n                     std::max( iY * nBlockYSize, nYOff ));\n                nStatus |= GDAL_DATA_COVERAGE_STATUS_DATA;\n            }\n            if( nMaskFlagStop != 0 && (nMaskFlagStop & nStatus) != 0 )\n            {\n                if( pdfDataPct )\n                    *pdfDataPct = -1.0;\n                return nStatus;\n            }\n        }\n    }\n    if( pdfDataPct )\n        *pdfDataPct =\n          100.0 * nPixelsData /\n          (static_cast<GIntBig>(nXSize) * nYSize);\n    return nStatus;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                    void * pImage )\n\n{\n    if( !poGDS->SetDirectory() )\n        return CE_Failure;\n\n    int nBlockBufSize = 0;\n    if( TIFFIsTiled(poGDS->hTIFF) )\n    {\n        nBlockBufSize = static_cast<int>(TIFFTileSize( poGDS->hTIFF ));\n    }\n    else\n    {\n        CPLAssert( nBlockXOff == 0 );\n        nBlockBufSize = static_cast<int>(TIFFStripSize( poGDS->hTIFF ));\n    }\n\n    CPLAssert(nBlocksPerRow != 0);\n    const int nBlockIdBand0 =\n        nBlockXOff + nBlockYOff * nBlocksPerRow;\n    int nBlockId = nBlockIdBand0;\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId = nBlockIdBand0 + (nBand - 1) * poGDS->nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      The bottom most partial tiles and strips are sometimes only     */\n/*      partially encoded.  This code reduces the requested data so     */\n/*      an error won't be reported in this case. (#1179)                */\n/* -------------------------------------------------------------------- */\n    int nBlockReqSize = nBlockBufSize;\n\n    if( nBlockYOff * nBlockYSize > nRasterYSize - nBlockYSize )\n    {\n        nBlockReqSize = (nBlockBufSize / nBlockYSize)\n            * (nBlockYSize - static_cast<int>(\n                (static_cast<GIntBig>(nBlockYOff + 1) * nBlockYSize)\n                    % nRasterYSize));\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle the case of a strip or tile that doesn't exist yet.      */\n/*      Just set to zeros and return.                                   */\n/* -------------------------------------------------------------------- */\n    vsi_l_offset nOffset = 0;\n    bool bErrOccurred = false;\n    if( nBlockId != poGDS->nLoadedBlock &&\n        !poGDS->IsBlockAvailable(nBlockId, &nOffset, nullptr, &bErrOccurred) )\n    {\n        NullBlock( pImage );\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n    if( poGDS->bStreamingIn &&\n        !(poGDS->nBands > 1 &&\n          poGDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n          nBlockId == poGDS->nLoadedBlock) )\n    {\n        if( nOffset < VSIFTellL(poGDS->fpL) )\n        {\n            CPLError( CE_Failure, CPLE_NotSupported,\n                      \"Trying to load block %d at offset \" CPL_FRMT_GUIB\n                      \" whereas current pos is \" CPL_FRMT_GUIB\n                      \" (backward read not supported)\",\n                      nBlockId, static_cast<GUIntBig>(nOffset),\n                      static_cast<GUIntBig>(VSIFTellL(poGDS->fpL)) );\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case (separate, onesampleperpixel)                */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nBands == 1\n        || poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        if( nBlockReqSize < nBlockBufSize )\n            memset( pImage, 0, nBlockBufSize );\n\n        CPLErr eErr = CE_None;\n        if( TIFFIsTiled( poGDS->hTIFF ) )\n        {\n            if( TIFFReadEncodedTile( poGDS->hTIFF, nBlockId, pImage,\n                                     nBlockReqSize ) == -1\n                && !poGDS->bIgnoreReadErrors )\n            {\n                memset( pImage, 0, nBlockBufSize );\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadEncodedTile() failed.\" );\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n            if( TIFFReadEncodedStrip( poGDS->hTIFF, nBlockId, pImage,\n                                      nBlockReqSize ) == -1\n                && !poGDS->bIgnoreReadErrors )\n            {\n                memset( pImage, 0, nBlockBufSize );\n                CPLError( CE_Failure, CPLE_AppDefined,\n                        \"TIFFReadEncodedStrip() failed.\" );\n\n                eErr = CE_Failure;\n            }\n        }\n\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load desired block                                              */\n/* -------------------------------------------------------------------- */\n    {\n        const CPLErr eErr = poGDS->LoadBlockBuf( nBlockId );\n        if( eErr != CE_None )\n        {\n            memset( pImage, 0,\n                    nBlockXSize * nBlockYSize\n                    * GDALGetDataTypeSizeBytes(eDataType) );\n            return eErr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for YCbCr subsampled data.                         */\n/* -------------------------------------------------------------------- */\n\n    // Removed \"Special case for YCbCr\" added in r9432; disabled in r9470\n\n    const int nWordBytes = poGDS->nBitsPerSample / 8;\n    GByte* pabyImage = poGDS->pabyBlockBuf + (nBand - 1) * nWordBytes;\n\n    GDALCopyWords(pabyImage, eDataType, poGDS->nBands * nWordBytes,\n                  pImage, eDataType, nWordBytes,\n                  nBlockXSize * nBlockYSize);\n\n    const CPLErr eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       FillCacheForOtherBands()                       */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::FillCacheForOtherBands( int nBlockXOff, int nBlockYOff )\n\n{\n/* -------------------------------------------------------------------- */\n/*      In the fairly common case of pixel interleaved 8bit data        */\n/*      that is multi-band, lets push the rest of the data into the     */\n/*      block cache too, to avoid (hopefully) having to redecode it.    */\n/*                                                                      */\n/*      Our following logic actually depends on the fact that the       */\n/*      this block is already loaded, so subsequent calls will end      */\n/*      up back in this method and pull from the loaded block.          */\n/*                                                                      */\n/*      Be careful not entering this portion of code from               */\n/*      the other bands, otherwise we'll get very deep nested calls     */\n/*      and O(nBands^2) performance !                                   */\n/*                                                                      */\n/*      If there are many bands and the block cache size is not big     */\n/*      enough to accommodate the size of all the blocks, don't enter   */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n    if( poGDS->nBands != 1 &&\n        poGDS->nBands < 128 && // avoid caching for datasets with too many bands\n        !poGDS->bLoadingOtherBands &&\n        nBlockXSize * nBlockYSize * GDALGetDataTypeSizeBytes(eDataType) <\n        GDALGetCacheMax64() / poGDS->nBands )\n    {\n        poGDS->bLoadingOtherBands = true;\n\n        for( int iOtherBand = 1; iOtherBand <= poGDS->nBands; ++iOtherBand )\n        {\n            if( iOtherBand == nBand )\n                continue;\n\n            GDALRasterBlock *poBlock = poGDS->GetRasterBand(iOtherBand)->\n                GetLockedBlockRef(nBlockXOff,nBlockYOff);\n            if( poBlock == nullptr )\n            {\n                eErr = CE_Failure;\n                break;\n            }\n            poBlock->DropLock();\n        }\n\n        poGDS->bLoadingOtherBands = false;\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                     void * pImage )\n\n{\n    if( poGDS->bDebugDontWriteBlocks )\n        return CE_None;\n\n    if( poGDS->bWriteErrorInFlushBlockBuf )\n    {\n        // Report as an error if a previously loaded block couldn't be written\n        // correctly.\n        poGDS->bWriteErrorInFlushBlockBuf = false;\n        return CE_Failure;\n    }\n\n    if( !poGDS->SetDirectory() )\n        return CE_Failure;\n\n    CPLAssert( poGDS != nullptr\n               && nBlockXOff >= 0\n               && nBlockYOff >= 0\n               && pImage != nullptr );\n    CPLAssert(nBlocksPerRow != 0);\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of \"separate\" images                                */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE\n        || poGDS->nBands == 1 )\n    {\n        const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow\n            + (nBand - 1) * poGDS->nBlocksPerBand;\n\n        const CPLErr eErr =\n            poGDS->WriteEncodedTileOrStrip(nBlockId, pImage, true);\n\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of pixel interleaved (PLANARCONFIG_CONTIG) images.  */\n/* -------------------------------------------------------------------- */\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n     // Why 10 ? Somewhat arbitrary\n    constexpr int MAX_BANDS_FOR_DIRTY_CHECK = 10;\n    GDALRasterBlock* apoBlocks[MAX_BANDS_FOR_DIRTY_CHECK] = {};\n    const int nBands = poGDS->nBands;\n    bool bAllBlocksDirty = false;\n\n/* -------------------------------------------------------------------- */\n/*     If all blocks are cached and dirty then we do not need to reload */\n/*     the tile/strip from disk                                         */\n/* -------------------------------------------------------------------- */\n    if( nBands <= MAX_BANDS_FOR_DIRTY_CHECK )\n    {\n        bAllBlocksDirty = true;\n        for( int iBand = 0; iBand < nBands; ++iBand )\n        {\n            if( iBand + 1 != nBand )\n            {\n                apoBlocks[iBand] =\n                    cpl::down_cast<GTiffRasterBand *>(\n                        poGDS->GetRasterBand( iBand + 1 ))\n                            ->TryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n                if( apoBlocks[iBand] == nullptr )\n                {\n                    bAllBlocksDirty = false;\n                }\n                else if( !apoBlocks[iBand]->GetDirty() )\n                {\n                    apoBlocks[iBand]->DropLock();\n                    apoBlocks[iBand] = nullptr;\n                    bAllBlocksDirty = false;\n                }\n            }\n            else\n                apoBlocks[iBand] = nullptr;\n        }\n#if DEBUG_VERBOSE\n        if( bAllBlocksDirty )\n            CPLDebug(\"GTIFF\", \"Saved reloading block %d\", nBlockId);\n        else\n            CPLDebug(\"GTIFF\", \"Must reload block %d\", nBlockId);\n#endif\n    }\n\n    {\n        const CPLErr eErr = poGDS->LoadBlockBuf( nBlockId, !bAllBlocksDirty );\n        if( eErr != CE_None )\n        {\n            if( nBands <= MAX_BANDS_FOR_DIRTY_CHECK )\n            {\n                for( int iBand = 0; iBand < nBands; ++iBand )\n                {\n                    if( apoBlocks[iBand] != nullptr )\n                        apoBlocks[iBand]->DropLock();\n                }\n            }\n            return eErr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      On write of pixel interleaved data, we might as well flush      */\n/*      out any other bands that are dirty in our cache.  This is       */\n/*      especially helpful when writing compressed blocks.              */\n/* -------------------------------------------------------------------- */\n    const int nWordBytes = poGDS->nBitsPerSample / 8;\n\n    for( int iBand = 0; iBand < nBands; ++iBand )\n    {\n        const GByte *pabyThisImage = nullptr;\n        GDALRasterBlock *poBlock = nullptr;\n\n        if( iBand + 1 == nBand )\n        {\n            pabyThisImage = static_cast<GByte *>( pImage );\n        }\n        else\n        {\n            if( nBands <= MAX_BANDS_FOR_DIRTY_CHECK )\n                poBlock = apoBlocks[iBand];\n            else\n                poBlock = cpl::down_cast<GTiffRasterBand *>(\n                    poGDS->GetRasterBand( iBand + 1 ))\n                        ->TryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n            if( poBlock == nullptr )\n                continue;\n\n            if( !poBlock->GetDirty() )\n            {\n                poBlock->DropLock();\n                continue;\n            }\n\n            pabyThisImage = static_cast<GByte *>( poBlock->GetDataRef() );\n        }\n\n        GByte *pabyOut = poGDS->pabyBlockBuf + iBand*nWordBytes;\n\n        GDALCopyWords(pabyThisImage, eDataType, nWordBytes,\n                      pabyOut, eDataType, nWordBytes * nBands,\n                      nBlockXSize * nBlockYSize);\n\n        if( poBlock != nullptr )\n        {\n            poBlock->MarkClean();\n            poBlock->DropLock();\n        }\n    }\n\n    if( bAllBlocksDirty )\n    {\n        // We can synchronously write the block now.\n        const CPLErr eErr =\n            poGDS->WriteEncodedTileOrStrip(nBlockId, poGDS->pabyBlockBuf, true);\n        poGDS->bLoadedBlockDirty = false;\n        return eErr;\n    }\n\n    poGDS->bLoadedBlockDirty = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           SetDescription()                           */\n/************************************************************************/\n\nvoid GTiffRasterBand::SetDescription( const char *pszDescription )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( pszDescription == nullptr )\n        pszDescription = \"\";\n\n    if( osDescription != pszDescription )\n        poGDS->bMetadataChanged = true;\n\n    osDescription = pszDescription;\n}\n\n/************************************************************************/\n/*                           GetDescription()                           */\n/************************************************************************/\n\nconst char *GTiffRasterBand::GetDescription() const\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    return osDescription;\n}\n\n/************************************************************************/\n/*                             GetOffset()                              */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetOffset( int *pbSuccess )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( pbSuccess )\n        *pbSuccess = bHaveOffsetScale;\n    return dfOffset;\n}\n\n/************************************************************************/\n/*                             SetOffset()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetOffset( double dfNewValue )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( !bHaveOffsetScale || dfNewValue != dfOffset )\n        poGDS->bMetadataChanged = true;\n\n    bHaveOffsetScale = true;\n    dfOffset = dfNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                              GetScale()                              */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetScale( int *pbSuccess )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( pbSuccess )\n        *pbSuccess = bHaveOffsetScale;\n    return dfScale;\n}\n\n/************************************************************************/\n/*                              SetScale()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetScale( double dfNewValue )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( !bHaveOffsetScale || dfNewValue != dfScale )\n        poGDS->bMetadataChanged = true;\n\n    bHaveOffsetScale = true;\n    dfScale = dfNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            GetUnitType()                             */\n/************************************************************************/\n\nconst char* GTiffRasterBand::GetUnitType()\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n    if( osUnitType.empty() )\n    {\n        poGDS->LookForProjection();\n        return poGDS->m_osVertUnit.c_str();\n    }\n\n    return osUnitType.c_str();\n}\n\n/************************************************************************/\n/*                           SetUnitType()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetUnitType( const char* pszNewValue )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    CPLString osNewValue(pszNewValue ? pszNewValue : \"\");\n    if( osNewValue.compare(osUnitType) != 0 )\n        poGDS->bMetadataChanged = true;\n\n    osUnitType = osNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                      GetMetadataDomainList()                         */\n/************************************************************************/\n\nchar **GTiffRasterBand::GetMetadataDomainList()\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    return CSLDuplicate(oGTiffMDMD.GetDomainList());\n}\n\n/************************************************************************/\n/*                            GetMetadata()                             */\n/************************************************************************/\n\nchar **GTiffRasterBand::GetMetadata( const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        poGDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    return oGTiffMDMD.GetMetadata( pszDomain );\n}\n\n/************************************************************************/\n/*                            SetMetadata()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetMetadata( char ** papszMD, const char *pszDomain )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( poGDS->bStreamingOut && poGDS->bCrystalized )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Cannot modify metadata at that point in a streamed \"\n                  \"output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        if( papszMD != nullptr || GetMetadata(pszDomain) != nullptr )\n        {\n            poGDS->bMetadataChanged = true;\n            // Cancel any existing metadata from PAM file.\n            if( eAccess == GA_Update &&\n                GDALPamRasterBand::GetMetadata(pszDomain) != nullptr )\n                GDALPamRasterBand::SetMetadata(nullptr, pszDomain);\n        }\n    }\n\n    return oGTiffMDMD.SetMetadata( papszMD, pszDomain );\n}\n\n/************************************************************************/\n/*                          GetMetadataItem()                           */\n/************************************************************************/\n\nconst char *GTiffRasterBand::GetMetadataItem( const char * pszName,\n                                              const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        poGDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszName != nullptr && pszDomain != nullptr && EQUAL(pszDomain, \"TIFF\") )\n    {\n        int nBlockXOff = 0;\n        int nBlockYOff = 0;\n\n        if( EQUAL(pszName, \"JPEGTABLES\") )\n        {\n            if( !poGDS->SetDirectory() )\n                return nullptr;\n\n            uint32 nJPEGTableSize = 0;\n            void* pJPEGTable = nullptr;\n            if( TIFFGetField( poGDS->hTIFF, TIFFTAG_JPEGTABLES,\n                              &nJPEGTableSize, &pJPEGTable ) != 1 ||\n                pJPEGTable == nullptr || nJPEGTableSize > INT_MAX )\n            {\n                return nullptr;\n            }\n            char* const pszHex =\n                CPLBinaryToHex( nJPEGTableSize, static_cast<const GByte*>(pJPEGTable) );\n            const char* pszReturn = CPLSPrintf(\"%s\", pszHex);\n            CPLFree(pszHex);\n\n            return pszReturn;\n        }\n\n        if( EQUAL(pszName, \"IFD_OFFSET\") )\n        {\n            if( !poGDS->SetDirectory() )\n                return nullptr;\n\n            return CPLSPrintf( CPL_FRMT_GUIB,\n                               static_cast<GUIntBig>(poGDS->nDirOffset) );\n        }\n\n        if( sscanf( pszName, \"BLOCK_OFFSET_%d_%d\",\n                         &nBlockXOff, &nBlockYOff ) == 2 )\n        {\n            if( !poGDS->SetDirectory() )\n                return nullptr;\n\n            nBlocksPerRow =\n                DIV_ROUND_UP(poGDS->nRasterXSize, poGDS->nBlockXSize);\n            nBlocksPerColumn =\n                DIV_ROUND_UP(poGDS->nRasterYSize, poGDS->nBlockYSize);\n            if( nBlockXOff < 0 || nBlockXOff >= nBlocksPerRow ||\n                nBlockYOff < 0 || nBlockYOff >= nBlocksPerColumn )\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n            {\n                nBlockId += (nBand - 1) * poGDS->nBlocksPerBand;\n            }\n\n            vsi_l_offset nOffset = 0;\n            if( !poGDS->IsBlockAvailable(nBlockId, &nOffset) )\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf( CPL_FRMT_GUIB, static_cast<GUIntBig>(nOffset) );\n        }\n\n        if( sscanf( pszName, \"BLOCK_SIZE_%d_%d\",\n                    &nBlockXOff, &nBlockYOff ) == 2 )\n        {\n            if( !poGDS->SetDirectory() )\n                return nullptr;\n\n            nBlocksPerRow =\n                DIV_ROUND_UP(poGDS->nRasterXSize, poGDS->nBlockXSize);\n            nBlocksPerColumn =\n                DIV_ROUND_UP(poGDS->nRasterYSize, poGDS->nBlockYSize);\n            if( nBlockXOff < 0 || nBlockXOff >= nBlocksPerRow ||\n                nBlockYOff < 0 || nBlockYOff >= nBlocksPerColumn )\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n            {\n                nBlockId += (nBand - 1) * poGDS->nBlocksPerBand;\n            }\n\n            vsi_l_offset nByteCount = 0;\n            if( !poGDS->IsBlockAvailable(nBlockId, nullptr, &nByteCount) )\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf(CPL_FRMT_GUIB, static_cast<GUIntBig>(nByteCount));\n        }\n    }\n    return oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}\n\n/************************************************************************/\n/*                          SetMetadataItem()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetMetadataItem( const char *pszName,\n                                         const char *pszValue,\n                                         const char *pszDomain )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( poGDS->bStreamingOut && poGDS->bCrystalized )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Cannot modify metadata at that point in a streamed \"\n                  \"output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        poGDS->bMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update &&\n            GDALPamRasterBand::GetMetadataItem(pszName, pszDomain) != nullptr )\n            GDALPamRasterBand::SetMetadataItem(pszName, nullptr, pszDomain);\n    }\n\n    return oGTiffMDMD.SetMetadataItem( pszName, pszValue, pszDomain );\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRasterBand::GetColorInterpretation()\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    return eBandInterp;\n}\n\n/************************************************************************/\n/*                         GTiffGetAlphaValue()                         */\n/************************************************************************/\n\nuint16 GTiffGetAlphaValue(const char* pszValue, uint16 nDefault)\n{\n    if( pszValue == nullptr )\n        return nDefault;\n    if( EQUAL(pszValue, \"YES\") )\n        return DEFAULT_ALPHA_TYPE;\n    if( EQUAL(pszValue, \"PREMULTIPLIED\") )\n        return EXTRASAMPLE_ASSOCALPHA;\n    if( EQUAL(pszValue, \"NON-PREMULTIPLIED\") )\n        return EXTRASAMPLE_UNASSALPHA;\n    if( EQUAL(pszValue, \"NO\") ||\n        EQUAL(pszValue, \"UNSPECIFIED\") )\n        return EXTRASAMPLE_UNSPECIFIED;\n\n    return nDefault;\n}\n\n/************************************************************************/\n/*                       SetColorInterpretation()                       */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetColorInterpretation( GDALColorInterp eInterp )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( eInterp == eBandInterp )\n        return CE_None;\n\n    eBandInterp = eInterp;\n\n    if( eAccess != GA_Update )\n    {\n        CPLDebug( \"GTIFF\", \"ColorInterpretation %s for band %d goes to PAM \"\n                  \"instead of TIFF tag\",\n                  GDALGetColorInterpretationName(eInterp), nBand );\n        return GDALPamRasterBand::SetColorInterpretation( eInterp );\n    }\n\n    if( poGDS->bCrystalized )\n    {\n        if( !poGDS->SetDirectory() )\n            return CE_Failure;\n    }\n\n    poGDS->bNeedsRewrite = true;\n    poGDS->bMetadataChanged = true;\n\n    // Try to autoset TIFFTAG_PHOTOMETRIC = PHOTOMETRIC_RGB if possible.\n    if( poGDS->nBands >= 3 &&\n        poGDS->nCompression != COMPRESSION_JPEG &&\n        poGDS->nPhotometric != PHOTOMETRIC_RGB &&\n        CSLFetchNameValue( poGDS->papszCreationOptions,\n                           \"PHOTOMETRIC\" ) == nullptr &&\n        ((nBand == 1 && eInterp == GCI_RedBand) ||\n         (nBand == 2 && eInterp == GCI_GreenBand) ||\n         (nBand == 3 && eInterp == GCI_BlueBand)) )\n    {\n        if( poGDS->GetRasterBand(1)->GetColorInterpretation() == GCI_RedBand &&\n            poGDS->GetRasterBand(2)->GetColorInterpretation() == GCI_GreenBand &&\n            poGDS->GetRasterBand(3)->GetColorInterpretation() == GCI_BlueBand )\n        {\n            poGDS->nPhotometric = PHOTOMETRIC_RGB;\n            TIFFSetField( poGDS->hTIFF, TIFFTAG_PHOTOMETRIC,\n                          poGDS->nPhotometric );\n\n            // We need to update the number of extra samples.\n            uint16 *v = nullptr;\n            uint16 count = 0;\n            const uint16 nNewExtraSamplesCount =\n                static_cast<uint16>(poGDS->nBands - 3);\n            if( poGDS->nBands >= 4 &&\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES,\n                              &count, &v ) &&\n                count > nNewExtraSamplesCount )\n            {\n                uint16 * const pasNewExtraSamples =\n                    static_cast<uint16 *>( CPLMalloc(\n                        nNewExtraSamplesCount * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v + count - nNewExtraSamplesCount,\n                        nNewExtraSamplesCount * sizeof(uint16) );\n\n                TIFFSetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES,\n                              nNewExtraSamplesCount, pasNewExtraSamples );\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n        return CE_None;\n    }\n\n    // On the contrary, cancel the above if needed\n    if( poGDS->nCompression != COMPRESSION_JPEG &&\n        poGDS->nPhotometric == PHOTOMETRIC_RGB &&\n        CSLFetchNameValue( poGDS->papszCreationOptions,\n                           \"PHOTOMETRIC\") == nullptr &&\n        ((nBand == 1 && eInterp != GCI_RedBand) ||\n         (nBand == 2 && eInterp != GCI_GreenBand) ||\n         (nBand == 3 && eInterp != GCI_BlueBand)) )\n    {\n        poGDS->nPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(poGDS->hTIFF, TIFFTAG_PHOTOMETRIC, poGDS->nPhotometric);\n\n        // We need to update the number of extra samples.\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        const uint16 nNewExtraSamplesCount =\n            static_cast<uint16>(poGDS->nBands - 1);\n        if( poGDS->nBands >= 2 )\n        {\n            TIFFGetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v );\n            if( nNewExtraSamplesCount > count )\n            {\n                uint16 * const pasNewExtraSamples =\n                    static_cast<uint16 *>( CPLMalloc(\n                        nNewExtraSamplesCount * sizeof(uint16) ) );\n                for( int i = 0;\n                     i < static_cast<int>(nNewExtraSamplesCount - count);\n                     ++i )\n                    pasNewExtraSamples[i] = EXTRASAMPLE_UNSPECIFIED;\n                if( count > 0 )\n                {\n                    memcpy( pasNewExtraSamples + nNewExtraSamplesCount - count,\n                            v,\n                            count * sizeof(uint16) );\n                }\n\n                TIFFSetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES,\n                              nNewExtraSamplesCount, pasNewExtraSamples );\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n    }\n\n    // Mark alpha band / undefined in extrasamples.\n    if( eInterp == GCI_AlphaBand || eInterp == GCI_Undefined )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        if( TIFFGetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            const int nBaseSamples = poGDS->nSamplesPerPixel - count;\n\n            if( eInterp == GCI_AlphaBand )\n            {\n                for( int i = 1; i <= poGDS->nBands; ++i )\n                {\n                    if( i != nBand &&\n                        poGDS->GetRasterBand(i)->GetColorInterpretation() ==\n                        GCI_AlphaBand )\n                    {\n                        if( i == nBaseSamples + 1 &&\n                            CSLFetchNameValue( poGDS->papszCreationOptions,\n                                            \"ALPHA\" ) != nullptr )\n                        {\n                            CPLError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too. \"\n                                \"Presumably ALPHA creation option is not needed\",\n                                i, nBand );\n                        }\n                        else\n                        {\n                            CPLError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too\",\n                                i, nBand );\n                        }\n                    }\n                }\n            }\n\n            if( nBand > nBaseSamples && nBand - nBaseSamples - 1 < count )\n            {\n                // We need to allocate a new array as (current) libtiff\n                // versions will not like that we reuse the array we got from\n                // TIFFGetField().\n\n                uint16* pasNewExtraSamples =\n                    static_cast<uint16 *>(\n                        CPLMalloc( count * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v, count * sizeof(uint16) );\n                if( eInterp == GCI_AlphaBand )\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        GTiffGetAlphaValue(CPLGetConfigOption(\"GTIFF_ALPHA\", nullptr),\n                                            DEFAULT_ALPHA_TYPE);\n                }\n                else\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        EXTRASAMPLE_UNSPECIFIED;\n                }\n\n                TIFFSetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES,\n                              count, pasNewExtraSamples);\n\n                CPLFree(pasNewExtraSamples);\n\n                return CE_None;\n            }\n        }\n    }\n\n    if( poGDS->nPhotometric != PHOTOMETRIC_MINISBLACK &&\n        CSLFetchNameValue( poGDS->papszCreationOptions, \"PHOTOMETRIC\") == nullptr )\n    {\n        poGDS->nPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(poGDS->hTIFF, TIFFTAG_PHOTOMETRIC, poGDS->nPhotometric);\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           GetColorTable()                            */\n/************************************************************************/\n\nGDALColorTable *GTiffRasterBand::GetColorTable()\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( nBand == 1 )\n        return poGDS->poColorTable;\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                           SetColorTable()                            */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetColorTable( GDALColorTable * poCT )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n/* -------------------------------------------------------------------- */\n/*      Check if this is even a candidate for applying a PCT.           */\n/* -------------------------------------------------------------------- */\n    if( nBand != 1)\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() can only be called on band 1.\" );\n        return CE_Failure;\n    }\n\n    if( poGDS->nSamplesPerPixel != 1 && poGDS->nSamplesPerPixel != 2)\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() not supported for multi-sample TIFF \"\n                  \"files.\" );\n        return CE_Failure;\n    }\n\n    if( eDataType != GDT_Byte && eDataType != GDT_UInt16 )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() only supported for Byte or UInt16 bands \"\n                  \"in TIFF format.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We are careful about calling SetDirectory() to avoid            */\n/*      prematurely crystallizing the directory.  (#2820)               */\n/* -------------------------------------------------------------------- */\n    if( poGDS->bCrystalized )\n    {\n        if( !poGDS->SetDirectory() )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Is this really a request to clear the color table?              */\n/* -------------------------------------------------------------------- */\n    if( poCT == nullptr || poCT->GetColorEntryCount() == 0 )\n    {\n        TIFFSetField( poGDS->hTIFF, TIFFTAG_PHOTOMETRIC,\n                      PHOTOMETRIC_MINISBLACK );\n\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( poGDS->hTIFF, TIFFTAG_COLORMAP );\n#else\n        CPLDebug(\n            \"GTiff\",\n            \"TIFFUnsetField() not supported, colormap may not be cleared.\" );\n#endif\n\n        if( poGDS->poColorTable )\n        {\n            delete poGDS->poColorTable;\n            poGDS->poColorTable = nullptr;\n        }\n\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the colortable, and update the configuration.         */\n/* -------------------------------------------------------------------- */\n    int nColors = 65536;\n\n    if( eDataType == GDT_Byte )\n        nColors = 256;\n\n    unsigned short *panTRed = static_cast<unsigned short *>(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n    unsigned short *panTGreen = static_cast<unsigned short *>(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n    unsigned short *panTBlue = static_cast<unsigned short *>(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n\n    for( int iColor = 0; iColor < nColors; ++iColor )\n    {\n        if( iColor < poCT->GetColorEntryCount() )\n        {\n            GDALColorEntry sRGB;\n            poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n            panTRed[iColor] = static_cast<unsigned short>(257 * sRGB.c1);\n            panTGreen[iColor] = static_cast<unsigned short>(257 * sRGB.c2);\n            panTBlue[iColor] = static_cast<unsigned short>(257 * sRGB.c3);\n        }\n        else\n        {\n            panTRed[iColor] = 0;\n            panTGreen[iColor] = 0;\n            panTBlue[iColor] = 0;\n        }\n    }\n\n    TIFFSetField( poGDS->hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n    TIFFSetField( poGDS->hTIFF, TIFFTAG_COLORMAP,\n                  panTRed, panTGreen, panTBlue );\n\n    CPLFree( panTRed );\n    CPLFree( panTGreen );\n    CPLFree( panTBlue );\n\n    if( poGDS->poColorTable )\n        delete poGDS->poColorTable;\n\n    // libtiff 3.X needs setting this in all cases (creation or update)\n    // whereas libtiff 4.X would just need it if there\n    // was no color table before.\n    poGDS->bNeedsRewrite = true;\n\n    poGDS->poColorTable = poCT->Clone();\n    eBandInterp = GCI_PaletteIndex;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           GetNoDataValue()                           */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetNoDataValue( int * pbSuccess )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( bNoDataSet )\n    {\n        if( pbSuccess )\n            *pbSuccess = TRUE;\n\n        return dfNoDataValue;\n    }\n\n    if( poGDS->bNoDataSet )\n    {\n        if( pbSuccess )\n            *pbSuccess = TRUE;\n\n        return poGDS->dfNoDataValue;\n    }\n\n    return GDALPamRasterBand::GetNoDataValue( pbSuccess );\n}\n\n/************************************************************************/\n/*                           SetNoDataValue()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetNoDataValue( double dfNoData )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( poGDS->bNoDataSet && poGDS->dfNoDataValue == dfNoData )\n    {\n        bNoDataSet = true;\n        dfNoDataValue = dfNoData;\n        return CE_None;\n    }\n\n    if( poGDS->nBands > 1 && poGDS->osProfile == szPROFILE_GDALGeoTIFF )\n    {\n        int bOtherBandHasNoData = FALSE;\n        const int nOtherBand = nBand > 1 ? 1 : 2;\n        double dfOtherNoData = poGDS->GetRasterBand(nOtherBand)->\n                                    GetNoDataValue(&bOtherBandHasNoData);\n        if( bOtherBandHasNoData && dfOtherNoData != dfNoData )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                 \"Setting nodata to %.18g on band %d, but band %d has nodata \"\n                 \"at %.18g. The TIFFTAG_GDAL_NODATA only support one value \"\n                 \"per dataset. This value of %.18g will be used for all bands \"\n                 \"on re-opening\",\n                 dfNoData, nBand, nOtherBand, dfOtherNoData, dfNoData);\n        }\n    }\n\n    if( poGDS->bStreamingOut && poGDS->bCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify nodata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    poGDS->bNoDataSet = true;\n    poGDS->dfNoDataValue = dfNoData;\n\n    poGDS->bNoDataChanged = true;\n\n    bNoDataSet = true;\n    dfNoDataValue = dfNoData;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                        DeleteNoDataValue()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::DeleteNoDataValue()\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( !poGDS->bNoDataSet )\n        return CE_None;\n\n    if( poGDS->bStreamingOut && poGDS->bCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify nodata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    poGDS->bNoDataSet = false;\n    poGDS->dfNoDataValue = -9999.0;\n\n    poGDS->bNoDataChanged = true;\n\n    bNoDataSet = false;\n    dfNoDataValue = -9999.0;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             NullBlock()                              */\n/*                                                                      */\n/*      Set the block data to the null value if it is set, or zero      */\n/*      if there is no null data value.                                 */\n/************************************************************************/\n\nvoid GTiffRasterBand::NullBlock( void *pData )\n\n{\n    const int nWords = nBlockXSize * nBlockYSize;\n    const int nChunkSize = std::max(1, GDALGetDataTypeSizeBytes(eDataType));\n\n    int bNoDataSetIn = FALSE;\n    const double dfNoData = GetNoDataValue( &bNoDataSetIn );\n    if( !bNoDataSetIn )\n    {\n#ifdef ESRI_BUILD\n        if( poGDS->nBitsPerSample >= 2 )\n            memset( pData, 0, nWords * nChunkSize );\n        else\n            memset( pData, 1, nWords * nChunkSize );\n#else\n        memset( pData, 0, nWords * nChunkSize );\n#endif\n    }\n    else\n    {\n        // Will convert nodata value to the right type and copy efficiently.\n        GDALCopyWords( &dfNoData, GDT_Float64, 0,\n                       pData, eDataType, nChunkSize, nWords);\n    }\n}\n\n/************************************************************************/\n/*                          GetOverviewCount()                          */\n/************************************************************************/\n\nint GTiffRasterBand::GetOverviewCount()\n\n{\n    poGDS->ScanDirectories();\n\n    if( poGDS->nOverviewCount > 0 )\n    {\n        return poGDS->nOverviewCount;\n    }\n\n    const int nOverviewCount = GDALRasterBand::GetOverviewCount();\n    if( nOverviewCount > 0 )\n        return nOverviewCount;\n\n    // Implicit JPEG overviews are normally hidden, except when doing\n    // IRasterIO() operations.\n    if( poGDS->nJPEGOverviewVisibilityCounter )\n        return poGDS->GetJPEGOverviewCount();\n\n    return 0;\n}\n\n/************************************************************************/\n/*                            GetOverview()                             */\n/************************************************************************/\n\nGDALRasterBand *GTiffRasterBand::GetOverview( int i )\n\n{\n    poGDS->ScanDirectories();\n\n    if( poGDS->nOverviewCount > 0 )\n    {\n        // Do we have internal overviews?\n        if( i < 0 || i >= poGDS->nOverviewCount )\n            return nullptr;\n\n        return poGDS->papoOverviewDS[i]->GetRasterBand(nBand);\n    }\n\n    GDALRasterBand* const poOvrBand = GDALRasterBand::GetOverview( i );\n    if( poOvrBand != nullptr )\n        return poOvrBand;\n\n    // For consistency with GetOverviewCount(), we should also test\n    // nJPEGOverviewVisibilityCounter, but it is also convenient to be able\n    // to query them for testing purposes.\n    if( i >= 0 && i < poGDS->GetJPEGOverviewCount() )\n        return poGDS->papoJPEGOverviewDS[i]->GetRasterBand(nBand);\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                           GetMaskFlags()                             */\n/************************************************************************/\n\nint GTiffRasterBand::GetMaskFlags()\n{\n    poGDS->ScanDirectories();\n\n    if( poGDS->poMaskDS != nullptr )\n    {\n        if( poGDS->poMaskDS->GetRasterCount() == 1)\n        {\n            return GMF_PER_DATASET;\n        }\n\n        return 0;\n    }\n\n    if( poGDS->bIsOverview_ )\n    {\n        return poGDS->poBaseDS->GetRasterBand(nBand)->GetMaskFlags();\n    }\n\n    return GDALPamRasterBand::GetMaskFlags();\n}\n\n/************************************************************************/\n/*                            GetMaskBand()                             */\n/************************************************************************/\n\nGDALRasterBand *GTiffRasterBand::GetMaskBand()\n{\n    poGDS->ScanDirectories();\n\n    if( poGDS->poMaskDS != nullptr )\n    {\n        if( poGDS->poMaskDS->GetRasterCount() == 1 )\n            return poGDS->poMaskDS->GetRasterBand(1);\n\n        return poGDS->poMaskDS->GetRasterBand(nBand);\n    }\n\n    if( poGDS->bIsOverview_ )\n    {\n        GDALRasterBand* poBaseMask =\n            poGDS->poBaseDS->GetRasterBand(nBand)->GetMaskBand();\n        if( poBaseMask )\n        {\n            const int nOverviews = poBaseMask->GetOverviewCount();\n            for( int i = 0; i < nOverviews; i++ )\n            {\n                GDALRasterBand* poOvr = poBaseMask->GetOverview(i);\n                if( poOvr &&\n                    poOvr->GetXSize() == GetXSize() &&\n                    poOvr->GetYSize() == GetYSize() )\n                {\n                    return poOvr;\n                }\n            }\n        }\n    }\n\n    return GDALPamRasterBand::GetMaskBand();\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffSplitBand                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffSplitBand final : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n\n  public:\n             GTiffSplitBand( GTiffDataset *, int );\n    virtual ~GTiffSplitBand() {}\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                           GTiffSplitBand()                           */\n/************************************************************************/\n\nGTiffSplitBand::GTiffSplitBand( GTiffDataset *poDSIn, int nBandIn ) :\n    GTiffRasterBand( poDSIn, nBandIn )\n{\n    nBlockXSize = poDS->GetRasterXSize();\n    nBlockYSize = 1;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffSplitBand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBand::IReadBlock( int /* nBlockXOff */, int nBlockYOff,\n                                   void * pImage )\n\n{\n    // Optimization when reading the same line in a contig multi-band TIFF.\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG && poGDS->nBands > 1 &&\n        poGDS->nLastLineRead == nBlockYOff )\n    {\n        goto extract_band_data;\n    }\n\n    if( !poGDS->SetDirectory() )\n        return CE_Failure;\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n        poGDS->nBands > 1 )\n    {\n        if( poGDS->pabyBlockBuf == nullptr )\n        {\n            poGDS->pabyBlockBuf =\n                static_cast<GByte *>(\n                    VSI_MALLOC_VERBOSE(TIFFScanlineSize(poGDS->hTIFF)) );\n            if( poGDS->pabyBlockBuf == nullptr )\n            {\n                return CE_Failure;\n            }\n        }\n    }\n    else\n    {\n        CPLAssert(TIFFScanlineSize(poGDS->hTIFF) == nBlockXSize);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read through to target scanline.                                */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nLastLineRead >= nBlockYOff )\n        poGDS->nLastLineRead = -1;\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE && poGDS->nBands > 1 )\n    {\n        // If we change of band, we must start reading the\n        // new strip from its beginning.\n        if( poGDS->nLastBandRead != nBand )\n            poGDS->nLastLineRead = -1;\n        poGDS->nLastBandRead = nBand;\n    }\n\n    while( poGDS->nLastLineRead < nBlockYOff )\n    {\n        ++poGDS->nLastLineRead;\n        if( TIFFReadScanline(\n                poGDS->hTIFF,\n                poGDS->pabyBlockBuf ? poGDS->pabyBlockBuf : pImage,\n                poGDS->nLastLineRead,\n                (poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE) ?\n                 static_cast<uint16>(nBand - 1) : 0 ) == -1\n            && !poGDS->bIgnoreReadErrors )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadScanline() failed.\" );\n            poGDS->nLastLineRead = -1;\n            return CE_Failure;\n        }\n    }\n\nextract_band_data:\n/* -------------------------------------------------------------------- */\n/*      Extract band data from contig buffer.                           */\n/* -------------------------------------------------------------------- */\n    if( poGDS->pabyBlockBuf != nullptr )\n    {\n        for( int iPixel = 0, iSrcOffset= nBand - 1, iDstOffset = 0;\n             iPixel < nBlockXSize;\n             ++iPixel, iSrcOffset += poGDS->nBands, ++iDstOffset )\n        {\n            static_cast<GByte *>(pImage)[iDstOffset] =\n                poGDS->pabyBlockBuf[iSrcOffset];\n        }\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBand::IWriteBlock( int /* nBlockXOff */, int /* nBlockYOff */,\n                                    void * /* pImage */ )\n\n{\n    CPLError( CE_Failure, CPLE_AppDefined,\n              \"Split bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffRGBABand                            */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRGBABand final : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n\n  public:\n                   GTiffRGBABand( GTiffDataset *, int );\n    virtual ~GTiffRGBABand() {}\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n\n    virtual GDALColorInterp GetColorInterpretation() override;\n};\n\n/************************************************************************/\n/*                           GTiffRGBABand()                            */\n/************************************************************************/\n\nGTiffRGBABand::GTiffRGBABand( GTiffDataset *poDSIn, int nBandIn ) :\n    GTiffRasterBand( poDSIn, nBandIn )\n{\n    eDataType = GDT_Byte;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRGBABand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IWriteBlock( int, int, void * )\n\n{\n    CPLError( CE_Failure, CPLE_AppDefined,\n              \"RGBA interpreted raster bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                  void * pImage )\n\n{\n    if( !poGDS->SetDirectory() )\n        return CE_Failure;\n\n    CPLAssert( nBlocksPerRow != 0 );\n    const int nBlockBufSize = 4 * nBlockXSize * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n#ifdef INTERNAL_LIBTIFF\n    if( poGDS->nCompression == COMPRESSION_OJPEG )\n    {\n        // Need to fetch all offsets for Old-JPEG compression\n        if( poGDS->pabyBlockBuf == nullptr )\n        {\n            toff_t *panByteCounts = nullptr;\n            toff_t *panOffsets = nullptr;\n            const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(poGDS->hTIFF) );\n\n            if( bIsTiled )\n            {\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts );\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_TILEOFFSETS, &panOffsets );\n            }\n            else\n            {\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts );\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPOFFSETS, &panOffsets );\n            }\n        }\n    }\n#endif\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        for( int iBand = 0; iBand < poGDS->nSamplesPerPixel; iBand ++ )\n        {\n            int nBlockIdBand = nBlockId + iBand * poGDS->nBlocksPerBand;\n            if( !poGDS->IsBlockAvailable(nBlockIdBand) )\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if( !poGDS->IsBlockAvailable(nBlockId) )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( poGDS->pabyBlockBuf == nullptr )\n    {\n        poGDS->pabyBlockBuf =\n            static_cast<GByte *>(\n                VSI_MALLOC3_VERBOSE( 4, nBlockXSize, nBlockYSize ) );\n        if( poGDS->pabyBlockBuf == nullptr )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read the strip                                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if( poGDS->nLoadedBlock != nBlockId )\n    {\n        if( TIFFIsTiled( poGDS->hTIFF ) )\n        {\n#if defined(INTERNAL_LIBTIFF) || TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBATileExt(\n                   poGDS->hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf),\n                   !poGDS->bIgnoreReadErrors) == 0\n                && !poGDS->bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBATile(\n                   poGDS->hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf)) == 0\n                && !poGDS->bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBATile() failed.\" );\n\n                memset( poGDS->pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n#if defined(INTERNAL_LIBTIFF) || TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBAStripExt(\n                   poGDS->hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf),\n                   !poGDS->bIgnoreReadErrors) == 0\n                && !poGDS->bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBAStrip(\n                   poGDS->hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf)) == 0\n                && !poGDS->bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBAStrip() failed.\" );\n\n                memset( poGDS->pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    poGDS->nLoadedBlock = nBlockId;\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case of eight bit data, and pixel interleaving.   */\n/* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if( nBlockYOff * nBlockYSize > GetYSize() - nBlockYSize\n        && !TIFFIsTiled( poGDS->hTIFF ) )\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for( int iDestLine = 0; iDestLine < nThisBlockYSize; ++iDestLine )\n    {\n        const int nSrcOffset =\n            (nThisBlockYSize - iDestLine - 1) * nBlockXSize * 4;\n\n        GDALCopyWords(\n            poGDS->pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n            static_cast<GByte *>(pImage)+iDestLine*nBlockXSize, GDT_Byte, 1,\n            nBlockXSize );\n    }\n\n    if( eErr == CE_None )\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRGBABand::GetColorInterpretation()\n\n{\n    if( nBand == 1 )\n        return GCI_RedBand;\n    if( nBand == 2 )\n        return GCI_GreenBand;\n    if( nBand == 3 )\n        return GCI_BlueBand;\n\n    return GCI_AlphaBand;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffOddBitsBand                         */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffOddBitsBand : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n  public:\n\n                   GTiffOddBitsBand( GTiffDataset *, int );\n    virtual ~GTiffOddBitsBand() {}\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                           GTiffOddBitsBand()                         */\n/************************************************************************/\n\nGTiffOddBitsBand::GTiffOddBitsBand( GTiffDataset *poGDSIn, int nBandIn )\n        : GTiffRasterBand( poGDSIn, nBandIn )\n\n{\n    eDataType = GDT_Unknown;\n    if( (poGDS->nBitsPerSample == 16 || poGDS->nBitsPerSample == 24) &&\n        poGDS->nSampleFormat == SAMPLEFORMAT_IEEEFP )\n        eDataType = GDT_Float32;\n    // FIXME ? in autotest we currently open gcore/data/int24.tif\n    // which is declared as signed, but we consider it as unsigned\n    else if( (poGDS->nSampleFormat == SAMPLEFORMAT_UINT ||\n              poGDS->nSampleFormat == SAMPLEFORMAT_INT) &&\n             poGDS->nBitsPerSample < 8 )\n        eDataType = GDT_Byte;\n    else if( (poGDS->nSampleFormat == SAMPLEFORMAT_UINT ||\n              poGDS->nSampleFormat == SAMPLEFORMAT_INT) &&\n             poGDS->nBitsPerSample > 8 && poGDS->nBitsPerSample < 16 )\n        eDataType = GDT_UInt16;\n    else if( (poGDS->nSampleFormat == SAMPLEFORMAT_UINT ||\n              poGDS->nSampleFormat == SAMPLEFORMAT_INT) &&\n             poGDS->nBitsPerSample > 16 && poGDS->nBitsPerSample < 32 )\n        eDataType = GDT_UInt32;\n}\n\n/************************************************************************/\n/*                            FloatToHalf()                             */\n/************************************************************************/\n\nstatic GUInt16 FloatToHalf( GUInt32 iFloat32, bool& bHasWarned )\n{\n    GUInt32 iSign =     (iFloat32 >> 31) & 0x00000001;\n    GUInt32 iExponent = (iFloat32 >> 23) & 0x000000ff;\n    GUInt32 iMantissa = iFloat32         & 0x007fffff;\n\n    if (iExponent == 255)\n    {\n        if (iMantissa == 0)\n        {\n/* -------------------------------------------------------------------- */\n/*       Positive or negative infinity.                                 */\n/* -------------------------------------------------------------------- */\n\n            return static_cast<GUInt16>((iSign << 15) | 0x7C00);\n        }\n        else\n        {\n/* -------------------------------------------------------------------- */\n/*       NaN -- preserve sign and significand bits.                     */\n/* -------------------------------------------------------------------- */\n            if( iMantissa >> 13 )\n                return static_cast<GUInt16>((iSign << 15) | 0x7C00 |\n                                                            (iMantissa >> 13));\n\n            return static_cast<GUInt16>((iSign << 15) | 0x7E00);\n        }\n    }\n\n    if( iExponent <= 127 - 15 )\n    {\n        // Zero, float32 denormalized number or float32 too small normalized\n        // number\n        if( 13 + 1 + 127 - 15 - iExponent >= 32 )\n            return static_cast<GUInt16>(iSign << 15);\n\n        // Return a denormalized number\n        return static_cast<GUInt16>((iSign << 15) |\n                ((iMantissa | 0x00800000) >> (13 + 1 + 127 - 15 - iExponent)));\n    }\n    if( iExponent - (127 - 15) >= 31 )\n    {\n        if( !bHasWarned )\n        {\n            bHasWarned = true;\n            float fVal = 0.0f;\n            memcpy(&fVal, &iFloat32, 4);\n            CPLError(\n                CE_Failure, CPLE_AppDefined,\n                \"Value %.8g is beyond range of float16. Converted to %sinf\",\n                fVal, (fVal > 0) ? \"+\" : \"-\");\n        }\n        return static_cast<GUInt16>((iSign << 15) | 0x7C00);  // Infinity\n    }\n\n/* -------------------------------------------------------------------- */\n/*       Normalized number.                                             */\n/* -------------------------------------------------------------------- */\n\n    iExponent = iExponent - (127 - 15);\n    iMantissa = iMantissa >> 13;\n\n/* -------------------------------------------------------------------- */\n/*       Assemble sign, exponent and mantissa.                          */\n/* -------------------------------------------------------------------- */\n\n    // coverity[overflow_sink]\n    return static_cast<GUInt16>((iSign << 15) | (iExponent << 10) | iMantissa);\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffOddBitsBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                      void *pImage )\n\n{\n    if( poGDS->bWriteErrorInFlushBlockBuf )\n    {\n        // Report as an error if a previously loaded block couldn't be written\n        // correctly.\n        poGDS->bWriteErrorInFlushBlockBuf = false;\n        return CE_Failure;\n    }\n\n    if( !poGDS->SetDirectory() )\n        return CE_Failure;\n\n    CPLAssert( poGDS != nullptr\n               && nBlockXOff >= 0\n               && nBlockYOff >= 0\n               && pImage != nullptr );\n\n    if( eDataType == GDT_Float32 && poGDS->nBitsPerSample != 16 )\n    {\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Writing float data with nBitsPerSample = %d is unsupported\",\n                 poGDS->nBitsPerSample);\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block buffer.                                          */\n/* -------------------------------------------------------------------- */\n    CPLAssert(nBlocksPerRow != 0);\n    int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId += (nBand - 1) * poGDS->nBlocksPerBand;\n\n    // Only read content from disk in the CONTIG case.\n    {\n        const CPLErr eErr =\n            poGDS->LoadBlockBuf( nBlockId,\n                                 poGDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n                                 poGDS->nBands > 1 );\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n    const GUInt32 nMaxVal = (1U << poGDS->nBitsPerSample) - 1;\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of \"separate\" images or single band images where    */\n/*      no interleaving with other data is required.                    */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE\n        || poGDS->nBands == 1 )\n    {\n        // TODO(schwehr): Create a CplNumBits8Aligned.\n        // Bits per line rounds up to next byte boundary.\n        int nBitsPerLine = nBlockXSize * poGDS->nBitsPerSample;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        int iPixel = 0;\n\n        // Small optimization in 1 bit case.\n        if( poGDS->nBitsPerSample == 1 )\n        {\n            for( int iY = 0; iY < nBlockYSize; ++iY, iPixel += nBlockXSize )\n            {\n                int iBitOffset = iY * nBitsPerLine;\n\n                const GByte* pabySrc =\n                    static_cast<const GByte*>(pImage) + iPixel;\n                int iByteOffset = iBitOffset / 8;\n                int iX = 0;  // Used after for.\n                for( ; iX + 7 < nBlockXSize; iX += 8, iByteOffset++ )\n                {\n                    int nRes = (!(!pabySrc[iX+0])) << 7;\n                    nRes |= (!(!pabySrc[iX+1])) << 6;\n                    nRes |= (!(!pabySrc[iX+2])) << 5;\n                    nRes |= (!(!pabySrc[iX+3])) << 4;\n                    nRes |= (!(!pabySrc[iX+4])) << 3;\n                    nRes |= (!(!pabySrc[iX+5])) << 2;\n                    nRes |= (!(!pabySrc[iX+6])) << 1;\n                    nRes |= (!(!pabySrc[iX+7])) << 0;\n                    poGDS->pabyBlockBuf[iByteOffset] = static_cast<GByte>(nRes);\n                }\n                iBitOffset = iByteOffset * 8;\n                if( iX < nBlockXSize )\n                {\n                    int nRes = 0;\n                    for( ; iX < nBlockXSize; ++iX )\n                    {\n                        if( pabySrc[iX] )\n                            nRes |= (0x80 >>(iBitOffset & 7) );\n                        ++iBitOffset;\n                    }\n                    poGDS->pabyBlockBuf[iBitOffset>>3] =\n                        static_cast<GByte>(nRes);\n                }\n            }\n\n            poGDS->bLoadedBlockDirty = true;\n\n            return CE_None;\n        }\n\n        if( eDataType == GDT_Float32 && poGDS->nBitsPerSample == 16 )\n        {\n            for( ; iPixel < nBlockYSize * nBlockXSize; iPixel++ )\n            {\n                GUInt32 nInWord = static_cast<GUInt32 *>(pImage)[iPixel];\n                GUInt16 nHalf = FloatToHalf(nInWord, poGDS->bClipWarn);\n                reinterpret_cast<GUInt16*>(poGDS->pabyBlockBuf)[iPixel] = nHalf;\n            }\n\n            poGDS->bLoadedBlockDirty = true;\n\n            return CE_None;\n        }\n\n        // Initialize to zero as we set the buffer with binary or operations.\n        if( poGDS->nBitsPerSample != 24 )\n            memset(poGDS->pabyBlockBuf, 0, (nBitsPerLine / 8) * nBlockYSize);\n\n        for( int iY = 0; iY < nBlockYSize; ++iY )\n        {\n            int iBitOffset = iY * nBitsPerLine;\n\n            if( poGDS->nBitsPerSample == 12 )\n            {\n                for( int iX = 0; iX < nBlockXSize; ++iX )\n                {\n                    GUInt32 nInWord = static_cast<GUInt16 *>(pImage)[iPixel++];\n                    if( nInWord > nMaxVal )\n                    {\n                        nInWord = nMaxVal;\n                        if( !poGDS->bClipWarn )\n                        {\n                            poGDS->bClipWarn = true;\n                            CPLError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"One or more pixels clipped to fit %d bit \"\n                                \"domain.\", poGDS->nBitsPerSample );\n                        }\n                    }\n\n                    if( (iBitOffset % 8) == 0 )\n                    {\n                        poGDS->pabyBlockBuf[iBitOffset>>3] =\n                            static_cast<GByte>(nInWord >> 4);\n                        // Let 4 lower bits to zero as they're going to be\n                        // overridden by the next word.\n                        poGDS->pabyBlockBuf[(iBitOffset>>3)+1] =\n                            static_cast<GByte>((nInWord & 0xf) << 4);\n                    }\n                    else\n                    {\n                        // Must or to preserve the 4 upper bits written\n                        // for the previous word.\n                        poGDS->pabyBlockBuf[iBitOffset>>3] |=\n                            static_cast<GByte>(nInWord >> 8);\n                        poGDS->pabyBlockBuf[(iBitOffset>>3)+1] =\n                            static_cast<GByte>(nInWord & 0xff);\n                    }\n\n                    iBitOffset += poGDS->nBitsPerSample;\n                }\n                continue;\n            }\n\n            for( int iX = 0; iX < nBlockXSize; ++iX )\n            {\n                GUInt32 nInWord = 0;\n                if( eDataType == GDT_Byte )\n                {\n                    nInWord = static_cast<GByte *>(pImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                    nInWord = static_cast<GUInt16 *>(pImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                    nInWord = static_cast<GUInt32 *>(pImage)[iPixel++];\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n\n                if( nInWord > nMaxVal )\n                {\n                    nInWord = nMaxVal;\n                    if( !poGDS->bClipWarn )\n                    {\n                        poGDS->bClipWarn = true;\n                        CPLError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"One or more pixels clipped to fit %d bit domain.\",\n                            poGDS->nBitsPerSample );\n                    }\n                }\n\n                if( poGDS->nBitsPerSample == 24 )\n                {\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n#ifdef CPL_MSB\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 0] =\n                        static_cast<GByte>( nInWord );\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 1] =\n                        static_cast<GByte>( nInWord >> 8 );\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 2] =\n                        static_cast<GByte>( nInWord >> 16 );\n#else\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 0] =\n                        static_cast<GByte>( nInWord >> 16 );\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 1] =\n                        static_cast<GByte>( nInWord >> 8 );\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 2] =\n                        static_cast<GByte>( nInWord );\n#endif\n                    iBitOffset += 24;\n                }\n                else\n                {\n                    for( int iBit = 0; iBit < poGDS->nBitsPerSample; ++iBit )\n                    {\n                        if( nInWord &\n                            (1 << (poGDS->nBitsPerSample - 1 - iBit)) )\n                            poGDS->pabyBlockBuf[iBitOffset>>3] |=\n                                ( 0x80 >> (iBitOffset & 7) );\n                        ++iBitOffset;\n                    }\n                }\n            }\n        }\n\n        poGDS->bLoadedBlockDirty = true;\n\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of pixel interleaved (PLANARCONFIG_CONTIG) images.  */\n/* -------------------------------------------------------------------- */\n\n/* -------------------------------------------------------------------- */\n/*      On write of pixel interleaved data, we might as well flush      */\n/*      out any other bands that are dirty in our cache.  This is       */\n/*      especially helpful when writing compressed blocks.              */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < poGDS->nBands; ++iBand )\n    {\n        const GByte *pabyThisImage = nullptr;\n        GDALRasterBlock *poBlock = nullptr;\n\n        if( iBand + 1 == nBand )\n        {\n            pabyThisImage = static_cast<GByte *>( pImage );\n        }\n        else\n        {\n            poBlock =\n                cpl::down_cast<GTiffOddBitsBand *>(\n                    poGDS->GetRasterBand( iBand + 1 ))\n                        ->TryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n            if( poBlock == nullptr )\n                continue;\n\n            if( !poBlock->GetDirty() )\n            {\n                poBlock->DropLock();\n                continue;\n            }\n\n            pabyThisImage = static_cast<GByte *>(poBlock->GetDataRef());\n        }\n\n        const int iPixelBitSkip = poGDS->nBitsPerSample * poGDS->nBands;\n        const int iBandBitOffset = iBand * poGDS->nBitsPerSample;\n\n        // Bits per line rounds up to next byte boundary.\n        int nBitsPerLine = nBlockXSize * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        int iPixel = 0;\n\n        if( eDataType == GDT_Float32 && poGDS->nBitsPerSample == 16 )\n        {\n            for( ; iPixel < nBlockYSize * nBlockXSize; iPixel++ )\n            {\n                GUInt32 nInWord = reinterpret_cast<const GUInt32 *>(\n                                                        pabyThisImage)[iPixel];\n                GUInt16 nHalf = FloatToHalf(nInWord, poGDS->bClipWarn);\n                reinterpret_cast<GUInt16*>(poGDS->pabyBlockBuf)[\n                                    iPixel * poGDS->nBands + iBand] = nHalf;\n            }\n\n            if( poBlock != nullptr )\n            {\n                poBlock->MarkClean();\n                poBlock->DropLock();\n            }\n            continue;\n        }\n\n        for( int iY = 0; iY < nBlockYSize; ++iY )\n        {\n            int iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            if( poGDS->nBitsPerSample == 12 )\n            {\n                for( int iX = 0; iX < nBlockXSize; ++iX )\n                {\n                    GUInt32 nInWord =\n                        reinterpret_cast<const GUInt16 *>(\n                            pabyThisImage)[iPixel++];\n                    if( nInWord > nMaxVal )\n                    {\n                        nInWord = nMaxVal;\n                        if( !poGDS->bClipWarn )\n                        {\n                            poGDS->bClipWarn = true;\n                            CPLError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"One or more pixels clipped to fit %d bit \"\n                                \"domain.\", poGDS->nBitsPerSample );\n                        }\n                    }\n\n                    if( (iBitOffset % 8) == 0 )\n                    {\n                        poGDS->pabyBlockBuf[iBitOffset>>3] =\n                            static_cast<GByte>( nInWord >> 4 );\n                        poGDS->pabyBlockBuf[(iBitOffset>>3)+1] =\n                            static_cast<GByte>(\n                                ((nInWord & 0xf) << 4) |\n                                (poGDS->pabyBlockBuf[(iBitOffset>>3)+1] &\n                                 0xf) );\n                    }\n                    else\n                    {\n                        poGDS->pabyBlockBuf[iBitOffset>>3] =\n                            static_cast<GByte>(\n                                (poGDS->pabyBlockBuf[iBitOffset>>3] &\n                                 0xf0) |\n                                (nInWord >> 8));\n                        poGDS->pabyBlockBuf[(iBitOffset>>3)+1] =\n                            static_cast<GByte>(nInWord & 0xff);\n                    }\n\n                    iBitOffset += iPixelBitSkip;\n                }\n                continue;\n            }\n\n            for( int iX = 0; iX < nBlockXSize; ++iX )\n            {\n                GUInt32 nInWord = 0;\n                if( eDataType == GDT_Byte )\n                {\n                    nInWord =\n                        static_cast<const GByte *>(pabyThisImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                    nInWord = reinterpret_cast<const GUInt16 *>(\n                        pabyThisImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                    nInWord = reinterpret_cast<const GUInt32 *>(\n                        pabyThisImage)[iPixel++];\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n\n                if( nInWord > nMaxVal )\n                {\n                    nInWord = nMaxVal;\n                    if( !poGDS->bClipWarn )\n                    {\n                        poGDS->bClipWarn = true;\n                        CPLError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"One or more pixels clipped to fit %d bit domain.\",\n                            poGDS->nBitsPerSample );\n                    }\n                }\n\n                if( poGDS->nBitsPerSample == 24 )\n                {\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n#ifdef CPL_MSB\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 0] =\n                        static_cast<GByte>(nInWord);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 1] =\n                        static_cast<GByte>(nInWord >> 8);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 2] =\n                        static_cast<GByte>(nInWord >> 16);\n#else\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 0] =\n                        static_cast<GByte>(nInWord >> 16);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 1] =\n                        static_cast<GByte>(nInWord >> 8);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 2] =\n                        static_cast<GByte>(nInWord);\n#endif\n                    iBitOffset += 24;\n                }\n                else\n                {\n                    for( int iBit = 0; iBit < poGDS->nBitsPerSample; ++iBit )\n                    {\n                        // TODO(schwehr): Revisit this block.\n                        if( nInWord &\n                            (1 << (poGDS->nBitsPerSample - 1 - iBit)) )\n                        {\n                            poGDS->pabyBlockBuf[iBitOffset>>3] |=\n                                ( 0x80 >> (iBitOffset & 7) );\n                        }\n                        else\n                        {\n                            // We must explicitly unset the bit as we\n                            // may update an existing block.\n                            poGDS->pabyBlockBuf[iBitOffset>>3] &=\n                                ~(0x80 >>(iBitOffset & 7));\n                        }\n\n                        ++iBitOffset;\n                    }\n                }\n\n                iBitOffset = iBitOffset + iPixelBitSkip - poGDS->nBitsPerSample;\n            }\n        }\n\n        if( poBlock != nullptr )\n        {\n            poBlock->MarkClean();\n            poBlock->DropLock();\n        }\n    }\n\n    poGDS->bLoadedBlockDirty = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nstatic void ExpandPacked8ToByte1( const GByte * const CPL_RESTRICT pabySrc,\n                                  GByte* const CPL_RESTRICT pabyDest,\n                                  int nBytes )\n{\n    for( int i = 0, j = 0; i < nBytes; i++, j+= 8 )\n    {\n        const GByte byVal = pabySrc[i];\n        pabyDest[j+0] = (byVal >> 7) & 0x1;\n        pabyDest[j+1] = (byVal >> 6) & 0x1;\n        pabyDest[j+2] = (byVal >> 5) & 0x1;\n        pabyDest[j+3] = (byVal >> 4) & 0x1;\n        pabyDest[j+4] = (byVal >> 3) & 0x1;\n        pabyDest[j+5] = (byVal >> 2) & 0x1;\n        pabyDest[j+6] = (byVal >> 1) & 0x1;\n        pabyDest[j+7] = (byVal >> 0) & 0x1;\n    }\n}\n\n#if defined(__GNUC__) || defined(_MSC_VER)\n// Signedness of char implementation dependent, so be explicit.\n// Assumes 2-complement integer types and sign extension of right shifting\n// GCC guarantees such:\n// https://gcc.gnu.org/onlinedocs/gcc/Integers-implementation.html#Integers-implementation\nstatic inline GByte ExtractBitAndConvertTo255(GByte byVal, int nBit)\n{\n    return\n        static_cast<GByte>(static_cast<signed char>(byVal << (7 - nBit)) >> 7);\n}\n#else\n// Portable way\nstatic inline GByte ExtractBitAndConvertTo255(GByte byVal, int nBit)\n{\n    return (byVal & (1 << nBit)) ? 255 : 0;\n}\n#endif\n\nstatic void ExpandPacked8ToByte255( const GByte * const CPL_RESTRICT pabySrc,\n                                    GByte* const CPL_RESTRICT pabyDest,\n                                    int nBytes )\n{\n    for( int i = 0, j = 0; i < nBytes; i++, j += 8 )\n    {\n        const GByte byVal = pabySrc[i];\n        pabyDest[j+0] = ExtractBitAndConvertTo255(byVal, 7);\n        pabyDest[j+1] = ExtractBitAndConvertTo255(byVal, 6);\n        pabyDest[j+2] = ExtractBitAndConvertTo255(byVal, 5);\n        pabyDest[j+3] = ExtractBitAndConvertTo255(byVal, 4);\n        pabyDest[j+4] = ExtractBitAndConvertTo255(byVal, 3);\n        pabyDest[j+5] = ExtractBitAndConvertTo255(byVal, 2);\n        pabyDest[j+6] = ExtractBitAndConvertTo255(byVal, 1);\n        pabyDest[j+7] = ExtractBitAndConvertTo255(byVal, 0);\n    }\n}\n\nCPLErr GTiffOddBitsBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                     void * pImage )\n\n{\n    if( !poGDS->SetDirectory() )\n        return CE_Failure;\n\n    CPLAssert(nBlocksPerRow != 0);\n    int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId += (nBand - 1) * poGDS->nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Handle the case of a strip in a writable file that doesn't      */\n/*      exist yet, but that we want to read.  Just set to zeros and     */\n/*      return.                                                         */\n/* -------------------------------------------------------------------- */\n    if( nBlockId != poGDS->nLoadedBlock )\n    {\n        bool bErrOccurred = false;\n        if( !poGDS->IsBlockAvailable(nBlockId, nullptr, nullptr, &bErrOccurred) )\n        {\n            NullBlock( pImage );\n            if( bErrOccurred )\n                return CE_Failure;\n            return CE_None;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block buffer.                                          */\n/* -------------------------------------------------------------------- */\n    {\n        const CPLErr eErr = poGDS->LoadBlockBuf( nBlockId );\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n    if( poGDS->nBitsPerSample == 1 &&\n        (poGDS->nBands == 1 || poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE ) )\n    {\n/* -------------------------------------------------------------------- */\n/*      Translate 1bit data to eight bit.                               */\n/* -------------------------------------------------------------------- */\n        int iDstOffset = 0;\n        const GByte * const CPL_RESTRICT pabyBlockBuf = poGDS->pabyBlockBuf;\n        GByte* CPL_RESTRICT pabyDest = static_cast<GByte *>(pImage);\n\n        for( int iLine = 0; iLine < nBlockYSize; ++iLine )\n        {\n            int iSrcOffsetByte = ((nBlockXSize + 7) >> 3) * iLine;\n\n            if( !poGDS->bPromoteTo8Bits )\n            {\n                ExpandPacked8ToByte1( pabyBlockBuf + iSrcOffsetByte,\n                                      pabyDest + iDstOffset,\n                                      nBlockXSize / 8 );\n            }\n            else\n            {\n                ExpandPacked8ToByte255( pabyBlockBuf + iSrcOffsetByte,\n                                        pabyDest + iDstOffset,\n                                        nBlockXSize / 8 );\n            }\n            int iSrcOffsetBit = (iSrcOffsetByte + nBlockXSize / 8) * 8;\n            iDstOffset += nBlockXSize & ~0x7;\n            const GByte bSetVal = poGDS->bPromoteTo8Bits ? 255 : 1;\n            for( int iPixel = nBlockXSize & ~0x7 ;\n                 iPixel < nBlockXSize;\n                 ++iPixel, ++iSrcOffsetBit )\n            {\n                if( pabyBlockBuf[iSrcOffsetBit >>3] &\n                    (0x80 >> (iSrcOffsetBit & 0x7)) )\n                    static_cast<GByte *>(pImage)[iDstOffset++] = bSetVal;\n                else\n                    static_cast<GByte *>(pImage)[iDstOffset++] = 0;\n            }\n        }\n    }\n/* -------------------------------------------------------------------- */\n/*      Handle the case of 16- and 24-bit floating point data as per    */\n/*      TIFF Technical Note 3.                                          */\n/* -------------------------------------------------------------------- */\n    else if( eDataType == GDT_Float32 )\n    {\n        const int nWordBytes = poGDS->nBitsPerSample / 8;\n        const GByte *pabyImage = poGDS->pabyBlockBuf +\n            ( ( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE ) ? 0 :\n              (nBand - 1) * nWordBytes );\n        const int iSkipBytes =\n            ( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE ) ?\n            nWordBytes : poGDS->nBands * nWordBytes;\n\n        const int nBlockPixels = nBlockXSize * nBlockYSize;\n        if( poGDS->nBitsPerSample == 16 )\n        {\n            for( int i = 0; i < nBlockPixels; ++i )\n            {\n                static_cast<GUInt32 *>(pImage)[i] =\n                    HalfToFloat( *reinterpret_cast<const GUInt16 *>(pabyImage) );\n                pabyImage += iSkipBytes;\n            }\n        }\n        else if( poGDS->nBitsPerSample == 24 )\n        {\n            for( int i = 0; i < nBlockPixels; ++i )\n            {\n#ifdef CPL_MSB\n                static_cast<GUInt32 *>(pImage)[i] =\n                    TripleToFloat(\n                        ( static_cast<GUInt32>(*(pabyImage + 0)) << 16)\n                        | (static_cast<GUInt32>(*(pabyImage + 1)) << 8)\n                        | static_cast<GUInt32>(*(pabyImage + 2)) );\n#else\n                static_cast<GUInt32 *>(pImage)[i] =\n                    TripleToFloat(\n                        ( static_cast<GUInt32>(*(pabyImage + 2)) << 16)\n                        | (static_cast<GUInt32>(*(pabyImage + 1)) << 8)\n                        | static_cast<GUInt32>(*pabyImage) );\n#endif\n                pabyImage += iSkipBytes;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for moving 12bit data somewhat more efficiently.   */\n/* -------------------------------------------------------------------- */\n    else if( poGDS->nBitsPerSample == 12 )\n    {\n        int iPixelBitSkip = 0;\n        int iBandBitOffset = 0;\n\n        if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelBitSkip = poGDS->nBands * poGDS->nBitsPerSample;\n            iBandBitOffset = (nBand - 1) * poGDS->nBitsPerSample;\n        }\n        else\n        {\n            iPixelBitSkip = poGDS->nBitsPerSample;\n        }\n\n        // Bits per line rounds up to next byte boundary.\n        int nBitsPerLine = nBlockXSize * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        int iPixel = 0;\n        for( int iY = 0; iY < nBlockYSize; ++iY )\n        {\n            int iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( int iX = 0; iX < nBlockXSize; ++iX )\n            {\n                const int iByte = iBitOffset >> 3;\n\n                if( (iBitOffset & 0x7) == 0 )\n                {\n                    // Starting on byte boundary.\n\n                    static_cast<GUInt16 *>(pImage)[iPixel++] =\n                        (poGDS->pabyBlockBuf[iByte] << 4)\n                        | (poGDS->pabyBlockBuf[iByte+1] >> 4);\n                }\n                else\n                {\n                    // Starting off byte boundary.\n\n                    static_cast<GUInt16 *>(pImage)[iPixel++] =\n                        ((poGDS->pabyBlockBuf[iByte] & 0xf) << 8)\n                        | (poGDS->pabyBlockBuf[iByte+1]);\n                }\n                iBitOffset += iPixelBitSkip;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n    else if( poGDS->nBitsPerSample == 24 )\n    {\n        int iPixelByteSkip = 0;\n        int iBandByteOffset = 0;\n\n        if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelByteSkip = (poGDS->nBands * poGDS->nBitsPerSample) / 8;\n            iBandByteOffset = ((nBand - 1) * poGDS->nBitsPerSample) / 8;\n        }\n        else\n        {\n            iPixelByteSkip = poGDS->nBitsPerSample / 8;\n        }\n\n        const int nBytesPerLine = nBlockXSize * iPixelByteSkip;\n\n        int iPixel = 0;\n        for( int iY = 0; iY < nBlockYSize; ++iY )\n        {\n            GByte *pabyImage =\n                poGDS->pabyBlockBuf + iBandByteOffset + iY * nBytesPerLine;\n\n            for( int iX = 0; iX < nBlockXSize; ++iX )\n            {\n#ifdef CPL_MSB\n                static_cast<GUInt32 *>(pImage)[iPixel++] =\n                    ( static_cast<GUInt32>(*(pabyImage + 2)) << 16)\n                    | (static_cast<GUInt32>(*(pabyImage + 1)) << 8)\n                    | static_cast<GUInt32>(*(pabyImage + 0));\n#else\n                static_cast<GUInt32 *>(pImage)[iPixel++] =\n                    ( static_cast<GUInt32>(*(pabyImage + 0)) << 16)\n                    | (static_cast<GUInt32>(*(pabyImage + 1)) << 8)\n                    | static_cast<GUInt32>(*(pabyImage + 2));\n#endif\n                pabyImage += iPixelByteSkip;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle 1-32 bit integer data.                                   */\n/* -------------------------------------------------------------------- */\n    else\n    {\n        unsigned iPixelBitSkip = 0;\n        unsigned iBandBitOffset = 0;\n\n        if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelBitSkip = poGDS->nBands * poGDS->nBitsPerSample;\n            iBandBitOffset = (nBand - 1) * poGDS->nBitsPerSample;\n        }\n        else\n        {\n            iPixelBitSkip = poGDS->nBitsPerSample;\n        }\n\n        // Bits per line rounds up to next byte boundary.\n        GUIntBig nBitsPerLine = static_cast<GUIntBig>(nBlockXSize) * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        const GByte * const pabyBlockBuf = poGDS->pabyBlockBuf;\n        const unsigned nBitsPerSample = poGDS->nBitsPerSample;\n        unsigned iPixel = 0;\n\n        if( nBitsPerSample == 1 && eDataType == GDT_Byte )\n        {\n          for( unsigned iY = 0; iY < static_cast<unsigned>(nBlockYSize); ++iY )\n          {\n            GUIntBig iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( unsigned iX = 0; iX < static_cast<unsigned>(nBlockXSize); ++iX )\n            {\n                if( pabyBlockBuf[iBitOffset>>3] & (0x80 >>(iBitOffset & 7)) )\n                    static_cast<GByte *>(pImage)[iPixel] = 1;\n                else\n                    static_cast<GByte *>(pImage)[iPixel] = 0;\n                iBitOffset += iPixelBitSkip;\n                iPixel++;\n            }\n          }\n        }\n        else\n        {\n          for( unsigned iY = 0; iY < static_cast<unsigned>(nBlockYSize); ++iY )\n          {\n            GUIntBig iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( unsigned iX = 0; iX < static_cast<unsigned>(nBlockXSize); ++iX )\n            {\n                unsigned nOutWord = 0;\n\n                for( unsigned iBit = 0; iBit < nBitsPerSample; ++iBit )\n                {\n                    if( pabyBlockBuf[iBitOffset>>3]\n                        & (0x80 >>(iBitOffset & 7)) )\n                        nOutWord |= (1 << (nBitsPerSample - 1 - iBit));\n                    ++iBitOffset;\n                }\n\n                iBitOffset = iBitOffset + iPixelBitSkip - nBitsPerSample;\n\n                if( eDataType == GDT_Byte )\n                {\n                    static_cast<GByte *>(pImage)[iPixel++] =\n                        static_cast<GByte>(nOutWord);\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                  static_cast<GUInt16 *>(pImage)[iPixel++] =\n                      static_cast<GUInt16>(nOutWord);\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                  static_cast<GUInt32 *>(pImage)[iPixel++] = nOutWord;\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n            }\n          }\n        }\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffBitmapBand                          */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffBitmapBand : public GTiffOddBitsBand\n{\n    friend class GTiffDataset;\n\n    GDALColorTable *poColorTable = nullptr;\n\n    CPL_DISALLOW_COPY_ASSIGN(GTiffBitmapBand)\n\n  public:\n\n                   GTiffBitmapBand( GTiffDataset *, int );\n    virtual       ~GTiffBitmapBand();\n\n    virtual GDALColorInterp GetColorInterpretation() override;\n    virtual GDALColorTable *GetColorTable() override;\n};\n\n/************************************************************************/\n/*                           GTiffBitmapBand()                          */\n/************************************************************************/\n\nGTiffBitmapBand::GTiffBitmapBand( GTiffDataset *poDSIn, int nBandIn )\n        : GTiffOddBitsBand( poDSIn, nBandIn )\n\n{\n    eDataType = GDT_Byte;\n\n    if( poDSIn->poColorTable != nullptr )\n    {\n        poColorTable = poDSIn->poColorTable->Clone();\n    }\n    else\n    {\n#ifdef ESRI_BUILD\n        poColorTable = nullptr;\n#else\n        const GDALColorEntry oWhite = { 255, 255, 255, 255 };\n        const GDALColorEntry oBlack = { 0, 0, 0, 255 };\n\n        poColorTable = new GDALColorTable();\n\n        if( poDSIn->nPhotometric == PHOTOMETRIC_MINISWHITE )\n        {\n            poColorTable->SetColorEntry( 0, &oWhite );\n            poColorTable->SetColorEntry( 1, &oBlack );\n        }\n        else\n        {\n            poColorTable->SetColorEntry( 0, &oBlack );\n            poColorTable->SetColorEntry( 1, &oWhite );\n        }\n#endif  // not defined ESRI_BUILD.\n    }\n}\n\n/************************************************************************/\n/*                          ~GTiffBitmapBand()                          */\n/************************************************************************/\n\nGTiffBitmapBand::~GTiffBitmapBand()\n\n{\n    delete poColorTable;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffBitmapBand::GetColorInterpretation()\n\n{\n    if( poGDS->bPromoteTo8Bits )\n        return GCI_Undefined;\n\n    return GCI_PaletteIndex;\n}\n\n/************************************************************************/\n/*                           GetColorTable()                            */\n/************************************************************************/\n\nGDALColorTable *GTiffBitmapBand::GetColorTable()\n\n{\n    if( poGDS->bPromoteTo8Bits )\n        return nullptr;\n\n    return poColorTable;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                          GTiffSplitBitmapBand                        */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffSplitBitmapBand final : public GTiffBitmapBand\n{\n    friend class GTiffDataset;\n    int nLastLineValid;\n\n  public:\n\n                   GTiffSplitBitmapBand( GTiffDataset *, int );\n    virtual       ~GTiffSplitBitmapBand();\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                       GTiffSplitBitmapBand()                         */\n/************************************************************************/\n\nGTiffSplitBitmapBand::GTiffSplitBitmapBand( GTiffDataset *poDSIn, int nBandIn )\n        : GTiffBitmapBand( poDSIn, nBandIn )\n        , nLastLineValid( -1 )\n\n{\n    nBlockXSize = poDS->GetRasterXSize();\n    nBlockYSize = 1;\n}\n\n/************************************************************************/\n/*                      ~GTiffSplitBitmapBand()                         */\n/************************************************************************/\n\nGTiffSplitBitmapBand::~GTiffSplitBitmapBand() {}\n\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffSplitBitmapBand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                            GTIFFErrorHandler()                       */\n/************************************************************************/\n\nnamespace {\nclass GTIFFErrorStruct final\n{\n  public:\n    CPLErr type;\n    CPLErrorNum no;\n    CPLString msg{};\n\n    GTIFFErrorStruct() : type(CE_None), no(CPLE_None) {}\n    GTIFFErrorStruct(CPLErr eErrIn, CPLErrorNum noIn, const char* msgIn) :\n        type(eErrIn), no(noIn), msg(msgIn) {}\n};\n}\n\nstatic void CPL_STDCALL GTIFFErrorHandler( CPLErr eErr, CPLErrorNum no,\n                                           const char* msg )\n{\n    std::vector<GTIFFErrorStruct>* paoErrors =\n        static_cast<std::vector<GTIFFErrorStruct> *>(\n            CPLGetErrorHandlerUserData());\n    paoErrors->push_back(GTIFFErrorStruct(eErr, no, msg));\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBitmapBand::IReadBlock( int /* nBlockXOff */, int nBlockYOff,\n                                         void * pImage )\n\n{\n    if( nLastLineValid >= 0 && nBlockYOff > nLastLineValid )\n        return CE_Failure;\n\n    if( !poGDS->SetDirectory() )\n        return CE_Failure;\n\n    if( poGDS->pabyBlockBuf == nullptr )\n    {\n        poGDS->pabyBlockBuf =\n            static_cast<GByte *>(\n                VSI_MALLOC_VERBOSE(TIFFScanlineSize(poGDS->hTIFF)) );\n        if( poGDS->pabyBlockBuf == nullptr )\n        {\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read through to target scanline.                                */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nLastLineRead >= nBlockYOff )\n        poGDS->nLastLineRead = -1;\n\n    while( poGDS->nLastLineRead < nBlockYOff )\n    {\n        ++poGDS->nLastLineRead;\n\n        std::vector<GTIFFErrorStruct> aoErrors;\n        CPLPushErrorHandlerEx(GTIFFErrorHandler, &aoErrors);\n        int nRet = TIFFReadScanline( poGDS->hTIFF, poGDS->pabyBlockBuf,\n                                     poGDS->nLastLineRead, 0 );\n        CPLPopErrorHandler();\n\n        for( size_t iError = 0; iError < aoErrors.size(); ++iError )\n        {\n            CPLError( aoErrors[iError].type,\n                      aoErrors[iError].no,\n                      \"%s\",\n                      aoErrors[iError].msg.c_str() );\n            // FAX decoding only handles EOF condition as a warning, so\n            // catch it so as to turn on error when attempting to read\n            // following lines, to avoid performance issues.\n            if(  !poGDS->bIgnoreReadErrors &&\n                    aoErrors[iError].msg.find(\"Premature EOF\") !=\n                                                    std::string::npos )\n            {\n                nLastLineValid = nBlockYOff;\n                nRet = -1;\n            }\n        }\n\n        if( nRet == -1\n            && !poGDS->bIgnoreReadErrors )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadScanline() failed.\" );\n            poGDS->nLastLineRead = -1;\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Translate 1bit data to eight bit.                               */\n/* -------------------------------------------------------------------- */\n    int iSrcOffset = 0;\n    int iDstOffset = 0;\n\n    for( int iPixel = 0; iPixel < nBlockXSize; ++iPixel, ++iSrcOffset )\n    {\n        if( poGDS->pabyBlockBuf[iSrcOffset >>3] & (0x80 >> (iSrcOffset & 0x7)) )\n            static_cast<GByte *>(pImage)[iDstOffset++] = 1;\n        else\n            static_cast<GByte *>(pImage)[iDstOffset++] = 0;\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBitmapBand::IWriteBlock( int /* nBlockXOff */,\n                                          int /* nBlockYOff */,\n                                          void * /* pImage */ )\n\n{\n    CPLError( CE_Failure, CPLE_AppDefined,\n              \"Split bitmap bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                            GTiffDataset                              */\n/* ==================================================================== */\n/************************************************************************/\n\n/************************************************************************/\n/*                            GTiffDataset()                            */\n/************************************************************************/\n\nGTiffDataset::GTiffDataset() :\n    hTIFF(nullptr),\n    fpL(nullptr),\n#if defined(INTERNAL_LIBTIFF) && defined(DEFER_STRILE_LOAD)\n    nStripArrayAlloc(0),\n    m_nFileSize(0),\n#endif\n    bStreamingIn(false),\n    bStreamingOut(false),\n    fpToWrite(nullptr),\n    nLastWrittenBlockId(-1),\n    ppoActiveDSRef(nullptr),\n    poActiveDS(nullptr),\n    bScanDeferred(true),\n    nDirOffset(0),\n    bBase(true),\n    bCloseTIFFHandle(false),\n    nPlanarConfig(0),\n    nSamplesPerPixel(0),\n    nBitsPerSample(0),\n    nRowsPerStrip(0),\n    nPhotometric(0),\n    nSampleFormat(0),\n    nCompression(0),\n    nBlocksPerBand(0),\n    nBlockXSize(0),\n    nBlockYSize(0),\n    nLoadedBlock(-1),\n    bLoadedBlockDirty(false),\n    pabyBlockBuf(nullptr),\n    bWriteErrorInFlushBlockBuf(false),\n    pszProjection(CPLStrdup(\"\")),\n    bLookedForProjection(false),\n    bLookedForMDAreaOrPoint(false),\n    bGeoTransformValid(false),\n    bTreatAsRGBA(false),\n    bCrystalized(true),\n    poColorTable(nullptr),\n    nOverviewCount(0),\n    papoOverviewDS(nullptr),\n    nJPEGOverviewVisibilityCounter(0),\n    nJPEGOverviewCount(-1),\n    nJPEGOverviewCountOri(0),\n    papoJPEGOverviewDS(nullptr),\n    nGCPCount(0),\n    pasGCPList(nullptr),\n    bGeoTIFFInfoChanged(false),\n    bForceUnsetGTOrGCPs(false),\n    bForceUnsetProjection(false),\n    bNoDataChanged(false),\n    bNoDataSet(false),\n    dfNoDataValue(-9999.0),\n    bMetadataChanged(false),\n    bColorProfileMetadataChanged(false),\n    bNeedsRewrite(false),\n    osProfile(szPROFILE_GDALGeoTIFF),\n    papszCreationOptions(nullptr),\n    bLoadingOtherBands(false),\n    pabyTempWriteBuffer(nullptr),\n    nTempWriteBufferSize(0),\n    poMaskDS(nullptr),\n    poBaseDS(nullptr),\n    bWriteEmptyTiles(true),\n    bFillEmptyTilesAtClosing(false),\n    nLastLineRead(-1),\n    nLastBandRead(-1),\n    bTreatAsSplit(false),\n    bTreatAsSplitBitmap(false),\n    bClipWarn(false),\n    bIMDRPCMetadataLoaded(false),\n    papszMetadataFiles(nullptr),\n    bEXIFMetadataLoaded(false),\n    bICCMetadataLoaded(false),\n    bHasWarnedDisableAggressiveBandCaching(false),\n    bDontReloadFirstBlock(false),\n    nZLevel(-1),\n    nLZMAPreset(-1),\n    nZSTDLevel(-1),\n    nWebPLevel(-1),\n    bWebPLossless(false),\n    nJpegQuality(-1),\n    nJpegTablesMode(-1),\n    bPromoteTo8Bits(false),\n    bDebugDontWriteBlocks(false),\n    bIsFinalized(false),\n    bIgnoreReadErrors(false),\n    bDirectIO(false),\n    eVirtualMemIOUsage(VIRTUAL_MEM_IO_NO),\n    psVirtualMemIOMapping(nullptr),\n    eGeoTIFFKeysFlavor(GEOTIFF_KEYS_STANDARD),\n    pBaseMapping(nullptr),\n    nRefBaseMapping(0),\n    bHasDiscardedLsb(false),\n    poCompressThreadPool(nullptr),\n    hCompressThreadPoolMutex(nullptr),\n    m_pTempBufferForCommonDirectIO(nullptr),\n    m_nTempBufferForCommonDirectIOSize(0),\n    m_bReadGeoTransform(false),\n    m_bLoadPam(false),\n    m_bHasGotSiblingFiles(false),\n    m_bHasIdentifiedAuthorizedGeoreferencingSources(false),\n    m_nPAMGeorefSrcIndex(-1),\n    m_nINTERNALGeorefSrcIndex(-1),\n    m_nTABFILEGeorefSrcIndex(-1),\n    m_nWORLDFILEGeorefSrcIndex(-1),\n    m_nGeoTransformGeorefSrcIndex(-1)\n{\n    adfGeoTransform[0] = 0.0;\n    adfGeoTransform[1] = 1.0;\n    adfGeoTransform[2] = 0.0;\n    adfGeoTransform[3] = 0.0;\n    adfGeoTransform[4] = 0.0;\n    adfGeoTransform[5] = 1.0;\n\n    bDebugDontWriteBlocks =\n        CPLTestBool(CPLGetConfigOption(\"GTIFF_DONT_WRITE_BLOCKS\", \"NO\"));\n\n    bIgnoreReadErrors =\n        CPLTestBool(CPLGetConfigOption(\"GTIFF_IGNORE_READ_ERRORS\", \"NO\"));\n\n    bDirectIO = CPLTestBool(CPLGetConfigOption(\"GTIFF_DIRECT_IO\", \"NO\"));\n\n    const char* pszVirtualMemIO =\n        CPLGetConfigOption(\"GTIFF_VIRTUAL_MEM_IO\", \"NO\");\n    if( EQUAL(pszVirtualMemIO, \"IF_ENOUGH_RAM\") )\n        eVirtualMemIOUsage = VIRTUAL_MEM_IO_IF_ENOUGH_RAM;\n    else if( CPLTestBool(pszVirtualMemIO) )\n        eVirtualMemIOUsage = VIRTUAL_MEM_IO_YES;\n}\n\n/************************************************************************/\n/*                           ~GTiffDataset()                            */\n/************************************************************************/\n\nGTiffDataset::~GTiffDataset()\n\n{\n    Finalize();\n    if( !osTmpFilename.empty() )\n        VSIUnlink(osTmpFilename);\n}\n\n/************************************************************************/\n/*                             Finalize()                               */\n/************************************************************************/\n\nint GTiffDataset::Finalize()\n{\n    if( bIsFinalized )\n        return FALSE;\n\n    bool bHasDroppedRef = false;\n\n    Crystalize();\n\n    if( bColorProfileMetadataChanged )\n    {\n        SaveICCProfile(this, nullptr, nullptr, 0);\n        bColorProfileMetadataChanged = false;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle forcing xml:ESRI data to be written to PAM.              */\n/* -------------------------------------------------------------------- */\n    if( CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n    {\n        char **papszESRIMD = GTiffDataset::GetMetadata(\"xml:ESRI\");\n        if( papszESRIMD )\n        {\n            GDALPamDataset::SetMetadata( papszESRIMD, \"xml:ESRI\");\n        }\n    }\n\n    if( psVirtualMemIOMapping )\n        CPLVirtualMemFree( psVirtualMemIOMapping );\n    psVirtualMemIOMapping = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Fill in missing blocks with empty data.                         */\n/* -------------------------------------------------------------------- */\n    if( bFillEmptyTilesAtClosing )\n    {\n/* -------------------------------------------------------------------- */\n/*  Ensure any blocks write cached by GDAL gets pushed through libtiff. */\n/* -------------------------------------------------------------------- */\n        FlushCacheInternal( false /* do not call FlushDirectory */ );\n\n        FillEmptyTiles();\n        bFillEmptyTilesAtClosing = false;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Force a complete flush, including either rewriting(moving)      */\n/*      of writing in place the current directory.                      */\n/* -------------------------------------------------------------------- */\n    FlushCacheInternal( true );\n\n    // Destroy compression pool.\n    if( poCompressThreadPool )\n    {\n        poCompressThreadPool->WaitCompletion();\n\n        // Save thread pool for later reuse.\n        {\n            std::lock_guard<std::mutex> oLock(gMutexThreadPool);\n            delete gpoCompressThreadPool;\n            gpoCompressThreadPool = poCompressThreadPool;\n            poCompressThreadPool = nullptr;\n        }\n\n        for( int i = 0; i < static_cast<int>(asCompressionJobs.size()); ++i )\n        {\n            CPLFree(asCompressionJobs[i].pabyBuffer);\n            if( asCompressionJobs[i].pszTmpFilename )\n            {\n                VSIUnlink(asCompressionJobs[i].pszTmpFilename);\n                CPLFree(asCompressionJobs[i].pszTmpFilename);\n            }\n        }\n        CPLDestroyMutex(hCompressThreadPoolMutex);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If there is still changed metadata, then presumably we want     */\n/*      to push it into PAM.                                            */\n/* -------------------------------------------------------------------- */\n    if( bMetadataChanged )\n    {\n        PushMetadataToPam();\n        bMetadataChanged = false;\n        GDALPamDataset::FlushCache();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews.                                              */\n/* -------------------------------------------------------------------- */\n    if( bBase )\n    {\n        for( int i = 0; i < nOverviewCount; ++i )\n        {\n            delete papoOverviewDS[i];\n            bHasDroppedRef = true;\n        }\n        nOverviewCount = 0;\n\n        for( int i = 0; i < nJPEGOverviewCountOri; ++i )\n        {\n            delete papoJPEGOverviewDS[i];\n            bHasDroppedRef = true;\n        }\n        nJPEGOverviewCount = 0;\n        nJPEGOverviewCountOri = 0;\n        CPLFree( papoJPEGOverviewDS );\n        papoJPEGOverviewDS = nullptr;\n    }\n\n    // If we are a mask dataset, we can have overviews, but we don't\n    // own them. We can only free the array, not the overviews themselves.\n    CPLFree( papoOverviewDS );\n    papoOverviewDS = nullptr;\n\n    // poMaskDS is owned by the main image and the overviews\n    // so because of the latter case, we can delete it even if\n    // we are not the base image.\n    if( poMaskDS )\n    {\n        delete poMaskDS;\n        poMaskDS = nullptr;\n        bHasDroppedRef = true;\n    }\n\n    if( poColorTable != nullptr )\n        delete poColorTable;\n    poColorTable = nullptr;\n\n    if( bBase || bCloseTIFFHandle )\n    {\n        XTIFFClose( hTIFF );\n        hTIFF = nullptr;\n        if( fpL != nullptr )\n        {\n            if( VSIFCloseL( fpL ) != 0 )\n            {\n                CPLError(CE_Failure, CPLE_FileIO, \"I/O error\");\n            }\n            fpL = nullptr;\n        }\n    }\n\n    if( fpToWrite != nullptr )\n    {\n        if( VSIFCloseL( fpToWrite ) != 0 )\n        {\n            CPLError(CE_Failure, CPLE_FileIO, \"I/O error\");\n        }\n        fpToWrite = nullptr;\n    }\n\n    if( nGCPCount > 0 )\n    {\n        GDALDeinitGCPs( nGCPCount, pasGCPList );\n        CPLFree( pasGCPList );\n        pasGCPList = nullptr;\n        nGCPCount = 0;\n    }\n\n    CPLFree( pszProjection );\n    pszProjection = nullptr;\n\n    CSLDestroy( papszCreationOptions );\n    papszCreationOptions = nullptr;\n\n    CPLFree(pabyTempWriteBuffer);\n    pabyTempWriteBuffer = nullptr;\n\n    if( ppoActiveDSRef != nullptr && *ppoActiveDSRef == this )\n        *ppoActiveDSRef = nullptr;\n    ppoActiveDSRef = nullptr;\n\n    bIMDRPCMetadataLoaded = false;\n    CSLDestroy(papszMetadataFiles);\n    papszMetadataFiles = nullptr;\n\n    VSIFree(m_pTempBufferForCommonDirectIO);\n    m_pTempBufferForCommonDirectIO = nullptr;\n\n    bIsFinalized = true;\n\n    return bHasDroppedRef;\n}\n\n/************************************************************************/\n/*                        CloseDependentDatasets()                      */\n/************************************************************************/\n\nint GTiffDataset::CloseDependentDatasets()\n{\n    if( !bBase )\n        return FALSE;\n\n    int bHasDroppedRef = GDALPamDataset::CloseDependentDatasets();\n\n    bHasDroppedRef |= Finalize();\n\n    return bHasDroppedRef;\n}\n\n/************************************************************************/\n/*                        GetJPEGOverviewCount()                        */\n/************************************************************************/\n\nint GTiffDataset::GetJPEGOverviewCount()\n{\n    if( nJPEGOverviewCount >= 0 )\n        return nJPEGOverviewCount;\n\n    nJPEGOverviewCount = 0;\n    if( !bBase || eAccess != GA_ReadOnly || nCompression != COMPRESSION_JPEG ||\n        (nRasterXSize < 256 && nRasterYSize < 256) ||\n        !CPLTestBool(CPLGetConfigOption(\"GTIFF_IMPLICIT_JPEG_OVR\", \"YES\")) ||\n        GDALGetDriverByName(\"JPEG\") == nullptr )\n    {\n        return 0;\n    }\n    const char* pszSourceColorSpace =\n        oGTiffMDMD.GetMetadataItem( \"SOURCE_COLOR_SPACE\", \"IMAGE_STRUCTURE\" );\n    if( pszSourceColorSpace != nullptr && EQUAL(pszSourceColorSpace, \"CMYK\") )\n    {\n        // We cannot handle implicit overviews on JPEG CMYK datasets converted\n        // to RGBA This would imply doing the conversion in\n        // GTiffJPEGOverviewBand.\n        return 0;\n    }\n\n    // libjpeg-6b only supports 2, 4 and 8 scale denominators.\n    // TODO: Later versions support more.\n    for( int i = 2; i >= 0; i-- )\n    {\n        if( nRasterXSize >= (256 << i) || nRasterYSize >= (256 << i) )\n        {\n            nJPEGOverviewCount = i + 1;\n            break;\n        }\n    }\n    if( nJPEGOverviewCount == 0 )\n        return 0;\n\n    if( !SetDirectory() )\n    {\n        nJPEGOverviewCount = 0;\n        return 0;\n    }\n\n    // Get JPEG tables.\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    GByte abyFFD8[] = { 0xFF, 0xD8 };\n    if( TIFFGetField(hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize, &pJPEGTable) )\n    {\n        if( pJPEGTable == nullptr ||\n            nJPEGTableSize > INT_MAX ||\n            static_cast<GByte*>(pJPEGTable)[nJPEGTableSize-1] != 0xD9 )\n        {\n            nJPEGOverviewCount = 0;\n            return 0;\n        }\n        nJPEGTableSize--;  // Remove final 0xD9.\n    }\n    else\n    {\n        pJPEGTable = abyFFD8;\n        nJPEGTableSize = 2;\n    }\n\n    papoJPEGOverviewDS =\n        static_cast<GTiffJPEGOverviewDS **>(\n            CPLMalloc( sizeof(GTiffJPEGOverviewDS*) * nJPEGOverviewCount ) );\n    for( int i = 0; i < nJPEGOverviewCount; ++i )\n    {\n        papoJPEGOverviewDS[i] =\n            new GTiffJPEGOverviewDS(\n                this, i + 1,\n                pJPEGTable, static_cast<int>(nJPEGTableSize) );\n    }\n\n    nJPEGOverviewCountOri = nJPEGOverviewCount;\n\n    return nJPEGOverviewCount;\n}\n\n/************************************************************************/\n/*                           FillEmptyTiles()                           */\n/************************************************************************/\n\nvoid GTiffDataset::FillEmptyTiles()\n\n{\n    if( !SetDirectory() )\n        return;\n\n/* -------------------------------------------------------------------- */\n/*      How many blocks are there in this file?                         */\n/* -------------------------------------------------------------------- */\n    const int nBlockCount =\n        nPlanarConfig == PLANARCONFIG_SEPARATE ?\n        nBlocksPerBand * nBands :\n        nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Fetch block maps.                                               */\n/* -------------------------------------------------------------------- */\n    toff_t *panByteCounts = nullptr;\n\n    if( TIFFIsTiled( hTIFF ) )\n        TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts );\n    else\n        TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts );\n\n    if( panByteCounts == nullptr )\n    {\n        // Got here with libtiff 3.9.3 and tiff_write_8 test.\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"FillEmptyTiles() failed because panByteCounts == NULL\" );\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Prepare a blank data buffer to write for uninitialized blocks.  */\n/* -------------------------------------------------------------------- */\n    const int nBlockBytes =\n        TIFFIsTiled( hTIFF ) ?\n        static_cast<int>(TIFFTileSize(hTIFF)) :\n        static_cast<int>(TIFFStripSize(hTIFF));\n\n    GByte *pabyData =\n        static_cast<GByte *>( VSI_CALLOC_VERBOSE(nBlockBytes, 1) );\n    if( pabyData == nullptr )\n    {\n        return;\n    }\n\n    // Force tiles completely filled with the nodata value to be written.\n    bWriteEmptyTiles = true;\n\n/* -------------------------------------------------------------------- */\n/*      If set, fill data buffer with no data value.                    */\n/* -------------------------------------------------------------------- */\n    if( bNoDataSet && dfNoDataValue != 0.0 )\n    {\n        const GDALDataType eDataType = GetRasterBand( 1 )->GetRasterDataType();\n        const int nDataTypeSize = GDALGetDataTypeSizeBytes( eDataType );\n        if( nDataTypeSize &&\n            nDataTypeSize * 8 == static_cast<int>(nBitsPerSample) )\n        {\n            GDALCopyWords( &dfNoDataValue, GDT_Float64, 0,\n                           pabyData, eDataType,\n                           nDataTypeSize,\n                           nBlockBytes / nDataTypeSize );\n        }\n        else if( nDataTypeSize )\n        {\n            // Handle non power-of-two depths.\n            // Ideally make a packed buffer, but that is a bit tedious,\n            // so use the normal I/O interfaces.\n\n            CPLFree( pabyData );\n\n            pabyData = static_cast<GByte *>(\n                VSI_MALLOC3_VERBOSE(nBlockXSize, nBlockYSize, nDataTypeSize) );\n            if( pabyData == nullptr )\n                return;\n            GDALCopyWords( &dfNoDataValue, GDT_Float64, 0,\n                           pabyData, eDataType,\n                           nDataTypeSize,\n                           nBlockXSize * nBlockYSize );\n            const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n            for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n            {\n                if( panByteCounts[iBlock] == 0 )\n                {\n                    if( nPlanarConfig == PLANARCONFIG_SEPARATE || nBands == 1 )\n                    {\n                        CPL_IGNORE_RET_VAL( GetRasterBand(\n                            1 + iBlock / nBlocksPerBand )->WriteBlock(\n                                (iBlock % nBlocksPerBand) % nBlocksPerRow,\n                                (iBlock % nBlocksPerBand) / nBlocksPerRow,\n                                pabyData ) );\n                    }\n                    else\n                    {\n                        // In contig case, don't directly call WriteBlock(), as\n                        // it could cause useless decompression-recompression.\n                        const int nXOff =\n                            (iBlock % nBlocksPerRow) * nBlockXSize;\n                        const int nYOff =\n                            (iBlock / nBlocksPerRow) * nBlockYSize;\n                        const int nXSize =\n                            (nXOff + nBlockXSize <= nRasterXSize) ?\n                            nBlockXSize : nRasterXSize - nXOff;\n                        const int nYSize =\n                            (nYOff + nBlockYSize <= nRasterYSize) ?\n                            nBlockYSize : nRasterYSize - nYOff;\n                        for( int iBand = 1; iBand <= nBands; ++iBand )\n                        {\n                            CPL_IGNORE_RET_VAL( GetRasterBand( iBand )->\n                                RasterIO(\n                                    GF_Write, nXOff, nYOff, nXSize, nYSize,\n                                    pabyData, nXSize, nYSize,\n                                    eDataType, 0, 0, nullptr ) );\n                        }\n                    }\n                }\n            }\n            CPLFree( pabyData );\n            return;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      When we must fill with zeroes, try to create non-sparse file    */\n/*      w.r.t TIFF spec ... as a sparse file w.r.t filesystem, ie by    */\n/*      seeking to end of file instead of writing zero blocks.          */\n/* -------------------------------------------------------------------- */\n    else if( nCompression == COMPRESSION_NONE && (nBitsPerSample % 8) == 0 )\n    {\n        // Only use libtiff to write the first sparse block to ensure that it\n        // will serialize offset and count arrays back to disk.\n        int nCountBlocksToZero = 0;\n        for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n        {\n            if( panByteCounts[iBlock] == 0 )\n            {\n                if( nCountBlocksToZero == 0 )\n                {\n                    const bool bWriteEmptyTilesBak = bWriteEmptyTiles;\n                    bWriteEmptyTiles = true;\n                    const bool bOK =\n                        WriteEncodedTileOrStrip( iBlock, pabyData,\n                                                 FALSE ) == CE_None;\n                    bWriteEmptyTiles = bWriteEmptyTilesBak;\n                    if( !bOK )\n                        break;\n                }\n                nCountBlocksToZero++;\n            }\n        }\n        CPLFree( pabyData );\n\n        --nCountBlocksToZero;\n\n        // And then seek to end of file for other ones.\n        if( nCountBlocksToZero > 0 )\n        {\n            toff_t *panByteOffsets = nullptr;\n\n            if( TIFFIsTiled( hTIFF ) )\n                TIFFGetField( hTIFF, TIFFTAG_TILEOFFSETS, &panByteOffsets );\n            else\n                TIFFGetField( hTIFF, TIFFTAG_STRIPOFFSETS, &panByteOffsets );\n\n            if( panByteOffsets == nullptr )\n            {\n                CPLError(\n                    CE_Failure, CPLE_AppDefined,\n                    \"FillEmptyTiles() failed because panByteOffsets == NULL\");\n                return;\n            }\n\n            VSILFILE* fpTIF = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n            VSIFSeekL( fpTIF, 0, SEEK_END );\n            const vsi_l_offset nOffset = VSIFTellL(fpTIF);\n\n            vsi_l_offset iBlockToZero = 0;\n            for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n            {\n                if( panByteCounts[iBlock] == 0 )\n                {\n                    panByteOffsets[iBlock] = static_cast<toff_t>(\n                                        nOffset + iBlockToZero * nBlockBytes);\n                    panByteCounts[iBlock] = nBlockBytes;\n                    iBlockToZero++;\n                }\n            }\n            CPLAssert( iBlockToZero ==\n                       static_cast<vsi_l_offset>(nCountBlocksToZero) );\n\n            if( VSIFTruncateL( fpTIF,\n                               nOffset + iBlockToZero * nBlockBytes ) != 0 )\n            {\n                CPLError(CE_Failure, CPLE_FileIO,\n                         \"Cannot initialize empty blocks\");\n            }\n        }\n\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check all blocks, writing out data for uninitialized blocks.    */\n/* -------------------------------------------------------------------- */\n\n    GByte* pabyRaw = nullptr;\n    vsi_l_offset nRawSize = 0;\n    for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n    {\n        if( panByteCounts[iBlock] == 0 )\n        {\n            if( pabyRaw == nullptr )\n            {\n                if( WriteEncodedTileOrStrip( iBlock, pabyData, FALSE\n                                                                ) != CE_None )\n                    break;\n\n                vsi_l_offset nOffset = 0;\n                bool b = IsBlockAvailable( iBlock, &nOffset, &nRawSize);\n#ifdef DEBUG\n                CPLAssert(b);\n#else\n                CPL_IGNORE_RET_VAL(b);\n#endif\n                // When using compression, get back the compressed block\n                // so we can use the raw API to write it faster.\n                if( nCompression != COMPRESSION_NONE )\n                {\n                    pabyRaw = static_cast<GByte*>(\n                            VSI_MALLOC_VERBOSE(static_cast<int>(nRawSize)));\n                    if( pabyRaw )\n                    {\n                        VSILFILE* fp = VSI_TIFFGetVSILFile(\n                                                    TIFFClientdata( hTIFF ));\n                        const vsi_l_offset nCurOffset = VSIFTellL(fp);\n                        VSIFSeekL(fp, nOffset, SEEK_SET);\n                        VSIFReadL(pabyRaw, 1, static_cast<int>(nRawSize), fp);\n                        VSIFSeekL(fp, nCurOffset, SEEK_SET);\n                    }\n                }\n            }\n            else\n            {\n                WriteRawStripOrTile( iBlock, pabyRaw,\n                                     static_cast<int>(nRawSize) );\n            }\n        }\n    }\n\n    CPLFree( pabyData );\n    VSIFree( pabyRaw );\n}\n\n/************************************************************************/\n/*                         HasOnlyNoData()                              */\n/************************************************************************/\n\ntemplate<class T>\nstatic inline bool IsEqualToNoData( T value, T noDataValue )\n{\n    return value == noDataValue;\n}\n\ntemplate<> bool IsEqualToNoData<float>( float value, float noDataValue )\n{\n    return\n        CPLIsNan(noDataValue) ?\n        CPL_TO_BOOL(CPLIsNan(value)) : value == noDataValue;\n}\n\ntemplate<> bool IsEqualToNoData<double>( double value, double noDataValue )\n{\n    return\n        CPLIsNan(noDataValue) ?\n        CPL_TO_BOOL(CPLIsNan(value)) : value == noDataValue;\n}\n\ntemplate<class T>\nbool GTiffDataset::HasOnlyNoDataT( const T* pBuffer, int nWidth, int nHeight,\n                                   int nLineStride, int nComponents ) const\n{\n    const T noDataValue = static_cast<T>((bNoDataSet) ? dfNoDataValue : 0.0);\n    // Fast test: check the 4 corners and the middle pixel.\n    for( int iBand = 0; iBand < nComponents; iBand++ )\n    {\n        if( !(IsEqualToNoData(pBuffer[iBand], noDataValue) &&\n              IsEqualToNoData(\n                  pBuffer[static_cast<size_t>(nWidth - 1) * nComponents +\n                          iBand],\n                  noDataValue) &&\n              IsEqualToNoData(\n                  pBuffer[(static_cast<size_t>(nHeight-1)/2 * nLineStride +\n                           (nWidth - 1)/2) * nComponents + iBand],\n                  noDataValue) &&\n              IsEqualToNoData(\n                  pBuffer[static_cast<size_t>(nHeight - 1) * nLineStride *\n                          nComponents + iBand], noDataValue) &&\n              IsEqualToNoData(\n                  pBuffer[(static_cast<size_t>(nHeight - 1) * nLineStride +\n                           nWidth - 1) * nComponents + iBand], noDataValue) ) )\n        {\n            return false;\n        }\n    }\n\n    // Test all pixels.\n    for( int iY = 0; iY < nHeight; iY++ )\n    {\n        for( int iX = 0; iX < nWidth * nComponents; iX++ )\n        {\n            if( !IsEqualToNoData(\n                   pBuffer[iY * static_cast<size_t>(nLineStride) * nComponents +\n                           iX], noDataValue) )\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool GTiffDataset::HasOnlyNoData( const void* pBuffer, int nWidth, int nHeight,\n                                  int nLineStride, int nComponents )\n{\n    const GDALDataType eDT = GetRasterBand(1)->GetRasterDataType();\n\n    // In the case where the nodata is 0, we can compare several bytes at\n    // once. Select the largest natural integer type for the architecture.\n#if SIZEOF_VOIDP == 8 || defined(__x86_64__)\n    // We test __x86_64__ for x32 arch where SIZEOF_VOIDP == 4\n    typedef GUInt64 WordType;\n#else\n    typedef unsigned int WordType;\n#endif\n    if( (!bNoDataSet || dfNoDataValue == 0.0) && nWidth == nLineStride\n#ifdef CPL_CPU_REQUIRES_ALIGNED_ACCESS\n        && CPL_IS_ALIGNED(pBuffer, sizeof(WordType))\n#endif\n        )\n    {\n        const GByte* pabyBuffer = static_cast<const GByte*>(pBuffer);\n        const size_t nSize = static_cast<size_t>(nWidth) * nHeight *\n                             nComponents * GDALGetDataTypeSizeBytes(eDT);\n        size_t i = 0;\n        for( ; i + sizeof(WordType) - 1 < nSize; i += sizeof(WordType) )\n        {\n            if( *(reinterpret_cast<const WordType*>(pabyBuffer + i)) )\n                return false;\n        }\n        for( ; i < nSize; i++ )\n        {\n            if( pabyBuffer[i] )\n                return false;\n        }\n        return true;\n    }\n\n    if( nBitsPerSample == 8 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n        {\n            return HasOnlyNoDataT(static_cast<const signed char*>(pBuffer),\n                                  nWidth, nHeight, nLineStride, nComponents);\n        }\n        return HasOnlyNoDataT(static_cast<const GByte*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 16 && eDT == GDT_UInt16 )\n    {\n        return HasOnlyNoDataT(static_cast<const GUInt16*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 16 && eDT== GDT_Int16 )\n    {\n        return HasOnlyNoDataT(static_cast<const GInt16*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 32 && eDT == GDT_UInt32 )\n    {\n        return HasOnlyNoDataT(static_cast<const GUInt32*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 32 && eDT == GDT_Int32 )\n    {\n        return HasOnlyNoDataT(static_cast<const GInt32*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 32 && eDT == GDT_Float32 )\n    {\n        return HasOnlyNoDataT(static_cast<const float*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 64 && eDT == GDT_Float64 )\n    {\n        return HasOnlyNoDataT(static_cast<const double*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    return false;\n}\n\n/************************************************************************/\n/*                     IsFirstPixelEqualToNoData()                      */\n/************************************************************************/\n\ninline bool GTiffDataset::IsFirstPixelEqualToNoData( const void* pBuffer )\n{\n    const GDALDataType eDT = GetRasterBand(1)->GetRasterDataType();\n    const double dfEffectiveNoData = (bNoDataSet) ? dfNoDataValue : 0.0;\n    if( nBitsPerSample == 8 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n        {\n            return GDALIsValueInRange<signed char>(dfEffectiveNoData) &&\n                   *(static_cast<const signed char*>(pBuffer)) ==\n                        static_cast<signed char>(dfEffectiveNoData);\n        }\n        return GDALIsValueInRange<GByte>(dfEffectiveNoData) &&\n               *(static_cast<const GByte*>(pBuffer)) ==\n                        static_cast<GByte>(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 16 && eDT == GDT_UInt16 )\n    {\n        return GDALIsValueInRange<GUInt16>(dfEffectiveNoData) &&\n               *(static_cast<const GUInt16*>(pBuffer)) ==\n                        static_cast<GUInt16>(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 16 && eDT == GDT_Int16 )\n    {\n        return GDALIsValueInRange<GInt16>(dfEffectiveNoData) &&\n               *(static_cast<const GInt16*>(pBuffer)) ==\n                        static_cast<GInt16>(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 32 && eDT == GDT_UInt32 )\n    {\n        return GDALIsValueInRange<GUInt32>(dfEffectiveNoData) &&\n               *(static_cast<const GUInt32*>(pBuffer)) ==\n                        static_cast<GUInt32>(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 32 && eDT == GDT_Int32 )\n    {\n        return GDALIsValueInRange<GInt32>(dfEffectiveNoData) &&\n               *(static_cast<const GInt32*>(pBuffer)) ==\n                        static_cast<GInt32>(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 32 && eDT == GDT_Float32 )\n    {\n        if( CPLIsNan(dfNoDataValue) )\n            return CPL_TO_BOOL(\n                CPLIsNan(*(static_cast<const float*>(pBuffer))));\n        return GDALIsValueInRange<float>(dfEffectiveNoData) &&\n               *(static_cast<const float*>(pBuffer)) ==\n                        static_cast<float>(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 64 && eDT == GDT_Float64 )\n    {\n        if( CPLIsNan(dfEffectiveNoData) )\n            return CPL_TO_BOOL(\n                CPLIsNan(*(static_cast<const double*>(pBuffer))));\n        return *(static_cast<const double*>(pBuffer)) == dfEffectiveNoData;\n    }\n    return false;\n}\n\n/************************************************************************/\n/*                        WriteEncodedTile()                            */\n/************************************************************************/\n\nbool GTiffDataset::WriteEncodedTile( uint32 tile, GByte *pabyData,\n                                     int bPreserveDataBuffer )\n{\n    int iRow = 0;\n    int iColumn = 0;\n    int nBlocksPerRow = 1;\n    int nBlocksPerColumn = 1;\n\n/* -------------------------------------------------------------------- */\n/*      Don't write empty blocks in some cases.                         */\n/* -------------------------------------------------------------------- */\n    if( !bWriteEmptyTiles && IsFirstPixelEqualToNoData(pabyData) )\n    {\n        if( !IsBlockAvailable(tile) )\n        {\n            const int nComponents =\n                nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n            nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n            nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, nBlockYSize);\n\n            iColumn = (tile % nBlocksPerBand) % nBlocksPerRow;\n            iRow = (tile % nBlocksPerBand) / nBlocksPerRow;\n\n            const int nActualBlockWidth =\n                ( iColumn == nBlocksPerRow - 1 ) ?\n                nRasterXSize - iColumn * nBlockXSize : nBlockXSize;\n            const int nActualBlockHeight =\n                ( iRow == nBlocksPerColumn - 1 ) ?\n                nRasterYSize - iRow * nBlockYSize : nBlockYSize;\n\n            if( HasOnlyNoData(pabyData,\n                              nActualBlockWidth, nActualBlockHeight,\n                              nBlockXSize, nComponents ) )\n            {\n                return true;\n            }\n        }\n    }\n\n    // Do we need to spread edge values right or down for a partial\n    // JPEG encoded tile?  We do this to avoid edge artifacts.\n    bool bNeedTileFill = false;\n    if( nCompression == COMPRESSION_JPEG )\n    {\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, nBlockYSize);\n\n        iColumn = (tile % nBlocksPerBand) % nBlocksPerRow;\n        iRow = (tile % nBlocksPerBand) / nBlocksPerRow;\n\n        // Is this a partial right edge tile?\n        if( iRow == nBlocksPerRow - 1\n            && nRasterXSize % nBlockXSize != 0 )\n            bNeedTileFill = true;\n\n        // Is this a partial bottom edge tile?\n        if( iColumn == nBlocksPerColumn - 1\n            && nRasterYSize % nBlockYSize != 0 )\n            bNeedTileFill = true;\n    }\n\n    // If we need to fill out the tile, or if we want to prevent\n    // TIFFWriteEncodedTile from altering the buffer as part of\n    // byte swapping the data on write then we will need a temporary\n    // working buffer.  If not, we can just do a direct write.\n    const int cc = static_cast<int>(TIFFTileSize( hTIFF ));\n\n    if( bPreserveDataBuffer\n        && (TIFFIsByteSwapped(hTIFF) || bNeedTileFill || bHasDiscardedLsb) )\n    {\n        if( cc != nTempWriteBufferSize )\n        {\n            pabyTempWriteBuffer = CPLRealloc(pabyTempWriteBuffer, cc);\n            nTempWriteBufferSize = cc;\n        }\n        memcpy(pabyTempWriteBuffer, pabyData, cc);\n\n        pabyData = static_cast<GByte *>( pabyTempWriteBuffer );\n    }\n\n    // Perform tile fill if needed.\n    // TODO: we should also handle the case of nBitsPerSample == 12\n    // but this is more involved.\n    if( bNeedTileFill && nBitsPerSample == 8 )\n    {\n        const int nComponents =\n            nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n\n        CPLDebug( \"GTiff\", \"Filling out jpeg edge tile on write.\" );\n\n        const int nRightPixelsToFill =\n            iColumn == nBlocksPerRow - 1 ?\n            nBlockXSize * (iColumn + 1) - nRasterXSize :\n            0;\n        const int nBottomPixelsToFill =\n            iRow == nBlocksPerColumn - 1 ?\n            nBlockYSize * (iRow + 1) - nRasterYSize :\n            0;\n\n        // Fill out to the right.\n        const int iSrcX = nBlockXSize - nRightPixelsToFill - 1;\n\n        for( int iX = iSrcX + 1; iX < nBlockXSize; ++iX )\n        {\n            for( int iY = 0; iY < nBlockYSize; ++iY )\n            {\n                memcpy( pabyData + (nBlockXSize * iY + iX) * nComponents,\n                        pabyData + (nBlockXSize * iY + iSrcX) * nComponents,\n                        nComponents );\n            }\n        }\n\n        // Now fill out the bottom.\n        const int iSrcY = nBlockYSize - nBottomPixelsToFill - 1;\n        for( int iY = iSrcY + 1; iY < nBlockYSize; ++iY )\n        {\n            memcpy( pabyData + nBlockXSize * nComponents * iY,\n                    pabyData + nBlockXSize * nComponents * iSrcY,\n                    nBlockXSize * nComponents );\n        }\n    }\n\n    if( bHasDiscardedLsb )\n    {\n        const int iBand =\n            nPlanarConfig == PLANARCONFIG_SEPARATE ?\n            static_cast<int>(tile) / nBlocksPerBand : -1;\n        DiscardLsb(pabyData, cc, iBand);\n    }\n\n    if( bStreamingOut )\n    {\n        if( tile != static_cast<uint32>(nLastWrittenBlockId + 1) )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Attempt to write block %d whereas %d was expected\",\n                     tile, nLastWrittenBlockId + 1);\n            return false;\n        }\n        if( static_cast<int>( VSIFWriteL(pabyData, 1, cc, fpToWrite) ) != cc )\n        {\n            CPLError( CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                      cc );\n            return false;\n        }\n        nLastWrittenBlockId = tile;\n        return true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    if( SubmitCompressionJob(tile, pabyData, cc, nBlockYSize) )\n        return true;\n\n    // libtiff 4.0.6 or older do not always properly report write errors.\n#if !defined(INTERNAL_LIBTIFF) && (!defined(TIFFLIB_VERSION) || (TIFFLIB_VERSION <= 20150912))\n    const CPLErr eBefore = CPLGetLastErrorType();\n#endif\n    const bool bRet =\n        static_cast<int>(TIFFWriteEncodedTile(hTIFF, tile, pabyData, cc)) == cc;\n#if !defined(INTERNAL_LIBTIFF) && (!defined(TIFFLIB_VERSION) || (TIFFLIB_VERSION <= 20150912))\n    if( eBefore == CE_None && CPLGetLastErrorType() == CE_Failure )\n        return false;\n#endif\n    return bRet;\n}\n\n/************************************************************************/\n/*                        WriteEncodedStrip()                           */\n/************************************************************************/\n\nbool GTiffDataset::WriteEncodedStrip( uint32 strip, GByte* pabyData,\n                                      int bPreserveDataBuffer )\n{\n    int cc = static_cast<int>(TIFFStripSize( hTIFF ));\n\n/* -------------------------------------------------------------------- */\n/*      If this is the last strip in the image, and is partial, then    */\n/*      we need to trim the number of scanlines written to the          */\n/*      amount of valid data we have. (#2748)                           */\n/* -------------------------------------------------------------------- */\n    const int nStripWithinBand = strip % nBlocksPerBand;\n    int nStripHeight = nRowsPerStrip;\n\n    if( nStripWithinBand * nStripHeight > GetRasterYSize() - nStripHeight )\n    {\n        nStripHeight = GetRasterYSize() - nStripWithinBand * nRowsPerStrip;\n        cc = (cc / nRowsPerStrip) * nStripHeight;\n        CPLDebug( \"GTiff\", \"Adjusted bytes to write from %d to %d.\",\n                  static_cast<int>(TIFFStripSize(hTIFF)), cc );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Don't write empty blocks in some cases.                         */\n/* -------------------------------------------------------------------- */\n    if( !bWriteEmptyTiles && IsFirstPixelEqualToNoData(pabyData) )\n    {\n        if( !IsBlockAvailable(strip) )\n        {\n            const int nComponents =\n                nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n\n            if( HasOnlyNoData(pabyData,\n                              nBlockXSize, nStripHeight,\n                              nBlockXSize, nComponents ) )\n            {\n                return true;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      TIFFWriteEncodedStrip can alter the passed buffer if            */\n/*      byte-swapping is necessary so we use a temporary buffer         */\n/*      before calling it.                                              */\n/* -------------------------------------------------------------------- */\n    if( bPreserveDataBuffer && (TIFFIsByteSwapped(hTIFF) || bHasDiscardedLsb) )\n    {\n        if( cc != nTempWriteBufferSize )\n        {\n            pabyTempWriteBuffer = CPLRealloc(pabyTempWriteBuffer, cc);\n            nTempWriteBufferSize = cc;\n        }\n        memcpy(pabyTempWriteBuffer, pabyData, cc);\n        pabyData = static_cast<GByte *>( pabyTempWriteBuffer );\n    }\n\n    if( bHasDiscardedLsb )\n    {\n        int iBand =\n            nPlanarConfig == PLANARCONFIG_SEPARATE ?\n            static_cast<int>(strip) / nBlocksPerBand : -1;\n        DiscardLsb(pabyData, cc, iBand);\n    }\n\n    if( bStreamingOut )\n    {\n        if( strip != static_cast<uint32>(nLastWrittenBlockId + 1) )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Attempt to write block %d whereas %d was expected\",\n                     strip, nLastWrittenBlockId + 1);\n            return false;\n        }\n        if( static_cast<int>( VSIFWriteL(pabyData, 1, cc, fpToWrite) ) != cc )\n        {\n            CPLError(CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                     cc);\n            return false;\n        }\n        nLastWrittenBlockId = strip;\n        return true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    if( SubmitCompressionJob(strip, pabyData, cc, nStripHeight) )\n        return true;\n\n    // libtiff 4.0.6 or older do not always properly report write errors.\n#if !defined(INTERNAL_LIBTIFF) && (!defined(TIFFLIB_VERSION) || (TIFFLIB_VERSION <= 20150912))\n    CPLErr eBefore = CPLGetLastErrorType();\n#endif\n    bool bRet =\n        static_cast<int>(TIFFWriteEncodedStrip( hTIFF, strip,\n                                                pabyData, cc)) == cc;\n#if !defined(INTERNAL_LIBTIFF) && (!defined(TIFFLIB_VERSION) || (TIFFLIB_VERSION <= 20150912))\n    if( eBefore == CE_None && CPLGetLastErrorType() == CE_Failure )\n        bRet = FALSE;\n#endif\n    return bRet;\n}\n\n/************************************************************************/\n/*                        InitCompressionThreads()                      */\n/************************************************************************/\n\nvoid GTiffDataset::InitCompressionThreads( char** papszOptions )\n{\n    // Raster == tile, then no need for threads\n    if( nBlockXSize == nRasterXSize && nBlockYSize == nRasterYSize )\n        return;\n\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"NUM_THREADS\" );\n    if( pszValue == nullptr )\n        pszValue = CPLGetConfigOption(\"GDAL_NUM_THREADS\", nullptr);\n    if( pszValue )\n    {\n        const int nThreads =\n            EQUAL(pszValue, \"ALL_CPUS\") ? CPLGetNumCPUs() : atoi(pszValue);\n        if( nThreads > 1 )\n        {\n            if( nCompression == COMPRESSION_NONE ||\n                nCompression == COMPRESSION_JPEG )\n            {\n                CPLDebug( \"GTiff\",\n                          \"NUM_THREADS ignored with uncompressed or JPEG\" );\n            }\n            else\n            {\n                CPLDebug(\"GTiff\", \"Using %d threads for compression\", nThreads);\n\n                // Try to reuse previously created thread pool\n                {\n                    std::lock_guard<std::mutex> oLock(gMutexThreadPool);\n                    if( gpoCompressThreadPool &&\n                        gpoCompressThreadPool->GetThreadCount() == nThreads )\n                    {\n                        poCompressThreadPool = gpoCompressThreadPool;\n                    }\n                    else\n                    {\n                        delete gpoCompressThreadPool;\n                    }\n                    gpoCompressThreadPool = nullptr;\n                }\n\n                if( poCompressThreadPool == nullptr )\n                {\n                    poCompressThreadPool = new CPLWorkerThreadPool();\n                    if( !poCompressThreadPool->Setup(nThreads, nullptr, nullptr) )\n                    {\n                        delete poCompressThreadPool;\n                        poCompressThreadPool = nullptr;\n                    }\n                }\n                if( poCompressThreadPool != nullptr )\n                {\n                    // Add a margin of an extra job w.r.t thread number\n                    // so as to optimize compression time (enables the main\n                    // thread to do boring I/O while all CPUs are working).\n                    asCompressionJobs.resize(nThreads + 1);\n                    memset(&asCompressionJobs[0], 0,\n                           asCompressionJobs.size() *\n                           sizeof(GTiffCompressionJob));\n                    for( int i = 0;\n                         i < static_cast<int>(asCompressionJobs.size());\n                         ++i )\n                    {\n                        asCompressionJobs[i].pszTmpFilename =\n                            CPLStrdup(CPLSPrintf(\"/vsimem/gtiff/thread/job/%p\",\n                                                 &asCompressionJobs[i]));\n                        asCompressionJobs[i].nStripOrTile = -1;\n                    }\n                    hCompressThreadPoolMutex = CPLCreateMutex();\n                    CPLReleaseMutex(hCompressThreadPoolMutex);\n\n                    // This is kind of a hack, but basically using\n                    // TIFFWriteRawStrip/Tile and then TIFFReadEncodedStrip/Tile\n                    // does not work on a newly created file, because\n                    // TIFF_MYBUFFER is not set in tif_flags\n                    // (if using TIFFWriteEncodedStrip/Tile first,\n                    // TIFFWriteBufferSetup() is automatically called).\n                    // This should likely rather fixed in libtiff itself.\n                    TIFFWriteBufferSetup(hTIFF, nullptr, -1);\n                }\n            }\n        }\n        else if( nThreads < 0 ||\n                 (!EQUAL(pszValue, \"0\") &&\n                  !EQUAL(pszValue, \"1\") &&\n                  !EQUAL(pszValue, \"ALL_CPUS\")) )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"Invalid value for NUM_THREADS: %s\", pszValue);\n        }\n    }\n}\n\n/************************************************************************/\n/*                       GetGTIFFKeysFlavor()                           */\n/************************************************************************/\n\nstatic GTIFFKeysFlavorEnum GetGTIFFKeysFlavor( char** papszOptions )\n{\n    const char* pszGeoTIFFKeysFlavor =\n        CSLFetchNameValueDef( papszOptions, \"GEOTIFF_KEYS_FLAVOR\", \"STANDARD\" );\n    if( EQUAL(pszGeoTIFFKeysFlavor, \"ESRI_PE\") )\n        return GEOTIFF_KEYS_ESRI_PE;\n    return GEOTIFF_KEYS_STANDARD;\n}\n\n/************************************************************************/\n/*                      InitCreationOrOpenOptions()                     */\n/************************************************************************/\n\nvoid GTiffDataset::InitCreationOrOpenOptions( char** papszOptions )\n{\n    InitCompressionThreads(papszOptions);\n\n    eGeoTIFFKeysFlavor = GetGTIFFKeysFlavor(papszOptions);\n}\n\n/************************************************************************/\n/*                      ThreadCompressionFunc()                         */\n/************************************************************************/\n\nvoid GTiffDataset::ThreadCompressionFunc( void* pData )\n{\n    GTiffCompressionJob* psJob = static_cast<GTiffCompressionJob *>(pData);\n    GTiffDataset* poDS = psJob->poDS;\n\n    VSILFILE* fpTmp = VSIFOpenL(psJob->pszTmpFilename, \"wb+\");\n    TIFF* hTIFFTmp = VSI_TIFFOpen(psJob->pszTmpFilename,\n        psJob->bTIFFIsBigEndian ? \"wb+\" : \"wl+\", fpTmp);\n    CPLAssert( hTIFFTmp != nullptr );\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGEWIDTH, poDS->nBlockXSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGELENGTH, psJob->nHeight);\n    TIFFSetField(hTIFFTmp, TIFFTAG_BITSPERSAMPLE, poDS->nBitsPerSample);\n    TIFFSetField(hTIFFTmp, TIFFTAG_COMPRESSION, poDS->nCompression);\n    if( psJob->nPredictor != PREDICTOR_NONE )\n        TIFFSetField(hTIFFTmp, TIFFTAG_PREDICTOR, psJob->nPredictor);\n\n    TIFFSetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, poDS->nPhotometric);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLEFORMAT, poDS->nSampleFormat);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLESPERPIXEL, poDS->nSamplesPerPixel);\n    TIFFSetField(hTIFFTmp, TIFFTAG_ROWSPERSTRIP, poDS->nBlockYSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PLANARCONFIG, poDS->nPlanarConfig);\n\n    poDS->RestoreVolatileParameters(hTIFFTmp);\n\n    bool bOK =\n        TIFFWriteEncodedStrip(hTIFFTmp, 0, psJob->pabyBuffer,\n                              psJob->nBufferSize) == psJob->nBufferSize;\n\n    int nOffset = 0;\n    if( bOK )\n    {\n        toff_t* panOffsets = nullptr;\n        toff_t* panByteCounts = nullptr;\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPOFFSETS, &panOffsets);\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts);\n\n        nOffset = static_cast<int>( panOffsets[0]);\n        psJob->nCompressedBufferSize = static_cast<int>( panByteCounts[0] );\n    }\n    else\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Error when compressing strip/tile %d\",\n                  psJob->nStripOrTile);\n    }\n\n    XTIFFClose(hTIFFTmp);\n    if( VSIFCloseL(fpTmp) != 0 )\n    {\n        if( bOK )\n        {\n            bOK = false;\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"Error when compressing strip/tile %d\",\n                      psJob->nStripOrTile);\n        }\n    }\n\n    if( bOK )\n    {\n        vsi_l_offset nFileSize = 0;\n        GByte* pabyCompressedBuffer = VSIGetMemFileBuffer(psJob->pszTmpFilename,\n                                                          &nFileSize,\n                                                          FALSE);\n        CPLAssert( nOffset + psJob->nCompressedBufferSize <=\n                   static_cast<int>(nFileSize) );\n        psJob->pabyCompressedBuffer = pabyCompressedBuffer + nOffset;\n    }\n    else\n    {\n        psJob->pabyCompressedBuffer = nullptr;\n        psJob->nCompressedBufferSize = 0;\n    }\n\n    CPLAcquireMutex(poDS->hCompressThreadPoolMutex, 1000.0);\n    psJob->bReady = true;\n    CPLReleaseMutex(poDS->hCompressThreadPoolMutex);\n}\n\n/************************************************************************/\n/*                        WriteRawStripOrTile()                         */\n/************************************************************************/\n\nvoid GTiffDataset::WriteRawStripOrTile( int nStripOrTile,\n                                        GByte* pabyCompressedBuffer,\n                                        int nCompressedBufferSize )\n{\n#ifdef DEBUG_VERBOSE\n    CPLDebug(\"GTIFF\", \"Writing raw strip/tile %d, size %d\",\n             nStripOrTile, nCompressedBufferSize);\n#endif\n    toff_t *panOffsets = nullptr;\n    if( TIFFGetField(\n            hTIFF,\n            TIFFIsTiled( hTIFF ) ?\n            TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS, &panOffsets ) &&\n            panOffsets[nStripOrTile] != 0 )\n    {\n        // Make sure that if the tile/strip already exists,\n        // we write at end of file.\n        TIFFSetWriteOffset(hTIFF, 0);\n    }\n    if( TIFFIsTiled( hTIFF ) )\n        TIFFWriteRawTile( hTIFF, nStripOrTile, pabyCompressedBuffer,\n                          nCompressedBufferSize );\n    else\n        TIFFWriteRawStrip( hTIFF, nStripOrTile, pabyCompressedBuffer,\n                           nCompressedBufferSize );\n}\n\n/************************************************************************/\n/*                        WaitCompletionForBlock()                      */\n/************************************************************************/\n\nvoid GTiffDataset::WaitCompletionForBlock(int nBlockId)\n{\n    if( poCompressThreadPool != nullptr )\n    {\n        for( int i = 0; i < static_cast<int>(asCompressionJobs.size()); ++i )\n        {\n            if( asCompressionJobs[i].nStripOrTile == nBlockId )\n            {\n                CPLDebug(\"GTIFF\",\n                         \"Waiting for worker job to finish handling block %d\",\n                         nBlockId);\n\n                CPLAcquireMutex(hCompressThreadPoolMutex, 1000.0);\n                const bool bReady = asCompressionJobs[i].bReady;\n                CPLReleaseMutex(hCompressThreadPoolMutex);\n                if( !bReady )\n                {\n                    poCompressThreadPool->WaitCompletion(0);\n                    CPLAssert( asCompressionJobs[i].bReady );\n                }\n\n                if( asCompressionJobs[i].nCompressedBufferSize )\n                {\n                    WriteRawStripOrTile(asCompressionJobs[i].nStripOrTile,\n                                  asCompressionJobs[i].pabyCompressedBuffer,\n                                  asCompressionJobs[i].nCompressedBufferSize);\n                }\n                asCompressionJobs[i].pabyCompressedBuffer = nullptr;\n                asCompressionJobs[i].nBufferSize = 0;\n                asCompressionJobs[i].bReady = false;\n                asCompressionJobs[i].nStripOrTile = -1;\n                return;\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                      SubmitCompressionJob()                          */\n/************************************************************************/\n\nbool GTiffDataset::SubmitCompressionJob( int nStripOrTile, GByte* pabyData,\n                                         int cc, int nHeight )\n{\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    if( !( poCompressThreadPool != nullptr &&\n           (nCompression == COMPRESSION_ADOBE_DEFLATE ||\n            nCompression == COMPRESSION_LZW ||\n            nCompression == COMPRESSION_PACKBITS ||\n            nCompression == COMPRESSION_LZMA ||\n            nCompression == COMPRESSION_ZSTD ||\n            nCompression == COMPRESSION_LERC ||\n            nCompression == COMPRESSION_WEBP) ) )\n        return false;\n\n    int nNextCompressionJobAvail = -1;\n    // Wait that at least one job is finished.\n    poCompressThreadPool->WaitCompletion(\n        static_cast<int>(asCompressionJobs.size() - 1) );\n    for( int i = 0; i < static_cast<int>(asCompressionJobs.size()); ++i )\n    {\n        CPLAcquireMutex(hCompressThreadPoolMutex, 1000.0);\n        const bool bReady = asCompressionJobs[i].bReady;\n        CPLReleaseMutex(hCompressThreadPoolMutex);\n        if( bReady )\n        {\n            if( asCompressionJobs[i].nCompressedBufferSize )\n            {\n                WriteRawStripOrTile( asCompressionJobs[i].nStripOrTile,\n                                asCompressionJobs[i].pabyCompressedBuffer,\n                                asCompressionJobs[i].nCompressedBufferSize );\n            }\n            asCompressionJobs[i].pabyCompressedBuffer = nullptr;\n            asCompressionJobs[i].nBufferSize = 0;\n            asCompressionJobs[i].bReady = false;\n            asCompressionJobs[i].nStripOrTile = -1;\n        }\n        if( asCompressionJobs[i].nBufferSize == 0 )\n        {\n            if( nNextCompressionJobAvail < 0 )\n                nNextCompressionJobAvail = i;\n        }\n    }\n    CPLAssert(nNextCompressionJobAvail >= 0);\n\n    GTiffCompressionJob* psJob = &asCompressionJobs[nNextCompressionJobAvail];\n    psJob->poDS = this;\n    psJob->bTIFFIsBigEndian = CPL_TO_BOOL( TIFFIsBigEndian(hTIFF) );\n    psJob->pabyBuffer =\n        static_cast<GByte*>( CPLRealloc(psJob->pabyBuffer, cc) );\n    memcpy(psJob->pabyBuffer, pabyData, cc);\n    psJob->nBufferSize = cc;\n    psJob->nHeight = nHeight;\n    psJob->nStripOrTile = nStripOrTile;\n    psJob->nPredictor = PREDICTOR_NONE;\n    if( nCompression == COMPRESSION_LZW ||\n        nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        nCompression == COMPRESSION_ZSTD )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_PREDICTOR, &psJob->nPredictor );\n    }\n\n    poCompressThreadPool->SubmitJob(ThreadCompressionFunc, psJob);\n    return true;\n}\n\n/************************************************************************/\n/*                          DiscardLsb()                                */\n/************************************************************************/\n\nvoid GTiffDataset::DiscardLsb( GByte* pabyBuffer, int nBytes, int iBand ) const\n{\n    if( nBitsPerSample == 8 )\n    {\n        if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            const int nMask = anMaskLsb[iBand];\n            const int nOffset = anOffsetLsb[iBand];\n            for( int i = 0; i < nBytes; ++i )\n            {\n                // Keep 255 in case it is alpha.\n                if( pabyBuffer[i] != 255 )\n                    pabyBuffer[i] =\n                        static_cast<GByte>((pabyBuffer[i] & nMask) | nOffset);\n            }\n        }\n        else\n        {\n            for( int i = 0; i < nBytes; i += nBands )\n            {\n                for( int j = 0; j < nBands; ++j )\n                {\n                    // Keep 255 in case it is alpha.\n                    if( pabyBuffer[i + j] != 255 )\n                        pabyBuffer[i + j] =\n                            static_cast<GByte>((pabyBuffer[i + j] &\n                                                anMaskLsb[j]) | anOffsetLsb[j]);\n                }\n            }\n        }\n    }\n    else if( nBitsPerSample == 16 )\n    {\n        if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            const int nMask = anMaskLsb[iBand];\n            const int nOffset = anOffsetLsb[iBand];\n            for( int i = 0; i < nBytes/2; ++i )\n            {\n                reinterpret_cast<GUInt16*>(pabyBuffer)[i] =\n                    static_cast<GUInt16>(\n                        (reinterpret_cast<GUInt16 *>(pabyBuffer)[i] & nMask) |\n                        nOffset);\n            }\n        }\n        else\n        {\n            for( int i = 0; i < nBytes/2; i += nBands )\n            {\n                for( int j = 0; j < nBands; ++j )\n                {\n                    reinterpret_cast<GUInt16*>(pabyBuffer)[i + j] =\n                        static_cast<GUInt16>(\n                            (reinterpret_cast<GUInt16*>(pabyBuffer)[i + j] &\n                             anMaskLsb[j]) |\n                            anOffsetLsb[j]);\n                }\n            }\n        }\n    }\n    else if( nBitsPerSample == 32 )\n    {\n        if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            const int nMask = anMaskLsb[iBand];\n            const int nOffset = anOffsetLsb[iBand];\n            for( int i = 0; i < nBytes/4; ++i )\n            {\n                reinterpret_cast<GUInt32 *>(pabyBuffer)[i] =\n                    (reinterpret_cast<GUInt32*>(pabyBuffer)[i] & nMask) |\n                    nOffset;\n            }\n        }\n        else\n        {\n            for( int i = 0; i < nBytes/4; i += nBands )\n            {\n                for( int j = 0; j < nBands; ++j )\n                {\n                    reinterpret_cast<GUInt32 *>(pabyBuffer)[i + j] =\n                        (reinterpret_cast<GUInt32 *>(pabyBuffer)[i + j] &\n                         anMaskLsb[j]) |\n                        anOffsetLsb[j];\n                }\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                  WriteEncodedTileOrStrip()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::WriteEncodedTileOrStrip( uint32 tile_or_strip, void* data,\n                                              int bPreserveDataBuffer )\n{\n    CPLErr eErr = CE_None;\n\n    if( TIFFIsTiled( hTIFF ) )\n    {\n        if( !(WriteEncodedTile(\n               tile_or_strip,\n               static_cast<GByte *>(data),\n               bPreserveDataBuffer)) )\n        {\n            eErr = CE_Failure;\n        }\n    }\n    else\n    {\n        if( !(WriteEncodedStrip(\n               tile_or_strip,\n               static_cast<GByte *>(data),\n               bPreserveDataBuffer)) )\n        {\n            eErr = CE_Failure;\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                           FlushBlockBuf()                            */\n/************************************************************************/\n\nCPLErr GTiffDataset::FlushBlockBuf()\n\n{\n    if( nLoadedBlock < 0 || !bLoadedBlockDirty )\n        return CE_None;\n\n    bLoadedBlockDirty = false;\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n    const CPLErr eErr =\n        WriteEncodedTileOrStrip(nLoadedBlock, pabyBlockBuf, true);\n    if( eErr != CE_None )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                    \"WriteEncodedTile/Strip() failed.\" );\n        bWriteErrorInFlushBlockBuf = true;\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                            LoadBlockBuf()                            */\n/*                                                                      */\n/*      Load working block buffer with request block (tile/strip).      */\n/************************************************************************/\n\nCPLErr GTiffDataset::LoadBlockBuf( int nBlockId, bool bReadFromDisk )\n\n{\n    if( nLoadedBlock == nBlockId )\n        return CE_None;\n\n/* -------------------------------------------------------------------- */\n/*      If we have a dirty loaded block, flush it out first.            */\n/* -------------------------------------------------------------------- */\n    if( nLoadedBlock != -1 && bLoadedBlockDirty )\n    {\n        const CPLErr eErr = FlushBlockBuf();\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get block size.                                                 */\n/* -------------------------------------------------------------------- */\n    const int nBlockBufSize =\n        static_cast<int>(\n            TIFFIsTiled(hTIFF) ? TIFFTileSize(hTIFF) : TIFFStripSize(hTIFF));\n    if( !nBlockBufSize )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Bogus block size; unable to allocate a buffer.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( pabyBlockBuf == nullptr )\n    {\n        pabyBlockBuf =\n            static_cast<GByte *>( VSI_CALLOC_VERBOSE( 1, nBlockBufSize ) );\n        if( pabyBlockBuf == nullptr )\n        {\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*  When called from ::IWriteBlock in separate cases (or in single band */\n/*  geotiffs), the ::IWriteBlock will override the content of the buffer*/\n/*  with pImage, so we don't need to read data from disk                */\n/* -------------------------------------------------------------------- */\n    if( !bReadFromDisk || bStreamingOut )\n    {\n        nLoadedBlock = nBlockId;\n        return CE_None;\n    }\n\n    // libtiff 3.X doesn't like mixing read&write of JPEG compressed blocks\n    // The below hack is necessary due to another hack that consist in\n    // writing zero block to force creation of JPEG tables.\n    if( nBlockId == 0 && bDontReloadFirstBlock )\n    {\n        bDontReloadFirstBlock = false;\n        memset( pabyBlockBuf, 0, nBlockBufSize );\n        nLoadedBlock = nBlockId;\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      The bottom most partial tiles and strips are sometimes only     */\n/*      partially encoded.  This code reduces the requested data so     */\n/*      an error won't be reported in this case. (#1179)                */\n/* -------------------------------------------------------------------- */\n    int nBlockReqSize = nBlockBufSize;\n    const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    const int nBlockYOff = (nBlockId % nBlocksPerBand) / nBlocksPerRow;\n\n    if( nBlockYOff * nBlockYSize > nRasterYSize - nBlockYSize )\n    {\n        nBlockReqSize = (nBlockBufSize / nBlockYSize)\n            * (nBlockYSize - static_cast<int>(\n                (static_cast<GIntBig>(nBlockYOff + 1) * nBlockYSize) %\n                    nRasterYSize));\n        memset( pabyBlockBuf, 0, nBlockBufSize );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have this block already loaded, and we know it      */\n/*      doesn't yet exist on disk, just zero the memory buffer and      */\n/*      pretend we loaded it.                                           */\n/* -------------------------------------------------------------------- */\n    bool bErrOccurred = false;\n    if( !IsBlockAvailable( nBlockId, nullptr, nullptr, &bErrOccurred ) )\n    {\n        memset( pabyBlockBuf, 0, nBlockBufSize );\n        nLoadedBlock = nBlockId;\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block, if it isn't our current block.                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n    if( TIFFIsTiled( hTIFF ) )\n    {\n        if( TIFFReadEncodedTile(hTIFF, nBlockId, pabyBlockBuf,\n                                nBlockReqSize) == -1\n            && !bIgnoreReadErrors )\n        {\n            // Once TIFFError() is properly hooked, this can go away.\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadEncodedTile() failed.\" );\n\n            memset( pabyBlockBuf, 0, nBlockBufSize );\n\n            eErr = CE_Failure;\n        }\n    }\n    else\n    {\n        if( TIFFReadEncodedStrip(hTIFF, nBlockId, pabyBlockBuf,\n                                 nBlockReqSize) == -1\n            && !bIgnoreReadErrors )\n        {\n            // Once TIFFError() is properly hooked, this can go away.\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadEncodedStrip() failed.\" );\n\n            memset( pabyBlockBuf, 0, nBlockBufSize );\n\n            eErr = CE_Failure;\n        }\n    }\n\n    if( eErr == CE_None )\n    {\n        nLoadedBlock = nBlockId;\n    }\n    else\n    {\n        nLoadedBlock = -1;\n    }\n    bLoadedBlockDirty = false;\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                   GTiffFillStreamableOffsetAndCount()                */\n/************************************************************************/\n\nstatic void GTiffFillStreamableOffsetAndCount( TIFF* hTIFF, int nSize )\n{\n    uint32 nXSize = 0;\n    uint32 nYSize = 0;\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(hTIFF) );\n    const int nBlockCount =\n        bIsTiled ? TIFFNumberOfTiles(hTIFF) : TIFFNumberOfStrips(hTIFF);\n\n    toff_t *panOffset = nullptr;\n    TIFFGetField( hTIFF, bIsTiled ? TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                  &panOffset );\n    toff_t *panSize = nullptr;\n    TIFFGetField( hTIFF,\n                  bIsTiled ? TIFFTAG_TILEBYTECOUNTS : TIFFTAG_STRIPBYTECOUNTS,\n                  &panSize );\n    toff_t nOffset = nSize;\n    // Trick to avoid clang static analyzer raising false positive about\n    // divide by zero later.\n    int nBlocksPerBand = 1;\n    uint32 nRowsPerStrip = 0;\n    if( !bIsTiled )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP, &nRowsPerStrip);\n        if( nRowsPerStrip > static_cast<uint32>(nYSize) )\n            nRowsPerStrip = nYSize;\n        nBlocksPerBand = DIV_ROUND_UP(nYSize, nRowsPerStrip);\n    }\n    for( int i = 0; i < nBlockCount; ++i )\n    {\n        int cc = bIsTiled ? static_cast<int>(TIFFTileSize(hTIFF)) :\n                            static_cast<int>(TIFFStripSize(hTIFF));\n        if( !bIsTiled )\n        {\n/* -------------------------------------------------------------------- */\n/*      If this is the last strip in the image, and is partial, then    */\n/*      we need to trim the number of scanlines written to the          */\n/*      amount of valid data we have. (#2748)                           */\n/* -------------------------------------------------------------------- */\n            int nStripWithinBand = i % nBlocksPerBand;\n            if( nStripWithinBand * nRowsPerStrip > nYSize - nRowsPerStrip )\n            {\n                cc = (cc / nRowsPerStrip)\n                    * (nYSize - nStripWithinBand * nRowsPerStrip);\n            }\n        }\n        panOffset[i] = nOffset;\n        panSize[i] = cc;\n        nOffset += cc;\n    }\n}\n\n/************************************************************************/\n/*                             Crystalize()                             */\n/*                                                                      */\n/*      Make sure that the directory information is written out for     */\n/*      a new file, require before writing any imagery data.            */\n/************************************************************************/\n\nvoid GTiffDataset::Crystalize()\n\n{\n    if( bCrystalized )\n        return;\n\n    // TODO: libtiff writes extended tags in the order they are specified\n    // and not in increasing order.\n    WriteMetadata( this, hTIFF, true, osProfile, osFilename,\n                   papszCreationOptions );\n    WriteGeoTIFFInfo();\n    if( bNoDataSet )\n        WriteNoDataValue( hTIFF, dfNoDataValue );\n\n    bMetadataChanged = false;\n    bGeoTIFFInfoChanged = false;\n    bNoDataChanged = false;\n    bNeedsRewrite = false;\n\n    bCrystalized = true;\n\n    TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTiffDataset::Crystalize\");\n\n    TIFFWriteDirectory( hTIFF );\n    if( bStreamingOut )\n    {\n        // We need to write twice the directory to be sure that custom\n        // TIFF tags are correctly sorted and that padding bytes have been\n        // added.\n        TIFFSetDirectory( hTIFF, 0 );\n        TIFFWriteDirectory( hTIFF );\n\n        if( VSIFSeekL( fpL, 0, SEEK_END ) != 0 )\n        {\n            CPLError(CE_Failure, CPLE_FileIO, \"Could not seek\");\n        }\n        const int nSize = static_cast<int>( VSIFTellL(fpL) );\n\n        TIFFSetDirectory( hTIFF, 0 );\n        GTiffFillStreamableOffsetAndCount( hTIFF, nSize );\n        TIFFWriteDirectory( hTIFF );\n\n        vsi_l_offset nDataLength = 0;\n        void* pabyBuffer =\n            VSIGetMemFileBuffer( osTmpFilename, &nDataLength, FALSE);\n        if( static_cast<int>(\n                VSIFWriteL( pabyBuffer, 1,\n                            static_cast<int>(nDataLength), fpToWrite ) ) !=\n            static_cast<int>(nDataLength) )\n        {\n            CPLError( CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                      static_cast<int>(nDataLength) );\n        }\n        // In case of single strip file, there's a libtiff check that would\n        // issue a warning since the file hasn't the required size.\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        TIFFSetDirectory( hTIFF, 0 );\n        CPLPopErrorHandler();\n    }\n    else\n    {\n        TIFFSetDirectory( hTIFF, 0 );\n    }\n\n    RestoreVolatileParameters( hTIFF );\n\n    nDirOffset = TIFFCurrentDirOffset( hTIFF );\n}\n\n#if defined(INTERNAL_LIBTIFF) && defined(DEFER_STRILE_LOAD)\n\nstatic\nbool GTiffCacheOffsetOrCount( VSILFILE* fp,\n                              bool bSwab,\n                              vsi_l_offset nBaseOffset,\n                              int nBlockId,\n                              uint32 nstrips,\n                              uint64* panVals,\n                              size_t sizeofval )\n{\n    constexpr vsi_l_offset IO_CACHE_PAGE_SIZE = 4096;\n\n    const int sizeofvalint = static_cast<int>(sizeofval);\n    const vsi_l_offset nOffset = nBaseOffset + sizeofval * nBlockId;\n    const vsi_l_offset nOffsetStartPage =\n        (nOffset / IO_CACHE_PAGE_SIZE) * IO_CACHE_PAGE_SIZE;\n    vsi_l_offset nOffsetEndPage = nOffsetStartPage + IO_CACHE_PAGE_SIZE;\n\n    if( nOffset + sizeofval > nOffsetEndPage )\n        nOffsetEndPage += IO_CACHE_PAGE_SIZE;\n    vsi_l_offset nLastStripOffset = nBaseOffset + nstrips * sizeofval;\n    if( nLastStripOffset < nOffsetEndPage )\n        nOffsetEndPage = nLastStripOffset;\n    if( nOffsetStartPage >= nOffsetEndPage )\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"Cannot read offset/size for strile %d\", nBlockId);\n        panVals[nBlockId] = 0;\n        return false;\n    }\n    if( VSIFSeekL(fp, nOffsetStartPage, SEEK_SET) != 0 )\n    {\n        panVals[nBlockId] = 0;\n        return false;\n    }\n\n    const size_t nToRead =\n        static_cast<size_t>(nOffsetEndPage - nOffsetStartPage);\n    GByte buffer[2 * IO_CACHE_PAGE_SIZE] = {};  // TODO(schwehr): Off the stack.\n    const size_t nRead = VSIFReadL(buffer, 1, nToRead, fp);\n    if( nRead < nToRead )\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"Cannot read offset/size for strile around ~%d\", nBlockId);\n        return false;\n    }\n    int iStartBefore =\n        - static_cast<int>((nOffset - nOffsetStartPage) / sizeofval);\n    if( nBlockId + iStartBefore < 0 )\n        iStartBefore = -nBlockId;\n    for( int i = iStartBefore;\n         static_cast<uint32>(nBlockId + i) < nstrips &&\n         static_cast<GIntBig>(nOffset) + (i + 1) * sizeofvalint <=\n         static_cast<GIntBig>(nOffsetEndPage);\n         ++i )\n    {\n        if( sizeofval == 2 )\n        {\n            uint16 val;\n            memcpy(&val,\n                   buffer + (nOffset - nOffsetStartPage) + i * sizeofvalint,\n                   sizeof(val));\n            if( bSwab )\n                CPL_SWAP16PTR(&val);\n            panVals[nBlockId + i] = val;\n        }\n        else if( sizeofval == 4 )\n        {\n            uint32 val;\n            memcpy(&val,\n                   buffer + (nOffset - nOffsetStartPage) + i * sizeofvalint,\n                   sizeof(val));\n            if( bSwab )\n                CPL_SWAP32PTR(&val);\n            panVals[nBlockId + i] = val;\n        }\n        else\n        {\n            uint64 val;\n            memcpy(&val,\n                   buffer + (nOffset - nOffsetStartPage) + i * sizeofvalint,\n                   sizeof(val));\n            if( bSwab )\n                CPL_SWAP64PTR(&val);\n            panVals[nBlockId + i] = val;\n        }\n    }\n    return true;\n}\n\nstatic bool ReadStripArray( VSILFILE* fp,\n                            TIFF* hTIFF,\n                            const TIFFDirEntry* psEntry,\n                            int nBlockId,\n                            uint32 nStripArrayAlloc,\n                            uint64* panOffsetOrCountArray )\n{\n    const bool bSwab = (hTIFF->tif_flags & TIFF_SWAB) != 0;\n    if( (hTIFF->tif_flags&TIFF_BIGTIFF) &&\n        psEntry->tdir_type == TIFF_SHORT &&\n        psEntry->tdir_count <= 4 )\n    {\n        uint16 offset;\n        const GByte* src = reinterpret_cast<const GByte*>(\n                                    &(psEntry->tdir_offset.toff_long8));\n        for( size_t i = 0; i < 4 && i < nStripArrayAlloc; i++ )\n        {\n            memcpy(&offset, src + sizeof(offset) * i, sizeof(offset));\n            if( bSwab )\n                CPL_SWAP16PTR(&offset);\n            panOffsetOrCountArray[i] = offset;\n        }\n        return true;\n    }\n    else if( (hTIFF->tif_flags&TIFF_BIGTIFF) &&\n        psEntry->tdir_type == TIFF_LONG &&\n        psEntry->tdir_count <= 2 )\n    {\n        uint32 offset;\n        const GByte* src = reinterpret_cast<const GByte*>(\n                                    &(psEntry->tdir_offset.toff_long8));\n        for( size_t i = 0; i < 2 && i < nStripArrayAlloc; i++ )\n        {\n            memcpy(&offset, src + sizeof(offset) * i, sizeof(offset));\n            if( bSwab )\n                CPL_SWAP32PTR(&offset);\n            panOffsetOrCountArray[i] = offset;\n        }\n        return true;\n    }\n    else if( (hTIFF->tif_flags&TIFF_BIGTIFF) &&\n        psEntry->tdir_type == TIFF_LONG8 &&\n        psEntry->tdir_count <= 1 )\n    {\n        uint64 offset = psEntry->tdir_offset.toff_long8;\n        if( bSwab )\n            CPL_SWAP64PTR(&offset);\n        panOffsetOrCountArray[0] = offset;\n        return true;\n    }\n    else if( !(hTIFF->tif_flags&TIFF_BIGTIFF) &&\n        psEntry->tdir_type == TIFF_SHORT &&\n        psEntry->tdir_count <= 2 )\n    {\n        uint16 offset;\n        const GByte* src = reinterpret_cast<const GByte*>(\n                                    &(psEntry->tdir_offset.toff_long));\n\n        for( size_t i = 0; i < 2 && i < nStripArrayAlloc; i++ )\n        {\n            memcpy(&offset, src + sizeof(offset) * i, sizeof(offset));\n            if( bSwab )\n                CPL_SWAP16PTR(&offset);\n            panOffsetOrCountArray[i] = offset;\n        }\n        return true;\n    }\n    else if( !(hTIFF->tif_flags&TIFF_BIGTIFF) &&\n        psEntry->tdir_type == TIFF_LONG &&\n        psEntry->tdir_count <= 1 )\n    {\n        uint32 offset = psEntry->tdir_offset.toff_long;\n        if( bSwab )\n            CPL_SWAP32PTR(&offset);\n        panOffsetOrCountArray[0] = offset;\n        return true;\n    }\n    else\n    {\n        vsi_l_offset l_nDirOffset = 0;\n        if( hTIFF->tif_flags&TIFF_BIGTIFF )\n        {\n            uint64 offset = psEntry->tdir_offset.toff_long8;\n            if( bSwab )\n                CPL_SWAP64PTR(&offset);\n            l_nDirOffset = offset;\n        }\n        else\n        {\n            uint32 offset = psEntry->tdir_offset.toff_long;\n            if( bSwab )\n                CPL_SWAP32PTR(&offset);\n            l_nDirOffset = offset;\n        }\n\n        if( psEntry->tdir_type == TIFF_SHORT )\n        {\n            return GTiffCacheOffsetOrCount(fp,\n                                    bSwab,\n                                    l_nDirOffset,\n                                    nBlockId,\n                                    nStripArrayAlloc,\n                                    panOffsetOrCountArray,\n                                    sizeof(uint16));\n        }\n        else if( psEntry->tdir_type == TIFF_LONG )\n        {\n            return GTiffCacheOffsetOrCount(fp,\n                                    bSwab,\n                                    l_nDirOffset,\n                                    nBlockId,\n                                    nStripArrayAlloc,\n                                    panOffsetOrCountArray,\n                                    sizeof(uint32));\n        }\n        else\n        {\n            return GTiffCacheOffsetOrCount(fp,\n                                    bSwab,\n                                    l_nDirOffset,\n                                    nBlockId,\n                                    nStripArrayAlloc,\n                                    panOffsetOrCountArray,\n                                    sizeof(uint64));\n        }\n    }\n}\n\n#endif  // #if defined(INTERNAL_LIBTIFF) && defined(DEFER_STRILE_LOAD)\n\n/************************************************************************/\n/*                          IsBlockAvailable()                          */\n/*                                                                      */\n/*      Return true if the indicated strip/tile is available.  We       */\n/*      establish this by testing if the stripbytecount is zero.  If    */\n/*      zero then the block has never been committed to disk.           */\n/************************************************************************/\n\nbool GTiffDataset::IsBlockAvailable( int nBlockId,\n                                     vsi_l_offset* pnOffset,\n                                     vsi_l_offset* pnSize,\n                                     bool *pbErrOccurred )\n\n{\n    if( pbErrOccurred )\n        *pbErrOccurred = false;\n\n    WaitCompletionForBlock(nBlockId);\n\n#if defined(INTERNAL_LIBTIFF) && defined(DEFER_STRILE_LOAD)\n    // Optimization to avoid fetching the whole Strip/TileCounts and\n    // Strip/TileOffsets arrays.\n\n    // Note: if strip choping is in effect, _TIFFFillStrilesInternal()\n    // will have 0-memset td_stripoffset_entry/td_stripbytecount_entry, so\n    // we won't enter the below block\n\n    if( eAccess == GA_ReadOnly &&\n        hTIFF->tif_dir.td_stripoffset_entry.tdir_tag != 0 &&\n        hTIFF->tif_dir.td_stripbytecount_entry.tdir_tag != 0 &&\n        !bStreamingIn )\n    {\n        if( !((hTIFF->tif_dir.td_stripoffset_entry.tdir_type == TIFF_SHORT ||\n               hTIFF->tif_dir.td_stripoffset_entry.tdir_type == TIFF_LONG ||\n               hTIFF->tif_dir.td_stripoffset_entry.tdir_type == TIFF_LONG8) &&\n              (hTIFF->tif_dir.td_stripbytecount_entry.tdir_type == TIFF_SHORT ||\n               hTIFF->tif_dir.td_stripbytecount_entry.tdir_type == TIFF_LONG ||\n               hTIFF->tif_dir.td_stripbytecount_entry.tdir_type == TIFF_LONG8)) )\n        {\n            if( nStripArrayAlloc == 0 )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"Unhandled type for StripOffset/StripByteCount\");\n                nStripArrayAlloc = ~nStripArrayAlloc;\n            }\n            if( pnOffset )\n                *pnOffset = 0;\n            if( pnSize )\n                *pnSize = 0;\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        // The size of tags can be actually lesser than the number of strips\n        // (libtiff accepts such files)\n        if( static_cast<uint32>(nBlockId) >=\n                hTIFF->tif_dir.td_stripoffset_entry.tdir_count ||\n            static_cast<uint32>(nBlockId) >=\n                hTIFF->tif_dir.td_stripbytecount_entry.tdir_count )\n        {\n            // In case the tags aren't large enough.\n            if( pnOffset )\n                *pnOffset = 0;\n            if( pnSize )\n                *pnSize = 0;\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        if( hTIFF->tif_dir.td_stripoffset == nullptr )\n        {\n            nStripArrayAlloc = 0;\n        }\n        if( static_cast<uint32>(nBlockId) >= nStripArrayAlloc )\n        {\n            if( nBlockId > 1000000 )\n            {\n                // Avoid excessive memory allocation attempt\n                if( m_nFileSize == 0 )\n                {\n                    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n                    const vsi_l_offset nCurOffset = VSIFTellL(fp);\n                    CPL_IGNORE_RET_VAL( VSIFSeekL(fp, 0, SEEK_END) );\n                    m_nFileSize = VSIFTellL(fp);\n                    CPL_IGNORE_RET_VAL( VSIFSeekL(fp, nCurOffset, SEEK_SET) );\n                }\n                // For such a big blockid we need at least a TIFF_LONG\n                if( static_cast<vsi_l_offset>(nBlockId) >\n                                        m_nFileSize / (2 * sizeof(GUInt32)) )\n                {\n                    CPLError(CE_Failure, CPLE_AppDefined, \"File too short\");\n                    if( pnOffset )\n                        *pnOffset = 0;\n                    if( pnSize )\n                        *pnSize = 0;\n                    if( pbErrOccurred )\n                        *pbErrOccurred = true;\n                    return false;\n                }\n            }\n\n            uint32 nStripArrayAllocBefore = nStripArrayAlloc;\n            uint32 nStripArrayAllocNew;\n            if( nStripArrayAlloc == 0 &&\n                hTIFF->tif_dir.td_nstrips < 1024 * 1024 )\n            {\n                nStripArrayAllocNew = hTIFF->tif_dir.td_nstrips;\n            }\n            else\n            {\n                nStripArrayAllocNew = std::max(\n                    static_cast<uint32>(nBlockId) + 1, 1024U * 512U );\n                if( nStripArrayAllocNew < UINT_MAX / 2  )\n                    nStripArrayAllocNew *= 2;\n                nStripArrayAllocNew = std::min(\n                    nStripArrayAllocNew, hTIFF->tif_dir.td_nstrips);\n            }\n            CPLAssert( static_cast<uint32>(nBlockId) < nStripArrayAllocNew );\n            const uint64 nArraySize64 =\n                static_cast<uint64>(sizeof(uint64)) * nStripArrayAllocNew;\n            const size_t nArraySize = static_cast<size_t>(nArraySize64);\n#if SIZEOF_VOIDP == 4\n            if( nArraySize != nArraySize64 )\n            {\n                CPLError(CE_Failure, CPLE_OutOfMemory,\n                         \"Cannot allocate strip offset and bytecount arrays\");\n                if( pbErrOccurred )\n                    *pbErrOccurred = true;\n                return false;\n            }\n#endif\n            uint64* offsetArray = static_cast<uint64 *>(\n                _TIFFrealloc( hTIFF->tif_dir.td_stripoffset, nArraySize ) );\n            uint64* bytecountArray = static_cast<uint64 *>(\n                _TIFFrealloc( hTIFF->tif_dir.td_stripbytecount, nArraySize ) );\n            if( offsetArray )\n                hTIFF->tif_dir.td_stripoffset = offsetArray;\n            if( bytecountArray )\n                hTIFF->tif_dir.td_stripbytecount = bytecountArray;\n            if( offsetArray && bytecountArray )\n            {\n                nStripArrayAlloc = nStripArrayAllocNew;\n                memset(hTIFF->tif_dir.td_stripoffset + nStripArrayAllocBefore,\n                    0xFF,\n                    (nStripArrayAlloc - nStripArrayAllocBefore) * sizeof(uint64) );\n                memset(hTIFF->tif_dir.td_stripbytecount + nStripArrayAllocBefore,\n                    0xFF,\n                    (nStripArrayAlloc - nStripArrayAllocBefore) * sizeof(uint64) );\n            }\n            else\n            {\n                CPLError(CE_Failure, CPLE_OutOfMemory,\n                         \"Cannot allocate strip offset and bytecount arrays\");\n                _TIFFfree(hTIFF->tif_dir.td_stripoffset);\n                hTIFF->tif_dir.td_stripoffset = nullptr;\n                _TIFFfree(hTIFF->tif_dir.td_stripbytecount);\n                hTIFF->tif_dir.td_stripbytecount = nullptr;\n                nStripArrayAlloc = 0;\n            }\n        }\n        if( hTIFF->tif_dir.td_stripbytecount == nullptr )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n        if( ~(hTIFF->tif_dir.td_stripoffset[nBlockId]) == 0 ||\n            ~(hTIFF->tif_dir.td_stripbytecount[nBlockId]) == 0 )\n        {\n            VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n            const vsi_l_offset nCurOffset = VSIFTellL(fp);\n            if( ~(hTIFF->tif_dir.td_stripoffset[nBlockId]) == 0 )\n            {\n                if( !ReadStripArray( fp,\n                                hTIFF,\n                                &hTIFF->tif_dir.td_stripoffset_entry,\n                                nBlockId,\n                                nStripArrayAlloc,\n                                hTIFF->tif_dir.td_stripoffset ) )\n                {\n                    if( pbErrOccurred )\n                        *pbErrOccurred = true;\n                    return false;\n                }\n            }\n\n            if( ~(hTIFF->tif_dir.td_stripbytecount[nBlockId]) == 0 )\n            {\n                if( !ReadStripArray( fp,\n                                hTIFF,\n                                &hTIFF->tif_dir.td_stripbytecount_entry,\n                                nBlockId,\n                                nStripArrayAlloc,\n                                hTIFF->tif_dir.td_stripbytecount ) )\n                {\n                    if( pbErrOccurred )\n                        *pbErrOccurred = true;\n                    return false;\n                }\n            }\n            if( VSIFSeekL(fp, nCurOffset, SEEK_SET) != 0 )\n            {\n                // For some reason Coverity reports:\n                // Value of non-local \"this->hTIFF->tif_dir.td_stripoffset\"\n                // that was verified to be \"NULL\" is not restored as it was\n                // along other paths.\n                // coverity[end_of_path]\n                if( pbErrOccurred )\n                    *pbErrOccurred = true;\n                return false;\n            }\n        }\n        if( pnOffset )\n            *pnOffset = hTIFF->tif_dir.td_stripoffset[nBlockId];\n        if( pnSize )\n            *pnSize = hTIFF->tif_dir.td_stripbytecount[nBlockId];\n        return hTIFF->tif_dir.td_stripbytecount[nBlockId] != 0;\n    }\n#endif  // defined(INTERNAL_LIBTIFF) && defined(DEFER_STRILE_LOAD)\n    toff_t *panByteCounts = nullptr;\n    toff_t *panOffsets = nullptr;\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(hTIFF) );\n\n    if( ( bIsTiled\n          && TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts )\n          && (pnOffset == nullptr ||\n              TIFFGetField( hTIFF, TIFFTAG_TILEOFFSETS, &panOffsets )) )\n        || ( !bIsTiled\n          && TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts )\n          && (pnOffset == nullptr ||\n              TIFFGetField( hTIFF, TIFFTAG_STRIPOFFSETS, &panOffsets )) ) )\n    {\n        if( panByteCounts == nullptr || (pnOffset != nullptr && panOffsets == nullptr) )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n        const int nBlockCount =\n            bIsTiled ? TIFFNumberOfTiles(hTIFF) : TIFFNumberOfStrips(hTIFF);\n        if( nBlockId >= nBlockCount )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        if( pnOffset )\n            *pnOffset = panOffsets[nBlockId];\n        if( pnSize )\n            *pnSize = panByteCounts[nBlockId];\n        return panByteCounts[nBlockId] != 0;\n    }\n    else\n    {\n        if( pbErrOccurred )\n            *pbErrOccurred = true;\n    }\n\n    return false;\n}\n\n/************************************************************************/\n/*                             FlushCache()                             */\n/*                                                                      */\n/*      We override this so we can also flush out local tiff strip      */\n/*      cache if need be.                                               */\n/************************************************************************/\n\nvoid GTiffDataset::FlushCache()\n\n{\n    FlushCacheInternal( true );\n}\n\nvoid GTiffDataset::FlushCacheInternal( bool bFlushDirectory )\n{\n    if( bIsFinalized || ppoActiveDSRef == nullptr )\n        return;\n\n    GDALPamDataset::FlushCache();\n\n    if( bLoadedBlockDirty && nLoadedBlock != -1 )\n        FlushBlockBuf();\n\n    CPLFree( pabyBlockBuf );\n    pabyBlockBuf = nullptr;\n    nLoadedBlock = -1;\n    bLoadedBlockDirty = false;\n\n    // Finish compression\n    if( poCompressThreadPool )\n    {\n        poCompressThreadPool->WaitCompletion();\n\n        // Flush remaining data\n        for( int i = 0; i < static_cast<int>(asCompressionJobs.size()); ++i )\n        {\n            if( asCompressionJobs[i].bReady )\n            {\n                if( asCompressionJobs[i].nCompressedBufferSize )\n                {\n                    WriteRawStripOrTile( asCompressionJobs[i].nStripOrTile,\n                                   asCompressionJobs[i].pabyCompressedBuffer,\n                                   asCompressionJobs[i].nCompressedBufferSize );\n                }\n                asCompressionJobs[i].pabyCompressedBuffer = nullptr;\n                asCompressionJobs[i].nBufferSize = 0;\n                asCompressionJobs[i].bReady = false;\n                asCompressionJobs[i].nStripOrTile = -1;\n            }\n        }\n    }\n\n    if( bFlushDirectory && GetAccess() == GA_Update )\n    {\n        if( !SetDirectory() )\n            return;\n        FlushDirectory();\n    }\n}\n\n/************************************************************************/\n/*                           FlushDirectory()                           */\n/************************************************************************/\n\nvoid GTiffDataset::FlushDirectory()\n\n{\n    if( GetAccess() == GA_Update )\n    {\n        if( bMetadataChanged )\n        {\n            if( !SetDirectory() )\n                return;\n            bNeedsRewrite =\n                    WriteMetadata( this, hTIFF, true, osProfile, osFilename,\n                                   papszCreationOptions );\n            bMetadataChanged = false;\n\n            if( m_bForceUnsetRPC )\n            {\n#ifdef HAVE_UNSETFIELD\n                double *padfRPCTag = nullptr;\n                uint16 nCount;\n                if( TIFFGetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, &nCount, &padfRPCTag ) )\n                {\n                    std::vector<double> zeroes(92);\n                    TIFFSetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, 92, zeroes.data() );\n                    TIFFUnsetField( hTIFF, TIFFTAG_RPCCOEFFICIENT );\n                    bNeedsRewrite = true;\n                }\n#endif\n                GDALWriteRPCTXTFile( osFilename, nullptr );\n                GDALWriteRPBFile( osFilename, nullptr );\n            }\n        }\n\n        if( bGeoTIFFInfoChanged )\n        {\n            if( !SetDirectory() )\n                return;\n            WriteGeoTIFFInfo();\n        }\n\n        if( bNoDataChanged )\n        {\n            if( !SetDirectory() )\n                return;\n            if( bNoDataSet )\n            {\n                WriteNoDataValue( hTIFF, dfNoDataValue );\n            }\n            else\n            {\n                UnsetNoDataValue( hTIFF );\n            }\n            bNeedsRewrite = true;\n            bNoDataChanged = false;\n        }\n\n        if( bNeedsRewrite )\n        {\n#if defined(TIFFLIB_VERSION)\n#if defined(HAVE_TIFFGETSIZEPROC)\n            if( !SetDirectory() )\n                return;\n\n            const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( hTIFF );\n\n            nDirOffset = pfnSizeProc( TIFFClientdata( hTIFF ) );\n            if( (nDirOffset % 2) == 1 )\n                ++nDirOffset;\n\n            TIFFRewriteDirectory( hTIFF );\n\n            TIFFSetSubDirectory( hTIFF, nDirOffset );\n#elif TIFFLIB_VERSION > 20010925 && TIFFLIB_VERSION != 20011807\n            if( !SetDirectory() )\n                return;\n\n            TIFFRewriteDirectory( hTIFF );\n#endif\n#endif\n            bNeedsRewrite = false;\n        }\n    }\n\n    // There are some circumstances in which we can reach this point\n    // without having made this our directory (SetDirectory()) in which\n    // case we should not risk a flush.\n    if( GetAccess() == GA_Update && TIFFCurrentDirOffset(hTIFF) == nDirOffset )\n    {\n#if defined(BIGTIFF_SUPPORT)\n        const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            ++nNewDirOffset;\n\n        TIFFFlush( hTIFF );\n\n        if( nDirOffset != TIFFCurrentDirOffset( hTIFF ) )\n        {\n            nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\",\n                      \"directory moved during flush in FlushDirectory()\" );\n        }\n#else\n        // For libtiff 3.X, the above causes regressions and crashes in\n        // tiff_write.py and tiff_ovr.py.\n        TIFFFlush( hTIFF );\n#endif\n    }\n}\n\n/************************************************************************/\n/*                           CleanOverviews()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::CleanOverviews()\n\n{\n    CPLAssert( bBase );\n\n    ScanDirectories();\n\n    FlushDirectory();\n    *ppoActiveDSRef = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews objects, and get offsets to all overview      */\n/*      directories.                                                    */\n/* -------------------------------------------------------------------- */\n    std::vector<toff_t> anOvDirOffsets;\n\n    for( int i = 0; i < nOverviewCount; ++i )\n    {\n        anOvDirOffsets.push_back( papoOverviewDS[i]->nDirOffset );\n        delete papoOverviewDS[i];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Loop through all the directories, translating the offsets       */\n/*      into indexes we can use with TIFFUnlinkDirectory().             */\n/* -------------------------------------------------------------------- */\n    std::vector<uint16> anOvDirIndexes;\n    int iThisOffset = 1;\n\n    TIFFSetDirectory( hTIFF, 0 );\n\n    while( true )\n    {\n        for( int i = 0; i < nOverviewCount; ++i )\n        {\n            if( anOvDirOffsets[i] == TIFFCurrentDirOffset( hTIFF ) )\n            {\n                CPLDebug( \"GTiff\", \"%d -> %d\",\n                          static_cast<int>(anOvDirOffsets[i]), iThisOffset );\n                anOvDirIndexes.push_back( static_cast<uint16>(iThisOffset) );\n            }\n        }\n\n        if( TIFFLastDirectory( hTIFF ) )\n            break;\n\n        TIFFReadDirectory( hTIFF );\n        ++iThisOffset;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Actually unlink the target directories.  Note that we do        */\n/*      this from last to first so as to avoid renumbering any of       */\n/*      the earlier directories we need to remove.                      */\n/* -------------------------------------------------------------------- */\n    while( !anOvDirIndexes.empty() )\n    {\n        TIFFUnlinkDirectory( hTIFF, anOvDirIndexes.back() );\n        anOvDirIndexes.pop_back();\n    }\n\n    CPLFree( papoOverviewDS );\n\n    nOverviewCount = 0;\n    papoOverviewDS = nullptr;\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                   RegisterNewOverviewDataset()                       */\n/************************************************************************/\n\nCPLErr GTiffDataset::RegisterNewOverviewDataset(toff_t nOverviewOffset,\n                                                int l_nJpegQuality)\n{\n    GTiffDataset* poODS = new GTiffDataset();\n    poODS->osFilename = osFilename;\n    poODS->nJpegQuality = l_nJpegQuality;\n    poODS->nZLevel = nZLevel;\n    poODS->nLZMAPreset = nLZMAPreset;\n    poODS->nZSTDLevel = nZSTDLevel;\n    poODS->nWebPLevel = nWebPLevel;\n    poODS->bWebPLossless = bWebPLossless;\n    poODS->nJpegTablesMode = nJpegTablesMode;\n#if HAVE_LERC\n    poODS->dfMaxZError = dfMaxZError;\n    memcpy(poODS->anLercAddCompressionAndVersion, anLercAddCompressionAndVersion,\n           sizeof(anLercAddCompressionAndVersion));\n#endif\n\n    if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, nOverviewOffset, false,\n                            GA_Update ) != CE_None )\n    {\n        delete poODS;\n        return CE_Failure;\n    }\n\n    ++nOverviewCount;\n    papoOverviewDS = static_cast<GTiffDataset **>(\n        CPLRealloc( papoOverviewDS,\n                    nOverviewCount * (sizeof(void*))) );\n    papoOverviewDS[nOverviewCount-1] = poODS;\n    poODS->poBaseDS = this;\n    poODS->bIsOverview_ = true;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                     CreateTIFFColorTable()                           */\n/************************************************************************/\n\nstatic void CreateTIFFColorTable(GDALColorTable* poColorTable,\n                                 int nBits,\n                                 std::vector<unsigned short>& anTRed,\n                                 std::vector<unsigned short>& anTGreen,\n                                 std::vector<unsigned short>& anTBlue,\n                                 unsigned short*& panRed,\n                                 unsigned short*& panGreen,\n                                 unsigned short*& panBlue)\n{\n    int nColors;\n\n    if( nBits == 8 )\n        nColors = 256;\n    else if( nBits < 8 )\n        nColors = 1 << nBits;\n    else\n        nColors = 65536;\n\n    anTRed.resize(nColors,0);\n    anTGreen.resize(nColors,0);\n    anTBlue.resize(nColors,0);\n\n    for( int iColor = 0; iColor < nColors; ++iColor )\n    {\n        if( iColor < poColorTable->GetColorEntryCount() )\n        {\n            GDALColorEntry sRGB;\n\n            poColorTable->GetColorEntryAsRGB( iColor, &sRGB );\n\n            anTRed[iColor] = static_cast<unsigned short>(257 * sRGB.c1);\n            anTGreen[iColor] = static_cast<unsigned short>(257 * sRGB.c2);\n            anTBlue[iColor] = static_cast<unsigned short>(257 * sRGB.c3);\n        }\n        else\n        {\n            anTRed[iColor] = 0;\n            anTGreen[iColor] = 0;\n            anTBlue[iColor] = 0;\n        }\n    }\n\n    panRed = &(anTRed[0]);\n    panGreen = &(anTGreen[0]);\n    panBlue = &(anTBlue[0]);\n}\n\n/************************************************************************/\n/*                  CreateOverviewsFromSrcOverviews()                   */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateOverviewsFromSrcOverviews(GDALDataset* poSrcDS)\n{\n    CPLAssert(poSrcDS->GetRasterCount() != 0);\n    CPLAssert(nOverviewCount == 0);\n\n    ScanDirectories();\n\n/* -------------------------------------------------------------------- */\n/*      Move to the directory for this dataset.                         */\n/* -------------------------------------------------------------------- */\n    if( !SetDirectory() )\n        return CE_Failure;\n    FlushDirectory();\n\n    int nOvBitsPerSample = nBitsPerSample;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed;\n    std::vector<unsigned short> anTGreen;\n    std::vector<unsigned short> anTBlue;\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( nPhotometric == PHOTOMETRIC_PALETTE && poColorTable != nullptr )\n    {\n        CreateTIFFColorTable(poColorTable, nOvBitsPerSample,\n                             anTRed, anTGreen, anTBlue,\n                             panRed, panGreen, panBlue);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( \"NONE\", this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = nullptr;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples,\n                      &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew =\n            static_cast<uint16*>(\n                CPLMalloc(nExtraSamples * sizeof(uint16)) );\n        memcpy( panExtraSampleValuesNew, panExtraSampleValues,\n                nExtraSamples * sizeof(uint16));\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = nullptr;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if( nCompression == COMPRESSION_LZW ||\n        nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        nCompression == COMPRESSION_ZSTD )\n        TIFFGetField( hTIFF, TIFFTAG_PREDICTOR, &nPredictor );\n    int nOvrBlockXSize = 0;\n    int nOvrBlockYSize = 0;\n    GTIFFGetOverviewBlockSize(&nOvrBlockXSize, &nOvrBlockYSize);\n\n    int nSrcOverviews = poSrcDS->GetRasterBand(1)->GetOverviewCount();\n    CPLErr eErr = CE_None;\n\n    for( int i = 0; i < nSrcOverviews && eErr == CE_None; ++i )\n    {\n        GDALRasterBand* poOvrBand = poSrcDS->GetRasterBand(1)->GetOverview(i);\n\n        int nOXSize = poOvrBand->GetXSize();\n        int nOYSize = poOvrBand->GetYSize();\n\n        int nOvrJpegQuality = nJpegQuality;\n        if( nCompression == COMPRESSION_JPEG &&\n            CPLGetConfigOption( \"JPEG_QUALITY_OVERVIEW\", nullptr ) != nullptr )\n        {\n            nOvrJpegQuality =\n                atoi(CPLGetConfigOption(\"JPEG_QUALITY_OVERVIEW\",\"75\"));\n        }\n\n        CPLString osNoData; // don't move this in inner scope\n        const char* pszNoData = nullptr;\n        if( bNoDataSet )\n        {\n            osNoData = GTiffFormatGDALNoDataTagValue(dfNoDataValue);\n            pszNoData = osNoData.c_str();\n        }\n\n        toff_t nOverviewOffset =\n                GTIFFWriteDirectory(hTIFF, FILETYPE_REDUCEDIMAGE,\n                                    nOXSize, nOYSize,\n                                    nOvBitsPerSample, nPlanarConfig,\n                                    nSamplesPerPixel,\n                                    nOvrBlockXSize,\n                                    nOvrBlockYSize,\n                                    TRUE,\n                                    nCompression, nPhotometric, nSampleFormat,\n                                    nPredictor,\n                                    panRed, panGreen, panBlue,\n                                    nExtraSamples, panExtraSampleValues,\n                                    osMetadata,\n                                    nOvrJpegQuality >= 0 ?\n                                        CPLSPrintf(\"%d\", nOvrJpegQuality) : nullptr,\n                                    CPLSPrintf(\"%d\", nJpegTablesMode),\n                                    pszNoData,\n#ifdef HAVE_LERC\n                                    anLercAddCompressionAndVersion\n#else\n                                    nullptr\n#endif\n                                   );\n\n        if( nOverviewOffset == 0 )\n            eErr = CE_Failure;\n        else\n            eErr = RegisterNewOverviewDataset(nOverviewOffset, nOvrJpegQuality);\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    if( eErr == CE_None )\n        eErr = CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       CreateInternalMaskOverviews()                  */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateInternalMaskOverviews(int nOvrBlockXSize,\n                                                 int nOvrBlockYSize)\n{\n    ScanDirectories();\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    const char* pszInternalMask =\n        CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", nullptr);\n    if( poMaskDS != nullptr &&\n        poMaskDS->GetRasterCount() == 1 &&\n        (pszInternalMask == nullptr || CPLTestBool(pszInternalMask)) )\n    {\n        int nMaskOvrCompression;\n        if( strstr(GDALGetMetadataItem(GDALGetDriverByName( \"GTiff\" ),\n                                       GDAL_DMD_CREATIONOPTIONLIST, nullptr ),\n                   \"<Value>DEFLATE</Value>\") != nullptr )\n            nMaskOvrCompression = COMPRESSION_ADOBE_DEFLATE;\n        else\n            nMaskOvrCompression = COMPRESSION_PACKBITS;\n\n        for( int i = 0; i < nOverviewCount; ++i )\n        {\n            if( papoOverviewDS[i]->poMaskDS == nullptr )\n            {\n                const toff_t nOverviewOffset =\n                    GTIFFWriteDirectory(\n                        hTIFF, FILETYPE_REDUCEDIMAGE | FILETYPE_MASK,\n                        papoOverviewDS[i]->nRasterXSize,\n                        papoOverviewDS[i]->nRasterYSize,\n                        1, PLANARCONFIG_CONTIG,\n                        1, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                        nMaskOvrCompression, PHOTOMETRIC_MASK,\n                        SAMPLEFORMAT_UINT, PREDICTOR_NONE,\n                        nullptr, nullptr, nullptr, 0, nullptr,\n                        \"\",\n                        nullptr, nullptr, nullptr, nullptr );\n\n                if( nOverviewOffset == 0 )\n                {\n                    eErr = CE_Failure;\n                    continue;\n                }\n\n                GTiffDataset *poODS = new GTiffDataset();\n                poODS->osFilename = osFilename;\n                if( poODS->OpenOffset( hTIFF, ppoActiveDSRef,\n                                       nOverviewOffset, false,\n                                       GA_Update ) != CE_None )\n                {\n                    delete poODS;\n                    eErr = CE_Failure;\n                }\n                else\n                {\n                    poODS->bPromoteTo8Bits =\n                        CPLTestBool(\n                            CPLGetConfigOption(\n                                \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\" ) );\n                    poODS->poBaseDS = this;\n                    papoOverviewDS[i]->poMaskDS = poODS;\n                    ++poMaskDS->nOverviewCount;\n                    poMaskDS->papoOverviewDS = static_cast<GTiffDataset **>(\n                        CPLRealloc(\n                            poMaskDS->papoOverviewDS,\n                            poMaskDS->nOverviewCount * (sizeof(void*))) );\n                    poMaskDS->papoOverviewDS[poMaskDS->nOverviewCount-1] =\n                        poODS;\n                }\n            }\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                          IBuildOverviews()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::IBuildOverviews(\n    const char * pszResampling,\n    int nOverviews, int * panOverviewList,\n    int nBandsIn, int * panBandList,\n    GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    ScanDirectories();\n\n    // Make implicit JPEG overviews invisible, but do not destroy\n    // them in case they are already used (not sure that the client\n    // has the right to do that.  Behaviour maybe undefined in GDAL API.\n    nJPEGOverviewCount = 0;\n\n/* -------------------------------------------------------------------- */\n/*      If RRD or external OVR overviews requested, then invoke         */\n/*      generic handling.                                               */\n/* -------------------------------------------------------------------- */\n    bool bUseGenericHandling = false;\n\n    if( CPLTestBool(CPLGetConfigOption( \"USE_RRD\", \"NO\" ))\n        || CPLTestBool(CPLGetConfigOption( \"TIFF_USE_OVR\", \"NO\" )) )\n    {\n        bUseGenericHandling = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have read access, then create the overviews         */\n/*      externally.                                                     */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() != GA_Update )\n    {\n        CPLDebug( \"GTiff\",\n                  \"File open for read-only accessing, \"\n                  \"creating overviews externally.\" );\n\n        bUseGenericHandling = true;\n    }\n\n    if( bUseGenericHandling )\n    {\n        if( nOverviewCount != 0 )\n        {\n            CPLError(\n                CE_Failure, CPLE_NotSupported,\n                \"Cannot add external overviews when there are already \"\n                \"internal overviews\" );\n            return CE_Failure;\n        }\n\n        return GDALDataset::IBuildOverviews(\n            pszResampling, nOverviews, panOverviewList,\n            nBandsIn, panBandList, pfnProgress, pProgressData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Our TIFF overview support currently only works safely if all    */\n/*      bands are handled at the same time.                             */\n/* -------------------------------------------------------------------- */\n    if( nBandsIn != GetRasterCount() )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Generation of overviews in TIFF currently only \"\n                  \"supported when operating on all bands.  \"\n                  \"Operation failed.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If zero overviews were requested, we need to clear all          */\n/*      existing overviews.                                             */\n/* -------------------------------------------------------------------- */\n    if( nOverviews == 0 )\n    {\n        if( nOverviewCount == 0 )\n            return GDALDataset::IBuildOverviews(\n                pszResampling, nOverviews, panOverviewList,\n                nBandsIn, panBandList, pfnProgress, pProgressData );\n\n        return CleanOverviews();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      libtiff 3.X has issues when generating interleaved overviews.   */\n/*      so generate them one after another one.                         */\n/* -------------------------------------------------------------------- */\n\n    CPLErr eErr = CE_None;\n\n#ifndef BIGTIFF_SUPPORT\n    if( nOverviews > 1 )\n    {\n        double* padfOvrRasterFactor =\n            static_cast<double*>( CPLMalloc(sizeof(double) * nOverviews) );\n        double dfTotal = 0;\n        for( int i = 0; i < nOverviews; ++i )\n        {\n            if( panOverviewList[i] <= 0 )\n            {\n                CPLError(CE_Failure, CPLE_AppDefined,\n                         \"Invalid overview factor : %d\", panOverviewList[i]);\n                eErr = CE_Failure;\n                break;\n            }\n            padfOvrRasterFactor[i] =\n                1.0 / (panOverviewList[i] * panOverviewList[i]);\n            dfTotal += padfOvrRasterFactor[i];\n        }\n\n        double dfAcc = 0.0;\n        for( int i = 0; i < nOverviews && eErr == CE_None; ++i )\n        {\n            void *pScaledProgressData =\n                GDALCreateScaledProgress(\n                    dfAcc / dfTotal,\n                    (dfAcc + padfOvrRasterFactor[i]) / dfTotal,\n                    pfnProgress, pProgressData );\n            dfAcc += padfOvrRasterFactor[i];\n\n            eErr = IBuildOverviews(\n                pszResampling, 1, &panOverviewList[i],\n                nBandsIn, panBandList, GDALScaledProgress,\n                pScaledProgressData );\n\n            GDALDestroyScaledProgress(pScaledProgressData);\n        }\n\n        CPLFree(padfOvrRasterFactor);\n\n        return eErr;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Initialize progress counter.                                    */\n/* -------------------------------------------------------------------- */\n    if( !pfnProgress( 0.0, nullptr, pProgressData ) )\n    {\n        CPLError( CE_Failure, CPLE_UserInterrupt, \"User terminated\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Move to the directory for this dataset.                         */\n/* -------------------------------------------------------------------- */\n    if( !SetDirectory() )\n        return CE_Failure;\n    FlushDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      If we are averaging bit data to grayscale we need to create     */\n/*      8bit overviews.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvBitsPerSample = nBitsPerSample;\n\n    if( STARTS_WITH_CI(pszResampling, \"AVERAGE_BIT2\") )\n        nOvBitsPerSample = 8;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed;\n    std::vector<unsigned short> anTGreen;\n    std::vector<unsigned short> anTBlue;\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( nPhotometric == PHOTOMETRIC_PALETTE && poColorTable != nullptr )\n    {\n        CreateTIFFColorTable(poColorTable, nOvBitsPerSample,\n                             anTRed, anTGreen, anTBlue,\n                             panRed, panGreen, panBlue);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( pszResampling, this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = nullptr;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples,\n                      &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew =\n            static_cast<uint16*>( CPLMalloc(nExtraSamples * sizeof(uint16)) );\n        memcpy( panExtraSampleValuesNew, panExtraSampleValues,\n                nExtraSamples * sizeof(uint16) );\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = nullptr;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if( nCompression == COMPRESSION_LZW ||\n        nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        nCompression == COMPRESSION_ZSTD )\n        TIFFGetField( hTIFF, TIFFTAG_PREDICTOR, &nPredictor );\n\n/* -------------------------------------------------------------------- */\n/*      Establish which of the overview levels we already have, and     */\n/*      which are new.  We assume that band 1 of the file is            */\n/*      representative.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvrBlockXSize = 0;\n    int nOvrBlockYSize = 0;\n    GTIFFGetOverviewBlockSize(&nOvrBlockXSize, &nOvrBlockYSize);\n    std::vector<bool> abRequireNewOverview(nOverviews, true);\n    for( int i = 0; i < nOverviews && eErr == CE_None; ++i )\n    {\n        for( int j = 0; j < nOverviewCount && eErr == CE_None; ++j )\n        {\n            GTiffDataset *poODS = papoOverviewDS[j];\n\n            const int nOvFactor =\n                GDALComputeOvFactor(poODS->GetRasterXSize(),\n                                    GetRasterXSize(),\n                                    poODS->GetRasterYSize(),\n                                    GetRasterYSize());\n\n            // If we already have a 1x1 overview and this new one would result\n            // in it too, then don't create it.\n            if( poODS->GetRasterXSize() == 1 &&\n                poODS->GetRasterYSize() == 1 &&\n                (GetRasterXSize() + panOverviewList[i] - 1)\n                    / panOverviewList[i] == 1 &&\n                (GetRasterYSize() + panOverviewList[i] - 1)\n                    / panOverviewList[i] == 1 )\n            {\n                abRequireNewOverview[i] = false;\n                break;\n            }\n\n            if( nOvFactor == panOverviewList[i]\n                || nOvFactor == GDALOvLevelAdjust2( panOverviewList[i],\n                                                    GetRasterXSize(),\n                                                    GetRasterYSize() ) )\n            {\n                abRequireNewOverview[i] = false;\n                break;\n            }\n        }\n\n        if( abRequireNewOverview[i] )\n        {\n            const int nOXSize =\n                (GetRasterXSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n            const int nOYSize =\n                (GetRasterYSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n\n            int nOvrJpegQuality = nJpegQuality;\n            if( nCompression == COMPRESSION_JPEG &&\n                CPLGetConfigOption( \"JPEG_QUALITY_OVERVIEW\", nullptr ) != nullptr )\n            {\n                nOvrJpegQuality =\n                    atoi(CPLGetConfigOption(\"JPEG_QUALITY_OVERVIEW\",\"75\"));\n            }\n\n            CPLString osNoData; // don't move this in inner scope\n            const char* pszNoData = nullptr;\n            if( bNoDataSet )\n            {\n                osNoData = GTiffFormatGDALNoDataTagValue(dfNoDataValue);\n                pszNoData = osNoData.c_str();\n            }\n\n            const toff_t nOverviewOffset =\n                GTIFFWriteDirectory(\n                    hTIFF, FILETYPE_REDUCEDIMAGE,\n                    nOXSize, nOYSize,\n                    nOvBitsPerSample, nPlanarConfig,\n                    nSamplesPerPixel, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                    nCompression, nPhotometric, nSampleFormat,\n                    nPredictor,\n                    panRed, panGreen, panBlue,\n                    nExtraSamples, panExtraSampleValues,\n                    osMetadata,\n                    nOvrJpegQuality >= 0 ?\n                                CPLSPrintf(\"%d\", nOvrJpegQuality) : nullptr,\n                    CPLSPrintf(\"%d\", nJpegTablesMode),\n                    pszNoData,\n#ifdef HAVE_LERC\n                    anLercAddCompressionAndVersion\n#else\n                    nullptr\n#endif\n            );\n\n            if( nOverviewOffset == 0 )\n                eErr = CE_Failure;\n            else\n                eErr = RegisterNewOverviewDataset(nOverviewOffset,\n                                                  nOvrJpegQuality);\n        }\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    if( eErr != CE_None )\n        return eErr;\n\n    eErr = CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n\n/* -------------------------------------------------------------------- */\n/*      Refresh overviews for the mask                                  */\n/* -------------------------------------------------------------------- */\n    if( poMaskDS != nullptr &&\n        poMaskDS->GetRasterCount() == 1 )\n    {\n        int nMaskOverviews = 0;\n\n        GDALRasterBand **papoOverviewBands = static_cast<GDALRasterBand **>(\n            CPLCalloc(sizeof(void*),nOverviewCount) );\n        for( int i = 0; i < nOverviewCount; ++i )\n        {\n            if( papoOverviewDS[i]->poMaskDS != nullptr )\n            {\n                papoOverviewBands[nMaskOverviews++] =\n                        papoOverviewDS[i]->poMaskDS->GetRasterBand(1);\n            }\n        }\n        eErr = GDALRegenerateOverviews(\n            poMaskDS->GetRasterBand(1),\n            nMaskOverviews,\n            reinterpret_cast<GDALRasterBandH *>( papoOverviewBands ),\n            pszResampling, GDALDummyProgress, nullptr );\n        CPLFree(papoOverviewBands);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Refresh old overviews that were listed.                         */\n/* -------------------------------------------------------------------- */\n    if( nPlanarConfig == PLANARCONFIG_CONTIG &&\n        GDALDataTypeIsComplex(GetRasterBand( panBandList[0] )->\n                              GetRasterDataType()) == FALSE &&\n        GetRasterBand( panBandList[0] )->GetColorTable() == nullptr &&\n        (STARTS_WITH_CI(pszResampling, \"NEAR\") ||\n         EQUAL(pszResampling, \"AVERAGE\") ||\n         EQUAL(pszResampling, \"GAUSS\") ||\n         EQUAL(pszResampling, \"CUBIC\") ||\n         EQUAL(pszResampling, \"CUBICSPLINE\") ||\n         EQUAL(pszResampling, \"LANCZOS\") ||\n         EQUAL(pszResampling, \"BILINEAR\")) )\n    {\n        // In the case of pixel interleaved compressed overviews, we want to\n        // generate the overviews for all the bands block by block, and not\n        // band after band, in order to write the block once and not loose\n        // space in the TIFF file.  We also use that logic for uncompressed\n        // overviews, since GDALRegenerateOverviewsMultiBand() will be able to\n        // trigger cascading overview regeneration even in the presence\n        // of an alpha band.\n\n        int nNewOverviews = 0;\n\n        GDALRasterBand ***papapoOverviewBands =\n            static_cast<GDALRasterBand ***>(CPLCalloc(sizeof(void*),nBandsIn));\n        GDALRasterBand **papoBandList =\n            static_cast<GDALRasterBand **>(CPLCalloc(sizeof(void*),nBandsIn));\n        for( int iBand = 0; iBand < nBandsIn; ++iBand )\n        {\n            GDALRasterBand* poBand = GetRasterBand( panBandList[iBand] );\n\n            papoBandList[iBand] = poBand;\n            papapoOverviewBands[iBand] =\n                static_cast<GDALRasterBand **>( CPLCalloc(\n                    sizeof(void*), poBand->GetOverviewCount()) );\n\n            int iCurOverview = 0;\n            std::vector<bool> abAlreadyUsedOverviewBand(\n                poBand->GetOverviewCount(), false);\n\n            for( int i = 0; i < nOverviews; ++i )\n            {\n                for( int j = 0; j < poBand->GetOverviewCount(); ++j )\n                {\n                    if( abAlreadyUsedOverviewBand[j] )\n                        continue;\n\n                    int    nOvFactor;\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    nOvFactor = GDALComputeOvFactor(poOverview->GetXSize(),\n                                                     poBand->GetXSize(),\n                                                     poOverview->GetYSize(),\n                                                     poBand->GetYSize());\n\n                    int bHasNoData = FALSE;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if( bHasNoData )\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    if( nOvFactor == panOverviewList[i]\n                        || nOvFactor == GDALOvLevelAdjust2(\n                                            panOverviewList[i],\n                                            poBand->GetXSize(),\n                                            poBand->GetYSize() ) )\n                    {\n                        abAlreadyUsedOverviewBand[j] = true;\n                        CPLAssert(iCurOverview < poBand->GetOverviewCount());\n                        papapoOverviewBands[iBand][iCurOverview] = poOverview;\n                        ++iCurOverview ;\n                        break;\n                    }\n                }\n            }\n\n            if( nNewOverviews == 0 )\n            {\n                nNewOverviews = iCurOverview;\n            }\n            else if( nNewOverviews != iCurOverview )\n            {\n                CPLAssert(false);\n                return CE_Failure;\n            }\n        }\n\n        GDALRegenerateOverviewsMultiBand( nBandsIn, papoBandList,\n                                          nNewOverviews, papapoOverviewBands,\n                                          pszResampling, pfnProgress,\n                                          pProgressData );\n\n        for( int iBand = 0; iBand < nBandsIn; ++iBand )\n        {\n            CPLFree(papapoOverviewBands[iBand]);\n        }\n        CPLFree(papapoOverviewBands);\n        CPLFree(papoBandList);\n    }\n    else\n    {\n        GDALRasterBand **papoOverviewBands = static_cast<GDALRasterBand **>(\n            CPLCalloc(sizeof(void*), nOverviews) );\n\n        for( int iBand = 0; iBand < nBandsIn && eErr == CE_None; ++iBand )\n        {\n            GDALRasterBand *poBand = GetRasterBand( panBandList[iBand] );\n            if( poBand == nullptr )\n            {\n                eErr = CE_Failure;\n                break;\n            }\n\n            std::vector<bool> abAlreadyUsedOverviewBand(\n                poBand->GetOverviewCount(), false);\n\n            int nNewOverviews = 0;\n            for( int i = 0; i < nOverviews; ++i )\n            {\n                for( int j = 0; j < poBand->GetOverviewCount(); ++j )\n                {\n                    if( abAlreadyUsedOverviewBand[j] )\n                        continue;\n\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    int bHasNoData = FALSE;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if( bHasNoData )\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    const int nOvFactor =\n                        GDALComputeOvFactor(poOverview->GetXSize(),\n                                            poBand->GetXSize(),\n                                            poOverview->GetYSize(),\n                                            poBand->GetYSize());\n\n                    if( nOvFactor == panOverviewList[i]\n                        || nOvFactor == GDALOvLevelAdjust2(\n                                            panOverviewList[i],\n                                            poBand->GetXSize(),\n                                            poBand->GetYSize() ) )\n                    {\n                        abAlreadyUsedOverviewBand[j] = true;\n                        CPLAssert(nNewOverviews < poBand->GetOverviewCount());\n                        papoOverviewBands[nNewOverviews++] = poOverview;\n                        break;\n                    }\n                }\n            }\n\n            void *pScaledProgressData =\n                GDALCreateScaledProgress(\n                    iBand / static_cast<double>( nBandsIn ),\n                    (iBand + 1) / static_cast<double>( nBandsIn ),\n                    pfnProgress, pProgressData );\n\n            eErr = GDALRegenerateOverviews(\n                poBand,\n                nNewOverviews,\n                reinterpret_cast<GDALRasterBandH *>( papoOverviewBands ),\n                pszResampling,\n                GDALScaledProgress,\n                pScaledProgressData );\n\n            GDALDestroyScaledProgress( pScaledProgressData );\n        }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup                                                         */\n    /* -------------------------------------------------------------------- */\n        CPLFree( papoOverviewBands );\n    }\n\n    pfnProgress( 1.0, nullptr, pProgressData );\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                      GTiffWriteDummyGeokeyDirectory()                */\n/************************************************************************/\n\nstatic void GTiffWriteDummyGeokeyDirectory( TIFF* hTIFF )\n{\n    // If we have existing geokeys, try to wipe them\n    // by writing a dummy geokey directory. (#2546)\n    uint16 *panVI = nullptr;\n    uint16 nKeyCount = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY,\n                        &nKeyCount, &panVI ) )\n    {\n        GUInt16 anGKVersionInfo[4] = { 1, 1, 0, 0 };\n        double adfDummyDoubleParams[1] = { 0.0 };\n        TIFFSetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY,\n                        4, anGKVersionInfo );\n        TIFFSetField( hTIFF, TIFFTAG_GEODOUBLEPARAMS,\n                        1, adfDummyDoubleParams );\n        TIFFSetField( hTIFF, TIFFTAG_GEOASCIIPARAMS, \"\" );\n    }\n}\n\n#if LIBGEOTIFF_VERSION >= 1430\n\n/************************************************************************/\n/*               GTiffDatasetLibGeotiffErrorCallback()                  */\n/************************************************************************/\n\nstatic void GTiffDatasetLibGeotiffErrorCallback(GTIF*,\n                                                int level,\n                                                const char* pszMsg, ...)\n{\n    va_list ap;\n    va_start(ap, pszMsg);\n    CPLErrorV( (level == LIBGEOTIFF_WARNING ) ? CE_Warning : CE_Failure,\n               CPLE_AppDefined, pszMsg, ap );\n    va_end(ap);\n}\n\n/************************************************************************/\n/*                           GTiffDatasetGTIFNew()                      */\n/************************************************************************/\n\nstatic GTIF* GTiffDatasetGTIFNew( TIFF* hTIFF )\n{\n    return GTIFNewEx(hTIFF, GTiffDatasetLibGeotiffErrorCallback, nullptr);\n}\n#else\n\n/************************************************************************/\n/*                           GTiffDatasetGTIFNew()                      */\n/************************************************************************/\n\nstatic GTIF* GTiffDatasetGTIFNew( TIFF* hTIFF )\n{\n    return GTIFNew(hTIFF);\n}\n#endif\n\n\n/************************************************************************/\n/*                          WriteGeoTIFFInfo()                          */\n/************************************************************************/\n\nvoid GTiffDataset::WriteGeoTIFFInfo()\n\n{\n    bool bPixelIsPoint = false;\n    bool bPointGeoIgnore = false;\n\n    const char* pszAreaOrPoint =\n        GTiffDataset::GetMetadataItem( GDALMD_AREA_OR_POINT );\n    if( pszAreaOrPoint && EQUAL(pszAreaOrPoint, GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore =\n            CPLTestBool( CPLGetConfigOption( \"GTIFF_POINT_GEO_IGNORE\",\n                                             \"FALSE\") );\n    }\n\n    if( bForceUnsetGTOrGCPs )\n    {\n        bNeedsRewrite = true;\n        bForceUnsetGTOrGCPs = false;\n\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOPIXELSCALE );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTIEPOINTS );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTRANSMATRIX );\n#endif\n    }\n\n    if( bForceUnsetProjection )\n    {\n        bNeedsRewrite = true;\n        bForceUnsetProjection = false;\n\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEODOUBLEPARAMS );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOASCIIPARAMS );\n#else\n        GTiffWriteDummyGeokeyDirectory(hTIFF);\n#endif\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write geotransform if valid.                                    */\n/* -------------------------------------------------------------------- */\n    if( bGeoTransformValid )\n    {\n        bNeedsRewrite = true;\n\n/* -------------------------------------------------------------------- */\n/*      Clear old tags to ensure we don't end up with conflicting       */\n/*      information. (#2625)                                            */\n/* -------------------------------------------------------------------- */\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOPIXELSCALE );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTIEPOINTS );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTRANSMATRIX );\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Write the transform.  If we have a normal north-up image we     */\n/*      use the tiepoint plus pixelscale otherwise we use a matrix.     */\n/* -------------------------------------------------------------------- */\n        if( adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0\n                && adfGeoTransform[5] < 0.0 )\n        {\n            double dfOffset = 0.0;\n            if( !EQUAL(osProfile,szPROFILE_BASELINE) )\n            {\n                // In the case the SRS has a vertical component and we have\n                // a single band, encode its scale/offset in the GeoTIFF tags\n                int bHasScale = FALSE;\n                double dfScale = GetRasterBand(1)->GetScale(&bHasScale);\n                int bHasOffset = FALSE;\n                dfOffset = GetRasterBand(1)->GetOffset(&bHasOffset);\n                const bool bApplyScaleOffset =\n                    HasVerticalCS(GetProjectionRef()) &&\n                    GetRasterCount() == 1;\n                if( bApplyScaleOffset && !bHasScale )\n                    dfScale = 1.0;\n                if( !bApplyScaleOffset || !bHasOffset )\n                    dfOffset = 0.0;\n                const double adfPixelScale[3] = {\n                    adfGeoTransform[1], fabs(adfGeoTransform[5]),\n                    bApplyScaleOffset ? dfScale  : 0.0 };\n                TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n            }\n\n            double adfTiePoints[6] = {\n                0.0, 0.0, 0.0, adfGeoTransform[0], adfGeoTransform[3], dfOffset };\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfTiePoints[3] +=\n                    adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                adfTiePoints[4] +=\n                    adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n            }\n\n            if( !EQUAL(osProfile,szPROFILE_BASELINE) )\n                TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n        }\n        else\n        {\n            double adfMatrix[16] = {};\n\n            adfMatrix[0] = adfGeoTransform[1];\n            adfMatrix[1] = adfGeoTransform[2];\n            adfMatrix[3] = adfGeoTransform[0];\n            adfMatrix[4] = adfGeoTransform[4];\n            adfMatrix[5] = adfGeoTransform[5];\n            adfMatrix[7] = adfGeoTransform[3];\n            adfMatrix[15] = 1.0;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfMatrix[3] +=\n                    adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                adfMatrix[7] +=\n                    adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n            }\n\n            if( !EQUAL(osProfile,szPROFILE_BASELINE) )\n                TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n        }\n\n        // Do we need a world file?\n        if( CPLFetchBool( papszCreationOptions, \"TFW\", false ) )\n            GDALWriteWorldFile( osFilename, \"tfw\", adfGeoTransform );\n        else if( CPLFetchBool( papszCreationOptions, \"WORLDFILE\", false ) )\n            GDALWriteWorldFile( osFilename, \"wld\", adfGeoTransform );\n    }\n    else if( GetGCPCount() > 0 )\n    {\n        bNeedsRewrite = true;\n\n        double *padfTiePoints = static_cast<double *>(\n            CPLMalloc( 6 * sizeof(double) * GetGCPCount() ) );\n\n        for( int iGCP = 0; iGCP < GetGCPCount(); ++iGCP )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPList[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPList[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPList[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPList[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPList[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] += 0.5;\n                padfTiePoints[iGCP*6+1] += 0.5;\n            }\n        }\n\n        if( !EQUAL(osProfile,szPROFILE_BASELINE) )\n            TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS,\n                          6 * GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out projection definition.                                */\n/* -------------------------------------------------------------------- */\n    const bool bHasProjection =\n        pszProjection != nullptr && strlen(pszProjection) > 0;\n    if( (bHasProjection || bPixelIsPoint)\n        && !EQUAL(osProfile,szPROFILE_BASELINE) )\n    {\n        bNeedsRewrite = true;\n\n        // If we have existing geokeys, try to wipe them\n        // by writing a dummy geokey directory. (#2546)\n        GTiffWriteDummyGeokeyDirectory(hTIFF);\n\n        GTIF *psGTIF = GTiffDatasetGTIFNew( hTIFF );\n\n        // Set according to coordinate system.\n        if( bHasProjection )\n        {\n            GTIFSetFromOGISDefnEx( psGTIF, pszProjection, eGeoTIFFKeysFlavor );\n        }\n\n        if( bPixelIsPoint )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n}\n\n/************************************************************************/\n/*                         AppendMetadataItem()                         */\n/************************************************************************/\n\nstatic void AppendMetadataItem( CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail,\n                                const char *pszKey, const char *pszValue,\n                                int nBand, const char *pszRole,\n                                const char *pszDomain )\n\n{\n/* -------------------------------------------------------------------- */\n/*      Create the Item element, and subcomponents.                     */\n/* -------------------------------------------------------------------- */\n    CPLXMLNode *psItem = CPLCreateXMLNode( nullptr, CXT_Element, \"Item\" );\n    CPLCreateXMLNode( CPLCreateXMLNode( psItem, CXT_Attribute, \"name\"),\n                      CXT_Text, pszKey );\n\n    if( nBand > 0 )\n    {\n        char szBandId[32] = {};\n        snprintf( szBandId, sizeof(szBandId), \"%d\", nBand - 1 );\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"sample\"),\n                          CXT_Text, szBandId );\n    }\n\n    if( pszRole != nullptr )\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"role\"),\n                          CXT_Text, pszRole );\n\n    if( pszDomain != nullptr && strlen(pszDomain) > 0 )\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"domain\"),\n                          CXT_Text, pszDomain );\n\n    char *pszEscapedItemValue = CPLEscapeString(pszValue,-1,CPLES_XML);\n    CPLCreateXMLNode( psItem, CXT_Text, pszEscapedItemValue );\n    CPLFree( pszEscapedItemValue );\n\n/* -------------------------------------------------------------------- */\n/*      Create root, if missing.                                        */\n/* -------------------------------------------------------------------- */\n    if( *ppsRoot == nullptr )\n        *ppsRoot = CPLCreateXMLNode( nullptr, CXT_Element, \"GDALMetadata\" );\n\n/* -------------------------------------------------------------------- */\n/*      Append item to tail.  We keep track of the tail to avoid        */\n/*      O(nsquared) time as the list gets longer.                       */\n/* -------------------------------------------------------------------- */\n    if( *ppsTail == nullptr )\n        CPLAddXMLChild( *ppsRoot, psItem );\n    else\n        CPLAddXMLSibling( *ppsTail, psItem );\n\n    *ppsTail = psItem;\n}\n\n/************************************************************************/\n/*                         WriteMDMetadata()                            */\n/************************************************************************/\n\nstatic void WriteMDMetadata( GDALMultiDomainMetadata *poMDMD, TIFF *hTIFF,\n                             CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail,\n                             int nBand, const char * pszProfile )\n\n{\n\n/* ==================================================================== */\n/*      Process each domain.                                            */\n/* ==================================================================== */\n    char **papszDomainList = poMDMD->GetDomainList();\n    for( int iDomain = 0;\n         papszDomainList && papszDomainList[iDomain];\n         ++iDomain )\n    {\n        char **papszMD = poMDMD->GetMetadata( papszDomainList[iDomain] );\n        bool bIsXML = false;\n\n        if( EQUAL(papszDomainList[iDomain], \"IMAGE_STRUCTURE\") )\n            continue;  // Ignored.\n        if( EQUAL(papszDomainList[iDomain], \"COLOR_PROFILE\") )\n            continue;  // Ignored.\n        if( EQUAL(papszDomainList[iDomain], MD_DOMAIN_RPC) )\n            continue;  // Handled elsewhere.\n        if( EQUAL(papszDomainList[iDomain], \"xml:ESRI\")\n            && CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n            continue;  // Handled elsewhere.\n        if( EQUAL(papszDomainList[iDomain], \"xml:XMP\") )\n            continue;  // Handled in SetMetadata.\n\n        if( STARTS_WITH_CI(papszDomainList[iDomain], \"xml:\") )\n            bIsXML = true;\n\n/* -------------------------------------------------------------------- */\n/*      Process each item in this domain.                               */\n/* -------------------------------------------------------------------- */\n        for( int iItem = 0; papszMD && papszMD[iItem]; ++iItem )\n        {\n            const char *pszItemValue = nullptr;\n            char *pszItemName = nullptr;\n\n            if( bIsXML )\n            {\n                pszItemName = CPLStrdup(\"doc\");\n                pszItemValue = papszMD[iItem];\n            }\n            else\n            {\n                pszItemValue = CPLParseNameValue( papszMD[iItem], &pszItemName);\n                if( pszItemName == nullptr )\n                {\n                    CPLDebug( \"GTiff\",\n                              \"Invalid metadata item : %s\", papszMD[iItem] );\n                    continue;\n                }\n            }\n\n/* -------------------------------------------------------------------- */\n/*      Convert into XML item or handle as a special TIFF tag.          */\n/* -------------------------------------------------------------------- */\n            if( strlen(papszDomainList[iDomain]) == 0\n                && nBand == 0 &&\n                (STARTS_WITH_CI(pszItemName, \"TIFFTAG_\") ||\n                 (EQUAL(pszItemName, \"GEO_METADATA\") &&\n                  EQUAL(pszProfile, szPROFILE_GDALGeoTIFF)) ||\n                 (EQUAL(pszItemName, \"TIFF_RSID\") &&\n                  EQUAL(pszProfile, szPROFILE_GDALGeoTIFF))) )\n            {\n                if( EQUAL(pszItemName, \"TIFFTAG_RESOLUTIONUNIT\") )\n                {\n                    // ResolutionUnit can't be 0, which is the default if\n                    // atoi() fails.  Set to 1=Unknown.\n                    int v = atoi(pszItemValue);\n                    if( !v ) v = RESUNIT_NONE;\n                    TIFFSetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, v);\n                }\n                else\n                {\n                    bool bFoundTag = false;\n                    size_t iTag = 0;  // Used after for.\n                    for( ;\n                         iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n                         ++iTag )\n                    {\n                        if( EQUAL(pszItemName, asTIFFTags[iTag].pszTagName) )\n                        {\n                            bFoundTag = true;\n                            break;\n                        }\n                    }\n\n                    if( bFoundTag &&\n                        asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      pszItemValue );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      CPLAtof(pszItemValue) );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      atoi(pszItemValue) );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING )\n                    {\n                        int nLen = static_cast<int>(strlen(pszItemValue));\n                        if( nLen )\n                        {\n                            TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                          nLen,\n                                          pszItemValue );\n                        }\n                    }\n                    else\n                        CPLError(\n                            CE_Warning, CPLE_NotSupported,\n                            \"%s metadata item is unhandled and \"\n                            \"will not be written\",\n                            pszItemName);\n                }\n            }\n            else if( nBand == 0 && EQUAL(pszItemName,GDALMD_AREA_OR_POINT) )\n            {\n                /* Do nothing, handled elsewhere. */;\n            }\n            else\n            {\n                AppendMetadataItem( ppsRoot, ppsTail,\n                                    pszItemName, pszItemValue,\n                                    nBand, nullptr, papszDomainList[iDomain] );\n            }\n\n            CPLFree( pszItemName );\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Remove TIFFTAG_xxxxxx that are already set but no longer in     */\n/*      the metadata list (#5619)                                       */\n/* -------------------------------------------------------------------- */\n        if( strlen(papszDomainList[iDomain]) == 0 && nBand == 0 )\n        {\n            for( size_t iTag = 0;\n                 iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n                 ++iTag )\n            {\n                uint32 nCount = 0;\n                char* pszText = nullptr;\n                int16 nVal = 0;\n                float fVal = 0.0f;\n                const char* pszVal =\n                    CSLFetchNameValue(papszMD, asTIFFTags[iTag].pszTagName);\n                if( pszVal == nullptr &&\n                    ((asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                    &pszText )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &nVal )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &fVal )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &nCount, &pszText ))) )\n                {\n#ifdef HAVE_UNSETFIELD\n                    TIFFUnsetField( hTIFF, asTIFFTags[iTag].nTagVal );\n#else\n                    if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n                    {\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal, \"\" );\n                    }\n#endif\n                }\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                           WriteRPC()                                 */\n/************************************************************************/\n\nvoid GTiffDataset::WriteRPC( GDALDataset *poSrcDS, TIFF *l_hTIFF,\n                             int bSrcIsGeoTIFF,\n                             const char *pszProfile,\n                             const char *pszTIFFFilename,\n                             char **l_papszCreationOptions,\n                             bool bWriteOnlyInPAMIfNeeded )\n{\n/* -------------------------------------------------------------------- */\n/*      Handle RPC data written to TIFF RPCCoefficient tag, RPB file,   */\n/*      RPCTEXT file or PAM.                                            */\n/* -------------------------------------------------------------------- */\n    char **papszRPCMD = poSrcDS->GetMetadata(MD_DOMAIN_RPC);\n    if( papszRPCMD != nullptr )\n    {\n        bool bRPCSerializedOtherWay = false;\n\n        if( EQUAL(pszProfile,szPROFILE_GDALGeoTIFF) )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GTiffDatasetWriteRPCTag( l_hTIFF, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        // Write RPB file if explicitly asked, or if a non GDAL specific\n        // profile is selected and RPCTXT is not asked.\n        bool bRPBExplicitlyAsked =\n            CPLFetchBool( l_papszCreationOptions, \"RPB\", false );\n        bool bRPBExplicitlyDenied =\n            !CPLFetchBool( l_papszCreationOptions, \"RPB\", true );\n        if( (!EQUAL(pszProfile,szPROFILE_GDALGeoTIFF) &&\n             !CPLFetchBool( l_papszCreationOptions, \"RPCTXT\", false ) &&\n             !bRPBExplicitlyDenied )\n            || bRPBExplicitlyAsked )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GDALWriteRPBFile( pszTIFFFilename, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        if( CPLFetchBool( l_papszCreationOptions, \"RPCTXT\", false ) )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GDALWriteRPCTXTFile( pszTIFFFilename, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        if( !bRPCSerializedOtherWay && bWriteOnlyInPAMIfNeeded &&\n            bSrcIsGeoTIFF )\n            cpl::down_cast<GTiffDataset*>(poSrcDS)->\n                GDALPamDataset::SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n    }\n}\n\n/************************************************************************/\n/*                  IsStandardColorInterpretation()                     */\n/************************************************************************/\n\nstatic bool IsStandardColorInterpretation(GDALDataset* poSrcDS,\n                                          uint16 nPhotometric,\n                                          char** papszCreationOptions)\n{\n    bool bStardardColorInterp = true;\n    if( nPhotometric == PHOTOMETRIC_MINISBLACK )\n    {\n        for( int i = 0; i < poSrcDS->GetRasterCount(); ++i )\n        {\n            const GDALColorInterp eInterp =\n                poSrcDS->GetRasterBand(i + 1)->GetColorInterpretation();\n            if( !(eInterp == GCI_GrayIndex || eInterp == GCI_Undefined ||\n                    (i > 0 && eInterp == GCI_AlphaBand)) )\n            {\n                bStardardColorInterp = false;\n                break;\n            }\n        }\n    }\n    else if( nPhotometric == PHOTOMETRIC_PALETTE )\n    {\n        bStardardColorInterp =\n            poSrcDS->GetRasterBand(1)->GetColorInterpretation() ==\n                GCI_PaletteIndex;\n    }\n    else if( nPhotometric == PHOTOMETRIC_RGB )\n    {\n        int iStart = 0;\n        if( EQUAL(CSLFetchNameValueDef(papszCreationOptions,\n                                       \"PHOTOMETRIC\", \"\"), \"RGB\") )\n        {\n            iStart = 3;\n            if( poSrcDS->GetRasterCount() == 4 &&\n                CSLFetchNameValue(papszCreationOptions, \"ALPHA\") != nullptr )\n            {\n                iStart = 4;\n            }\n        }\n        for( int i = iStart; i < poSrcDS->GetRasterCount(); ++i )\n        {\n            const GDALColorInterp eInterp =\n                poSrcDS->GetRasterBand(i+1)->GetColorInterpretation();\n            if( !((i == 0 && eInterp == GCI_RedBand) ||\n                    (i == 1 && eInterp == GCI_GreenBand) ||\n                    (i == 2 && eInterp == GCI_BlueBand) ||\n                    (i >= 3 && (eInterp == GCI_Undefined ||\n                                eInterp == GCI_AlphaBand))) )\n            {\n                bStardardColorInterp = false;\n                break;\n            }\n        }\n    }\n    else if( nPhotometric == PHOTOMETRIC_YCBCR &&\n             poSrcDS->GetRasterCount() == 3 )\n    {\n        // do nothing\n    }\n    else\n    {\n        bStardardColorInterp = false;\n    }\n    return bStardardColorInterp;\n}\n\n/************************************************************************/\n/*                           WriteMetadata()                            */\n/************************************************************************/\n\nbool GTiffDataset::WriteMetadata( GDALDataset *poSrcDS, TIFF *l_hTIFF,\n                                  bool bSrcIsGeoTIFF,\n                                  const char *pszProfile,\n                                  const char *pszTIFFFilename,\n                                  char **l_papszCreationOptions,\n                                  bool bExcludeRPBandIMGFileWriting)\n\n{\n/* -------------------------------------------------------------------- */\n/*      Convert all the remaining metadata into a simple XML            */\n/*      format.                                                         */\n/* -------------------------------------------------------------------- */\n    CPLXMLNode *psRoot = nullptr;\n    CPLXMLNode *psTail = nullptr;\n\n    if( bSrcIsGeoTIFF )\n    {\n        GTiffDataset* poSrcDSGTiff = cpl::down_cast<GTiffDataset *>(poSrcDS);\n        assert(poSrcDSGTiff);\n        WriteMDMetadata(\n            &poSrcDSGTiff->oGTiffMDMD,\n            l_hTIFF, &psRoot, &psTail, 0, pszProfile );\n    }\n    else\n    {\n        char **papszMD = poSrcDS->GetMetadata();\n\n        if( CSLCount(papszMD) > 0 )\n        {\n            GDALMultiDomainMetadata l_oMDMD;\n            l_oMDMD.SetMetadata( papszMD );\n\n            WriteMDMetadata( &l_oMDMD, l_hTIFF, &psRoot, &psTail,\n                             0, pszProfile );\n        }\n    }\n\n    if( !bExcludeRPBandIMGFileWriting )\n    {\n        WriteRPC(poSrcDS, l_hTIFF, bSrcIsGeoTIFF,\n                 pszProfile, pszTIFFFilename,\n                 l_papszCreationOptions);\n\n/* -------------------------------------------------------------------- */\n/*      Handle metadata data written to an IMD file.                    */\n/* -------------------------------------------------------------------- */\n        char **papszIMDMD = poSrcDS->GetMetadata(MD_DOMAIN_IMD);\n        if( papszIMDMD != nullptr )\n        {\n            GDALWriteIMDFile( pszTIFFFilename, papszIMDMD );\n        }\n    }\n\n    uint16 nPhotometric = 0;\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    const bool bStardardColorInterp =\n        IsStandardColorInterpretation(poSrcDS, nPhotometric,\n                                      l_papszCreationOptions);\n\n/* -------------------------------------------------------------------- */\n/*      We also need to address band specific metadata, and special     */\n/*      \"role\" metadata.                                                */\n/* -------------------------------------------------------------------- */\n    for( int nBand = 1; nBand <= poSrcDS->GetRasterCount(); ++nBand )\n    {\n        GDALRasterBand *poBand = poSrcDS->GetRasterBand( nBand );\n\n        if( bSrcIsGeoTIFF )\n        {\n            GTiffRasterBand* poSrcBandGTiff = cpl::down_cast<GTiffRasterBand *>(poBand);\n            assert(poSrcBandGTiff);\n            WriteMDMetadata(\n                &poSrcBandGTiff->oGTiffMDMD,\n                l_hTIFF, &psRoot, &psTail, nBand, pszProfile );\n        }\n        else\n        {\n            char **papszMD = poBand->GetMetadata();\n\n            if( CSLCount(papszMD) > 0 )\n            {\n                GDALMultiDomainMetadata l_oMDMD;\n                l_oMDMD.SetMetadata( papszMD );\n\n                WriteMDMetadata( &l_oMDMD, l_hTIFF, &psRoot, &psTail, nBand,\n                                 pszProfile );\n            }\n        }\n\n        const double dfOffset = poBand->GetOffset();\n        const double dfScale = poBand->GetScale();\n        bool bGeoTIFFScaleOffsetInZ = false;\n        double adfGeoTransform[6];\n        // Check if we have already encoded scale/offset in the GeoTIFF tags\n        if( poSrcDS->GetGeoTransform(adfGeoTransform) == CE_None &&\n            adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0\n            && adfGeoTransform[5] < 0.0 &&\n            HasVerticalCS(poSrcDS->GetProjectionRef()) &&\n            poSrcDS->GetRasterCount() == 1 )\n        {\n            bGeoTIFFScaleOffsetInZ = true;\n        }\n\n        if( (dfOffset != 0.0 || dfScale != 1.0) && !bGeoTIFFScaleOffsetInZ )\n        {\n            char szValue[128] = {};\n\n            CPLsnprintf( szValue, sizeof(szValue), \"%.18g\", dfOffset );\n            AppendMetadataItem( &psRoot, &psTail, \"OFFSET\", szValue, nBand,\n                                \"offset\", \"\" );\n            CPLsnprintf( szValue, sizeof(szValue), \"%.18g\", dfScale );\n            AppendMetadataItem( &psRoot, &psTail, \"SCALE\", szValue, nBand,\n                                \"scale\", \"\" );\n        }\n\n        const char* pszUnitType = poBand->GetUnitType();\n        if( pszUnitType != nullptr && pszUnitType[0] != '\\0' )\n            AppendMetadataItem( &psRoot, &psTail, \"UNITTYPE\",\n                                pszUnitType, nBand,\n                                \"unittype\", \"\" );\n\n        if( strlen(poBand->GetDescription()) > 0 )\n        {\n            AppendMetadataItem( &psRoot, &psTail, \"DESCRIPTION\",\n                                poBand->GetDescription(), nBand,\n                                \"description\", \"\" );\n        }\n\n        if( !bStardardColorInterp &&\n            !(nBand <= 3 &&  EQUAL(CSLFetchNameValueDef(\n                l_papszCreationOptions, \"PHOTOMETRIC\", \"\"), \"RGB\") ) )\n        {\n            AppendMetadataItem( &psRoot, &psTail, \"COLORINTERP\",\n                                GDALGetColorInterpretationName(\n                                    poBand->GetColorInterpretation()),\n                                nBand,\n                                \"colorinterp\", \"\" );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the generic XML metadata if there is any.             */\n/* -------------------------------------------------------------------- */\n    if( psRoot != nullptr )\n    {\n        bool bRet = true;\n\n        if( EQUAL(pszProfile,szPROFILE_GDALGeoTIFF) )\n        {\n            char *pszXML_MD = CPLSerializeXMLTree( psRoot );\n            if( strlen(pszXML_MD) > 32000 )\n            {\n                if( bSrcIsGeoTIFF )\n                {\n                    if( cpl::down_cast<GTiffDataset *>(\n                           poSrcDS)->GetPamFlags() & GPF_DISABLED )\n                    {\n                        CPLError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"Metadata exceeding 32000 bytes cannot be written \"\n                            \"into GeoTIFF.\" );\n                    }\n                    else\n                    {\n                        cpl::down_cast<GTiffDataset *>(poSrcDS)->\n                            PushMetadataToPam();\n                        CPLError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"Metadata exceeding 32000 bytes cannot be written \"\n                            \"into GeoTIFF. Transferred to PAM instead.\" );\n                    }\n                }\n                else\n                {\n                    bRet = false;\n                }\n            }\n            else\n            {\n                TIFFSetField( l_hTIFF, TIFFTAG_GDAL_METADATA, pszXML_MD );\n            }\n            CPLFree( pszXML_MD );\n        }\n        else\n        {\n            if( bSrcIsGeoTIFF )\n                cpl::down_cast<GTiffDataset *>(poSrcDS)->PushMetadataToPam();\n            else\n                bRet = false;\n        }\n\n        CPLDestroyXMLNode( psRoot );\n\n        return bRet;\n    }\n\n    // If we have no more metadata but it existed before,\n    // remove the GDAL_METADATA tag.\n    if( EQUAL(pszProfile,szPROFILE_GDALGeoTIFF) )\n    {\n        char* pszText = nullptr;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n        {\n#ifdef HAVE_UNSETFIELD\n            TIFFUnsetField( l_hTIFF, TIFFTAG_GDAL_METADATA );\n#else\n            TIFFSetField( l_hTIFF, TIFFTAG_GDAL_METADATA, \"\" );\n#endif\n        }\n    }\n\n    return true;\n}\n\n/************************************************************************/\n/*                         PushMetadataToPam()                          */\n/*                                                                      */\n/*      When producing a strict profile TIFF or if our aggregate        */\n/*      metadata is too big for a single tiff tag we may end up         */\n/*      needing to write it via the PAM mechanisms.  This method        */\n/*      copies all the appropriate metadata into the PAM level          */\n/*      metadata object but with special care to avoid copying          */\n/*      metadata handled in other ways in TIFF format.                  */\n/************************************************************************/\n\nvoid GTiffDataset::PushMetadataToPam()\n\n{\n    if( GetPamFlags() & GPF_DISABLED )\n        return;\n\n    const bool bStardardColorInterp =\n        IsStandardColorInterpretation(this, nPhotometric, papszCreationOptions);\n\n    for( int nBand = 0; nBand <= GetRasterCount(); ++nBand )\n    {\n        GDALMultiDomainMetadata *poSrcMDMD = nullptr;\n        GTiffRasterBand *poBand = nullptr;\n\n        if( nBand == 0 )\n        {\n            poSrcMDMD = &(this->oGTiffMDMD);\n        }\n        else\n        {\n            poBand = cpl::down_cast<GTiffRasterBand *>(GetRasterBand(nBand));\n            poSrcMDMD = &(poBand->oGTiffMDMD);\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Loop over the available domains.                                */\n/* -------------------------------------------------------------------- */\n        char **papszDomainList = poSrcMDMD->GetDomainList();\n        for( int iDomain = 0;\n             papszDomainList && papszDomainList[iDomain];\n             ++iDomain )\n        {\n            char **papszMD = poSrcMDMD->GetMetadata( papszDomainList[iDomain] );\n\n            if( EQUAL(papszDomainList[iDomain],MD_DOMAIN_RPC)\n                || EQUAL(papszDomainList[iDomain],MD_DOMAIN_IMD)\n                || EQUAL(papszDomainList[iDomain],\"_temporary_\")\n                || EQUAL(papszDomainList[iDomain],\"IMAGE_STRUCTURE\")\n                || EQUAL(papszDomainList[iDomain],\"COLOR_PROFILE\") )\n                continue;\n\n            papszMD = CSLDuplicate(papszMD);\n\n            for( int i = CSLCount(papszMD)-1; i >= 0; --i )\n            {\n                if( STARTS_WITH_CI(papszMD[i], \"TIFFTAG_\")\n                    || EQUALN(papszMD[i],GDALMD_AREA_OR_POINT,\n                              strlen(GDALMD_AREA_OR_POINT)) )\n                    papszMD = CSLRemoveStrings( papszMD, i, 1, nullptr );\n            }\n\n            if( nBand == 0 )\n                GDALPamDataset::SetMetadata( papszMD, papszDomainList[iDomain]);\n            else\n                poBand->\n                    GDALPamRasterBand::SetMetadata( papszMD,\n                                                    papszDomainList[iDomain]);\n\n            CSLDestroy( papszMD );\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Handle some \"special domain\" stuff.                             */\n/* -------------------------------------------------------------------- */\n        if( poBand != nullptr )\n        {\n            poBand->GDALPamRasterBand::SetOffset( poBand->GetOffset() );\n            poBand->GDALPamRasterBand::SetScale( poBand->GetScale() );\n            poBand->GDALPamRasterBand::SetUnitType( poBand->GetUnitType() );\n            poBand->\n                GDALPamRasterBand::SetDescription( poBand->GetDescription() );\n            if( !bStardardColorInterp )\n            {\n                poBand->GDALPamRasterBand::SetColorInterpretation(\n                                        poBand->GetColorInterpretation() );\n            }\n        }\n    }\n    MarkPamDirty();\n}\n\n/************************************************************************/\n/*                     GTiffDatasetWriteRPCTag()                        */\n/*                                                                      */\n/*      Format a TAG according to:                                      */\n/*                                                                      */\n/*      http://geotiff.maptools.org/rpc_prop.html                       */\n/************************************************************************/\n\nvoid GTiffDatasetWriteRPCTag( TIFF *hTIFF, char **papszRPCMD )\n\n{\n    GDALRPCInfo sRPC;\n\n    if( !GDALExtractRPCInfo( papszRPCMD, &sRPC ) )\n        return;\n\n    double adfRPCTag[92] = {};\n    adfRPCTag[0] = -1.0;  // Error Bias\n    adfRPCTag[1] = -1.0;  // Error Random\n\n    adfRPCTag[2] = sRPC.dfLINE_OFF;\n    adfRPCTag[3] = sRPC.dfSAMP_OFF;\n    adfRPCTag[4] = sRPC.dfLAT_OFF;\n    adfRPCTag[5] = sRPC.dfLONG_OFF;\n    adfRPCTag[6] = sRPC.dfHEIGHT_OFF;\n    adfRPCTag[7] = sRPC.dfLINE_SCALE;\n    adfRPCTag[8] = sRPC.dfSAMP_SCALE;\n    adfRPCTag[9] = sRPC.dfLAT_SCALE;\n    adfRPCTag[10] = sRPC.dfLONG_SCALE;\n    adfRPCTag[11] = sRPC.dfHEIGHT_SCALE;\n\n    memcpy( adfRPCTag + 12, sRPC.adfLINE_NUM_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 32, sRPC.adfLINE_DEN_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 52, sRPC.adfSAMP_NUM_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 72, sRPC.adfSAMP_DEN_COEFF, sizeof(double) * 20 );\n\n    TIFFSetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, 92, adfRPCTag );\n}\n\n/************************************************************************/\n/*                             ReadRPCTag()                             */\n/*                                                                      */\n/*      Format a TAG according to:                                      */\n/*                                                                      */\n/*      http://geotiff.maptools.org/rpc_prop.html                       */\n/************************************************************************/\n\nchar** GTiffDatasetReadRPCTag(TIFF* hTIFF)\n\n{\n    double *padfRPCTag = nullptr;\n    uint16 nCount;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, &nCount, &padfRPCTag )\n        || nCount != 92 )\n        return nullptr;\n\n    CPLStringList asMD;\n    asMD.SetNameValue(RPC_LINE_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[2]));\n    asMD.SetNameValue(RPC_SAMP_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[3]));\n    asMD.SetNameValue(RPC_LAT_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[4]));\n    asMD.SetNameValue(RPC_LONG_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[5]));\n    asMD.SetNameValue(RPC_HEIGHT_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[6]));\n    asMD.SetNameValue(RPC_LINE_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[7]));\n    asMD.SetNameValue(RPC_SAMP_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[8]));\n    asMD.SetNameValue(RPC_LAT_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[9]));\n    asMD.SetNameValue(RPC_LONG_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[10]));\n    asMD.SetNameValue(RPC_HEIGHT_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[11]));\n\n    CPLString osField;\n    CPLString osMultiField;\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[12+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue(RPC_LINE_NUM_COEFF, osMultiField );\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[32+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_LINE_DEN_COEFF, osMultiField );\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[52+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_SAMP_NUM_COEFF, osMultiField );\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[72+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_SAMP_DEN_COEFF, osMultiField );\n\n    return asMD.StealList();\n}\n\n/************************************************************************/\n/*                  GTiffFormatGDALNoDataTagValue()                     */\n/************************************************************************/\n\nCPLString GTiffFormatGDALNoDataTagValue( double dfNoData )\n{\n    CPLString osVal;\n    if( CPLIsNan(dfNoData) )\n        osVal = \"nan\";\n    else\n        osVal.Printf(\"%.18g\", dfNoData);\n    return osVal;\n}\n\n/************************************************************************/\n/*                         WriteNoDataValue()                           */\n/************************************************************************/\n\nvoid GTiffDataset::WriteNoDataValue( TIFF *l_hTIFF, double dfNoData )\n\n{\n    CPLString osVal( GTiffFormatGDALNoDataTagValue(dfNoData) );\n    TIFFSetField( l_hTIFF, TIFFTAG_GDAL_NODATA, osVal.c_str() );\n}\n\n/************************************************************************/\n/*                         UnsetNoDataValue()                           */\n/************************************************************************/\n\nvoid GTiffDataset::UnsetNoDataValue( TIFF *l_hTIFF )\n\n{\n#ifdef HAVE_UNSETFIELD\n    TIFFUnsetField( l_hTIFF, TIFFTAG_GDAL_NODATA );\n#else\n    TIFFSetField( l_hTIFF, TIFFTAG_GDAL_NODATA, \"\" );\n#endif\n}\n\n/************************************************************************/\n/*                            SetDirectory()                            */\n/************************************************************************/\n\nbool GTiffDataset::SetDirectory( toff_t nNewOffset )\n\n{\n    Crystalize();\n\n    if( nNewOffset == 0 )\n        nNewOffset = nDirOffset;\n\n    if( TIFFCurrentDirOffset(hTIFF) == nNewOffset )\n    {\n        CPLAssert( *ppoActiveDSRef == this || *ppoActiveDSRef == nullptr );\n        *ppoActiveDSRef = this;\n        return true;\n    }\n\n    if( GetAccess() == GA_Update )\n    {\n        if( *ppoActiveDSRef != nullptr )\n            (*ppoActiveDSRef)->FlushDirectory();\n    }\n\n    if( nNewOffset == 0)\n        return true;\n\n    (*ppoActiveDSRef) = this;\n\n    const int nSetDirResult = TIFFSetSubDirectory( hTIFF, nNewOffset );\n    if( !nSetDirResult )\n        return false;\n\n    RestoreVolatileParameters( hTIFF );\n\n    return true;\n}\n\n/************************************************************************/\n/*                     RestoreVolatileParameters()                      */\n/************************************************************************/\n\nvoid GTiffDataset::RestoreVolatileParameters(TIFF* l_hTIFF)\n{\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( nCompression == COMPRESSION_JPEG\n        && nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode = JPEGCOLORMODE_RAW;  // Initialize to 0;\n\n        TIFFGetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode );\n        if( nColorMode != JPEGCOLORMODE_RGB )\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Propagate any quality settings.                                 */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() == GA_Update )\n    {\n        // Now, reset zip and jpeg quality.\n        if(nJpegQuality > 0 && nCompression == COMPRESSION_JPEG)\n        {\n#ifdef DEBUG_VERBOSE\n            CPLDebug( \"GTiff\", \"Propagate JPEG_QUALITY(%d) in SetDirectory()\",\n                      nJpegQuality );\n#endif\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGQUALITY, nJpegQuality);\n        }\n        if(nJpegTablesMode >= 0 && nCompression == COMPRESSION_JPEG)\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGTABLESMODE, nJpegTablesMode);\n        if(nZLevel > 0 && (nCompression == COMPRESSION_ADOBE_DEFLATE ||\n                           nCompression == COMPRESSION_LERC) )\n            TIFFSetField(l_hTIFF, TIFFTAG_ZIPQUALITY, nZLevel);\n        if(nLZMAPreset > 0 && nCompression == COMPRESSION_LZMA)\n            TIFFSetField(l_hTIFF, TIFFTAG_LZMAPRESET, nLZMAPreset);\n        if( nZSTDLevel > 0 && (nCompression == COMPRESSION_ZSTD ||\n                               nCompression == COMPRESSION_LERC) )\n            TIFFSetField(l_hTIFF, TIFFTAG_ZSTD_LEVEL, nZSTDLevel);\n#if HAVE_LERC\n        if( nCompression == COMPRESSION_LERC )\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_LERC_MAXZERROR, dfMaxZError);\n            TIFFSetField(l_hTIFF, TIFFTAG_LERC_PARAMETERS, 2,\n                         anLercAddCompressionAndVersion);\n        }\n#endif\n        if( nWebPLevel > 0 && nCompression == COMPRESSION_WEBP)\n            TIFFSetField(l_hTIFF, TIFFTAG_WEBP_LEVEL, nWebPLevel);\n        if( bWebPLossless && nCompression == COMPRESSION_WEBP)\n            TIFFSetField(l_hTIFF, TIFFTAG_WEBP_LOSSLESS, 1);\n    }\n}\n\n/************************************************************************/\n/*                              Identify()                              */\n/************************************************************************/\n\nint GTiffDataset::Identify( GDALOpenInfo *poOpenInfo )\n\n{\n    const char *pszFilename = poOpenInfo->pszFilename;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        pszFilename += strlen(\"GTIFF_RAW:\");\n        GDALOpenInfo oOpenInfo( pszFilename, poOpenInfo->eAccess );\n        return Identify(&oOpenInfo);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") )\n        return TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      First we check to see if the file has the expected header       */\n/*      bytes.                                                          */\n/* -------------------------------------------------------------------- */\n    if( poOpenInfo->fpL == nullptr || poOpenInfo->nHeaderBytes < 2 )\n        return FALSE;\n\n    if( (poOpenInfo->pabyHeader[0] != 'I' || poOpenInfo->pabyHeader[1] != 'I')\n        && (poOpenInfo->pabyHeader[0] != 'M'\n        || poOpenInfo->pabyHeader[1] != 'M'))\n        return FALSE;\n\n#ifndef BIGTIFF_SUPPORT\n    if( (poOpenInfo->pabyHeader[2] == 0x2B && poOpenInfo->pabyHeader[3] == 0) ||\n        (poOpenInfo->pabyHeader[2] == 0 && poOpenInfo->pabyHeader[3] == 0x2B) )\n    {\n        CPLError( CE_Failure, CPLE_OpenFailed,\n                  \"This is a BigTIFF file.  BigTIFF is not supported by this \"\n                  \"version of GDAL and libtiff.\" );\n        return FALSE;\n    }\n#endif\n\n    if( (poOpenInfo->pabyHeader[2] != 0x2A || poOpenInfo->pabyHeader[3] != 0)\n        && (poOpenInfo->pabyHeader[3] != 0x2A || poOpenInfo->pabyHeader[2] != 0)\n        && (poOpenInfo->pabyHeader[2] != 0x2B || poOpenInfo->pabyHeader[3] != 0)\n        && (poOpenInfo->pabyHeader[3] != 0x2B ||\n            poOpenInfo->pabyHeader[2] != 0))\n        return FALSE;\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*                          GTIFFExtendMemoryFile()                     */\n/************************************************************************/\n\nstatic bool GTIFFExtendMemoryFile( const CPLString& osTmpFilename,\n                                   VSILFILE* fpTemp,\n                                   VSILFILE* fpL,\n                                   int nNewLength,\n                                   GByte*& pabyBuffer,\n                                   vsi_l_offset& nDataLength )\n{\n    if( nNewLength <= static_cast<int>(nDataLength) )\n        return true;\n    if( VSIFSeekL(fpTemp, nNewLength - 1, SEEK_SET) != 0 )\n        return false;\n    char ch = 0;\n    if( VSIFWriteL(&ch, 1, 1, fpTemp) != 1 )\n        return false;\n    const int nOldDataLength = static_cast<int>(nDataLength);\n    pabyBuffer = static_cast<GByte*>(\n        VSIGetMemFileBuffer( osTmpFilename, &nDataLength, FALSE) );\n    const int nToRead = nNewLength - nOldDataLength;\n    const int nRead = static_cast<int>(\n        VSIFReadL( pabyBuffer + nOldDataLength, 1, nToRead, fpL) );\n    if( nRead != nToRead )\n    {\n        CPLError(CE_Failure, CPLE_FileIO,\n                 \"Needed to read %d bytes. Only %d got\", nToRead, nRead);\n        return false;\n    }\n    return true;\n}\n\n/************************************************************************/\n/*                         GTIFFMakeBufferedStream()                    */\n/************************************************************************/\n\nstatic bool GTIFFMakeBufferedStream(GDALOpenInfo* poOpenInfo)\n{\n    CPLString osTmpFilename;\n    static int nCounter = 0;\n    osTmpFilename.Printf(\"/vsimem/stream_%d.tif\", ++nCounter);\n    VSILFILE* fpTemp = VSIFOpenL(osTmpFilename, \"wb+\");\n    if( fpTemp == nullptr )\n        return false;\n    // The seek is needed for /vsistdin/ that has some rewind capabilities.\n    if( VSIFSeekL(poOpenInfo->fpL, poOpenInfo->nHeaderBytes, SEEK_SET) != 0 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        return false;\n    }\n    CPLAssert( static_cast<int>( VSIFTellL(poOpenInfo->fpL) ) ==\n               poOpenInfo->nHeaderBytes );\n    if( VSIFWriteL(poOpenInfo->pabyHeader, poOpenInfo->nHeaderBytes,\n                   1, fpTemp) != 1 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        return false;\n    }\n    vsi_l_offset nDataLength = 0;\n    GByte* pabyBuffer =\n        static_cast<GByte*>(\n            VSIGetMemFileBuffer( osTmpFilename, &nDataLength, FALSE) );\n    const bool bLittleEndian = (pabyBuffer[0] == 'I');\n#if CPL_IS_LSB\n    const bool bSwap = !bLittleEndian;\n#else\n    const bool bSwap = bLittleEndian;\n#endif\n    const bool bBigTIFF = pabyBuffer[2] == 43 || pabyBuffer[3] == 43;\n    vsi_l_offset nMaxOffset = 0;\n    if( bBigTIFF )\n    {\n        GUInt64 nTmp = 0;\n        memcpy(&nTmp, pabyBuffer + 8, 8);\n        if( bSwap ) CPL_SWAP64PTR(&nTmp);\n        if( nTmp != 16 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"IFD start should be at offset 16 for a streamed BigTIFF\");\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        memcpy(&nTmp, pabyBuffer + 16, 8);\n        if( bSwap ) CPL_SWAP64PTR(&nTmp);\n        if( nTmp > 1024 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Too many tags : \" CPL_FRMT_GIB, nTmp);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        const int nTags = static_cast<int>(nTmp);\n        const int nSpaceForTags = nTags * 20;\n        if( !GTIFFExtendMemoryFile(osTmpFilename, fpTemp, poOpenInfo->fpL,\n                                    24 + nSpaceForTags,\n                                    pabyBuffer, nDataLength) )\n        {\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        nMaxOffset = 24 + nSpaceForTags + 8;\n        for( int i = 0; i < nTags; ++i )\n        {\n            GUInt16 nTmp16 = 0;\n            memcpy(&nTmp16, pabyBuffer + 24 + i * 20, 2);\n            if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n            const int nTag = nTmp16;\n            memcpy(&nTmp16, pabyBuffer + 24 + i * 20 + 2, 2);\n            if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n            const int nDataType = nTmp16;\n            memcpy(&nTmp, pabyBuffer + 24 + i * 20 + 4, 8);\n            if( bSwap ) CPL_SWAP64PTR(&nTmp);\n            if( nTmp >= 16 * 1024 * 1024 )\n            {\n                CPLError(\n                    CE_Failure, CPLE_NotSupported,\n                    \"Too many elements for tag %d : \" CPL_FRMT_GUIB,\n                    nTag, nTmp );\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                VSIUnlink(osTmpFilename);\n                return false;\n            }\n            const GUInt32 nCount = static_cast<GUInt32>(nTmp);\n            const GUInt32 nTagSize =\n                TIFFDataWidth(static_cast<TIFFDataType>(nDataType)) * nCount;\n            if( nTagSize > 8 )\n            {\n                memcpy(&nTmp, pabyBuffer + 24 + i * 20 + 12, 8);\n                if( bSwap ) CPL_SWAP64PTR(&nTmp);\n                if( nTmp > GUINT64_MAX - nTagSize )\n                {\n                    CPLError(CE_Failure, CPLE_NotSupported,\n                             \"Overflow with tag %d\", nTag);\n                    CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                    VSIUnlink(osTmpFilename);\n                    return false;\n                }\n                if( static_cast<vsi_l_offset>(nTmp + nTagSize) > nMaxOffset )\n                    nMaxOffset = nTmp + nTagSize;\n            }\n        }\n    }\n    else\n    {\n        GUInt32 nTmp = 0;\n        memcpy(&nTmp, pabyBuffer + 4, 4);\n        if( bSwap ) CPL_SWAP32PTR(&nTmp);\n        if( nTmp != 8 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"IFD start should be at offset 8 for a streamed TIFF\");\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        GUInt16 nTmp16 = 0;\n        memcpy(&nTmp16, pabyBuffer + 8, 2);\n        if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n        if( nTmp16 > 1024 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Too many tags : %d\", nTmp16);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        const int nTags = nTmp16;\n        const int nSpaceForTags = nTags * 12;\n        if( !GTIFFExtendMemoryFile(osTmpFilename, fpTemp, poOpenInfo->fpL,\n                                   10 + nSpaceForTags,\n                                   pabyBuffer, nDataLength) )\n        {\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        nMaxOffset = 10 + nSpaceForTags + 4;\n        for( int i = 0; i < nTags; ++i )\n        {\n            memcpy(&nTmp16, pabyBuffer + 10 + i * 12, 2);\n            if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n            const int nTag = nTmp16;\n            memcpy(&nTmp16, pabyBuffer + 10 + i * 12 + 2, 2);\n            if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n            const int nDataType = nTmp16;\n            memcpy(&nTmp, pabyBuffer + 10 + i * 12 + 4, 4);\n            if( bSwap ) CPL_SWAP32PTR(&nTmp);\n            if( nTmp >= 16 * 1024 * 1024 )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"Too many elements for tag %d : %u\", nTag, nTmp);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                VSIUnlink(osTmpFilename);\n                return false;\n            }\n            const GUInt32 nCount = nTmp;\n            const GUInt32 nTagSize =\n                TIFFDataWidth(static_cast<TIFFDataType>(nDataType)) * nCount;\n            if( nTagSize > 4 )\n            {\n                memcpy(&nTmp, pabyBuffer + 10 + i * 12 + 8, 4);\n                if( bSwap ) CPL_SWAP32PTR(&nTmp);\n                if( nTmp > static_cast<GUInt32>(UINT_MAX - nTagSize) )\n                {\n                    CPLError(CE_Failure, CPLE_NotSupported,\n                             \"Overflow with tag %d\", nTag);\n                    CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                    VSIUnlink(osTmpFilename);\n                    return false;\n                }\n                if( nTmp + nTagSize > nMaxOffset )\n                    nMaxOffset = nTmp + nTagSize;\n            }\n        }\n    }\n    if( nMaxOffset > 10 * 1024 * 1024 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        VSIUnlink(osTmpFilename);\n        return false;\n    }\n    if( !GTIFFExtendMemoryFile(\n           osTmpFilename, fpTemp, poOpenInfo->fpL,\n           static_cast<int>(nMaxOffset), pabyBuffer, nDataLength) )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        VSIUnlink(osTmpFilename);\n        return false;\n    }\n    CPLAssert(nDataLength == VSIFTellL(poOpenInfo->fpL));\n    poOpenInfo->fpL = reinterpret_cast<VSILFILE *>(\n        VSICreateBufferedReaderHandle(\n            reinterpret_cast<VSIVirtualHandle*>(poOpenInfo->fpL),\n            pabyBuffer,\n            static_cast<vsi_l_offset>(INT_MAX) << 32 ) );\n    if( VSIFCloseL(fpTemp) != 0 )\n        return false;\n    VSIUnlink(osTmpFilename);\n\n    return true;\n}\n\n/************************************************************************/\n/*                                Open()                                */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::Open( GDALOpenInfo * poOpenInfo )\n\n{\n    const char *pszFilename = poOpenInfo->pszFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Check if it looks like a TIFF file.                             */\n/* -------------------------------------------------------------------- */\n    if( !Identify(poOpenInfo) )\n        return nullptr;\n\n    bool bAllowRGBAInterface = true;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") )\n        return OpenDir( poOpenInfo );\n\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    // Disable strip chop for now.\n    bool bStreaming = false;\n    const char* pszReadStreaming =\n        CPLGetConfigOption(\"TIFF_READ_STREAMING\", nullptr);\n    if( poOpenInfo->fpL == nullptr )\n    {\n        poOpenInfo->fpL =\n            VSIFOpenL( pszFilename,\n                       poOpenInfo->eAccess == GA_ReadOnly ? \"rb\" : \"r+b\" );\n        if( poOpenInfo->fpL == nullptr )\n            return nullptr;\n    }\n    else if( !(pszReadStreaming && !CPLTestBool(pszReadStreaming)) &&\n             poOpenInfo->nHeaderBytes >= 24 &&\n             // A pipe has no seeking capability, so its position is 0 despite\n             // having read bytes.\n             (static_cast<int>( VSIFTellL(poOpenInfo->fpL) ) ==\n              poOpenInfo->nHeaderBytes ||\n              strcmp(pszFilename, \"/vsistdin/\") == 0 ||\n              // STARTS_WITH(pszFilename, \"/vsicurl_streaming/\") ||\n              (pszReadStreaming && CPLTestBool(pszReadStreaming))) )\n    {\n        bStreaming = true;\n        if( !GTIFFMakeBufferedStream(poOpenInfo) )\n            return nullptr;\n    }\n\n    // Store errors/warnings and emit them later.\n    std::vector<GTIFFErrorStruct> aoErrors;\n    CPLPushErrorHandlerEx(GTIFFErrorHandler, &aoErrors);\n    CPLSetCurrentErrorHandlerCatchDebug( FALSE );\n    // Open and disable \"strip chopping\" (c option)\n    TIFF *l_hTIFF =\n        VSI_TIFFOpen( pszFilename,\n                      poOpenInfo->eAccess == GA_ReadOnly ? \"r\" : \"r+\",\n                      poOpenInfo->fpL );\n    CPLPopErrorHandler();\n\n    // Now emit errors and change their criticality if needed\n    // We only emit failures if we didn't manage to open the file.\n    // Otherwise it makes Python bindings unhappy (#5616).\n    for( size_t iError = 0; iError < aoErrors.size(); ++iError )\n    {\n        CPLError( (l_hTIFF == nullptr && aoErrors[iError].type == CE_Failure) ?\n                  CE_Failure : CE_Warning,\n                  aoErrors[iError].no,\n                  \"%s\",\n                  aoErrors[iError].msg.c_str() );\n    }\n    aoErrors.resize(0);\n\n    if( l_hTIFF == nullptr )\n        return nullptr;\n\n    uint32 nXSize = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    uint32 nYSize = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n    if( nXSize > INT_MAX || nYSize > INT_MAX )\n    {\n        // GDAL only supports signed 32bit dimensions.\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Too large image size: %u x %u\",\n                 nXSize, nYSize);\n        XTIFFClose( l_hTIFF );\n        return nullptr;\n    }\n\n    uint16 l_nCompression = 0;\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, &(l_nCompression) ) )\n        l_nCompression = COMPRESSION_NONE;\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription( pszFilename );\n    poDS->osFilename = pszFilename;\n    poDS->poActiveDS = poDS;\n    poDS->fpL = poOpenInfo->fpL;\n    poOpenInfo->fpL = nullptr;\n    poDS->bStreamingIn = bStreaming;\n    poDS->nCompression = l_nCompression;\n\n    // In the case of GDAL_DISABLE_READDIR_ON_OPEN = NO / EMPTY_DIR\n    if( poOpenInfo->AreSiblingFilesLoaded() &&\n        CSLCount( poOpenInfo->GetSiblingFiles() ) <= 1 )\n    {\n        poDS->oOvManager.TransferSiblingFiles( CSLDuplicate(\n                                            poOpenInfo->GetSiblingFiles() ) );\n        poDS->m_bHasGotSiblingFiles = true;\n    }\n\n    if( poDS->OpenOffset( l_hTIFF, &(poDS->poActiveDS),\n                          TIFFCurrentDirOffset(l_hTIFF), true,\n                          poOpenInfo->eAccess,\n                          bAllowRGBAInterface, true) != CE_None )\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    // Do we want blocks that are set to zero and that haven't yet being\n    // allocated as tile/strip to remain implicit?\n    if( CPLFetchBool( poOpenInfo->papszOpenOptions, \"SPARSE_OK\", false ) )\n        poDS->bWriteEmptyTiles = false;\n\n    if( poOpenInfo->eAccess == GA_Update )\n    {\n        poDS->InitCreationOrOpenOptions(poOpenInfo->papszOpenOptions);\n    }\n\n    poDS->m_bLoadPam = true;\n    poDS->bColorProfileMetadataChanged = false;\n    poDS->bMetadataChanged = false;\n    poDS->bGeoTIFFInfoChanged = false;\n    poDS->bNoDataChanged = false;\n    poDS->bForceUnsetGTOrGCPs = false;\n    poDS->bForceUnsetProjection = false;\n\n/* -------------------------------------------------------------------- */\n/*      Initialize info for external overviews.                         */\n/* -------------------------------------------------------------------- */\n    poDS->oOvManager.Initialize( poDS, pszFilename );\n    if( poOpenInfo->AreSiblingFilesLoaded() )\n        poDS->oOvManager.TransferSiblingFiles(\n            poOpenInfo->StealSiblingFiles() );\n\n    // For backward compatibility, in case GTIFF_POINT_GEO_IGNORE is defined\n    // load georeferencing right now so as to not require it to be defined\n    // at the GetGeoTransform() time.\n    if( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\", nullptr) != nullptr )\n    {\n        poDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                      GTiffDatasetSetAreaOrPointMD()                  */\n/************************************************************************/\n\nstatic void GTiffDatasetSetAreaOrPointMD( GTIF* hGTIF,\n                                          GDALMultiDomainMetadata& oGTiffMDMD )\n{\n    // Is this a pixel-is-point dataset?\n    short nRasterType = 0;\n\n    if( GDALGTIFKeyGetSHORT(hGTIF, GTRasterTypeGeoKey, &nRasterType,\n                    0, 1 ) == 1 )\n    {\n        if( nRasterType == static_cast<short>(RasterPixelIsPoint) )\n            oGTiffMDMD.SetMetadataItem(GDALMD_AREA_OR_POINT, GDALMD_AOP_POINT);\n        else\n            oGTiffMDMD.SetMetadataItem(GDALMD_AREA_OR_POINT, GDALMD_AOP_AREA);\n    }\n}\n\n/************************************************************************/\n/*                         LoadMDAreaOrPoint()                          */\n/************************************************************************/\n\n// This is a light version of LookForProjection(), which saves the\n// potential costly cost of GTIFGetOGISDefn(), since we just need to\n// access to a raw GeoTIFF key, and not build the full projection object.\n\nvoid GTiffDataset::LoadMDAreaOrPoint()\n{\n    if( bLookedForProjection || bLookedForMDAreaOrPoint ||\n        oGTiffMDMD.GetMetadataItem( GDALMD_AREA_OR_POINT ) != nullptr )\n        return;\n\n    bLookedForMDAreaOrPoint = true;\n\n    if( !SetDirectory() )\n        return;\n\n    GTIF* hGTIF = GTiffDatasetGTIFNew(hTIFF);\n\n    if( !hGTIF )\n    {\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"GeoTIFF tags apparently corrupt, they are being ignored.\" );\n    }\n    else\n    {\n        GTiffDatasetSetAreaOrPointMD( hGTIF, oGTiffMDMD );\n\n        GTIFFree( hGTIF );\n    }\n}\n\n/************************************************************************/\n/*                         LookForProjection()                          */\n/************************************************************************/\n\nvoid GTiffDataset::LookForProjection()\n\n{\n    if( bLookedForProjection )\n        return;\n\n    bLookedForProjection = true;\n\n    IdentifyAuthorizedGeoreferencingSources();\n    if( m_nINTERNALGeorefSrcIndex < 0 )\n        return;\n\n    if( !SetDirectory() )\n        return;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the GeoTIFF projection, if available.                   */\n/* -------------------------------------------------------------------- */\n    CPLFree( pszProjection );\n    pszProjection = nullptr;\n\n    GTIF *hGTIF = GTiffDatasetGTIFNew(hTIFF);\n\n    if( !hGTIF )\n    {\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"GeoTIFF tags apparently corrupt, they are being ignored.\" );\n    }\n    else\n    {\n#if LIBGEOTIFF_VERSION >= 1410\n        GTIFDefn *psGTIFDefn = GTIFAllocDefn();\n#else\n        GTIFDefn *psGTIFDefn =\n            static_cast<GTIFDefn *>(CPLCalloc(1, sizeof(GTIFDefn)));\n#endif\n\n        if( GTIFGetDefn( hGTIF, psGTIFDefn ) )\n        {\n            pszProjection = GTIFGetOGISDefn( hGTIF, psGTIFDefn );\n\n            if( STARTS_WITH_CI(pszProjection, \"COMPD_CS\") )\n            {\n                OGRSpatialReference oSRS;\n\n                oSRS.importFromWkt( pszProjection );\n\n                const char* pszVertUnit = nullptr;\n                oSRS.GetTargetLinearUnits(\"COMPD_CS|VERT_CS\", &pszVertUnit);\n                if( pszVertUnit && !EQUAL(pszVertUnit, \"unknown\") )\n                {\n                    m_osVertUnit = pszVertUnit;\n                }\n\n                // Should we simplify away vertical CS stuff?\n                if( !CPLTestBool( CPLGetConfigOption(\"GTIFF_REPORT_COMPD_CS\",\n                                                    \"NO\") ) )\n                {\n                    CPLDebug( \"GTiff\", \"Got COMPD_CS, but stripping it.\" );\n\n                    oSRS.StripVertical();\n                    CPLFree( pszProjection );\n                    oSRS.exportToWkt( &pszProjection );\n                }\n            }\n        }\n\n        // Check the tif linear unit and the CS linear unit.\n#ifdef ESRI_BUILD\n        AdjustLinearUnit(psGTIFDefn.UOMLength);\n#endif\n\n#if LIBGEOTIFF_VERSION >= 1410\n        GTIFFreeDefn(psGTIFDefn);\n#else\n        CPLFree(psGTIFDefn);\n#endif\n\n        GTiffDatasetSetAreaOrPointMD( hGTIF, oGTiffMDMD );\n\n        GTIFFree( hGTIF );\n    }\n\n    if( pszProjection == nullptr )\n    {\n        pszProjection = CPLStrdup( \"\" );\n    }\n    // else if( !EQUAL(pszProjection, \"\") )\n    // {\n    //     m_nProjectionGeorefSrcIndex = m_nINTERNALGeorefSrcIndex;\n    // }\n\n    bGeoTIFFInfoChanged = false;\n    bForceUnsetGTOrGCPs = false;\n    bForceUnsetProjection = false;\n}\n\n/************************************************************************/\n/*                          AdjustLinearUnit()                          */\n/*                                                                      */\n/*      The following code is only used in ESRI Builds and there is     */\n/*      outstanding discussion on whether it is even appropriate        */\n/*      then.                                                           */\n/************************************************************************/\n#ifdef ESRI_BUILD\n\nvoid GTiffDataset::AdjustLinearUnit( short UOMLength )\n{\n    if( !pszProjection || strlen(pszProjection) == 0 )\n        return;\n    if( UOMLength == 9001 )\n    {\n        char* pstr = strstr(pszProjection, \"PARAMETER\");\n        if( !pstr )\n            return;\n        pstr = strstr(pstr, \"UNIT[\");\n        if( !pstr )\n            return;\n        pstr = strchr(pstr, ',') + 1;\n        if( !pstr )\n            return;\n        char* pstr1 = strchr(pstr, ']');\n        if( !pstr1 || pstr1 - pstr >= 128 )\n            return;\n        char csUnitStr[128];\n        strncpy(csUnitStr, pstr, pstr1 - pstr);\n        csUnitStr[pstr1-pstr] = '\\0';\n        const double csUnit = CPLAtof(csUnitStr);\n        if( fabs(csUnit - 1.0) > 0.000001 )\n        {\n            for( long i = 0; i < 6; ++i )\n                adfGeoTransform[i] /= csUnit;\n        }\n    }\n}\n\n#endif  // def ESRI_BUILD\n\n/************************************************************************/\n/*                            ApplyPamInfo()                            */\n/*                                                                      */\n/*      PAM Information, if available, overrides the GeoTIFF            */\n/*      geotransform and projection definition.  Check for them         */\n/*      now.                                                            */\n/************************************************************************/\n\nvoid GTiffDataset::ApplyPamInfo()\n\n{\n    if( m_nPAMGeorefSrcIndex >= 0 &&\n        ((bGeoTransformValid &&\n          m_nPAMGeorefSrcIndex < m_nGeoTransformGeorefSrcIndex) ||\n          m_nGeoTransformGeorefSrcIndex < 0 || !bGeoTransformValid) )\n    {\n        double adfPamGeoTransform[6] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };\n        if( GDALPamDataset::GetGeoTransform( adfPamGeoTransform ) == CE_None )\n        {\n            if( m_nGeoTransformGeorefSrcIndex == m_nWORLDFILEGeorefSrcIndex )\n                osGeorefFilename.clear();\n            memcpy(adfGeoTransform, adfPamGeoTransform, sizeof(double) * 6);\n            bGeoTransformValid = true;\n        }\n    }\n\n    if( m_nPAMGeorefSrcIndex >= 0 )\n    {\n        if( (m_nTABFILEGeorefSrcIndex < 0 ||\n             m_nPAMGeorefSrcIndex < m_nTABFILEGeorefSrcIndex) &&\n            (m_nINTERNALGeorefSrcIndex < 0 ||\n             m_nPAMGeorefSrcIndex < m_nINTERNALGeorefSrcIndex) )\n        {\n            const char *pszPamSRS = GDALPamDataset::GetProjectionRef();\n            if( pszPamSRS != nullptr && strlen(pszPamSRS) > 0 )\n            {\n                CPLFree( pszProjection );\n                pszProjection = CPLStrdup( pszPamSRS );\n                bLookedForProjection = true;\n                // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n            }\n        }\n        else\n        {\n            if( m_nINTERNALGeorefSrcIndex >= 0 )\n                LookForProjection();\n            if( pszProjection == nullptr || strlen(pszProjection) == 0 )\n            {\n                const char *pszPamSRS = GDALPamDataset::GetProjectionRef();\n                if( pszPamSRS != nullptr && strlen(pszPamSRS) > 0 )\n                {\n                    CPLFree( pszProjection );\n                    pszProjection = CPLStrdup( pszPamSRS );\n                    bLookedForProjection = true;\n                    // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n                }\n            }\n        }\n    }\n\n    int nPamGCPCount;\n    if( m_nPAMGeorefSrcIndex >= 0 &&\n        (nPamGCPCount = GDALPamDataset::GetGCPCount()) > 0 &&\n        ( (nGCPCount > 0 &&\n           m_nPAMGeorefSrcIndex < m_nGeoTransformGeorefSrcIndex) ||\n          m_nGeoTransformGeorefSrcIndex < 0 || nGCPCount == 0 ) )\n    {\n        if( nGCPCount > 0 )\n        {\n            GDALDeinitGCPs( nGCPCount, pasGCPList );\n            CPLFree( pasGCPList );\n            pasGCPList = nullptr;\n        }\n\n        nGCPCount = nPamGCPCount;\n        pasGCPList = GDALDuplicateGCPs(nGCPCount, GDALPamDataset::GetGCPs());\n\n        CPLFree( pszProjection );\n        pszProjection = nullptr;\n        // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n\n        const char *pszPamGCPProjection = GDALPamDataset::GetGCPProjection();\n        if( pszPamGCPProjection != nullptr && strlen(pszPamGCPProjection) > 0 )\n            pszProjection = CPLStrdup(pszPamGCPProjection);\n        else\n            pszProjection = CPLStrdup(\"\");\n\n        bLookedForProjection = true;\n    }\n\n    if( m_nPAMGeorefSrcIndex >= 0 && nGCPCount == 0 )\n    {\n        CPLXMLNode *psValueAsXML = nullptr;\n        CPLXMLNode *psGeodataXform = nullptr;\n        char** papszXML = oMDMD.GetMetadata( \"xml:ESRI\" );\n        if (CSLCount(papszXML) == 1)\n        {\n            psValueAsXML = CPLParseXMLString( papszXML[0] );\n            if( psValueAsXML )\n                psGeodataXform = CPLGetXMLNode(psValueAsXML, \"=GeodataXform\");\n        }\n\n        const char* pszTIFFTagResUnit = GetMetadataItem(\"TIFFTAG_RESOLUTIONUNIT\");\n        const char* pszTIFFTagXRes = GetMetadataItem(\"TIFFTAG_XRESOLUTION\");\n        const char* pszTIFFTagYRes = GetMetadataItem(\"TIFFTAG_YRESOLUTION\");\n        if (psGeodataXform && pszTIFFTagResUnit &&pszTIFFTagXRes &&\n            pszTIFFTagYRes && atoi(pszTIFFTagResUnit) == 2 )\n        {\n            CPLXMLNode* psSourceGCPs = CPLGetXMLNode(psGeodataXform,\n                                                        \"SourceGCPs\");\n            CPLXMLNode* psTargetGCPs = CPLGetXMLNode(psGeodataXform,\n                                                        \"TargetGCPs\");\n            if( psSourceGCPs && psTargetGCPs )\n            {\n                std::vector<double> adfSourceGCPs, adfTargetGCPs;\n                for( CPLXMLNode* psIter = psSourceGCPs->psChild;\n                                    psIter != nullptr;\n                                    psIter = psIter->psNext )\n                {\n                    if( psIter->eType == CXT_Element &&\n                        EQUAL(psIter->pszValue, \"Double\") )\n                    {\n                        adfSourceGCPs.push_back(\n                            CPLAtof( CPLGetXMLValue(psIter, nullptr, \"\") ) );\n                    }\n                }\n                for( CPLXMLNode* psIter = psTargetGCPs->psChild;\n                                    psIter != nullptr;\n                                    psIter = psIter->psNext )\n                {\n                    if( psIter->eType == CXT_Element &&\n                        EQUAL(psIter->pszValue, \"Double\") )\n                    {\n                        adfTargetGCPs.push_back(\n                            CPLAtof( CPLGetXMLValue(psIter, nullptr, \"\") ) );\n                    }\n                }\n                if( adfSourceGCPs.size() == adfTargetGCPs.size() &&\n                    (adfSourceGCPs.size() % 2) == 0 )\n                {\n                    nGCPCount = static_cast<int>(\n                                            adfSourceGCPs.size() / 2);\n                    pasGCPList = static_cast<GDAL_GCP *>(\n                            CPLCalloc(sizeof(GDAL_GCP), nGCPCount) );\n                    for( int i = 0; i < nGCPCount; ++i )\n                    {\n                        pasGCPList[i].pszId = CPLStrdup(\"\");\n                        pasGCPList[i].pszInfo = CPLStrdup(\"\");\n                        // The origin used is the bottom left corner,\n                        // and raw values are in inches!\n                        pasGCPList[i].dfGCPPixel = adfSourceGCPs[2*i] *\n                                                        CPLAtof(pszTIFFTagXRes);\n                        pasGCPList[i].dfGCPLine = nRasterYSize -\n                                adfSourceGCPs[2*i+1] * CPLAtof(pszTIFFTagYRes);\n                        pasGCPList[i].dfGCPX = adfTargetGCPs[2*i];\n                        pasGCPList[i].dfGCPY = adfTargetGCPs[2*i+1];\n                    }\n                }\n            }\n        }\n        if( psValueAsXML )\n            CPLDestroyXMLNode(psValueAsXML);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy any PAM metadata into our GeoTIFF context, and with        */\n/*      the PAM info overriding the GeoTIFF context.                    */\n/* -------------------------------------------------------------------- */\n    char **papszPamDomains = oMDMD.GetDomainList();\n\n    for( int iDomain = 0;\n         papszPamDomains && papszPamDomains[iDomain] != nullptr;\n         ++iDomain )\n    {\n        const char *pszDomain = papszPamDomains[iDomain];\n        char **papszGT_MD = CSLDuplicate(oGTiffMDMD.GetMetadata( pszDomain ));\n        char **papszPAM_MD = oMDMD.GetMetadata( pszDomain );\n\n        papszGT_MD = CSLMerge( papszGT_MD, papszPAM_MD );\n\n        oGTiffMDMD.SetMetadata( papszGT_MD, pszDomain );\n        CSLDestroy( papszGT_MD );\n    }\n\n    for( int i = 1; i <= GetRasterCount(); ++i )\n    {\n        GTiffRasterBand* poBand =\n            cpl::down_cast<GTiffRasterBand *>(GetRasterBand(i));\n        papszPamDomains = poBand->oMDMD.GetDomainList();\n\n        for( int iDomain = 0;\n             papszPamDomains && papszPamDomains[iDomain] != nullptr;\n             ++iDomain )\n        {\n            const char *pszDomain = papszPamDomains[iDomain];\n            char **papszGT_MD =\n                CSLDuplicate(poBand->oGTiffMDMD.GetMetadata( pszDomain ));\n            char **papszPAM_MD = poBand->oMDMD.GetMetadata( pszDomain );\n\n            papszGT_MD = CSLMerge( papszGT_MD, papszPAM_MD );\n\n            poBand->oGTiffMDMD.SetMetadata( papszGT_MD, pszDomain );\n            CSLDestroy( papszGT_MD );\n        }\n    }\n}\n\n/************************************************************************/\n/*                              OpenDir()                               */\n/*                                                                      */\n/*      Open a specific directory as encoded into a filename.           */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::OpenDir( GDALOpenInfo * poOpenInfo )\n\n{\n    bool bAllowRGBAInterface = true;\n    const char* pszFilename = poOpenInfo->pszFilename;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n    if( !STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") ||\n        pszFilename[strlen(\"GTIFF_DIR:\")] == '\\0' )\n    {\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Split out filename, and dir#/offset.                            */\n/* -------------------------------------------------------------------- */\n    pszFilename += strlen(\"GTIFF_DIR:\");\n    bool bAbsolute = false;\n\n    if( STARTS_WITH_CI(pszFilename, \"off:\") )\n    {\n        bAbsolute = true;\n        pszFilename += 4;\n    }\n\n    toff_t nOffset = atol(pszFilename);\n    pszFilename += 1;\n\n    while( *pszFilename != '\\0' && pszFilename[-1] != ':' )\n        ++pszFilename;\n\n    if( *pszFilename == '\\0' || nOffset == 0 )\n    {\n        CPLError(\n            CE_Failure, CPLE_OpenFailed,\n            \"Unable to extract offset or filename, should take the form:\\n\"\n            \"GTIFF_DIR:<dir>:filename or GTIFF_DIR:off:<dir_offset>:filename\" );\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n    VSILFILE* l_fpL = VSIFOpenL(pszFilename, \"r\");\n    if( l_fpL == nullptr )\n        return nullptr;\n    TIFF *l_hTIFF = VSI_TIFFOpen( pszFilename, \"r\", l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If a directory was requested by index, advance to it now.       */\n/* -------------------------------------------------------------------- */\n    if( !bAbsolute )\n    {\n        const toff_t nOffsetRequested = nOffset;\n        while( nOffset > 1 )\n        {\n            if( TIFFReadDirectory( l_hTIFF ) == 0 )\n            {\n                XTIFFClose( l_hTIFF );\n                CPLError(\n                    CE_Failure, CPLE_OpenFailed,\n                    \"Requested directory %lu not found.\",\n                    static_cast<long unsigned int>(nOffsetRequested));\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n            nOffset--;\n        }\n\n        nOffset = TIFFCurrentDirOffset( l_hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription( poOpenInfo->pszFilename );\n    poDS->osFilename = poOpenInfo->pszFilename;\n    poDS->poActiveDS = poDS;\n    poDS->fpL = l_fpL;\n    poDS->hTIFF = l_hTIFF;\n    poDS->bCloseTIFFHandle = true;\n\n    if( !EQUAL(pszFilename,poOpenInfo->pszFilename)\n        && !STARTS_WITH_CI(poOpenInfo->pszFilename, \"GTIFF_RAW:\") )\n    {\n        poDS->SetPhysicalFilename( pszFilename );\n        poDS->SetSubdatasetName( poOpenInfo->pszFilename );\n        poDS->osFilename = pszFilename;\n    }\n\n    if( poOpenInfo->eAccess == GA_Update )\n    {\n        CPLError(\n            CE_Warning, CPLE_AppDefined,\n            \"Opening a specific TIFF directory is not supported in \"\n            \"update mode. Switching to read-only\" );\n    }\n\n    if( poOpenInfo->AreSiblingFilesLoaded() )\n        poDS->oOvManager.TransferSiblingFiles(\n            poOpenInfo->StealSiblingFiles() );\n\n    if( poDS->OpenOffset( l_hTIFF, &(poDS->poActiveDS),\n                          nOffset, false, GA_ReadOnly,\n                          bAllowRGBAInterface, true ) != CE_None )\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                   ConvertTransferFunctionToString()                  */\n/*                                                                      */\n/*      Convert a transfer function table into a string.                */\n/*      Used by LoadICCProfile().                                       */\n/************************************************************************/\nstatic CPLString ConvertTransferFunctionToString( const uint16 *pTable,\n                                                  uint32 nTableEntries )\n{\n    CPLString sValue;\n\n    for( uint32 i = 0; i < nTableEntries; ++i )\n    {\n        if( i == 0 )\n            sValue = sValue.Printf(\"%d\", static_cast<uint32>(pTable[i]));\n        else\n            sValue = sValue.Printf( \"%s, %d\",\n                                    sValue.c_str(),\n                                    static_cast<uint32>(pTable[i]));\n    }\n\n    return sValue;\n}\n\n/************************************************************************/\n/*                             LoadICCProfile()                         */\n/*                                                                      */\n/*      Load ICC Profile or colorimetric data into metadata             */\n/************************************************************************/\n\nvoid GTiffDataset::LoadICCProfile()\n{\n    if( bICCMetadataLoaded )\n        return;\n    bICCMetadataLoaded = true;\n\n    if( !SetDirectory() )\n        return;\n\n    uint32 nEmbedLen = 0;\n    uint8* pEmbedBuffer = nullptr;\n\n\n    if( TIFFGetField(hTIFF, TIFFTAG_ICCPROFILE, &nEmbedLen, &pEmbedBuffer) )\n    {\n        char *pszBase64Profile =\n            CPLBase64Encode(nEmbedLen, reinterpret_cast<const GByte*>(pEmbedBuffer));\n\n        oGTiffMDMD.SetMetadataItem( \"SOURCE_ICC_PROFILE\", pszBase64Profile,\n                                    \"COLOR_PROFILE\" );\n\n        CPLFree(pszBase64Profile);\n\n        return;\n    }\n\n    // Check for colorimetric tiff.\n    float* pCHR = nullptr;\n    float* pWP = nullptr;\n    uint16 *pTFR = nullptr;\n    uint16 *pTFG = nullptr;\n    uint16 *pTFB = nullptr;\n    uint16 *pTransferRange = nullptr;\n\n    if( TIFFGetField(hTIFF, TIFFTAG_PRIMARYCHROMATICITIES, &pCHR) )\n    {\n        if( TIFFGetField(hTIFF, TIFFTAG_WHITEPOINT, &pWP) )\n        {\n            if( !TIFFGetFieldDefaulted( hTIFF, TIFFTAG_TRANSFERFUNCTION, &pTFR,\n                                        &pTFG, &pTFB) )\n                return;\n\n            const int TIFFTAG_TRANSFERRANGE = 0x0156;\n            TIFFGetFieldDefaulted( hTIFF, TIFFTAG_TRANSFERRANGE,\n                                   &pTransferRange);\n\n            // Set all the colorimetric metadata.\n            oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_RED\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[0]),\n                                    static_cast<double>(pCHR[1]) ),\n                \"COLOR_PROFILE\" );\n            oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_GREEN\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[2]),\n                                    static_cast<double>(pCHR[3]) ),\n                \"COLOR_PROFILE\" );\n            oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_BLUE\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[4]),\n                                    static_cast<double>(pCHR[5]) ),\n                \"COLOR_PROFILE\" );\n\n            oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_WHITEPOINT\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pWP[0]),\n                                    static_cast<double>(pWP[1]) ),\n                \"COLOR_PROFILE\" );\n\n            // Set transfer function metadata.\n\n            // Get length of table.\n            const uint32 nTransferFunctionLength = 1 << nBitsPerSample;\n\n            oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_RED\",\n                ConvertTransferFunctionToString( pTFR, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n                ConvertTransferFunctionToString( pTFG, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n                ConvertTransferFunctionToString( pTFB, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            // Set transfer range.\n            if( pTransferRange )\n            {\n                oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_BLACK\",\n                    CPLString().Printf( \"%d, %d, %d\",\n                                        static_cast<int>(pTransferRange[0]),\n                                        static_cast<int>(pTransferRange[2]),\n                                        static_cast<int>(pTransferRange[4])),\n                    \"COLOR_PROFILE\" );\n                oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_WHITE\",\n                    CPLString().Printf( \"%d, %d, %d\",\n                                        static_cast<int>(pTransferRange[1]),\n                                        static_cast<int>(pTransferRange[3]),\n                                        static_cast<int>(pTransferRange[5])),\n                    \"COLOR_PROFILE\" );\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                             SaveICCProfile()                         */\n/*                                                                      */\n/*      Save ICC Profile or colorimetric data into file                 */\n/* pDS:                                                                 */\n/*      Dataset that contains the metadata with the ICC or colorimetric */\n/*      data. If this argument is specified, all other arguments are    */\n/*      ignored. Set them to NULL or 0.                                 */\n/* hTIFF:                                                               */\n/*      Pointer to TIFF handle. Only needed if pDS is NULL or           */\n/*      pDS->hTIFF is NULL.                                             */\n/* papszParmList:                                                       */\n/*      Options containing the ICC profile or colorimetric metadata.    */\n/*      Ignored if pDS is not NULL.                                     */\n/* nBitsPerSample:                                                      */\n/*      Bits per sample. Ignored if pDS is not NULL.                    */\n/************************************************************************/\n\nvoid GTiffDataset::SaveICCProfile( GTiffDataset *pDS, TIFF *l_hTIFF,\n                                   char **papszParmList,\n                                   uint32 l_nBitsPerSample )\n{\n    if( (pDS != nullptr) && (pDS->eAccess != GA_Update) )\n        return;\n\n    if( l_hTIFF == nullptr )\n    {\n        if( pDS == nullptr )\n            return;\n\n        l_hTIFF = pDS->hTIFF;\n        if( l_hTIFF == nullptr )\n            return;\n    }\n\n    if( (papszParmList == nullptr) && (pDS == nullptr) )\n        return;\n\n    const char *pszValue = nullptr;\n    if( pDS != nullptr )\n        pszValue = pDS->GetMetadataItem(\"SOURCE_ICC_PROFILE\", \"COLOR_PROFILE\");\n    else\n        pszValue = CSLFetchNameValue(papszParmList, \"SOURCE_ICC_PROFILE\");\n    if( pszValue != nullptr )\n    {\n        char *pEmbedBuffer = CPLStrdup(pszValue);\n        int32 nEmbedLen =\n            CPLBase64DecodeInPlace(reinterpret_cast<GByte *>(pEmbedBuffer));\n\n        TIFFSetField(l_hTIFF, TIFFTAG_ICCPROFILE, nEmbedLen, pEmbedBuffer);\n\n        CPLFree(pEmbedBuffer);\n    }\n    else\n    {\n        // Output colorimetric data.\n        float pCHR[6] = {};  // Primaries.\n        uint16 pTXR[6] = {};  // Transfer range.\n        const char* pszCHRNames[] = {\n            \"SOURCE_PRIMARIES_RED\",\n            \"SOURCE_PRIMARIES_GREEN\",\n            \"SOURCE_PRIMARIES_BLUE\"\n        };\n        const char* pszTXRNames[] = {\n            \"TIFFTAG_TRANSFERRANGE_BLACK\",\n            \"TIFFTAG_TRANSFERRANGE_WHITE\"\n        };\n\n        // Output chromacities.\n        bool bOutputCHR = true;\n        for( int i = 0; i < 3 && bOutputCHR; ++i )\n        {\n            if( pDS != nullptr )\n                pszValue =\n                    pDS->GetMetadataItem(pszCHRNames[i], \"COLOR_PROFILE\");\n            else\n                pszValue = CSLFetchNameValue(papszParmList, pszCHRNames[i]);\n            if( pszValue == nullptr )\n            {\n                bOutputCHR = false;\n                break;\n            }\n\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputCHR = false;\n                CSLDestroy( papszTokens );\n                break;\n            }\n\n            for( int j = 0; j < 3; ++j )\n            {\n                float v = static_cast<float>(CPLAtof(papszTokens[j]));\n\n                if( j == 2 )\n                {\n                    // Last term of xyY color must be 1.0.\n                    if( v != 1.0 )\n                    {\n                        bOutputCHR = false;\n                        break;\n                    }\n                }\n                else\n                {\n                    pCHR[i * 2 + j] = v;\n                }\n            }\n\n            CSLDestroy( papszTokens );\n        }\n\n        if( bOutputCHR )\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_PRIMARYCHROMATICITIES, pCHR);\n        }\n\n        // Output whitepoint.\n        if( pDS != nullptr )\n            pszValue =\n                pDS->GetMetadataItem(\"SOURCE_WHITEPOINT\", \"COLOR_PROFILE\");\n        else\n            pszValue = CSLFetchNameValue(papszParmList, \"SOURCE_WHITEPOINT\");\n        if( pszValue != nullptr )\n        {\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            bool bOutputWhitepoint = true;\n            float pWP[2] = { 0.0f, 0.0f };  // Whitepoint\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputWhitepoint = false;\n            }\n            else\n            {\n                for( int j = 0; j < 3; ++j )\n                {\n                    const float v = static_cast<float>(CPLAtof(papszTokens[j]));\n\n                    if( j == 2 )\n                    {\n                        // Last term of xyY color must be 1.0.\n                        if( v != 1.0 )\n                        {\n                            bOutputWhitepoint = false;\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        pWP[j] = v;\n                    }\n                }\n            }\n            CSLDestroy( papszTokens );\n\n            if( bOutputWhitepoint )\n            {\n                TIFFSetField(l_hTIFF, TIFFTAG_WHITEPOINT, pWP);\n            }\n        }\n\n        // Set transfer function metadata.\n        char const *pszTFRed = nullptr;\n        if( pDS != nullptr )\n            pszTFRed =\n                pDS->GetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_RED\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFRed =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_RED\" );\n\n        char const *pszTFGreen = nullptr;\n        if( pDS != nullptr )\n            pszTFGreen =\n                pDS->GetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFGreen =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_GREEN\" );\n\n        char const *pszTFBlue = nullptr;\n        if( pDS != nullptr )\n            pszTFBlue =\n                pDS->GetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFBlue =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_BLUE\" );\n\n        if( (pszTFRed != nullptr) && (pszTFGreen != nullptr) && (pszTFBlue != nullptr) )\n        {\n            // Get length of table.\n            const int nTransferFunctionLength =\n                1 << ((pDS!=nullptr)?pDS->nBitsPerSample:l_nBitsPerSample);\n\n            char** papszTokensRed =\n                CSLTokenizeString2(\n                    pszTFRed, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n            char** papszTokensGreen =\n                CSLTokenizeString2(\n                    pszTFGreen, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n            char** papszTokensBlue =\n                CSLTokenizeString2(\n                    pszTFBlue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( (CSLCount( papszTokensRed ) == nTransferFunctionLength) &&\n                (CSLCount( papszTokensGreen ) == nTransferFunctionLength) &&\n                (CSLCount( papszTokensBlue ) == nTransferFunctionLength) )\n            {\n                uint16 *pTransferFuncRed =\n                    static_cast<uint16*>( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n                uint16 *pTransferFuncGreen =\n                    static_cast<uint16*>( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n                uint16 *pTransferFuncBlue =\n                    static_cast<uint16*>( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n\n                // Convert our table in string format into int16 format.\n                for( int i = 0; i < nTransferFunctionLength; ++i )\n                {\n                    pTransferFuncRed[i] =\n                        static_cast<uint16>(atoi(papszTokensRed[i]));\n                    pTransferFuncGreen[i] =\n                        static_cast<uint16>(atoi(papszTokensGreen[i]));\n                    pTransferFuncBlue[i] =\n                        static_cast<uint16>(atoi(papszTokensBlue[i]));\n                }\n\n                TIFFSetField(l_hTIFF, TIFFTAG_TRANSFERFUNCTION,\n                    pTransferFuncRed, pTransferFuncGreen, pTransferFuncBlue);\n\n                CPLFree(pTransferFuncRed);\n                CPLFree(pTransferFuncGreen);\n                CPLFree(pTransferFuncBlue);\n            }\n\n            CSLDestroy( papszTokensRed );\n            CSLDestroy( papszTokensGreen );\n            CSLDestroy( papszTokensBlue );\n        }\n\n        // Output transfer range.\n        bool bOutputTransferRange = true;\n        for( int i = 0; (i < 2) && bOutputTransferRange; ++i )\n        {\n            if( pDS != nullptr )\n                pszValue = pDS->GetMetadataItem( pszTXRNames[i],\n                                                 \"COLOR_PROFILE\" );\n            else\n                pszValue = CSLFetchNameValue(papszParmList, pszTXRNames[i]);\n            if( pszValue == nullptr )\n            {\n                bOutputTransferRange = false;\n                break;\n            }\n\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputTransferRange = false;\n                CSLDestroy( papszTokens );\n                break;\n            }\n\n            for( int j = 0; j < 3; ++j )\n            {\n                pTXR[i + j * 2] = static_cast<uint16>(atoi(papszTokens[j]));\n            }\n\n            CSLDestroy( papszTokens );\n        }\n\n        if( bOutputTransferRange )\n        {\n            const int TIFFTAG_TRANSFERRANGE = 0x0156;\n            TIFFSetField(l_hTIFF, TIFFTAG_TRANSFERRANGE, pTXR);\n        }\n    }\n}\n\n/************************************************************************/\n/*                             OpenOffset()                             */\n/*                                                                      */\n/*      Initialize the GTiffDataset based on a passed in file           */\n/*      handle, and directory offset to utilize.  This is called for    */\n/*      full res, and overview pages.                                   */\n/************************************************************************/\n\nCPLErr GTiffDataset::OpenOffset( TIFF *hTIFFIn,\n                                 GTiffDataset **ppoActiveDSRefIn,\n                                 toff_t nDirOffsetIn,\n                                 bool bBaseIn, GDALAccess eAccessIn,\n                                 bool bAllowRGBAInterface,\n                                 bool bReadGeoTransform )\n\n{\n    eAccess = eAccessIn;\n\n    hTIFF = hTIFFIn;\n    ppoActiveDSRef = ppoActiveDSRefIn;\n\n    nDirOffset = nDirOffsetIn;\n\n    if( !SetDirectory( nDirOffsetIn ) )\n        return CE_Failure;\n\n    bBase = bBaseIn;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some information from the file that is of interest.     */\n/* -------------------------------------------------------------------- */\n    uint32 nXSize = 0;\n    uint32 nYSize = 0;\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    if( nXSize > INT_MAX || nYSize > INT_MAX )\n    {\n        // GDAL only supports signed 32bit dimensions.\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Too large image size: %u x %u\",\n                 nXSize, nYSize);\n        return CE_Failure;\n    }\n    nRasterXSize = nXSize;\n    nRasterYSize = nYSize;\n\n    if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSamplesPerPixel ) )\n        nBands = 1;\n    else\n        nBands = nSamplesPerPixel;\n\n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &(nBitsPerSample)) )\n        nBitsPerSample = 1;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &(nPlanarConfig) ) )\n        nPlanarConfig = PLANARCONFIG_CONTIG;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLEFORMAT, &(nSampleFormat) ) )\n        nSampleFormat = SAMPLEFORMAT_UINT;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n\n#if defined(TIFFLIB_VERSION) && TIFFLIB_VERSION > 20031007 // 3.6.0\n    if( nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(nCompression) )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Cannot open TIFF file due to missing codec.\" );\n        return CE_Failure;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( nCompression == COMPRESSION_JPEG\n        && nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\") ) )\n    {\n        oGTiffMDMD.SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\",\n                                    \"IMAGE_STRUCTURE\" );\n        int nColorMode = 0;\n        if( !TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n            nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get strip/tile layout.                                          */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled(hTIFF) )\n    {\n        uint32 l_nBlockXSize = 0;\n        uint32 l_nBlockYSize = 0;\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(l_nBlockXSize) );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(l_nBlockYSize) );\n        if( l_nBlockXSize > INT_MAX || l_nBlockYSize > INT_MAX )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Too large block size: %u x %u\",\n                     l_nBlockXSize, l_nBlockYSize);\n            return CE_Failure;\n        }\n        nBlockXSize = static_cast<int>(l_nBlockXSize);\n        nBlockYSize = static_cast<int>(l_nBlockYSize);\n    }\n    else\n    {\n        if( !TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(nRowsPerStrip) ) )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined,\n                      \"RowsPerStrip not defined ... assuming all one strip.\" );\n            nRowsPerStrip = nYSize;  // Dummy value.\n        }\n\n        // If the rows per strip is larger than the file we will get\n        // confused.  libtiff internally will treat the rowsperstrip as\n        // the image height and it is best if we do too. (#4468)\n        if( nRowsPerStrip > static_cast<uint32>(nRasterYSize) )\n            nRowsPerStrip = nRasterYSize;\n\n        nBlockXSize = nRasterXSize;\n        nBlockYSize = nRowsPerStrip;\n    }\n\n    const int l_nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, nBlockYSize);\n    const int l_nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    if( l_nBlocksPerColumn > INT_MAX / l_nBlocksPerRow )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Too many blocks: %d x %d\",\n                  l_nBlocksPerRow, l_nBlocksPerColumn );\n        return CE_Failure;\n    }\n\n    // Note: we could potentially go up to UINT_MAX blocks, but currently\n    // we use a int nBlockId\n    nBlocksPerBand = l_nBlocksPerColumn * l_nBlocksPerRow;\n    if( nPlanarConfig == PLANARCONFIG_SEPARATE &&\n        nBlocksPerBand > INT_MAX / nBands )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Too many blocks: %d x %d x %d bands\",\n                  l_nBlocksPerRow, l_nBlocksPerColumn, nBands );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we handle this using the GTiffBitmapBand?                */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsBitmap = false;\n\n    if( nBitsPerSample == 1 && nBands == 1 )\n    {\n        bTreatAsBitmap = true;\n\n        // Lets treat large \"one row\" bitmaps using the scanline api.\n        if( !TIFFIsTiled(hTIFF)\n            && nBlockYSize == nRasterYSize\n            && nRasterYSize > 2000\n            // libtiff does not support reading JBIG files with\n            // TIFFReadScanline().\n            && nCompression != COMPRESSION_JBIG )\n        {\n            bTreatAsSplitBitmap = true;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the RGBA interface?                    */\n/* -------------------------------------------------------------------- */\n    if(\n#ifdef DEBUG\n        CPLTestBool(CPLGetConfigOption(\"GTIFF_FORCE_RGBA\", \"NO\")) ||\n#endif\n        (bAllowRGBAInterface &&\n        !bTreatAsBitmap && !(nBitsPerSample > 8)\n        && (nPhotometric == PHOTOMETRIC_CIELAB ||\n            nPhotometric == PHOTOMETRIC_LOGL ||\n            nPhotometric == PHOTOMETRIC_LOGLUV ||\n            nPhotometric == PHOTOMETRIC_SEPARATED ||\n            ( nPhotometric == PHOTOMETRIC_YCBCR\n              && nCompression != COMPRESSION_JPEG ))) )\n    {\n        char szMessage[1024] = {};\n\n        if( TIFFRGBAImageOK( hTIFF, szMessage ) == 1 )\n        {\n            const char* pszSourceColorSpace = nullptr;\n            nBands = 4;\n            switch( nPhotometric )\n            {\n                case PHOTOMETRIC_CIELAB:\n                    pszSourceColorSpace = \"CIELAB\";\n                    break;\n                case PHOTOMETRIC_LOGL:\n                    pszSourceColorSpace = \"LOGL\";\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    pszSourceColorSpace = \"LOGLUV\";\n                    break;\n                case PHOTOMETRIC_SEPARATED:\n                    pszSourceColorSpace = \"CMYK\";\n                    break;\n                case PHOTOMETRIC_YCBCR:\n                    pszSourceColorSpace = \"YCbCr\";\n                    nBands = 3; // probably true for other photometric values\n                    break;\n            }\n            if( pszSourceColorSpace )\n                oGTiffMDMD.SetMetadataItem( \"SOURCE_COLOR_SPACE\",\n                                            pszSourceColorSpace,\n                                            \"IMAGE_STRUCTURE\" );\n            bTreatAsRGBA = true;\n\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"TIFFRGBAImageOK says:\\n%s\", szMessage );\n        }\n    }\n\n    // libtiff has various issues with OJPEG compression and chunky-strip\n    // support with the \"classic\" scanline/strip/tile interfaces, and that\n    // wouldn't work either, so better bail out.\n    if( nCompression == COMPRESSION_OJPEG &&\n        !bTreatAsRGBA )\n    {\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Old-JPEG compression only supported through RGBA interface, \"\n                 \"which cannot be used probably because the file is corrupted\");\n        return CE_Failure;\n    }\n\n    // If photometric is YCbCr, scanline/strip/tile interfaces assumes that\n    // we are ready with downsampled data. And we are not.\n    if( nCompression != COMPRESSION_JPEG &&\n        nCompression != COMPRESSION_OJPEG &&\n        nPhotometric == PHOTOMETRIC_YCBCR &&\n        nPlanarConfig == PLANARCONFIG_CONTIG &&\n        !bTreatAsRGBA )\n    {\n        uint16 nF1, nF2;\n        TIFFGetFieldDefaulted(hTIFF,TIFFTAG_YCBCRSUBSAMPLING,&nF1,&nF2);\n        if( nF1 != 1 || nF2 != 1 )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"Cannot open TIFF file with YCbCr, subsampling and \"\n                      \"BitsPerSample > 8 that is not JPEG compressed\" );\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the split interface?                   */\n/* -------------------------------------------------------------------- */\n    if( !TIFFIsTiled(hTIFF)\n        && nBitsPerSample == 8\n        && nBlockYSize == nRasterYSize\n        && nRasterYSize > 2000\n        && !bTreatAsRGBA\n        && CPLTestBool(CPLGetConfigOption(\"GDAL_ENABLE_TIFF_SPLIT\", \"YES\")) )\n    {\n        // libtiff 3.9.2 (20091104) and older, libtiff 4.0.0beta5 (also\n        // 20091104) and older will crash when trying to open a\n        // all-in-one-strip YCbCr JPEG compressed TIFF (see #3259).\n#if (TIFFLIB_VERSION <= 20091104 && !defined(BIGTIFF_SUPPORT)) || \\\n    (TIFFLIB_VERSION <= 20091104 && defined(BIGTIFF_SUPPORT))\n        if( nPhotometric == PHOTOMETRIC_YCBCR &&\n            nCompression == COMPRESSION_JPEG )\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"Avoid using split band to open all-in-one-strip \"\n                \"YCbCr JPEG compressed TIFF because of older libtiff\" );\n        }\n        else\n#endif\n        {\n            bTreatAsSplit = true;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the odd bits interface?                */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsOdd = false;\n    if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n    {\n        if( nBitsPerSample == 16 || nBitsPerSample == 24 )\n            bTreatAsOdd = true;\n    }\n    else if( !bTreatAsRGBA && !bTreatAsBitmap\n             && nBitsPerSample != 8\n             && nBitsPerSample != 16\n             && nBitsPerSample != 32\n             && nBitsPerSample != 64\n             && nBitsPerSample != 128 )\n    {\n        bTreatAsOdd = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We don't support 'chunks' bigger than 2GB although libtiff v4   */\n/*      can.                                                            */\n/* -------------------------------------------------------------------- */\n#if defined(BIGTIFF_SUPPORT)\n    uint64 nChunkSize = 0;\n    if( bTreatAsSplit || bTreatAsSplitBitmap )\n    {\n        nChunkSize = TIFFScanlineSize64( hTIFF );\n    }\n    else\n    {\n        if( TIFFIsTiled(hTIFF) )\n            nChunkSize = TIFFTileSize64( hTIFF );\n        else\n            nChunkSize = TIFFStripSize64( hTIFF );\n    }\n    if( bTreatAsRGBA )\n    {\n        nChunkSize = std::max(nChunkSize,\n                        4 * static_cast<uint64>(nBlockXSize) * nBlockYSize);\n    }\n    if( nChunkSize > static_cast<uint64>(INT_MAX) )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Scanline/tile/strip size bigger than 2GB.\" );\n        return CE_Failure;\n    }\n#endif\n\n    const bool bMinIsWhite = nPhotometric == PHOTOMETRIC_MINISWHITE;\n\n/* -------------------------------------------------------------------- */\n/*      Check for NODATA                                                */\n/* -------------------------------------------------------------------- */\n    char *pszText = nullptr;\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_NODATA, &pszText ) &&\n        !EQUAL(pszText, \"\") )\n    {\n        bNoDataSet = true;\n        dfNoDataValue = CPLAtofM( pszText );\n        if( nBitsPerSample == 32 && nSampleFormat == SAMPLEFORMAT_IEEEFP )\n        {\n            dfNoDataValue = GDALAdjustNoDataCloseToFloatMax(dfNoDataValue);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture the color table if there is one.                        */\n/* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( bTreatAsRGBA || nBitsPerSample > 16\n        || TIFFGetField( hTIFF, TIFFTAG_COLORMAP,\n                         &panRed, &panGreen, &panBlue) == 0 )\n    {\n        // Build inverted palette if we have inverted photometric.\n        // Pixel values remains unchanged.  Avoid doing this for *deep*\n        // data types (per #1882)\n        if( nBitsPerSample <= 16 && nPhotometric == PHOTOMETRIC_MINISWHITE )\n        {\n            poColorTable = new GDALColorTable();\n            const int nColorCount = 1 << nBitsPerSample;\n\n            for( int iColor = 0; iColor < nColorCount; ++iColor )\n            {\n                const short nValue =\n                    static_cast<short>(((255 * (nColorCount - 1 - iColor)) /\n                                        (nColorCount - 1)));\n                const GDALColorEntry oEntry =\n                    { nValue, nValue, nValue, static_cast<short>(255) };\n                poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n\n            nPhotometric = PHOTOMETRIC_PALETTE;\n        }\n        else\n        {\n            poColorTable = nullptr;\n        }\n    }\n    else\n    {\n        unsigned short nMaxColor = 0;\n\n        poColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 << nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            // TODO(schwehr): Ensure the color entries are never negative?\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast<short>(panRed[iColor] / divisor),\n                static_cast<short>(panGreen[iColor] / divisor),\n                static_cast<short>(panBlue[iColor] / divisor),\n                static_cast<short>(\n                    bNoDataSet && static_cast<int>(dfNoDataValue) == iColor\n                    ? 0\n                    : 255)\n            };\n\n            poColorTable->SetColorEntry( iColor, &oEntry );\n\n            nMaxColor = std::max(nMaxColor, panRed[iColor]);\n            nMaxColor = std::max(nMaxColor, panGreen[iColor]);\n            nMaxColor = std::max(nMaxColor, panBlue[iColor]);\n        }\n\n        // Bug 1384 - Some TIFF files are generated with color map entry\n        // values in range 0-255 instead of 0-65535 - try to handle these\n        // gracefully.\n        if( nMaxColor > 0 && nMaxColor < 256 )\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"TIFF ColorTable seems to be improperly scaled, fixing up.\" );\n\n            for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n            {\n                // TODO(schwehr): Ensure the color entries are never negative?\n                const GDALColorEntry oEntry = {\n                    static_cast<short>(panRed[iColor]),\n                    static_cast<short>(panGreen[iColor]),\n                    static_cast<short>(panBlue[iColor]),\n                    bNoDataSet &&\n                    static_cast<int>(dfNoDataValue) == iColor\n                    ? static_cast<short>(0)\n                    : static_cast<short>(255)\n                };\n\n                poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < nBands; ++iBand )\n    {\n        if( bTreatAsRGBA )\n            SetBand( iBand + 1, new GTiffRGBABand( this, iBand + 1 ) );\n        else if( bTreatAsSplitBitmap )\n            SetBand( iBand + 1, new GTiffSplitBitmapBand( this, iBand + 1 ) );\n        else if( bTreatAsSplit )\n            SetBand( iBand + 1, new GTiffSplitBand( this, iBand + 1 ) );\n        else if( bTreatAsBitmap )\n            SetBand( iBand + 1, new GTiffBitmapBand( this, iBand + 1 ) );\n        else if( bTreatAsOdd )\n            SetBand( iBand + 1, new GTiffOddBitsBand( this, iBand + 1 ) );\n        else\n            SetBand( iBand + 1, new GTiffRasterBand( this, iBand + 1 ) );\n    }\n\n    if( GetRasterBand(1)->GetRasterDataType() == GDT_Unknown )\n    {\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Unsupported TIFF configuration: BitsPerSample(=%d) and \"\n                 \"SampleType(=%d)\",\n                 nBitsPerSample,\n                 nSampleFormat);\n        return CE_Failure;\n    }\n\n    m_bReadGeoTransform = bReadGeoTransform;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some other potentially interesting information.         */\n/* -------------------------------------------------------------------- */\n    char szWorkMDI[200] = {};\n    uint16 nShort = 0;\n\n    for( size_t iTag = 0;\n         iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n         ++iTag )\n    {\n        if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n        {\n            if( TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &pszText ) )\n                oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            pszText );\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT )\n        {\n            float fVal = 0.0;\n            if( TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &fVal ) )\n            {\n                CPLsnprintf( szWorkMDI, sizeof(szWorkMDI), \"%.8g\", fVal );\n                oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            szWorkMDI );\n            }\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT &&\n                 asTIFFTags[iTag].nTagVal != TIFFTAG_RESOLUTIONUNIT )\n        {\n            if( TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &nShort ) )\n            {\n                snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort );\n                oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            szWorkMDI );\n            }\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING )\n        {\n            uint32 nCount = 0;\n            if( TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                              &nCount, &pszText ) )\n            {\n                std::string osStr;\n                osStr.assign(pszText, nCount);\n                oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            osStr.c_str() );\n            }\n        }\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, &nShort ) )\n    {\n        if( nShort == RESUNIT_NONE )\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d (unitless)\", nShort );\n        else if( nShort == RESUNIT_INCH )\n            snprintf( szWorkMDI, sizeof(szWorkMDI),\n                      \"%d (pixels/inch)\", nShort );\n        else if( nShort == RESUNIT_CENTIMETER )\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d (pixels/cm)\", nShort );\n        else\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort );\n        oGTiffMDMD.SetMetadataItem( \"TIFFTAG_RESOLUTIONUNIT\", szWorkMDI );\n    }\n\n    int nTagSize = 0;\n    void* pData = nullptr;\n    if( TIFFGetField( hTIFF, TIFFTAG_XMLPACKET, &nTagSize, &pData ) )\n    {\n        char* pszXMP =\n            static_cast<char *>( VSI_MALLOC_VERBOSE(nTagSize + 1) );\n        if( pszXMP )\n        {\n            memcpy(pszXMP, pData, nTagSize);\n            pszXMP[nTagSize] = '\\0';\n\n            char *apszMDList[2] = { pszXMP, nullptr };\n            oGTiffMDMD.SetMetadata(apszMDList, \"xml:XMP\");\n\n            CPLFree(pszXMP);\n        }\n    }\n\n    if( nCompression == COMPRESSION_NONE )\n        /* no compression tag */;\n    else if( nCompression == COMPRESSION_CCITTRLE )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTRLE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_CCITTFAX3 )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTFAX3\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_CCITTFAX4 )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTFAX4\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_LZW )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LZW\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_OJPEG )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"OJPEG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_JPEG )\n    {\n        if( nPhotometric == PHOTOMETRIC_YCBCR )\n            oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\",\n                                        \"IMAGE_STRUCTURE\" );\n        else\n            oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JPEG\",\n                                        \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_NEXT )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"NEXT\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_CCITTRLEW )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTRLEW\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_PACKBITS )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PACKBITS\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_THUNDERSCAN )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"THUNDERSCAN\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_PIXARFILM )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PIXARFILM\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_PIXARLOG )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PIXARLOG\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_DEFLATE )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DEFLATE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_ADOBE_DEFLATE )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DEFLATE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_DCS )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DCS\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_JBIG )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JBIG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_SGILOG )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"SGILOG\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_SGILOG24 )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"SGILOG24\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_JP2000 )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JP2000\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_LZMA )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LZMA\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_ZSTD )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"ZSTD\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_LERC )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC\", \"IMAGE_STRUCTURE\" );\n#if HAVE_LERC\n        uint32 nLercParamCount = 0;\n        uint32* panLercParms = nullptr;\n        if( TIFFGetField( hTIFF, TIFFTAG_LERC_PARAMETERS, &nLercParamCount,\n                          &panLercParms ) &&\n            nLercParamCount == 2 )\n        {\n            memcpy( anLercAddCompressionAndVersion, panLercParms,\n                    sizeof(anLercAddCompressionAndVersion) );\n        }\n\n        uint32 nAddVersion = LERC_ADD_COMPRESSION_NONE;\n        if( TIFFGetField( hTIFF, TIFFTAG_LERC_ADD_COMPRESSION, &nAddVersion ) &&\n            nAddVersion != LERC_ADD_COMPRESSION_NONE )\n        {\n            if( nAddVersion == LERC_ADD_COMPRESSION_DEFLATE )\n            {\n                oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC_DEFLATE\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n            else if( nAddVersion == LERC_ADD_COMPRESSION_ZSTD )\n            {\n                oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC_ZSTD\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n        }\n        uint32 nLercVersion = LERC_VERSION_2_4;\n        if( TIFFGetField( hTIFF, TIFFTAG_LERC_VERSION, &nLercVersion) )\n        {\n            if( nLercVersion == LERC_VERSION_2_4 )\n            {\n                oGTiffMDMD.SetMetadataItem( \"LERC_VERSION\", \"2.4\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n            else\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"Unknown Lerc version: %d\", nLercVersion);\n            }\n        }\n#endif\n    }\n    else if( nCompression == COMPRESSION_WEBP )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"WEBP\", \"IMAGE_STRUCTURE\" );\n    }\n    else\n    {\n        CPLString oComp;\n        oComp.Printf( \"%d\", nCompression);\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", oComp.c_str());\n    }\n\n    if( nPlanarConfig == PLANARCONFIG_CONTIG && nBands != 1 )\n        oGTiffMDMD.SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        oGTiffMDMD.SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    if( (GetRasterBand(1)->GetRasterDataType() == GDT_Byte &&\n         nBitsPerSample != 8 ) ||\n        (GetRasterBand(1)->GetRasterDataType() == GDT_UInt16 &&\n         nBitsPerSample != 16) ||\n        ((GetRasterBand(1)->GetRasterDataType() == GDT_UInt32 ||\n          GetRasterBand(1)->GetRasterDataType() == GDT_Float32) &&\n         nBitsPerSample != 32) )\n    {\n        for( int i = 0; i < nBands; ++i )\n            cpl::down_cast<GTiffRasterBand*>(GetRasterBand(i + 1))->\n                oGTiffMDMD.SetMetadataItem(\n                    \"NBITS\",\n                    CPLString().Printf(\n                        \"%d\", static_cast<int>(nBitsPerSample) ),\n                    \"IMAGE_STRUCTURE\" );\n    }\n\n    if( bMinIsWhite )\n        oGTiffMDMD.SetMetadataItem( \"MINISWHITE\", \"YES\", \"IMAGE_STRUCTURE\" );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n    {\n        CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n        CPLXMLNode *psItem = nullptr;\n\n        if( psRoot != nullptr && psRoot->eType == CXT_Element\n            && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n            psItem = psRoot->psChild;\n\n        for( ; psItem != nullptr; psItem = psItem->psNext )\n        {\n\n            if( psItem->eType != CXT_Element\n                || !EQUAL(psItem->pszValue,\"Item\") )\n                continue;\n\n            const char *pszKey = CPLGetXMLValue( psItem, \"name\", nullptr );\n            const char *pszValue = CPLGetXMLValue( psItem, nullptr, nullptr );\n            int nBand =\n                atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" ));\n            if( nBand < -1 || nBand > 65535 )\n                continue;\n            nBand ++;\n            const char *pszRole = CPLGetXMLValue( psItem, \"role\", \"\" );\n            const char *pszDomain = CPLGetXMLValue( psItem, \"domain\", \"\" );\n\n            if( pszKey == nullptr || pszValue == nullptr )\n                continue;\n            if( EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n                continue;\n\n            bool bIsXML = false;\n\n            if( STARTS_WITH_CI(pszDomain, \"xml:\") )\n                bIsXML = TRUE;\n\n            char *pszUnescapedValue =\n                CPLUnescapeString( pszValue, nullptr, CPLES_XML );\n            if( nBand == 0 )\n            {\n                if( bIsXML )\n                {\n                    char *apszMD[2] = { pszUnescapedValue, nullptr };\n                    oGTiffMDMD.SetMetadata( apszMD, pszDomain );\n                }\n                else\n                {\n                    oGTiffMDMD.SetMetadataItem( pszKey, pszUnescapedValue,\n                                                pszDomain );\n                }\n            }\n            else\n            {\n                GTiffRasterBand *poBand =\n                    cpl::down_cast<GTiffRasterBand*>(GetRasterBand(nBand));\n                if( poBand != nullptr )\n                {\n                    if( EQUAL(pszRole,\"scale\") )\n                    {\n                        poBand->bHaveOffsetScale = true;\n                        poBand->dfScale = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if( EQUAL(pszRole,\"offset\") )\n                    {\n                        poBand->bHaveOffsetScale = true;\n                        poBand->dfOffset = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if( EQUAL(pszRole,\"unittype\") )\n                    {\n                        poBand->osUnitType = pszUnescapedValue;\n                    }\n                    else if( EQUAL(pszRole,\"description\") )\n                    {\n                        poBand->osDescription = pszUnescapedValue;\n                    }\n                    else if( EQUAL(pszRole, \"colorinterp\") )\n                    {\n                        poBand->eBandInterp =\n                            GDALGetColorInterpretationByName(pszUnescapedValue);\n                    }\n                    else\n                    {\n                        if( bIsXML )\n                        {\n                            char *apszMD[2] = { pszUnescapedValue, nullptr };\n                            poBand->oGTiffMDMD.SetMetadata( apszMD, pszDomain );\n                        }\n                        else\n                        {\n                            poBand->oGTiffMDMD.SetMetadataItem(\n                                pszKey,\n                                pszUnescapedValue,\n                                pszDomain );\n                        }\n                    }\n                }\n            }\n            CPLFree( pszUnescapedValue );\n        }\n\n        CPLDestroyXMLNode( psRoot );\n    }\n\n    if( bStreamingIn )\n    {\n        toff_t* panOffsets = nullptr;\n        TIFFGetField( hTIFF,\n                      TIFFIsTiled( hTIFF ) ?\n                      TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                      &panOffsets );\n        if( panOffsets )\n        {\n            int nBlockCount =\n                TIFFIsTiled(hTIFF) ?\n                TIFFNumberOfTiles(hTIFF) : TIFFNumberOfStrips(hTIFF);\n            for( int i = 1; i < nBlockCount; ++i )\n            {\n                if( panOffsets[i] < panOffsets[i-1] )\n                {\n                    oGTiffMDMD.SetMetadataItem( \"UNORDERED_BLOCKS\", \"YES\",\n                                                \"TIFF\");\n                    CPLDebug(\n                        \"GTIFF\",\n                        \"Offset of block %d is lower than previous block. \"\n                        \"Reader must be careful\",\n                        i );\n                    break;\n                }\n            }\n        }\n    }\n\n    if( nCompression == COMPRESSION_JPEG && eAccess == GA_Update )\n    {\n        SetJPEGQualityAndTablesModeFromFile();\n    }\n\n    CPLAssert(m_bReadGeoTransform == bReadGeoTransform);\n    CPLAssert(!bMetadataChanged);\n    bMetadataChanged = false;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                         GetSiblingFiles()                            */\n/************************************************************************/\n\nchar** GTiffDataset::GetSiblingFiles()\n{\n    if( m_bHasGotSiblingFiles )\n    {\n        return oOvManager.GetSiblingFiles();\n    }\n\n    m_bHasGotSiblingFiles = true;\n    const int nMaxFiles =\n        atoi(CPLGetConfigOption(\"GDAL_READDIR_LIMIT_ON_OPEN\", \"1000\"));\n    char** papszSiblingFiles =\n        VSIReadDirEx(CPLGetDirname(osFilename), nMaxFiles);\n    if( nMaxFiles > 0 && CSLCount(papszSiblingFiles) > nMaxFiles )\n    {\n        CPLDebug(\"GTiff\", \"GDAL_READDIR_LIMIT_ON_OPEN reached on %s\",\n                 CPLGetDirname(osFilename));\n        CSLDestroy(papszSiblingFiles);\n        papszSiblingFiles = nullptr;\n    }\n    oOvManager.TransferSiblingFiles( papszSiblingFiles );\n\n    return papszSiblingFiles;\n}\n\n/************************************************************************/\n/*                   IdentifyAuthorizedGeoreferencingSources()          */\n/************************************************************************/\n\nvoid GTiffDataset::IdentifyAuthorizedGeoreferencingSources()\n{\n    if( m_bHasIdentifiedAuthorizedGeoreferencingSources )\n        return;\n    m_bHasIdentifiedAuthorizedGeoreferencingSources = true;\n    CPLString osGeorefSources = CSLFetchNameValueDef( papszOpenOptions,\n        \"GEOREF_SOURCES\",\n        CPLGetConfigOption(\"GDAL_GEOREF_SOURCES\",\n                           \"PAM,INTERNAL,TABFILE,WORLDFILE\") );\n    char** papszTokens = CSLTokenizeString2(osGeorefSources, \",\", 0);\n    m_nPAMGeorefSrcIndex = CSLFindString(papszTokens, \"PAM\");\n    m_nINTERNALGeorefSrcIndex = CSLFindString(papszTokens, \"INTERNAL\");\n    m_nTABFILEGeorefSrcIndex = CSLFindString(papszTokens, \"TABFILE\");\n    m_nWORLDFILEGeorefSrcIndex = CSLFindString(papszTokens, \"WORLDFILE\");\n    CSLDestroy(papszTokens);\n}\n\n/************************************************************************/\n/*                     LoadGeoreferencingAndPamIfNeeded()               */\n/************************************************************************/\n\nvoid GTiffDataset::LoadGeoreferencingAndPamIfNeeded()\n\n{\n    if( !m_bReadGeoTransform && !m_bLoadPam )\n        return;\n\n    IdentifyAuthorizedGeoreferencingSources();\n\n/* -------------------------------------------------------------------- */\n/*      Get the transform or gcps from the GeoTIFF file.                */\n/* -------------------------------------------------------------------- */\n    if( m_bReadGeoTransform )\n    {\n        m_bReadGeoTransform = false;\n\n        if( !SetDirectory() )\n            return;\n\n        char *pszTabWKT = nullptr;\n        double *padfTiePoints = nullptr;\n        double *padfScale = nullptr;\n        double *padfMatrix = nullptr;\n        uint16 nCount = 0;\n        bool bPixelIsPoint = false;\n        short nRasterType = 0;\n        bool bPointGeoIgnore = false;\n\n        std::set<int> aoSetPriorities;\n        if( m_nINTERNALGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nINTERNALGeorefSrcIndex);\n        if( m_nTABFILEGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nTABFILEGeorefSrcIndex);\n        if( m_nWORLDFILEGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nWORLDFILEGeorefSrcIndex);\n        std::set<int>::iterator oIter = aoSetPriorities.begin();\n        for( ; oIter != aoSetPriorities.end(); ++oIter )\n        {\n            int nIndex = *oIter;\n            if( m_nINTERNALGeorefSrcIndex == nIndex )\n            {\n                GTIF *psGTIF = GTiffDatasetGTIFNew( hTIFF );  // How expensive this is?\n\n                if( psGTIF )\n                {\n                    if( GDALGTIFKeyGetSHORT(psGTIF, GTRasterTypeGeoKey,\n                                            &nRasterType, 0, 1 ) == 1\n                        && nRasterType ==\n                           static_cast<short>(RasterPixelIsPoint) )\n                    {\n                        bPixelIsPoint = true;\n                        bPointGeoIgnore =\n                            CPLTestBool(\n                                CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                                   \"FALSE\") );\n                    }\n\n                    GTIFFree( psGTIF );\n                }\n\n                adfGeoTransform[0] = 0.0;\n                adfGeoTransform[1] = 1.0;\n                adfGeoTransform[2] = 0.0;\n                adfGeoTransform[3] = 0.0;\n                adfGeoTransform[4] = 0.0;\n                adfGeoTransform[5] = 1.0;\n\n                uint16 nCountScale = 0;\n                if( TIFFGetField(hTIFF, TIFFTAG_GEOPIXELSCALE,\n                                 &nCountScale, &padfScale )\n                    && nCountScale >= 2\n                    && padfScale[0] != 0.0 && padfScale[1] != 0.0 )\n                {\n                    adfGeoTransform[1] = padfScale[0];\n                    if( padfScale[1] < 0 )\n                    {\n                        const char* pszOptionVal =\n                            CPLGetConfigOption(\"GTIFF_HONOUR_NEGATIVE_SCALEY\",\n                                               nullptr);\n                        if( pszOptionVal == nullptr )\n                        {\n                            CPLError(CE_Warning, CPLE_AppDefined,\n                                \"File with negative value for ScaleY in \"\n                                \"GeoPixelScale tag. This is rather \"\n                                \"unusual. GDAL, contrary to the GeoTIFF \"\n                                \"specification, assumes that the file \"\n                                \"was intended to be north-up, and will \"\n                                \"treat this file as if ScaleY was \"\n                                \"positive. You may override this behaviour \"\n                                \"by setting the GTIFF_HONOUR_NEGATIVE_SCALEY \"\n                                \"configuration option to YES\");\n                            adfGeoTransform[5] = padfScale[1];\n                        }\n                        else if( CPLTestBool(pszOptionVal) )\n                        {\n                            adfGeoTransform[5] = -padfScale[1];\n                        }\n                        else\n                        {\n                            adfGeoTransform[5] = padfScale[1];\n                        }\n                    }\n                    else\n                    {\n                        adfGeoTransform[5] = -padfScale[1];\n                    }\n\n                    if( TIFFGetField(hTIFF, TIFFTAG_GEOTIEPOINTS,\n                                     &nCount, &padfTiePoints )\n                        && nCount >= 6 )\n                    {\n                        adfGeoTransform[0] =\n                            padfTiePoints[3] -\n                            padfTiePoints[0] * adfGeoTransform[1];\n                        adfGeoTransform[3] =\n                            padfTiePoints[4] -\n                            padfTiePoints[1] * adfGeoTransform[5];\n\n                        if( bPixelIsPoint && !bPointGeoIgnore )\n                        {\n                            adfGeoTransform[0] -=\n                                (adfGeoTransform[1] * 0.5 +\n                                 adfGeoTransform[2] * 0.5);\n                            adfGeoTransform[3] -=\n                                (adfGeoTransform[4] * 0.5 +\n                                 adfGeoTransform[5] * 0.5);\n                        }\n\n                        bGeoTransformValid = true;\n                        m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                        if( nCountScale >= 3 && GetRasterCount() == 1 &&\n                            (padfScale[2] != 0.0 ||\n                             padfTiePoints[2] != 0.0 ||\n                             padfTiePoints[5] != 0.0) )\n                        {\n                            LookForProjection();\n                            if( pszProjection && HasVerticalCS(pszProjection) )\n                            {\n                                /* modelTiePointTag = (pixel, line, z0, X, Y, Z0) */\n                                /* thus Z(some_point) = (z(some_point) - z0) * scaleZ + Z0 */\n                                /* equivalently written as */\n                                /* Z(some_point) = z(some_point) * scaleZ + offsetZ with */\n                                /* offsetZ = - z0 * scaleZ + Z0 */\n                                double dfScale = padfScale[2];\n                                double dfOffset =\n                                    -padfTiePoints[2] * dfScale + padfTiePoints[5];\n                                GTiffRasterBand* poBand =\n                                    cpl::down_cast<GTiffRasterBand*>(GetRasterBand(1));\n                                poBand->bHaveOffsetScale = true;\n                                poBand->dfScale = dfScale;\n                                poBand->dfOffset = dfOffset;\n                            }\n                        }\n                    }\n                }\n\n                else if( TIFFGetField(hTIFF, TIFFTAG_GEOTRANSMATRIX,\n                                      &nCount, &padfMatrix )\n                        && nCount == 16 )\n                {\n                    adfGeoTransform[0] = padfMatrix[3];\n                    adfGeoTransform[1] = padfMatrix[0];\n                    adfGeoTransform[2] = padfMatrix[1];\n                    adfGeoTransform[3] = padfMatrix[7];\n                    adfGeoTransform[4] = padfMatrix[4];\n                    adfGeoTransform[5] = padfMatrix[5];\n\n                    if( bPixelIsPoint && !bPointGeoIgnore )\n                    {\n                        adfGeoTransform[0] -=\n                            adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                        adfGeoTransform[3] -=\n                            adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n                    }\n\n                    bGeoTransformValid = true;\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                }\n                if( bGeoTransformValid )\n                    break;\n            }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise try looking for a .tab, .tfw, .tifw or .wld file.     */\n/* -------------------------------------------------------------------- */\n            if( m_nTABFILEGeorefSrcIndex == nIndex )\n            {\n                char* pszGeorefFilename = nullptr;\n\n                char** papszSiblingFiles = GetSiblingFiles();\n\n                // Begin with .tab since it can also have projection info.\n                const int bTabFileOK =\n                    GDALReadTabFile2( osFilename, adfGeoTransform,\n                                        &pszTabWKT, &nGCPCount, &pasGCPList,\n                                        papszSiblingFiles, &pszGeorefFilename );\n\n                if( bTabFileOK )\n                {\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                    // if( pszTabWKT )\n                    // {\n                    //     m_nProjectionGeorefSrcIndex = nIndex;\n                    // }\n                    if( nGCPCount == 0 )\n                    {\n                        bGeoTransformValid = true;\n                    }\n                }\n\n                if( pszGeorefFilename )\n                {\n                    osGeorefFilename = pszGeorefFilename;\n                    CPLFree(pszGeorefFilename);\n                }\n                if( bGeoTransformValid )\n                    break;\n            }\n\n            if( m_nWORLDFILEGeorefSrcIndex == nIndex )\n            {\n                char* pszGeorefFilename = nullptr;\n\n                char** papszSiblingFiles = GetSiblingFiles();\n\n                bGeoTransformValid = CPL_TO_BOOL( GDALReadWorldFile2(\n                                osFilename, nullptr, adfGeoTransform,\n                                papszSiblingFiles, &pszGeorefFilename) );\n\n                if( !bGeoTransformValid )\n                {\n                    bGeoTransformValid =\n                        CPL_TO_BOOL( GDALReadWorldFile2(\n                            osFilename, \"wld\", adfGeoTransform,\n                            papszSiblingFiles, &pszGeorefFilename ) );\n                }\n                if( bGeoTransformValid )\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                if( pszGeorefFilename )\n                {\n                    osGeorefFilename = pszGeorefFilename;\n                    CPLFree(pszGeorefFilename);\n                }\n                if( bGeoTransformValid )\n                    break;\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Check for GCPs.                                                 */\n/* -------------------------------------------------------------------- */\n        if( m_nINTERNALGeorefSrcIndex >= 0 &&\n            TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && !bGeoTransformValid )\n        {\n            if( nGCPCount > 0 )\n            {\n                GDALDeinitGCPs( nGCPCount, pasGCPList );\n                CPLFree( pasGCPList );\n            }\n            nGCPCount = nCount / 6;\n            pasGCPList =\n                static_cast<GDAL_GCP *>(CPLCalloc(sizeof(GDAL_GCP), nGCPCount));\n\n            for( int iGCP = 0; iGCP < nGCPCount; ++iGCP )\n            {\n                char szID[32] = {};\n\n                snprintf( szID, sizeof(szID), \"%d\", iGCP + 1 );\n                pasGCPList[iGCP].pszId = CPLStrdup( szID );\n                pasGCPList[iGCP].pszInfo = CPLStrdup(\"\");\n                pasGCPList[iGCP].dfGCPPixel = padfTiePoints[iGCP*6+0];\n                pasGCPList[iGCP].dfGCPLine = padfTiePoints[iGCP*6+1];\n                pasGCPList[iGCP].dfGCPX = padfTiePoints[iGCP*6+3];\n                pasGCPList[iGCP].dfGCPY = padfTiePoints[iGCP*6+4];\n                pasGCPList[iGCP].dfGCPZ = padfTiePoints[iGCP*6+5];\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    pasGCPList[iGCP].dfGCPPixel -= 0.5;\n                    pasGCPList[iGCP].dfGCPLine -= 0.5;\n                }\n            }\n            m_nGeoTransformGeorefSrcIndex = m_nINTERNALGeorefSrcIndex;\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Did we find a tab file?  If so we will use its coordinate       */\n/*      system and give it precedence.                                  */\n/* -------------------------------------------------------------------- */\n        if( pszTabWKT != nullptr\n            && (pszProjection == nullptr || pszProjection[0] == '\\0') )\n        {\n            CPLFree( pszProjection );\n            pszProjection = pszTabWKT;\n            pszTabWKT = nullptr;\n            bLookedForProjection = true;\n        }\n\n        CPLFree( pszTabWKT );\n    }\n\n    if( m_bLoadPam && m_nPAMGeorefSrcIndex >= 0 )\n    {\n/* -------------------------------------------------------------------- */\n/*      Initialize any PAM information.                                 */\n/* -------------------------------------------------------------------- */\n        CPLAssert(!bColorProfileMetadataChanged);\n        CPLAssert(!bMetadataChanged);\n        CPLAssert(!bGeoTIFFInfoChanged);\n        CPLAssert(!bNoDataChanged);\n\n        // We must absolutely unset m_bLoadPam now, otherwise calling\n        // GetFileList() on a .tif with a .aux will result in an (almost)\n        // endless sequence of calls.\n        m_bLoadPam = false;\n\n        TryLoadXML( GetSiblingFiles() );\n        ApplyPamInfo();\n\n        bColorProfileMetadataChanged = false;\n        bMetadataChanged = false;\n        bGeoTIFFInfoChanged = false;\n        bNoDataChanged = false;\n\n        for( int i = 1; i <= nBands; ++i )\n        {\n            GTiffRasterBand* poBand =\n                cpl::down_cast<GTiffRasterBand *>(GetRasterBand(i));\n\n            /* Load scale, offset and unittype from PAM if available */\n            if( !poBand->bHaveOffsetScale )\n            {\n                int nHaveOffsetScale = FALSE;\n                poBand->dfScale =\n                    poBand->GDALPamRasterBand::GetScale( &nHaveOffsetScale );\n                poBand->bHaveOffsetScale = CPL_TO_BOOL(nHaveOffsetScale);\n                poBand->dfOffset = poBand->GDALPamRasterBand::GetOffset();\n            }\n            if( poBand->osUnitType.empty() )\n            {\n                const char* pszUnitType =\n                    poBand->GDALPamRasterBand::GetUnitType();\n                if( pszUnitType )\n                    poBand->osUnitType = pszUnitType;\n            }\n            if( poBand->osDescription.empty() )\n                poBand->osDescription =\n                    poBand->GDALPamRasterBand::GetDescription();\n\n            GDALColorInterp ePAMColorInterp =\n                poBand->GDALPamRasterBand::GetColorInterpretation();\n            if( ePAMColorInterp != GCI_Undefined )\n                poBand->eBandInterp = ePAMColorInterp;\n        }\n    }\n    m_bLoadPam = false;\n}\n\n/************************************************************************/\n/*                          ScanDirectories()                           */\n/*                                                                      */\n/*      Scan through all the directories finding overviews, masks       */\n/*      and subdatasets.                                                */\n/************************************************************************/\n\nvoid GTiffDataset::ScanDirectories()\n\n{\n/* -------------------------------------------------------------------- */\n/*      We only scan once.  We do not scan for non-base datasets.       */\n/* -------------------------------------------------------------------- */\n    if( !bScanDeferred )\n        return;\n\n    bScanDeferred = false;\n\n    if( !bBase )\n        return;\n\n    if( TIFFLastDirectory( hTIFF ) )\n        return;\n\n    CPLDebug( \"GTiff\", \"ScanDirectories()\" );\n\n/* ==================================================================== */\n/*      Scan all directories.                                           */\n/* ==================================================================== */\n    CPLStringList aosSubdatasets;\n    int iDirIndex = 0;\n\n    FlushDirectory();\n    while( !TIFFLastDirectory( hTIFF )\n           && (iDirIndex == 0 || TIFFReadDirectory( hTIFF ) != 0) )\n    {\n        // Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if !defined(SUPPORTS_MORE_THAN_32768_DIRECTORIES)\n        if( iDirIndex == 32768 )\n            break;\n#endif\n        toff_t nThisDir = TIFFCurrentDirOffset(hTIFF);\n        uint32 nSubType = 0;\n\n        *ppoActiveDSRef = nullptr; // Our directory no longer matches this ds.\n\n        ++iDirIndex;\n\n        if( !TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n            nSubType = 0;\n\n        /* Embedded overview of the main image */\n        if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n            (nSubType & FILETYPE_MASK) == 0 &&\n            iDirIndex != 1 &&\n            nOverviewCount < 30 /* to avoid DoS */ )\n        {\n            GTiffDataset *poODS = new GTiffDataset();\n            poODS->osFilename = osFilename;\n            if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, false,\n                                   eAccess ) != CE_None\n                || poODS->GetRasterCount() != GetRasterCount() )\n            {\n                delete poODS;\n            }\n            else\n            {\n                CPLDebug( \"GTiff\", \"Opened %dx%d overview.\",\n                          poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                ++nOverviewCount;\n                papoOverviewDS = static_cast<GTiffDataset **>(\n                    CPLRealloc(papoOverviewDS,\n                               nOverviewCount * (sizeof(void*))) );\n                papoOverviewDS[nOverviewCount-1] = poODS;\n                poODS->poBaseDS = this;\n                poODS->bIsOverview_ = true;\n            }\n        }\n        // Embedded mask of the main image.\n        else if( (nSubType & FILETYPE_MASK) != 0 &&\n                 (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                 iDirIndex != 1 &&\n                 poMaskDS == nullptr )\n        {\n            poMaskDS = new GTiffDataset();\n            poMaskDS->osFilename = osFilename;\n\n            // The TIFF6 specification - page 37 - only allows 1\n            // SamplesPerPixel and 1 BitsPerSample Here we support either 1 or\n            // 8 bit per sample and we support either 1 sample per pixel or as\n            // many samples as in the main image We don't check the value of\n            // the PhotometricInterpretation tag, which should be set to\n            // \"Transparency mask\" (4) according to the specification (page\n            // 36).  However, the TIFF6 specification allows image masks to\n            // have a higher resolution than the main image, what we don't\n            // support here.\n\n            if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir,\n                                      false, eAccess ) != CE_None\n                || poMaskDS->GetRasterCount() == 0\n                || !(poMaskDS->GetRasterCount() == 1\n                     || poMaskDS->GetRasterCount() == GetRasterCount())\n                || poMaskDS->GetRasterXSize() != GetRasterXSize()\n                || poMaskDS->GetRasterYSize() != GetRasterYSize()\n                || poMaskDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n            {\n                delete poMaskDS;\n                poMaskDS = nullptr;\n            }\n            else\n            {\n                CPLDebug( \"GTiff\", \"Opened band mask.\");\n                poMaskDS->poBaseDS = this;\n\n                poMaskDS->bPromoteTo8Bits =\n                    CPLTestBool(\n                        CPLGetConfigOption( \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                            \"YES\" ) );\n            }\n        }\n\n        // Embedded mask of an overview.  The TIFF6 specification allows the\n        // combination of the FILETYPE_xxxx masks.\n        else if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                 (nSubType & FILETYPE_MASK) != 0 &&\n                 iDirIndex != 1 )\n        {\n            GTiffDataset* poDS = new GTiffDataset();\n            poDS->osFilename = osFilename;\n            if( poDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE,\n                                  eAccess ) != CE_None\n                || poDS->GetRasterCount() == 0\n                || poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n            {\n                delete poDS;\n            }\n            else\n            {\n                int i = 0;  // Used after for.\n                for( ; i < nOverviewCount; ++i )\n                {\n                    if( cpl::down_cast<GTiffDataset *>(GDALDataset::FromHandle(\n                           papoOverviewDS[i]))->poMaskDS == nullptr &&\n                        poDS->GetRasterXSize() ==\n                        papoOverviewDS[i]->GetRasterXSize() &&\n                        poDS->GetRasterYSize() ==\n                        papoOverviewDS[i]->GetRasterYSize() &&\n                        (poDS->GetRasterCount() == 1 ||\n                         poDS->GetRasterCount() == GetRasterCount()))\n                    {\n                        CPLDebug(\n                            \"GTiff\", \"Opened band mask for %dx%d overview.\",\n                            poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                        cpl::down_cast<GTiffDataset*>(GDALDataset::FromHandle(\n                            papoOverviewDS[i]))->\n                            poMaskDS = poDS;\n                        poDS->bPromoteTo8Bits =\n                            CPLTestBool(\n                                CPLGetConfigOption(\n                                    \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                    \"YES\" ) );\n                        poDS->poBaseDS = this;\n                        break;\n                    }\n                }\n                if( i == nOverviewCount )\n                {\n                    delete poDS;\n                }\n            }\n        }\n        else if( nSubType == 0 || nSubType == FILETYPE_PAGE )\n        {\n            uint32 nXSize = 0;\n            uint32 nYSize = 0;\n\n            TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n            TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n            if( nXSize > INT_MAX || nYSize > INT_MAX )\n            {\n                CPLDebug(\"GTiff\",\n                         \"Skipping directory with too large image: %u x %u\",\n                         nXSize, nYSize);\n            }\n            else\n            {\n                uint16 nSPP = 0;\n                if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP ) )\n                    nSPP = 1;\n\n                CPLString osName, osDesc;\n                osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\",\n                            iDirIndex, iDirIndex, osFilename.c_str() );\n                osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\",\n                            iDirIndex, iDirIndex,\n                            static_cast<int>(nXSize),\n                            static_cast<int>(nYSize),\n                            nSPP );\n\n                aosSubdatasets.AddString(osName);\n                aosSubdatasets.AddString(osDesc);\n            }\n        }\n\n        // Make sure we are stepping from the expected directory regardless\n        // of churn done processing the above.\n        if( TIFFCurrentDirOffset(hTIFF) != nThisDir )\n            TIFFSetSubDirectory( hTIFF, nThisDir );\n        *ppoActiveDSRef = nullptr;\n    }\n\n    // Nasty hack. Probably something that should be fixed in libtiff\n    // In case the last directory cycles to the first directory, we have\n    // TIFFCurrentDirOffset(hTIFF) == nDirOffset, but the TIFFReadDirectory()\n    // hasn't done its job, so SetDirectory() would be confused and think it\n    // has nothing to do. To avoid that reset to a fake offset before calling\n    // SetDirectory()\n    // This can also occur if the last directory cycles to the IFD of the\n    // mask dataset and we activate this mask dataset.\n    // So always completely reset\n    TIFFSetSubDirectory( hTIFF, 0 );\n    *ppoActiveDSRef = nullptr;\n    CPL_IGNORE_RET_VAL( SetDirectory() );\n\n    // If we have a mask for the main image, loop over the overviews, and if\n    // they have a mask, let's set this mask as an overview of the main mask.\n    if( poMaskDS != nullptr )\n    {\n        for( int i = 0; i < nOverviewCount; ++i )\n        {\n            if( cpl::down_cast<GTiffDataset *>(GDALDataset::FromHandle(\n                   papoOverviewDS[i]))->poMaskDS != nullptr)\n            {\n                ++poMaskDS->nOverviewCount;\n                poMaskDS->papoOverviewDS = static_cast<GTiffDataset **>(\n                    CPLRealloc(poMaskDS->papoOverviewDS,\n                               poMaskDS->nOverviewCount * (sizeof(void*))) );\n                poMaskDS->papoOverviewDS[poMaskDS->nOverviewCount-1] =\n                    cpl::down_cast<GTiffDataset*>(GDALDataset::FromHandle(\n                        papoOverviewDS[i]))->poMaskDS;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n    if( aosSubdatasets.size() > 2 )\n    {\n        oGTiffMDMD.SetMetadata( aosSubdatasets.List(), \"SUBDATASETS\" );\n    }\n}\n\nstatic int GTiffGetLZMAPreset(char** papszOptions)\n{\n    int nLZMAPreset = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"LZMA_PRESET\" );\n    if( pszValue != nullptr )\n    {\n        nLZMAPreset = atoi( pszValue );\n        if( !(nLZMAPreset >= 0 && nLZMAPreset <= 9) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"LZMA_PRESET=%s value not recognised, ignoring.\",\n                      pszValue );\n            nLZMAPreset = -1;\n        }\n    }\n    return nLZMAPreset;\n}\n\nstatic int GTiffGetZSTDPreset(char** papszOptions)\n{\n    int nZSTDLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"ZSTD_LEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nZSTDLevel = atoi( pszValue );\n        if( !(nZSTDLevel >= 1 && nZSTDLevel <= 22) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"ZSTD_LEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nZSTDLevel = -1;\n        }\n    }\n    return nZSTDLevel;\n}\n\n#if HAVE_LERC\nstatic double GTiffGetLERCMaxZError(char** papszOptions)\n{\n    return CPLAtof(CSLFetchNameValueDef( papszOptions, \"MAX_Z_ERROR\", \"0.0\") );\n}\n#endif\n\nstatic int GTiffGetWebPLevel(char** papszOptions)\n{\n    int nWebPLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"WEBP_LEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nWebPLevel = atoi( pszValue );\n        if( !(nWebPLevel >= 1 && nWebPLevel <= 100) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"WEBP_LEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nWebPLevel = -1;\n        }\n    }\n    return nWebPLevel;\n}\n\nstatic bool GTiffGetWebPLossless(char** papszOptions)\n{\n    return CPLFetchBool( papszOptions, \"WEBP_LOSSLESS\", false);\n}\n\nstatic int GTiffGetZLevel(char** papszOptions)\n{\n    int nZLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"ZLEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nZLevel = atoi( pszValue );\n        if( nZLevel < 1 || nZLevel > 9 )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"ZLEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nZLevel = -1;\n        }\n    }\n    return nZLevel;\n}\n\nstatic int GTiffGetJpegQuality(char** papszOptions)\n{\n    int nJpegQuality = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"JPEG_QUALITY\" );\n    if( pszValue != nullptr )\n    {\n        nJpegQuality = atoi( pszValue );\n        if( nJpegQuality < 1 || nJpegQuality > 100 )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"JPEG_QUALITY=%s value not recognised, ignoring.\",\n                      pszValue );\n            nJpegQuality = -1;\n        }\n    }\n    return nJpegQuality;\n}\n\nstatic int GTiffGetJpegTablesMode(char** papszOptions)\n{\n    return atoi(CSLFetchNameValueDef( papszOptions, \"JPEGTABLESMODE\",\n                                      CPLSPrintf(\"%d\",\n                                                knGTIFFJpegTablesModeDefault)));\n}\n\n/************************************************************************/\n/*                        GetDiscardLsbOption()                         */\n/************************************************************************/\n\nvoid GTiffDataset::GetDiscardLsbOption(char** papszOptions)\n{\n    const char* pszBits = CSLFetchNameValue( papszOptions, \"DISCARD_LSB\" );\n    if( pszBits == nullptr)\n        return;\n\n    if( nPhotometric == PHOTOMETRIC_PALETTE )\n    {\n        CPLError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored on a paletted image\");\n        return;\n    }\n    if( !(nBitsPerSample == 8 || nBitsPerSample == 16 || nBitsPerSample == 32) )\n    {\n        CPLError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored on non 8, 16 or 32 bits integer images\");\n        return;\n    }\n\n    char** papszTokens = CSLTokenizeString2( pszBits, \",\", 0 );\n    if( CSLCount(papszTokens) == 1 )\n    {\n        bHasDiscardedLsb = true;\n        for( int i = 0; i < nBands; ++i )\n        {\n            int nBits = atoi(papszTokens[0]);\n            anMaskLsb.push_back(~((1 << nBits)-1));\n            if( nBits > 1 )\n                anOffsetLsb.push_back(1 << (nBits - 1));\n            else\n                anOffsetLsb.push_back(0);\n        }\n    }\n    else if( CSLCount(papszTokens) == nBands )\n    {\n        bHasDiscardedLsb = true;\n        for( int i = 0; i < nBands; ++i )\n        {\n            int nBits = atoi(papszTokens[i]);\n            anMaskLsb.push_back(~((1 << nBits)-1));\n            if( nBits > 1 )\n                anOffsetLsb.push_back(1 << (nBits - 1));\n            else\n                anOffsetLsb.push_back(0);\n        }\n    }\n    else\n    {\n        CPLError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored: wrong number of components\");\n    }\n    CSLDestroy(papszTokens);\n}\n\n/************************************************************************/\n/*                            GTiffCreate()                             */\n/*                                                                      */\n/*      Shared functionality between GTiffDataset::Create() and         */\n/*      GTiffCreateCopy() for creating TIFF file based on a set of      */\n/*      options and a configuration.                                    */\n/************************************************************************/\n\nTIFF *GTiffDataset::CreateLL( const char * pszFilename,\n                              int nXSize, int nYSize, int l_nBands,\n                              GDALDataType eType,\n                              double dfExtraSpaceForOverviews,\n                              char **papszParmList,\n                              VSILFILE** pfpL,\n                              CPLString& l_osTmpFilename )\n\n{\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Blow on a few errors.                                           */\n/* -------------------------------------------------------------------- */\n    if( nXSize < 1 || nYSize < 1 || l_nBands < 1 )\n    {\n        CPLError(\n            CE_Failure, CPLE_AppDefined,\n            \"Attempt to create %dx%dx%d TIFF file, but width, height and bands\"\n            \"must be positive.\",\n            nXSize, nYSize, l_nBands );\n\n        return nullptr;\n    }\n\n    if( l_nBands > 65535 )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Attempt to create %dx%dx%d TIFF file, but bands \"\n                  \"must be lesser or equal to 65535.\",\n                  nXSize, nYSize, l_nBands );\n\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Setup values based on options.                                  */\n/* -------------------------------------------------------------------- */\n    const char *pszProfile = CSLFetchNameValue(papszParmList, \"PROFILE\");\n    if( pszProfile == nullptr )\n        pszProfile = szPROFILE_GDALGeoTIFF;\n\n    const bool bTiled = CPLFetchBool( papszParmList, \"TILED\", false );\n\n    int l_nBlockXSize = 0;\n    const char *pszValue = CSLFetchNameValue(papszParmList, \"BLOCKXSIZE\");\n    if( pszValue != nullptr )\n        l_nBlockXSize = atoi( pszValue );\n\n    int l_nBlockYSize = 0;\n    pszValue = CSLFetchNameValue(papszParmList, \"BLOCKYSIZE\");\n    if( pszValue != nullptr )\n        l_nBlockYSize = atoi( pszValue );\n\n    int nPlanar = 0;\n    pszValue = CSLFetchNameValue(papszParmList, \"INTERLEAVE\");\n    if( pszValue != nullptr )\n    {\n        if( EQUAL( pszValue, \"PIXEL\" ) )\n            nPlanar = PLANARCONFIG_CONTIG;\n        else if( EQUAL( pszValue, \"BAND\" ) )\n        {\n            nPlanar = PLANARCONFIG_SEPARATE;\n        }\n        else\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"INTERLEAVE=%s unsupported, value must be PIXEL or BAND.\",\n                      pszValue );\n            return nullptr;\n        }\n    }\n    else\n    {\n        nPlanar = PLANARCONFIG_CONTIG;\n    }\n\n    int l_nCompression = COMPRESSION_NONE;\n    pszValue = CSLFetchNameValue( papszParmList, \"COMPRESS\" );\n    if( pszValue != nullptr )\n    {\n        l_nCompression = GTIFFGetCompressionMethod(pszValue, \"COMPRESS\");\n        if( l_nCompression < 0 )\n            return nullptr;\n    }\n\n    int nPredictor = PREDICTOR_NONE;\n    pszValue = CSLFetchNameValue( papszParmList, \"PREDICTOR\" );\n    if( pszValue != nullptr )\n        nPredictor = atoi( pszValue );\n\n    const int l_nZLevel = GTiffGetZLevel(papszParmList);\n    const int l_nLZMAPreset = GTiffGetLZMAPreset(papszParmList);\n    const int l_nZSTDLevel = GTiffGetZSTDPreset(papszParmList);\n    const int l_nWebPLevel = GTiffGetWebPLevel(papszParmList);\n    const bool l_bWebPLossless = GTiffGetWebPLossless(papszParmList);\n    const int l_nJpegQuality = GTiffGetJpegQuality(papszParmList);\n    const int l_nJpegTablesMode = GTiffGetJpegTablesMode(papszParmList);\n#if HAVE_LERC\n    const double l_dfMaxZError = GTiffGetLERCMaxZError(papszParmList);\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Streaming related code                                          */\n/* -------------------------------------------------------------------- */\n    const CPLString osOriFilename(pszFilename);\n    bool bStreaming =\n        strcmp(pszFilename, \"/vsistdout/\") == 0 ||\n        CPLFetchBool(papszParmList, \"STREAMABLE_OUTPUT\", false);\n#ifdef S_ISFIFO\n    if( !bStreaming )\n    {\n        VSIStatBufL sStat;\n        if( VSIStatExL( pszFilename, &sStat,\n                        VSI_STAT_EXISTS_FLAG | VSI_STAT_NATURE_FLAG) == 0 &&\n             S_ISFIFO(sStat.st_mode) )\n        {\n            bStreaming = true;\n        }\n    }\n#endif\n    if( bStreaming &&\n        !EQUAL( \"NONE\",\n                CSLFetchNameValueDef(papszParmList, \"COMPRESS\", \"NONE\")) )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Streaming only supported to uncompressed TIFF\" );\n        return nullptr;\n    }\n    if( bStreaming && CPLFetchBool(papszParmList, \"SPARSE_OK\", false) )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Streaming not supported with SPARSE_OK\" );\n        return nullptr;\n    }\n    if( bStreaming && CPLFetchBool(papszParmList, \"COPY_SRC_OVERVIEWS\", false) )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Streaming not supported with COPY_SRC_OVERVIEWS\" );\n        return nullptr;\n    }\n    if( bStreaming )\n    {\n        static int nCounter = 0;\n        l_osTmpFilename = CPLSPrintf(\"/vsimem/vsistdout_%d.tif\", ++nCounter);\n        pszFilename = l_osTmpFilename.c_str();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Compute the uncompressed size.                                  */\n/* -------------------------------------------------------------------- */\n    const double dfUncompressedImageSize =\n        nXSize * static_cast<double>(nYSize) * l_nBands *\n        GDALGetDataTypeSizeBytes(eType)\n        + dfExtraSpaceForOverviews;\n\n    if( l_nCompression == COMPRESSION_NONE\n        && dfUncompressedImageSize > 4200000000.0 )\n    {\n#ifndef BIGTIFF_SUPPORT\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"A %d pixels x %d lines x %d bands %s image would be larger than \"\n            \"4GB but this is the largest size a TIFF can be, and BigTIFF \"\n            \"is unavailable.  Creation failed.\",\n            nXSize, nYSize, l_nBands, GDALGetDataTypeName(eType) );\n        return nullptr;\n#endif\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check free space (only for big, non sparse, uncompressed)       */\n/* -------------------------------------------------------------------- */\n    if( l_nCompression == COMPRESSION_NONE &&\n        dfUncompressedImageSize >= 1e9 &&\n        !CPLFetchBool(papszParmList, \"SPARSE_OK\", false) &&\n        osOriFilename != \"/vsistdout/\" &&\n        osOriFilename != \"/vsistdout_redirect/\" &&\n        CPLTestBool(CPLGetConfigOption(\"CHECK_DISK_FREE_SPACE\", \"TRUE\")) )\n    {\n        GIntBig nFreeDiskSpace =\n            VSIGetDiskFreeSpace(CPLGetDirname(pszFilename));\n        if( nFreeDiskSpace >= 0 &&\n            nFreeDiskSpace < dfUncompressedImageSize )\n        {\n            CPLError( CE_Failure, CPLE_FileIO,\n                      \"Free disk space available is \" CPL_FRMT_GIB \" bytes, \"\n                      \"whereas \" CPL_FRMT_GIB \" are at least necessary. \"\n                      \"You can disable this check by defining the \"\n                      \"CHECK_DISK_FREE_SPACE configuration option to FALSE.\",\n                      nFreeDiskSpace,\n                      static_cast<GIntBig>(dfUncompressedImageSize) );\n            return nullptr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should the file be created as a bigtiff file?                   */\n/* -------------------------------------------------------------------- */\n    const char *pszBIGTIFF = CSLFetchNameValue(papszParmList, \"BIGTIFF\");\n\n    if( pszBIGTIFF == nullptr )\n        pszBIGTIFF = \"IF_NEEDED\";\n\n    bool bCreateBigTIFF = false;\n    if( EQUAL(pszBIGTIFF, \"IF_NEEDED\") )\n    {\n        if( l_nCompression == COMPRESSION_NONE\n            && dfUncompressedImageSize > 4200000000.0 )\n            bCreateBigTIFF = true;\n    }\n    else if( EQUAL(pszBIGTIFF, \"IF_SAFER\") )\n    {\n        if( dfUncompressedImageSize > 2000000000.0 )\n            bCreateBigTIFF = true;\n    }\n    else\n    {\n        bCreateBigTIFF = CPLTestBool( pszBIGTIFF );\n        if( !bCreateBigTIFF && l_nCompression == COMPRESSION_NONE &&\n             dfUncompressedImageSize > 4200000000.0 )\n        {\n            CPLError(\n                CE_Failure, CPLE_NotSupported,\n                \"The TIFF file will be larger than 4GB, so BigTIFF is \"\n                \"necessary.  Creation failed.\");\n            return nullptr;\n        }\n    }\n\n#ifndef BIGTIFF_SUPPORT\n    if( bCreateBigTIFF )\n    {\n        CPLError( CE_Warning, CPLE_NotSupported,\n                  \"BigTIFF requested, but GDAL built without BigTIFF \"\n                  \"enabled libtiff, request ignored.\" );\n        bCreateBigTIFF = false;\n    }\n#endif\n\n    if( bCreateBigTIFF )\n        CPLDebug( \"GTiff\", \"File being created as a BigTIFF.\" );\n\n/* -------------------------------------------------------------------- */\n/*      Check if the user wishes a particular endianness                */\n/* -------------------------------------------------------------------- */\n\n    int eEndianness = ENDIANNESS_NATIVE;\n    pszValue = CSLFetchNameValue(papszParmList, \"ENDIANNESS\");\n    if( pszValue == nullptr )\n        pszValue = CPLGetConfigOption( \"GDAL_TIFF_ENDIANNESS\", nullptr );\n    if( pszValue != nullptr )\n    {\n        if( EQUAL(pszValue, \"LITTLE\") )\n        {\n            eEndianness = ENDIANNESS_LITTLE;\n        }\n        else if( EQUAL(pszValue, \"BIG\") )\n        {\n            eEndianness = ENDIANNESS_BIG;\n        }\n        else if( EQUAL(pszValue, \"INVERTED\") )\n        {\n#ifdef CPL_LSB\n            eEndianness = ENDIANNESS_BIG;\n#else\n            eEndianness = ENDIANNESS_LITTLE;\n#endif\n        }\n        else if( !EQUAL(pszValue, \"NATIVE\") )\n        {\n            CPLError(\n                CE_Warning, CPLE_NotSupported,\n                \"ENDIANNESS=%s not supported. Defaulting to NATIVE\", pszValue );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n\n    char szOpeningFlag[5] = {};\n    strcpy(szOpeningFlag, \"w+\");\n    if( bCreateBigTIFF )\n        strcat(szOpeningFlag, \"8\");\n    if( eEndianness == ENDIANNESS_BIG )\n        strcat(szOpeningFlag, \"b\");\n    else if( eEndianness == ENDIANNESS_LITTLE )\n        strcat(szOpeningFlag, \"l\");\n\n    VSILFILE* l_fpL = VSIFOpenL( pszFilename, \"w+b\" );\n    if( l_fpL == nullptr )\n    {\n        CPLError( CE_Failure, CPLE_OpenFailed,\n                  \"Attempt to create new tiff file `%s' failed: %s\",\n                  pszFilename, VSIStrerror(errno) );\n        return nullptr;\n    }\n    TIFF *l_hTIFF = VSI_TIFFOpen( pszFilename, szOpeningFlag, l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        if( CPLGetLastErrorNo() == 0 )\n            CPLError( CE_Failure, CPLE_OpenFailed,\n                      \"Attempt to create new tiff file `%s' \"\n                      \"failed in XTIFFOpen().\",\n                      pszFilename );\n        CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      How many bits per sample?  We have a special case if NBITS      */\n/*      specified for GDT_Byte, GDT_UInt16, GDT_UInt32.                 */\n/* -------------------------------------------------------------------- */\n    int l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n    if( CSLFetchNameValue(papszParmList, \"NBITS\") != nullptr )\n    {\n        int nMinBits = 0;\n        int nMaxBits = 0;\n        l_nBitsPerSample = atoi(CSLFetchNameValue(papszParmList, \"NBITS\"));\n        if( eType == GDT_Byte )\n        {\n            nMinBits = 1;\n            nMaxBits = 8;\n        }\n        else if( eType == GDT_UInt16 )\n        {\n            nMinBits = 9;\n            nMaxBits = 16;\n        }\n        else if( eType == GDT_UInt32 )\n        {\n            nMinBits = 17;\n            nMaxBits = 32;\n        }\n        else if( eType == GDT_Float32 )\n        {\n            if( l_nBitsPerSample != 16 && l_nBitsPerSample != 32 )\n            {\n                CPLError(CE_Warning, CPLE_NotSupported,\n                     \"NBITS is not supported for data type %s\",\n                     GDALGetDataTypeName(eType));\n                l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n            }\n        }\n        else\n        {\n            CPLError(CE_Warning, CPLE_NotSupported,\n                     \"NBITS is not supported for data type %s\",\n                     GDALGetDataTypeName(eType));\n            l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n        }\n\n        if( nMinBits != 0 )\n        {\n            if( l_nBitsPerSample < nMinBits )\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"NBITS=%d is invalid for data type %s. Using NBITS=%d\",\n                         l_nBitsPerSample, GDALGetDataTypeName(eType),\n                         nMinBits);\n                l_nBitsPerSample = nMinBits;\n            }\n            else if( l_nBitsPerSample > nMaxBits )\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"NBITS=%d is invalid for data type %s. Using NBITS=%d\",\n                         l_nBitsPerSample, GDALGetDataTypeName(eType),\n                         nMaxBits);\n                l_nBitsPerSample = nMaxBits;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a custom pixel type (just used for signed byte now). */\n/* -------------------------------------------------------------------- */\n    const char *pszPixelType = CSLFetchNameValue( papszParmList, \"PIXELTYPE\" );\n    if( pszPixelType == nullptr )\n        pszPixelType = \"\";\n\n/* -------------------------------------------------------------------- */\n/*      Setup some standard flags.                                      */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( l_hTIFF, TIFFTAG_IMAGEWIDTH, nXSize );\n    TIFFSetField( l_hTIFF, TIFFTAG_IMAGELENGTH, nYSize );\n    TIFFSetField( l_hTIFF, TIFFTAG_BITSPERSAMPLE, l_nBitsPerSample );\n\n    uint16 l_nSampleFormat = 0;\n    if( (eType == GDT_Byte && EQUAL(pszPixelType,\"SIGNEDBYTE\"))\n        || eType == GDT_Int16 || eType == GDT_Int32 )\n        l_nSampleFormat = SAMPLEFORMAT_INT;\n    else if( eType == GDT_CInt16 || eType == GDT_CInt32 )\n        l_nSampleFormat = SAMPLEFORMAT_COMPLEXINT;\n    else if( eType == GDT_Float32 || eType == GDT_Float64 )\n        l_nSampleFormat = SAMPLEFORMAT_IEEEFP;\n    else if( eType == GDT_CFloat32 || eType == GDT_CFloat64 )\n        l_nSampleFormat = SAMPLEFORMAT_COMPLEXIEEEFP;\n    else\n        l_nSampleFormat = SAMPLEFORMAT_UINT;\n\n    TIFFSetField( l_hTIFF, TIFFTAG_SAMPLEFORMAT, l_nSampleFormat );\n    TIFFSetField( l_hTIFF, TIFFTAG_SAMPLESPERPIXEL, l_nBands );\n    TIFFSetField( l_hTIFF, TIFFTAG_PLANARCONFIG, nPlanar );\n\n/* -------------------------------------------------------------------- */\n/*      Setup Photometric Interpretation. Take this value from the user */\n/*      passed option or guess correct value otherwise.                 */\n/* -------------------------------------------------------------------- */\n    int nSamplesAccountedFor = 1;\n    bool bForceColorTable = false;\n\n    pszValue = CSLFetchNameValue(papszParmList,\"PHOTOMETRIC\");\n    if( pszValue != nullptr )\n    {\n        if( EQUAL( pszValue, \"MINISBLACK\" ) )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                          PHOTOMETRIC_MINISBLACK );\n        else if( EQUAL( pszValue, \"MINISWHITE\" ) )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                          PHOTOMETRIC_MINISWHITE );\n        }\n        else if( EQUAL( pszValue, \"PALETTE\" ))\n        {\n            if( eType == GDT_Byte || eType == GDT_UInt16 )\n            {\n                TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                              PHOTOMETRIC_PALETTE );\n                nSamplesAccountedFor = 1;\n                bForceColorTable = true;\n            }\n            else\n            {\n                CPLError(\n                    CE_Warning, CPLE_AppDefined,\n                    \"PHOTOMETRIC=PALETTE only compatible with Byte or UInt16\" );\n            }\n        }\n        else if( EQUAL( pszValue, \"RGB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"CMYK\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED );\n            nSamplesAccountedFor = 4;\n        }\n        else if( EQUAL( pszValue, \"YCBCR\" ))\n        {\n            // Because of subsampling, setting YCBCR without JPEG compression\n            // leads to a crash currently. Would need to make\n            // GTiffRasterBand::IWriteBlock() aware of subsampling so that it\n            // doesn't overrun buffer size returned by libtiff.\n            if( l_nCompression != COMPRESSION_JPEG )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"Currently, PHOTOMETRIC=YCBCR requires COMPRESS=JPEG\");\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            if( nPlanar == PLANARCONFIG_SEPARATE )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"PHOTOMETRIC=YCBCR requires INTERLEAVE=PIXEL\");\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            // YCBCR strictly requires 3 bands. Not less, not more Issue an\n            // explicit error message as libtiff one is a bit cryptic:\n            // TIFFVStripSize64:Invalid td_samplesperpixel value.\n            if( l_nBands != 3 )\n            {\n                CPLError(\n                    CE_Failure, CPLE_NotSupported,\n                    \"PHOTOMETRIC=YCBCR not supported on a %d-band raster: \"\n                    \"only compatible of a 3-band (RGB) raster\", l_nBands );\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR );\n            nSamplesAccountedFor = 3;\n\n            // Explicitly register the subsampling so that JPEGFixupTags\n            // is a no-op (helps for cloud optimized geotiffs)\n            TIFFSetField( l_hTIFF, TIFFTAG_YCBCRSUBSAMPLING, 2, 2 );\n        }\n        else if( EQUAL( pszValue, \"CIELAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CIELAB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"ICCLAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ICCLAB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"ITULAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ITULAB );\n            nSamplesAccountedFor = 3;\n        }\n        else\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"PHOTOMETRIC=%s value not recognised, ignoring.  \"\n                      \"Set the Photometric Interpretation as MINISBLACK.\",\n                      pszValue );\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        }\n\n        if( l_nBands < nSamplesAccountedFor )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"PHOTOMETRIC=%s value does not correspond to number \"\n                      \"of bands (%d), ignoring.  \"\n                      \"Set the Photometric Interpretation as MINISBLACK.\",\n                      pszValue, l_nBands );\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        }\n    }\n    else\n    {\n        // If image contains 3 or 4 bands and datatype is Byte then we will\n        // assume it is RGB. In all other cases assume it is MINISBLACK.\n        if( l_nBands == 3 && eType == GDT_Byte )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( l_nBands == 4 && eType == GDT_Byte )\n        {\n            uint16 v[1] = {\n                GTiffGetAlphaValue(CSLFetchNameValue(papszParmList, \"ALPHA\"),\n                                   DEFAULT_ALPHA_TYPE)\n            };\n\n            TIFFSetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 4;\n        }\n        else\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n            nSamplesAccountedFor = 1;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If there are extra samples, we need to mark them with an        */\n/*      appropriate extrasamples definition here.                       */\n/* -------------------------------------------------------------------- */\n    if( l_nBands > nSamplesAccountedFor )\n    {\n        const int nExtraSamples = l_nBands - nSamplesAccountedFor;\n\n        uint16 *v = static_cast<uint16 *>(\n            CPLMalloc( sizeof(uint16) * nExtraSamples ) );\n\n        v[0] = GTiffGetAlphaValue( CSLFetchNameValue(papszParmList, \"ALPHA\"),\n                                   EXTRASAMPLE_UNSPECIFIED );\n\n        for( int i = 1; i < nExtraSamples; ++i )\n            v[i] = EXTRASAMPLE_UNSPECIFIED;\n\n        TIFFSetField(l_hTIFF, TIFFTAG_EXTRASAMPLES, nExtraSamples, v );\n\n        CPLFree(v);\n    }\n\n    // Set the ICC color profile.\n    if( !EQUAL(pszProfile,szPROFILE_BASELINE) )\n    {\n        SaveICCProfile(nullptr, l_hTIFF, papszParmList, l_nBitsPerSample);\n    }\n\n    // Set the compression method before asking the default strip size\n    // This is useful when translating to a JPEG-In-TIFF file where\n    // the default strip size is 8 or 16 depending on the photometric value.\n    TIFFSetField( l_hTIFF, TIFFTAG_COMPRESSION, l_nCompression );\n\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        const char* pszCompress =\n            CSLFetchNameValueDef( papszParmList, \"COMPRESS\", \"\" );\n        if( EQUAL(pszCompress , \"LERC_DEFLATE\" ) )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION,\n                        LERC_ADD_COMPRESSION_DEFLATE );\n        }\n        else if( EQUAL(pszCompress, \"LERC_ZSTD\" ) )\n        {\n            if( TIFFSetField( l_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION,\n                            LERC_ADD_COMPRESSION_ZSTD ) != 1 )\n            {\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n        }\n    }\n    // TODO later: take into account LERC version\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Setup tiling/stripping flags.                                   */\n/* -------------------------------------------------------------------- */\n    if( bTiled )\n    {\n        if( l_nBlockXSize == 0 )\n            l_nBlockXSize = 256;\n\n        if( l_nBlockYSize == 0 )\n            l_nBlockYSize = 256;\n\n        if( !TIFFSetField( l_hTIFF, TIFFTAG_TILEWIDTH, l_nBlockXSize ) ||\n            !TIFFSetField( l_hTIFF, TIFFTAG_TILELENGTH, l_nBlockYSize ) )\n        {\n            XTIFFClose(l_hTIFF);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n            return nullptr;\n        }\n    }\n    else\n    {\n        const uint32 l_nRowsPerStrip = std::min(nYSize,\n            l_nBlockYSize == 0\n            ? static_cast<int>(TIFFDefaultStripSize(l_hTIFF,0))\n            : l_nBlockYSize );\n\n        TIFFSetField( l_hTIFF, TIFFTAG_ROWSPERSTRIP, l_nRowsPerStrip );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Set compression related tags.                                   */\n/* -------------------------------------------------------------------- */\n    if( l_nCompression == COMPRESSION_LZW ||\n         l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n         l_nCompression == COMPRESSION_ZSTD )\n        TIFFSetField( l_hTIFF, TIFFTAG_PREDICTOR, nPredictor );\n    if( (l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n         l_nCompression == COMPRESSION_LERC) && l_nZLevel != -1 )\n        TIFFSetField( l_hTIFF, TIFFTAG_ZIPQUALITY, l_nZLevel );\n    if( l_nCompression == COMPRESSION_JPEG && l_nJpegQuality != -1 )\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGQUALITY, l_nJpegQuality );\n    if( l_nCompression == COMPRESSION_LZMA && l_nLZMAPreset != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_LZMAPRESET, l_nLZMAPreset );\n    if( (l_nCompression == COMPRESSION_ZSTD ||\n         l_nCompression == COMPRESSION_LERC) && l_nZSTDLevel != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_ZSTD_LEVEL, l_nZSTDLevel);\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        TIFFSetField( l_hTIFF, TIFFTAG_LERC_MAXZERROR, l_dfMaxZError );\n    }\n#endif\n    if( l_nCompression == COMPRESSION_WEBP && l_nWebPLevel != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LEVEL, l_nWebPLevel);\n    if( l_nCompression == COMPRESSION_WEBP && l_bWebPLossless)\n        TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LOSSLESS, 1);\n\n    if( l_nCompression == COMPRESSION_JPEG )\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGTABLESMODE, l_nJpegTablesMode );\n\n/* -------------------------------------------------------------------- */\n/*      If we forced production of a file with photometric=palette,     */\n/*      we need to push out a default color table.                      */\n/* -------------------------------------------------------------------- */\n    if( bForceColorTable )\n    {\n        const int nColors = eType == GDT_Byte ? 256 : 65536;\n\n        unsigned short *panTRed = static_cast<unsigned short *>(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n        unsigned short *panTGreen = static_cast<unsigned short *>(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n        unsigned short *panTBlue = static_cast<unsigned short *>(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n\n        for( int iColor = 0; iColor < nColors; ++iColor )\n        {\n            if( eType == GDT_Byte )\n            {\n                panTRed[iColor] = static_cast<unsigned short>(257 * iColor);\n                panTGreen[iColor] = static_cast<unsigned short>(257 * iColor);\n                panTBlue[iColor] = static_cast<unsigned short>(257 * iColor);\n            }\n            else\n            {\n                panTRed[iColor] = static_cast<unsigned short>(iColor);\n                panTGreen[iColor] = static_cast<unsigned short>(iColor);\n                panTBlue[iColor] = static_cast<unsigned short>(iColor);\n            }\n        }\n\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP,\n                      panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n\n    // Would perhaps works with libtiff 3.X but didn't bother trying This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n#if defined(BIGTIFF_SUPPORT)\n    if( l_nCompression == COMPRESSION_JPEG &&\n        !STARTS_WITH(pszFilename, szJPEGGTiffDatasetTmpPrefix) &&\n        CPLTestBool(\n            CSLFetchNameValueDef(papszParmList, \"WRITE_JPEGTABLE_TAG\", \"YES\")) )\n    {\n        GTiffWriteJPEGTables( l_hTIFF,\n                              CSLFetchNameValue(papszParmList, \"PHOTOMETRIC\"),\n                              CSLFetchNameValue(papszParmList, \"JPEG_QUALITY\"),\n                              CSLFetchNameValue(papszParmList,\n                                                \"JPEGTABLESMODE\") );\n    }\n#endif\n\n    *pfpL = l_fpL;\n\n    return l_hTIFF;\n}\n\n/************************************************************************/\n/*                      GTiffWriteJPEGTables()                          */\n/*                                                                      */\n/*      Sets the TIFFTAG_JPEGTABLES (and TIFFTAG_REFERENCEBLACKWHITE)   */\n/*      tags immediately, instead of relying on the TIFF JPEG codec     */\n/*      to write them when it starts compressing imagery. This avoids   */\n/*      an IFD rewrite at the end of the file.                          */\n/*      Must be used after having set TIFFTAG_SAMPLESPERPIXEL,          */\n/*      TIFFTAG_BITSPERSAMPLE.                                          */\n/************************************************************************/\n\nvoid GTiffWriteJPEGTables( TIFF* hTIFF,\n                           const char* pszPhotometric,\n                           const char* pszJPEGQuality,\n                           const char* pszJPEGTablesMode )\n{\n    // Would perhaps works with libtiff 3.X but didn't bother trying This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n#if defined(BIGTIFF_SUPPORT)\n    uint16 nBands = 0;\n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL,\n                        &nBands ) )\n        nBands = 1;\n\n    uint16 l_nBitsPerSample = 0;\n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE,\n                        &(l_nBitsPerSample)) )\n        l_nBitsPerSample = 1;\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf(\"%s%p\", szJPEGGTiffDatasetTmpPrefix, hTIFF);\n    VSILFILE* fpTmp = nullptr;\n    CPLString osTmp;\n    char** papszLocalParameters = nullptr;\n    const int nInMemImageWidth = 16;\n    const int nInMemImageHeight = 16;\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\" );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEG_QUALITY\",\n                                            pszJPEGQuality );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"PHOTOMETRIC\", pszPhotometric );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"BLOCKYSIZE\",\n                                            CPLSPrintf(\"%u\", nInMemImageHeight)\n                                          );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"NBITS\",\n                                            CPLSPrintf(\"%u\", l_nBitsPerSample));\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEGTABLESMODE\",\n                                            pszJPEGTablesMode );\n\n    TIFF* hTIFFTmp = GTiffDataset::CreateLL(\n                    osTmpFilenameIn, nInMemImageWidth, nInMemImageHeight,\n                    (nBands <= 4) ? nBands : 1,\n                    (l_nBitsPerSample <= 8) ? GDT_Byte : GDT_UInt16, 0.0,\n                    papszLocalParameters, &fpTmp, osTmp );\n    CSLDestroy(papszLocalParameters);\n    if( hTIFFTmp )\n    {\n        uint16 l_nPhotometric = 0;\n        int nJpegTablesModeIn = 0;\n        TIFFGetField( hTIFFTmp, TIFFTAG_PHOTOMETRIC, &(l_nPhotometric) );\n        TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                        &nJpegTablesModeIn );\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now, reset quality and jpegcolormode.\n        const int l_nJpegQuality = pszJPEGQuality ? atoi(pszJPEGQuality) : 0;\n        if(l_nJpegQuality > 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGQUALITY, l_nJpegQuality);\n        if( l_nPhotometric == PHOTOMETRIC_YCBCR\n            && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGCOLORMODE,\n                            JPEGCOLORMODE_RGB);\n        }\n        if( nJpegTablesModeIn >= 0 )\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                            nJpegTablesModeIn);\n\n        int nBlockSize = nInMemImageWidth * nInMemImageHeight *\n                                        ((nBands <= 4) ? nBands : 1);\n        if( l_nBitsPerSample == 12 )\n            nBlockSize = (nBlockSize * 3) / 2;\n        std::vector<GByte> abyZeroData( nBlockSize, 0 );\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, &abyZeroData[0], nBlockSize);\n\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSize,\n                            &pJPEGTable) )\n            TIFFSetField( hTIFF, TIFFTAG_JPEGTABLES, nJPEGTableSize,\n                            pJPEGTable);\n\n        float *ref = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_REFERENCEBLACKWHITE, &ref) )\n            TIFFSetField(hTIFF, TIFFTAG_REFERENCEBLACKWHITE, ref);\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n    VSIUnlink(osTmpFilenameIn);\n#endif\n}\n\n/************************************************************************/\n/*                            GuessJPEGQuality()                        */\n/*                                                                      */\n/*      Guess JPEG quality from JPEGTABLES tag.                         */\n/************************************************************************/\n\nstatic const GByte* GTIFFFindNextTable( const GByte* paby, GByte byMarker,\n                                        int nLen, int* pnLenTable )\n{\n    for( int i = 0; i + 1 < nLen; )\n    {\n        if( paby[i] != 0xFF )\n            return nullptr;\n        ++i;\n        if( paby[i] == 0xD8 )\n        {\n            ++i;\n            continue;\n        }\n        if( i + 2 >= nLen )\n            return nullptr;\n        int nMarkerLen = paby[i+1] * 256 + paby[i+2];\n        if( i+1+nMarkerLen >= nLen )\n            return nullptr;\n        if( paby[i] == byMarker )\n        {\n            if( pnLenTable ) *pnLenTable = nMarkerLen;\n            return paby + i + 1;\n        }\n        i += 1 + nMarkerLen;\n    }\n    return nullptr;\n}\n\n// We assume that if there are several quantization tables, they are\n// in the same order. Which is a reasonable assumption for updating\n// a file generated by ourselves.\nstatic bool GTIFFQuantizationTablesEqual( const GByte* paby1, int nLen1,\n                                          const GByte* paby2, int nLen2 )\n{\n    bool bFound = false;\n    while( true )\n    {\n        int nLenTable1 = 0;\n        int nLenTable2 = 0;\n        const GByte* paby1New =\n            GTIFFFindNextTable(paby1, 0xDB, nLen1, &nLenTable1);\n        const GByte* paby2New =\n            GTIFFFindNextTable(paby2, 0xDB, nLen2, &nLenTable2);\n        if( paby1New == nullptr && paby2New == nullptr )\n            return bFound;\n        if( paby1New == nullptr || paby2New == nullptr )\n            return false;\n        if( nLenTable1 != nLenTable2 )\n            return false;\n        if( memcmp(paby1New, paby2New, nLenTable1) != 0 )\n            return false;\n        paby1New += nLenTable1;\n        paby2New += nLenTable2;\n        nLen1 -= static_cast<int>(paby1New - paby1);\n        nLen2 -= static_cast<int>(paby2New - paby2);\n        paby1 = paby1New;\n        paby2 = paby2New;\n        bFound = true;\n    }\n}\n\nint GTiffDataset::GuessJPEGQuality( bool& bOutHasQuantizationTable,\n                                    bool& bOutHasHuffmanTable )\n{\n    CPLAssert( nCompression == COMPRESSION_JPEG );\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    if( !TIFFGetField(hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize, &pJPEGTable) )\n    {\n        bOutHasQuantizationTable = false;\n        bOutHasHuffmanTable = false;\n        return -1;\n    }\n\n    bOutHasQuantizationTable =\n        GTIFFFindNextTable( static_cast<const GByte*>(pJPEGTable), 0xDB,\n                            nJPEGTableSize, nullptr) != nullptr;\n    bOutHasHuffmanTable =\n        GTIFFFindNextTable( static_cast<const GByte*>(pJPEGTable), 0xC4,\n                            nJPEGTableSize, nullptr) != nullptr;\n    if( !bOutHasQuantizationTable )\n        return -1;\n\n    char** papszLocalParameters = nullptr;\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\");\n    if( nPhotometric == PHOTOMETRIC_YCBCR )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"YCBCR\");\n    else if( nPhotometric == PHOTOMETRIC_SEPARATED )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"CMYK\");\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"BLOCKYSIZE\", \"16\");\n    if( nBitsPerSample == 12 )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                \"NBITS\", \"12\");\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf( \"/vsimem/gtiffdataset_guess_jpeg_quality_tmp_%p\",\n                            this );\n\n    int nRet = -1;\n    for( int nQuality = 0; nQuality <= 100 && nRet < 0; ++nQuality )\n    {\n        VSILFILE* fpTmp = nullptr;\n        if( nQuality == 0 )\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                   \"JPEG_QUALITY\", \"75\");\n        else\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                \"JPEG_QUALITY\", CPLSPrintf(\"%d\", nQuality));\n\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        CPLString osTmp;\n        TIFF* hTIFFTmp =\n            CreateLL( osTmpFilenameIn, 16, 16, (nBands <= 4) ? nBands : 1,\n                      GetRasterBand(1)->GetRasterDataType(), 0.0,\n                      papszLocalParameters, &fpTmp, osTmp );\n        CPLPopErrorHandler();\n        if( !hTIFFTmp )\n        {\n            break;\n        }\n\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now reset jpegcolormode.\n        if( nPhotometric == PHOTOMETRIC_YCBCR\n            && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n\n        GByte abyZeroData[(16*16*4*3)/2] = {};\n        const int nBlockSize =\n            (16 * 16 * ((nBands <= 4) ? nBands : 1) * nBitsPerSample) / 8;\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, abyZeroData, nBlockSize);\n\n        uint32 nJPEGTableSizeTry = 0;\n        void* pJPEGTableTry = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES,\n                         &nJPEGTableSizeTry, &pJPEGTableTry) )\n        {\n            if( GTIFFQuantizationTablesEqual(\n                   static_cast<GByte *>(pJPEGTable), nJPEGTableSize,\n                   static_cast<GByte *>(pJPEGTableTry), nJPEGTableSizeTry) )\n            {\n                nRet = (nQuality == 0 ) ? 75 : nQuality;\n            }\n        }\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n\n    CSLDestroy(papszLocalParameters);\n    VSIUnlink(osTmpFilenameIn);\n\n    return nRet;\n}\n\n/************************************************************************/\n/*               SetJPEGQualityAndTablesModeFromFile()                  */\n/************************************************************************/\n\nvoid GTiffDataset::SetJPEGQualityAndTablesModeFromFile()\n{\n    bool bHasQuantizationTable = false;\n    bool bHasHuffmanTable = false;\n    int nQuality = GuessJPEGQuality( bHasQuantizationTable,\n                                     bHasHuffmanTable );\n    if( nQuality > 0 )\n    {\n        CPLDebug(\"GTiff\", \"Guessed JPEG quality to be %d\", nQuality);\n        nJpegQuality = nQuality;\n        TIFFSetField( hTIFF, TIFFTAG_JPEGQUALITY, nQuality );\n\n        // This means we will use the quantization tables from the\n        // JpegTables tag.\n        nJpegTablesMode = JPEGTABLESMODE_QUANT;\n    }\n    else\n    {\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( !TIFFGetField( hTIFF, TIFFTAG_JPEGTABLES,\n                            &nJPEGTableSize, &pJPEGTable) )\n        {\n            toff_t *panByteCounts = nullptr;\n            const int nBlockCount =\n                nPlanarConfig == PLANARCONFIG_SEPARATE\n                ? nBlocksPerBand * nBands\n                : nBlocksPerBand;\n            if( TIFFIsTiled( hTIFF ) )\n                TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS,\n                                &panByteCounts );\n            else\n                TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS,\n                                &panByteCounts );\n\n            bool bFoundNonEmptyBlock = false;\n            if( panByteCounts != nullptr )\n            {\n                for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n                {\n                    if( panByteCounts[iBlock] != 0 )\n                    {\n                        bFoundNonEmptyBlock = true;\n                        break;\n                    }\n                }\n            }\n            if( bFoundNonEmptyBlock )\n            {\n                CPLDebug(\"GTiff\", \"Could not guess JPEG quality. \"\n                            \"JPEG tables are missing, so going in \"\n                            \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n                // Write quantization tables in each strile.\n                nJpegTablesMode = 0;\n            }\n        }\n        else\n        {\n            if( bHasQuantizationTable )\n            {\n                // FIXME in libtiff: this is likely going to cause issues\n                // since libtiff will reuse in each strile the number of\n                // the global quantization table, which is invalid.\n                CPLDebug(\n                    \"GTiff\", \"Could not guess JPEG quality although JPEG \"\n                    \"quantization tables are present, so going in \"\n                    \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\" );\n            }\n            else\n            {\n                CPLDebug(\"GTiff\", \"Could not guess JPEG quality since JPEG \"\n                        \"quantization tables are not present, so going in \"\n                        \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n            }\n\n            // Write quantization tables in each strile.\n            nJpegTablesMode = 0;\n        }\n    }\n    if( bHasHuffmanTable )\n    {\n        // If there are Huffman tables in header use them, otherwise\n        // if we use optimized tables, libtiff will currently reuse\n        // the number of the Huffman tables of the header for the\n        // optimized version of each strile, which is illegal.\n        nJpegTablesMode |= JPEGTABLESMODE_HUFF;\n    }\n    if( nJpegTablesMode >= 0 )\n        TIFFSetField( hTIFF, TIFFTAG_JPEGTABLESMODE,\n                        nJpegTablesMode);\n}\n\n/************************************************************************/\n/*                               Create()                               */\n/*                                                                      */\n/*      Create a new GeoTIFF or TIFF file.                              */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::Create( const char * pszFilename,\n                                   int nXSize, int nYSize, int l_nBands,\n                                   GDALDataType eType,\n                                   char **papszParmList )\n\n{\n    VSILFILE* l_fpL = nullptr;\n    CPLString l_osTmpFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Create the underlying TIFF file.                                */\n/* -------------------------------------------------------------------- */\n    TIFF *l_hTIFF = CreateLL(\n        pszFilename,\n        nXSize, nYSize, l_nBands,\n        eType, 0, papszParmList, &l_fpL, l_osTmpFilename );\n    const bool bStreaming = !l_osTmpFilename.empty();\n\n    if( l_hTIFF == nullptr )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Create the new GTiffDataset object.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->hTIFF = l_hTIFF;\n    poDS->fpL = l_fpL;\n    if( bStreaming )\n    {\n        poDS->bStreamingOut = true;\n        poDS->osTmpFilename = l_osTmpFilename;\n        poDS->fpToWrite = VSIFOpenL( pszFilename, \"wb\" );\n        if( poDS->fpToWrite == nullptr )\n        {\n            VSIUnlink(l_osTmpFilename);\n            delete poDS;\n            return nullptr;\n        }\n    }\n    poDS->poActiveDS = poDS;\n    poDS->ppoActiveDSRef = &(poDS->poActiveDS);\n\n    poDS->nRasterXSize = nXSize;\n    poDS->nRasterYSize = nYSize;\n    poDS->eAccess = GA_Update;\n    poDS->bCrystalized = false;\n    poDS->nSamplesPerPixel = static_cast<uint16>(l_nBands);\n    poDS->osFilename = pszFilename;\n\n    // Don't try to load external metadata files (#6597).\n    poDS->bIMDRPCMetadataLoaded = true;\n\n    // Avoid premature crystalization that will cause directory re-writing if\n    // GetProjectionRef() or GetGeoTransform() are called on the newly created\n    // GeoTIFF.\n    poDS->bLookedForProjection = true;\n\n    TIFFGetField( l_hTIFF, TIFFTAG_SAMPLEFORMAT, &(poDS->nSampleFormat) );\n    TIFFGetField( l_hTIFF, TIFFTAG_PLANARCONFIG, &(poDS->nPlanarConfig) );\n    // Weird that we need this, but otherwise we get a Valgrind warning on\n    // tiff_write_124.\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, &(poDS->nPhotometric) ) )\n        poDS->nPhotometric = PHOTOMETRIC_MINISBLACK;\n    TIFFGetField( l_hTIFF, TIFFTAG_BITSPERSAMPLE, &(poDS->nBitsPerSample) );\n    TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, &(poDS->nCompression) );\n\n    if( TIFFIsTiled(l_hTIFF) )\n    {\n        TIFFGetField( l_hTIFF, TIFFTAG_TILEWIDTH, &(poDS->nBlockXSize) );\n        TIFFGetField( l_hTIFF, TIFFTAG_TILELENGTH, &(poDS->nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( l_hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(poDS->nRowsPerStrip) ) )\n            poDS->nRowsPerStrip = 1;  // Dummy value.\n\n        poDS->nBlockXSize = nXSize;\n        poDS->nBlockYSize =\n            std::min( static_cast<int>(poDS->nRowsPerStrip) , nYSize );\n    }\n\n    poDS->nBlocksPerBand =\n        DIV_ROUND_UP(nYSize, poDS->nBlockYSize)\n        * DIV_ROUND_UP(nXSize, poDS->nBlockXSize);\n\n    if( CSLFetchNameValue( papszParmList, \"PROFILE\" ) != nullptr )\n        poDS->osProfile = CSLFetchNameValue( papszParmList, \"PROFILE\" );\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( poDS->nCompression == COMPRESSION_JPEG\n        && poDS->nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\") ) )\n    {\n        int nColorMode = 0;\n\n        poDS->SetMetadataItem(\"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\");\n        if( !TIFFGetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n            nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n#ifdef HAVE_LERC\n    if( poDS->nCompression == COMPRESSION_LERC )\n    {\n        uint32 nLercParamCount = 0;\n        uint32* panLercParms = nullptr;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_LERC_PARAMETERS, &nLercParamCount,\n                          &panLercParms ) &&\n            nLercParamCount == 2 )\n        {\n            memcpy( poDS->anLercAddCompressionAndVersion, panLercParms,\n                    sizeof(poDS->anLercAddCompressionAndVersion) );\n        }\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Read palette back as a color table if it has one.               */\n/* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( poDS->nPhotometric == PHOTOMETRIC_PALETTE\n        && TIFFGetField( l_hTIFF, TIFFTAG_COLORMAP,\n                         &panRed, &panGreen, &panBlue) )\n    {\n\n        poDS->poColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 << poDS->nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast<short>(panRed[iColor] / divisor),\n                static_cast<short>(panGreen[iColor] / divisor),\n                static_cast<short>(panBlue[iColor] / divisor),\n                static_cast<short>(255)\n            };\n\n            poDS->poColorTable->SetColorEntry( iColor, &oEntry );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we want to ensure all blocks get written out on close to     */\n/*      avoid sparse files?                                             */\n/* -------------------------------------------------------------------- */\n    if( !CPLFetchBool( papszParmList, \"SPARSE_OK\", false ) )\n        poDS->bFillEmptyTilesAtClosing = true;\n\n    poDS->bWriteEmptyTiles = bStreaming ||\n        (poDS->nCompression != COMPRESSION_NONE &&\n         poDS->bFillEmptyTilesAtClosing);\n    // Only required for people writing non-compressed stripped files in the\n    // right order and wanting all tstrips to be written in the same order\n    // so that the end result can be memory mapped without knowledge of each\n    // strip offset.\n    if( CPLTestBool( CSLFetchNameValueDef( papszParmList,\n                              \"WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) ||\n         CPLTestBool( CSLFetchNameValueDef( papszParmList,\n                              \"@WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) )\n    {\n        poDS->bWriteEmptyTiles = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Preserve creation options for consulting later (for instance    */\n/*      to decide if a TFW file should be written).                     */\n/* -------------------------------------------------------------------- */\n    poDS->papszCreationOptions = CSLDuplicate( papszParmList );\n\n    poDS->nZLevel = GTiffGetZLevel(papszParmList);\n    poDS->nLZMAPreset = GTiffGetLZMAPreset(papszParmList);\n    poDS->nZSTDLevel = GTiffGetZSTDPreset(papszParmList);\n    poDS->nWebPLevel = GTiffGetWebPLevel(papszParmList);\n    poDS->bWebPLossless = GTiffGetWebPLossless(papszParmList);\n    poDS->nJpegQuality = GTiffGetJpegQuality(papszParmList);\n    poDS->nJpegTablesMode = GTiffGetJpegTablesMode(papszParmList);\n#if HAVE_LERC\n    poDS->dfMaxZError = GTiffGetLERCMaxZError(papszParmList);\n#endif\n    poDS->InitCreationOrOpenOptions(papszParmList);\n\n#if !defined(BIGTIFF_SUPPORT)\n/* -------------------------------------------------------------------- */\n/*      If we are writing jpeg compression we need to write some        */\n/*      imagery to force the jpegtables to get created.  This is,       */\n/*      likely only needed with libtiff >= 3.9.3 (#3633)                */\n/* -------------------------------------------------------------------- */\n    if( poDS->nCompression == COMPRESSION_JPEG\n        && strstr(TIFFLIB_VERSION_STR, \"Version 3.9\") != nullptr )\n    {\n        CPLDebug( \"GDAL\",\n                  \"Writing zero block to force creation of JPEG tables.\" );\n        if( TIFFIsTiled( l_hTIFF ) )\n        {\n            const int cc = TIFFTileSize( l_hTIFF );\n            unsigned char *pabyZeros =\n                static_cast<unsigned char *>(CPLCalloc(cc, 1));\n            TIFFWriteEncodedTile(l_hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        else\n        {\n            const int cc = TIFFStripSize( l_hTIFF );\n            unsigned char *pabyZeros =\n                static_cast<unsigned char *>(CPLCalloc(cc, 1));\n            TIFFWriteEncodedStrip(l_hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        poDS->bDontReloadFirstBlock = true;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < l_nBands; ++iBand )\n    {\n        if( poDS->nBitsPerSample == 8 ||\n            (poDS->nBitsPerSample == 16 && eType != GDT_Float32) ||\n            poDS->nBitsPerSample == 32 ||\n            poDS->nBitsPerSample == 64 ||\n            poDS->nBitsPerSample == 128)\n        {\n            poDS->SetBand( iBand + 1, new GTiffRasterBand( poDS, iBand + 1 ) );\n        }\n        else\n        {\n            poDS->SetBand( iBand + 1, new GTiffOddBitsBand( poDS, iBand + 1 ) );\n            poDS->GetRasterBand( iBand + 1 )->\n                SetMetadataItem( \"NBITS\",\n                                 CPLString().Printf(\"%d\",poDS->nBitsPerSample),\n                                 \"IMAGE_STRUCTURE\" );\n        }\n    }\n\n    poDS->GetDiscardLsbOption(papszParmList);\n\n    if( poDS->nPlanarConfig == PLANARCONFIG_CONTIG && l_nBands != 1 )\n        poDS->SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        poDS->SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    poDS->oOvManager.Initialize( poDS, pszFilename );\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                             CreateCopy()                             */\n/************************************************************************/\n\nGDALDataset *\nGTiffDataset::CreateCopy( const char * pszFilename, GDALDataset *poSrcDS,\n                          int bStrict, char ** papszOptions,\n                          GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    if( poSrcDS->GetRasterCount() == 0 )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Unable to export GeoTIFF files with zero bands.\" );\n        return nullptr;\n    }\n\n    GDALRasterBand * const poPBand = poSrcDS->GetRasterBand(1);\n    const GDALDataType eType = poPBand->GetRasterDataType();\n\n/* -------------------------------------------------------------------- */\n/*      Check, whether all bands in input dataset has the same type.    */\n/* -------------------------------------------------------------------- */\n    const int l_nBands = poSrcDS->GetRasterCount();\n    for( int iBand = 2; iBand <= l_nBands; ++iBand )\n    {\n        if( eType != poSrcDS->GetRasterBand(iBand)->GetRasterDataType() )\n        {\n            if( bStrict )\n            {\n                CPLError(\n                    CE_Failure, CPLE_AppDefined,\n                    \"Unable to export GeoTIFF file with different datatypes \"\n                    \"per different bands. All bands should have the same \"\n                    \"types in TIFF.\" );\n                return nullptr;\n            }\n            else\n            {\n                CPLError(\n                    CE_Warning, CPLE_AppDefined,\n                    \"Unable to export GeoTIFF file with different datatypes \"\n                    \"per different bands. All bands should have the same \"\n                    \"types in TIFF.\" );\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture the profile.                                            */\n/* -------------------------------------------------------------------- */\n    const char *pszProfile = CSLFetchNameValue(papszOptions, \"PROFILE\");\n    if( pszProfile == nullptr )\n        pszProfile = szPROFILE_GDALGeoTIFF;\n\n    if( !EQUAL(pszProfile, szPROFILE_BASELINE)\n        && !EQUAL(pszProfile, szPROFILE_GeoTIFF)\n        && !EQUAL(pszProfile, szPROFILE_GDALGeoTIFF) )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"PROFILE=%s not supported in GTIFF driver.\",\n                  pszProfile );\n        return nullptr;\n    }\n\n    const bool bGeoTIFF = !EQUAL(pszProfile, szPROFILE_BASELINE);\n\n/* -------------------------------------------------------------------- */\n/*      Special handling for NBITS.  Copy from band metadata if found.  */\n/* -------------------------------------------------------------------- */\n    char **papszCreateOptions = CSLDuplicate( papszOptions );\n\n    if( poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" ) != nullptr\n        && atoi(poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" )) > 0\n        && CSLFetchNameValue( papszCreateOptions, \"NBITS\") == nullptr )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"NBITS\",\n                             poPBand->GetMetadataItem( \"NBITS\",\n                                                       \"IMAGE_STRUCTURE\" ) );\n    }\n\n    if( CSLFetchNameValue( papszOptions, \"PIXELTYPE\" ) == nullptr\n        && eType == GDT_Byte\n        && poPBand->GetMetadataItem( \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"PIXELTYPE\",\n                             poPBand->GetMetadataItem(\n                                 \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Color profile.  Copy from band metadata if found.              */\n/* -------------------------------------------------------------------- */\n    if( bGeoTIFF )\n    {\n        const char* pszOptionsMD[] = {\n            \"SOURCE_ICC_PROFILE\",\n            \"SOURCE_PRIMARIES_RED\",\n            \"SOURCE_PRIMARIES_GREEN\",\n            \"SOURCE_PRIMARIES_BLUE\",\n            \"SOURCE_WHITEPOINT\",\n            \"TIFFTAG_TRANSFERFUNCTION_RED\",\n            \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n            \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n            \"TIFFTAG_TRANSFERRANGE_BLACK\",\n            \"TIFFTAG_TRANSFERRANGE_WHITE\",\n            nullptr\n        };\n\n        // Copy all the tags.  Options will override tags in the source.\n        int i = 0;\n        while(pszOptionsMD[i] != nullptr)\n        {\n            char const *pszMD =\n                CSLFetchNameValue(papszOptions, pszOptionsMD[i]);\n            if( pszMD == nullptr )\n                pszMD = poSrcDS->GetMetadataItem( pszOptionsMD[i],\n                                                  \"COLOR_PROFILE\" );\n\n            if( (pszMD != nullptr) && !EQUAL(pszMD, \"\") )\n            {\n                papszCreateOptions =\n                    CSLSetNameValue( papszCreateOptions, pszOptionsMD[i],\n                                     pszMD );\n\n                // If an ICC profile exists, other tags are not needed.\n                if( EQUAL(pszOptionsMD[i], \"SOURCE_ICC_PROFILE\") )\n                    break;\n            }\n\n            ++i;\n        }\n    }\n\n    double dfExtraSpaceForOverviews = 0;\n    if( CPLFetchBool(papszOptions, \"COPY_SRC_OVERVIEWS\", false) )\n    {\n        const int nSrcOverviews = poSrcDS->GetRasterBand(1)->GetOverviewCount();\n        if( nSrcOverviews )\n        {\n            for( int j = 1; j <= l_nBands; ++j )\n            {\n                if( poSrcDS->GetRasterBand(j)->GetOverviewCount() !=\n                                                        nSrcOverviews )\n                {\n                    CPLError(\n                        CE_Failure, CPLE_NotSupported,\n                        \"COPY_SRC_OVERVIEWS cannot be used when the bands have \"\n                        \"not the same number of overview levels.\" );\n                    CSLDestroy(papszCreateOptions);\n                    return nullptr;\n                }\n                for( int i = 0; i < nSrcOverviews; ++i )\n                {\n                    GDALRasterBand* poOvrBand =\n                        poSrcDS->GetRasterBand(j)->GetOverview(i);\n                    if( poOvrBand == nullptr )\n                    {\n                        CPLError(\n                            CE_Failure, CPLE_NotSupported,\n                            \"COPY_SRC_OVERVIEWS cannot be used when one \"\n                            \"overview band is NULL.\" );\n                        CSLDestroy(papszCreateOptions);\n                        return nullptr;\n                    }\n                    GDALRasterBand* poOvrFirstBand =\n                        poSrcDS->GetRasterBand(1)->GetOverview(i);\n                    if( poOvrBand->GetXSize() != poOvrFirstBand->GetXSize() ||\n                        poOvrBand->GetYSize() != poOvrFirstBand->GetYSize() )\n                    {\n                        CPLError(\n                            CE_Failure, CPLE_NotSupported,\n                            \"COPY_SRC_OVERVIEWS cannot be used when the \"\n                            \"overview bands have not the same dimensions \"\n                            \"among bands.\" );\n                        CSLDestroy(papszCreateOptions);\n                        return nullptr;\n                    }\n                }\n            }\n\n            for( int i = 0; i < nSrcOverviews; ++i )\n            {\n                dfExtraSpaceForOverviews +=\n                    static_cast<double>(\n                      poSrcDS->GetRasterBand(1)->GetOverview(i)->GetXSize() ) *\n                      poSrcDS->GetRasterBand(1)->GetOverview(i)->GetYSize();\n            }\n            dfExtraSpaceForOverviews *=\n                                l_nBands * GDALGetDataTypeSizeBytes(eType);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we use optimized way of copying from an input JPEG       */\n/*      dataset?                                                        */\n/* -------------------------------------------------------------------- */\n\n// TODO(schwehr): Refactor bDirectCopyFromJPEG to be a const.\n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n    bool bDirectCopyFromJPEG = false;\n#endif\n\n    // Note: JPEG_DIRECT_COPY is not defined by default, because it is mainly\n    // useful for debugging purposes.\n#ifdef JPEG_DIRECT_COPY\n    if( CPLFetchBool(papszCreateOptions, \"JPEG_DIRECT_COPY\", false) &&\n        GTIFF_CanDirectCopyFromJPEG(poSrcDS, papszCreateOptions) )\n    {\n        CPLDebug(\"GTiff\", \"Using special direct copy mode from a JPEG dataset\");\n\n        bDirectCopyFromJPEG = true;\n    }\n#endif\n\n#ifdef HAVE_LIBJPEG\n    bool bCopyFromJPEG = false;\n\n    // When CreateCopy'ing() from a JPEG dataset, and asking for COMPRESS=JPEG,\n    // use DCT coefficients (unless other options are incompatible, like\n    // strip/tile dimensions, specifying JPEG_QUALITY option, incompatible\n    // PHOTOMETRIC with the source colorspace, etc.) to avoid the lossy steps\n    // involved by decompression/recompression.\n    if( !bDirectCopyFromJPEG &&\n        GTIFF_CanCopyFromJPEG(poSrcDS, papszCreateOptions) )\n    {\n        CPLDebug( \"GTiff\", \"Using special copy mode from a JPEG dataset\" );\n\n        bCopyFromJPEG = true;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      If the source is RGB, then set the PHOTOMETRIC=RGB value        */\n/* -------------------------------------------------------------------- */\n\n    const bool bForcePhotometric =\n        CSLFetchNameValue(papszOptions, \"PHOTOMETRIC\") != nullptr;\n\n    if( l_nBands >= 3 && !bForcePhotometric &&\n#ifdef HAVE_LIBJPEG\n        !bCopyFromJPEG &&\n#endif\n        poSrcDS->GetRasterBand(1)->GetColorInterpretation() == GCI_RedBand &&\n        poSrcDS->GetRasterBand(2)->GetColorInterpretation() == GCI_GreenBand &&\n        poSrcDS->GetRasterBand(3)->GetColorInterpretation() == GCI_BlueBand )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"PHOTOMETRIC\", \"RGB\" );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create the file.                                                */\n/* -------------------------------------------------------------------- */\n    VSILFILE* l_fpL = nullptr;\n    CPLString l_osTmpFilename;\n\n    const int nXSize = poSrcDS->GetRasterXSize();\n    const int nYSize = poSrcDS->GetRasterYSize();\n    TIFF *l_hTIFF =\n        CreateLL( pszFilename, nXSize, nYSize, l_nBands,\n                  eType, dfExtraSpaceForOverviews, papszCreateOptions, &l_fpL,\n                  l_osTmpFilename );\n    const bool bStreaming = !l_osTmpFilename.empty();\n\n    CSLDestroy( papszCreateOptions );\n    papszCreateOptions = nullptr;\n\n    if( l_hTIFF == nullptr )\n    {\n        if( bStreaming ) VSIUnlink(l_osTmpFilename);\n        return nullptr;\n    }\n\n    uint16 l_nPlanarConfig = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_PLANARCONFIG, &l_nPlanarConfig );\n\n    uint16 l_nBitsPerSample = 0;\n    TIFFGetField(l_hTIFF, TIFFTAG_BITSPERSAMPLE, &l_nBitsPerSample );\n\n    uint16 l_nCompression = 0;\n\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, &(l_nCompression) ) )\n        l_nCompression = COMPRESSION_NONE;\n\n/* -------------------------------------------------------------------- */\n/*      Set the alpha channel if it is the last one.                    */\n/* -------------------------------------------------------------------- */\n    if( poSrcDS->GetRasterBand(l_nBands)->GetColorInterpretation() ==\n        GCI_AlphaBand )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            const int nBaseSamples = l_nBands - count;\n            if( l_nBands > nBaseSamples && l_nBands - nBaseSamples - 1 < count )\n            {\n                // We need to allocate a new array as (current) libtiff\n                // versions will not like that we reuse the array we got from\n                // TIFFGetField().\n\n                uint16* pasNewExtraSamples =\n                    static_cast<uint16 *>(\n                        CPLMalloc( count * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v, count * sizeof(uint16) );\n                pasNewExtraSamples[l_nBands - nBaseSamples - 1] =\n                    GTiffGetAlphaValue(\n                        CPLGetConfigOption(\n                            \"GTIFF_ALPHA\",\n                            CSLFetchNameValue(papszOptions,\"ALPHA\") ),\n                        DEFAULT_ALPHA_TYPE);\n\n                TIFFSetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, count,\n                              pasNewExtraSamples);\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the output is jpeg compressed, and the input is RGB make     */\n/*      sure we note that.                                              */\n/* -------------------------------------------------------------------- */\n\n    if( l_nCompression == COMPRESSION_JPEG )\n    {\n        if( l_nBands >= 3\n            && (poSrcDS->GetRasterBand(1)->GetColorInterpretation()\n                == GCI_YCbCr_YBand)\n            && (poSrcDS->GetRasterBand(2)->GetColorInterpretation()\n                == GCI_YCbCr_CbBand)\n            && (poSrcDS->GetRasterBand(3)->GetColorInterpretation()\n                == GCI_YCbCr_CrBand) )\n        {\n            // Do nothing.\n        }\n        else\n        {\n            // Assume RGB if it is not explicitly YCbCr.\n            CPLDebug( \"GTiff\", \"Setting JPEGCOLORMODE_RGB\" );\n            TIFFSetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Does the source image consist of one band, with a palette?      */\n/*      If so, copy over.                                               */\n/* -------------------------------------------------------------------- */\n    if( (l_nBands == 1 || l_nBands == 2) &&\n        poSrcDS->GetRasterBand(1)->GetColorTable() != nullptr\n        && eType == GDT_Byte )\n    {\n        unsigned short anTRed[256] = { 0 };\n        unsigned short anTGreen[256] = { 0 };\n        unsigned short anTBlue[256] = { 0 };\n        GDALColorTable *poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n\n        for( int iColor = 0; iColor < 256; ++iColor )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry sRGB = { 0, 0, 0, 0 };\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = static_cast<unsigned short>(257 * sRGB.c1);\n                anTGreen[iColor] = static_cast<unsigned short>(257 * sRGB.c2);\n                anTBlue[iColor] = static_cast<unsigned short>(257 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = 0;\n                anTGreen[iColor] = 0;\n                anTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP, anTRed, anTGreen, anTBlue );\n    }\n    else if( (l_nBands == 1 || l_nBands == 2)\n             && poSrcDS->GetRasterBand(1)->GetColorTable() != nullptr\n             && eType == GDT_UInt16 )\n    {\n        unsigned short *panTRed = static_cast<unsigned short *>(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n        unsigned short *panTGreen = static_cast<unsigned short *>(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n        unsigned short *panTBlue = static_cast<unsigned short *>(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n\n        GDALColorTable *poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n\n        for( int iColor = 0; iColor < 65536; ++iColor )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry sRGB = { 0, 0, 0, 0 };\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                panTRed[iColor] = static_cast<unsigned short>(257 * sRGB.c1);\n                panTGreen[iColor] = static_cast<unsigned short>(257 * sRGB.c2);\n                panTBlue[iColor] = static_cast<unsigned short>(257 * sRGB.c3);\n            }\n            else\n            {\n                panTRed[iColor] = 0;\n                panTGreen[iColor] = 0;\n                panTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP, panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n    else if( poSrcDS->GetRasterBand(1)->GetColorTable() != nullptr )\n        CPLError(\n            CE_Warning, CPLE_AppDefined,\n            \"Unable to export color table to GeoTIFF file.  Color tables \"\n            \"can only be written to 1 band or 2 bands Byte or \"\n            \"UInt16 GeoTIFF files.\" );\n\n    if( l_nBands == 2\n        && poSrcDS->GetRasterBand(1)->GetColorTable() != nullptr\n        && (eType == GDT_Byte || eType == GDT_UInt16) )\n    {\n        uint16 v[1] = { EXTRASAMPLE_UNASSALPHA };\n\n        TIFFSetField(l_hTIFF, TIFFTAG_EXTRASAMPLES, 1, v );\n    }\n\n    // FIXME? libtiff writes extended tags in the order they are specified\n    // and not in increasing order.\n\n/* -------------------------------------------------------------------- */\n/*      Transfer some TIFF specific metadata, if available.             */\n/*      The return value will tell us if we need to try again later with*/\n/*      PAM because the profile doesn't allow to write some metadata    */\n/*      as TIFF tag                                                     */\n/* -------------------------------------------------------------------- */\n    const bool bHasWrittenMDInGeotiffTAG =\n            GTiffDataset::WriteMetadata( poSrcDS, l_hTIFF, false, pszProfile,\n                                         pszFilename, papszOptions );\n\n/* -------------------------------------------------------------------- */\n/*      Write NoData value, if exist.                                   */\n/* -------------------------------------------------------------------- */\n    if( EQUAL(pszProfile,szPROFILE_GDALGeoTIFF) )\n    {\n        int bSuccess = FALSE;\n        const double dfNoData =\n            poSrcDS->GetRasterBand(1)->GetNoDataValue( &bSuccess );\n        if( bSuccess )\n            GTiffDataset::WriteNoDataValue( l_hTIFF, dfNoData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Are we addressing PixelIsPoint mode?                            */\n/* -------------------------------------------------------------------- */\n    bool bPixelIsPoint = false;\n    bool bPointGeoIgnore = false;\n\n    if( poSrcDS->GetMetadataItem( GDALMD_AREA_OR_POINT )\n        && EQUAL(poSrcDS->GetMetadataItem(GDALMD_AREA_OR_POINT),\n                 GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore =\n            CPLTestBool( CPLGetConfigOption( \"GTIFF_POINT_GEO_IGNORE\",\n                                             \"FALSE\") );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write affine transform if it is meaningful.                     */\n/* -------------------------------------------------------------------- */\n    const char *l_pszProjection = nullptr;\n    double l_adfGeoTransform[6] = { 0.0 };\n\n    if( poSrcDS->GetGeoTransform( l_adfGeoTransform ) == CE_None )\n    {\n        if( bGeoTIFF )\n        {\n            l_pszProjection = poSrcDS->GetProjectionRef();\n\n            if( l_adfGeoTransform[2] == 0.0 && l_adfGeoTransform[4] == 0.0\n                && l_adfGeoTransform[5] < 0.0 )\n            {\n                double dfOffset = 0.0;\n                {\n                    // In the case the SRS has a vertical component and we have\n                    // a single band, encode its scale/offset in the GeoTIFF tags\n                    int bHasScale = FALSE;\n                    double dfScale =\n                        poSrcDS->GetRasterBand(1)->GetScale(&bHasScale);\n                    int bHasOffset = FALSE;\n                    dfOffset =\n                        poSrcDS->GetRasterBand(1)->GetOffset(&bHasOffset);\n                    const bool bApplyScaleOffset =\n                        HasVerticalCS(l_pszProjection) &&\n                        poSrcDS->GetRasterCount() == 1;\n                    if( bApplyScaleOffset && !bHasScale )\n                        dfScale = 1.0;\n                    if( !bApplyScaleOffset || !bHasOffset )\n                        dfOffset = 0.0;\n                    const double adfPixelScale[3] = {\n                        l_adfGeoTransform[1], fabs(l_adfGeoTransform[5]),\n                        bApplyScaleOffset ? dfScale : 0.0 };\n\n                    TIFFSetField( l_hTIFF, TIFFTAG_GEOPIXELSCALE, 3,\n                                  adfPixelScale );\n                }\n\n                double adfTiePoints[6] = {\n                    0.0,\n                    0.0,\n                    0.0,\n                    l_adfGeoTransform[0],\n                    l_adfGeoTransform[3],\n                    dfOffset\n                };\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfTiePoints[3] +=\n                        l_adfGeoTransform[1] * 0.5 + l_adfGeoTransform[2] * 0.5;\n                    adfTiePoints[4] +=\n                        l_adfGeoTransform[4] * 0.5 + l_adfGeoTransform[5] * 0.5;\n                }\n\n                TIFFSetField( l_hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n            }\n            else\n            {\n                double adfMatrix[16] = { 0.0 };\n\n                adfMatrix[0] = l_adfGeoTransform[1];\n                adfMatrix[1] = l_adfGeoTransform[2];\n                adfMatrix[3] = l_adfGeoTransform[0];\n                adfMatrix[4] = l_adfGeoTransform[4];\n                adfMatrix[5] = l_adfGeoTransform[5];\n                adfMatrix[7] = l_adfGeoTransform[3];\n                adfMatrix[15] = 1.0;\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfMatrix[3] +=\n                        l_adfGeoTransform[1] * 0.5 + l_adfGeoTransform[2] * 0.5;\n                    adfMatrix[7] +=\n                        l_adfGeoTransform[4] * 0.5 + l_adfGeoTransform[5] * 0.5;\n                }\n\n                TIFFSetField( l_hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need a TFW file?                                          */\n/* -------------------------------------------------------------------- */\n        if( CPLFetchBool( papszOptions, \"TFW\", false ) )\n            GDALWriteWorldFile( pszFilename, \"tfw\", l_adfGeoTransform );\n        else if( CPLFetchBool( papszOptions, \"WORLDFILE\", false ) )\n            GDALWriteWorldFile( pszFilename, \"wld\", l_adfGeoTransform );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise write tiepoints if they are available.                */\n/* -------------------------------------------------------------------- */\n    else if( poSrcDS->GetGCPCount() > 0 && bGeoTIFF )\n    {\n        const GDAL_GCP *pasGCPs = poSrcDS->GetGCPs();\n        double *padfTiePoints = static_cast<double *>(\n            CPLMalloc(6 * sizeof(double) * poSrcDS->GetGCPCount()) );\n\n        for( int iGCP = 0; iGCP < poSrcDS->GetGCPCount(); ++iGCP )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPs[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPs[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPs[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPs[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPs[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] += 0.5;\n                padfTiePoints[iGCP*6+1] += 0.5;\n            }\n        }\n\n        TIFFSetField( l_hTIFF, TIFFTAG_GEOTIEPOINTS,\n                      6*poSrcDS->GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n\n        l_pszProjection = poSrcDS->GetGCPProjection();\n\n        if( CPLFetchBool( papszOptions, \"TFW\", false )\n            || CPLFetchBool( papszOptions, \"WORLDFILE\", false ) )\n        {\n            CPLError(\n                CE_Warning, CPLE_AppDefined,\n                \"TFW=ON or WORLDFILE=ON creation options are ignored when \"\n                \"GCPs are available\" );\n        }\n    }\n    else\n    {\n        l_pszProjection = poSrcDS->GetProjectionRef();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write the projection information, if possible.                  */\n/* -------------------------------------------------------------------- */\n    const bool bHasProjection =\n        l_pszProjection != nullptr && strlen(l_pszProjection) > 0;\n    if( (bHasProjection || bPixelIsPoint) && bGeoTIFF )\n    {\n        GTIF *psGTIF = GTiffDatasetGTIFNew( l_hTIFF );\n\n        if( bHasProjection )\n        {\n            GTIFSetFromOGISDefnEx( psGTIF, l_pszProjection,\n                                   GetGTIFFKeysFlavor(papszOptions) );\n        }\n\n        if( bPixelIsPoint )\n        {\n            GTIFKeySet( psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                        RasterPixelIsPoint );\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n\n    bool l_bDontReloadFirstBlock = false;\n\n#ifdef HAVE_LIBJPEG\n    if( bCopyFromJPEG )\n    {\n        GTIFF_CopyFromJPEG_WriteAdditionalTags(l_hTIFF,\n                                               poSrcDS);\n    }\n#endif\n\n#if defined(HAVE_LIBJPEG) && !defined(BIGTIFF_SUPPORT)\n    else\n#endif\n\n#if !defined(BIGTIFF_SUPPORT)\n    /* -------------------------------------------------------------------- */\n    /*      If we are writing jpeg compression we need to write some        */\n    /*      imagery to force the jpegtables to get created.  This is,       */\n    /*      likely only needed with libtiff >= 3.9.3 (#3633)                */\n    /* -------------------------------------------------------------------- */\n    if( l_nCompression == COMPRESSION_JPEG\n            && strstr(TIFFLIB_VERSION_STR, \"Version 3.9\") != nullptr )\n    {\n        CPLDebug( \"GDAL\",\n                  \"Writing zero block to force creation of JPEG tables.\" );\n        if( TIFFIsTiled( l_hTIFF ) )\n        {\n            const int cc = TIFFTileSize( l_hTIFF );\n            unsigned char *pabyZeros =\n                static_cast<unsigned char *>( CPLCalloc(cc, 1) );\n            TIFFWriteEncodedTile( l_hTIFF, 0, pabyZeros, cc );\n            CPLFree( pabyZeros );\n        }\n        else\n        {\n            int cc = TIFFStripSize( l_hTIFF );\n            unsigned char *pabyZeros =\n                static_cast<unsigned char *>( CPLCalloc(cc,1) );\n            TIFFWriteEncodedStrip( l_hTIFF, 0, pabyZeros, cc );\n            CPLFree( pabyZeros );\n        }\n        l_bDontReloadFirstBlock = true;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup                                                         */\n/* -------------------------------------------------------------------- */\n\n    TIFFWriteCheck( l_hTIFF, TIFFIsTiled(l_hTIFF), \"GTiffCreateCopy()\" );\n    TIFFWriteDirectory( l_hTIFF );\n    if( bStreaming )\n    {\n        // We need to write twice the directory to be sure that custom\n        // TIFF tags are correctly sorted and that padding bytes have been\n        // added.\n        TIFFSetDirectory( l_hTIFF, 0 );\n        TIFFWriteDirectory( l_hTIFF );\n\n        if( VSIFSeekL( l_fpL, 0, SEEK_END ) != 0 )\n            CPLError(CE_Failure, CPLE_FileIO, \"Cannot seek\");\n        const int nSize = static_cast<int>( VSIFTellL(l_fpL) );\n\n        vsi_l_offset nDataLength = 0;\n        VSIGetMemFileBuffer( l_osTmpFilename, &nDataLength, FALSE);\n        TIFFSetDirectory( l_hTIFF, 0 );\n        GTiffFillStreamableOffsetAndCount( l_hTIFF, nSize );\n        TIFFWriteDirectory( l_hTIFF );\n    }\n    TIFFFlush( l_hTIFF );\n    XTIFFClose( l_hTIFF );\n    l_hTIFF = nullptr;\n\n    {\n        const CPLErr eErr = VSIFCloseL(l_fpL) == 0 ? CE_None : CE_Failure;\n        l_fpL = nullptr;\n\n        if( eErr != CE_None )\n        {\n            VSIUnlink( bStreaming ? l_osTmpFilename.c_str() : pszFilename );\n            return nullptr;\n        }\n    }\n\n    // fpStreaming will assigned to the instance and not closed here.\n    VSILFILE *fpStreaming = nullptr;\n    if( bStreaming )\n    {\n        vsi_l_offset nDataLength = 0;\n        void* pabyBuffer =\n            VSIGetMemFileBuffer( l_osTmpFilename, &nDataLength, FALSE);\n        fpStreaming = VSIFOpenL( pszFilename, \"wb\" );\n        if( fpStreaming == nullptr )\n        {\n            VSIUnlink(l_osTmpFilename);\n            return nullptr;\n        }\n        if( static_cast<vsi_l_offset>(\n                VSIFWriteL( pabyBuffer, 1, static_cast<int>(nDataLength),\n                            fpStreaming ) ) != nDataLength )\n        {\n            CPLError( CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                      static_cast<int>(nDataLength) );\n            CPL_IGNORE_RET_VAL(VSIFCloseL( fpStreaming ));\n            VSIUnlink(l_osTmpFilename);\n            return nullptr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Re-open as a dataset and copy over missing metadata using       */\n/*      PAM facilities.                                                 */\n/* -------------------------------------------------------------------- */\n    CPLString osFileName(\"GTIFF_RAW:\");\n\n    osFileName += bStreaming ? l_osTmpFilename.c_str() : pszFilename;\n\n    GDALOpenInfo oOpenInfo( osFileName, GA_Update );\n    if( bStreaming )\n    {\n        // In case of single strip file, there's a libtiff check that would\n        // issue a warning since the file hasn't the required size.\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n    }\n    GTiffDataset *poDS = cpl::down_cast<GTiffDataset *>( Open(&oOpenInfo) );\n    if( bStreaming )\n        CPLPopErrorHandler();\n    if( poDS == nullptr )\n    {\n        oOpenInfo.eAccess = GA_ReadOnly;\n        poDS = cpl::down_cast<GTiffDataset *>( Open(&oOpenInfo) );\n    }\n\n    if( poDS == nullptr )\n    {\n        VSIUnlink( bStreaming ? l_osTmpFilename.c_str() : pszFilename );\n        return nullptr;\n    }\n    poDS->osFilename = pszFilename;\n\n    if( bStreaming )\n    {\n        VSIUnlink(l_osTmpFilename);\n        poDS->fpToWrite = fpStreaming;\n    }\n    poDS->osProfile = pszProfile;\n\n    int nCloneInfoFlags = GCIF_PAM_DEFAULT & ~GCIF_MASK;\n\n    // If we explicitly asked not to tag the alpha band as such, do not\n    // reintroduce this alpha color interpretation in PAM.\n    if( poSrcDS->GetRasterBand(l_nBands)->GetColorInterpretation() ==\n        GCI_AlphaBand &&\n        GTiffGetAlphaValue(\n            CPLGetConfigOption(\n                \"GTIFF_ALPHA\",\n                CSLFetchNameValue(papszOptions,\"ALPHA\") ),\n            DEFAULT_ALPHA_TYPE) == EXTRASAMPLE_UNSPECIFIED )\n    {\n        nCloneInfoFlags &= ~GCIF_COLORINTERP;\n    }\n    // Ignore source band color interpretation if requesting PHOTOMETRIC=RGB\n    else if( l_nBands >= 3 &&\n        EQUAL(CSLFetchNameValueDef(papszOptions, \"PHOTOMETRIC\", \"\"), \"RGB\") )\n    {\n        for( int i = 1; i <= 3; i++)\n        {\n            poDS->GetRasterBand(i)->SetColorInterpretation(\n                static_cast<GDALColorInterp>(GCI_RedBand + (i-1)));\n        }\n        nCloneInfoFlags &= ~GCIF_COLORINTERP;\n        if( !(l_nBands == 4 && CSLFetchNameValue(papszOptions, \"ALPHA\") != nullptr) )\n        {\n            for( int i = 4; i <= l_nBands; i++)\n            {\n                poDS->GetRasterBand(i)->SetColorInterpretation(\n                    poSrcDS->GetRasterBand(i)->GetColorInterpretation());\n            }\n        }\n    }\n\n    CPLString osOldGTIFF_REPORT_COMPD_CSVal(\n        CPLGetConfigOption(\"GTIFF_REPORT_COMPD_CS\", \"\"));\n    CPLSetThreadLocalConfigOption(\"GTIFF_REPORT_COMPD_CS\", \"YES\");\n    poDS->CloneInfo( poSrcDS, nCloneInfoFlags );\n    CPLSetThreadLocalConfigOption(\"GTIFF_REPORT_COMPD_CS\",\n        osOldGTIFF_REPORT_COMPD_CSVal.empty() ? nullptr :\n        osOldGTIFF_REPORT_COMPD_CSVal.c_str());\n\n    if( !bGeoTIFF && (poDS->GetPamFlags() & GPF_DISABLED) == 0 )\n    {\n        // Copy georeferencing info to PAM if the profile is not GeoTIFF\n        poDS->GDALPamDataset::SetProjection(poDS->GetProjectionRef());\n        double adfGeoTransform[6];\n        if( poDS->GetGeoTransform(adfGeoTransform) == CE_None )\n        {\n            poDS->GDALPamDataset::SetGeoTransform(adfGeoTransform);\n        }\n        poDS->GDALPamDataset::SetGCPs(poDS->GetGCPCount(),\n                                      poDS->GetGCPs(),\n                                      poDS->GetGCPProjection());\n    }\n\n    poDS->papszCreationOptions = CSLDuplicate( papszOptions );\n    poDS->bDontReloadFirstBlock = l_bDontReloadFirstBlock;\n\n/* -------------------------------------------------------------------- */\n/*      CloneInfo() does not merge metadata, it just replaces it        */\n/*      totally.  So we have to merge it.                               */\n/* -------------------------------------------------------------------- */\n\n    char **papszSRC_MD = poSrcDS->GetMetadata();\n    char **papszDST_MD = CSLDuplicate(poDS->GetMetadata());\n\n    papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n    poDS->SetMetadata( papszDST_MD );\n    CSLDestroy( papszDST_MD );\n\n    // Depending on the PHOTOMETRIC tag, the TIFF file may not have the same\n    // band count as the source. Will fail later in GDALDatasetCopyWholeRaster\n    // anyway.\n    for( int nBand = 1;\n         nBand <= std::min(poDS->GetRasterCount(), poSrcDS->GetRasterCount()) ;\n         ++nBand )\n    {\n        GDALRasterBand* poSrcBand = poSrcDS->GetRasterBand(nBand);\n        GDALRasterBand* poDstBand = poDS->GetRasterBand(nBand);\n        papszSRC_MD = poSrcBand->GetMetadata();\n        papszDST_MD = CSLDuplicate(poDstBand->GetMetadata());\n\n        papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n        poDstBand->SetMetadata( papszDST_MD );\n        CSLDestroy( papszDST_MD );\n\n        char** papszCatNames = poSrcBand->GetCategoryNames();\n        if( nullptr != papszCatNames )\n            poDstBand->SetCategoryNames( papszCatNames );\n    }\n\n    l_hTIFF = static_cast<TIFF *>( poDS->GetInternalHandle(nullptr) );\n\n/* -------------------------------------------------------------------- */\n/*      Handle forcing xml:ESRI data to be written to PAM.              */\n/* -------------------------------------------------------------------- */\n    if( CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n    {\n        char **papszESRIMD = poSrcDS->GetMetadata(\"xml:ESRI\");\n        if( papszESRIMD )\n        {\n            poDS->SetMetadata( papszESRIMD, \"xml:ESRI\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Second chance: now that we have a PAM dataset, it is possible   */\n/*      to write metadata that we could not write as a TIFF tag.        */\n/* -------------------------------------------------------------------- */\n    if( !bHasWrittenMDInGeotiffTAG && !bStreaming )\n        GTiffDataset::WriteMetadata(\n            poDS, l_hTIFF, true, pszProfile,\n            pszFilename, papszOptions,\n            true /* don't write RPC and IMD file again */ );\n\n    if( !bStreaming )\n        GTiffDataset::WriteRPC(\n            poDS, l_hTIFF, true, pszProfile,\n            pszFilename, papszOptions,\n            true /* write only in PAM AND if needed */ );\n\n    // To avoid unnecessary directory rewriting.\n    poDS->bMetadataChanged = false;\n    poDS->bGeoTIFFInfoChanged = false;\n    poDS->bNoDataChanged = false;\n    poDS->bForceUnsetGTOrGCPs = false;\n    poDS->bForceUnsetProjection = false;\n    poDS->bStreamingOut = bStreaming;\n\n    // Don't try to load external metadata files (#6597).\n    poDS->bIMDRPCMetadataLoaded = true;\n\n    // We must re-set the compression level at this point, since it has been\n    // lost a few lines above when closing the newly create TIFF file The\n    // TIFFTAG_ZIPQUALITY & TIFFTAG_JPEGQUALITY are not store in the TIFF file.\n    // They are just TIFF session parameters.\n\n    poDS->nZLevel = GTiffGetZLevel(papszOptions);\n    poDS->nLZMAPreset = GTiffGetLZMAPreset(papszOptions);\n    poDS->nZSTDLevel = GTiffGetZSTDPreset(papszOptions);\n    poDS->nWebPLevel = GTiffGetWebPLevel(papszOptions);\n    poDS->bWebPLossless = GTiffGetWebPLossless(papszOptions);\n    poDS->nJpegQuality = GTiffGetJpegQuality(papszOptions);\n    poDS->nJpegTablesMode = GTiffGetJpegTablesMode(papszOptions);\n    poDS->GetDiscardLsbOption(papszOptions);\n#if HAVE_LERC\n    poDS->dfMaxZError = GTiffGetLERCMaxZError(papszOptions);\n#endif\n    poDS->InitCreationOrOpenOptions(papszOptions);\n\n    if( l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        l_nCompression == COMPRESSION_LERC )\n    {\n        if( poDS->nZLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_ZIPQUALITY, poDS->nZLevel );\n        }\n    }\n    if( l_nCompression == COMPRESSION_JPEG )\n    {\n        if( poDS->nJpegQuality != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_JPEGQUALITY, poDS->nJpegQuality );\n        }\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGTABLESMODE, poDS->nJpegTablesMode );\n    }\n    if( l_nCompression == COMPRESSION_LZMA )\n    {\n        if( poDS->nLZMAPreset != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_LZMAPRESET, poDS->nLZMAPreset );\n        }\n    }\n    if( l_nCompression == COMPRESSION_ZSTD ||\n        l_nCompression == COMPRESSION_LERC )\n    {\n        if( poDS->nZSTDLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_ZSTD_LEVEL, poDS->nZSTDLevel );\n        }\n    }\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        TIFFSetField( l_hTIFF, TIFFTAG_LERC_MAXZERROR, poDS->dfMaxZError );\n    }\n#endif\n    if( l_nCompression == COMPRESSION_WEBP )\n    {\n        if( poDS->nWebPLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LEVEL, poDS->nWebPLevel );\n        }\n\n        if( poDS->bWebPLossless)\n        {\n          TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LOSSLESS, poDS->bWebPLossless );\n        }\n    }\n\n    // Precreate (internal) mask, so that the IBuildOverviews() below\n    // has a chance to create also the overviews of the mask.\n    CPLErr eErr = CE_None;\n\n    const int nMaskFlags = poSrcDS->GetRasterBand(1)->GetMaskFlags();\n    bool bMask = false;\n    if( !(nMaskFlags & (GMF_ALL_VALID|GMF_ALPHA|GMF_NODATA) )\n        && (nMaskFlags & GMF_PER_DATASET) && !bStreaming )\n    {\n        bMask = true;\n        eErr = poDS->CreateMaskBand( nMaskFlags );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create and then copy existing overviews if requested            */\n/*  We do it such that all the IFDs are at the beginning of the file,   */\n/*  and that the imagery data for the smallest overview is written      */\n/*  first, that way the file is more usable when embedded in a          */\n/*  compressed stream.                                                  */\n/* -------------------------------------------------------------------- */\n\n    // For scaled progress due to overview copying.\n    const int nBandsWidthMask = l_nBands +  (bMask ? 1 : 0);\n    double dfTotalPixels =\n        static_cast<double>(nXSize) * nYSize * nBandsWidthMask;\n    double dfCurPixels = 0;\n\n    if( eErr == CE_None &&\n        CPLFetchBool(papszOptions, \"COPY_SRC_OVERVIEWS\", false) )\n    {\n        const int nSrcOverviews = poSrcDS->GetRasterBand(1)->GetOverviewCount();\n        if( nSrcOverviews )\n        {\n            eErr = poDS->CreateOverviewsFromSrcOverviews(poSrcDS);\n\n            if( poDS->nOverviewCount != nSrcOverviews )\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                        \"Did only manage to instantiate %d overview levels, \"\n                        \"whereas source contains %d\",\n                        poDS->nOverviewCount, nSrcOverviews);\n                eErr = CE_Failure;\n            }\n\n            for( int i = 0; i < nSrcOverviews; ++i )\n            {\n                GDALRasterBand* poOvrBand =\n                    poSrcDS->GetRasterBand(1)->GetOverview(i);\n                dfTotalPixels += static_cast<double>(poOvrBand->GetXSize()) *\n                                poOvrBand->GetYSize() * nBandsWidthMask;\n            }\n\n            char* papszCopyWholeRasterOptions[2] = { nullptr, nullptr };\n            if( l_nCompression != COMPRESSION_NONE )\n                papszCopyWholeRasterOptions[0] =\n                    const_cast<char*>( \"COMPRESSED=YES\" );\n            // Now copy the imagery.\n            for( int i = 0; eErr == CE_None && i < nSrcOverviews; ++i )\n            {\n                // Begin with the smallest overview.\n                const int iOvrLevel = nSrcOverviews - 1 - i;\n\n                // Create a fake dataset with the source overview level so that\n                // GDALDatasetCopyWholeRaster can cope with it.\n                GDALDataset* poSrcOvrDS =\n                    GDALCreateOverviewDataset(poSrcDS, iOvrLevel, TRUE);\n\n                GDALRasterBand* poOvrBand =\n                        poSrcDS->GetRasterBand(1)->GetOverview(iOvrLevel);\n                double dfNextCurPixels =\n                    dfCurPixels +\n                    static_cast<double>(poOvrBand->GetXSize()) *\n                    poOvrBand->GetYSize() * l_nBands;\n\n                void* pScaledData =\n                    GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                            dfNextCurPixels / dfTotalPixels,\n                                            pfnProgress, pProgressData );\n\n                eErr =\n                    GDALDatasetCopyWholeRaster(\n                        GDALDataset::ToHandle(poSrcOvrDS),\n                        GDALDataset::ToHandle(poDS->papoOverviewDS[iOvrLevel]),\n                        papszCopyWholeRasterOptions,\n                        GDALScaledProgress, pScaledData );\n\n                dfCurPixels = dfNextCurPixels;\n                GDALDestroyScaledProgress(pScaledData);\n\n                delete poSrcOvrDS;\n                poSrcOvrDS = nullptr;\n                poDS->papoOverviewDS[iOvrLevel]->FlushCache();\n\n                // Copy mask of the overview.\n                if( eErr == CE_None && poDS->poMaskDS != nullptr )\n                {\n                    dfNextCurPixels +=\n                        static_cast<double>(poOvrBand->GetXSize()) *\n                                            poOvrBand->GetYSize();\n                    pScaledData =\n                        GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                            dfNextCurPixels / dfTotalPixels,\n                                            pfnProgress, pProgressData );\n                    eErr =\n                        GDALRasterBandCopyWholeRaster(\n                            poOvrBand->GetMaskBand(),\n                            poDS->papoOverviewDS[iOvrLevel]->\n                            poMaskDS->GetRasterBand(1),\n                            papszCopyWholeRasterOptions,\n                            GDALScaledProgress, pScaledData );\n                    dfCurPixels = dfNextCurPixels;\n                    GDALDestroyScaledProgress(pScaledData);\n                    poDS->papoOverviewDS[iOvrLevel]->poMaskDS->FlushCache();\n                }\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy actual imagery.                                            */\n/* -------------------------------------------------------------------- */\n    double dfNextCurPixels =\n        dfCurPixels + static_cast<double>(nXSize) * nYSize * l_nBands;\n    void* pScaledData = GDALCreateScaledProgress(\n        dfCurPixels / dfTotalPixels,\n        dfNextCurPixels / dfTotalPixels,\n        pfnProgress, pProgressData);\n\n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n    bool bTryCopy = true;\n#endif\n\n#ifdef HAVE_LIBJPEG\n    if( bCopyFromJPEG )\n    {\n        eErr = GTIFF_CopyFromJPEG( poDS, poSrcDS,\n                                   pfnProgress, pProgressData,\n                                   bTryCopy );\n\n        // In case of failure in the decompression step, try normal copy.\n        if( bTryCopy )\n            eErr = CE_None;\n    }\n#endif\n\n#ifdef JPEG_DIRECT_COPY\n    if( bDirectCopyFromJPEG )\n    {\n        eErr = GTIFF_DirectCopyFromJPEG(poDS, poSrcDS,\n                                        pfnProgress, pProgressData,\n                                        bTryCopy);\n\n        // In case of failure in the reading step, try normal copy.\n        if( bTryCopy )\n            eErr = CE_None;\n    }\n#endif\n\n    if( \n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n        bTryCopy &&\n#endif\n        (poDS->bTreatAsSplit || poDS->bTreatAsSplitBitmap) )\n    {\n        // For split bands, we use TIFFWriteScanline() interface.\n        CPLAssert(poDS->nBitsPerSample == 8 || poDS->nBitsPerSample == 1);\n\n        if( poDS->nPlanarConfig == PLANARCONFIG_CONTIG && poDS->nBands > 1 )\n        {\n            GByte* pabyScanline =\n                static_cast<GByte *>(\n                    VSI_MALLOC_VERBOSE(TIFFScanlineSize(l_hTIFF)) );\n            if( pabyScanline == nullptr )\n                eErr = CE_Failure;\n            for( int j = 0; j < nYSize && eErr == CE_None; ++j )\n            {\n                eErr =\n                    poSrcDS->RasterIO(\n                        GF_Read, 0, j, nXSize, 1,\n                        pabyScanline, nXSize, 1,\n                        GDT_Byte, l_nBands, nullptr, poDS->nBands, 0, 1,\n                        nullptr );\n                if( eErr == CE_None &&\n                    TIFFWriteScanline( l_hTIFF, pabyScanline, j, 0) == -1 )\n                {\n                    CPLError( CE_Failure, CPLE_AppDefined,\n                              \"TIFFWriteScanline() failed.\" );\n                    eErr = CE_Failure;\n                }\n                if( !GDALScaledProgress( (j + 1) * 1.0 / nYSize,\n                                         nullptr, pScaledData ) )\n                    eErr = CE_Failure;\n            }\n            CPLFree( pabyScanline );\n        }\n        else\n        {\n            GByte* pabyScanline = static_cast<GByte *>(\n                VSI_MALLOC_VERBOSE(nXSize) );\n            if( pabyScanline == nullptr )\n                eErr = CE_Failure;\n            else\n                eErr = CE_None;\n            for( int iBand = 1; iBand <= l_nBands && eErr == CE_None; ++iBand )\n            {\n                for( int j = 0; j < nYSize && eErr == CE_None; ++j )\n                {\n                    eErr = poSrcDS->GetRasterBand(iBand)->RasterIO(\n                        GF_Read, 0, j, nXSize, 1,\n                        pabyScanline, nXSize, 1,\n                        GDT_Byte, 0, 0, nullptr );\n                    if( poDS->bTreatAsSplitBitmap )\n                    {\n                        for( int i = 0; i < nXSize; ++i )\n                        {\n                            const GByte byVal = pabyScanline[i];\n                            if( (i & 0x7) == 0 )\n                                pabyScanline[i >> 3] = 0;\n                            if( byVal )\n                                pabyScanline[i >> 3] |= 0x80 >> (i & 0x7);\n                        }\n                    }\n                    if( eErr == CE_None &&\n                        TIFFWriteScanline(\n                            l_hTIFF, pabyScanline, j,\n                            static_cast<uint16>(iBand - 1)) == -1 )\n                    {\n                        CPLError( CE_Failure, CPLE_AppDefined,\n                                  \"TIFFWriteScanline() failed.\" );\n                        eErr = CE_Failure;\n                    }\n                    if( !GDALScaledProgress(\n                           (j + 1 + (iBand - 1) * nYSize) * 1.0 /\n                           (l_nBands * nYSize),\n                           nullptr, pScaledData ) )\n                        eErr = CE_Failure;\n                }\n            }\n            CPLFree(pabyScanline);\n        }\n\n        // Necessary to be able to read the file without re-opening.\n#if defined(HAVE_TIFFGETSIZEPROC)\n        TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( l_hTIFF );\n\n        TIFFFlushData( l_hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( l_hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            ++nNewDirOffset;\n#endif\n\n        TIFFFlush( l_hTIFF );\n\n#if defined(HAVE_TIFFGETSIZEPROC)\n        if( poDS->nDirOffset != TIFFCurrentDirOffset( l_hTIFF ) )\n        {\n            poDS->nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\", \"directory moved during flush.\" );\n        }\n#endif\n    }\n    else if( \n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n        bTryCopy &&\n#endif\n        eErr == CE_None )\n    {\n        char* papszCopyWholeRasterOptions[3] = { nullptr, nullptr, nullptr };\n        int iNextOption = 0;\n        papszCopyWholeRasterOptions[iNextOption++] =\n                const_cast<char *>( \"SKIP_HOLES=YES\" );\n        if( l_nCompression != COMPRESSION_NONE )\n        {\n            papszCopyWholeRasterOptions[iNextOption++] =\n                const_cast<char *>( \"COMPRESSED=YES\" );\n        }\n        // For streaming with separate, we really want that bands are written\n        // after each other, even if the source is pixel interleaved.\n        else if( bStreaming && poDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            papszCopyWholeRasterOptions[iNextOption++] =\n                const_cast<char *>(\"INTERLEAVE=BAND\");\n        }\n\n    /* -------------------------------------------------------------------- */\n    /*      Do we want to ensure all blocks get written out on close to     */\n    /*      avoid sparse files?                                             */\n    /* -------------------------------------------------------------------- */\n        if( !CPLFetchBool( papszOptions, \"SPARSE_OK\", false ) )\n            poDS->bFillEmptyTilesAtClosing = true;\n\n        poDS->bWriteEmptyTiles =\n            bStreaming ||\n            (poDS->nCompression != COMPRESSION_NONE &&\n             poDS->bFillEmptyTilesAtClosing);\n        // Only required for people writing non-compressed stripped files in the\n        // rightorder and wanting all tstrips to be written in the same order\n        // so that the end result can be memory mapped without knowledge of each\n        // strip offset\n        if( CPLTestBool( CSLFetchNameValueDef(\n                             papszOptions,\n                             \"WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) ||\n           CPLTestBool( CSLFetchNameValueDef(\n                             papszOptions,\n                             \"@WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) )\n        {\n            poDS->bWriteEmptyTiles = true;\n        }\n\n        eErr = GDALDatasetCopyWholeRaster(\n            /* (GDALDatasetH) */ poSrcDS,\n            /* (GDALDatasetH) */ poDS,\n            papszCopyWholeRasterOptions,\n            GDALScaledProgress, pScaledData );\n    }\n\n    GDALDestroyScaledProgress(pScaledData);\n\n    if( eErr == CE_None && !bStreaming )\n    {\n        pScaledData = GDALCreateScaledProgress(\n            dfNextCurPixels / dfTotalPixels,\n            1.0,\n            pfnProgress, pProgressData);\n        if( poDS->poMaskDS )\n        {\n            const char* l_papszOptions[2] = { \"COMPRESSED=YES\", nullptr };\n            eErr = GDALRasterBandCopyWholeRaster(\n                                    poSrcDS->GetRasterBand(1)->GetMaskBand(),\n                                    poDS->GetRasterBand(1)->GetMaskBand(),\n                                    const_cast<char **>(l_papszOptions),\n                                    GDALScaledProgress, pScaledData );\n        }\n        else\n        {\n            eErr = GDALDriver::DefaultCopyMasks( poSrcDS, poDS, bStrict,\n                                                 nullptr,\n                                                 GDALScaledProgress, pScaledData );\n        }\n        GDALDestroyScaledProgress(pScaledData);\n    }\n\n    if( eErr == CE_Failure )\n    {\n        delete poDS;\n        poDS = nullptr;\n\n        if( CPLTestBool(CPLGetConfigOption(\"GTIFF_DELETE_ON_ERROR\", \"YES\")) )\n        {\n            if( !bStreaming )\n            {\n                // Should really delete more carefully.\n                VSIUnlink( pszFilename );\n            }\n        }\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                          GetProjectionRef()                          */\n/************************************************************************/\n\nconst char *GTiffDataset::GetProjectionRef()\n\n{\n    if( nGCPCount == 0 )\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n        LookForProjection();\n\n        return pszProjection;\n    }\n\n    return \"\";\n}\n\n\n/************************************************************************/\n/*                           HasVerticalCS()                            */\n/************************************************************************/\n\nbool GTiffDataset::HasVerticalCS(const char *pszProjectionIn)\n{\n    if( pszProjectionIn != nullptr && pszProjectionIn[0] != '\\0' )\n    {\n        OGRSpatialReference oSRS;\n        oSRS.SetFromUserInput(pszProjectionIn);\n        return CPL_TO_BOOL(oSRS.IsVertical());\n    }\n    else\n    {\n        return false;\n    }\n}\n\n/************************************************************************/\n/*                           SetProjection()                            */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetProjection( const char * pszNewProjection )\n\n{\n    if( bStreamingOut && bCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify projection at that point in \"\n            \"a streamed output file\" );\n        return CE_Failure;\n    }\n\n    LoadGeoreferencingAndPamIfNeeded();\n    LookForProjection();\n\n    if( !STARTS_WITH_CI(pszNewProjection, \"GEOGCS\")\n        && !STARTS_WITH_CI(pszNewProjection, \"PROJCS\")\n        && !STARTS_WITH_CI(pszNewProjection, \"LOCAL_CS\")\n        && !STARTS_WITH_CI(pszNewProjection, \"COMPD_CS\")\n        && !STARTS_WITH_CI(pszNewProjection, \"GEOCCS\")\n        && !EQUAL(pszNewProjection,\"\") )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                \"Only OGC WKT Projections supported for writing to GeoTIFF.  \"\n                \"%s not supported.\",\n                  pszNewProjection );\n\n        return CE_Failure;\n    }\n\n    if( EQUAL(pszNewProjection, \"\") &&\n        pszProjection != nullptr &&\n        !EQUAL(pszProjection, \"\") )\n    {\n        bForceUnsetProjection = true;\n    }\n\n    CPLFree( pszProjection );\n    pszProjection = CPLStrdup( pszNewProjection );\n\n    bGeoTIFFInfoChanged = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                          GetGeoTransform()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::GetGeoTransform( double * padfTransform )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    memcpy( padfTransform, adfGeoTransform, sizeof(double) * 6 );\n\n    if( !bGeoTransformValid )\n        return CE_Failure;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                          SetGeoTransform()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetGeoTransform( double * padfTransform )\n\n{\n    if( bStreamingOut && bCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify geotransform at that point in a \"\n            \"streamed output file\" );\n        return CE_Failure;\n    }\n\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( GetAccess() == GA_Update )\n    {\n        if( nGCPCount > 0 )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"GCPs previously set are going to be cleared \"\n                     \"due to the setting of a geotransform.\");\n            bForceUnsetGTOrGCPs = true;\n            GDALDeinitGCPs( nGCPCount, pasGCPList );\n            CPLFree( pasGCPList );\n            nGCPCount = 0;\n            pasGCPList = nullptr;\n        }\n        else if( padfTransform[0] == 0.0 &&\n                 padfTransform[1] == 0.0 &&\n                 padfTransform[2] == 0.0 &&\n                 padfTransform[3] == 0.0 &&\n                 padfTransform[4] == 0.0 &&\n                 padfTransform[5] == 0.0 )\n        {\n            if( bGeoTransformValid )\n            {\n                bForceUnsetGTOrGCPs = true;\n                bGeoTIFFInfoChanged = true;\n            }\n            bGeoTransformValid = false;\n            memcpy( adfGeoTransform, padfTransform, sizeof(double)*6 );\n            return CE_None;\n        }\n\n        memcpy( adfGeoTransform, padfTransform, sizeof(double)*6 );\n        bGeoTransformValid = true;\n        bGeoTIFFInfoChanged = true;\n\n        return CE_None;\n    }\n    else\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Attempt to call SetGeoTransform() on a read-only GeoTIFF file.\" );\n        return CE_Failure;\n    }\n}\n\n/************************************************************************/\n/*                            GetGCPCount()                             */\n/************************************************************************/\n\nint GTiffDataset::GetGCPCount()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    return nGCPCount;\n}\n\n/************************************************************************/\n/*                          GetGCPProjection()                          */\n/************************************************************************/\n\nconst char *GTiffDataset::GetGCPProjection()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( nGCPCount > 0 )\n    {\n        LookForProjection();\n    }\n    if( pszProjection != nullptr )\n        return pszProjection;\n\n    return \"\";\n}\n\n/************************************************************************/\n/*                               GetGCPs()                              */\n/************************************************************************/\n\nconst GDAL_GCP *GTiffDataset::GetGCPs()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    return pasGCPList;\n}\n\n/************************************************************************/\n/*                               SetGCPs()                              */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetGCPs( int nGCPCountIn, const GDAL_GCP *pasGCPListIn,\n                              const char *pszGCPProjection )\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( GetAccess() == GA_Update )\n    {\n        LookForProjection();\n\n        if( nGCPCount > 0 && nGCPCountIn == 0 )\n        {\n            bForceUnsetGTOrGCPs = true;\n        }\n        else if( nGCPCountIn > 0 &&\n                 bGeoTransformValid )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"A geotransform previously set is going to be cleared \"\n                     \"due to the setting of GCPs.\");\n            adfGeoTransform[0] = 0.0;\n            adfGeoTransform[1] = 1.0;\n            adfGeoTransform[2] = 0.0;\n            adfGeoTransform[3] = 0.0;\n            adfGeoTransform[4] = 0.0;\n            adfGeoTransform[5] = 1.0;\n            bGeoTransformValid = false;\n            bForceUnsetGTOrGCPs = true;\n        }\n\n        if( pszProjection != nullptr &&\n            !EQUAL(pszProjection, \"\") &&\n                   (pszGCPProjection == nullptr ||\n                   pszGCPProjection[0] == '\\0') )\n            bForceUnsetProjection = true;\n\n        if( nGCPCount > 0 )\n        {\n            GDALDeinitGCPs( nGCPCount, pasGCPList );\n            CPLFree( pasGCPList );\n        }\n\n        nGCPCount = nGCPCountIn;\n        pasGCPList = GDALDuplicateGCPs(nGCPCount, pasGCPListIn);\n\n        CPLFree( pszProjection );\n        pszProjection = CPLStrdup( pszGCPProjection );\n        bGeoTIFFInfoChanged = true;\n\n        return CE_None;\n    }\n    else\n    {\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"SetGCPs() is only supported on newly created GeoTIFF files.\");\n        return CE_Failure;\n    }\n}\n\n/************************************************************************/\n/*                      GetMetadataDomainList()                         */\n/************************************************************************/\n\nchar **GTiffDataset::GetMetadataDomainList()\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    char **papszDomainList = CSLDuplicate(oGTiffMDMD.GetDomainList());\n    char **papszBaseList = GDALDataset::GetMetadataDomainList();\n\n    const int nbBaseDomains = CSLCount(papszBaseList);\n\n    for( int domainId = 0; domainId < nbBaseDomains; ++domainId )\n        papszDomainList = CSLAddString(papszDomainList,papszBaseList[domainId]);\n\n    CSLDestroy(papszBaseList);\n\n    return BuildMetadataDomainList(\n        papszDomainList,\n        TRUE,\n        \"\", \"ProxyOverviewRequest\", MD_DOMAIN_RPC, MD_DOMAIN_IMD,\n        \"SUBDATASETS\", \"EXIF\",\n        \"xml:XMP\", \"COLOR_PROFILE\", nullptr);\n}\n\n/************************************************************************/\n/*                            GetMetadata()                             */\n/************************************************************************/\n\nchar **GTiffDataset::GetMetadata( const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain, \"ProxyOverviewRequest\") )\n        return GDALPamDataset::GetMetadata( pszDomain );\n\n    if( pszDomain != nullptr && EQUAL(pszDomain, \"DERIVED_SUBDATASETS\"))\n    {\n        return GDALDataset::GetMetadata(pszDomain);\n    }\n\n    else if( pszDomain != nullptr && (EQUAL(pszDomain, MD_DOMAIN_RPC) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMD) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMAGERY)) )\n        LoadMetadata();\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"SUBDATASETS\") )\n        ScanDirectories();\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"EXIF\") )\n        LoadEXIFMetadata();\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"COLOR_PROFILE\") )\n        LoadICCProfile();\n\n    else if( pszDomain == nullptr || EQUAL(pszDomain, \"\") )\n        LoadMDAreaOrPoint();  // To set GDALMD_AREA_OR_POINT.\n\n    return oGTiffMDMD.GetMetadata( pszDomain );\n}\n\n/************************************************************************/\n/*                            SetMetadata()                             */\n/************************************************************************/\nCPLErr GTiffDataset::SetMetadata( char ** papszMD, const char *pszDomain )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( bStreamingOut && bCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify metadata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain, MD_DOMAIN_RPC) )\n    {\n        // So that a subsequent GetMetadata() wouldn't override our new values\n        LoadMetadata();\n        m_bForceUnsetRPC = (CSLCount(papszMD) == 0);\n    }\n\n    if( (papszMD != nullptr) &&\n        (pszDomain != nullptr) &&\n        EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        bColorProfileMetadataChanged = true;\n    }\n    else if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        bMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update &&\n            GDALPamDataset::GetMetadata(pszDomain) != nullptr )\n            GDALPamDataset::SetMetadata(nullptr, pszDomain);\n    }\n\n    if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) &&\n        CSLFetchNameValue(papszMD, GDALMD_AREA_OR_POINT) != nullptr )\n    {\n        const char* pszPrevValue =\n                GetMetadataItem(GDALMD_AREA_OR_POINT);\n        const char* pszNewValue =\n                CSLFetchNameValue(papszMD, GDALMD_AREA_OR_POINT);\n        if( pszPrevValue == nullptr || pszNewValue == nullptr ||\n            !EQUAL(pszPrevValue, pszNewValue) )\n        {\n            LookForProjection();\n            bGeoTIFFInfoChanged = true;\n        }\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain, \"xml:XMP\") )\n    {\n        if( papszMD != nullptr && *papszMD != nullptr )\n        {\n            int nTagSize = static_cast<int>(strlen(*papszMD));\n            TIFFSetField( hTIFF, TIFFTAG_XMLPACKET, nTagSize, *papszMD );\n        }\n        else\n        {\n#ifdef HAVE_UNSETFIELD\n            TIFFUnsetField( hTIFF, TIFFTAG_XMLPACKET );\n#else\n            CPLDebug(\n                \"GTiff\",\n                \"TIFFUnsetField() not supported, xml:XMP may not be cleared.\" );\n#endif\n        }\n    }\n\n    return oGTiffMDMD.SetMetadata( papszMD, pszDomain );\n}\n\n/************************************************************************/\n/*                          GetMetadataItem()                           */\n/************************************************************************/\n\nconst char *GTiffDataset::GetMetadataItem( const char *pszName,\n                                           const char *pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain,\"ProxyOverviewRequest\") )\n    {\n        return GDALPamDataset::GetMetadataItem( pszName, pszDomain );\n    }\n    else if( pszDomain != nullptr && (EQUAL(pszDomain, MD_DOMAIN_RPC) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMD) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMAGERY)) )\n    {\n        LoadMetadata();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"SUBDATASETS\") )\n    {\n        ScanDirectories();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"EXIF\") )\n    {\n        LoadEXIFMetadata();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        LoadICCProfile();\n    }\n    else if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) &&\n        pszName != nullptr && EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LoadMDAreaOrPoint();  // To set GDALMD_AREA_OR_POINT.\n    }\n\n#ifdef DEBUG_REACHED_VIRTUAL_MEM_IO\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"_DEBUG_\") &&\n             pszName != nullptr &&\n             EQUAL(pszName, \"UNREACHED_VIRTUALMEMIO_CODE_PATH\") )\n    {\n        CPLString osMissing;\n        for( int i = 0; i < static_cast<int>(\n                                CPL_ARRAYSIZE(anReachedVirtualMemIO)); ++i )\n        {\n            if( !anReachedVirtualMemIO[i] )\n            {\n                if( !osMissing.empty() ) osMissing += \",\";\n                osMissing += CPLSPrintf(\"%d\", i);\n            }\n        }\n        return (osMissing.size()) ? CPLSPrintf(\"%s\", osMissing.c_str()) : nullptr;\n    }\n#endif\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"_DEBUG_\") &&\n             pszName != nullptr && EQUAL(pszName, \"TIFFTAG_EXTRASAMPLES\") )\n    {\n        CPLString osRet;\n        uint16 *v = nullptr;\n        uint16 count = 0;\n\n        if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            for( int i = 0; i < static_cast<int>(count); ++i )\n            {\n                if( i > 0 ) osRet += \",\";\n                osRet += CPLSPrintf(\"%d\", v[i]);\n            }\n        }\n        return (osRet.size()) ? CPLSPrintf(\"%s\", osRet.c_str()) : nullptr;\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"_DEBUG_\") &&\n             pszName != nullptr && EQUAL(pszName, \"TIFFTAG_PHOTOMETRIC\") )\n    {\n        return CPLSPrintf(\"%d\", nPhotometric);\n    }\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"_DEBUG_\") &&\n             pszName != nullptr && EQUAL( pszName, \"TIFFTAG_GDAL_METADATA\") )\n    {\n        char* pszText = nullptr;\n        if( !TIFFGetField( hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n            return nullptr;\n\n        return CPLSPrintf(\"%s\", pszText);\n    }\n\n    return oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}\n\n/************************************************************************/\n/*                          SetMetadataItem()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetMetadataItem( const char *pszName,\n                                      const char *pszValue,\n                                      const char *pszDomain )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( bStreamingOut && bCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify metadata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    if( (pszDomain != nullptr) && EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        bColorProfileMetadataChanged = true;\n    }\n    else if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        bMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update &&\n            GDALPamDataset::GetMetadataItem(pszName, pszDomain) != nullptr )\n            GDALPamDataset::SetMetadataItem(pszName, nullptr, pszDomain);\n    }\n\n    if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) &&\n        pszName != nullptr && EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LookForProjection();\n        bGeoTIFFInfoChanged = true;\n    }\n\n    return oGTiffMDMD.SetMetadataItem( pszName, pszValue, pszDomain );\n}\n\n/************************************************************************/\n/*                         GetInternalHandle()                          */\n/************************************************************************/\n\nvoid *GTiffDataset::GetInternalHandle( const char * /* pszHandleName */ )\n\n{\n    return hTIFF;\n}\n\n/************************************************************************/\n/*                         LoadEXIFMetadata()                           */\n/************************************************************************/\n\nvoid GTiffDataset::LoadEXIFMetadata()\n{\n    if( bEXIFMetadataLoaded )\n        return;\n    bEXIFMetadataLoaded = true;\n\n    if( !SetDirectory() )\n        return;\n\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n\n    GByte abyHeader[2] = { 0 };\n    if( VSIFSeekL(fp, 0, SEEK_SET) != 0 ||\n        VSIFReadL(abyHeader, 1, 2, fp) != 2 )\n        return;\n\n    const bool bLittleEndian = abyHeader[0] == 'I' && abyHeader[1] == 'I';\n    const bool bLeastSignificantBit = CPL_IS_LSB != 0;\n    const bool bSwabflag = bLittleEndian != bLeastSignificantBit;  // != is XOR.\n\n    char** papszMetadata = nullptr;\n    toff_t nOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n\n    if( TIFFGetField(hTIFF, TIFFTAG_EXIFIFD, &nOffset) )\n    {\n        int nExifOffset = static_cast<int>(nOffset);\n        int nInterOffset = 0;\n        int nGPSOffset = 0;\n        EXIFExtractMetadata( papszMetadata,\n                             fp, static_cast<int>(nOffset),\n                             bSwabflag, 0,\n                             nExifOffset, nInterOffset, nGPSOffset);\n    }\n\n    if( TIFFGetField(hTIFF, TIFFTAG_GPSIFD, &nOffset) )\n    {\n        int nExifOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n        int nInterOffset = 0;\n        int nGPSOffset = static_cast<int>(nOffset);\n        EXIFExtractMetadata( papszMetadata,\n                             fp, static_cast<int>(nOffset),\n                             bSwabflag, 0,\n                             nExifOffset, nInterOffset, nGPSOffset );\n    }\n\n    if( papszMetadata )\n    {\n        oGTiffMDMD.SetMetadata( papszMetadata, \"EXIF\" );\n        CSLDestroy( papszMetadata );\n    }\n}\n\n/************************************************************************/\n/*                           LoadMetadata()                             */\n/************************************************************************/\nvoid GTiffDataset::LoadMetadata()\n{\n    if( bIMDRPCMetadataLoaded )\n        return;\n    bIMDRPCMetadataLoaded = true;\n\n    GDALMDReaderManager mdreadermanager;\n    GDALMDReaderBase* mdreader =\n        mdreadermanager.GetReader(osFilename,\n                                  oOvManager.GetSiblingFiles(), MDR_ANY);\n\n    if( nullptr != mdreader )\n    {\n        mdreader->FillMetadata(&oGTiffMDMD);\n\n        if(mdreader->GetMetadataDomain(MD_DOMAIN_RPC) == nullptr)\n        {\n            char** papszRPCMD = GTiffDatasetReadRPCTag(hTIFF);\n            if( papszRPCMD )\n            {\n                oGTiffMDMD.SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n                CSLDestroy( papszRPCMD );\n            }\n        }\n\n        papszMetadataFiles = mdreader->GetMetadataFiles();\n    }\n    else\n    {\n        char** papszRPCMD = GTiffDatasetReadRPCTag(hTIFF);\n        if( papszRPCMD )\n        {\n            oGTiffMDMD.SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n            CSLDestroy( papszRPCMD );\n        }\n    }\n}\n\n/************************************************************************/\n/*                            GetFileList()                             */\n/************************************************************************/\n\nchar **GTiffDataset::GetFileList()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    char **papszFileList = GDALPamDataset::GetFileList();\n\n    LoadMetadata();\n    if(nullptr != papszMetadataFiles)\n    {\n        for( int i = 0; papszMetadataFiles[i] != nullptr; ++i )\n        {\n            if( CSLFindString( papszFileList, papszMetadataFiles[i] ) < 0 )\n            {\n                papszFileList =\n                    CSLAddString( papszFileList, papszMetadataFiles[i] );\n            }\n        }\n    }\n\n    if( !osGeorefFilename.empty() &&\n        CSLFindString(papszFileList, osGeorefFilename) == -1 )\n    {\n        papszFileList = CSLAddString( papszFileList, osGeorefFilename );\n    }\n\n    return papszFileList;\n}\n\n/************************************************************************/\n/*                         CreateMaskBand()                             */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateMaskBand(int nFlagsIn)\n{\n    ScanDirectories();\n\n    if( poMaskDS != nullptr )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"This TIFF dataset has already an internal mask band\" );\n        return CE_Failure;\n    }\n    else if( CPLTestBool(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\")) )\n    {\n        if( nFlagsIn != GMF_PER_DATASET )\n        {\n            CPLError(\n                CE_Failure, CPLE_AppDefined,\n                \"The only flag value supported for internal mask is \"\n                \"GMF_PER_DATASET\" );\n            return CE_Failure;\n        }\n\n        int l_nCompression = COMPRESSION_PACKBITS;\n        if( strstr(GDALGetMetadataItem(GDALGetDriverByName( \"GTiff\" ),\n                                       GDAL_DMD_CREATIONOPTIONLIST, nullptr ),\n                   \"<Value>DEFLATE</Value>\") != nullptr )\n            l_nCompression = COMPRESSION_ADOBE_DEFLATE;\n\n    /* -------------------------------------------------------------------- */\n    /*      If we don't have read access, then create the mask externally.  */\n    /* -------------------------------------------------------------------- */\n        if( GetAccess() != GA_Update )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined,\n                      \"File open for read-only accessing, \"\n                      \"creating mask externally.\" );\n\n            return GDALPamDataset::CreateMaskBand(nFlagsIn);\n        }\n\n        if( poBaseDS && !poBaseDS->SetDirectory() )\n            return CE_Failure;\n\n        if( !SetDirectory() )\n            return CE_Failure;\n\n        bool bIsOverview = false;\n        uint32 nSubType = 0;\n        if( TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n        {\n            bIsOverview = (nSubType & FILETYPE_REDUCEDIMAGE) != 0;\n\n            if( (nSubType & FILETYPE_MASK) != 0 )\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"Cannot create a mask on a TIFF mask IFD !\" );\n                return CE_Failure;\n            }\n        }\n\n        const int bIsTiled = TIFFIsTiled(hTIFF);\n\n        FlushDirectory();\n\n        const toff_t nOffset =\n            GTIFFWriteDirectory(\n                hTIFF,\n                bIsOverview ?\n                FILETYPE_REDUCEDIMAGE | FILETYPE_MASK : FILETYPE_MASK,\n                nRasterXSize, nRasterYSize,\n                1, PLANARCONFIG_CONTIG, 1,\n                nBlockXSize, nBlockYSize,\n                bIsTiled, l_nCompression,\n                PHOTOMETRIC_MASK, PREDICTOR_NONE,\n                SAMPLEFORMAT_UINT, nullptr, nullptr, nullptr, 0, nullptr, \"\", nullptr, nullptr,\n                nullptr, nullptr );\n        if( nOffset == 0 )\n            return CE_Failure;\n\n        poMaskDS = new GTiffDataset();\n        poMaskDS->bPromoteTo8Bits =\n            CPLTestBool(\n                CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n        if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nOffset,\n                                  false, GA_Update ) != CE_None)\n        {\n            delete poMaskDS;\n            poMaskDS = nullptr;\n            return CE_Failure;\n        }\n\n        return CE_None;\n    }\n\n    return GDALPamDataset::CreateMaskBand(nFlagsIn);\n}\n\n/************************************************************************/\n/*                         CreateMaskBand()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::CreateMaskBand( int nFlagsIn )\n{\n    poGDS->ScanDirectories();\n\n    if( poGDS->poMaskDS != nullptr )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"This TIFF dataset has already an internal mask band\" );\n        return CE_Failure;\n    }\n\n    if( CPLTestBool( CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\") ) )\n    {\n        return poGDS->CreateMaskBand(nFlagsIn);\n    }\n\n    return GDALPamRasterBand::CreateMaskBand(nFlagsIn);\n}\n\n/************************************************************************/\n/*                       PrepareTIFFErrorFormat()                       */\n/*                                                                      */\n/*      sometimes the \"module\" has stuff in it that has special         */\n/*      meaning in a printf() style format, so we try to escape it.     */\n/*      For now we hope the only thing we have to escape is %'s.        */\n/************************************************************************/\n\nstatic char *PrepareTIFFErrorFormat( const char *module, const char *fmt )\n\n{\n    const size_t nModuleSize = strlen(module);\n    const size_t nModFmtSize = nModuleSize * 2 + strlen(fmt) + 2;\n    char *pszModFmt = static_cast<char *>( CPLMalloc( nModFmtSize ) );\n\n    size_t iOut = 0;  // Used after for.\n\n    for( size_t iIn = 0; iIn < nModuleSize; ++iIn )\n    {\n        if( module[iIn] == '%' )\n        {\n            CPLAssert(iOut < nModFmtSize - 2);\n            pszModFmt[iOut++] = '%';\n            pszModFmt[iOut++] = '%';\n        }\n        else\n        {\n            CPLAssert(iOut < nModFmtSize - 1);\n            pszModFmt[iOut++] = module[iIn];\n        }\n    }\n    CPLAssert(iOut < nModFmtSize);\n    pszModFmt[iOut] = '\\0';\n    strcat( pszModFmt, \":\" );\n    strcat( pszModFmt, fmt );\n\n    return pszModFmt;\n}\n\n/************************************************************************/\n/*                        GTiffWarningHandler()                         */\n/************************************************************************/\nstatic void\nGTiffWarningHandler(const char* module, const char* fmt, va_list ap )\n{\n    if( strstr(fmt,\"nknown field\") != nullptr )\n        return;\n\n    char *pszModFmt = PrepareTIFFErrorFormat( module, fmt );\n    if( strstr(fmt, \"does not end in null byte\") != nullptr )\n    {\n        CPLString osMsg;\n        osMsg.vPrintf(pszModFmt, ap);\n        CPLDebug( \"GTiff\", \"%s\", osMsg.c_str() );\n    }\n    else\n    {\n        CPLErrorV( CE_Warning, CPLE_AppDefined, pszModFmt, ap );\n    }\n    CPLFree( pszModFmt );\n}\n\n/************************************************************************/\n/*                         GTiffErrorHandler()                          */\n/************************************************************************/\nstatic void\nGTiffErrorHandler( const char* module, const char* fmt, va_list ap )\n{\n#ifdef BIGTIFF_SUPPORT\n    if( strcmp(fmt, \"Maximum TIFF file size exceeded\") == 0 )\n    {\n        // Ideally there would be a thread-safe way of setting this flag,\n        // but we cannot really use the extended error handler, since the\n        // handler is for all TIFF handles, and not necessarily the ones of\n        // this driver.\n        if( bGlobalInExternalOvr )\n            fmt =\n                \"Maximum TIFF file size exceeded. \"\n                \"Use --config BIGTIFF_OVERVIEW YES configuration option.\";\n        else\n            fmt =\n                \"Maximum TIFF file size exceeded. \"\n                \"Use BIGTIFF=YES creation option.\";\n    }\n#endif\n\n    char* pszModFmt = PrepareTIFFErrorFormat( module, fmt );\n    CPLErrorV( CE_Failure, CPLE_AppDefined, pszModFmt, ap );\n    CPLFree( pszModFmt );\n}\n\n/************************************************************************/\n/*                          GTiffTagExtender()                          */\n/*                                                                      */\n/*      Install tags specially known to GDAL.                           */\n/************************************************************************/\n\nstatic TIFFExtendProc _ParentExtender = nullptr;\n\nstatic void GTiffTagExtender(TIFF *tif)\n\n{\n    const TIFFFieldInfo xtiffFieldInfo[] = {\n        { TIFFTAG_GDAL_METADATA, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast<char *>( \"GDALMetadata\" ) },\n        { TIFFTAG_GDAL_NODATA, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast<char*>( \"GDALNoDataValue\" ) },\n        { TIFFTAG_RPCCOEFFICIENT, -1, -1, TIFF_DOUBLE, FIELD_CUSTOM,\n          TRUE, TRUE, const_cast<char *>( \"RPCCoefficient\" ) },\n        { TIFFTAG_TIFF_RSID, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast<char *>( \"TIFF_RSID\" ) },\n        { TIFFTAG_GEO_METADATA, -1, -1, TIFF_BYTE, FIELD_CUSTOM,\n          TRUE, TRUE, const_cast<char *>( \"GEO_METADATA\" ) }\n    };\n\n    if( _ParentExtender )\n        (*_ParentExtender)(tif);\n\n    TIFFMergeFieldInfo( tif, xtiffFieldInfo,\n                        sizeof(xtiffFieldInfo) / sizeof(xtiffFieldInfo[0]) );\n}\n\n/************************************************************************/\n/*                          GTiffOneTimeInit()                          */\n/*                                                                      */\n/*      This is stuff that is initialized for the TIFF library just     */\n/*      once.  We deliberately defer the initialization till the        */\n/*      first time we are likely to call into libtiff to avoid          */\n/*      unnecessary paging in of the library for GDAL apps that         */\n/*      don't use it.                                                   */\n/************************************************************************/\n#if defined(HAVE_DLFCN_H) && !defined(WIN32)\n#include <dlfcn.h>\n#endif\n\nstatic std::mutex oDeleteMutex;\n#ifdef HAVE_LERC\nstatic TIFFCodec* pLercCodec = nullptr;\n#endif\n\nint GTiffOneTimeInit()\n\n{\n    std::lock_guard<std::mutex> oLock(oDeleteMutex);\n \n#ifdef HAVE_LERC\n    if( pLercCodec == nullptr )\n    {\n        pLercCodec = TIFFRegisterCODEC(COMPRESSION_LERC, \"LERC\", TIFFInitLERC);\n    }\n#endif\n\n    static bool bOneTimeInitDone = false;\n    if( bOneTimeInitDone )\n        return TRUE;\n\n    bOneTimeInitDone = true;\n\n    // This is a frequent configuration error that is difficult to track down\n    // for people unaware of the issue : GDAL built against internal libtiff\n    // (4.X), but used by an application that links with external libtiff (3.X)\n    // Note: on my conf, the order that cause GDAL to crash - and that is\n    // detected by the following code - is \"-ltiff -lgdal\". \"-lgdal -ltiff\"\n    // works for the GTiff driver but probably breaks the application that\n    // believes it uses libtiff 3.X but we cannot detect that.\n#if defined(BIGTIFF_SUPPORT) && !defined(RENAME_INTERNAL_LIBTIFF_SYMBOLS)\n#if defined(HAVE_DLFCN_H) && !defined(WIN32)\n    const char* (*pfnVersion)(void);\n#ifdef HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n#endif\n    pfnVersion = reinterpret_cast<const char* (*)(void)>(dlsym(RTLD_DEFAULT, \"TIFFGetVersion\"));\n#ifdef HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT\n#pragma GCC diagnostic pop\n#endif\n    if( pfnVersion )\n    {\n        const char* pszVersion = pfnVersion();\n        if( pszVersion && strstr(pszVersion, \"Version 3.\") != nullptr )\n        {\n            CPLError(\n                CE_Warning, CPLE_AppDefined,\n                \"libtiff version mismatch: You're linking against libtiff 3.X, \"\n                \"but GDAL has been compiled against libtiff >= 4.0.0\" );\n        }\n    }\n#endif  // HAVE_DLFCN_H\n#endif  // BIGTIFF_SUPPORT\n\n    _ParentExtender = TIFFSetTagExtender(GTiffTagExtender);\n\n    TIFFSetWarningHandler( GTiffWarningHandler );\n    TIFFSetErrorHandler( GTiffErrorHandler );\n\n    LibgeotiffOneTimeInit();\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*                        GDALDeregister_GTiff()                        */\n/************************************************************************/\n\nstatic\nvoid GDALDeregister_GTiff( GDALDriver * )\n\n{\n    CSVDeaccess( nullptr );\n\n#if defined(LIBGEOTIFF_VERSION) && LIBGEOTIFF_VERSION > 1150\n    GTIFDeaccessCSV();\n#endif\n \n#ifdef HAVE_LERC\n    if( pLercCodec )\n        TIFFUnRegisterCODEC(pLercCodec);\n    pLercCodec = nullptr;\n#endif\n\n    delete gpoCompressThreadPool;\n    gpoCompressThreadPool = nullptr;\n}\n\n/************************************************************************/\n/*                   GTIFFGetCompressionMethod()                        */\n/************************************************************************/\n\nint GTIFFGetCompressionMethod(const char* pszValue, const char* pszVariableName)\n{\n    int nCompression = COMPRESSION_NONE;\n    if( EQUAL( pszValue, \"NONE\" ) )\n        nCompression = COMPRESSION_NONE;\n    else if( EQUAL( pszValue, \"JPEG\" ) )\n        nCompression = COMPRESSION_JPEG;\n    else if( EQUAL( pszValue, \"LZW\" ) )\n        nCompression = COMPRESSION_LZW;\n    else if( EQUAL( pszValue, \"PACKBITS\" ))\n        nCompression = COMPRESSION_PACKBITS;\n    else if( EQUAL( pszValue, \"DEFLATE\" ) || EQUAL( pszValue, \"ZIP\" ))\n        nCompression = COMPRESSION_ADOBE_DEFLATE;\n    else if( EQUAL( pszValue, \"FAX3\" )\n             || EQUAL( pszValue, \"CCITTFAX3\" ))\n        nCompression = COMPRESSION_CCITTFAX3;\n    else if( EQUAL( pszValue, \"FAX4\" )\n             || EQUAL( pszValue, \"CCITTFAX4\" ))\n        nCompression = COMPRESSION_CCITTFAX4;\n    else if( EQUAL( pszValue, \"CCITTRLE\" ) )\n        nCompression = COMPRESSION_CCITTRLE;\n    else if( EQUAL( pszValue, \"LZMA\" ) )\n        nCompression = COMPRESSION_LZMA;\n    else if( EQUAL( pszValue, \"ZSTD\" ) )\n        nCompression = COMPRESSION_ZSTD;\n#ifdef HAVE_LERC\n    else if( EQUAL( pszValue, \"LERC\" ) ||\n             EQUAL( pszValue, \"LERC_DEFLATE\" ) ||\n             EQUAL( pszValue, \"LERC_ZSTD\" ) )\n    {\n        nCompression = COMPRESSION_LERC;\n    }\n#endif\n    else if( EQUAL( pszValue, \"WEBP\" ) )\n        nCompression = COMPRESSION_WEBP;\n    else\n        CPLError( CE_Warning, CPLE_IllegalArg,\n                  \"%s=%s value not recognised, ignoring.\",\n                  pszVariableName,pszValue );\n\n#if defined(TIFFLIB_VERSION) && TIFFLIB_VERSION > 20031007  // 3.6.0\n    if( nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(static_cast<uint16>(nCompression)) )\n    {\n        CPLError(\n            CE_Failure, CPLE_AppDefined,\n            \"Cannot create TIFF file due to missing codec for %s.\", pszValue );\n        return -1;\n    }\n#endif\n\n    return nCompression;\n}\n\n/************************************************************************/\n/*                          GDALRegister_GTiff()                        */\n/************************************************************************/\n\nvoid GDALRegister_GTiff()\n\n{\n    if( GDALGetDriverByName( \"GTiff\" ) != nullptr )\n        return;\n\n    CPLString osOptions;\n    CPLString osCompressValues;\n    bool bHasJPEG = false;\n    bool bHasLZMA = false;\n    bool bHasZSTD = false;\n    bool bHasWebP = false;\n\n    GDALDriver *poDriver = new GDALDriver();\n\n/* -------------------------------------------------------------------- */\n/*      Determine which compression codecs are available that we        */\n/*      want to advertise.  If we are using an old libtiff we won't     */\n/*      be able to find out so we just assume all are available.        */\n/* -------------------------------------------------------------------- */\n    osCompressValues = \"       <Value>NONE</Value>\";\n\n#if TIFFLIB_VERSION <= 20040919\n    osCompressValues +=\n            \"       <Value>PACKBITS</Value>\"\n            \"       <Value>JPEG</Value>\"\n            \"       <Value>LZW</Value>\"\n            \"       <Value>DEFLATE</Value>\";\n    bool bHasLZW = true;\n    bool bHasDEFLATE = true;\n#else\n    bool bHasLZW = false;\n    bool bHasDEFLATE = false;\n    TIFFCodec *codecs = TIFFGetConfiguredCODECs();\n\n    for( TIFFCodec *c = codecs; c->name; ++c )\n    {\n        if( c->scheme == COMPRESSION_PACKBITS )\n        {\n            osCompressValues +=\n                    \"       <Value>PACKBITS</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_JPEG )\n        {\n            bHasJPEG = true;\n            osCompressValues +=\n                    \"       <Value>JPEG</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_LZW )\n        {\n            bHasLZW = true;\n            osCompressValues +=\n                    \"       <Value>LZW</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_ADOBE_DEFLATE )\n        {\n            bHasDEFLATE = true;\n            osCompressValues +=\n                    \"       <Value>DEFLATE</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_CCITTRLE )\n        {\n            osCompressValues +=\n                    \"       <Value>CCITTRLE</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_CCITTFAX3 )\n        {\n            osCompressValues +=\n                    \"       <Value>CCITTFAX3</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_CCITTFAX4 )\n        {\n            osCompressValues +=\n                    \"       <Value>CCITTFAX4</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_LZMA )\n        {\n            bHasLZMA = true;\n            osCompressValues +=\n                    \"       <Value>LZMA</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_ZSTD )\n        {\n            bHasZSTD = true;\n            osCompressValues +=\n                    \"       <Value>ZSTD</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_WEBP )\n        {\n            bHasWebP = true;\n            osCompressValues +=\n                    \"       <Value>WEBP</Value>\";\n        }\n    }\n#ifdef HAVE_LERC\n    osCompressValues +=\n                    \"       <Value>LERC</Value>\";\n    osCompressValues +=\n                    \"       <Value>LERC_DEFLATE</Value>\";\n    if( bHasZSTD )\n    {\n        osCompressValues +=\n                    \"       <Value>LERC_ZSTD</Value>\";\n    }\n#endif\n    _TIFFfree( codecs );\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Build full creation option list.                                */\n/* -------------------------------------------------------------------- */\n    osOptions = \"<CreationOptionList>\"\n              \"   <Option name='COMPRESS' type='string-select'>\";\n    osOptions += osCompressValues;\n    osOptions += \"   </Option>\";\n    if( bHasLZW || bHasDEFLATE || bHasZSTD )\n        osOptions += \"\"\n\"   <Option name='PREDICTOR' type='int' description='Predictor Type (1=default, 2=horizontal differencing, 3=floating point prediction)'/>\";\n    osOptions += \"\"\n\"   <Option name='DISCARD_LSB' type='string' description='Number of least-significant bits to set to clear as a single value or comma-separated list of values for per-band values'/>\";\n    if( bHasJPEG )\n    {\n        osOptions += \"\"\n\"   <Option name='JPEG_QUALITY' type='int' description='JPEG quality 1-100' default='75'/>\"\n\"   <Option name='JPEGTABLESMODE' type='int' description='Content of JPEGTABLES tag. 0=no JPEGTABLES tag, 1=Quantization tables only, 2=Huffman tables only, 3=Both' default='1'/>\";\n#ifdef JPEG_DIRECT_COPY\n        osOptions += \"\"\n\"   <Option name='JPEG_DIRECT_COPY' type='boolean' description='To copy without any decompression/recompression a JPEG source file' default='NO'/>\";\n#endif\n    }\n    if( bHasDEFLATE )\n        osOptions += \"\"\n\"   <Option name='ZLEVEL' type='int' description='DEFLATE compression level 1-9' default='6'/>\";\n    if( bHasLZMA )\n        osOptions += \"\"\n\"   <Option name='LZMA_PRESET' type='int' description='LZMA compression level 0(fast)-9(slow)' default='6'/>\";\n    if( bHasZSTD )\n        osOptions += \"\"\n\"   <Option name='ZSTD_LEVEL' type='int' description='ZSTD compression level 1(fast)-22(slow)' default='9'/>\";\n#ifdef HAVE_LERC\n    osOptions += \"\"\n\"   <Option name='MAX_Z_ERROR' type='float' description='Maximum error for LERC compression' default='0'/>\";\n#endif\n    if ( bHasWebP )\n    {\n      osOptions += \"\"\n#if WEBP_ENCODER_ABI_VERSION >= 0x0100\n\"   <Option name='WEBP_LOSSLESS' type='boolean' description='Whether lossless compression should be used' default='FALSE'/>\"\n#endif\n\"   <Option name='WEBP_LEVEL' type='int' description='WEBP quality level. Low values result in higher compression ratios' default='75'/>\";\n    }\n    osOptions += \"\"\n\"   <Option name='NUM_THREADS' type='string' description='Number of worker threads for compression. Can be set to ALL_CPUS' default='1'/>\"\n\"   <Option name='NBITS' type='int' description='BITS for sub-byte files (1-7), sub-uint16 (9-15), sub-uint32 (17-31), or float32 (16)'/>\"\n\"   <Option name='INTERLEAVE' type='string-select' default='PIXEL'>\"\n\"       <Value>BAND</Value>\"\n\"       <Value>PIXEL</Value>\"\n\"   </Option>\"\n\"   <Option name='TILED' type='boolean' description='Switch to tiled format'/>\"\n\"   <Option name='TFW' type='boolean' description='Write out world file'/>\"\n\"   <Option name='RPB' type='boolean' description='Write out .RPB (RPC) file'/>\"\n\"   <Option name='RPCTXT' type='boolean' description='Write out _RPC.TXT file'/>\"\n\"   <Option name='BLOCKXSIZE' type='int' description='Tile Width'/>\"\n\"   <Option name='BLOCKYSIZE' type='int' description='Tile/Strip Height'/>\"\n\"   <Option name='PHOTOMETRIC' type='string-select'>\"\n\"       <Value>MINISBLACK</Value>\"\n\"       <Value>MINISWHITE</Value>\"\n\"       <Value>PALETTE</Value>\"\n\"       <Value>RGB</Value>\"\n\"       <Value>CMYK</Value>\"\n\"       <Value>YCBCR</Value>\"\n\"       <Value>CIELAB</Value>\"\n\"       <Value>ICCLAB</Value>\"\n\"       <Value>ITULAB</Value>\"\n\"   </Option>\"\n\"   <Option name='SPARSE_OK' type='boolean' description='Should empty blocks be omitted on disk?' default='FALSE'/>\"\n\"   <Option name='ALPHA' type='string-select' description='Mark first extrasample as being alpha'>\"\n\"       <Value>NON-PREMULTIPLIED</Value>\"\n\"       <Value>PREMULTIPLIED</Value>\"\n\"       <Value>UNSPECIFIED</Value>\"\n\"       <Value aliasOf='NON-PREMULTIPLIED'>YES</Value>\"\n\"       <Value aliasOf='UNSPECIFIED'>NO</Value>\"\n\"   </Option>\"\n\"   <Option name='PROFILE' type='string-select' default='GDALGeoTIFF'>\"\n\"       <Value>GDALGeoTIFF</Value>\"\n\"       <Value>GeoTIFF</Value>\"\n\"       <Value>BASELINE</Value>\"\n\"   </Option>\"\n\"   <Option name='PIXELTYPE' type='string-select'>\"\n\"       <Value>DEFAULT</Value>\"\n\"       <Value>SIGNEDBYTE</Value>\"\n\"   </Option>\"\n#ifdef BIGTIFF_SUPPORT\n\"   <Option name='BIGTIFF' type='string-select' description='Force creation of BigTIFF file'>\"\n\"     <Value>YES</Value>\"\n\"     <Value>NO</Value>\"\n\"     <Value>IF_NEEDED</Value>\"\n\"     <Value>IF_SAFER</Value>\"\n\"   </Option>\"\n#endif\n\"   <Option name='ENDIANNESS' type='string-select' default='NATIVE' description='Force endianness of created file. For DEBUG purpose mostly'>\"\n\"       <Value>NATIVE</Value>\"\n\"       <Value>INVERTED</Value>\"\n\"       <Value>LITTLE</Value>\"\n\"       <Value>BIG</Value>\"\n\"   </Option>\"\n\"   <Option name='COPY_SRC_OVERVIEWS' type='boolean' default='NO' description='Force copy of overviews of source dataset (CreateCopy())'/>\"\n\"   <Option name='SOURCE_ICC_PROFILE' type='string' description='ICC profile'/>\"\n\"   <Option name='SOURCE_PRIMARIES_RED' type='string' description='x,y,1.0 (xyY) red chromaticity'/>\"\n\"   <Option name='SOURCE_PRIMARIES_GREEN' type='string' description='x,y,1.0 (xyY) green chromaticity'/>\"\n\"   <Option name='SOURCE_PRIMARIES_BLUE' type='string' description='x,y,1.0 (xyY) blue chromaticity'/>\"\n\"   <Option name='SOURCE_WHITEPOINT' type='string' description='x,y,1.0 (xyY) whitepoint'/>\"\n\"   <Option name='TIFFTAG_TRANSFERFUNCTION_RED' type='string' description='Transfer function for red'/>\"\n\"   <Option name='TIFFTAG_TRANSFERFUNCTION_GREEN' type='string' description='Transfer function for green'/>\"\n\"   <Option name='TIFFTAG_TRANSFERFUNCTION_BLUE' type='string' description='Transfer function for blue'/>\"\n\"   <Option name='TIFFTAG_TRANSFERRANGE_BLACK' type='string' description='Transfer range for black'/>\"\n\"   <Option name='TIFFTAG_TRANSFERRANGE_WHITE' type='string' description='Transfer range for white'/>\"\n\"   <Option name='STREAMABLE_OUTPUT' type='boolean' default='NO' description='Enforce a mode compatible with a streamable file'/>\"\n\"   <Option name='GEOTIFF_KEYS_FLAVOR' type='string-select' default='STANDARD' description='Which flavor of GeoTIFF keys must be used'>\"\n\"       <Value>STANDARD</Value>\"\n\"       <Value>ESRI_PE</Value>\"\n\"   </Option>\"\n\"</CreationOptionList>\";\n\n/* -------------------------------------------------------------------- */\n/*      Set the driver details.                                         */\n/* -------------------------------------------------------------------- */\n    poDriver->SetDescription( \"GTiff\" );\n    poDriver->SetMetadataItem( GDAL_DCAP_RASTER, \"YES\" );\n    poDriver->SetMetadataItem( GDAL_DMD_LONGNAME, \"GeoTIFF\" );\n    poDriver->SetMetadataItem( GDAL_DMD_HELPTOPIC, \"frmt_gtiff.html\" );\n    poDriver->SetMetadataItem( GDAL_DMD_MIMETYPE, \"image/tiff\" );\n    poDriver->SetMetadataItem( GDAL_DMD_EXTENSION, \"tif\" );\n    poDriver->SetMetadataItem( GDAL_DMD_EXTENSIONS, \"tif tiff\" );\n    poDriver->SetMetadataItem( GDAL_DMD_CREATIONDATATYPES,\n                               \"Byte UInt16 Int16 UInt32 Int32 Float32 \"\n                               \"Float64 CInt16 CInt32 CFloat32 CFloat64\" );\n    poDriver->SetMetadataItem( GDAL_DMD_CREATIONOPTIONLIST, osOptions );\n    poDriver->SetMetadataItem( GDAL_DMD_OPENOPTIONLIST,\n\"<OpenOptionList>\"\n\"   <Option name='NUM_THREADS' type='string' description='Number of worker threads for compression. Can be set to ALL_CPUS' default='1'/>\"\n\"   <Option name='GEOTIFF_KEYS_FLAVOR' type='string-select' default='STANDARD' description='Which flavor of GeoTIFF keys must be used (for writing)'>\"\n\"       <Value>STANDARD</Value>\"\n\"       <Value>ESRI_PE</Value>\"\n\"   </Option>\"\n\"   <Option name='GEOREF_SOURCES' type='string' description='Comma separated list made with values INTERNAL/TABFILE/WORLDFILE/PAM/NONE that describe the priority order for georeferencing' default='PAM,INTERNAL,TABFILE,WORLDFILE'/>\"\n\"   <Option name='SPARSE_OK' type='boolean' description='Should empty blocks be omitted on disk?' default='FALSE'/>\"\n\"</OpenOptionList>\" );\n    poDriver->SetMetadataItem( GDAL_DMD_SUBDATASETS, \"YES\" );\n    poDriver->SetMetadataItem( GDAL_DCAP_VIRTUALIO, \"YES\" );\n\n#ifdef INTERNAL_LIBTIFF\n    poDriver->SetMetadataItem( \"LIBTIFF\", \"INTERNAL\" );\n#else\n    poDriver->SetMetadataItem( \"LIBTIFF\", TIFFLIB_VERSION_STR );\n#endif\n\n    poDriver->pfnOpen = GTiffDataset::Open;\n    poDriver->pfnCreate = GTiffDataset::Create;\n    poDriver->pfnCreateCopy = GTiffDataset::CreateCopy;\n    poDriver->pfnUnloadDriver = GDALDeregister_GTiff;\n    poDriver->pfnIdentify = GTiffDataset::Identify;\n\n    GetGDALDriverManager()->RegisterDriver( poDriver );\n}\n",
                "name": "geotiff.cpp",
                "path": "deps/libgdal/gdal/frmts/gtiff/geotiff.cpp",
                "url": "/github.com/naturalatlas/node-gdal/-/blob/deps/libgdal/gdal/frmts/gtiff/geotiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 5960,
                    "offsetAndLengths": [
                        [
                            16,
                            19
                        ]
                    ],
                    "preview": "            if( TIFFReadRGBATileExt("
                }
            ],
            "repository": {
                "name": "github.com/naturalatlas/node-gdal",
                "url": "/github.com/naturalatlas/node-gdal"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "123c2fbef73b431e42d3d0294f94ed862bbc83d9"
                },
                "content": "/******************************************************************************\n *\n * Project:  GeoTIFF Driver\n * Purpose:  GDAL GeoTIFF support.\n * Author:   Frank Warmerdam, warmerdam@pobox.com\n *\n ******************************************************************************\n * Copyright (c) 1998, 2002, Frank Warmerdam <warmerdam@pobox.com>\n * Copyright (c) 2007-2015, Even Rouault <even dot rouault at spatialys dot com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ****************************************************************************/\n\n// If we use sunpro compiler on linux. Weird idea indeed!\n#if defined(__SUNPRO_CC) && defined(__linux__)\n#define _GNU_SOURCE\n#elif defined(__GNUC__) && !defined(_GNU_SOURCE)\n// Required to use RTLD_DEFAULT of dlfcn.h.\n#define _GNU_SOURCE\n#endif\n\n#include \"cpl_port.h\"  // Must be first.\n#include \"gtiff.h\"\n\n#include <cassert>\n#include <cerrno>\n#include <climits>\n#include <cmath>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#if HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#if HAVE_SYS_STAT_H\n#  include <sys/stat.h>\n#endif\n\n#include <algorithm>\n#include <map>\n#include <memory>\n#include <mutex>\n#include <set>\n#include <string>\n#include <queue>\n#include <utility>\n#include <vector>\n\n#include \"cpl_config.h\"\n#include \"cpl_conv.h\"\n#include \"cpl_error.h\"\n#include \"cpl_error_internal.h\"\n#include \"cpl_mem_cache.h\"\n#include \"cpl_minixml.h\"\n#include \"cpl_multiproc.h\"\n#include \"cpl_port.h\"\n#include \"cpl_progress.h\"\n#include \"cpl_string.h\"\n#include \"cpl_virtualmem.h\"\n#include \"cpl_vsi.h\"\n#include \"cpl_vsi_virtual.h\"\n#include \"cpl_worker_thread_pool.h\"\n#include \"cplkeywordparser.h\"\n#include \"gdal.h\"\n#include \"gdal_frmts.h\"\n#include \"gdal_mdreader.h\"\n#include \"gdal_pam.h\"\n#include \"gdal_priv.h\"\n#include \"gdal_priv_templates.hpp\"\n#include \"gdal_thread_pool.h\"\n#include \"geo_normalize.h\"\n#include \"geotiff.h\"\n#include \"geovalues.h\"\n#include \"gt_jpeg_copy.h\"\n#include \"gt_overview.h\"\n#include \"gt_wkt_srs.h\"\n#include \"gt_wkt_srs_priv.h\"\n#include \"ogr_spatialref.h\"\n#include \"ogr_proj_p.h\"\n#include \"tiff.h\"\n#include \"tif_float.h\"\n#include \"tiffio.h\"\n#ifdef INTERNAL_LIBTIFF\n#  include \"tif_lerc.h\"\n#endif\n#include \"tiffvers.h\"\n#include \"tifvsi.h\"\n#include \"xtiffio.h\"\n\nCPL_CVSID(\"$Id: geotiff.cpp 9e52ad241bade9e0b989281f186f01e8a17106de 2020-10-19 14:27:54 +0200 Even Rouault $\")\n\nstatic bool bGlobalInExternalOvr = false;\n\n// Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if TIFFLIB_VERSION >= 20120922\n#define SUPPORTS_MORE_THAN_32768_DIRECTORIES\n#endif\n\n#if TIFFLIB_VERSION > 20181110 // > 4.0.10\n#define SUPPORTS_GET_OFFSET_BYTECOUNT\n#endif\n\nconst char* const szJPEGGTiffDatasetTmpPrefix = \"/vsimem/gtiffdataset_jpg_tmp_\";\n\ntypedef enum\n{\n    GTIFFTAGTYPE_STRING,\n    GTIFFTAGTYPE_SHORT,\n    GTIFFTAGTYPE_FLOAT,\n    GTIFFTAGTYPE_BYTE_STRING\n} GTIFFTagTypes;\n\ntypedef struct\n{\n    const char    *pszTagName;\n    int            nTagVal;\n    GTIFFTagTypes  eType;\n} GTIFFTags;\n\nstatic const GTIFFTags asTIFFTags[] =\n{\n    { \"TIFFTAG_DOCUMENTNAME\", TIFFTAG_DOCUMENTNAME, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_IMAGEDESCRIPTION\", TIFFTAG_IMAGEDESCRIPTION,\n        GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_SOFTWARE\", TIFFTAG_SOFTWARE, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_DATETIME\", TIFFTAG_DATETIME, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_ARTIST\", TIFFTAG_ARTIST, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_HOSTCOMPUTER\", TIFFTAG_HOSTCOMPUTER, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_COPYRIGHT\", TIFFTAG_COPYRIGHT, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_XRESOLUTION\", TIFFTAG_XRESOLUTION, GTIFFTAGTYPE_FLOAT },\n    { \"TIFFTAG_YRESOLUTION\", TIFFTAG_YRESOLUTION, GTIFFTAGTYPE_FLOAT },\n    // Dealt as special case.\n    { \"TIFFTAG_RESOLUTIONUNIT\", TIFFTAG_RESOLUTIONUNIT, GTIFFTAGTYPE_SHORT },\n    { \"TIFFTAG_MINSAMPLEVALUE\", TIFFTAG_MINSAMPLEVALUE, GTIFFTAGTYPE_SHORT },\n    { \"TIFFTAG_MAXSAMPLEVALUE\", TIFFTAG_MAXSAMPLEVALUE, GTIFFTAGTYPE_SHORT },\n\n    // GeoTIFF DGIWG tags\n    { \"GEO_METADATA\", TIFFTAG_GEO_METADATA, GTIFFTAGTYPE_BYTE_STRING },\n    { \"TIFF_RSID\", TIFFTAG_TIFF_RSID, GTIFFTAGTYPE_STRING },\n};\n\nconst char szPROFILE_BASELINE[] = \"BASELINE\";\nconst char szPROFILE_GeoTIFF[] = \"GeoTIFF\";\nconst char szPROFILE_GDALGeoTIFF[] = \"GDALGeoTIFF\";\n\n/************************************************************************/\n/*                          GTIFFSetInExternalOvr()                     */\n/************************************************************************/\n\nvoid GTIFFSetInExternalOvr( bool b )\n{\n    bGlobalInExternalOvr = b;\n}\n\n/************************************************************************/\n/*                     GTIFFGetOverviewBlockSize()                      */\n/************************************************************************/\n\nvoid GTIFFGetOverviewBlockSize( GDALRasterBandH hBand, int* pnBlockXSize, int* pnBlockYSize )\n{\n    const char* pszVal = CPLGetConfigOption(\"GDAL_TIFF_OVR_BLOCKSIZE\", nullptr);\n    if( ! pszVal )\n    {\n        GDALRasterBand* const poBand = GDALRasterBand::FromHandle(hBand);\n        poBand->GetBlockSize(pnBlockXSize,pnBlockYSize);\n        if ( *pnBlockXSize != *pnBlockYSize ||\n             *pnBlockXSize < 64 || *pnBlockXSize > 4096 ||\n             !CPLIsPowerOfTwo(*pnBlockXSize) )\n        {\n            *pnBlockXSize=*pnBlockYSize=128;\n        }\n    }\n    else\n    {\n        int nOvrBlockSize = atoi(pszVal);\n        if( nOvrBlockSize < 64 || nOvrBlockSize > 4096 ||\n            !CPLIsPowerOfTwo(nOvrBlockSize) )\n        {\n            static bool bHasWarned = false;\n            if( !bHasWarned )\n            {\n                CPLError( CE_Warning, CPLE_NotSupported,\n                          \"Wrong value for GDAL_TIFF_OVR_BLOCKSIZE : %s. \"\n                          \"Should be a power of 2 between 64 and 4096. \"\n                          \"Defaulting to 128\",\n                          pszVal );\n                bHasWarned = true;\n            }\n            nOvrBlockSize = 128;\n        }\n\n        *pnBlockXSize = nOvrBlockSize;\n        *pnBlockYSize = nOvrBlockSize;\n    }\n}\n\nenum\n{\n    ENDIANNESS_NATIVE,\n    ENDIANNESS_LITTLE,\n    ENDIANNESS_BIG\n};\n\n/************************************************************************/\n/* ==================================================================== */\n/*                          GTiffDataset                                */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffBitmapBand;\nclass GTiffDataset;\nclass GTiffJPEGOverviewBand;\nclass GTiffJPEGOverviewDS;\nclass GTiffRasterBand;\nclass GTiffRGBABand;\n\n#if !defined(__MINGW32__)\nnamespace {\n#endif\ntypedef struct\n{\n    GTiffDataset *poDS;\n    char         *pszTmpFilename;\n    GByte        *pabyBuffer;\n    GByte        *pabyCompressedBuffer;  // Owned by pszTmpFilename.\n    GPtrDiff_t    nBufferSize;\n    GPtrDiff_t    nCompressedBufferSize;\n    int           nHeight;\n    int           nStripOrTile;\n    uint16        nPredictor;\n    bool          bTIFFIsBigEndian;\n    bool          bReady;\n} GTiffCompressionJob;\n#if !defined(__MINGW32__)\n}\n#endif\n\nenum class GTiffProfile: GByte\n{\n    BASELINE,\n    GEOTIFF,\n    GDALGEOTIFF\n};\n\nclass GTiffDataset final : public GDALPamDataset\n{\npublic:\n    struct MaskOffset\n    {\n        int nMask;\n        int nOffset;\n    };\n\nprivate:\n    CPL_DISALLOW_COPY_ASSIGN(GTiffDataset)\n\n    friend class GTiffBitmapBand;\n    friend class GTiffJPEGOverviewDS;\n    friend class GTiffJPEGOverviewBand;\n    friend class GTiffOddBitsBand;\n    friend class GTiffRasterBand;\n    friend class GTiffRGBABand;\n    friend class GTiffSplitBand;\n    friend class GTiffSplitBitmapBand;\n\n    friend void  GTIFFSetJpegQuality( GDALDatasetH hGTIFFDS, int nJpegQuality );\n    friend void  GTIFFSetJpegTablesMode( GDALDatasetH hGTIFFDS, int nJpegTablesMode );\n    friend void  GTIFFSetWebPLevel( GDALDatasetH hGTIFFDS, int nWebPLevel );\n\n    TIFF                 *m_hTIFF = nullptr;\n    VSILFILE             *m_fpL = nullptr;\n    VSILFILE             *m_fpToWrite = nullptr;\n    GTiffDataset        **m_papoOverviewDS = nullptr;\n    GTiffDataset         *m_poMaskDS = nullptr; // For a non-mask dataset, points to the corresponding (internal) mask\n    GDALDataset          *m_poExternalMaskDS = nullptr; // Points to a dataset within m_poMaskExtOvrDS\n    GTiffDataset         *m_poImageryDS = nullptr; // For a mask dataset, points to the corresponding imagery dataset\n    GTiffDataset         *m_poBaseDS = nullptr; // For an overview or mask dataset, points to the root dataset\n    std::unique_ptr<GDALDataset> m_poMaskExtOvrDS{}; // Used with MASK_OVERVIEW_DATASET open option\n    GTiffJPEGOverviewDS **m_papoJPEGOverviewDS = nullptr;\n    GDAL_GCP             *m_pasGCPList = nullptr;\n    GDALColorTable       *m_poColorTable = nullptr;\n    char                **m_papszMetadataFiles = nullptr;\n    GByte                *m_pabyBlockBuf = nullptr;\n    char                **m_papszCreationOptions = nullptr;\n    void                 *m_pabyTempWriteBuffer = nullptr;\n    CPLVirtualMem        *m_pBaseMapping = nullptr;\n    GByte                *m_pTempBufferForCommonDirectIO = nullptr;\n    CPLVirtualMem        *m_psVirtualMemIOMapping = nullptr;\n    std::unique_ptr<CPLJobQueue> m_poCompressQueue{};\n    CPLMutex             *m_hCompressThreadPoolMutex = nullptr;\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    lru11::Cache<int, std::pair<vsi_l_offset, vsi_l_offset>> m_oCacheStrileToOffsetByteCount{1024};\n#endif\n\n    MaskOffset* m_panMaskOffsetLsb = nullptr;\n    char       *m_pszVertUnit = nullptr;\n    char       *m_pszFilename = nullptr;\n    char       *m_pszTmpFilename = nullptr;\n    char       *m_pszGeorefFilename = nullptr;\n\n    double      m_adfGeoTransform[6]{0,1,0,0,0,1};\n#if HAVE_LERC\n    double      m_dfMaxZError = 0.0;\n    uint32      m_anLercAddCompressionAndVersion[2]{0,0};\n#endif\n    double      m_dfNoDataValue = -9999.0;\n\n    toff_t      m_nDirOffset = 0;\n\n    int         m_nBlocksPerBand = 0;\n    int         m_nBlockXSize = 0;\n    int         m_nBlockYSize = 0;\n    int         m_nLoadedBlock = -1;  // Or tile, or scanline\n    uint32      m_nRowsPerStrip = 0;\n    int         m_nLastBandRead = -1; // Used for the all-in-on-strip case.\n    int         m_nLastWrittenBlockId = -1; // used for m_bStreamingOut\n    int         m_nRefBaseMapping = 0;\n    int         m_nGCPCount = 0;\n\n    GTIFFKeysFlavorEnum m_eGeoTIFFKeysFlavor = GEOTIFF_KEYS_STANDARD;\n    GeoTIFFVersionEnum m_eGeoTIFFVersion = GEOTIFF_VERSION_AUTO;\n\n    uint16      m_nPlanarConfig = 0;\n    uint16      m_nSamplesPerPixel = 0;\n    uint16      m_nBitsPerSample = 0;\n    uint16      m_nPhotometric = 0;\n    uint16      m_nSampleFormat = 0;\n    uint16      m_nCompression = 0;\n\n    signed char m_nOverviewCount = 0;\n\n    // If > 0, the implicit JPEG overviews are visible through\n    // GetOverviewCount().\n    signed char m_nJPEGOverviewVisibilityCounter = 0;\n    // Currently visible overviews. Generally == nJPEGOverviewCountOri.\n    signed char m_nJPEGOverviewCount = -1;\n    signed char m_nJPEGOverviewCountOri = 0;  // Size of papoJPEGOverviewDS.\n    signed char m_nPAMGeorefSrcIndex = -1;\n    signed char m_nINTERNALGeorefSrcIndex = -1;\n    signed char m_nTABFILEGeorefSrcIndex = -1;\n    signed char m_nWORLDFILEGeorefSrcIndex = -1;\n    signed char m_nGeoTransformGeorefSrcIndex = -1;\n\n    signed char m_nHasOptimizedReadMultiRange = -1;\n\n    signed char m_nZLevel = -1;\n    signed char m_nLZMAPreset = -1;\n    signed char m_nZSTDLevel = -1;\n    signed char m_nWebPLevel = -1;\n    signed char m_nJpegQuality = -1;\n    signed char m_nJpegTablesMode = -1;\n\n    enum class VirtualMemIOEnum: GByte\n    {\n        NO,\n        YES,\n        IF_ENOUGH_RAM\n    };\n\n    VirtualMemIOEnum m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n\n    GTiffProfile m_eProfile = GTiffProfile::GDALGEOTIFF;\n\n    OGRSpatialReference m_oSRS{};\n\n    GDALMultiDomainMetadata m_oGTiffMDMD{};\n\n    std::vector<GTiffCompressionJob> m_asCompressionJobs{};\n    std::queue<int> m_asQueueJobIdx{}; // queue of index of m_asCompressionJobs being compressed in worker threads\n\n    bool        m_bStreamingIn:1;\n    bool        m_bStreamingOut:1;\n    bool        m_bScanDeferred:1;\n    bool        m_bSingleIFDOpened = false;\n    bool        m_bLoadedBlockDirty:1;\n    bool        m_bWriteError:1;\n    bool        m_bLookedForProjection:1;\n    bool        m_bLookedForMDAreaOrPoint:1;\n    bool        m_bGeoTransformValid:1;\n    bool        m_bCrystalized:1;\n    bool        m_bGeoTIFFInfoChanged:1;\n    bool        m_bForceUnsetGTOrGCPs:1;\n    bool        m_bForceUnsetProjection:1;\n    bool        m_bNoDataChanged:1;\n    bool        m_bNoDataSet:1;\n    bool        m_bMetadataChanged:1;\n    bool        m_bColorProfileMetadataChanged:1;\n    bool        m_bForceUnsetRPC:1;\n    bool        m_bNeedsRewrite:1;\n    bool        m_bLoadingOtherBands:1;\n    bool        m_bIsOverview:1;\n    bool        m_bWriteEmptyTiles:1;\n    bool        m_bFillEmptyTilesAtClosing:1;\n    bool        m_bTreatAsSplit:1;\n    bool        m_bTreatAsSplitBitmap:1;\n    bool        m_bClipWarn:1;\n    bool        m_bIMDRPCMetadataLoaded:1;\n    bool        m_bEXIFMetadataLoaded:1;\n    bool        m_bICCMetadataLoaded:1;\n    bool        m_bHasWarnedDisableAggressiveBandCaching:1;\n    bool        m_bDontReloadFirstBlock:1;  // Hack for libtiff 3.X and #3633.\n    bool        m_bWebPLossless:1;\n    bool        m_bPromoteTo8Bits:1;\n    bool        m_bDebugDontWriteBlocks:1;\n    bool        m_bIsFinalized:1;\n    bool        m_bIgnoreReadErrors:1;\n    bool        m_bDirectIO:1;\n    bool        m_bReadGeoTransform:1;\n    bool        m_bLoadPam:1;\n    bool        m_bHasGotSiblingFiles:1;\n    bool        m_bHasIdentifiedAuthorizedGeoreferencingSources:1;\n    bool        m_bLayoutIFDSBeforeData:1;\n    bool        m_bBlockOrderRowMajor:1;\n    bool        m_bLeaderSizeAsUInt4:1;\n    bool        m_bTrailerRepeatedLast4BytesRepeated:1;\n    bool        m_bMaskInterleavedWithImagery:1;\n    bool        m_bKnownIncompatibleEdition:1;\n    bool        m_bWriteKnownIncompatibleEdition:1;\n    bool        m_bHasUsedReadEncodedAPI:1; // for debugging\n    bool        m_bWriteCOGLayout:1;\n\n    void        ScanDirectories();\n    bool        ReadStrile(int nBlockId,\n                           void* pOutputBuffer, GPtrDiff_t nBlockReqSize);\n    CPLErr      LoadBlockBuf( int nBlockId, bool bReadFromDisk = true );\n    CPLErr      FlushBlockBuf();\n\n    void        LoadMDAreaOrPoint();\n    void        LookForProjection();\n#ifdef ESRI_BUILD\n    void        AdjustLinearUnit( short UOMLength );\n#endif\n\n    void        Crystalize();  // TODO: Spelling.\n    void        RestoreVolatileParameters(TIFF* hTIFF);\n\n    void        WriteGeoTIFFInfo();\n    bool        SetDirectory();\n    void        ReloadDirectory();\n\n    int         GetJPEGOverviewCount();\n\n    bool        IsBlockAvailable( int nBlockId,\n                                  vsi_l_offset* pnOffset = nullptr,\n                                  vsi_l_offset* pnSize = nullptr,\n                                  bool *pbErrOccurred = nullptr );\n\n    void        ApplyPamInfo();\n    void        PushMetadataToPam();\n\n    bool         WriteEncodedTile( uint32 tile, GByte* pabyData,\n                                   int bPreserveDataBuffer );\n    bool         WriteEncodedStrip( uint32 strip, GByte* pabyData,\n                                    int bPreserveDataBuffer );\n    template<class T>\n    bool         HasOnlyNoDataT( const T* pBuffer, int nWidth, int nHeight,\n                                int nLineStride, int nComponents ) const;\n    bool         HasOnlyNoData( const void* pBuffer, int nWidth, int nHeight,\n                                int nLineStride, int nComponents );\n    inline bool  IsFirstPixelEqualToNoData( const void* pBuffer );\n\n    void         FillEmptyTiles();\n\n    void         FlushDirectory();\n    CPLErr       CleanOverviews();\n\n    void          LoadMetadata();\n    void          LoadEXIFMetadata();\n    void          LoadICCProfile();\n\n    CPLErr        RegisterNewOverviewDataset( toff_t nOverviewOffset, int l_nJpegQuality,\n                                              int l_nWebPLevel );\n    CPLErr        CreateOverviewsFromSrcOverviews( GDALDataset* poSrcDS,\n                                                   GDALDataset* poOvrDS );\n    CPLErr        CreateInternalMaskOverviews( int nOvrBlockXSize,\n                                               int nOvrBlockYSize );\n    int           Finalize();\n\n    void           DiscardLsb(GByte* pabyBuffer, GPtrDiff_t nBytes, int iBand) const;\n    void           GetDiscardLsbOption( char** papszOptions );\n    void           InitCompressionThreads( char** papszOptions );\n    void           InitCreationOrOpenOptions( char** papszOptions );\n    static void    ThreadCompressionFunc( void* pData );\n    void           WaitCompletionForJobIdx( int i );\n    void           WaitCompletionForBlock( int nBlockId );\n    void           WriteRawStripOrTile( int nStripOrTile,\n                                        GByte* pabyCompressedBuffer,\n                                        GPtrDiff_t nCompressedBufferSize );\n    bool           SubmitCompressionJob( int nStripOrTile, GByte* pabyData,\n                                         GPtrDiff_t cc, int nHeight) ;\n\n    int            GuessJPEGQuality( bool& bOutHasQuantizationTable,\n                                     bool& bOutHasHuffmanTable );\n\n    void           SetJPEGQualityAndTablesModeFromFile();\n\n    int            DirectIO( GDALRWFlag eRWFlag,\n                             int nXOff, int nYOff, int nXSize, int nYSize,\n                             void * pData, int nBufXSize, int nBufYSize,\n                             GDALDataType eBufType,\n                             int nBandCount, int *panBandMap,\n                             GSpacing nPixelSpace, GSpacing nLineSpace,\n                             GSpacing nBandSpace,\n                             GDALRasterIOExtraArg* psExtraArg );\n\n    int            VirtualMemIO( GDALRWFlag eRWFlag,\n                                 int nXOff, int nYOff, int nXSize, int nYSize,\n                                 void * pData, int nBufXSize, int nBufYSize,\n                                 GDALDataType eBufType,\n                                 int nBandCount, int *panBandMap,\n                                 GSpacing nPixelSpace, GSpacing nLineSpace,\n                                 GSpacing nBandSpace,\n                                 GDALRasterIOExtraArg* psExtraArg );\n\n    void            SetStructuralMDFromParent(GTiffDataset* poParentDS);\n\n    template<class FetchBuffer> CPLErr CommonDirectIO(\n        FetchBuffer& oFetcher,\n        int nXOff, int nYOff, int nXSize, int nYSize,\n        void * pData, int nBufXSize, int nBufYSize,\n        GDALDataType eBufType,\n        int nBandCount, int *panBandMap,\n        GSpacing nPixelSpace, GSpacing nLineSpace,\n        GSpacing nBandSpace );\n\n    void        LoadGeoreferencingAndPamIfNeeded();\n\n    char      **GetSiblingFiles();\n\n    void        IdentifyAuthorizedGeoreferencingSources();\n\n    void        FlushCacheInternal( bool bFlushDirectory );\n    bool        HasOptimizedReadMultiRange();\n\n    bool        AssociateExternalMask();\n\n    static bool MustCreateInternalMask();\n\n    static CPLErr CopyImageryAndMask(GTiffDataset* poDstDS,\n                                     GDALDataset* poSrcDS,\n                                     GDALRasterBand* poSrcMaskBand,\n                                     GDALProgressFunc pfnProgress,\n                                     void * pProgressData);\n\n  protected:\n    virtual int         CloseDependentDatasets() override;\n\n  public:\n             GTiffDataset();\n    virtual ~GTiffDataset();\n\n    const OGRSpatialReference* GetSpatialRef() const override;\n    CPLErr SetSpatialRef(const OGRSpatialReference* poSRS) override;\n\n    virtual CPLErr GetGeoTransform( double * ) override;\n    virtual CPLErr SetGeoTransform( double * ) override;\n\n    virtual int    GetGCPCount() override;\n    const OGRSpatialReference* GetGCPSpatialRef() const override;\n    virtual const GDAL_GCP *GetGCPs() override;\n    CPLErr SetGCPs( int nGCPCountIn, const GDAL_GCP *pasGCPListIn,\n                    const OGRSpatialReference* poSRS ) override;\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              int nBandCount, int *panBandMap,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GSpacing nBandSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override;\n    virtual char **GetFileList() override;\n\n    virtual CPLErr IBuildOverviews( const char *, int, int *, int, int *,\n                                    GDALProgressFunc, void * ) override;\n\n    CPLErr         OpenOffset( TIFF *,\n                               toff_t nDirOffset, GDALAccess,\n                               bool bAllowRGBAInterface = true,\n                               bool bReadGeoTransform = false );\n\n    static GDALDataset *OpenDir( GDALOpenInfo * );\n    static GDALDataset *Open( GDALOpenInfo * );\n    static int          Identify( GDALOpenInfo * );\n    static GDALDataset *Create( const char * pszFilename,\n                                int nXSize, int nYSize, int nBands,\n                                GDALDataType eType, char ** papszParmList );\n    static GDALDataset *CreateCopy( const char * pszFilename,\n                                    GDALDataset *poSrcDS,\n                                    int bStrict, char ** papszOptions,\n                                    GDALProgressFunc pfnProgress,\n                                    void * pProgressData );\n    virtual void    FlushCache() override;\n\n    virtual char  **GetMetadataDomainList() override;\n    virtual CPLErr  SetMetadata( char **, const char * = \"\" ) override;\n    virtual char  **GetMetadata( const char * pszDomain = \"\" ) override;\n    virtual CPLErr  SetMetadataItem( const char*, const char*,\n                                     const char* = \"\" ) override;\n    virtual const char *GetMetadataItem( const char * pszName,\n                                         const char * pszDomain = \"\" ) override;\n    virtual void   *GetInternalHandle( const char * ) override;\n\n    virtual CPLErr          CreateMaskBand( int nFlags ) override;\n\n    bool GetRawBinaryLayout(GDALDataset::RawBinaryLayout&) override;\n\n    // Only needed by createcopy and close code.\n    static void     WriteRPC( GDALDataset *, TIFF *, int, GTiffProfile, \n                              const char *, char **,\n                              bool bWriteOnlyInPAMIfNeeded = false );\n    static bool     WriteMetadata( GDALDataset *, TIFF *, bool, GTiffProfile,\n                                   const char *, char **,\n                                   bool bExcludeRPBandIMGFileWriting = false );\n    static void     WriteNoDataValue( TIFF *, double );\n    static void     UnsetNoDataValue( TIFF * );\n\n    static TIFF *   CreateLL( const char * pszFilename,\n                              int nXSize, int nYSize, int nBands,\n                              GDALDataType eType,\n                              double dfExtraSpaceForOverviews,\n                              char **papszParmList,\n                              VSILFILE** pfpL,\n                              CPLString& osTmpFilename );\n\n    CPLErr   WriteEncodedTileOrStrip( uint32 tile_or_strip, void* data,\n                                      int bPreserveDataBuffer );\n\n    static void SaveICCProfile( GTiffDataset *pDS, TIFF *hTIFF,\n                                char **papszParmList, uint32 nBitsPerSample );\n};\n\n/************************************************************************/\n/* ==================================================================== */\n/*                        GTiffJPEGOverviewDS                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffJPEGOverviewDS final : public GDALDataset\n{\n    CPL_DISALLOW_COPY_ASSIGN(GTiffJPEGOverviewDS)\n\n    friend class GTiffJPEGOverviewBand;\n    GTiffDataset* m_poParentDS = nullptr;\n    int           m_nOverviewLevel = 0;\n\n    int        m_nJPEGTableSize = 0;\n    GByte     *m_pabyJPEGTable = nullptr;\n    CPLString  m_osTmpFilenameJPEGTable{};\n\n    CPLString    m_osTmpFilename{};\n    GDALDataset* m_poJPEGDS = nullptr;\n    // Valid block id of the parent DS that match poJPEGDS.\n    int          m_nBlockId = -1;\n\n  public:\n    GTiffJPEGOverviewDS( GTiffDataset* poParentDS, int nOverviewLevel,\n                         const void* pJPEGTable, int nJPEGTableSize );\n    virtual ~GTiffJPEGOverviewDS();\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              int nBandCount, int *panBandMap,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GSpacing nBandSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override;\n};\n\nclass GTiffJPEGOverviewBand final : public GDALRasterBand\n{\n  public:\n    GTiffJPEGOverviewBand( GTiffJPEGOverviewDS* poDS, int nBand );\n    virtual ~GTiffJPEGOverviewBand() {}\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                        GTiffJPEGOverviewDS()                         */\n/************************************************************************/\n\nGTiffJPEGOverviewDS::GTiffJPEGOverviewDS( GTiffDataset* poParentDSIn,\n                                          int nOverviewLevelIn,\n                                          const void* pJPEGTable,\n                                          int nJPEGTableSizeIn ) :\n    m_poParentDS(poParentDSIn),\n    m_nOverviewLevel(nOverviewLevelIn),\n    m_nJPEGTableSize(nJPEGTableSizeIn)\n{\n    ShareLockWithParentDataset(poParentDSIn);\n\n    m_osTmpFilenameJPEGTable.Printf(\"/vsimem/jpegtable_%p\", this);\n\n    const GByte abyAdobeAPP14RGB[] = {\n        0xFF, 0xEE, 0x00, 0x0E, 0x41, 0x64, 0x6F, 0x62, 0x65, 0x00,\n        0x64, 0x00, 0x00, 0x00, 0x00, 0x00 };\n    const bool bAddAdobe =\n        m_poParentDS->m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        m_poParentDS->m_nPhotometric != PHOTOMETRIC_YCBCR &&\n        m_poParentDS->nBands == 3;\n    m_pabyJPEGTable =\n        static_cast<GByte*>( CPLMalloc(\n            m_nJPEGTableSize + (bAddAdobe ? sizeof(abyAdobeAPP14RGB) : 0)) );\n    memcpy(m_pabyJPEGTable, pJPEGTable, m_nJPEGTableSize);\n    if( bAddAdobe )\n    {\n        memcpy( m_pabyJPEGTable + m_nJPEGTableSize, abyAdobeAPP14RGB,\n                sizeof(abyAdobeAPP14RGB) );\n        m_nJPEGTableSize += sizeof(abyAdobeAPP14RGB);\n    }\n    CPL_IGNORE_RET_VAL(\n        VSIFCloseL(\n            VSIFileFromMemBuffer(\n                m_osTmpFilenameJPEGTable, m_pabyJPEGTable, m_nJPEGTableSize, TRUE )));\n\n    const int nScaleFactor = 1 << m_nOverviewLevel;\n    nRasterXSize = (m_poParentDS->nRasterXSize + nScaleFactor - 1) / nScaleFactor;\n    nRasterYSize = (m_poParentDS->nRasterYSize + nScaleFactor - 1) / nScaleFactor;\n\n    for( int i = 1; i <= m_poParentDS->nBands; ++i )\n        SetBand(i, new GTiffJPEGOverviewBand(this, i));\n\n    SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    if( m_poParentDS->m_nPhotometric == PHOTOMETRIC_YCBCR )\n        SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\", \"IMAGE_STRUCTURE\" );\n    else\n        SetMetadataItem( \"COMPRESSION\", \"JPEG\", \"IMAGE_STRUCTURE\" );\n}\n\n/************************************************************************/\n/*                       ~GTiffJPEGOverviewDS()                         */\n/************************************************************************/\n\nGTiffJPEGOverviewDS::~GTiffJPEGOverviewDS()\n{\n    if( m_poJPEGDS != nullptr )\n        GDALClose( m_poJPEGDS );\n    VSIUnlink(m_osTmpFilenameJPEGTable);\n    if( !m_osTmpFilename.empty() )\n        VSIUnlink(m_osTmpFilename);\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffJPEGOverviewDS::IRasterIO(\n    GDALRWFlag eRWFlag,\n    int nXOff, int nYOff, int nXSize, int nYSize,\n    void * pData, int nBufXSize, int nBufYSize,\n    GDALDataType eBufType,\n    int nBandCount, int *panBandMap,\n    GSpacing nPixelSpace, GSpacing nLineSpace,\n    GSpacing nBandSpace,\n    GDALRasterIOExtraArg* psExtraArg )\n\n{\n    // For non-single strip JPEG-IN-TIFF, the block based strategy will\n    // be the most efficient one, to avoid decompressing the JPEG content\n    // for each requested band.\n    if( nBandCount > 1 && m_poParentDS->m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        (m_poParentDS->m_nBlockXSize < m_poParentDS->nRasterXSize ||\n         m_poParentDS->m_nBlockYSize > 1) )\n    {\n        return BlockBasedRasterIO( eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                                   pData, nBufXSize, nBufYSize,\n                                   eBufType, nBandCount, panBandMap,\n                                   nPixelSpace, nLineSpace, nBandSpace,\n                                   psExtraArg );\n    }\n\n    return GDALDataset::IRasterIO(\n        eRWFlag, nXOff, nYOff, nXSize, nYSize,\n        pData, nBufXSize, nBufYSize, eBufType,\n        nBandCount, panBandMap, nPixelSpace, nLineSpace, nBandSpace,\n        psExtraArg );\n}\n\n/************************************************************************/\n/*                        GTiffJPEGOverviewBand()                       */\n/************************************************************************/\n\nGTiffJPEGOverviewBand::GTiffJPEGOverviewBand( GTiffJPEGOverviewDS* poDSIn,\n                                              int nBandIn )\n{\n    poDS = poDSIn;\n    nBand = nBandIn;\n    eDataType =\n        poDSIn->m_poParentDS->GetRasterBand(nBandIn)->GetRasterDataType();\n    poDSIn->m_poParentDS->GetRasterBand(nBandIn)->\n        GetBlockSize(&nBlockXSize, &nBlockYSize);\n    const int nScaleFactor = 1 << poDSIn->m_nOverviewLevel;\n    nBlockXSize = (nBlockXSize + nScaleFactor - 1) / nScaleFactor;\n    nBlockYSize = (nBlockYSize + nScaleFactor - 1) / nScaleFactor;\n}\n\n/************************************************************************/\n/*                          IReadBlock()                                */\n/************************************************************************/\n\nCPLErr GTiffJPEGOverviewBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                          void *pImage )\n{\n    GTiffJPEGOverviewDS* m_poGDS = cpl::down_cast<GTiffJPEGOverviewDS *>(poDS);\n\n    // Compute the source block ID.\n    int nBlockId = 0;\n    int nParentBlockXSize, nParentBlockYSize;\n    m_poGDS->m_poParentDS->GetRasterBand(1)->\n        GetBlockSize(&nParentBlockXSize, &nParentBlockYSize);\n    const bool bIsSingleStripAsSplit = (nParentBlockYSize == 1 &&\n                           m_poGDS->m_poParentDS->m_nBlockYSize != nParentBlockYSize);\n    if( !bIsSingleStripAsSplit )\n    {\n        int l_nBlocksPerRow = DIV_ROUND_UP(m_poGDS->m_poParentDS->nRasterXSize,\n                                               m_poGDS->m_poParentDS->m_nBlockXSize);\n        nBlockId = nBlockYOff * l_nBlocksPerRow + nBlockXOff;\n    }\n    if( m_poGDS->m_poParentDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        nBlockId += (nBand-1) * m_poGDS->m_poParentDS->m_nBlocksPerBand;\n    }\n\n    // Make sure it is available.\n    const int nDataTypeSize = GDALGetDataTypeSizeBytes(eDataType);\n    vsi_l_offset nOffset = 0;\n    vsi_l_offset nByteCount = 0;\n    bool bErrOccurred = false;\n    if( !m_poGDS->m_poParentDS->IsBlockAvailable(nBlockId, &nOffset, &nByteCount, &bErrOccurred) )\n    {\n        memset(pImage, 0, static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize * nDataTypeSize );\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n    const int nScaleFactor = 1 << m_poGDS->m_nOverviewLevel;\n    if( m_poGDS->m_poJPEGDS == nullptr || nBlockId != m_poGDS->m_nBlockId )\n    {\n        if( nByteCount < 2 )\n            return CE_Failure;\n        nOffset += 2;  // Skip leading 0xFF 0xF8.\n        nByteCount -= 2;\n\n        // Special case for last strip that might be smaller than other strips\n        // In which case we must invalidate the dataset.\n        TIFF* hTIFF = m_poGDS->m_poParentDS->m_hTIFF;\n        if( !TIFFIsTiled( hTIFF ) && !bIsSingleStripAsSplit &&\n            (nBlockYOff + 1 ==\n                 DIV_ROUND_UP( m_poGDS->m_poParentDS->nRasterYSize,\n                               m_poGDS->m_poParentDS->m_nBlockYSize ) ||\n             (m_poGDS->m_poJPEGDS != nullptr &&\n              m_poGDS->m_poJPEGDS->GetRasterYSize() !=\n              nBlockYSize * nScaleFactor)) )\n        {\n            if( m_poGDS->m_poJPEGDS != nullptr )\n                GDALClose( m_poGDS->m_poJPEGDS );\n            m_poGDS->m_poJPEGDS = nullptr;\n        }\n\n        CPLString osFileToOpen;\n        m_poGDS->m_osTmpFilename.Printf(\"/vsimem/sparse_%p\", m_poGDS);\n        VSILFILE* fp = VSIFOpenL(m_poGDS->m_osTmpFilename, \"wb+\");\n\n        // If the size of the JPEG strip/tile is small enough, we will\n        // read it from the TIFF file and forge a in-memory JPEG file with\n        // the JPEG table followed by the JPEG data.\n        const bool bInMemoryJPEGFile = nByteCount < 256 * 256;\n        if( bInMemoryJPEGFile )\n        {\n            // If the previous file was opened as a /vsisparse/, must re-open.\n            if( m_poGDS->m_poJPEGDS != nullptr &&\n                STARTS_WITH(m_poGDS->m_poJPEGDS->GetDescription(), \"/vsisparse/\") )\n            {\n                GDALClose( m_poGDS->m_poJPEGDS );\n                m_poGDS->m_poJPEGDS = nullptr;\n            }\n            osFileToOpen = m_poGDS->m_osTmpFilename;\n\n            bool bError = false;\n            if( VSIFSeekL(fp, m_poGDS->m_nJPEGTableSize + nByteCount - 1, SEEK_SET)\n                != 0 )\n                bError = true;\n            char ch = 0;\n            if( !bError && VSIFWriteL(&ch, 1, 1, fp) != 1 )\n                bError = true;\n            GByte* pabyBuffer =\n                VSIGetMemFileBuffer( m_poGDS->m_osTmpFilename, nullptr, FALSE);\n            memcpy(pabyBuffer, m_poGDS->m_pabyJPEGTable, m_poGDS->m_nJPEGTableSize);\n            VSILFILE* fpTIF = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n            if( !bError && VSIFSeekL(fpTIF, nOffset, SEEK_SET) != 0 )\n                bError = true;\n            if( VSIFReadL( pabyBuffer + m_poGDS->m_nJPEGTableSize,\n                           static_cast<size_t>(nByteCount), 1, fpTIF) != 1 )\n                bError = true;\n            if( bError )\n            {\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n                return CE_Failure;\n            }\n        }\n        else\n        {\n            // If the JPEG strip/tile is too big (e.g. a single-strip\n            // JPEG-in-TIFF), we will use /vsisparse mechanism to make a\n            // fake JPEG file.\n\n            // Always re-open.\n            GDALClose( m_poGDS->m_poJPEGDS );\n            m_poGDS->m_poJPEGDS = nullptr;\n\n            osFileToOpen =\n                CPLSPrintf(\"/vsisparse/%s\", m_poGDS->m_osTmpFilename.c_str());\n\n            if( VSIFPrintfL(\n                    fp,\n                    \"<VSISparseFile><SubfileRegion>\"\n                    \"<Filename relative='0'>%s</Filename>\"\n                    \"<DestinationOffset>0</DestinationOffset>\"\n                    \"<SourceOffset>0</SourceOffset>\"\n                    \"<RegionLength>%d</RegionLength>\"\n                    \"</SubfileRegion>\"\n                    \"<SubfileRegion>\"\n                    \"<Filename relative='0'>%s</Filename>\"\n                    \"<DestinationOffset>%d</DestinationOffset>\"\n                    \"<SourceOffset>\" CPL_FRMT_GUIB \"</SourceOffset>\"\n                    \"<RegionLength>\" CPL_FRMT_GUIB \"</RegionLength>\"\n                    \"</SubfileRegion></VSISparseFile>\",\n                    m_poGDS->m_osTmpFilenameJPEGTable.c_str(),\n                    static_cast<int>(m_poGDS->m_nJPEGTableSize),\n                    m_poGDS->m_poParentDS->GetDescription(),\n                    static_cast<int>(m_poGDS->m_nJPEGTableSize),\n                    nOffset,\n                    nByteCount) < 0 )\n            {\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n                return CE_Failure;\n            }\n        }\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n\n        if( m_poGDS->m_poJPEGDS == nullptr )\n        {\n            const char* apszDrivers[] = { \"JPEG\", nullptr };\n\n            CPLString osOldVal;\n            if( m_poGDS->m_poParentDS->m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n                m_poGDS->nBands == 4 )\n            {\n                osOldVal =\n                    CPLGetThreadLocalConfigOption(\"GDAL_JPEG_TO_RGB\", \"\");\n                CPLSetThreadLocalConfigOption(\"GDAL_JPEG_TO_RGB\", \"NO\");\n            }\n\n            m_poGDS->m_poJPEGDS =\n                static_cast<GDALDataset *>( GDALOpenEx(\n                    osFileToOpen,\n                    GDAL_OF_RASTER | GDAL_OF_INTERNAL,\n                    apszDrivers, nullptr, nullptr) );\n\n            if( m_poGDS->m_poJPEGDS != nullptr )\n            {\n                // Force all implicit overviews to be available, even for\n                // small tiles.\n                CPLSetThreadLocalConfigOption( \"JPEG_FORCE_INTERNAL_OVERVIEWS\",\n                                               \"YES\");\n                GDALGetOverviewCount(GDALGetRasterBand(m_poGDS->m_poJPEGDS, 1));\n                CPLSetThreadLocalConfigOption( \"JPEG_FORCE_INTERNAL_OVERVIEWS\",\n                                               nullptr);\n\n                m_poGDS->m_nBlockId = nBlockId;\n            }\n\n            if( m_poGDS->m_poParentDS->m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n                m_poGDS->nBands == 4 )\n            {\n                CPLSetThreadLocalConfigOption(\n                    \"GDAL_JPEG_TO_RGB\",\n                    !osOldVal.empty() ? osOldVal.c_str() : nullptr );\n            }\n        }\n        else\n        {\n            // Trick: we invalidate the JPEG dataset to force a reload\n            // of the new content.\n            CPLErrorReset();\n            m_poGDS->m_poJPEGDS->FlushCache();\n            if( CPLGetLastErrorNo() != 0 )\n            {\n                GDALClose( m_poGDS->m_poJPEGDS );\n                m_poGDS->m_poJPEGDS = nullptr;\n                return CE_Failure;\n            }\n            m_poGDS->m_nBlockId = nBlockId;\n        }\n    }\n\n    CPLErr eErr = CE_Failure;\n    if( m_poGDS->m_poJPEGDS )\n    {\n        GDALDataset* l_poDS = m_poGDS->m_poJPEGDS;\n\n        int nReqXOff = 0;\n        int nReqYOff = 0;\n        int nReqXSize = 0;\n        int nReqYSize = 0;\n        if( bIsSingleStripAsSplit )\n        {\n            nReqYOff = nBlockYOff * nScaleFactor;\n            nReqXSize = l_poDS->GetRasterXSize();\n            nReqYSize = nScaleFactor;\n        }\n        else\n        {\n            if( nBlockXSize == m_poGDS->GetRasterXSize() )\n            {\n                nReqXSize = l_poDS->GetRasterXSize();\n            }\n            else\n            {\n                nReqXSize = nBlockXSize * nScaleFactor;\n            }\n            nReqYSize = nBlockYSize * nScaleFactor;\n        }\n        int nBufXSize = nBlockXSize;\n        int nBufYSize = nBlockYSize;\n        if( nBlockXOff == DIV_ROUND_UP(m_poGDS->m_poParentDS->nRasterXSize,\n                                       m_poGDS->m_poParentDS->m_nBlockXSize) - 1 )\n        {\n            nReqXSize = m_poGDS->m_poParentDS->nRasterXSize -\n                                nBlockXOff * m_poGDS->m_poParentDS->m_nBlockXSize;\n        }\n        if( nReqXOff + nReqXSize > l_poDS->GetRasterXSize() )\n        {\n            nReqXSize = l_poDS->GetRasterXSize() - nReqXOff;\n        }\n        if( !bIsSingleStripAsSplit &&\n            nBlockYOff == DIV_ROUND_UP(m_poGDS->m_poParentDS->nRasterYSize,\n                                       m_poGDS->m_poParentDS->m_nBlockYSize) - 1 )\n        {\n            nReqYSize = m_poGDS->m_poParentDS->nRasterYSize -\n                                nBlockYOff * m_poGDS->m_poParentDS->m_nBlockYSize;\n        }\n        if( nReqYOff + nReqYSize > l_poDS->GetRasterYSize() )\n        {\n            nReqYSize = l_poDS->GetRasterYSize() - nReqYOff;\n        }\n        if( nBlockXOff * nBlockXSize > m_poGDS->GetRasterXSize() - nBufXSize )\n        {\n            memset(pImage, 0, static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize * nDataTypeSize);\n            nBufXSize = m_poGDS->GetRasterXSize() - nBlockXOff * nBlockXSize;\n        }\n        if( nBlockYOff * nBlockYSize > m_poGDS->GetRasterYSize() - nBufYSize )\n        {\n            memset(pImage, 0, static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize * nDataTypeSize);\n            nBufYSize = m_poGDS->GetRasterYSize() - nBlockYOff * nBlockYSize;\n        }\n\n        const int nSrcBand =\n            m_poGDS->m_poParentDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE ?\n            1 : nBand;\n        if( nSrcBand <= l_poDS->GetRasterCount() )\n        {\n            eErr = l_poDS->GetRasterBand(nSrcBand)->RasterIO(GF_Read,\n                                 nReqXOff, nReqYOff, nReqXSize, nReqYSize,\n                                 pImage,\n                                 nBufXSize, nBufYSize, eDataType,\n                                 0, static_cast<GPtrDiff_t>(nBlockXSize) * nDataTypeSize, nullptr );\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                        GTIFFSetJpegQuality()                         */\n/* Called by GTIFFBuildOverviews() to set the jpeg quality on the IFD   */\n/* of the .ovr file.                                                    */\n/************************************************************************/\n\nvoid GTIFFSetJpegQuality( GDALDatasetH hGTIFFDS, int nJpegQuality )\n{\n    CPLAssert(\n        EQUAL(GDALGetDriverShortName(GDALGetDatasetDriver(hGTIFFDS)), \"GTIFF\"));\n\n    GTiffDataset* const poDS = static_cast<GTiffDataset *>(hGTIFFDS);\n    poDS->m_nJpegQuality = static_cast<signed char>(nJpegQuality);\n\n    poDS->ScanDirectories();\n\n    for( int i = 0; i < poDS->m_nOverviewCount; ++i )\n        poDS->m_papoOverviewDS[i]->m_nJpegQuality = poDS->m_nJpegQuality;\n}\n\n/************************************************************************/\n/*                        GTIFFSetWebPLevel()                         */\n/* Called by GTIFFBuildOverviews() to set the jpeg quality on the IFD   */\n/* of the .ovr file.                                                    */\n/************************************************************************/\n\nvoid GTIFFSetWebPLevel( GDALDatasetH hGTIFFDS, int nWebpLevel )\n{\n    CPLAssert(\n        EQUAL(GDALGetDriverShortName(GDALGetDatasetDriver(hGTIFFDS)), \"GTIFF\"));\n\n    GTiffDataset* const poDS = static_cast<GTiffDataset *>(hGTIFFDS);\n    poDS->m_nWebPLevel = static_cast<signed char>(nWebpLevel);\n\n    poDS->ScanDirectories();\n\n    for( int i = 0; i < poDS->m_nOverviewCount; ++i )\n        poDS->m_papoOverviewDS[i]->m_nWebPLevel = poDS->m_nWebPLevel;\n}\n\n/************************************************************************/\n/*                     GTIFFSetJpegTablesMode()                         */\n/* Called by GTIFFBuildOverviews() to set the jpeg tables mode on the   */\n/* of the .ovr file.                                                    */\n/************************************************************************/\n\nvoid GTIFFSetJpegTablesMode( GDALDatasetH hGTIFFDS, int nJpegTablesMode )\n{\n    CPLAssert(\n        EQUAL(GDALGetDriverShortName(GDALGetDatasetDriver(hGTIFFDS)), \"GTIFF\"));\n\n    GTiffDataset* const poDS = static_cast<GTiffDataset *>(hGTIFFDS);\n    poDS->m_nJpegTablesMode = static_cast<signed char>(nJpegTablesMode);\n\n    poDS->ScanDirectories();\n\n    for( int i = 0; i < poDS->m_nOverviewCount; ++i )\n        poDS->m_papoOverviewDS[i]->m_nJpegTablesMode = poDS->m_nJpegTablesMode;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                            GTiffRasterBand                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRasterBand CPL_NON_FINAL: public GDALPamRasterBand\n{\n    CPL_DISALLOW_COPY_ASSIGN(GTiffRasterBand)\n\n    friend class GTiffDataset;\n\n    double             m_dfOffset = 0;\n    double             m_dfScale = 1;\n    CPLString          m_osUnitType{};\n    CPLString          m_osDescription{};\n    GDALColorInterp    m_eBandInterp = GCI_Undefined;\n    std::set<GTiffRasterBand **> m_aSetPSelf{};\n    bool               m_bHaveOffsetScale = false;\n\n    int                DirectIO( GDALRWFlag eRWFlag,\n                                 int nXOff, int nYOff, int nXSize, int nYSize,\n                                 void * pData, int nBufXSize, int nBufYSize,\n                                 GDALDataType eBufType,\n                                 GSpacing nPixelSpace, GSpacing nLineSpace,\n                                 GDALRasterIOExtraArg* psExtraArg );\n\n    static void     DropReferenceVirtualMem( void* pUserData );\n    CPLVirtualMem * GetVirtualMemAutoInternal( GDALRWFlag eRWFlag,\n                                               int *pnPixelSpace,\n                                               GIntBig *pnLineSpace,\n                                               char **papszOptions );\n\n    void*           CacheMultiRange( int nXOff, int nYOff,\n                                     int nXSize, int nYSize,\n                                     int nBufXSize, int nBufYSize,\n                                     GDALRasterIOExtraArg* psExtraArg );\n\nprotected:\n    GTiffDataset       *m_poGDS = nullptr;\n    GDALMultiDomainMetadata m_oGTiffMDMD{};\n\n    double             m_dfNoDataValue = -9999.0;\n    bool               m_bNoDataSet = false;\n\n    void NullBlock( void *pData );\n    CPLErr FillCacheForOtherBands( int nBlockXOff, int nBlockYOff );\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    void CacheMaskForBlock( int nBlockXOff, int nBlockYOff );\n#endif\n\npublic:\n             GTiffRasterBand( GTiffDataset *, int );\n    virtual ~GTiffRasterBand();\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override final;\n\n    virtual const char *GetDescription() const override final;\n    virtual void        SetDescription( const char * ) override final;\n\n    virtual GDALColorInterp GetColorInterpretation() override /*final*/;\n    virtual GDALColorTable *GetColorTable() override /*final*/;\n    virtual CPLErr          SetColorTable( GDALColorTable * ) override final;\n    virtual double          GetNoDataValue( int * ) override final;\n    virtual CPLErr          SetNoDataValue( double ) override final;\n    virtual CPLErr DeleteNoDataValue() override final;\n\n    virtual double GetOffset( int *pbSuccess = nullptr ) override final;\n    virtual CPLErr SetOffset( double dfNewValue ) override final;\n    virtual double GetScale( int *pbSuccess = nullptr ) override final;\n    virtual CPLErr SetScale( double dfNewValue ) override final;\n    virtual const char* GetUnitType() override final;\n    virtual CPLErr SetUnitType( const char *pszNewValue ) override final;\n    virtual CPLErr SetColorInterpretation( GDALColorInterp ) override final;\n\n    virtual char      **GetMetadataDomainList() override final;\n    virtual CPLErr  SetMetadata( char **, const char * = \"\" ) override final;\n    virtual char  **GetMetadata( const char * pszDomain = \"\" ) override final;\n    virtual CPLErr  SetMetadataItem( const char*, const char*,\n                                     const char* = \"\" ) override final;\n    virtual const char *GetMetadataItem(\n        const char * pszName, const char * pszDomain = \"\" ) override final;\n    virtual int    GetOverviewCount()  override final;\n    virtual GDALRasterBand *GetOverview( int ) override final;\n\n    virtual GDALRasterBand *GetMaskBand() override final;\n    virtual int             GetMaskFlags() override final;\n    virtual CPLErr          CreateMaskBand( int nFlags )  override final;\n\n    virtual CPLVirtualMem  *GetVirtualMemAuto( GDALRWFlag eRWFlag,\n                                               int *pnPixelSpace,\n                                               GIntBig *pnLineSpace,\n                                               char **papszOptions )  override final;\n\n    GDALRasterAttributeTable* GetDefaultRAT() override final;\n    virtual CPLErr  GetHistogram(\n        double dfMin, double dfMax,\n        int nBuckets, GUIntBig * panHistogram,\n        int bIncludeOutOfRange, int bApproxOK,\n        GDALProgressFunc, void *pProgressData )  override final;\n\n    virtual CPLErr GetDefaultHistogram( double *pdfMin, double *pdfMax,\n                                        int *pnBuckets,\n                                        GUIntBig ** ppanHistogram,\n                                        int bForce,\n                                        GDALProgressFunc,\n                                        void *pProgressData)  override final;\n};\n\n/************************************************************************/\n/*                           GTiffRasterBand()                          */\n/************************************************************************/\n\nGTiffRasterBand::GTiffRasterBand( GTiffDataset *poDSIn, int nBandIn ):\n    m_poGDS(poDSIn)\n{\n    poDS = poDSIn;\n    nBand = nBandIn;\n\n/* -------------------------------------------------------------------- */\n/*      Get the GDAL data type.                                         */\n/* -------------------------------------------------------------------- */\n    const uint16 nBitsPerSample = m_poGDS->m_nBitsPerSample;\n    const uint16 nSampleFormat = m_poGDS->m_nSampleFormat;\n\n    eDataType = GDT_Unknown;\n\n    if( nBitsPerSample <= 8 )\n    {\n        eDataType = GDT_Byte;\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            m_oGTiffMDMD.SetMetadataItem( \"PIXELTYPE\", \"SIGNEDBYTE\",\n                                        \"IMAGE_STRUCTURE\" );\n    }\n    else if( nBitsPerSample <= 16 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int16;\n        else\n            eDataType = GDT_UInt16;\n    }\n    else if( nBitsPerSample == 32 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt16;\n        else if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float32;\n        else if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int32;\n        else\n            eDataType = GDT_UInt32;\n    }\n    else if( nBitsPerSample == 64 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float64;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat32;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt32;\n    }\n    else if( nBitsPerSample == 128 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat64;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try to work out band color interpretation.                      */\n/* -------------------------------------------------------------------- */\n    bool bLookForExtraSamples = false;\n\n    if( m_poGDS->m_poColorTable != nullptr && nBand == 1 )\n    {\n        m_eBandInterp = GCI_PaletteIndex;\n    }\n    else if( m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB\n             || (m_poGDS->m_nPhotometric == PHOTOMETRIC_YCBCR\n                 && m_poGDS->m_nCompression == COMPRESSION_JPEG\n                 && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                    \"YES\") )) )\n    {\n        if( nBand == 1 )\n            m_eBandInterp = GCI_RedBand;\n        else if( nBand == 2 )\n            m_eBandInterp = GCI_GreenBand;\n        else if( nBand == 3 )\n            m_eBandInterp = GCI_BlueBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( m_poGDS->m_nPhotometric == PHOTOMETRIC_YCBCR )\n    {\n        if( nBand == 1 )\n            m_eBandInterp = GCI_YCbCr_YBand;\n        else if( nBand == 2 )\n            m_eBandInterp = GCI_YCbCr_CbBand;\n        else if( nBand == 3 )\n            m_eBandInterp = GCI_YCbCr_CrBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( m_poGDS->m_nPhotometric == PHOTOMETRIC_SEPARATED )\n    {\n        if( nBand == 1 )\n            m_eBandInterp = GCI_CyanBand;\n        else if( nBand == 2 )\n            m_eBandInterp = GCI_MagentaBand;\n        else if( nBand == 3 )\n            m_eBandInterp = GCI_YellowBand;\n        else if( nBand == 4 )\n            m_eBandInterp = GCI_BlackBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISBLACK && nBand == 1 )\n    {\n        m_eBandInterp = GCI_GrayIndex;\n    }\n    else\n    {\n        bLookForExtraSamples = true;\n    }\n\n    if( bLookForExtraSamples )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n\n        if( TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            const int nBaseSamples = m_poGDS->m_nSamplesPerPixel - count;\n            const int nExpectedBaseSamples =\n                (m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISBLACK) ? 1 :\n                (m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISWHITE) ? 1 :\n                (m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB) ? 3 :\n                (m_poGDS->m_nPhotometric == PHOTOMETRIC_YCBCR) ? 3 :\n                (m_poGDS->m_nPhotometric == PHOTOMETRIC_SEPARATED) ? 4 : 0;\n\n            if( nExpectedBaseSamples > 0 &&\n                nBand == nExpectedBaseSamples + 1 &&\n                nBaseSamples != nExpectedBaseSamples )\n            {\n                ReportError(CE_Warning, CPLE_AppDefined,\n                         \"Wrong number of ExtraSamples : %d. %d were expected\",\n                         count, m_poGDS->m_nSamplesPerPixel - nExpectedBaseSamples);\n            }\n\n            if( nBand > nBaseSamples\n                && nBand-nBaseSamples-1 < count\n                && (v[nBand-nBaseSamples-1] == EXTRASAMPLE_ASSOCALPHA\n                    || v[nBand-nBaseSamples-1] == EXTRASAMPLE_UNASSALPHA) )\n                m_eBandInterp = GCI_AlphaBand;\n            else\n                m_eBandInterp = GCI_Undefined;\n        }\n        else\n        {\n            m_eBandInterp = GCI_Undefined;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Establish block size for strip or tiles.                        */\n/* -------------------------------------------------------------------- */\n    nBlockXSize = m_poGDS->m_nBlockXSize;\n    nBlockYSize = m_poGDS->m_nBlockYSize;\n}\n\n/************************************************************************/\n/*                          ~GTiffRasterBand()                          */\n/************************************************************************/\n\nGTiffRasterBand::~GTiffRasterBand()\n{\n    // So that any future DropReferenceVirtualMem() will not try to access the\n    // raster band object, but this would not conform to the advertised\n    // contract.\n    if( !m_aSetPSelf.empty() )\n    {\n        ReportError( CE_Warning, CPLE_AppDefined,\n                  \"Virtual memory objects still exist at GTiffRasterBand \"\n                  \"destruction\" );\n        std::set<GTiffRasterBand**>::iterator oIter = m_aSetPSelf.begin();\n        for( ; oIter != m_aSetPSelf.end(); ++oIter )\n            *(*oIter) = nullptr;\n    }\n}\n\n/************************************************************************/\n/*                        FetchBufferDirectIO                           */\n/************************************************************************/\n\nclass FetchBufferDirectIO final\n{\n    VSILFILE*    fp;\n    GByte       *pTempBuffer;\n    size_t       nTempBufferSize;\n\npublic:\n            FetchBufferDirectIO( VSILFILE* fpIn,\n                                 GByte* pTempBufferIn,\n                                 size_t nTempBufferSizeIn ) :\n                fp(fpIn),\n                pTempBuffer(pTempBufferIn),\n                nTempBufferSize(nTempBufferSizeIn) {}\n\n    const GByte* FetchBytes( vsi_l_offset nOffset,\n                             int nPixels, int nDTSize,\n                             bool bIsByteSwapped, bool bIsComplex,\n                             int nBlockId )\n    {\n        if( !FetchBytes(pTempBuffer, nOffset, nPixels, nDTSize, bIsByteSwapped,\n                        bIsComplex, nBlockId) )\n        {\n            return nullptr;\n        }\n        return pTempBuffer;\n    }\n\n    bool FetchBytes( GByte* pabyDstBuffer,\n                     vsi_l_offset nOffset,\n                     int nPixels, int nDTSize,\n                     bool bIsByteSwapped, bool bIsComplex,\n                     int nBlockId )\n    {\n        vsi_l_offset nSeekForward = 0;\n        if( nOffset <= VSIFTellL(fp) ||\n            (nSeekForward = nOffset - VSIFTellL(fp)) > nTempBufferSize )\n        {\n            if( VSIFSeekL(fp, nOffset, SEEK_SET) != 0 )\n            {\n                CPLError(CE_Failure, CPLE_FileIO,\n                         \"Cannot seek to block %d\", nBlockId);\n                return false;\n            }\n        }\n        else\n        {\n            while( nSeekForward > 0 )\n            {\n                vsi_l_offset nToRead = nSeekForward;\n                if( nToRead > nTempBufferSize )\n                    nToRead = nTempBufferSize;\n                if( VSIFReadL(pTempBuffer, static_cast<size_t>(nToRead),\n                              1, fp) != 1 )\n                {\n                    CPLError(CE_Failure, CPLE_FileIO,\n                             \"Cannot seek to block %d\", nBlockId);\n                    return false;\n                }\n                nSeekForward -= nToRead;\n            }\n        }\n        if( VSIFReadL(pabyDstBuffer, nPixels * nDTSize, 1, fp) != 1 )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return false;\n        }\n\n        if( bIsByteSwapped )\n        {\n            if( bIsComplex )\n                GDALSwapWords( pabyDstBuffer, nDTSize / 2, 2 * nPixels,\n                               nDTSize / 2 );\n            else\n                GDALSwapWords( pabyDstBuffer, nDTSize, nPixels, nDTSize);\n        }\n        return true;\n    }\n\n    static const EMULATED_BOOL bMinimizeIO = true;\n};\n\n/************************************************************************/\n/*                           DirectIO()                                 */\n/************************************************************************/\n\n// Reads directly bytes from the file using ReadMultiRange(), and by-pass\n// block reading. Restricted to simple TIFF configurations\n// (uncompressed data, standard data types). Particularly useful to extract\n// sub-windows of data on a large /vsicurl dataset).\n// Returns -1 if DirectIO() can't be supported on that file.\n\nint GTiffRasterBand::DirectIO( GDALRWFlag eRWFlag,\n                               int nXOff, int nYOff, int nXSize, int nYSize,\n                               void * pData, int nBufXSize, int nBufYSize,\n                               GDALDataType eBufType,\n                               GSpacing nPixelSpace, GSpacing nLineSpace,\n                               GDALRasterIOExtraArg* psExtraArg )\n{\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(eRWFlag == GF_Read &&\n          m_poGDS->m_nCompression == COMPRESSION_NONE &&\n          (m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB ||\n           m_poGDS->m_nPhotometric == PHOTOMETRIC_PALETTE) &&\n          m_poGDS->m_nBitsPerSample == nDTSizeBits) )\n    {\n        return -1;\n    }\n    m_poGDS->Crystalize();\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) &&\n        psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"DirectIO(%d,%d,%d,%d -> %dx%d)\",\n              nXOff, nYOff, nXSize, nYSize,\n              nBufXSize, nBufYSize );\n#endif\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( m_poGDS->GetAccess() == GA_Update )\n    {\n        m_poGDS->FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( m_poGDS->m_hTIFF ) );\n    }\n\n    if( TIFFIsTiled( m_poGDS->m_hTIFF ) )\n    {\n        const int nDTSize = nDTSizeBits / 8;\n        const size_t nTempBufferForCommonDirectIOSize =\n                static_cast<size_t>(\n                    static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize * nDTSize *\n                    (m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG ?\n                     m_poGDS->nBands : 1) );\n        if( m_poGDS->m_pTempBufferForCommonDirectIO == nullptr )\n        {\n            m_poGDS->m_pTempBufferForCommonDirectIO =\n                static_cast<GByte *>( VSI_MALLOC_VERBOSE(\n                    nTempBufferForCommonDirectIOSize ) );\n            if( m_poGDS->m_pTempBufferForCommonDirectIO == nullptr )\n                return CE_Failure;\n        }\n\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_poGDS->m_hTIFF ));\n        FetchBufferDirectIO oFetcher(fp, m_poGDS->m_pTempBufferForCommonDirectIO,\n                                     nTempBufferForCommonDirectIOSize);\n\n        return m_poGDS->CommonDirectIO(\n            oFetcher,\n            nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize,\n            eBufType,\n            1, &nBand,\n            nPixelSpace, nLineSpace,\n            0 );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    // TODO(schwehr): Make ppData be GByte**.\n    void** ppData = static_cast<void **>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void*)) );\n    vsi_l_offset* panOffsets = static_cast<vsi_l_offset *>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)) );\n    size_t* panSizes = static_cast<size_t *>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)) );\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void* pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands =\n        m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG ? m_poGDS->nBands : 1;\n    int nSrcPixelSize = nDTSize * nContigBands;\n\n    if( ppData == nullptr || panOffsets == nullptr || panSizes == nullptr )\n        eErr = CE_Failure;\n    else if( nXSize != nBufXSize || nYSize != nBufYSize ||\n             eBufType != eDataType ||\n             nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n             nContigBands > 1 )\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC_VERBOSE(nReqXSize * nReqYSize * nSrcPixelSize);\n        if( pTmpBuffer == nullptr )\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    for( int iLine = 0; eErr == CE_None && iLine < nReqYSize; ++iLine )\n    {\n        if( pTmpBuffer == nullptr )\n            ppData[iLine] = static_cast<GByte *>(pData) + iLine * nLineSpace;\n        else\n            ppData[iLine] =\n                static_cast<GByte *>(pTmpBuffer) +\n                iLine * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if( nBufYSize < nYSize )  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast<int>((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n        if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            nBlockId += (nBand-1) * m_poGDS->m_nBlocksPerBand;\n        }\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if( panOffsets[iLine] == 0 )  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff + nYOffsetInBlock * nBlockXSize) * nSrcPixelSize;\n        panSizes[iLine] = nReqXSize * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if( eErr == CE_None )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_poGDS->m_hTIFF ));\n        const int nRet =\n            VSIFReadMultiRangeL( nReqYSize, ppData, panOffsets, panSizes, fp );\n        if( nRet != 0 )\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if( eErr == CE_None && TIFFIsByteSwapped(m_poGDS->m_hTIFF) )\n    {\n        for( int iLine = 0; iLine < nReqYSize; ++iLine )\n        {\n            if( GDALDataTypeIsComplex(eDataType) )\n                GDALSwapWords( ppData[iLine], nDTSize / 2,\n                               2 * nReqXSize * nContigBands, nDTSize / 2 );\n            else\n                GDALSwapWords( ppData[iLine], nDTSize,\n                               nReqXSize * nContigBands, nDTSize );\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    if( eErr == CE_None && pTmpBuffer != nullptr )\n    {\n        for( int iY=0; iY < nBufYSize; ++iY )\n        {\n            const int iSrcY =\n                nBufYSize <= nYSize ?\n                iY : static_cast<int>((iY + 0.5) * dfSrcYInc);\n\n            GByte* pabySrcData =\n                static_cast<GByte*>(ppData[iSrcY]) +\n                (nContigBands > 1 ? (nBand-1) : 0) * nDTSize;\n            GByte* pabyDstData =\n                static_cast<GByte *>(pData) + iY * nLineSpace;\n            if( nBufXSize == nXSize )\n            {\n                GDALCopyWords( pabySrcData,\n                               eDataType,\n                               nSrcPixelSize,\n                               pabyDstData,\n                               eBufType,\n                               static_cast<int>(nPixelSpace),\n                               nBufXSize );\n            }\n            else\n            {\n                if( eDataType == GDT_Byte && eBufType == GDT_Byte )\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for( int iX = 0; iX < nBufXSize; ++iX, dfSrcX += dfSrcXInc )\n                    {\n                        const int iSrcX = static_cast<int>(dfSrcX);\n                        pabyDstData[iX * nPixelSpace] =\n                            pabySrcData[iSrcX * nSrcPixelSize];\n                    }\n                }\n                else\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for( int iX = 0; iX < nBufXSize; ++iX, dfSrcX += dfSrcXInc )\n                    {\n                        const int iSrcX = static_cast<int>(dfSrcX);\n                        GDALCopyWords( pabySrcData + iSrcX * nSrcPixelSize,\n                                       eDataType, 0,\n                                       pabyDstData + iX * nPixelSpace,\n                                       eBufType, 0, 1 );\n                    }\n                }\n            }\n        }\n    }\n\n    // Cleanup.\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                           GetVirtualMemAuto()                        */\n/************************************************************************/\n\nCPLVirtualMem* GTiffRasterBand::GetVirtualMemAuto( GDALRWFlag eRWFlag,\n                                                   int *pnPixelSpace,\n                                                   GIntBig *pnLineSpace,\n                                                   char **papszOptions )\n{\n    const char* pszImpl = CSLFetchNameValueDef(\n            papszOptions, \"USE_DEFAULT_IMPLEMENTATION\", \"AUTO\");\n    if( EQUAL(pszImpl, \"YES\") || EQUAL(pszImpl, \"ON\") ||\n        EQUAL(pszImpl, \"1\") || EQUAL(pszImpl, \"TRUE\") )\n    {\n        return GDALRasterBand::GetVirtualMemAuto( eRWFlag, pnPixelSpace,\n                                                  pnLineSpace, papszOptions );\n    }\n\n    CPLVirtualMem *psRet =\n        GetVirtualMemAutoInternal( eRWFlag, pnPixelSpace, pnLineSpace,\n                                   papszOptions );\n    if( psRet != nullptr )\n    {\n        CPLDebug(\"GTiff\", \"GetVirtualMemAuto(): Using memory file mapping\");\n        return psRet;\n    }\n\n    if( EQUAL(pszImpl, \"NO\") || EQUAL(pszImpl, \"OFF\") ||\n        EQUAL(pszImpl, \"0\") || EQUAL(pszImpl, \"FALSE\") )\n    {\n        return nullptr;\n    }\n\n    CPLDebug(\"GTiff\", \"GetVirtualMemAuto(): Defaulting to base implementation\");\n    return GDALRasterBand::GetVirtualMemAuto( eRWFlag, pnPixelSpace,\n                                              pnLineSpace, papszOptions );\n}\n\n\n/************************************************************************/\n/*                           GetDefaultRAT()                            */\n/************************************************************************/\n\nGDALRasterAttributeTable *GTiffRasterBand::GetDefaultRAT()\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetDefaultRAT();\n}\n\n/************************************************************************/\n/*                           GetHistogram()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::GetHistogram(\n    double dfMin, double dfMax,\n    int nBuckets, GUIntBig * panHistogram,\n    int bIncludeOutOfRange, int bApproxOK,\n    GDALProgressFunc pfnProgress, void *pProgressData )\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetHistogram( dfMin, dfMax,\n                                            nBuckets, panHistogram,\n                                            bIncludeOutOfRange, bApproxOK,\n                                            pfnProgress, pProgressData );\n}\n\n/************************************************************************/\n/*                       GetDefaultHistogram()                          */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::GetDefaultHistogram( double *pdfMin, double *pdfMax,\n                                             int *pnBuckets,\n                                             GUIntBig ** ppanHistogram,\n                                             int bForce,\n                                             GDALProgressFunc pfnProgress,\n                                             void *pProgressData )\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetDefaultHistogram( pdfMin, pdfMax,\n                                                   pnBuckets, ppanHistogram,\n                                                   bForce,\n                                                   pfnProgress, pProgressData );\n}\n\n/************************************************************************/\n/*                     DropReferenceVirtualMem()                        */\n/************************************************************************/\n\nvoid GTiffRasterBand::DropReferenceVirtualMem( void* pUserData )\n{\n    // This function may also be called when the dataset and rasterband\n    // objects have been destroyed.\n    // If they are still alive, it updates the reference counter of the\n    // base mapping to invalidate the pointer to it if needed.\n\n    GTiffRasterBand** ppoSelf = static_cast<GTiffRasterBand **>( pUserData );\n    GTiffRasterBand* poSelf = *ppoSelf;\n\n    if( poSelf != nullptr )\n    {\n        if( --(poSelf->m_poGDS->m_nRefBaseMapping) == 0 )\n        {\n            poSelf->m_poGDS->m_pBaseMapping = nullptr;\n        }\n        poSelf->m_aSetPSelf.erase(ppoSelf);\n    }\n    CPLFree(pUserData);\n}\n\n/************************************************************************/\n/*                     GetVirtualMemAutoInternal()                      */\n/************************************************************************/\n\nCPLVirtualMem* GTiffRasterBand::GetVirtualMemAutoInternal( GDALRWFlag eRWFlag,\n                                                           int *pnPixelSpace,\n                                                           GIntBig *pnLineSpace,\n                                                           char **papszOptions )\n{\n    int nLineSize = nBlockXSize * GDALGetDataTypeSizeBytes(eDataType);\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n        nLineSize *= m_poGDS->nBands;\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        // In case of a pixel interleaved file, we save virtual memory space\n        // by reusing a base mapping that embraces the whole imagery.\n        if( m_poGDS->m_pBaseMapping != nullptr )\n        {\n            // Offset between the base mapping and the requested mapping.\n            vsi_l_offset nOffset =\n                static_cast<vsi_l_offset>(nBand - 1) *\n                GDALGetDataTypeSizeBytes(eDataType);\n\n            GTiffRasterBand** ppoSelf =\n                static_cast<GTiffRasterBand** >(\n                    CPLCalloc(1, sizeof(GTiffRasterBand*)) );\n            *ppoSelf = this;\n\n            CPLVirtualMem* pVMem = CPLVirtualMemDerivedNew(\n                m_poGDS->m_pBaseMapping,\n                nOffset,\n                CPLVirtualMemGetSize(m_poGDS->m_pBaseMapping) - nOffset,\n                GTiffRasterBand::DropReferenceVirtualMem,\n                ppoSelf);\n            if( pVMem == nullptr )\n            {\n                CPLFree(ppoSelf);\n                return nullptr;\n            }\n\n            // Mechanism used so that the memory mapping object can be\n            // destroyed after the raster band.\n            m_aSetPSelf.insert(ppoSelf);\n            ++m_poGDS->m_nRefBaseMapping;\n            *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n            if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                *pnPixelSpace *= m_poGDS->nBands;\n            *pnLineSpace = nLineSize;\n            return pVMem;\n        }\n    }\n\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_poGDS->m_hTIFF ));\n\n    vsi_l_offset nLength = static_cast<vsi_l_offset>(nRasterYSize) * nLineSize;\n\n    if( !(CPLIsVirtualMemFileMapAvailable() &&\n          VSIFGetNativeFileDescriptorL(fp) != nullptr &&\n#if SIZEOF_VOIDP == 4\n          nLength == static_cast<size_t>(nLength) &&\n#endif\n          m_poGDS->m_nCompression == COMPRESSION_NONE &&\n          (m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB ||\n           m_poGDS->m_nPhotometric == PHOTOMETRIC_PALETTE) &&\n          m_poGDS->m_nBitsPerSample == GDALGetDataTypeSizeBits(eDataType) &&\n          !TIFFIsTiled( m_poGDS->m_hTIFF ) && !TIFFIsByteSwapped(m_poGDS->m_hTIFF)) )\n    {\n        return nullptr;\n    }\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( m_poGDS->GetAccess() == GA_Update )\n    {\n        m_poGDS->FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( m_poGDS->m_hTIFF ) );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return nullptr;\n    }\n\n    GPtrDiff_t nBlockSize =\n        static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize * GDALGetDataTypeSizeBytes(eDataType);\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n        nBlockSize *= m_poGDS->nBands;\n\n    int nBlocks = m_poGDS->m_nBlocksPerBand;\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlocks *= m_poGDS->nBands;\n    int i = 0;  // Used after for.\n    for( ; i < nBlocks; ++i )\n    {\n        if( panTIFFOffsets[i] != 0 )\n            break;\n    }\n    if( i == nBlocks )\n    {\n        // All zeroes.\n        if( m_poGDS->eAccess == GA_Update )\n        {\n            // Initialize the file with empty blocks so that the file has\n            // the appropriate size.\n\n            toff_t* panByteCounts = nullptr;\n            if( !TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_STRIPBYTECOUNTS,\n                               &panByteCounts ) ||\n                panByteCounts == nullptr )\n            {\n                return nullptr;\n            }\n            if( VSIFSeekL(fp, 0, SEEK_END) != 0 )\n                return nullptr;\n            vsi_l_offset nBaseOffset = VSIFTellL(fp);\n\n            // Just write one tile with libtiff to put it in appropriate state.\n            GByte* pabyData =\n                static_cast<GByte*>(VSI_CALLOC_VERBOSE(1, nBlockSize));\n            if( pabyData == nullptr )\n            {\n                return nullptr;\n            }\n            const auto ret =\n                    TIFFWriteEncodedStrip( m_poGDS->m_hTIFF, 0, pabyData,\n                                           nBlockSize );\n            VSI_TIFFFlushBufferedWrite( TIFFClientdata( m_poGDS->m_hTIFF ) );\n            VSIFree(pabyData);\n            if( ret != nBlockSize )\n            {\n                return nullptr;\n            }\n            CPLAssert(panTIFFOffsets[0] == nBaseOffset);\n            CPLAssert(panByteCounts[0] == static_cast<toff_t>(nBlockSize));\n\n            // Now simulate the writing of other blocks.\n            const vsi_l_offset nDataSize =\n                static_cast<vsi_l_offset>(nBlockSize) * nBlocks;\n            if( VSIFTruncateL(fp, nBaseOffset + nDataSize) != 0 )\n                return nullptr;\n\n            for( i = 1; i < nBlocks; ++i)\n            {\n                panTIFFOffsets[i] =\n                    nBaseOffset + i * static_cast<toff_t>(nBlockSize);\n                panByteCounts[i] = nBlockSize;\n            }\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"Sparse files not supported in file mapping\" );\n            return nullptr;\n        }\n    }\n\n    GIntBig nBlockSpacing = 0;\n    bool bCompatibleSpacing = true;\n    toff_t nPrevOffset = 0;\n    for( i = 0; i < m_poGDS->m_nBlocksPerBand; ++i )\n    {\n        toff_t nCurOffset = 0;\n        if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n            nCurOffset =\n                panTIFFOffsets[m_poGDS->m_nBlocksPerBand * (nBand - 1) + i];\n        else\n            nCurOffset = panTIFFOffsets[i];\n        if( nCurOffset == 0 )\n        {\n            bCompatibleSpacing = false;\n            break;\n        }\n        if( i > 0 )\n        {\n            const GIntBig nCurSpacing = nCurOffset - nPrevOffset;\n            if( i == 1 )\n            {\n                if( nCurSpacing !=\n                    static_cast<GIntBig>(nBlockYSize) * nLineSize )\n                {\n                    bCompatibleSpacing = false;\n                    break;\n                }\n                nBlockSpacing = nCurSpacing;\n            }\n            else if( nBlockSpacing != nCurSpacing )\n            {\n                bCompatibleSpacing = false;\n                break;\n            }\n        }\n        nPrevOffset = nCurOffset;\n    }\n\n    if( !bCompatibleSpacing )\n    {\n        return nullptr;\n    }\n\n    vsi_l_offset nOffset = 0;\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        CPLAssert( m_poGDS->m_pBaseMapping == nullptr );\n        nOffset = panTIFFOffsets[0];\n    }\n    else\n    {\n        nOffset = panTIFFOffsets[m_poGDS->m_nBlocksPerBand * (nBand - 1)];\n    }\n    CPLVirtualMem* pVMem = CPLVirtualMemFileMapNew(\n        fp, nOffset, nLength,\n        eRWFlag == GF_Write ? VIRTUALMEM_READWRITE : VIRTUALMEM_READONLY,\n        nullptr, nullptr);\n    if( pVMem == nullptr )\n    {\n        return nullptr;\n    }\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        // TODO(schwehr): Revisit this block.\n        m_poGDS->m_pBaseMapping = pVMem;\n        pVMem = GetVirtualMemAutoInternal( eRWFlag,\n                                           pnPixelSpace,\n                                           pnLineSpace,\n                                           papszOptions );\n        // Drop ref on base mapping.\n        CPLVirtualMemFree(m_poGDS->m_pBaseMapping);\n        if( pVMem == nullptr )\n            m_poGDS->m_pBaseMapping = nullptr;\n    }\n    else\n    {\n        *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n        if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n            *pnPixelSpace *= m_poGDS->nBands;\n        *pnLineSpace = nLineSize;\n    }\n    return pVMem;\n}\n\n/************************************************************************/\n/*                     HasOptimizedReadMultiRange()                     */\n/************************************************************************/\n\nbool GTiffDataset::HasOptimizedReadMultiRange()\n{\n    if( m_nHasOptimizedReadMultiRange >= 0 )\n        return m_nHasOptimizedReadMultiRange != 0;\n    m_nHasOptimizedReadMultiRange = static_cast<signed char>(\n        VSIHasOptimizedReadMultiRange(m_pszFilename)\n        // Config option for debug and testing purposes only\n        || CPLTestBool(CPLGetConfigOption(\"GTIFF_HAS_OPTIMIZED_READ_MULTI_RANGE\", \"NO\"))\n    );\n    return m_nHasOptimizedReadMultiRange != 0;\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffDataset::IRasterIO( GDALRWFlag eRWFlag,\n                                int nXOff, int nYOff, int nXSize, int nYSize,\n                                void * pData, int nBufXSize, int nBufYSize,\n                                GDALDataType eBufType,\n                                int nBandCount, int *panBandMap,\n                                GSpacing nPixelSpace, GSpacing nLineSpace,\n                                GSpacing nBandSpace,\n                                GDALRasterIOExtraArg* psExtraArg )\n\n{\n    // Try to pass the request to the most appropriate overview dataset.\n    if( nBufXSize < nXSize && nBufYSize < nYSize )\n    {\n        int bTried = FALSE;\n        ++m_nJPEGOverviewVisibilityCounter;\n        const CPLErr eErr =\n            TryOverviewRasterIO( eRWFlag,\n                                 nXOff, nYOff, nXSize, nYSize,\n                                 pData, nBufXSize, nBufYSize,\n                                 eBufType,\n                                 nBandCount, panBandMap,\n                                 nPixelSpace, nLineSpace,\n                                 nBandSpace,\n                                 psExtraArg,\n                                 &bTried );\n        --m_nJPEGOverviewVisibilityCounter;\n        if( bTried )\n            return eErr;\n    }\n\n    if( m_eVirtualMemIOUsage != VirtualMemIOEnum::NO )\n    {\n        const int nErr = VirtualMemIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg );\n        if( nErr >= 0 )\n            return static_cast<CPLErr>(nErr);\n    }\n    if( m_bDirectIO )\n    {\n        const int nErr = DirectIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg );\n        if( nErr >= 0 )\n            return static_cast<CPLErr>(nErr);\n    }\n\n    void* pBufferedData = nullptr;\n    if( eAccess == GA_ReadOnly &&\n        eRWFlag == GF_Read &&\n        m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        HasOptimizedReadMultiRange() )\n    {\n        pBufferedData = cpl::down_cast<GTiffRasterBand *>(\n            GetRasterBand(1))->CacheMultiRange(nXOff, nYOff,\n                                               nXSize, nYSize,\n                                               nBufXSize, nBufYSize,\n                                               psExtraArg);\n    }\n\n    ++m_nJPEGOverviewVisibilityCounter;\n    const CPLErr eErr =\n        GDALPamDataset::IRasterIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg);\n    m_nJPEGOverviewVisibilityCounter--;\n\n    if( pBufferedData )\n    {\n        VSIFree( pBufferedData );\n        VSI_TIFFSetCachedRanges( TIFFClientdata( m_hTIFF ),\n                                 0, nullptr, nullptr, nullptr );\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                        FetchBufferVirtualMemIO                       */\n/************************************************************************/\n\nclass FetchBufferVirtualMemIO final\n{\n    const GByte* pabySrcData;\n    size_t       nMappingSize;\n    GByte       *pTempBuffer;\n\npublic:\n            FetchBufferVirtualMemIO( const GByte* pabySrcDataIn,\n                                     size_t nMappingSizeIn,\n                                     GByte* pTempBufferIn ) :\n                pabySrcData(pabySrcDataIn),\n                nMappingSize(nMappingSizeIn),\n                pTempBuffer(pTempBufferIn) {}\n\n    const GByte* FetchBytes( vsi_l_offset nOffset,\n                             int nPixels, int nDTSize,\n                             bool bIsByteSwapped, bool bIsComplex,\n                             int nBlockId )\n    {\n        if( nOffset + nPixels * nDTSize > nMappingSize )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return nullptr;\n        }\n        if( !bIsByteSwapped )\n            return pabySrcData + nOffset;\n        memcpy(pTempBuffer, pabySrcData + nOffset, nPixels * nDTSize);\n        if( bIsComplex )\n            GDALSwapWords( pTempBuffer, nDTSize / 2, 2 * nPixels, nDTSize / 2);\n        else\n            GDALSwapWords( pTempBuffer, nDTSize, nPixels, nDTSize);\n        return pTempBuffer;\n    }\n\n    bool FetchBytes( GByte* pabyDstBuffer,\n                     vsi_l_offset nOffset,\n                     int nPixels, int nDTSize,\n                     bool bIsByteSwapped, bool bIsComplex,\n                     int nBlockId )\n    {\n        if( nOffset + nPixels * nDTSize > nMappingSize )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return false;\n        }\n        memcpy(pabyDstBuffer, pabySrcData + nOffset, nPixels * nDTSize);\n        if( bIsByteSwapped )\n        {\n            if( bIsComplex )\n                GDALSwapWords( pabyDstBuffer, nDTSize / 2, 2 * nPixels,\n                               nDTSize / 2);\n            else\n                GDALSwapWords( pabyDstBuffer, nDTSize, nPixels, nDTSize);\n        }\n        return true;\n    }\n\n    static const EMULATED_BOOL bMinimizeIO = false;\n};\n\n/************************************************************************/\n/*                         VirtualMemIO()                               */\n/************************************************************************/\n\nint GTiffDataset::VirtualMemIO( GDALRWFlag eRWFlag,\n                                int nXOff, int nYOff, int nXSize, int nYSize,\n                                void * pData, int nBufXSize, int nBufYSize,\n                                GDALDataType eBufType,\n                                int nBandCount, int *panBandMap,\n                                GSpacing nPixelSpace, GSpacing nLineSpace,\n                                GSpacing nBandSpace,\n                                GDALRasterIOExtraArg* psExtraArg )\n{\n    if( eAccess == GA_Update || eRWFlag == GF_Write || m_bStreamingIn )\n        return -1;\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) &&\n        psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n    const GDALDataType eDataType = GetRasterBand(1)->GetRasterDataType();\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(m_nCompression == COMPRESSION_NONE &&\n        (m_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n        m_nPhotometric == PHOTOMETRIC_RGB ||\n        m_nPhotometric == PHOTOMETRIC_PALETTE) &&\n        m_nBitsPerSample == nDTSizeBits) )\n    {\n        m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n        return -1;\n    }\n\n    size_t nMappingSize = 0;\n    GByte* pabySrcData = nullptr;\n    if( STARTS_WITH(m_pszFilename, \"/vsimem/\") )\n    {\n        vsi_l_offset nDataLength = 0;\n        pabySrcData =\n            VSIGetMemFileBuffer(m_pszFilename, &nDataLength, FALSE);\n        nMappingSize = static_cast<size_t>(nDataLength);\n        if( pabySrcData == nullptr )\n            return -1;\n    }\n    else if( m_psVirtualMemIOMapping == nullptr )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n        if( !CPLIsVirtualMemFileMapAvailable() ||\n            VSIFGetNativeFileDescriptorL(fp) == nullptr )\n        {\n            m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n            return -1;\n        }\n        if( VSIFSeekL(fp, 0, SEEK_END) != 0 )\n        {\n            m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n            return -1;\n        }\n        const vsi_l_offset nLength = VSIFTellL(fp);\n        if( static_cast<size_t>(nLength) != nLength )\n        {\n            m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n            return -1;\n        }\n        if( m_eVirtualMemIOUsage == VirtualMemIOEnum::IF_ENOUGH_RAM )\n        {\n            GIntBig nRAM = CPLGetUsablePhysicalRAM();\n            if( static_cast<GIntBig>(nLength) > nRAM )\n            {\n                CPLDebug( \"GTiff\",\n                          \"Not enough RAM to map whole file into memory.\" );\n                m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n                return -1;\n            }\n        }\n        m_psVirtualMemIOMapping = CPLVirtualMemFileMapNew(\n            fp, 0, nLength, VIRTUALMEM_READONLY, nullptr, nullptr);\n        if( m_psVirtualMemIOMapping == nullptr )\n        {\n            m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n            return -1;\n        }\n        m_eVirtualMemIOUsage = VirtualMemIOEnum::YES;\n    }\n\n    if( m_psVirtualMemIOMapping )\n    {\n#ifdef DEBUG\n        CPLDebug(\"GTiff\", \"Using VirtualMemIO\");\n#endif\n        nMappingSize = CPLVirtualMemGetSize(m_psVirtualMemIOMapping);\n        pabySrcData = static_cast<GByte *>(\n            CPLVirtualMemGetAddr(m_psVirtualMemIOMapping) );\n    }\n\n    if( TIFFIsByteSwapped(m_hTIFF) && m_pTempBufferForCommonDirectIO == nullptr )\n    {\n        const int nDTSize = nDTSizeBits / 8;\n        size_t nTempBufferForCommonDirectIOSize =\n            static_cast<size_t>(m_nBlockXSize * nDTSize *\n                (m_nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1));\n        if( TIFFIsTiled(m_hTIFF) )\n            nTempBufferForCommonDirectIOSize *= m_nBlockYSize;\n\n        m_pTempBufferForCommonDirectIO =\n            static_cast<GByte *>(\n                VSI_MALLOC_VERBOSE(nTempBufferForCommonDirectIOSize) );\n        if( m_pTempBufferForCommonDirectIO == nullptr )\n            return CE_Failure;\n    }\n    FetchBufferVirtualMemIO oFetcher( pabySrcData, nMappingSize,\n                                      m_pTempBufferForCommonDirectIO );\n\n    return CommonDirectIO( oFetcher,\n                           nXOff, nYOff, nXSize, nYSize,\n                           pData, nBufXSize, nBufYSize,\n                           eBufType,\n                           nBandCount, panBandMap,\n                           nPixelSpace, nLineSpace,\n                           nBandSpace );\n}\n\n/************************************************************************/\n/*                   CopyContigByteMultiBand()                          */\n/************************************************************************/\n\nstatic inline void CopyContigByteMultiBand(\n    const GByte* CPL_RESTRICT pabySrc, int nSrcStride,\n    GByte* CPL_RESTRICT pabyDest, int nDestStride,\n    int nIters, int nBandCount )\n{\n    if( nBandCount == 3 )\n    {\n        if( nSrcStride == 3 && nDestStride == 4 )\n        {\n            while( nIters >= 8 )\n            {\n                pabyDest[4*0+0] = pabySrc[3*0+0];\n                pabyDest[4*0+1] = pabySrc[3*0+1];\n                pabyDest[4*0+2] = pabySrc[3*0+2];\n                pabyDest[4*1+0] = pabySrc[3*1+0];\n                pabyDest[4*1+1] = pabySrc[3*1+1];\n                pabyDest[4*1+2] = pabySrc[3*1+2];\n                pabyDest[4*2+0] = pabySrc[3*2+0];\n                pabyDest[4*2+1] = pabySrc[3*2+1];\n                pabyDest[4*2+2] = pabySrc[3*2+2];\n                pabyDest[4*3+0] = pabySrc[3*3+0];\n                pabyDest[4*3+1] = pabySrc[3*3+1];\n                pabyDest[4*3+2] = pabySrc[3*3+2];\n                pabyDest[4*4+0] = pabySrc[3*4+0];\n                pabyDest[4*4+1] = pabySrc[3*4+1];\n                pabyDest[4*4+2] = pabySrc[3*4+2];\n                pabyDest[4*5+0] = pabySrc[3*5+0];\n                pabyDest[4*5+1] = pabySrc[3*5+1];\n                pabyDest[4*5+2] = pabySrc[3*5+2];\n                pabyDest[4*6+0] = pabySrc[3*6+0];\n                pabyDest[4*6+1] = pabySrc[3*6+1];\n                pabyDest[4*6+2] = pabySrc[3*6+2];\n                pabyDest[4*7+0] = pabySrc[3*7+0];\n                pabyDest[4*7+1] = pabySrc[3*7+1];\n                pabyDest[4*7+2] = pabySrc[3*7+2];\n                pabySrc += 3 * 8;\n                pabyDest += 4 * 8;\n                nIters -= 8;\n            }\n            while( nIters-- > 0 )\n            {\n                pabyDest[0] = pabySrc[0];\n                pabyDest[1] = pabySrc[1];\n                pabyDest[2] = pabySrc[2];\n                pabySrc += 3;\n                pabyDest += 4;\n            }\n        }\n        else\n        {\n            while( nIters-- > 0 )\n            {\n                pabyDest[0] = pabySrc[0];\n                pabyDest[1] = pabySrc[1];\n                pabyDest[2] = pabySrc[2];\n                pabySrc += nSrcStride;\n                pabyDest += nDestStride;\n            }\n        }\n    }\n    else\n    {\n        while( nIters-- > 0 )\n        {\n            for( int iBand = 0; iBand < nBandCount; ++iBand )\n                pabyDest[iBand] = pabySrc[iBand];\n            pabySrc += nSrcStride;\n            pabyDest += nDestStride;\n        }\n    }\n}\n\n/************************************************************************/\n/*                         CommonDirectIO()                             */\n/************************************************************************/\n\n// #define DEBUG_REACHED_VIRTUAL_MEM_IO\n#ifdef DEBUG_REACHED_VIRTUAL_MEM_IO\nstatic int anReachedVirtualMemIO[52] = { 0 };\n#define REACHED(x) anReachedVirtualMemIO[x] = 1\n#else\n#define REACHED(x)\n#endif\n\ntemplate<class FetchBuffer> CPLErr GTiffDataset::CommonDirectIO(\n    FetchBuffer& oFetcher,\n    int nXOff, int nYOff, int nXSize, int nYSize,\n    void * pData, int nBufXSize, int nBufYSize,\n    GDALDataType eBufType,\n    int nBandCount, int *panBandMap,\n    GSpacing nPixelSpace, GSpacing nLineSpace,\n    GSpacing nBandSpace )\n{\n    const GDALDataType eDataType = GetRasterBand(1)->GetRasterDataType();\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    const bool bIsComplex = CPL_TO_BOOL(GDALDataTypeIsComplex(eDataType));\n    const int nBufDTSize = GDALGetDataTypeSizeBytes(eBufType);\n\n    // Get strip offsets.\n    toff_t *panOffsets = nullptr;\n    if( !TIFFGetField( m_hTIFF, (TIFFIsTiled( m_hTIFF )) ?\n                       TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                       &panOffsets ) ||\n        panOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    bool bUseContigImplementation =\n        m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        nBandCount > 1 &&\n        nBandSpace == nBufDTSize;\n    if( bUseContigImplementation )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            const int nBand = panBandMap[iBand];\n            if( nBand != iBand + 1 )\n            {\n                bUseContigImplementation = false;\n                break;\n            }\n        }\n    }\n\n    const int nBandsPerBlock =\n        m_nPlanarConfig == PLANARCONFIG_SEPARATE ? 1 : nBands;\n    const int nBandsPerBlockDTSize = nBandsPerBlock * nDTSize;\n    const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n    const bool bNoTypeChange = (eDataType == eBufType);\n    const bool bNoXResampling = (nXSize == nBufXSize );\n    const bool bNoXResamplingNoTypeChange = (bNoTypeChange && bNoXResampling);\n    const bool bByteOnly = (bNoTypeChange && nDTSize == 1 );\n    const bool bByteNoXResampling = ( bByteOnly && bNoXResamplingNoTypeChange );\n    const bool bIsByteSwapped = CPL_TO_BOOL(TIFFIsByteSwapped(m_hTIFF));\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    int bNoDataSetIn = FALSE;\n    double dfNoData = GetRasterBand(1)->GetNoDataValue( &bNoDataSetIn );\n    GByte abyNoData = 0;\n    if( !bNoDataSetIn )\n        dfNoData = 0;\n    else if( dfNoData >= 0 && dfNoData <= 255 )\n        abyNoData = static_cast<GByte>(dfNoData + 0.5);\n\n    if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( m_hTIFF ) && bNoXResampling && (nYSize == nBufYSize ) &&\n             m_nPlanarConfig == PLANARCONFIG_CONTIG && nBandCount > 1 )\n    {\n        GByte* pabyData = static_cast<GByte *>(pData);\n        for( int y = 0; y < nBufYSize; )\n        {\n            const int nSrcLine = nYOff + y;\n            const int nBlockYOff = nSrcLine / m_nBlockYSize;\n            const int nYOffsetInBlock = nSrcLine % m_nBlockYSize;\n            const int nUsedBlockHeight =\n                std::min( nBufYSize - y,\n                          m_nBlockYSize - nYOffsetInBlock );\n\n            int nBlockXOff = nXOff / m_nBlockXSize;\n            int nXOffsetInBlock = nXOff % m_nBlockXSize;\n            int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n            int x = 0;\n            while( x < nBufXSize )\n            {\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                const int nUsedBlockWidth =\n                    std::min( m_nBlockXSize - nXOffsetInBlock,\n                              nBufXSize - x );\n\n                if( nCurOffset == 0 )\n                {\n                    REACHED(30);\n                    for( int k = 0; k < nUsedBlockHeight; ++k )\n                    {\n                        GByte* pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for( int iBand = 0; iBand < nBandCount; ++iBand )\n                        {\n                            GByte* pabyLocalDataBand =\n                                pabyLocalData + iBand * nBandSpace;\n\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalDataBand, eBufType,\n                                static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth );\n                        }\n                    }\n                }\n                else\n                {\n                    const int nByteOffsetInBlock =\n                        nYOffsetInBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n                    const GByte* pabyLocalSrcDataK0 = oFetcher.FetchBytes(\n                            nCurOffset + nByteOffsetInBlock,\n                            m_nBlockXSize *\n                            nUsedBlockHeight * nBandsPerBlock,\n                            nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                    if( pabyLocalSrcDataK0 == nullptr )\n                        return CE_Failure;\n\n                    for( int k = 0; k < nUsedBlockHeight; ++k )\n                    {\n                        GByte* pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        const GByte* pabyLocalSrcData =\n                            pabyLocalSrcDataK0 +\n                            (k * m_nBlockXSize + nXOffsetInBlock) *\n                            nBandsPerBlockDTSize;\n\n                        if( bUseContigImplementation && nBands == nBandCount &&\n                            nPixelSpace == nBandsPerBlockDTSize )\n                        {\n                            REACHED(31);\n                            GDALCopyWords( pabyLocalSrcData,\n                                           eDataType, nDTSize,\n                                           pabyLocalData,\n                                           eBufType, nBufDTSize,\n                                           nUsedBlockWidth * nBands );\n                        }\n                        else\n                        {\n                            REACHED(32);\n                            for( int iBand = 0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand]-1) * nDTSize;\n\n                                GDALCopyWords(\n                                    pabyLocalSrcDataBand,\n                                    eDataType, nBandsPerBlockDTSize,\n                                    pabyLocalDataBand,\n                                    eBufType, static_cast<int>(nPixelSpace),\n                                    nUsedBlockWidth );\n                            }\n                        }\n                    }\n                }\n\n                nXOffsetInBlock = 0;\n                ++nBlockXOff;\n                ++nBlockId;\n                x += nUsedBlockWidth;\n            }\n\n            y += nUsedBlockHeight;\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( m_hTIFF ) && bNoXResampling &&\n             (nYSize == nBufYSize ) )\n             // && (m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            GByte* pabyData = static_cast<GByte *>(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            for( int y = 0; y < nBufYSize; )\n            {\n                const int nSrcLine = nYOff + y;\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int nUsedBlockHeight =\n                    std::min( nBufYSize - y,\n                              m_nBlockYSize - nYOffsetIm_nBlock);\n\n                int nBlockXOff = nXOff / m_nBlockXSize;\n                int nXOffsetInBlock = nXOff % m_nBlockXSize;\n                int nBlockId = nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                {\n                    REACHED(33);\n                    nBlockId += m_nBlocksPerBand * (nBand - 1);\n                }\n                else\n                {\n                    REACHED(34);\n                }\n\n                int x = 0;\n                while( x < nBufXSize )\n                {\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    const int nUsedBlockWidth =\n                        std::min(\n                            m_nBlockXSize - nXOffsetInBlock,\n                            nBufXSize - x);\n\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(35);\n                        for( int k = 0; k < nUsedBlockHeight; ++k )\n                        {\n                            GByte* pabyLocalData =\n                                pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData, eBufType,\n                                static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth );\n                        }\n                    }\n                    else\n                    {\n                        const int nByteOffsetIm_nBlock =\n                            nYOffsetIm_nBlock * m_nBlockXSize *\n                            nBandsPerBlockDTSize;\n                        const GByte* pabyLocalSrcDataK0 =\n                            oFetcher.FetchBytes(\n                                nCurOffset + nByteOffsetIm_nBlock,\n                                m_nBlockXSize *\n                                nUsedBlockHeight * nBandsPerBlock,\n                                nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                        if( pabyLocalSrcDataK0 == nullptr )\n                            return CE_Failure;\n\n                        if( m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                        {\n                            REACHED(36);\n                            pabyLocalSrcDataK0 += (nBand - 1) * nDTSize;\n                        }\n                        else\n                        {\n                            REACHED(37);\n                        }\n\n                        for( int k = 0; k < nUsedBlockHeight; ++k )\n                        {\n                            GByte* pabyLocalData =\n                                pabyData + (y + k) * nLineSpace +\n                                x * nPixelSpace;\n                            const GByte* pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (k * m_nBlockXSize + nXOffsetInBlock) *\n                                nBandsPerBlockDTSize;\n\n                            GDALCopyWords(\n                                pabyLocalSrcData,\n                                eDataType, nBandsPerBlockDTSize,\n                                pabyLocalData,\n                                eBufType, static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth);\n                        }\n                    }\n\n                    nXOffsetInBlock = 0;\n                    ++nBlockXOff;\n                    ++nBlockId;\n                    x += nUsedBlockWidth;\n                }\n\n                y += nUsedBlockHeight;\n            }\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( m_hTIFF ) &&\n             m_nPlanarConfig == PLANARCONFIG_CONTIG && nBandCount > 1 )\n    {\n        GByte* pabyData = static_cast<GByte *>(pData);\n        int anSrcYOffset[256] = { 0 };\n        for( int y = 0; y < nBufYSize; )\n        {\n            const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n            const int nSrcLine = static_cast<int>(dfYOffStart);\n            const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n            const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n            const int nBaseByteOffsetIm_nBlock =\n                nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n            int ychunk = 1;\n            int nLastSrcLineK = nSrcLine;\n            anSrcYOffset[0] = 0;\n            for( int k = 1; k < nBufYSize - y; ++k )\n            {\n                int nSrcLineK =\n                    nYOff + static_cast<int>((y + k + 0.5) * dfSrcYInc);\n                const int nBlockYOffK = nSrcLineK / m_nBlockYSize;\n                if( k < 256)\n                    anSrcYOffset[k] =\n                        ((nSrcLineK % m_nBlockYSize) - nYOffsetIm_nBlock) *\n                        m_nBlockXSize * nBandsPerBlockDTSize;\n                if( nBlockYOffK != m_nBlockYOff )\n                {\n                    break;\n                }\n                ++ychunk;\n                nLastSrcLineK = nSrcLineK;\n            }\n            const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n            // CPLAssert(nUsedBlockHeight <= m_nBlockYSize);\n\n            double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n            int nCurBlockXOff = 0;\n            int nNextBlockXOff = 0;\n            toff_t nCurOffset = 0;\n            const GByte* pabyLocalSrcDataStartLine = nullptr;\n            for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc)\n            {\n                const int nSrcPixel = static_cast<int>(dfSrcX);\n                if( nSrcPixel >= nNextBlockXOff )\n                {\n                    const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                    nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                    nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                    const int nBlockId =\n                        nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                    nCurOffset = panOffsets[nBlockId];\n                    if( nCurOffset != 0 )\n                    {\n                        pabyLocalSrcDataStartLine =\n                            oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetIm_nBlock,\n                                m_nBlockXSize *\n                                nBandsPerBlock * nUsedBlockHeight,\n                                nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId);\n                        if( pabyLocalSrcDataStartLine == nullptr )\n                            return CE_Failure;\n                    }\n                }\n\n                if( nCurOffset == 0 )\n                {\n                    REACHED(38);\n\n                    for( int k = 0; k < ychunk; ++k )\n                    {\n                        GByte* const pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for( int iBand = 0; iBand < nBandCount; ++iBand )\n                        {\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData + nBandSpace * iBand, eBufType, 0,\n                                1);\n                        }\n                    }\n                }\n                else\n                {\n                    const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                    double dfYOff = dfYOffStart;\n                    const GByte* const pabyLocalSrcDataK0 =\n                        pabyLocalSrcDataStartLine +\n                        nXOffsetInBlock * nBandsPerBlockDTSize;\n                    GByte* pabyLocalData =\n                        pabyData + y * nLineSpace + x * nPixelSpace;\n                    for( int k = 0;\n                         k < ychunk;\n                         ++k, pabyLocalData += nLineSpace )\n                    {\n                        const GByte* pabyLocalSrcData = nullptr;\n                        if( ychunk <= 256 )\n                        {\n                            REACHED(39);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 + anSrcYOffset[k];\n                        }\n                        else\n                        {\n                            REACHED(40);\n                            const int nYOffsetIm_nBlockK =\n                                static_cast<int>(dfYOff) % m_nBlockYSize;\n                            // CPLAssert(\n                            //     nYOffsetIm_nBlockK - nYOffsetIm_nBlock <=\n                            //     nUsedBlockHeight);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (nYOffsetIm_nBlockK - nYOffsetIm_nBlock) *\n                                m_nBlockXSize * nBandsPerBlockDTSize;\n                            dfYOff += dfSrcYInc;\n                        }\n\n                        if( bByteOnly )\n                        {\n                            REACHED(41);\n                            for( int iBand=0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData + (panBandMap[iBand]-1);\n                                *pabyLocalDataBand = *pabyLocalSrcDataBand;\n                            }\n                        }\n                        else\n                        {\n                            REACHED(42);\n                            for( int iBand = 0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand]-1) * nDTSize;\n\n                                GDALCopyWords( pabyLocalSrcDataBand,\n                                               eDataType, 0,\n                                               pabyLocalDataBand,\n                                               eBufType, 0,\n                                               1 );\n                            }\n                        }\n                    }\n                }\n            }\n\n            y += ychunk;\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( m_hTIFF ) )\n             // && (m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            GByte* pabyData = static_cast<GByte*>(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            int anSrcYOffset[256] = { 0 };\n            for( int y = 0; y < nBufYSize; )\n            {\n                const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n                const int nSrcLine = static_cast<int>(dfYOffStart);\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nBaseByteOffsetIm_nBlock =\n                    nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n                int ychunk = 1;\n                int nLastSrcLineK = nSrcLine;\n                anSrcYOffset[0] = 0;\n                for( int k = 1; k < nBufYSize - y; ++k )\n                {\n                    const int nSrcLineK =\n                        nYOff + static_cast<int>((y + k + 0.5) * dfSrcYInc);\n                    const int nBlockYOffK = nSrcLineK / m_nBlockYSize;\n                    if( k < 256)\n                        anSrcYOffset[k] =\n                            ((nSrcLineK % m_nBlockYSize) - nYOffsetIm_nBlock) *\n                            m_nBlockXSize * nBandsPerBlockDTSize;\n                    if( nBlockYOffK != m_nBlockYOff )\n                    {\n                        break;\n                    }\n                    ++ychunk;\n                    nLastSrcLineK = nSrcLineK;\n                }\n                const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n                // CPLAssert(nUsedBlockHeight <= m_nBlockYSize);\n\n                double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                int nCurBlockXOff = 0;\n                int nNextBlockXOff = 0;\n                toff_t nCurOffset = 0;\n                const GByte* pabyLocalSrcDataStartLine = nullptr;\n                for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc )\n                {\n                    int nSrcPixel = static_cast<int>(dfSrcX);\n                    if( nSrcPixel >= nNextBlockXOff )\n                    {\n                        const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                        nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                        nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                        int nBlockId = nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                        if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                        {\n                            REACHED(43);\n                            nBlockId += m_nBlocksPerBand * (nBand - 1);\n                        }\n                        else\n                        {\n                            REACHED(44);\n                        }\n                        nCurOffset = panOffsets[nBlockId];\n                        if( nCurOffset != 0 )\n                        {\n                            pabyLocalSrcDataStartLine =\n                                oFetcher.FetchBytes(\n                                    nCurOffset + nBaseByteOffsetIm_nBlock,\n                                    m_nBlockXSize *\n                                    nBandsPerBlock * nUsedBlockHeight,\n                                    nDTSize,\n                                    bIsByteSwapped, bIsComplex, nBlockId);\n                            if( pabyLocalSrcDataStartLine == nullptr )\n                                return CE_Failure;\n\n                            if( m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                            {\n                                REACHED(45);\n                                pabyLocalSrcDataStartLine +=\n                                    (nBand - 1) * nDTSize;\n                            }\n                            else\n                            {\n                                REACHED(46);\n                            }\n                        }\n                    }\n\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(47);\n\n                        for( int k = 0; k < ychunk; ++k )\n                        {\n                            GByte* const pabyLocalData =\n                                pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n\n                            GDALCopyWords( &dfNoData, GDT_Float64, 0,\n                                           pabyLocalData, eBufType, 0,\n                                           1 );\n                        }\n                    }\n                    else\n                    {\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                        double dfYOff = dfYOffStart;\n                        const GByte* const pabyLocalSrcDataK0 =\n                            pabyLocalSrcDataStartLine +\n                            nXOffsetInBlock * nBandsPerBlockDTSize;\n                        GByte* pabyLocalData =\n                            pabyData + y * nLineSpace + x * nPixelSpace;\n                        for( int k = 0;\n                             k < ychunk;\n                             ++k, pabyLocalData += nLineSpace )\n                        {\n                            const GByte* pabyLocalSrcData = nullptr;\n                            if( ychunk <= 256 )\n                            {\n                                REACHED(48);\n                                pabyLocalSrcData =\n                                    pabyLocalSrcDataK0 + anSrcYOffset[k];\n                            }\n                            else\n                            {\n                                REACHED(49);\n                                const int nYOffsetIm_nBlockK =\n                                    static_cast<int>(dfYOff) % m_nBlockYSize;\n                                // CPLAssert(\n                                //     nYOffsetIm_nBlockK - nYOffsetIm_nBlock <=\n                                //     nUsedBlockHeight);\n                                pabyLocalSrcData = pabyLocalSrcDataK0 +\n                                    (nYOffsetIm_nBlockK - nYOffsetIm_nBlock) *\n                                    m_nBlockXSize * nBandsPerBlockDTSize;\n                                dfYOff += dfSrcYInc;\n                            }\n\n                            if( bByteOnly )\n                            {\n                                REACHED(50);\n\n                                *pabyLocalData = *pabyLocalSrcData;\n                            }\n                            else\n                            {\n                                REACHED(51);\n\n                                GDALCopyWords( pabyLocalSrcData,\n                                               eDataType, 0,\n                                               pabyLocalData,\n                                               eBufType, 0,\n                                               1 );\n                            }\n                        }\n                    }\n                }\n\n                y += ychunk;\n            }\n        }\n    }\n    else if( bUseContigImplementation )\n    {\n        if( !FetchBuffer::bMinimizeIO && TIFFIsTiled( m_hTIFF ) )\n        {\n            GByte* pabyData = static_cast<GByte *>(pData);\n            for( int y = 0; y < nBufYSize; ++y )\n            {\n                const int nSrcLine =\n                    nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int nBaseByteOffsetIm_nBlock =\n                    nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n\n                if( bNoXResampling )\n                {\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    int nBlockXOff = nXOff / m_nBlockXSize;\n                    int nXOffsetInBlock = nXOff % m_nBlockXSize;\n                    int nBlockId = nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n\n                    int x = 0;\n                    while( x < nBufXSize )\n                    {\n                        const int nByteOffsetIm_nBlock = nBaseByteOffsetIm_nBlock +\n                                        nXOffsetInBlock * nBandsPerBlockDTSize;\n                        const toff_t nCurOffset = panOffsets[nBlockId];\n                        const int nUsedBlockWidth =\n                            std::min(\n                                m_nBlockXSize - nXOffsetInBlock,\n                                nBufXSize - x);\n\n                        int nIters = nUsedBlockWidth;\n                        if( nCurOffset == 0 )\n                        {\n                            if( bByteNoXResampling )\n                            {\n                                REACHED(0);\n                                while( nIters-- > 0 )\n                                {\n                                    for( int iBand = 0;\n                                         iBand < nBandCount;\n                                         ++iBand )\n                                    {\n                                        pabyLocalData[iBand] = abyNoData;\n                                    }\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                            else\n                            {\n                                REACHED(1);\n                                while( nIters-- > 0 )\n                                {\n                                    GDALCopyWords(\n                                        &dfNoData, GDT_Float64, 0,\n                                        pabyLocalData, eBufType,\n                                        static_cast<int>(nBandSpace),\n                                        nBandCount);\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if( bNoTypeChange && nBands == nBandCount &&\n                                nPixelSpace == nBandsPerBlockDTSize )\n                            {\n                                REACHED(2);\n                                if( !oFetcher.FetchBytes(\n                                        pabyLocalData,\n                                        nCurOffset + nByteOffsetIm_nBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId) )\n                                {\n                                    return CE_Failure;\n                                }\n                                pabyLocalData +=\n                                    nIters * nBandsPerBlock * nDTSize;\n                            }\n                            else\n                            {\n                                const GByte* pabyLocalSrcData =\n                                    oFetcher.FetchBytes(\n                                        nCurOffset + nByteOffsetIm_nBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId);\n                                if( pabyLocalSrcData == nullptr )\n                                    return CE_Failure;\n                                if( bByteNoXResampling )\n                                {\n                                    REACHED(3);\n                                    CopyContigByteMultiBand(\n                                        pabyLocalSrcData,\n                                        nBandsPerBlockDTSize,\n                                        pabyLocalData,\n                                        static_cast<int>(nPixelSpace),\n                                        nIters,\n                                        nBandCount);\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    REACHED(4);\n                                    while( nIters-- > 0 )\n                                    {\n                                        GDALCopyWords(\n                                            pabyLocalSrcData,\n                                            eDataType, nDTSize,\n                                            pabyLocalData,\n                                            eBufType,\n                                            static_cast<int>(nBandSpace),\n                                            nBandCount);\n                                        pabyLocalSrcData +=\n                                            nBandsPerBlockDTSize;\n                                        pabyLocalData += nPixelSpace;\n                                    }\n                                }\n                            }\n                        }\n\n                        nXOffsetInBlock = 0;\n                        ++nBlockXOff;\n                        ++nBlockId;\n                        x += nUsedBlockWidth;\n                    }\n                }\n                else  // Contig, tiled, potential resampling & data type change.\n                {\n                    const GByte* pabyLocalSrcDataStartLine = nullptr;\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                    int nCurBlockXOff = 0;\n                    int nNextBlockXOff = 0;\n                    toff_t nCurOffset = 0;\n                    for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc )\n                    {\n                        int nSrcPixel = static_cast<int>(dfSrcX);\n                        if( nSrcPixel >= nNextBlockXOff )\n                        {\n                            const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                            nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                            nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                            const int nBlockId =\n                                nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                            nCurOffset = panOffsets[nBlockId];\n                            if( nCurOffset != 0 )\n                            {\n                                pabyLocalSrcDataStartLine =\n                                    oFetcher.FetchBytes(\n                                        nCurOffset + nBaseByteOffsetIm_nBlock,\n                                        m_nBlockXSize *\n                                        nBandsPerBlock,\n                                        nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId);\n                                if( pabyLocalSrcDataStartLine == nullptr )\n                                    return CE_Failure;\n                            }\n                        }\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n\n                        if( nCurOffset == 0 )\n                        {\n                            REACHED(5);\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData,\n                                eBufType,\n                                static_cast<int>(nBandSpace),\n                                nBandCount );\n                            pabyLocalData += nPixelSpace;\n                        }\n                        else\n                        {\n                            const GByte* pabyLocalSrcData =\n                                pabyLocalSrcDataStartLine +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                            REACHED(6);\n                            if( bByteOnly )\n                            {\n                                for( int iBand = 0; iBand < nBands; ++iBand )\n                                    pabyLocalData[iBand] =\n                                        pabyLocalSrcData[iBand];\n                            }\n                            else\n                            {\n                                GDALCopyWords(\n                                    pabyLocalSrcData,\n                                    eDataType, nDTSize,\n                                    pabyLocalData,\n                                    eBufType,\n                                    static_cast<int>(nBandSpace),\n                                    nBandCount );\n                            }\n                            pabyLocalData += nPixelSpace;\n                        }\n                    }\n                }\n            }\n        }\n        else  // Contig, striped organized.\n        {\n            GByte* pabyData = static_cast<GByte*>(pData);\n            for( int y = 0; y < nBufYSize; ++y )\n            {\n                const int nSrcLine =\n                    nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int nBlockId = m_nBlockYOff;\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                if( nCurOffset == 0 )\n                {\n                    REACHED(7);\n                    for( int x = 0; x < nBufXSize; ++x )\n                    {\n                        GDALCopyWords(\n                            &dfNoData, GDT_Float64, 0,\n                            pabyData + y * nLineSpace + x * nPixelSpace,\n                            eBufType, static_cast<int>(nBandSpace),\n                            nBandCount);\n                    }\n                }\n                else\n                {\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    const int nBaseByteOffsetIm_nBlock =\n                        (nYOffsetIm_nBlock * m_nBlockXSize + nXOff) *\n                        nBandsPerBlockDTSize;\n\n                    if( bNoXResamplingNoTypeChange && nBands == nBandCount &&\n                        nPixelSpace == nBandsPerBlockDTSize )\n                    {\n                        REACHED(8);\n                        if( !oFetcher.FetchBytes(\n                               pabyLocalData,\n                               nCurOffset + nBaseByteOffsetIm_nBlock,\n                               nXSize * nBandsPerBlock, nDTSize, bIsByteSwapped,\n                               bIsComplex, nBlockId) )\n                        {\n                            return CE_Failure;\n                        }\n                    }\n                    else\n                    {\n                        const GByte* pabyLocalSrcData = oFetcher.FetchBytes(\n                            nCurOffset + nBaseByteOffsetIm_nBlock,\n                            nXSize * nBandsPerBlock, nDTSize, bIsByteSwapped,\n                            bIsComplex, nBlockId);\n                        if( pabyLocalSrcData == nullptr )\n                            return CE_Failure;\n\n                        if( bByteNoXResampling )\n                        {\n                            REACHED(9);\n                            CopyContigByteMultiBand(\n                                pabyLocalSrcData,\n                                nBandsPerBlockDTSize,\n                                pabyLocalData,\n                                static_cast<int>(nPixelSpace),\n                                nBufXSize,\n                                nBandCount);\n                        }\n                        else if( bByteOnly )\n                        {\n                            REACHED(10);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for( int x = 0;\n                                 x < nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc )\n                            {\n                                const int nSrcPixelMinusXOff =\n                                    static_cast<int>(dfSrcX);\n                                for( int iBand = 0;\n                                     iBand < nBandCount;\n                                     ++iBand )\n                                {\n                                    pabyLocalData[x * nPixelSpace + iBand] =\n                                        pabyLocalSrcData[nSrcPixelMinusXOff *\n                                                         nBandsPerBlockDTSize +\n                                                         iBand];\n                                }\n                            }\n                        }\n                        else\n                        {\n                            REACHED(11);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for( int x = 0;\n                                 x < nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc )\n                            {\n                                int nSrcPixelMinusXOff =\n                                    static_cast<int>(dfSrcX);\n                                GDALCopyWords(\n                                    pabyLocalSrcData +\n                                    nSrcPixelMinusXOff * nBandsPerBlockDTSize,\n                                    eDataType, nDTSize,\n                                    pabyLocalData + x * nPixelSpace,\n                                    eBufType,\n                                    static_cast<int>(nBandSpace),\n                                    nBandCount );\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else  // Non-contig reading case.\n    {\n        if( !FetchBuffer::bMinimizeIO && TIFFIsTiled( m_hTIFF ) )\n        {\n            for( int iBand = 0; iBand < nBandCount; ++iBand )\n            {\n                const int nBand = panBandMap[iBand];\n                GByte* const pabyData =\n                    static_cast<GByte*>(pData) + iBand * nBandSpace;\n                for( int y = 0; y < nBufYSize; ++y )\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                    const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                    const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n\n                    int nBaseByteOffsetIm_nBlock =\n                        nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n                    if( m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                    {\n                        REACHED(12);\n                        nBaseByteOffsetIm_nBlock += (nBand - 1) * nDTSize;\n                    }\n                    else\n                    {\n                        REACHED(13);\n                    }\n\n                    if( bNoXResampling )\n                    {\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        int nBlockXOff = nXOff / m_nBlockXSize;\n                        int nBlockId = nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                        if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                        {\n                            REACHED(14);\n                            nBlockId += m_nBlocksPerBand * (nBand - 1);\n                        }\n                        else\n                        {\n                            REACHED(15);\n                        }\n                        int nXOffsetInBlock = nXOff % m_nBlockXSize;\n\n                        int x = 0;\n                        while( x < nBufXSize )\n                        {\n                            const int nByteOffsetIm_nBlock =\n                                nBaseByteOffsetIm_nBlock +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n                            const toff_t nCurOffset = panOffsets[nBlockId];\n                            const int nUsedBlockWidth =\n                                std::min(\n                                    m_nBlockXSize - nXOffsetInBlock,\n                                    nBufXSize - x );\n                            int nIters = nUsedBlockWidth;\n\n                            if( nCurOffset == 0 )\n                            {\n                                REACHED(16);\n                                GDALCopyWords(\n                                    &dfNoData, GDT_Float64, 0,\n                                    pabyLocalData, eBufType,\n                                    static_cast<int>(nPixelSpace),\n                                    nIters);\n                                pabyLocalData += nIters * nPixelSpace;\n                            }\n                            else\n                            {\n                                if( bNoTypeChange &&\n                                    nPixelSpace == nBandsPerBlockDTSize )\n                                {\n                                    REACHED(17);\n                                    if( !oFetcher.FetchBytes(\n                                           pabyLocalData,\n                                           nCurOffset + nByteOffsetIm_nBlock,\n                                           (nIters - 1) * nBandsPerBlock + 1,\n                                           nDTSize,\n                                           bIsByteSwapped, bIsComplex,\n                                           nBlockId) )\n                                    {\n                                        return CE_Failure;\n                                    }\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    const GByte* pabyLocalSrcData =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset + nByteOffsetIm_nBlock,\n                                            (nIters - 1) * nBandsPerBlock + 1,\n                                            nDTSize,\n                                            bIsByteSwapped,\n                                            bIsComplex,\n                                            nBlockId );\n                                    if( pabyLocalSrcData == nullptr )\n                                        return CE_Failure;\n\n                                    REACHED(18);\n                                    GDALCopyWords(\n                                        pabyLocalSrcData, eDataType,\n                                        nBandsPerBlockDTSize,\n                                        pabyLocalData, eBufType,\n                                        static_cast<int>(nPixelSpace),\n                                        nIters );\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                            }\n\n                            nXOffsetInBlock = 0;\n                            ++nBlockXOff;\n                            ++nBlockId;\n                            x += nUsedBlockWidth;\n                        }\n                    }\n                    else\n                    {\n                        // Non-contig reading, tiled, potential resampling and\n                        // data type change.\n\n                        const GByte* pabyLocalSrcDataStartLine = nullptr;\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                        int nCurBlockXOff = 0;\n                        int nNextBlockXOff = 0;\n                        toff_t nCurOffset = 0;\n                        for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc)\n                        {\n                            const int nSrcPixel = static_cast<int>(dfSrcX);\n                            if( nSrcPixel >= nNextBlockXOff )\n                            {\n                                const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                                nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                                nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                                int nBlockId =\n                                    nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                                if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                                {\n                                    REACHED(19);\n                                    nBlockId += m_nBlocksPerBand * (nBand - 1);\n                                }\n                                else\n                                {\n                                    REACHED(20);\n                                }\n                                nCurOffset = panOffsets[nBlockId];\n                                if( nCurOffset != 0 )\n                                {\n                                    pabyLocalSrcDataStartLine =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset + nBaseByteOffsetIm_nBlock,\n                                            m_nBlockXSize * nBandsPerBlock,\n                                            nDTSize,\n                                            bIsByteSwapped,\n                                            bIsComplex,\n                                            nBlockId);\n                                    if( pabyLocalSrcDataStartLine == nullptr )\n                                        return CE_Failure;\n                                }\n                            }\n                            const int nXOffsetInBlock =\n                                nSrcPixel - nCurBlockXOff;\n\n                            if( nCurOffset == 0 )\n                            {\n                                REACHED(21);\n                                GDALCopyWords( &dfNoData, GDT_Float64, 0,\n                                               pabyLocalData,\n                                               eBufType, 0,\n                                               1 );\n                                pabyLocalData += nPixelSpace;\n                            }\n                            else\n                            {\n                                const GByte* pabyLocalSrcData =\n                                    pabyLocalSrcDataStartLine +\n                                    nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                                REACHED(22);\n                                if( bByteOnly )\n                                {\n                                    *pabyLocalData = *pabyLocalSrcData;\n                                }\n                                else\n                                {\n                                    GDALCopyWords(pabyLocalSrcData,\n                                                eDataType, 0,\n                                                pabyLocalData,\n                                                eBufType, 0,\n                                                1);\n                                }\n                                pabyLocalData += nPixelSpace;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else  // Non-contig reading, striped.\n        {\n            for( int iBand = 0; iBand < nBandCount; ++iBand )\n            {\n                const int nBand = panBandMap[iBand];\n                GByte* pabyData =\n                    static_cast<GByte *>(pData) + iBand * nBandSpace;\n                for( int y = 0; y < nBufYSize; ++y )\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                    const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                    const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                    int nBlockId = m_nBlockYOff;\n                    if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                    {\n                        REACHED(23);\n                        nBlockId += m_nBlocksPerBand * (nBand - 1);\n                    }\n                    else\n                    {\n                        REACHED(24);\n                    }\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(25);\n                        GDALCopyWords(\n                            &dfNoData, GDT_Float64, 0,\n                            pabyData + y * nLineSpace,\n                            eBufType,\n                            static_cast<int>(nPixelSpace),\n                            nBufXSize);\n                    }\n                    else\n                    {\n                        int nBaseByteOffsetIm_nBlock =\n                            (nYOffsetIm_nBlock * m_nBlockXSize + nXOff) *\n                            nBandsPerBlockDTSize;\n                        if( m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                            nBaseByteOffsetIm_nBlock += (nBand - 1) * nDTSize;\n\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        if( bNoXResamplingNoTypeChange &&\n                            nPixelSpace == nBandsPerBlockDTSize )\n                        {\n                            REACHED(26);\n                            if( !oFetcher.FetchBytes(\n                                pabyLocalData,\n                                nCurOffset + nBaseByteOffsetIm_nBlock,\n                                (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId) )\n                            {\n                                return CE_Failure;\n                            }\n                        }\n                        else\n                        {\n                            const GByte* pabyLocalSrcData = oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetIm_nBlock,\n                                (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId);\n                            if( pabyLocalSrcData == nullptr )\n                                return CE_Failure;\n\n                            if( bNoXResamplingNoTypeChange )\n                            {\n                                REACHED(27);\n                                GDALCopyWords(pabyLocalSrcData,\n                                              eDataType, nBandsPerBlockDTSize,\n                                              pabyLocalData, eBufType,\n                                              static_cast<int>(nPixelSpace),\n                                              nBufXSize);\n                            }\n                            else if( bByteOnly )\n                            {\n                                REACHED(28);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for( int x = 0;\n                                     x < nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc )\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast<int>(dfSrcX);\n                                    pabyLocalData[x * nPixelSpace] =\n                                        pabyLocalSrcData[nSrcPixelMinusXOff *\n                                                         nBandsPerBlockDTSize];\n                                }\n                            }\n                            else\n                            {\n                                REACHED(29);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for( int x = 0;\n                                     x < nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc )\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast<int>(dfSrcX);\n                                    GDALCopyWords(\n                                        pabyLocalSrcData +\n                                        nSrcPixelMinusXOff *\n                                        nBandsPerBlockDTSize,\n                                        eDataType, 0,\n                                        pabyLocalData + x * nPixelSpace,\n                                        eBufType, 0,\n                                        1 );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           DirectIO()                                 */\n/************************************************************************/\n\n// Reads directly bytes from the file using ReadMultiRange(), and by-pass\n// block reading. Restricted to simple TIFF configurations\n// (uncompressed data, standard data types). Particularly useful to extract\n// sub-windows of data on a large /vsicurl dataset).\n// Returns -1 if DirectIO() can't be supported on that file.\n\nint GTiffDataset::DirectIO( GDALRWFlag eRWFlag,\n                            int nXOff, int nYOff, int nXSize, int nYSize,\n                            void * pData, int nBufXSize, int nBufYSize,\n                            GDALDataType eBufType,\n                            int nBandCount, int *panBandMap,\n                            GSpacing nPixelSpace, GSpacing nLineSpace,\n                            GSpacing nBandSpace,\n                            GDALRasterIOExtraArg* psExtraArg )\n{\n    const GDALDataType eDataType = GetRasterBand(1)->GetRasterDataType();\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(eRWFlag == GF_Read &&\n          m_nCompression == COMPRESSION_NONE &&\n          (m_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           m_nPhotometric == PHOTOMETRIC_RGB ||\n           m_nPhotometric == PHOTOMETRIC_PALETTE) &&\n          m_nBitsPerSample == nDTSizeBits) )\n    {\n        return -1;\n    }\n    Crystalize();\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) &&\n        psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n    // If the file is band interleave or only one band is requested, then\n    // fallback to band DirectIO.\n    bool bUseBandRasterIO = false;\n    if( m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1 )\n    {\n        bUseBandRasterIO = true;\n    }\n    else\n    {\n        // For simplicity, only deals with \"naturally ordered\" bands.\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            if( panBandMap[iBand] != iBand + 1)\n            {\n                bUseBandRasterIO = true;\n                break;\n            }\n        }\n    }\n    if( bUseBandRasterIO )\n    {\n        CPLErr eErr = CE_None;\n        for( int iBand = 0; eErr == CE_None && iBand < nBandCount; ++iBand )\n        {\n            eErr = GetRasterBand(panBandMap[iBand])->RasterIO(\n                eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                static_cast<GByte *>(pData) + iBand * nBandSpace,\n                nBufXSize, nBufYSize,\n                eBufType,\n                nPixelSpace, nLineSpace,\n                psExtraArg );\n        }\n        return eErr;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"DirectIO(%d,%d,%d,%d -> %dx%d)\",\n              nXOff, nYOff, nXSize, nYSize,\n              nBufXSize, nBufYSize );\n#endif\n\n    // No need to look if overviews can satisfy the request as it has already */\n    // been done in GTiffDataset::IRasterIO().\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( GetAccess() == GA_Update )\n    {\n        FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( m_hTIFF ) );\n    }\n\n    if( TIFFIsTiled( m_hTIFF ) )\n    {\n        const int nDTSize = nDTSizeBits / 8;\n        const size_t nTempBufferForCommonDirectIOSize =\n            static_cast<size_t>(static_cast<GPtrDiff_t>(m_nBlockXSize) * m_nBlockYSize * nDTSize *\n            ((m_nPlanarConfig == PLANARCONFIG_CONTIG) ? nBands : 1));\n        if( m_pTempBufferForCommonDirectIO == nullptr )\n        {\n            m_pTempBufferForCommonDirectIO =\n                static_cast<GByte *>(\n                    VSI_MALLOC_VERBOSE(nTempBufferForCommonDirectIOSize) );\n            if( m_pTempBufferForCommonDirectIO == nullptr )\n                return CE_Failure;\n        }\n\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n        FetchBufferDirectIO oFetcher(fp, m_pTempBufferForCommonDirectIO,\n                                     nTempBufferForCommonDirectIOSize);\n\n        return CommonDirectIO( oFetcher,\n                               nXOff, nYOff, nXSize, nYSize,\n                               pData, nBufXSize, nBufYSize,\n                               eBufType,\n                               nBandCount, panBandMap,\n                               nPixelSpace, nLineSpace,\n                              nBandSpace );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    void** ppData =\n        static_cast<void **>( VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void*)) );\n    vsi_l_offset* panOffsets =\n        static_cast<vsi_l_offset *>(\n            VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)) );\n    size_t* panSizes =\n        static_cast<size_t *>( VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)) );\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void* pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands = nBands;\n    const int nSrcPixelSize = nDTSize * nContigBands;\n\n    if( ppData == nullptr || panOffsets == nullptr || panSizes == nullptr )\n    {\n        eErr = CE_Failure;\n    }\n    // For now we always allocate a temp buffer as it is easier.\n    else\n        // if( nXSize != nBufXSize || nYSize != nBufYSize ||\n        //   eBufType != eDataType ||\n        //   nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n        //   check if the user buffer is large enough )\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC_VERBOSE(nReqXSize * nReqYSize * nSrcPixelSize);\n        if( pTmpBuffer == nullptr )\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    for( int iLine = 0; eErr == CE_None && iLine < nReqYSize; ++iLine )\n    {\n        ppData[iLine] =\n            static_cast<GByte *>(pTmpBuffer) +\n            iLine * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if( nBufYSize < nYSize )  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast<int>((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / m_nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % m_nBlockYSize;\n        const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n        const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if( panOffsets[iLine] == 0)  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff + nYOffsetInBlock * m_nBlockXSize) * nSrcPixelSize;\n        panSizes[iLine] = nReqXSize * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if( eErr == CE_None )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n        const int nRet =\n            VSIFReadMultiRangeL(nReqYSize, ppData, panOffsets, panSizes, fp);\n        if( nRet != 0 )\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if( eErr == CE_None && TIFFIsByteSwapped(m_hTIFF) )\n    {\n        for( int iLine = 0; iLine < nReqYSize; ++iLine )\n        {\n            if( GDALDataTypeIsComplex(eDataType) )\n                GDALSwapWords( ppData[iLine], nDTSize / 2,\n                               2 * nReqXSize * nContigBands, nDTSize / 2);\n            else\n                GDALSwapWords( ppData[iLine], nDTSize,\n                               nReqXSize * nContigBands, nDTSize);\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    if( eErr == CE_None && pTmpBuffer != nullptr )\n    {\n        for( int iY = 0; iY < nBufYSize; ++iY )\n        {\n            const int iSrcY =\n                nBufYSize <= nYSize ?\n                iY : static_cast<int>((iY + 0.5) * dfSrcYInc);\n            // Optimization: no resampling, no data type change, number of\n            // bands requested == number of bands and buffer is packed\n            // pixel-interleaved.\n            if( nBufXSize == nXSize && nContigBands == nBandCount &&\n                eDataType == eBufType &&\n                nBandSpace == nDTSize &&\n                nPixelSpace == nBandCount * nBandSpace )\n            {\n                memcpy(\n                    static_cast<GByte *>(pData) + iY * nLineSpace,\n                    ppData[iSrcY],\n                    static_cast<size_t>(nReqXSize * nPixelSpace) );\n            }\n            // Other optimization: no resampling, no data type change,\n            // data type is Byte.\n            else if( nBufXSize == nXSize &&\n                     eDataType == eBufType && eDataType == GDT_Byte )\n            {\n                GByte* pabySrcData = static_cast<GByte *>(ppData[iSrcY]);\n                GByte* pabyDstData =\n                    static_cast<GByte *>(pData) + iY * nLineSpace;\n                if( nBandSpace == 1 && nPixelSpace > nBandCount )\n                {\n                    // Buffer is pixel-interleaved (with some stridding\n                    // between pixels).\n                    CopyContigByteMultiBand( pabySrcData, nSrcPixelSize,\n                                             pabyDstData,\n                                             static_cast<int>(nPixelSpace),\n                                             nBufXSize, nBandCount );\n                }\n                else\n                {\n                    for( int iBand = 0; iBand < nBandCount; ++iBand )\n                    {\n                        GDALCopyWords(\n                            pabySrcData + iBand, GDT_Byte, nSrcPixelSize,\n                            pabyDstData + iBand * nBandSpace,\n                            GDT_Byte, static_cast<int>(nPixelSpace),\n                            nBufXSize );\n                    }\n                }\n            }\n            else  // General case.\n            {\n                for( int iBand = 0; iBand < nBandCount; ++iBand )\n                {\n                    GByte* pabySrcData =\n                        static_cast<GByte *>(ppData[iSrcY]) + iBand * nDTSize;\n                    GByte* pabyDstData =\n                        static_cast<GByte *>(pData) +\n                        iBand * nBandSpace + iY * nLineSpace;\n                    if( eDataType == GDT_Byte && eBufType == GDT_Byte )\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for( int iX = 0;\n                             iX < nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast<int>(dfSrcX);\n                            pabyDstData[iX * nPixelSpace] =\n                                pabySrcData[iSrcX * nSrcPixelSize];\n                        }\n                    }\n                    else\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for( int iX = 0;\n                             iX < nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast<int>(dfSrcX);\n                            GDALCopyWords( pabySrcData + iSrcX * nSrcPixelSize,\n                                        eDataType, 0,\n                                        pabyDstData + iX * nPixelSpace,\n                                        eBufType, 0, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                         CacheMultiRange()                            */\n/************************************************************************/\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\nstatic bool CheckTrailer(const GByte* strileData, vsi_l_offset nStrileSize)\n{\n    GByte abyTrailer[4];\n    memcpy(abyTrailer,strileData + nStrileSize, 4);\n    GByte abyLastBytes[4] = {};\n    if( nStrileSize >= 4 )\n        memcpy(abyLastBytes, strileData + nStrileSize - 4, 4);\n    else\n    {\n        // The last bytes will be zero due to the above {} initialization,\n        // and that's what should be in abyTrailer too when the trailer is\n        // correct.\n        memcpy(abyLastBytes, strileData, static_cast<size_t>(nStrileSize));\n    }\n    return memcmp(abyTrailer, abyLastBytes, 4) == 0;\n}\n#endif\n\nvoid* GTiffRasterBand::CacheMultiRange( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nBufXSize, int nBufYSize,\n                                        GDALRasterIOExtraArg* psExtraArg )\n{\n    void* pBufferedData = nullptr;\n    // Same logic as in GDALRasterBand::IRasterIO()\n    double dfXOff = nXOff;\n    double dfYOff = nYOff;\n    double dfXSize = nXSize;\n    double dfYSize = nYSize;\n    if( psExtraArg->bFloatingPointWindowValidity )\n    {\n        dfXOff = psExtraArg->dfXOff;\n        dfYOff = psExtraArg->dfYOff;\n        dfXSize = psExtraArg->dfXSize;\n        dfYSize = psExtraArg->dfYSize;\n    }\n    const double dfSrcXInc = dfXSize / static_cast<double>( nBufXSize );\n    const double dfSrcYInc = dfYSize / static_cast<double>( nBufYSize );\n    const double EPS = 1e-10;\n    const int nBlockX1 = static_cast<int>(std::max(0.0, (0+0.5) * dfSrcXInc + dfXOff + EPS)) / nBlockXSize;\n    const int nBlockY1 = static_cast<int>(std::max(0.0, (0+0.5) * dfSrcYInc + dfYOff + EPS)) / nBlockYSize;\n    const int nBlockX2 = static_cast<int>(std::min(static_cast<double>(nRasterXSize - 1), (nBufXSize-1+0.5) * dfSrcXInc + dfXOff + EPS)) / nBlockXSize;\n    const int nBlockY2 = static_cast<int>(std::min(static_cast<double>(nRasterYSize - 1), (nBufYSize-1+0.5) * dfSrcYInc + dfYOff + EPS)) / nBlockYSize;\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    const int nBlockXCount = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    const int nBlockYCount = DIV_ROUND_UP(nRasterYSize, nBlockYSize);\n    const int nBlockCount = nBlockXCount * nBlockYCount;\n    struct StrileData\n    {\n        vsi_l_offset nOffset;\n        vsi_l_offset nByteCount;\n        bool         bTryMask;\n    };\n    std::map<int, StrileData> oMapStrileToOffsetByteCount;\n\n    // Dedicated method to retrieved the offset and size in an efficient way\n    // when m_bBlockOrderRowMajor and m_bLeaderSizeAsUInt4 conditions are\n    // met.\n    // Except for the last block, we just read the offset from the TIFF offset\n    // array, and retrieve the size in the leader 4 bytes that come before the\n    // payload.\n    auto OptimizedRetrievalOfOffsetSize = [&](int nBlockId,\n                                               vsi_l_offset& nOffset,\n                                               vsi_l_offset& nSize,\n                                               size_t nTotalSize,\n                                               size_t nMaxRawBlockCacheSize)\n    {\n        bool bTryMask = m_poGDS->m_bMaskInterleavedWithImagery;\n        nOffset = TIFFGetStrileOffset(m_poGDS->m_hTIFF, nBlockId);\n        if( nOffset >= 4 )\n        {\n            if( nBlockId == nBlockCount - 1 )\n            {\n                // Special case for the last block. As there is no next block\n                // from which to retrieve an offset, use the good old method\n                // that consists in reading the ByteCount array.\n                if( bTryMask &&\n                    m_poGDS->GetRasterBand(1)->GetMaskBand() &&\n                    m_poGDS->m_poMaskDS )\n                {\n                    auto nMaskOffset = TIFFGetStrileOffset(m_poGDS->m_poMaskDS->m_hTIFF, nBlockId);\n                    if( nMaskOffset )\n                    {\n                        nSize = nMaskOffset + TIFFGetStrileByteCount(m_poGDS->m_poMaskDS->m_hTIFF, nBlockId) - nOffset;\n                    }\n                    else\n                    {\n                        bTryMask = false;\n                    }\n                }\n                if( nSize == 0 )\n                {\n                    nSize = TIFFGetStrileByteCount(m_poGDS->m_hTIFF, nBlockId);\n                }\n                if( nSize && m_poGDS->m_bTrailerRepeatedLast4BytesRepeated )\n                {\n                    nSize += 4;\n                }\n            }\n            else\n            {\n                auto nOffsetNext = TIFFGetStrileOffset(m_poGDS->m_hTIFF, nBlockId + 1);\n                if( nOffsetNext > nOffset )\n                {\n                    nSize = nOffsetNext - nOffset;\n                }\n                else\n                {\n                    // Shouldn't happen for a compliant file\n                    if( nOffsetNext != 0 )\n                    {\n                        CPLDebug(\"GTiff\",\n                                    \"Tile %d is not located after %d\", nBlockId + 1, nBlockId);\n                    }\n                    bTryMask = false;\n                    nSize = TIFFGetStrileByteCount(m_poGDS->m_hTIFF, nBlockId);\n                    if( m_poGDS->m_bTrailerRepeatedLast4BytesRepeated )\n                        nSize += 4;\n                }\n            }\n            if( nSize )\n            {\n                nOffset -= 4;\n                nSize += 4;\n                if( nTotalSize + nSize < nMaxRawBlockCacheSize )\n                {\n                    StrileData data;\n                    data.nOffset = nOffset;\n                    data.nByteCount = nSize;\n                    data.bTryMask = bTryMask;\n                    oMapStrileToOffsetByteCount[nBlockId] = data;\n                }\n            }\n        }\n        else\n        {\n            // Sparse tile\n            StrileData data;\n            data.nOffset = 0;\n            data.nByteCount = 0;\n            data.bTryMask = false;\n            oMapStrileToOffsetByteCount[nBlockId] = data;\n        }\n    };\n\n    // This lambda fills m_poDS->m_oCacheStrileToOffsetByteCount (and\n    // m_poDS->m_poMaskDS->m_oCacheStrileToOffsetByteCount, when there is a mask)\n    // from the temporary oMapStrileToOffsetByteCount.\n    auto FillCacheStrileToOffsetByteCount = [&](\n        const std::vector<vsi_l_offset>& anOffsets,\n        const std::vector<size_t>& anSizes,\n        const std::vector<void*> apData)\n    {\n        CPLAssert( m_poGDS->m_bLeaderSizeAsUInt4 );\n        size_t i = 0;\n        vsi_l_offset nLastOffset = 0;\n        for( const auto& entry: oMapStrileToOffsetByteCount )\n        {\n            const auto nBlockId = entry.first;\n            const auto nOffset = entry.second.nOffset;\n            const auto nSize = entry.second.nByteCount;\n            if( nOffset == 0 )\n            {\n                // Sparse tile\n                m_poGDS->m_oCacheStrileToOffsetByteCount.insert(\n                    nBlockId,\n                    std::pair<vsi_l_offset, vsi_l_offset>(0, 0));\n                continue;\n            }\n\n            if( nOffset < nLastOffset )\n            {\n                // shouldn't happen normally if tiles are sorted\n                i = 0;\n            }\n            nLastOffset = nOffset;\n            while( i < anOffsets.size() && !(\n                    nOffset >= anOffsets[i] &&\n                    nOffset + nSize <= anOffsets[i] + anSizes[i]) )\n            {\n                i++;\n            }\n            CPLAssert( i < anOffsets.size() );\n            CPLAssert( nOffset >= anOffsets[i] );\n            CPLAssert( nOffset + nSize <= anOffsets[i] + anSizes[i] );\n            GUInt32 nSizeFromLeader;\n            memcpy(&nSizeFromLeader,\n                    static_cast<GByte*>(apData[i]) + nOffset - anOffsets[i],\n                    sizeof(nSizeFromLeader));\n            CPL_LSBPTR32(&nSizeFromLeader);\n            bool bOK = true;\n            constexpr int nLeaderSize = 4;\n            const int nTrailerSize =\n                (m_poGDS->m_bTrailerRepeatedLast4BytesRepeated ? 4 : 0);\n            if( nSizeFromLeader > nSize - nLeaderSize - nTrailerSize )\n            {\n                CPLDebug(\"GTiff\",\n                            \"Inconsistent block size from in leader of block %d\", nBlockId);\n                bOK = false;\n            }\n            else if( m_poGDS->m_bTrailerRepeatedLast4BytesRepeated )\n            {\n                // Check trailer consistency\n                const GByte* strileData = static_cast<GByte*>(\n                    apData[i]) + nOffset - anOffsets[i] + nLeaderSize;\n                if( !CheckTrailer(strileData, nSizeFromLeader) )\n                {\n                    CPLDebug(\"GTiff\",\n                            \"Inconsistent trailer of block %d\", nBlockId);\n                    bOK = false;\n                }\n            }\n            if( !bOK )\n            {\n                return false;\n            }\n\n            {\n                const vsi_l_offset nRealOffset = nOffset + nLeaderSize;\n                const vsi_l_offset nRealSize = nSizeFromLeader;\n#ifdef DEBUG_VERBOSE\n                CPLDebug(\"GTiff\", \"Block %d found at offset \"\n                            CPL_FRMT_GUIB \" with size \" CPL_FRMT_GUIB,\n                            nBlockId, nRealOffset, nRealSize);\n#endif\n                m_poGDS->m_oCacheStrileToOffsetByteCount.insert(\n                    nBlockId,\n                    std::pair<vsi_l_offset, vsi_l_offset>(nRealOffset, nRealSize));\n            }\n\n            // Processing of mask\n            if( !(entry.second.bTryMask &&\n                  m_poGDS->m_bMaskInterleavedWithImagery &&\n                  m_poGDS->GetRasterBand(1)->GetMaskBand() &&\n                  m_poGDS->m_poMaskDS ) )\n            {\n                continue;\n            }\n\n            bOK = false;\n            const vsi_l_offset nMaskOffsetWithLeader =\n                nOffset + nLeaderSize + nSizeFromLeader + nTrailerSize;\n            if( nMaskOffsetWithLeader + nLeaderSize <= anOffsets[i] + anSizes[i] )\n            {\n                GUInt32 nMaskSizeFromLeader;\n                memcpy(&nMaskSizeFromLeader,\n                        static_cast<GByte*>(apData[i]) + nMaskOffsetWithLeader - anOffsets[i],\n                        sizeof(nMaskSizeFromLeader));\n                CPL_LSBPTR32(&nMaskSizeFromLeader);\n                if( nMaskOffsetWithLeader + nLeaderSize + nMaskSizeFromLeader + nTrailerSize <= anOffsets[i] + anSizes[i] )\n                {\n                    bOK = true;\n                    if( m_poGDS->m_bTrailerRepeatedLast4BytesRepeated )\n                    {\n                        // Check trailer consistency\n                        const GByte* strileMaskData = static_cast<GByte*>(\n                            apData[i]) + nOffset - anOffsets[i] + nLeaderSize + nSizeFromLeader + nTrailerSize + nLeaderSize;\n                        if( !CheckTrailer(strileMaskData, nMaskSizeFromLeader) )\n                        {\n                            CPLDebug(\"GTiff\",\n                                \"Inconsistent trailer of mask of block %d\", nBlockId);\n                            bOK = false;\n                        }\n                    }\n                }\n                if( bOK )\n                {\n                    const vsi_l_offset nRealOffset = nOffset + nLeaderSize + nSizeFromLeader + nTrailerSize + nLeaderSize;\n                    const vsi_l_offset nRealSize = nMaskSizeFromLeader;\n#ifdef DEBUG_VERBOSE\n                    CPLDebug(\"GTiff\", \"Mask of block %d found at offset \"\n                            CPL_FRMT_GUIB \" with size \" CPL_FRMT_GUIB,\n                            nBlockId, nRealOffset, nRealSize);\n#endif\n\n                    m_poGDS->m_poMaskDS->m_oCacheStrileToOffsetByteCount.insert(\n                        nBlockId,\n                        std::pair<vsi_l_offset, vsi_l_offset>(nRealOffset, nRealSize));\n                }\n            }\n            if( !bOK )\n            {\n                CPLDebug(\"GTiff\",\n                          \"Mask for block %d is not properly interleaved with imagery block\",\n                          nBlockId);\n            }\n        }\n        return true;\n    };\n#endif\n\n    thandle_t th = TIFFClientdata( m_poGDS->m_hTIFF );\n    if( !VSI_TIFFHasCachedRanges(th) )\n    {\n        std::vector< std::pair<vsi_l_offset, size_t> > aOffsetSize;\n        size_t nTotalSize = 0;\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        const unsigned int nMaxRawBlockCacheSize =\n            atoi(CPLGetConfigOption(\"GDAL_MAX_RAW_BLOCK_CACHE_SIZE\",\n                                    \"10485760\"));\n        bool bGoOn = true;\n        for( int iY = nBlockY1; bGoOn && iY <= nBlockY2; iY ++)\n        {\n            for( int iX = nBlockX1; bGoOn && iX <= nBlockX2; iX ++)\n            {\n                GDALRasterBlock* poBlock = TryGetLockedBlockRef(iX, iY);\n                if( poBlock != nullptr )\n                {\n                    poBlock->DropLock();\n                    continue;\n                }\n                int nBlockId = iX + iY * nBlocksPerRow;\n                if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                    nBlockId += (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n                vsi_l_offset nOffset = 0;\n                vsi_l_offset nSize = 0;\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n                if( (m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG || m_poGDS->nBands == 1) &&\n                    !m_poGDS->m_bStreamingIn &&\n                    m_poGDS->m_bBlockOrderRowMajor && m_poGDS->m_bLeaderSizeAsUInt4 )\n                {\n                    OptimizedRetrievalOfOffsetSize(nBlockId, nOffset, nSize, nTotalSize, nMaxRawBlockCacheSize);\n                }\n                else\n#endif\n                {\n                    CPL_IGNORE_RET_VAL(m_poGDS->IsBlockAvailable(nBlockId, &nOffset, &nSize));\n                }\n                if( nSize )\n                {\n                    if( nTotalSize + nSize < nMaxRawBlockCacheSize )\n                    {\n#ifdef DEBUG_VERBOSE\n                        CPLDebug(\"GTiff\",\n                                 \"Precaching for block (%d, %d), \"\n                                 CPL_FRMT_GUIB \"-\" CPL_FRMT_GUIB,\n                                 iX, iY,\n                                 nOffset,\n                                 nOffset + static_cast<size_t>(nSize) - 1);\n#endif\n                        aOffsetSize.push_back(\n                            std::pair<vsi_l_offset, size_t>\n                                (nOffset, static_cast<size_t>(nSize)) );\n                        nTotalSize += static_cast<size_t>(nSize);\n                    }\n                    else\n                    {\n                        bGoOn = false;\n                    }\n                }\n            }\n        }\n\n        std::sort(aOffsetSize.begin(), aOffsetSize.end());\n\n        if( nTotalSize > 0 )\n        {\n            pBufferedData = VSI_MALLOC_VERBOSE(nTotalSize);\n            if( pBufferedData )\n            {\n                std::vector<vsi_l_offset> anOffsets;\n                std::vector<size_t> anSizes;\n                std::vector<void*> apData;\n                anOffsets.push_back(aOffsetSize[0].first);\n                apData.push_back(static_cast<GByte *>(pBufferedData));\n                size_t nChunkSize = aOffsetSize[0].second;\n                size_t nAccOffset = 0;\n                // Try to merge contiguous or slightly overlapping ranges\n                for( size_t i = 0; i < aOffsetSize.size()-1; i++ )\n                {\n                    if ( aOffsetSize[i].first < aOffsetSize[i+1].first &&\n                         aOffsetSize[i].first + aOffsetSize[i].second >= aOffsetSize[i+1].first )\n                    {\n                        const auto overlap = aOffsetSize[i].first + aOffsetSize[i].second - aOffsetSize[i+1].first;\n                        // That should always be the case for well behaved\n                        // TIFF files.\n                        if( aOffsetSize[i+1].second > overlap )\n                        {\n                            nChunkSize += static_cast<size_t>(\n                                aOffsetSize[i+1].second - overlap);\n                        }\n                    }\n                    else \n                    {\n                        //terminate current block\n                        anSizes.push_back(nChunkSize);\n#ifdef DEBUG_VERBOSE\n                        CPLDebug(\"GTiff\", \"Requesting range [\" CPL_FRMT_GUIB \"-\" CPL_FRMT_GUIB \"]\",\n                                 anOffsets.back(), anOffsets.back() + anSizes.back() - 1);\n#endif\n                        nAccOffset += nChunkSize;\n                        //start a new range\n                        anOffsets.push_back(aOffsetSize[i+1].first);\n                        apData.push_back(static_cast<GByte*>(pBufferedData) + nAccOffset);\n                        nChunkSize = aOffsetSize[i+1].second;\n                    }\n                }\n                //terminate last block \n                anSizes.push_back(nChunkSize);\n#ifdef DEBUG_VERBOSE\n                CPLDebug(\"GTiff\", \"Requesting range [\" CPL_FRMT_GUIB \"-\" CPL_FRMT_GUIB \"]\",\n                            anOffsets.back(), anOffsets.back() + anSizes.back() - 1);\n#endif\n\n                VSILFILE* fp = VSI_TIFFGetVSILFile(th);\n\n\n                if( VSIFReadMultiRangeL(\n                                    static_cast<int>(anSizes.size()),\n                                    &apData[0],\n                                    &anOffsets[0],\n                                    &anSizes[0],\n                                    fp ) == 0 )\n                {\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n                    if( !oMapStrileToOffsetByteCount.empty() &&\n                        !FillCacheStrileToOffsetByteCount(\n                                                anOffsets, anSizes, apData) )\n                    {\n                        // Retry without optimization\n                        CPLFree(pBufferedData);\n                        m_poGDS->m_bLeaderSizeAsUInt4 = false;\n                        void* pRet = CacheMultiRange(\n                            nXOff, nYOff, nXSize, nYSize,\n                            nBufXSize, nBufYSize, psExtraArg );\n                        m_poGDS->m_bLeaderSizeAsUInt4 = true;\n                        return pRet;\n                    }\n\n#endif\n                    VSI_TIFFSetCachedRanges( th,\n                                             static_cast<int>(anSizes.size()),\n                                             &apData[0],\n                                             &anOffsets[0],\n                                             &anSizes[0] );\n                }\n            }\n        }\n    }\n    return pBufferedData;\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IRasterIO( GDALRWFlag eRWFlag,\n                                   int nXOff, int nYOff, int nXSize, int nYSize,\n                                   void * pData, int nBufXSize, int nBufYSize,\n                                   GDALDataType eBufType,\n                                   GSpacing nPixelSpace, GSpacing nLineSpace,\n                                   GDALRasterIOExtraArg* psExtraArg )\n{\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"RasterIO(%d, %d, %d, %d, %d, %d)\",\n              nXOff, nYOff, nXSize, nYSize, nBufXSize, nBufYSize );\n#endif\n\n    // Try to pass the request to the most appropriate overview dataset.\n    if( nBufXSize < nXSize && nBufYSize < nYSize )\n    {\n        int bTried = FALSE;\n        ++m_poGDS->m_nJPEGOverviewVisibilityCounter;\n        const CPLErr eErr =\n            TryOverviewRasterIO( eRWFlag,\n                                 nXOff, nYOff, nXSize, nYSize,\n                                 pData, nBufXSize, nBufYSize,\n                                 eBufType,\n                                 nPixelSpace, nLineSpace,\n                                 psExtraArg,\n                                 &bTried );\n        --m_poGDS->m_nJPEGOverviewVisibilityCounter;\n        if( bTried )\n            return eErr;\n    }\n\n    if( m_poGDS->m_eVirtualMemIOUsage != GTiffDataset::VirtualMemIOEnum::NO )\n    {\n        const int nErr = m_poGDS->VirtualMemIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            1, &nBand, nPixelSpace, nLineSpace, 0, psExtraArg);\n        if( nErr >= 0 )\n            return static_cast<CPLErr>(nErr);\n    }\n    if( m_poGDS->m_bDirectIO )\n    {\n        int nErr = DirectIO(eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                            pData, nBufXSize, nBufYSize, eBufType,\n                            nPixelSpace, nLineSpace, psExtraArg);\n        if( nErr >= 0 )\n            return static_cast<CPLErr>(nErr);\n    }\n\n    void* pBufferedData = nullptr;\n    if( m_poGDS->eAccess == GA_ReadOnly &&\n        eRWFlag == GF_Read &&\n        m_poGDS->HasOptimizedReadMultiRange() )\n    {\n        GTiffRasterBand* poBandForCache = this;\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n        if( !m_poGDS->m_bStreamingIn &&\n            m_poGDS->m_bBlockOrderRowMajor &&\n            m_poGDS->m_bLeaderSizeAsUInt4 &&\n            m_poGDS->m_bMaskInterleavedWithImagery &&\n            m_poGDS->m_poImageryDS )\n        {\n            poBandForCache = cpl::down_cast<GTiffRasterBand*>(\n                m_poGDS->m_poImageryDS->GetRasterBand(1));\n        }\n#endif\n        pBufferedData = poBandForCache->CacheMultiRange(\n                                        nXOff, nYOff, nXSize, nYSize,\n                                        nBufXSize, nBufYSize,\n                                        psExtraArg);\n    }\n\n    if( m_poGDS->nBands != 1 &&\n        m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        eRWFlag == GF_Read &&\n        nXSize == nBufXSize && nYSize == nBufYSize )\n    {\n        const int nBlockX1 = nXOff / nBlockXSize;\n        const int nBlockY1 = nYOff / nBlockYSize;\n        const int nBlockX2 = (nXOff + nXSize - 1) / nBlockXSize;\n        const int nBlockY2 = (nYOff + nYSize - 1) / nBlockYSize;\n        const int nXBlocks = nBlockX2 - nBlockX1 + 1;\n        const int nYBlocks = nBlockY2 - nBlockY1 + 1;\n        const GIntBig nRequiredMem =\n            static_cast<GIntBig>(m_poGDS->nBands) * nXBlocks * nYBlocks *\n            nBlockXSize * nBlockYSize *\n            GDALGetDataTypeSizeBytes(eDataType);\n        if( nRequiredMem > GDALGetCacheMax64() )\n        {\n            if( !m_poGDS->m_bHasWarnedDisableAggressiveBandCaching )\n            {\n                CPLDebug( \"GTiff\",\n                          \"Disable aggressive band caching. \"\n                          \"Cache not big enough. \"\n                          \"At least \" CPL_FRMT_GIB \" bytes necessary\",\n                          nRequiredMem );\n                m_poGDS->m_bHasWarnedDisableAggressiveBandCaching = true;\n            }\n            m_poGDS->m_bLoadingOtherBands = true;\n        }\n    }\n\n    ++m_poGDS->m_nJPEGOverviewVisibilityCounter;\n    const CPLErr eErr =\n        GDALPamRasterBand::IRasterIO( eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                                      pData, nBufXSize, nBufYSize, eBufType,\n                                      nPixelSpace, nLineSpace, psExtraArg );\n    --m_poGDS->m_nJPEGOverviewVisibilityCounter;\n\n    m_poGDS->m_bLoadingOtherBands = false;\n\n    if( pBufferedData )\n    {\n        VSIFree( pBufferedData );\n        VSI_TIFFSetCachedRanges( TIFFClientdata( m_poGDS->m_hTIFF ),\n                                 0, nullptr, nullptr, nullptr );\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRasterBand::IGetDataCoverageStatus( int nXOff, int nYOff,\n                                             int nXSize, int nYSize,\n                                             int nMaskFlagStop,\n                                             double* pdfDataPct)\n{\n    if( eAccess == GA_Update )\n        m_poGDS->FlushCache();\n\n    const int iXBlockStart = nXOff / nBlockXSize;\n    const int iXBlockEnd = (nXOff + nXSize - 1) / nBlockXSize;\n    const int iYBlockStart = nYOff / nBlockYSize;\n    const int iYBlockEnd = (nYOff + nYSize - 1) / nBlockYSize;\n    int nStatus = 0;\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_poGDS->m_hTIFF ));\n    GIntBig nPixelsData = 0;\n    // We need to compute this here as it might not have been computed\n    // previously (which sucks...)\n    nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    for( int iY = iYBlockStart; iY <= iYBlockEnd; ++iY )\n    {\n        for( int iX = iXBlockStart; iX <= iXBlockEnd; ++iX )\n        {\n            const int nBlockIdBand0 =\n                iX + iY * nBlocksPerRow;\n            int nBlockId = nBlockIdBand0;\n            if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                nBlockId = nBlockIdBand0 + (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n            vsi_l_offset nOffset = 0;\n            vsi_l_offset nLength = 0;\n            bool bHasData = false;\n            if( !m_poGDS->IsBlockAvailable(nBlockId,&nOffset,&nLength) )\n            {\n                nStatus |= GDAL_DATA_COVERAGE_STATUS_EMPTY;\n            }\n            else\n            {\n                if( m_poGDS->m_nCompression == COMPRESSION_NONE &&\n                    m_poGDS->eAccess == GA_ReadOnly &&\n                    (!m_bNoDataSet || m_dfNoDataValue == 0.0) )\n                {\n                    VSIRangeStatus eStatus =\n                          VSIFGetRangeStatusL( fp, nOffset, nLength );\n                    if( eStatus == VSI_RANGE_STATUS_HOLE )\n                    {\n                        nStatus |= GDAL_DATA_COVERAGE_STATUS_EMPTY;\n                    }\n                    else\n                    {\n                        bHasData = true;\n                    }\n                }\n                else\n                {\n                    bHasData = true;\n                }\n            }\n            if( bHasData )\n            {\n                const int nXBlockRight =\n                    ( iX * nBlockXSize > INT_MAX - nBlockXSize ) ? INT_MAX :\n                    (iX + 1) * nBlockXSize;\n                const int nYBlockBottom =\n                    ( iY * nBlockYSize > INT_MAX - nBlockYSize ) ? INT_MAX :\n                    (iY + 1) * nBlockYSize;\n\n                nPixelsData +=\n                    (std::min( nXBlockRight, nXOff + nXSize ) -\n                     std::max( iX * nBlockXSize, nXOff )) *\n                    (std::min( nYBlockBottom, nYOff + nYSize ) -\n                     std::max( iY * nBlockYSize, nYOff ));\n                nStatus |= GDAL_DATA_COVERAGE_STATUS_DATA;\n            }\n            if( nMaskFlagStop != 0 && (nMaskFlagStop & nStatus) != 0 )\n            {\n                if( pdfDataPct )\n                    *pdfDataPct = -1.0;\n                return nStatus;\n            }\n        }\n    }\n    if( pdfDataPct )\n        *pdfDataPct =\n          100.0 * nPixelsData /\n          (static_cast<GIntBig>(nXSize) * nYSize);\n    return nStatus;\n}\n\n/************************************************************************/\n/*                             ReadStrile()                             */\n/************************************************************************/\n\nbool GTiffDataset::ReadStrile(int nBlockId,\n                              void* pOutputBuffer,\n                              GPtrDiff_t nBlockReqSize)\n{\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    std::pair<vsi_l_offset, vsi_l_offset> oPair;\n    if( m_oCacheStrileToOffsetByteCount.tryGet(nBlockId, oPair) )\n    {\n        // For the mask, use the parent TIFF handle to get cached ranges\n        auto th = TIFFClientdata(\n            m_poImageryDS && m_bMaskInterleavedWithImagery ?\n                m_poImageryDS->m_hTIFF : m_hTIFF);\n        void* pInputBuffer = VSI_TIFFGetCachedRange( th, oPair.first,\n                                                static_cast<size_t>(oPair.second) );\n        if( pInputBuffer &&\n            TIFFReadFromUserBuffer( m_hTIFF, nBlockId,\n                                    pInputBuffer, static_cast<size_t>(oPair.second),\n                                    pOutputBuffer, nBlockReqSize ) )\n        {\n            return true;\n        }\n    }\n#endif\n\n    // For debugging\n    if( m_poBaseDS )\n        m_poBaseDS->m_bHasUsedReadEncodedAPI = true;\n    else\n        m_bHasUsedReadEncodedAPI = true;\n\n    if( TIFFIsTiled( m_hTIFF ) )\n    {\n        if( TIFFReadEncodedTile( m_hTIFF, nBlockId, pOutputBuffer,\n                                    nBlockReqSize ) == -1\n            && !m_bIgnoreReadErrors )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                        \"TIFFReadEncodedTile() failed.\" );\n\n            return false;\n        }\n    }\n    else\n    {\n        if( TIFFReadEncodedStrip( m_hTIFF, nBlockId, pOutputBuffer,\n                                    nBlockReqSize ) == -1\n            && !m_bIgnoreReadErrors )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                    \"TIFFReadEncodedStrip() failed.\" );\n\n            return false;\n        }\n    }\n    return true;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                    void * pImage )\n\n{\n    m_poGDS->Crystalize();\n\n    GPtrDiff_t nBlockBufSize = 0;\n    if( TIFFIsTiled(m_poGDS->m_hTIFF) )\n    {\n        nBlockBufSize = static_cast<GPtrDiff_t>(TIFFTileSize( m_poGDS->m_hTIFF ));\n    }\n    else\n    {\n        CPLAssert( nBlockXOff == 0 );\n        nBlockBufSize = static_cast<GPtrDiff_t>(TIFFStripSize( m_poGDS->m_hTIFF ));\n    }\n\n    CPLAssert(nBlocksPerRow != 0);\n    const int nBlockIdBand0 =\n        nBlockXOff + nBlockYOff * nBlocksPerRow;\n    int nBlockId = nBlockIdBand0;\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId = nBlockIdBand0 + (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      The bottom most partial tiles and strips are sometimes only     */\n/*      partially encoded.  This code reduces the requested data so     */\n/*      an error won't be reported in this case. (#1179)                */\n/* -------------------------------------------------------------------- */\n    auto nBlockReqSize = nBlockBufSize;\n\n    if( nBlockYOff * nBlockYSize > nRasterYSize - nBlockYSize )\n    {\n        nBlockReqSize = (nBlockBufSize / nBlockYSize)\n            * (nBlockYSize - static_cast<int>(\n                (static_cast<GIntBig>(nBlockYOff + 1) * nBlockYSize)\n                    % nRasterYSize));\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle the case of a strip or tile that doesn't exist yet.      */\n/*      Just set to zeros and return.                                   */\n/* -------------------------------------------------------------------- */\n    vsi_l_offset nOffset = 0;\n    bool bErrOccurred = false;\n    if( nBlockId != m_poGDS->m_nLoadedBlock &&\n        !m_poGDS->IsBlockAvailable(nBlockId, &nOffset, nullptr, &bErrOccurred) )\n    {\n        NullBlock( pImage );\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n    if( m_poGDS->m_bStreamingIn &&\n        !(m_poGDS->nBands > 1 &&\n          m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n          nBlockId == m_poGDS->m_nLoadedBlock) )\n    {\n        if( nOffset < VSIFTellL(m_poGDS->m_fpL) )\n        {\n            ReportError( CE_Failure, CPLE_NotSupported,\n                      \"Trying to load block %d at offset \" CPL_FRMT_GUIB\n                      \" whereas current pos is \" CPL_FRMT_GUIB\n                      \" (backward read not supported)\",\n                      nBlockId, static_cast<GUIntBig>(nOffset),\n                      static_cast<GUIntBig>(VSIFTellL(m_poGDS->m_fpL)) );\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case (separate, onesampleperpixel)                */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n    if( m_poGDS->nBands == 1\n        || m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        if( nBlockReqSize < nBlockBufSize )\n            memset( pImage, 0, nBlockBufSize );\n\n        if( !m_poGDS->ReadStrile(nBlockId, pImage, nBlockReqSize) )\n        {\n            memset( pImage, 0, nBlockBufSize );\n            return CE_Failure;\n        }\n    }\n    else\n    {\n/* -------------------------------------------------------------------- */\n/*      Load desired block                                              */\n/* -------------------------------------------------------------------- */\n        eErr = m_poGDS->LoadBlockBuf( nBlockId );\n        if( eErr != CE_None )\n        {\n            memset( pImage, 0,\n                    static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize\n                    * GDALGetDataTypeSizeBytes(eDataType) );\n            return eErr;\n        }\n\n        const int nWordBytes = m_poGDS->m_nBitsPerSample / 8;\n        GByte* pabyImage = m_poGDS->m_pabyBlockBuf + (nBand - 1) * nWordBytes;\n\n        GDALCopyWords64(pabyImage, eDataType, m_poGDS->nBands * nWordBytes,\n                    pImage, eDataType, nWordBytes,\n                    static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize);\n\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n    }\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    CacheMaskForBlock(nBlockXOff,nBlockYOff);\n#endif\n    return eErr;\n}\n\n/************************************************************************/\n/*                           CacheMaskForBlock()                       */\n/************************************************************************/\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\nvoid GTiffRasterBand::CacheMaskForBlock( int nBlockXOff, int nBlockYOff )\n\n{\n    // Preload mask data if layout compatible and we have cached ranges\n    if( m_poGDS->m_bMaskInterleavedWithImagery &&\n        m_poGDS->GetRasterBand(1)->GetMaskBand() &&\n        m_poGDS->m_poMaskDS &&\n        VSI_TIFFHasCachedRanges( TIFFClientdata(m_poGDS->m_hTIFF) ) &&\n        m_poGDS->m_poMaskDS->m_oCacheStrileToOffsetByteCount.contains(\n            nBlockXOff + nBlockYOff * nBlocksPerRow) )\n    {\n        GDALRasterBlock *poBlock = m_poGDS->m_poMaskDS->GetRasterBand(1)->\n            GetLockedBlockRef(nBlockXOff,nBlockYOff);\n        if( poBlock )\n            poBlock->DropLock();\n    }\n}\n#endif\n\n/************************************************************************/\n/*                       FillCacheForOtherBands()                       */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::FillCacheForOtherBands( int nBlockXOff, int nBlockYOff )\n\n{\n/* -------------------------------------------------------------------- */\n/*      In the fairly common case of pixel interleaved 8bit data        */\n/*      that is multi-band, lets push the rest of the data into the     */\n/*      block cache too, to avoid (hopefully) having to redecode it.    */\n/*                                                                      */\n/*      Our following logic actually depends on the fact that the       */\n/*      this block is already loaded, so subsequent calls will end      */\n/*      up back in this method and pull from the loaded block.          */\n/*                                                                      */\n/*      Be careful not entering this portion of code from               */\n/*      the other bands, otherwise we'll get very deep nested calls     */\n/*      and O(nBands^2) performance !                                   */\n/*                                                                      */\n/*      If there are many bands and the block cache size is not big     */\n/*      enough to accommodate the size of all the blocks, don't enter   */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n    if( m_poGDS->nBands != 1 &&\n        m_poGDS->nBands < 128 && // avoid caching for datasets with too many bands\n        !m_poGDS->m_bLoadingOtherBands &&\n        static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize * GDALGetDataTypeSizeBytes(eDataType) <\n        GDALGetCacheMax64() / m_poGDS->nBands )\n    {\n        m_poGDS->m_bLoadingOtherBands = true;\n\n        for( int iOtherBand = 1; iOtherBand <= m_poGDS->nBands; ++iOtherBand )\n        {\n            if( iOtherBand == nBand )\n                continue;\n\n            GDALRasterBlock *poBlock = m_poGDS->GetRasterBand(iOtherBand)->\n                GetLockedBlockRef(nBlockXOff,nBlockYOff);\n            if( poBlock == nullptr )\n            {\n                eErr = CE_Failure;\n                break;\n            }\n            poBlock->DropLock();\n        }\n\n        m_poGDS->m_bLoadingOtherBands = false;\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                     void * pImage )\n\n{\n    m_poGDS->Crystalize();\n\n    if( m_poGDS->m_bDebugDontWriteBlocks )\n        return CE_None;\n\n    if( m_poGDS->m_bWriteError )\n    {\n        // Report as an error if a previously loaded block couldn't be written\n        // correctly.\n        return CE_Failure;\n    }\n\n    CPLAssert(nBlocksPerRow != 0);\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of \"separate\" images                                */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE\n        || m_poGDS->nBands == 1 )\n    {\n        const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow\n            + (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n\n        const CPLErr eErr =\n            m_poGDS->WriteEncodedTileOrStrip(nBlockId, pImage, true);\n\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of pixel interleaved (PLANARCONFIG_CONTIG) images.  */\n/* -------------------------------------------------------------------- */\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n     // Why 10 ? Somewhat arbitrary\n    constexpr int MAX_BANDS_FOR_DIRTY_CHECK = 10;\n    GDALRasterBlock* apoBlocks[MAX_BANDS_FOR_DIRTY_CHECK] = {};\n    const int nBands = m_poGDS->nBands;\n    bool bAllBlocksDirty = false;\n\n/* -------------------------------------------------------------------- */\n/*     If all blocks are cached and dirty then we do not need to reload */\n/*     the tile/strip from disk                                         */\n/* -------------------------------------------------------------------- */\n    if( nBands <= MAX_BANDS_FOR_DIRTY_CHECK )\n    {\n        bAllBlocksDirty = true;\n        for( int iBand = 0; iBand < nBands; ++iBand )\n        {\n            if( iBand + 1 != nBand )\n            {\n                apoBlocks[iBand] =\n                    cpl::down_cast<GTiffRasterBand *>(\n                        m_poGDS->GetRasterBand( iBand + 1 ))\n                            ->TryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n                if( apoBlocks[iBand] == nullptr )\n                {\n                    bAllBlocksDirty = false;\n                }\n                else if( !apoBlocks[iBand]->GetDirty() )\n                {\n                    apoBlocks[iBand]->DropLock();\n                    apoBlocks[iBand] = nullptr;\n                    bAllBlocksDirty = false;\n                }\n            }\n            else\n                apoBlocks[iBand] = nullptr;\n        }\n#if DEBUG_VERBOSE\n        if( bAllBlocksDirty )\n            CPLDebug(\"GTIFF\", \"Saved reloading block %d\", nBlockId);\n        else\n            CPLDebug(\"GTIFF\", \"Must reload block %d\", nBlockId);\n#endif\n    }\n\n    {\n        const CPLErr eErr = m_poGDS->LoadBlockBuf( nBlockId, !bAllBlocksDirty );\n        if( eErr != CE_None )\n        {\n            if( nBands <= MAX_BANDS_FOR_DIRTY_CHECK )\n            {\n                for( int iBand = 0; iBand < nBands; ++iBand )\n                {\n                    if( apoBlocks[iBand] != nullptr )\n                        apoBlocks[iBand]->DropLock();\n                }\n            }\n            return eErr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      On write of pixel interleaved data, we might as well flush      */\n/*      out any other bands that are dirty in our cache.  This is       */\n/*      especially helpful when writing compressed blocks.              */\n/* -------------------------------------------------------------------- */\n    const int nWordBytes = m_poGDS->m_nBitsPerSample / 8;\n\n    for( int iBand = 0; iBand < nBands; ++iBand )\n    {\n        const GByte *pabyThisImage = nullptr;\n        GDALRasterBlock *poBlock = nullptr;\n\n        if( iBand + 1 == nBand )\n        {\n            pabyThisImage = static_cast<GByte *>( pImage );\n        }\n        else\n        {\n            if( nBands <= MAX_BANDS_FOR_DIRTY_CHECK )\n                poBlock = apoBlocks[iBand];\n            else\n                poBlock = cpl::down_cast<GTiffRasterBand *>(\n                    m_poGDS->GetRasterBand( iBand + 1 ))\n                        ->TryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n            if( poBlock == nullptr )\n                continue;\n\n            if( !poBlock->GetDirty() )\n            {\n                poBlock->DropLock();\n                continue;\n            }\n\n            pabyThisImage = static_cast<GByte *>( poBlock->GetDataRef() );\n        }\n\n        GByte *pabyOut = m_poGDS->m_pabyBlockBuf + iBand*nWordBytes;\n\n        GDALCopyWords64(pabyThisImage, eDataType, nWordBytes,\n                      pabyOut, eDataType, nWordBytes * nBands,\n                      static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize);\n\n        if( poBlock != nullptr )\n        {\n            poBlock->MarkClean();\n            poBlock->DropLock();\n        }\n    }\n\n    if( bAllBlocksDirty )\n    {\n        // We can synchronously write the block now.\n        const CPLErr eErr =\n            m_poGDS->WriteEncodedTileOrStrip(nBlockId, m_poGDS->m_pabyBlockBuf, true);\n        m_poGDS->m_bLoadedBlockDirty = false;\n        return eErr;\n    }\n\n    m_poGDS->m_bLoadedBlockDirty = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           SetDescription()                           */\n/************************************************************************/\n\nvoid GTiffRasterBand::SetDescription( const char *pszDescription )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( pszDescription == nullptr )\n        pszDescription = \"\";\n\n    if( m_osDescription != pszDescription )\n        m_poGDS->m_bMetadataChanged = true;\n\n    m_osDescription = pszDescription;\n}\n\n/************************************************************************/\n/*                           GetDescription()                           */\n/************************************************************************/\n\nconst char *GTiffRasterBand::GetDescription() const\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    return m_osDescription;\n}\n\n/************************************************************************/\n/*                             GetOffset()                              */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetOffset( int *pbSuccess )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( pbSuccess )\n        *pbSuccess = m_bHaveOffsetScale;\n    return m_dfOffset;\n}\n\n/************************************************************************/\n/*                             SetOffset()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetOffset( double dfNewValue )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( !m_bHaveOffsetScale || dfNewValue != m_dfOffset )\n        m_poGDS->m_bMetadataChanged = true;\n\n    m_bHaveOffsetScale = true;\n    m_dfOffset = dfNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                              GetScale()                              */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetScale( int *pbSuccess )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( pbSuccess )\n        *pbSuccess = m_bHaveOffsetScale;\n    return m_dfScale;\n}\n\n/************************************************************************/\n/*                              SetScale()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetScale( double dfNewValue )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( !m_bHaveOffsetScale || dfNewValue != m_dfScale )\n        m_poGDS->m_bMetadataChanged = true;\n\n    m_bHaveOffsetScale = true;\n    m_dfScale = dfNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            GetUnitType()                             */\n/************************************************************************/\n\nconst char* GTiffRasterBand::GetUnitType()\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n    if( m_osUnitType.empty() )\n    {\n        m_poGDS->LookForProjection();\n        if( m_poGDS->m_pszVertUnit )\n            return m_poGDS->m_pszVertUnit;\n    }\n\n    return m_osUnitType.c_str();\n}\n\n/************************************************************************/\n/*                           SetUnitType()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetUnitType( const char* pszNewValue )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    CPLString osNewValue(pszNewValue ? pszNewValue : \"\");\n    if( osNewValue.compare(m_osUnitType) != 0 )\n        m_poGDS->m_bMetadataChanged = true;\n\n    m_osUnitType = osNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                      GetMetadataDomainList()                         */\n/************************************************************************/\n\nchar **GTiffRasterBand::GetMetadataDomainList()\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    return CSLDuplicate(m_oGTiffMDMD.GetDomainList());\n}\n\n/************************************************************************/\n/*                            GetMetadata()                             */\n/************************************************************************/\n\nchar **GTiffRasterBand::GetMetadata( const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    return m_oGTiffMDMD.GetMetadata( pszDomain );\n}\n\n/************************************************************************/\n/*                            SetMetadata()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetMetadata( char ** papszMD, const char *pszDomain )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( m_poGDS->m_bStreamingOut && m_poGDS->m_bCrystalized )\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"Cannot modify metadata at that point in a streamed \"\n                  \"output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        if( papszMD != nullptr || GetMetadata(pszDomain) != nullptr )\n        {\n            m_poGDS->m_bMetadataChanged = true;\n            // Cancel any existing metadata from PAM file.\n            if( eAccess == GA_Update &&\n                GDALPamRasterBand::GetMetadata(pszDomain) != nullptr )\n                GDALPamRasterBand::SetMetadata(nullptr, pszDomain);\n        }\n    }\n\n    return m_oGTiffMDMD.SetMetadata( papszMD, pszDomain );\n}\n\n/************************************************************************/\n/*                          GetMetadataItem()                           */\n/************************************************************************/\n\nconst char *GTiffRasterBand::GetMetadataItem( const char * pszName,\n                                              const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszName != nullptr && pszDomain != nullptr && EQUAL(pszDomain, \"TIFF\") )\n    {\n        int nBlockXOff = 0;\n        int nBlockYOff = 0;\n\n        if( EQUAL(pszName, \"JPEGTABLES\") )\n        {\n            uint32 nJPEGTableSize = 0;\n            void* pJPEGTable = nullptr;\n            if( TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_JPEGTABLES,\n                              &nJPEGTableSize, &pJPEGTable ) != 1 ||\n                pJPEGTable == nullptr || nJPEGTableSize > INT_MAX )\n            {\n                return nullptr;\n            }\n            char* const pszHex =\n                CPLBinaryToHex( nJPEGTableSize, static_cast<const GByte*>(pJPEGTable) );\n            const char* pszReturn = CPLSPrintf(\"%s\", pszHex);\n            CPLFree(pszHex);\n\n            return pszReturn;\n        }\n\n        if( EQUAL(pszName, \"IFD_OFFSET\") )\n        {\n            return CPLSPrintf( CPL_FRMT_GUIB,\n                               static_cast<GUIntBig>(m_poGDS->m_nDirOffset) );\n        }\n\n        if( sscanf( pszName, \"BLOCK_OFFSET_%d_%d\",\n                         &nBlockXOff, &nBlockYOff ) == 2 )\n        {\n            nBlocksPerRow =\n                DIV_ROUND_UP(m_poGDS->nRasterXSize, m_poGDS->m_nBlockXSize);\n            nBlocksPerColumn =\n                DIV_ROUND_UP(m_poGDS->nRasterYSize, m_poGDS->m_nBlockYSize);\n            if( nBlockXOff < 0 || nBlockXOff >= nBlocksPerRow ||\n                nBlockYOff < 0 || nBlockYOff >= nBlocksPerColumn )\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n            {\n                nBlockId += (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n            }\n\n            vsi_l_offset nOffset = 0;\n            if( !m_poGDS->IsBlockAvailable(nBlockId, &nOffset) )\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf( CPL_FRMT_GUIB, static_cast<GUIntBig>(nOffset) );\n        }\n\n        if( sscanf( pszName, \"BLOCK_SIZE_%d_%d\",\n                    &nBlockXOff, &nBlockYOff ) == 2 )\n        {\n            nBlocksPerRow =\n                DIV_ROUND_UP(m_poGDS->nRasterXSize, m_poGDS->m_nBlockXSize);\n            nBlocksPerColumn =\n                DIV_ROUND_UP(m_poGDS->nRasterYSize, m_poGDS->m_nBlockYSize);\n            if( nBlockXOff < 0 || nBlockXOff >= nBlocksPerRow ||\n                nBlockYOff < 0 || nBlockYOff >= nBlocksPerColumn )\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n            {\n                nBlockId += (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n            }\n\n            vsi_l_offset nByteCount = 0;\n            if( !m_poGDS->IsBlockAvailable(nBlockId, nullptr, &nByteCount) )\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf(CPL_FRMT_GUIB, static_cast<GUIntBig>(nByteCount));\n        }\n    }\n    return m_oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}\n\n/************************************************************************/\n/*                          SetMetadataItem()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetMetadataItem( const char *pszName,\n                                         const char *pszValue,\n                                         const char *pszDomain )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( m_poGDS->m_bStreamingOut && m_poGDS->m_bCrystalized )\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"Cannot modify metadata at that point in a streamed \"\n                  \"output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        m_poGDS->m_bMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update &&\n            GDALPamRasterBand::GetMetadataItem(pszName, pszDomain) != nullptr )\n            GDALPamRasterBand::SetMetadataItem(pszName, nullptr, pszDomain);\n    }\n\n    return m_oGTiffMDMD.SetMetadataItem( pszName, pszValue, pszDomain );\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRasterBand::GetColorInterpretation()\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    return m_eBandInterp;\n}\n\n/************************************************************************/\n/*                         GTiffGetAlphaValue()                         */\n/************************************************************************/\n\nuint16 GTiffGetAlphaValue(const char* pszValue, uint16 nDefault)\n{\n    if( pszValue == nullptr )\n        return nDefault;\n    if( EQUAL(pszValue, \"YES\") )\n        return DEFAULT_ALPHA_TYPE;\n    if( EQUAL(pszValue, \"PREMULTIPLIED\") )\n        return EXTRASAMPLE_ASSOCALPHA;\n    if( EQUAL(pszValue, \"NON-PREMULTIPLIED\") )\n        return EXTRASAMPLE_UNASSALPHA;\n    if( EQUAL(pszValue, \"NO\") ||\n        EQUAL(pszValue, \"UNSPECIFIED\") )\n        return EXTRASAMPLE_UNSPECIFIED;\n\n    return nDefault;\n}\n\n/************************************************************************/\n/*                       SetColorInterpretation()                       */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetColorInterpretation( GDALColorInterp eInterp )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( eInterp == m_eBandInterp )\n        return CE_None;\n\n    m_eBandInterp = eInterp;\n\n    if( eAccess != GA_Update )\n    {\n        CPLDebug( \"GTIFF\", \"ColorInterpretation %s for band %d goes to PAM \"\n                  \"instead of TIFF tag\",\n                  GDALGetColorInterpretationName(eInterp), nBand );\n        return GDALPamRasterBand::SetColorInterpretation( eInterp );\n    }\n\n    m_poGDS->m_bNeedsRewrite = true;\n    m_poGDS->m_bMetadataChanged = true;\n\n    // Try to autoset TIFFTAG_PHOTOMETRIC = PHOTOMETRIC_RGB if possible.\n    if( m_poGDS->nBands >= 3 &&\n        m_poGDS->m_nCompression != COMPRESSION_JPEG &&\n        m_poGDS->m_nPhotometric != PHOTOMETRIC_RGB &&\n        CSLFetchNameValue( m_poGDS->m_papszCreationOptions,\n                           \"PHOTOMETRIC\" ) == nullptr &&\n        ((nBand == 1 && eInterp == GCI_RedBand) ||\n         (nBand == 2 && eInterp == GCI_GreenBand) ||\n         (nBand == 3 && eInterp == GCI_BlueBand)) )\n    {\n        if( m_poGDS->GetRasterBand(1)->GetColorInterpretation() == GCI_RedBand &&\n            m_poGDS->GetRasterBand(2)->GetColorInterpretation() == GCI_GreenBand &&\n            m_poGDS->GetRasterBand(3)->GetColorInterpretation() == GCI_BlueBand )\n        {\n            m_poGDS->m_nPhotometric = PHOTOMETRIC_RGB;\n            TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_PHOTOMETRIC,\n                          m_poGDS->m_nPhotometric );\n\n            // We need to update the number of extra samples.\n            uint16 *v = nullptr;\n            uint16 count = 0;\n            const uint16 nNewExtraSamplesCount =\n                static_cast<uint16>(m_poGDS->nBands - 3);\n            if( m_poGDS->nBands >= 4 &&\n                TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES,\n                              &count, &v ) &&\n                count > nNewExtraSamplesCount )\n            {\n                uint16 * const pasNewExtraSamples =\n                    static_cast<uint16 *>( CPLMalloc(\n                        nNewExtraSamplesCount * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v + count - nNewExtraSamplesCount,\n                        nNewExtraSamplesCount * sizeof(uint16) );\n\n                TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES,\n                              nNewExtraSamplesCount, pasNewExtraSamples );\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n        return CE_None;\n    }\n\n    // On the contrary, cancel the above if needed\n    if( m_poGDS->m_nCompression != COMPRESSION_JPEG &&\n        m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB &&\n        CSLFetchNameValue( m_poGDS->m_papszCreationOptions,\n                           \"PHOTOMETRIC\") == nullptr &&\n        ((nBand == 1 && eInterp != GCI_RedBand) ||\n         (nBand == 2 && eInterp != GCI_GreenBand) ||\n         (nBand == 3 && eInterp != GCI_BlueBand)) )\n    {\n        m_poGDS->m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(m_poGDS->m_hTIFF, TIFFTAG_PHOTOMETRIC, m_poGDS->m_nPhotometric);\n\n        // We need to update the number of extra samples.\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        const uint16 nNewExtraSamplesCount =\n            static_cast<uint16>(m_poGDS->nBands - 1);\n        if( m_poGDS->nBands >= 2 )\n        {\n            TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v );\n            if( nNewExtraSamplesCount > count )\n            {\n                uint16 * const pasNewExtraSamples =\n                    static_cast<uint16 *>( CPLMalloc(\n                        nNewExtraSamplesCount * sizeof(uint16) ) );\n                for( int i = 0;\n                     i < static_cast<int>(nNewExtraSamplesCount - count);\n                     ++i )\n                    pasNewExtraSamples[i] = EXTRASAMPLE_UNSPECIFIED;\n                if( count > 0 )\n                {\n                    memcpy( pasNewExtraSamples + nNewExtraSamplesCount - count,\n                            v,\n                            count * sizeof(uint16) );\n                }\n\n                TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES,\n                              nNewExtraSamplesCount, pasNewExtraSamples );\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n    }\n\n    // Mark alpha band / undefined in extrasamples.\n    if( eInterp == GCI_AlphaBand || eInterp == GCI_Undefined )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        if( TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            const int nBaseSamples = m_poGDS->m_nSamplesPerPixel - count;\n\n            if( eInterp == GCI_AlphaBand )\n            {\n                for( int i = 1; i <= m_poGDS->nBands; ++i )\n                {\n                    if( i != nBand &&\n                        m_poGDS->GetRasterBand(i)->GetColorInterpretation() ==\n                        GCI_AlphaBand )\n                    {\n                        if( i == nBaseSamples + 1 &&\n                            CSLFetchNameValue( m_poGDS->m_papszCreationOptions,\n                                            \"ALPHA\" ) != nullptr )\n                        {\n                            ReportError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too. \"\n                                \"Presumably ALPHA creation option is not needed\",\n                                i, nBand );\n                        }\n                        else\n                        {\n                            ReportError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too\",\n                                i, nBand );\n                        }\n                    }\n                }\n            }\n\n            if( nBand > nBaseSamples && nBand - nBaseSamples - 1 < count )\n            {\n                // We need to allocate a new array as (current) libtiff\n                // versions will not like that we reuse the array we got from\n                // TIFFGetField().\n\n                uint16* pasNewExtraSamples =\n                    static_cast<uint16 *>(\n                        CPLMalloc( count * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v, count * sizeof(uint16) );\n                if( eInterp == GCI_AlphaBand )\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        GTiffGetAlphaValue(CPLGetConfigOption(\"GTIFF_ALPHA\", nullptr),\n                                            DEFAULT_ALPHA_TYPE);\n                }\n                else\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        EXTRASAMPLE_UNSPECIFIED;\n                }\n\n                TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES,\n                              count, pasNewExtraSamples);\n\n                CPLFree(pasNewExtraSamples);\n\n                return CE_None;\n            }\n        }\n    }\n\n    if( m_poGDS->m_nPhotometric != PHOTOMETRIC_MINISBLACK &&\n        CSLFetchNameValue( m_poGDS->m_papszCreationOptions, \"PHOTOMETRIC\") == nullptr )\n    {\n        m_poGDS->m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(m_poGDS->m_hTIFF, TIFFTAG_PHOTOMETRIC, m_poGDS->m_nPhotometric);\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           GetColorTable()                            */\n/************************************************************************/\n\nGDALColorTable *GTiffRasterBand::GetColorTable()\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( nBand == 1 )\n        return m_poGDS->m_poColorTable;\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                           SetColorTable()                            */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetColorTable( GDALColorTable * poCT )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n/* -------------------------------------------------------------------- */\n/*      Check if this is even a candidate for applying a PCT.           */\n/* -------------------------------------------------------------------- */\n    if( nBand != 1)\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() can only be called on band 1.\" );\n        return CE_Failure;\n    }\n\n    if( m_poGDS->m_nSamplesPerPixel != 1 && m_poGDS->m_nSamplesPerPixel != 2)\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() not supported for multi-sample TIFF \"\n                  \"files.\" );\n        return CE_Failure;\n    }\n\n    if( eDataType != GDT_Byte && eDataType != GDT_UInt16 )\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() only supported for Byte or UInt16 bands \"\n                  \"in TIFF format.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Is this really a request to clear the color table?              */\n/* -------------------------------------------------------------------- */\n    if( poCT == nullptr || poCT->GetColorEntryCount() == 0 )\n    {\n        TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_PHOTOMETRIC,\n                      PHOTOMETRIC_MINISBLACK );\n\n        TIFFUnsetField( m_poGDS->m_hTIFF, TIFFTAG_COLORMAP );\n\n        if( m_poGDS->m_poColorTable )\n        {\n            delete m_poGDS->m_poColorTable;\n            m_poGDS->m_poColorTable = nullptr;\n        }\n\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the colortable, and update the configuration.         */\n/* -------------------------------------------------------------------- */\n    int nColors = 65536;\n\n    if( eDataType == GDT_Byte )\n        nColors = 256;\n\n    unsigned short *panTRed = static_cast<unsigned short *>(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n    unsigned short *panTGreen = static_cast<unsigned short *>(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n    unsigned short *panTBlue = static_cast<unsigned short *>(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n\n    for( int iColor = 0; iColor < nColors; ++iColor )\n    {\n        if( iColor < poCT->GetColorEntryCount() )\n        {\n            GDALColorEntry sRGB;\n            poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n            panTRed[iColor] = static_cast<unsigned short>(257 * sRGB.c1);\n            panTGreen[iColor] = static_cast<unsigned short>(257 * sRGB.c2);\n            panTBlue[iColor] = static_cast<unsigned short>(257 * sRGB.c3);\n        }\n        else\n        {\n            panTRed[iColor] = 0;\n            panTGreen[iColor] = 0;\n            panTBlue[iColor] = 0;\n        }\n    }\n\n    TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n    TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_COLORMAP,\n                  panTRed, panTGreen, panTBlue );\n\n    CPLFree( panTRed );\n    CPLFree( panTGreen );\n    CPLFree( panTBlue );\n\n    if( m_poGDS->m_poColorTable )\n        delete m_poGDS->m_poColorTable;\n\n    // libtiff 3.X needs setting this in all cases (creation or update)\n    // whereas libtiff 4.X would just need it if there\n    // was no color table before.\n    m_poGDS->m_bNeedsRewrite = true;\n\n    m_poGDS->m_poColorTable = poCT->Clone();\n    m_eBandInterp = GCI_PaletteIndex;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           GetNoDataValue()                           */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetNoDataValue( int * pbSuccess )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( m_bNoDataSet )\n    {\n        if( pbSuccess )\n            *pbSuccess = TRUE;\n\n        return m_dfNoDataValue;\n    }\n\n    if( m_poGDS->m_bNoDataSet )\n    {\n        if( pbSuccess )\n            *pbSuccess = TRUE;\n\n        return m_poGDS->m_dfNoDataValue;\n    }\n\n    return GDALPamRasterBand::GetNoDataValue( pbSuccess );\n}\n\n/************************************************************************/\n/*                           SetNoDataValue()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetNoDataValue( double dfNoData )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( m_poGDS->m_bNoDataSet && m_poGDS->m_dfNoDataValue == dfNoData )\n    {\n        m_bNoDataSet = true;\n        m_dfNoDataValue = dfNoData;\n        return CE_None;\n    }\n\n    if( m_poGDS->nBands > 1 && m_poGDS->m_eProfile == GTiffProfile::GDALGEOTIFF )\n    {\n        int bOtherBandHasNoData = FALSE;\n        const int nOtherBand = nBand > 1 ? 1 : 2;\n        double dfOtherNoData = m_poGDS->GetRasterBand(nOtherBand)->\n                                    GetNoDataValue(&bOtherBandHasNoData);\n        if( bOtherBandHasNoData && dfOtherNoData != dfNoData )\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                 \"Setting nodata to %.18g on band %d, but band %d has nodata \"\n                 \"at %.18g. The TIFFTAG_GDAL_NODATA only support one value \"\n                 \"per dataset. This value of %.18g will be used for all bands \"\n                 \"on re-opening\",\n                 dfNoData, nBand, nOtherBand, dfOtherNoData, dfNoData);\n        }\n    }\n\n    if( m_poGDS->m_bStreamingOut && m_poGDS->m_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify nodata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    m_poGDS->m_bNoDataSet = true;\n    m_poGDS->m_dfNoDataValue = dfNoData;\n\n    m_poGDS->m_bNoDataChanged = true;\n\n    m_bNoDataSet = true;\n    m_dfNoDataValue = dfNoData;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                        DeleteNoDataValue()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::DeleteNoDataValue()\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( !m_poGDS->m_bNoDataSet )\n        return CE_None;\n\n    if( m_poGDS->m_bStreamingOut && m_poGDS->m_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify nodata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    m_poGDS->m_bNoDataSet = false;\n    m_poGDS->m_dfNoDataValue = -9999.0;\n\n    m_poGDS->m_bNoDataChanged = true;\n\n    m_bNoDataSet = false;\n    m_dfNoDataValue = -9999.0;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             NullBlock()                              */\n/*                                                                      */\n/*      Set the block data to the null value if it is set, or zero      */\n/*      if there is no null data value.                                 */\n/************************************************************************/\n\nvoid GTiffRasterBand::NullBlock( void *pData )\n\n{\n    const GPtrDiff_t nWords = static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize;\n    const int nChunkSize = std::max(1, GDALGetDataTypeSizeBytes(eDataType));\n\n    int bNoDataSetIn = FALSE;\n    const double dfNoData = GetNoDataValue( &bNoDataSetIn );\n    if( !bNoDataSetIn )\n    {\n#ifdef ESRI_BUILD\n        if( m_poGDS->m_nBitsPerSample >= 2 )\n            memset( pData, 0, nWords * nChunkSize );\n        else\n            memset( pData, 1, nWords * nChunkSize );\n#else\n        memset( pData, 0, nWords * nChunkSize );\n#endif\n    }\n    else\n    {\n        // Will convert nodata value to the right type and copy efficiently.\n        GDALCopyWords64( &dfNoData, GDT_Float64, 0,\n                       pData, eDataType, nChunkSize, nWords);\n    }\n}\n\n/************************************************************************/\n/*                          GetOverviewCount()                          */\n/************************************************************************/\n\nint GTiffRasterBand::GetOverviewCount()\n\n{\n    m_poGDS->ScanDirectories();\n\n    if( m_poGDS->m_nOverviewCount > 0 )\n    {\n        return m_poGDS->m_nOverviewCount;\n    }\n\n    const int nOverviewCount = GDALRasterBand::GetOverviewCount();\n    if( nOverviewCount > 0 )\n        return nOverviewCount;\n\n    // Implicit JPEG overviews are normally hidden, except when doing\n    // IRasterIO() operations.\n    if( m_poGDS->m_nJPEGOverviewVisibilityCounter )\n        return m_poGDS->GetJPEGOverviewCount();\n\n    return 0;\n}\n\n/************************************************************************/\n/*                            GetOverview()                             */\n/************************************************************************/\n\nGDALRasterBand *GTiffRasterBand::GetOverview( int i )\n\n{\n    m_poGDS->ScanDirectories();\n\n    if( m_poGDS->m_nOverviewCount > 0 )\n    {\n        // Do we have internal overviews?\n        if( i < 0 || i >= m_poGDS->m_nOverviewCount )\n            return nullptr;\n\n        return m_poGDS->m_papoOverviewDS[i]->GetRasterBand(nBand);\n    }\n\n    GDALRasterBand* const poOvrBand = GDALRasterBand::GetOverview( i );\n    if( poOvrBand != nullptr )\n        return poOvrBand;\n\n    // For consistency with GetOverviewCount(), we should also test\n    // m_nJPEGOverviewVisibilityCounter, but it is also convenient to be able\n    // to query them for testing purposes.\n    if( i >= 0 && i < m_poGDS->GetJPEGOverviewCount() )\n        return m_poGDS->m_papoJPEGOverviewDS[i]->GetRasterBand(nBand);\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                           GetMaskFlags()                             */\n/************************************************************************/\n\nint GTiffRasterBand::GetMaskFlags()\n{\n    m_poGDS->ScanDirectories();\n\n    if( m_poGDS->m_poExternalMaskDS != nullptr )\n    {\n        return GMF_PER_DATASET;\n    }\n\n    if( m_poGDS->m_poMaskDS != nullptr )\n    {\n        if( m_poGDS->m_poMaskDS->GetRasterCount() == 1)\n        {\n            return GMF_PER_DATASET;\n        }\n\n        return 0;\n    }\n\n    if( m_poGDS->m_bIsOverview )\n    {\n        return m_poGDS->m_poBaseDS->GetRasterBand(nBand)->GetMaskFlags();\n    }\n\n    return GDALPamRasterBand::GetMaskFlags();\n}\n\n/************************************************************************/\n/*                            GetMaskBand()                             */\n/************************************************************************/\n\nGDALRasterBand *GTiffRasterBand::GetMaskBand()\n{\n    m_poGDS->ScanDirectories();\n\n    if( m_poGDS->m_poExternalMaskDS != nullptr )\n    {\n        return m_poGDS->m_poExternalMaskDS->GetRasterBand(1);\n    }\n\n    if( m_poGDS->m_poMaskDS != nullptr )\n    {\n        if( m_poGDS->m_poMaskDS->GetRasterCount() == 1 )\n            return m_poGDS->m_poMaskDS->GetRasterBand(1);\n\n        return m_poGDS->m_poMaskDS->GetRasterBand(nBand);\n    }\n\n    if( m_poGDS->m_bIsOverview )\n    {\n        GDALRasterBand* poBaseMask =\n            m_poGDS->m_poBaseDS->GetRasterBand(nBand)->GetMaskBand();\n        if( poBaseMask )\n        {\n            const int nOverviews = poBaseMask->GetOverviewCount();\n            for( int i = 0; i < nOverviews; i++ )\n            {\n                GDALRasterBand* poOvr = poBaseMask->GetOverview(i);\n                if( poOvr &&\n                    poOvr->GetXSize() == GetXSize() &&\n                    poOvr->GetYSize() == GetYSize() )\n                {\n                    return poOvr;\n                }\n            }\n        }\n    }\n\n    return GDALPamRasterBand::GetMaskBand();\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffSplitBand                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffSplitBand final : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n\n  public:\n             GTiffSplitBand( GTiffDataset *, int );\n    virtual ~GTiffSplitBand() {}\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                           GTiffSplitBand()                           */\n/************************************************************************/\n\nGTiffSplitBand::GTiffSplitBand( GTiffDataset *poDSIn, int nBandIn ) :\n    GTiffRasterBand( poDSIn, nBandIn )\n{\n    nBlockXSize = poDS->GetRasterXSize();\n    nBlockYSize = 1;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffSplitBand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBand::IReadBlock( int /* nBlockXOff */, int nBlockYOff,\n                                   void * pImage )\n\n{\n    m_poGDS->Crystalize();\n\n    // Optimization when reading the same line in a contig multi-band TIFF.\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG && m_poGDS->nBands > 1 &&\n        m_poGDS->m_nLoadedBlock == nBlockYOff )\n    {\n        goto extract_band_data;\n    }\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        m_poGDS->nBands > 1 )\n    {\n        if( m_poGDS->m_pabyBlockBuf == nullptr )\n        {\n            m_poGDS->m_pabyBlockBuf =\n                static_cast<GByte *>(\n                    VSI_MALLOC_VERBOSE(TIFFScanlineSize(m_poGDS->m_hTIFF)) );\n            if( m_poGDS->m_pabyBlockBuf == nullptr )\n            {\n                return CE_Failure;\n            }\n        }\n    }\n    else\n    {\n        CPLAssert(TIFFScanlineSize(m_poGDS->m_hTIFF) == nBlockXSize);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read through to target scanline.                                */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS->m_nLoadedBlock >= nBlockYOff )\n        m_poGDS->m_nLoadedBlock = -1;\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE && m_poGDS->nBands > 1 )\n    {\n        // If we change of band, we must start reading the\n        // new strip from its beginning.\n        if( m_poGDS->m_nLastBandRead != nBand )\n            m_poGDS->m_nLoadedBlock = -1;\n        m_poGDS->m_nLastBandRead = nBand;\n    }\n\n    while( m_poGDS->m_nLoadedBlock < nBlockYOff )\n    {\n        ++m_poGDS->m_nLoadedBlock;\n        if( TIFFReadScanline(\n                m_poGDS->m_hTIFF,\n                m_poGDS->m_pabyBlockBuf ? m_poGDS->m_pabyBlockBuf : pImage,\n                m_poGDS->m_nLoadedBlock,\n                (m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE) ?\n                 static_cast<uint16>(nBand - 1) : 0 ) == -1\n            && !m_poGDS->m_bIgnoreReadErrors )\n        {\n            ReportError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadScanline() failed.\" );\n            m_poGDS->m_nLoadedBlock = -1;\n            return CE_Failure;\n        }\n    }\n\nextract_band_data:\n/* -------------------------------------------------------------------- */\n/*      Extract band data from contig buffer.                           */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS->m_pabyBlockBuf != nullptr )\n    {\n        for( int iPixel = 0, iSrcOffset= nBand - 1, iDstOffset = 0;\n             iPixel < nBlockXSize;\n             ++iPixel, iSrcOffset += m_poGDS->nBands, ++iDstOffset )\n        {\n            static_cast<GByte *>(pImage)[iDstOffset] =\n                m_poGDS->m_pabyBlockBuf[iSrcOffset];\n        }\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBand::IWriteBlock( int /* nBlockXOff */, int /* nBlockYOff */,\n                                    void * /* pImage */ )\n\n{\n    ReportError( CE_Failure, CPLE_AppDefined,\n              \"Split bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffRGBABand                            */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRGBABand final : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n\n  public:\n                   GTiffRGBABand( GTiffDataset *, int );\n    virtual ~GTiffRGBABand() {}\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n\n    virtual GDALColorInterp GetColorInterpretation() override;\n};\n\n/************************************************************************/\n/*                           GTiffRGBABand()                            */\n/************************************************************************/\n\nGTiffRGBABand::GTiffRGBABand( GTiffDataset *poDSIn, int nBandIn ) :\n    GTiffRasterBand( poDSIn, nBandIn )\n{\n    eDataType = GDT_Byte;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRGBABand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IWriteBlock( int, int, void * )\n\n{\n    ReportError( CE_Failure, CPLE_AppDefined,\n              \"RGBA interpreted raster bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                  void * pImage )\n\n{\n    m_poGDS->Crystalize();\n\n    CPLAssert( nBlocksPerRow != 0 );\n    const auto nBlockBufSize = 4 * static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        for( int iBand = 0; iBand < m_poGDS->m_nSamplesPerPixel; iBand ++ )\n        {\n            int nBlockIdBand = nBlockId + iBand * m_poGDS->m_nBlocksPerBand;\n            if( !m_poGDS->IsBlockAvailable(nBlockIdBand) )\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if( !m_poGDS->IsBlockAvailable(nBlockId) )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS->m_pabyBlockBuf == nullptr )\n    {\n        m_poGDS->m_pabyBlockBuf =\n            static_cast<GByte *>(\n                VSI_MALLOC3_VERBOSE( 4, nBlockXSize, nBlockYSize ) );\n        if( m_poGDS->m_pabyBlockBuf == nullptr )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read the strip                                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if( m_poGDS->m_nLoadedBlock != nBlockId )\n    {\n        if( TIFFIsTiled( m_poGDS->m_hTIFF ) )\n        {\n#if TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBATileExt(\n                   m_poGDS->m_hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(m_poGDS->m_pabyBlockBuf),\n                   !m_poGDS->m_bIgnoreReadErrors) == 0\n                && !m_poGDS->m_bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBATile(\n                   m_poGDS->m_hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(m_poGDS->m_pabyBlockBuf)) == 0\n                && !m_poGDS->m_bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBATile() failed.\" );\n\n                memset( m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n#if TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBAStripExt(\n                   m_poGDS->m_hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(m_poGDS->m_pabyBlockBuf),\n                   !m_poGDS->m_bIgnoreReadErrors) == 0\n                && !m_poGDS->m_bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBAStrip(\n                   m_poGDS->m_hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(m_poGDS->m_pabyBlockBuf)) == 0\n                && !m_poGDS->m_bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBAStrip() failed.\" );\n\n                memset( m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    m_poGDS->m_nLoadedBlock = nBlockId;\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case of eight bit data, and pixel interleaving.   */\n/* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if( nBlockYOff * nBlockYSize > GetYSize() - nBlockYSize\n        && !TIFFIsTiled( m_poGDS->m_hTIFF ) )\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for( int iDestLine = 0; iDestLine < nThisBlockYSize; ++iDestLine )\n    {\n        const auto nSrcOffset =\n            static_cast<GPtrDiff_t>(nThisBlockYSize - iDestLine - 1) * nBlockXSize * 4;\n\n        GDALCopyWords(\n            m_poGDS->m_pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n            static_cast<GByte *>(pImage)+static_cast<GPtrDiff_t>(iDestLine)*nBlockXSize, GDT_Byte, 1,\n            nBlockXSize );\n    }\n\n    if( eErr == CE_None )\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRGBABand::GetColorInterpretation()\n\n{\n    if( nBand == 1 )\n        return GCI_RedBand;\n    if( nBand == 2 )\n        return GCI_GreenBand;\n    if( nBand == 3 )\n        return GCI_BlueBand;\n\n    return GCI_AlphaBand;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffOddBitsBand                         */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffOddBitsBand CPL_NON_FINAL: public GTiffRasterBand\n{\n    friend class GTiffDataset;\n  public:\n\n                   GTiffOddBitsBand( GTiffDataset *, int );\n    virtual ~GTiffOddBitsBand() {}\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                           GTiffOddBitsBand()                         */\n/************************************************************************/\n\nGTiffOddBitsBand::GTiffOddBitsBand( GTiffDataset *m_poGDSIn, int nBandIn )\n        : GTiffRasterBand( m_poGDSIn, nBandIn )\n\n{\n    eDataType = GDT_Unknown;\n    if( (m_poGDS->m_nBitsPerSample == 16 || m_poGDS->m_nBitsPerSample == 24) &&\n        m_poGDS->m_nSampleFormat == SAMPLEFORMAT_IEEEFP )\n        eDataType = GDT_Float32;\n    // FIXME ? in autotest we currently open gcore/data/int24.tif\n    // which is declared as signed, but we consider it as unsigned\n    else if( (m_poGDS->m_nSampleFormat == SAMPLEFORMAT_UINT ||\n              m_poGDS->m_nSampleFormat == SAMPLEFORMAT_INT) &&\n             m_poGDS->m_nBitsPerSample < 8 )\n        eDataType = GDT_Byte;\n    else if( (m_poGDS->m_nSampleFormat == SAMPLEFORMAT_UINT ||\n              m_poGDS->m_nSampleFormat == SAMPLEFORMAT_INT) &&\n             m_poGDS->m_nBitsPerSample > 8 && m_poGDS->m_nBitsPerSample < 16 )\n        eDataType = GDT_UInt16;\n    else if( (m_poGDS->m_nSampleFormat == SAMPLEFORMAT_UINT ||\n              m_poGDS->m_nSampleFormat == SAMPLEFORMAT_INT) &&\n             m_poGDS->m_nBitsPerSample > 16 && m_poGDS->m_nBitsPerSample < 32 )\n        eDataType = GDT_UInt32;\n}\n\n/************************************************************************/\n/*                            FloatToHalf()                             */\n/************************************************************************/\n\nstatic GUInt16 FloatToHalf( GUInt32 iFloat32, bool& bHasWarned )\n{\n    GUInt32 iSign =     (iFloat32 >> 31) & 0x00000001;\n    GUInt32 iExponent = (iFloat32 >> 23) & 0x000000ff;\n    GUInt32 iMantissa = iFloat32         & 0x007fffff;\n\n    if (iExponent == 255)\n    {\n        if (iMantissa == 0)\n        {\n/* -------------------------------------------------------------------- */\n/*       Positive or negative infinity.                                 */\n/* -------------------------------------------------------------------- */\n\n            return static_cast<GUInt16>((iSign << 15) | 0x7C00);\n        }\n        else\n        {\n/* -------------------------------------------------------------------- */\n/*       NaN -- preserve sign and significand bits.                     */\n/* -------------------------------------------------------------------- */\n            if( iMantissa >> 13 )\n                return static_cast<GUInt16>((iSign << 15) | 0x7C00 |\n                                                            (iMantissa >> 13));\n\n            return static_cast<GUInt16>((iSign << 15) | 0x7E00);\n        }\n    }\n\n    if( iExponent <= 127 - 15 )\n    {\n        // Zero, float32 denormalized number or float32 too small normalized\n        // number\n        if( 13 + 1 + 127 - 15 - iExponent >= 32 )\n            return static_cast<GUInt16>(iSign << 15);\n\n        // Return a denormalized number\n        return static_cast<GUInt16>((iSign << 15) |\n                ((iMantissa | 0x00800000) >> (13 + 1 + 127 - 15 - iExponent)));\n    }\n    if( iExponent - (127 - 15) >= 31 )\n    {\n        if( !bHasWarned )\n        {\n            bHasWarned = true;\n            float fVal = 0.0f;\n            memcpy(&fVal, &iFloat32, 4);\n            CPLError(\n                CE_Failure, CPLE_AppDefined,\n                \"Value %.8g is beyond range of float16. Converted to %sinf\",\n                fVal, (fVal > 0) ? \"+\" : \"-\");\n        }\n        return static_cast<GUInt16>((iSign << 15) | 0x7C00);  // Infinity\n    }\n\n/* -------------------------------------------------------------------- */\n/*       Normalized number.                                             */\n/* -------------------------------------------------------------------- */\n\n    iExponent = iExponent - (127 - 15);\n    iMantissa = iMantissa >> 13;\n\n/* -------------------------------------------------------------------- */\n/*       Assemble sign, exponent and mantissa.                          */\n/* -------------------------------------------------------------------- */\n\n    // coverity[overflow_sink]\n    return static_cast<GUInt16>((iSign << 15) | (iExponent << 10) | iMantissa);\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffOddBitsBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                      void *pImage )\n\n{\n    m_poGDS->Crystalize();\n\n    if( m_poGDS->m_bWriteError )\n    {\n        // Report as an error if a previously loaded block couldn't be written\n        // correctly.\n        return CE_Failure;\n    }\n\n    if( eDataType == GDT_Float32 && m_poGDS->m_nBitsPerSample != 16 )\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"Writing float data with nBitsPerSample = %d is unsupported\",\n                 m_poGDS->m_nBitsPerSample);\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block buffer.                                          */\n/* -------------------------------------------------------------------- */\n    CPLAssert(nBlocksPerRow != 0);\n    int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId += (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n\n    // Only read content from disk in the CONTIG case.\n    {\n        const CPLErr eErr =\n            m_poGDS->LoadBlockBuf( nBlockId,\n                                 m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n                                 m_poGDS->nBands > 1 );\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n    const GUInt32 nMaxVal = (1U << m_poGDS->m_nBitsPerSample) - 1;\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of \"separate\" images or single band images where    */\n/*      no interleaving with other data is required.                    */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE\n        || m_poGDS->nBands == 1 )\n    {\n        // TODO(schwehr): Create a CplNumBits8Aligned.\n        // Bits per line rounds up to next byte boundary.\n        GInt64 nBitsPerLine = static_cast<GInt64>(nBlockXSize) * m_poGDS->m_nBitsPerSample;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        GPtrDiff_t iPixel = 0;\n\n        // Small optimization in 1 bit case.\n        if( m_poGDS->m_nBitsPerSample == 1 )\n        {\n            for( int iY = 0; iY < nBlockYSize; ++iY, iPixel += nBlockXSize )\n            {\n                GInt64 iBitOffset = iY * nBitsPerLine;\n\n                const GByte* pabySrc =\n                    static_cast<const GByte*>(pImage) + iPixel;\n                auto iByteOffset = iBitOffset / 8;\n                int iX = 0;  // Used after for.\n                for( ; iX + 7 < nBlockXSize; iX += 8, iByteOffset++ )\n                {\n                    int nRes = (!(!pabySrc[iX+0])) << 7;\n                    nRes |= (!(!pabySrc[iX+1])) << 6;\n                    nRes |= (!(!pabySrc[iX+2])) << 5;\n                    nRes |= (!(!pabySrc[iX+3])) << 4;\n                    nRes |= (!(!pabySrc[iX+4])) << 3;\n                    nRes |= (!(!pabySrc[iX+5])) << 2;\n                    nRes |= (!(!pabySrc[iX+6])) << 1;\n                    nRes |= (!(!pabySrc[iX+7])) << 0;\n                    m_poGDS->m_pabyBlockBuf[iByteOffset] = static_cast<GByte>(nRes);\n                }\n                iBitOffset = iByteOffset * 8;\n                if( iX < nBlockXSize )\n                {\n                    int nRes = 0;\n                    for( ; iX < nBlockXSize; ++iX )\n                    {\n                        if( pabySrc[iX] )\n                            nRes |= (0x80 >>(iBitOffset & 7) );\n                        ++iBitOffset;\n                    }\n                    m_poGDS->m_pabyBlockBuf[iBitOffset>>3] =\n                        static_cast<GByte>(nRes);\n                }\n            }\n\n            m_poGDS->m_bLoadedBlockDirty = true;\n\n            return CE_None;\n        }\n\n        if( eDataType == GDT_Float32 && m_poGDS->m_nBitsPerSample == 16 )\n        {\n            for( ; iPixel < static_cast<GPtrDiff_t>(nBlockYSize) * nBlockXSize; iPixel++ )\n            {\n                GUInt32 nInWord = static_cast<GUInt32 *>(pImage)[iPixel];\n                bool bClipWarn = m_poGDS->m_bClipWarn;\n                GUInt16 nHalf = FloatToHalf(nInWord, bClipWarn);\n                m_poGDS->m_bClipWarn = bClipWarn;\n                reinterpret_cast<GUInt16*>(m_poGDS->m_pabyBlockBuf)[iPixel] = nHalf;\n            }\n\n            m_poGDS->m_bLoadedBlockDirty = true;\n\n            return CE_None;\n        }\n\n        // Initialize to zero as we set the buffer with binary or operations.\n        if( m_poGDS->m_nBitsPerSample != 24 )\n            memset(m_poGDS->m_pabyBlockBuf, 0, static_cast<size_t>((nBitsPerLine / 8) * nBlockYSize));\n\n        for( int iY = 0; iY < nBlockYSize; ++iY )\n        {\n            GInt64 iBitOffset = iY * nBitsPerLine;\n\n            if( m_poGDS->m_nBitsPerSample == 12 )\n            {\n                for( int iX = 0; iX < nBlockXSize; ++iX )\n                {\n                    GUInt32 nInWord = static_cast<GUInt16 *>(pImage)[iPixel++];\n                    if( nInWord > nMaxVal )\n                    {\n                        nInWord = nMaxVal;\n                        if( !m_poGDS->m_bClipWarn )\n                        {\n                            m_poGDS->m_bClipWarn = true;\n                            ReportError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"One or more pixels clipped to fit %d bit \"\n                                \"domain.\", m_poGDS->m_nBitsPerSample );\n                        }\n                    }\n\n                    if( (iBitOffset % 8) == 0 )\n                    {\n                        m_poGDS->m_pabyBlockBuf[iBitOffset>>3] =\n                            static_cast<GByte>(nInWord >> 4);\n                        // Let 4 lower bits to zero as they're going to be\n                        // overridden by the next word.\n                        m_poGDS->m_pabyBlockBuf[(iBitOffset>>3)+1] =\n                            static_cast<GByte>((nInWord & 0xf) << 4);\n                    }\n                    else\n                    {\n                        // Must or to preserve the 4 upper bits written\n                        // for the previous word.\n                        m_poGDS->m_pabyBlockBuf[iBitOffset>>3] |=\n                            static_cast<GByte>(nInWord >> 8);\n                        m_poGDS->m_pabyBlockBuf[(iBitOffset>>3)+1] =\n                            static_cast<GByte>(nInWord & 0xff);\n                    }\n\n                    iBitOffset += m_poGDS->m_nBitsPerSample;\n                }\n                continue;\n            }\n\n            for( int iX = 0; iX < nBlockXSize; ++iX )\n            {\n                GUInt32 nInWord = 0;\n                if( eDataType == GDT_Byte )\n                {\n                    nInWord = static_cast<GByte *>(pImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                    nInWord = static_cast<GUInt16 *>(pImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                    nInWord = static_cast<GUInt32 *>(pImage)[iPixel++];\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n\n                if( nInWord > nMaxVal )\n                {\n                    nInWord = nMaxVal;\n                    if( !m_poGDS->m_bClipWarn )\n                    {\n                        m_poGDS->m_bClipWarn = true;\n                        ReportError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"One or more pixels clipped to fit %d bit domain.\",\n                            m_poGDS->m_nBitsPerSample );\n                    }\n                }\n\n                if( m_poGDS->m_nBitsPerSample == 24 )\n                {\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n#ifdef CPL_MSB\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 0] =\n                        static_cast<GByte>( nInWord );\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 1] =\n                        static_cast<GByte>( nInWord >> 8 );\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 2] =\n                        static_cast<GByte>( nInWord >> 16 );\n#else\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 0] =\n                        static_cast<GByte>( nInWord >> 16 );\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 1] =\n                        static_cast<GByte>( nInWord >> 8 );\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 2] =\n                        static_cast<GByte>( nInWord );\n#endif\n                    iBitOffset += 24;\n                }\n                else\n                {\n                    for( int iBit = 0; iBit < m_poGDS->m_nBitsPerSample; ++iBit )\n                    {\n                        if( nInWord &\n                            (1 << (m_poGDS->m_nBitsPerSample - 1 - iBit)) )\n                            m_poGDS->m_pabyBlockBuf[iBitOffset>>3] |=\n                                ( 0x80 >> (iBitOffset & 7) );\n                        ++iBitOffset;\n                    }\n                }\n            }\n        }\n\n        m_poGDS->m_bLoadedBlockDirty = true;\n\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of pixel interleaved (PLANARCONFIG_CONTIG) images.  */\n/* -------------------------------------------------------------------- */\n\n/* -------------------------------------------------------------------- */\n/*      On write of pixel interleaved data, we might as well flush      */\n/*      out any other bands that are dirty in our cache.  This is       */\n/*      especially helpful when writing compressed blocks.              */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < m_poGDS->nBands; ++iBand )\n    {\n        const GByte *pabyThisImage = nullptr;\n        GDALRasterBlock *poBlock = nullptr;\n\n        if( iBand + 1 == nBand )\n        {\n            pabyThisImage = static_cast<GByte *>( pImage );\n        }\n        else\n        {\n            poBlock =\n                cpl::down_cast<GTiffOddBitsBand *>(\n                    m_poGDS->GetRasterBand( iBand + 1 ))\n                        ->TryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n            if( poBlock == nullptr )\n                continue;\n\n            if( !poBlock->GetDirty() )\n            {\n                poBlock->DropLock();\n                continue;\n            }\n\n            pabyThisImage = static_cast<GByte *>(poBlock->GetDataRef());\n        }\n\n        const int iPixelBitSkip = m_poGDS->m_nBitsPerSample * m_poGDS->nBands;\n        const int iBandBitOffset = iBand * m_poGDS->m_nBitsPerSample;\n\n        // Bits per line rounds up to next byte boundary.\n        GInt64 nBitsPerLine = static_cast<GInt64>(nBlockXSize) * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        GPtrDiff_t iPixel = 0;\n\n        if( eDataType == GDT_Float32 && m_poGDS->m_nBitsPerSample == 16 )\n        {\n            for( ; iPixel < static_cast<GPtrDiff_t>(nBlockYSize) * nBlockXSize; iPixel++ )\n            {\n                GUInt32 nInWord = reinterpret_cast<const GUInt32 *>(\n                                                        pabyThisImage)[iPixel];\n                bool bClipWarn = m_poGDS->m_bClipWarn;\n                GUInt16 nHalf = FloatToHalf(nInWord, bClipWarn);\n                m_poGDS->m_bClipWarn = bClipWarn;\n                reinterpret_cast<GUInt16*>(m_poGDS->m_pabyBlockBuf)[\n                                    iPixel * m_poGDS->nBands + iBand] = nHalf;\n            }\n\n            if( poBlock != nullptr )\n            {\n                poBlock->MarkClean();\n                poBlock->DropLock();\n            }\n            continue;\n        }\n\n        for( int iY = 0; iY < nBlockYSize; ++iY )\n        {\n            GInt64 iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            if( m_poGDS->m_nBitsPerSample == 12 )\n            {\n                for( int iX = 0; iX < nBlockXSize; ++iX )\n                {\n                    GUInt32 nInWord =\n                        reinterpret_cast<const GUInt16 *>(\n                            pabyThisImage)[iPixel++];\n                    if( nInWord > nMaxVal )\n                    {\n                        nInWord = nMaxVal;\n                        if( !m_poGDS->m_bClipWarn )\n                        {\n                            m_poGDS->m_bClipWarn = true;\n                            ReportError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"One or more pixels clipped to fit %d bit \"\n                                \"domain.\", m_poGDS->m_nBitsPerSample );\n                        }\n                    }\n\n                    if( (iBitOffset % 8) == 0 )\n                    {\n                        m_poGDS->m_pabyBlockBuf[iBitOffset>>3] =\n                            static_cast<GByte>( nInWord >> 4 );\n                        m_poGDS->m_pabyBlockBuf[(iBitOffset>>3)+1] =\n                            static_cast<GByte>(\n                                ((nInWord & 0xf) << 4) |\n                                (m_poGDS->m_pabyBlockBuf[(iBitOffset>>3)+1] &\n                                 0xf) );\n                    }\n                    else\n                    {\n                        m_poGDS->m_pabyBlockBuf[iBitOffset>>3] =\n                            static_cast<GByte>(\n                                (m_poGDS->m_pabyBlockBuf[iBitOffset>>3] &\n                                 0xf0) |\n                                (nInWord >> 8));\n                        m_poGDS->m_pabyBlockBuf[(iBitOffset>>3)+1] =\n                            static_cast<GByte>(nInWord & 0xff);\n                    }\n\n                    iBitOffset += iPixelBitSkip;\n                }\n                continue;\n            }\n\n            for( int iX = 0; iX < nBlockXSize; ++iX )\n            {\n                GUInt32 nInWord = 0;\n                if( eDataType == GDT_Byte )\n                {\n                    nInWord =\n                        static_cast<const GByte *>(pabyThisImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                    nInWord = reinterpret_cast<const GUInt16 *>(\n                        pabyThisImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                    nInWord = reinterpret_cast<const GUInt32 *>(\n                        pabyThisImage)[iPixel++];\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n\n                if( nInWord > nMaxVal )\n                {\n                    nInWord = nMaxVal;\n                    if( !m_poGDS->m_bClipWarn )\n                    {\n                        m_poGDS->m_bClipWarn = true;\n                        ReportError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"One or more pixels clipped to fit %d bit domain.\",\n                            m_poGDS->m_nBitsPerSample );\n                    }\n                }\n\n                if( m_poGDS->m_nBitsPerSample == 24 )\n                {\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n#ifdef CPL_MSB\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 0] =\n                        static_cast<GByte>(nInWord);\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 1] =\n                        static_cast<GByte>(nInWord >> 8);\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 2] =\n                        static_cast<GByte>(nInWord >> 16);\n#else\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 0] =\n                        static_cast<GByte>(nInWord >> 16);\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 1] =\n                        static_cast<GByte>(nInWord >> 8);\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 2] =\n                        static_cast<GByte>(nInWord);\n#endif\n                    iBitOffset += 24;\n                }\n                else\n                {\n                    for( int iBit = 0; iBit < m_poGDS->m_nBitsPerSample; ++iBit )\n                    {\n                        // TODO(schwehr): Revisit this block.\n                        if( nInWord &\n                            (1 << (m_poGDS->m_nBitsPerSample - 1 - iBit)) )\n                        {\n                            m_poGDS->m_pabyBlockBuf[iBitOffset>>3] |=\n                                ( 0x80 >> (iBitOffset & 7) );\n                        }\n                        else\n                        {\n                            // We must explicitly unset the bit as we\n                            // may update an existing block.\n                            m_poGDS->m_pabyBlockBuf[iBitOffset>>3] &=\n                                ~(0x80 >>(iBitOffset & 7));\n                        }\n\n                        ++iBitOffset;\n                    }\n                }\n\n                iBitOffset = iBitOffset + iPixelBitSkip - m_poGDS->m_nBitsPerSample;\n            }\n        }\n\n        if( poBlock != nullptr )\n        {\n            poBlock->MarkClean();\n            poBlock->DropLock();\n        }\n    }\n\n    m_poGDS->m_bLoadedBlockDirty = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nstatic void ExpandPacked8ToByte1( const GByte * const CPL_RESTRICT pabySrc,\n                                  GByte* const CPL_RESTRICT pabyDest,\n                                  GPtrDiff_t nBytes )\n{\n    for( decltype(nBytes) i = 0, j = 0; i < nBytes; i++, j+= 8 )\n    {\n        const GByte byVal = pabySrc[i];\n        pabyDest[j+0] = (byVal >> 7) & 0x1;\n        pabyDest[j+1] = (byVal >> 6) & 0x1;\n        pabyDest[j+2] = (byVal >> 5) & 0x1;\n        pabyDest[j+3] = (byVal >> 4) & 0x1;\n        pabyDest[j+4] = (byVal >> 3) & 0x1;\n        pabyDest[j+5] = (byVal >> 2) & 0x1;\n        pabyDest[j+6] = (byVal >> 1) & 0x1;\n        pabyDest[j+7] = (byVal >> 0) & 0x1;\n    }\n}\n\n#if defined(__GNUC__) || defined(_MSC_VER)\n// Signedness of char implementation dependent, so be explicit.\n// Assumes 2-complement integer types and sign extension of right shifting\n// GCC guarantees such:\n// https://gcc.gnu.org/onlinedocs/gcc/Integers-implementation.html#Integers-implementation\nstatic inline GByte ExtractBitAndConvertTo255(GByte byVal, int nBit)\n{\n    return\n        static_cast<GByte>(static_cast<signed char>(byVal << (7 - nBit)) >> 7);\n}\n#else\n// Portable way\nstatic inline GByte ExtractBitAndConvertTo255(GByte byVal, int nBit)\n{\n    return (byVal & (1 << nBit)) ? 255 : 0;\n}\n#endif\n\nstatic void ExpandPacked8ToByte255( const GByte * const CPL_RESTRICT pabySrc,\n                                    GByte* const CPL_RESTRICT pabyDest,\n                                    GPtrDiff_t nBytes )\n{\n    for( decltype(nBytes) i = 0, j = 0; i < nBytes; i++, j += 8 )\n    {\n        const GByte byVal = pabySrc[i];\n        pabyDest[j+0] = ExtractBitAndConvertTo255(byVal, 7);\n        pabyDest[j+1] = ExtractBitAndConvertTo255(byVal, 6);\n        pabyDest[j+2] = ExtractBitAndConvertTo255(byVal, 5);\n        pabyDest[j+3] = ExtractBitAndConvertTo255(byVal, 4);\n        pabyDest[j+4] = ExtractBitAndConvertTo255(byVal, 3);\n        pabyDest[j+5] = ExtractBitAndConvertTo255(byVal, 2);\n        pabyDest[j+6] = ExtractBitAndConvertTo255(byVal, 1);\n        pabyDest[j+7] = ExtractBitAndConvertTo255(byVal, 0);\n    }\n}\n\nCPLErr GTiffOddBitsBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                     void * pImage )\n\n{\n    m_poGDS->Crystalize();\n\n    CPLAssert(nBlocksPerRow != 0);\n    int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId += (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Handle the case of a strip in a writable file that doesn't      */\n/*      exist yet, but that we want to read.  Just set to zeros and     */\n/*      return.                                                         */\n/* -------------------------------------------------------------------- */\n    if( nBlockId != m_poGDS->m_nLoadedBlock )\n    {\n        bool bErrOccurred = false;\n        if( !m_poGDS->IsBlockAvailable(nBlockId, nullptr, nullptr, &bErrOccurred) )\n        {\n            NullBlock( pImage );\n            if( bErrOccurred )\n                return CE_Failure;\n            return CE_None;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block buffer.                                          */\n/* -------------------------------------------------------------------- */\n    {\n        const CPLErr eErr = m_poGDS->LoadBlockBuf( nBlockId );\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n    if( m_poGDS->m_nBitsPerSample == 1 &&\n        (m_poGDS->nBands == 1 || m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE ) )\n    {\n/* -------------------------------------------------------------------- */\n/*      Translate 1bit data to eight bit.                               */\n/* -------------------------------------------------------------------- */\n        GPtrDiff_t iDstOffset = 0;\n        const GByte * const CPL_RESTRICT m_pabyBlockBuf = m_poGDS->m_pabyBlockBuf;\n        GByte* CPL_RESTRICT pabyDest = static_cast<GByte *>(pImage);\n\n        for( int iLine = 0; iLine < nBlockYSize; ++iLine )\n        {\n            GPtrDiff_t iSrcOffsetByte = static_cast<GPtrDiff_t>((nBlockXSize + 7) >> 3) * iLine;\n\n            if( !m_poGDS->m_bPromoteTo8Bits )\n            {\n                ExpandPacked8ToByte1( m_pabyBlockBuf + iSrcOffsetByte,\n                                      pabyDest + iDstOffset,\n                                      nBlockXSize / 8 );\n            }\n            else\n            {\n                ExpandPacked8ToByte255( m_pabyBlockBuf + iSrcOffsetByte,\n                                        pabyDest + iDstOffset,\n                                        nBlockXSize / 8 );\n            }\n            GPtrDiff_t iSrcOffsetBit = (iSrcOffsetByte + nBlockXSize / 8) * 8;\n            iDstOffset += nBlockXSize & ~0x7;\n            const GByte bSetVal = m_poGDS->m_bPromoteTo8Bits ? 255 : 1;\n            for( int iPixel = nBlockXSize & ~0x7 ;\n                 iPixel < nBlockXSize;\n                 ++iPixel, ++iSrcOffsetBit )\n            {\n                if( m_pabyBlockBuf[iSrcOffsetBit >>3] &\n                    (0x80 >> (iSrcOffsetBit & 0x7)) )\n                    static_cast<GByte *>(pImage)[iDstOffset++] = bSetVal;\n                else\n                    static_cast<GByte *>(pImage)[iDstOffset++] = 0;\n            }\n        }\n    }\n/* -------------------------------------------------------------------- */\n/*      Handle the case of 16- and 24-bit floating point data as per    */\n/*      TIFF Technical Note 3.                                          */\n/* -------------------------------------------------------------------- */\n    else if( eDataType == GDT_Float32 )\n    {\n        const int nWordBytes = m_poGDS->m_nBitsPerSample / 8;\n        const GByte *pabyImage = m_poGDS->m_pabyBlockBuf +\n            ( ( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE ) ? 0 :\n              (nBand - 1) * nWordBytes );\n        const int iSkipBytes =\n            ( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE ) ?\n            nWordBytes : m_poGDS->nBands * nWordBytes;\n\n        const auto nBlockPixels = static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize;\n        if( m_poGDS->m_nBitsPerSample == 16 )\n        {\n            for( GPtrDiff_t i = 0; i < nBlockPixels; ++i )\n            {\n                static_cast<GUInt32 *>(pImage)[i] =\n                    HalfToFloat( *reinterpret_cast<const GUInt16 *>(pabyImage) );\n                pabyImage += iSkipBytes;\n            }\n        }\n        else if( m_poGDS->m_nBitsPerSample == 24 )\n        {\n            for( GPtrDiff_t i = 0; i < nBlockPixels; ++i )\n            {\n#ifdef CPL_MSB\n                static_cast<GUInt32 *>(pImage)[i] =\n                    TripleToFloat(\n                        ( static_cast<GUInt32>(*(pabyImage + 0)) << 16)\n                        | (static_cast<GUInt32>(*(pabyImage + 1)) << 8)\n                        | static_cast<GUInt32>(*(pabyImage + 2)) );\n#else\n                static_cast<GUInt32 *>(pImage)[i] =\n                    TripleToFloat(\n                        ( static_cast<GUInt32>(*(pabyImage + 2)) << 16)\n                        | (static_cast<GUInt32>(*(pabyImage + 1)) << 8)\n                        | static_cast<GUInt32>(*pabyImage) );\n#endif\n                pabyImage += iSkipBytes;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for moving 12bit data somewhat more efficiently.   */\n/* -------------------------------------------------------------------- */\n    else if( m_poGDS->m_nBitsPerSample == 12 )\n    {\n        int iPixelBitSkip = 0;\n        int iBandBitOffset = 0;\n\n        if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelBitSkip = m_poGDS->nBands * m_poGDS->m_nBitsPerSample;\n            iBandBitOffset = (nBand - 1) * m_poGDS->m_nBitsPerSample;\n        }\n        else\n        {\n            iPixelBitSkip = m_poGDS->m_nBitsPerSample;\n        }\n\n        // Bits per line rounds up to next byte boundary.\n        GPtrDiff_t nBitsPerLine = static_cast<GPtrDiff_t>(nBlockXSize) * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        int iPixel = 0;\n        for( int iY = 0; iY < nBlockYSize; ++iY )\n        {\n            GPtrDiff_t iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( int iX = 0; iX < nBlockXSize; ++iX )\n            {\n                const auto iByte = iBitOffset >> 3;\n\n                if( (iBitOffset & 0x7) == 0 )\n                {\n                    // Starting on byte boundary.\n\n                    static_cast<GUInt16 *>(pImage)[iPixel++] =\n                        (m_poGDS->m_pabyBlockBuf[iByte] << 4)\n                        | (m_poGDS->m_pabyBlockBuf[iByte+1] >> 4);\n                }\n                else\n                {\n                    // Starting off byte boundary.\n\n                    static_cast<GUInt16 *>(pImage)[iPixel++] =\n                        ((m_poGDS->m_pabyBlockBuf[iByte] & 0xf) << 8)\n                        | (m_poGDS->m_pabyBlockBuf[iByte+1]);\n                }\n                iBitOffset += iPixelBitSkip;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n    else if( m_poGDS->m_nBitsPerSample == 24 )\n    {\n        int iPixelByteSkip = 0;\n        int iBandByteOffset = 0;\n\n        if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelByteSkip = (m_poGDS->nBands * m_poGDS->m_nBitsPerSample) / 8;\n            iBandByteOffset = ((nBand - 1) * m_poGDS->m_nBitsPerSample) / 8;\n        }\n        else\n        {\n            iPixelByteSkip = m_poGDS->m_nBitsPerSample / 8;\n        }\n\n        const GPtrDiff_t nBytesPerLine = static_cast<GPtrDiff_t>(nBlockXSize) * iPixelByteSkip;\n\n        GPtrDiff_t iPixel = 0;\n        for( int iY = 0; iY < nBlockYSize; ++iY )\n        {\n            GByte *pabyImage =\n                m_poGDS->m_pabyBlockBuf + iBandByteOffset + iY * nBytesPerLine;\n\n            for( int iX = 0; iX < nBlockXSize; ++iX )\n            {\n#ifdef CPL_MSB\n                static_cast<GUInt32 *>(pImage)[iPixel++] =\n                    ( static_cast<GUInt32>(*(pabyImage + 2)) << 16)\n                    | (static_cast<GUInt32>(*(pabyImage + 1)) << 8)\n                    | static_cast<GUInt32>(*(pabyImage + 0));\n#else\n                static_cast<GUInt32 *>(pImage)[iPixel++] =\n                    ( static_cast<GUInt32>(*(pabyImage + 0)) << 16)\n                    | (static_cast<GUInt32>(*(pabyImage + 1)) << 8)\n                    | static_cast<GUInt32>(*(pabyImage + 2));\n#endif\n                pabyImage += iPixelByteSkip;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle 1-32 bit integer data.                                   */\n/* -------------------------------------------------------------------- */\n    else\n    {\n        unsigned iPixelBitSkip = 0;\n        unsigned iBandBitOffset = 0;\n\n        if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelBitSkip = m_poGDS->nBands * m_poGDS->m_nBitsPerSample;\n            iBandBitOffset = (nBand - 1) * m_poGDS->m_nBitsPerSample;\n        }\n        else\n        {\n            iPixelBitSkip = m_poGDS->m_nBitsPerSample;\n        }\n\n        // Bits per line rounds up to next byte boundary.\n        GUIntBig nBitsPerLine = static_cast<GUIntBig>(nBlockXSize) * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        const GByte * const m_pabyBlockBuf = m_poGDS->m_pabyBlockBuf;\n        const unsigned nBitsPerSample = m_poGDS->m_nBitsPerSample;\n        GPtrDiff_t iPixel = 0;\n\n        if( nBitsPerSample == 1 && eDataType == GDT_Byte )\n        {\n          for( unsigned iY = 0; iY < static_cast<unsigned>(nBlockYSize); ++iY )\n          {\n            GUIntBig iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( unsigned iX = 0; iX < static_cast<unsigned>(nBlockXSize); ++iX )\n            {\n                if( m_pabyBlockBuf[iBitOffset>>3] & (0x80 >>(iBitOffset & 7)) )\n                    static_cast<GByte *>(pImage)[iPixel] = 1;\n                else\n                    static_cast<GByte *>(pImage)[iPixel] = 0;\n                iBitOffset += iPixelBitSkip;\n                iPixel++;\n            }\n          }\n        }\n        else\n        {\n          for( unsigned iY = 0; iY < static_cast<unsigned>(nBlockYSize); ++iY )\n          {\n            GUIntBig iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( unsigned iX = 0; iX < static_cast<unsigned>(nBlockXSize); ++iX )\n            {\n                unsigned nOutWord = 0;\n\n                for( unsigned iBit = 0; iBit < nBitsPerSample; ++iBit )\n                {\n                    if( m_pabyBlockBuf[iBitOffset>>3]\n                        & (0x80 >>(iBitOffset & 7)) )\n                        nOutWord |= (1 << (nBitsPerSample - 1 - iBit));\n                    ++iBitOffset;\n                }\n\n                iBitOffset = iBitOffset + iPixelBitSkip - nBitsPerSample;\n\n                if( eDataType == GDT_Byte )\n                {\n                    static_cast<GByte *>(pImage)[iPixel++] =\n                        static_cast<GByte>(nOutWord);\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                  static_cast<GUInt16 *>(pImage)[iPixel++] =\n                      static_cast<GUInt16>(nOutWord);\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                  static_cast<GUInt32 *>(pImage)[iPixel++] = nOutWord;\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n            }\n          }\n        }\n    }\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    CacheMaskForBlock(nBlockXOff,nBlockYOff);\n#endif\n\n    return CE_None;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffBitmapBand                          */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffBitmapBand : public GTiffOddBitsBand\n{\n    friend class GTiffDataset;\n\n    GDALColorTable *m_poColorTable = nullptr;\n\n    CPL_DISALLOW_COPY_ASSIGN(GTiffBitmapBand)\n\n  public:\n\n                   GTiffBitmapBand( GTiffDataset *, int );\n    virtual       ~GTiffBitmapBand();\n\n    virtual GDALColorInterp GetColorInterpretation() override;\n    virtual GDALColorTable *GetColorTable() override;\n};\n\n/************************************************************************/\n/*                           GTiffBitmapBand()                          */\n/************************************************************************/\n\nGTiffBitmapBand::GTiffBitmapBand( GTiffDataset *poDSIn, int nBandIn )\n        : GTiffOddBitsBand( poDSIn, nBandIn )\n\n{\n    eDataType = GDT_Byte;\n\n    if( poDSIn->m_poColorTable != nullptr )\n    {\n        m_poColorTable = poDSIn->m_poColorTable->Clone();\n    }\n    else\n    {\n#ifdef ESRI_BUILD\n        m_poColorTable = nullptr;\n#else\n        const GDALColorEntry oWhite = { 255, 255, 255, 255 };\n        const GDALColorEntry oBlack = { 0, 0, 0, 255 };\n\n        m_poColorTable = new GDALColorTable();\n\n        if( poDSIn->m_nPhotometric == PHOTOMETRIC_MINISWHITE )\n        {\n            m_poColorTable->SetColorEntry( 0, &oWhite );\n            m_poColorTable->SetColorEntry( 1, &oBlack );\n        }\n        else\n        {\n            m_poColorTable->SetColorEntry( 0, &oBlack );\n            m_poColorTable->SetColorEntry( 1, &oWhite );\n        }\n#endif  // not defined ESRI_BUILD.\n    }\n}\n\n/************************************************************************/\n/*                          ~GTiffBitmapBand()                          */\n/************************************************************************/\n\nGTiffBitmapBand::~GTiffBitmapBand()\n\n{\n    delete m_poColorTable;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffBitmapBand::GetColorInterpretation()\n\n{\n    if( m_poGDS->m_bPromoteTo8Bits )\n        return GCI_Undefined;\n\n    return GCI_PaletteIndex;\n}\n\n/************************************************************************/\n/*                           GetColorTable()                            */\n/************************************************************************/\n\nGDALColorTable *GTiffBitmapBand::GetColorTable()\n\n{\n    if( m_poGDS->m_bPromoteTo8Bits )\n        return nullptr;\n\n    return m_poColorTable;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                          GTiffSplitBitmapBand                        */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffSplitBitmapBand final : public GTiffBitmapBand\n{\n    friend class GTiffDataset;\n    int m_nLastLineValid = -1;\n\n  public:\n\n                   GTiffSplitBitmapBand( GTiffDataset *, int );\n    virtual       ~GTiffSplitBitmapBand();\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                       GTiffSplitBitmapBand()                         */\n/************************************************************************/\n\nGTiffSplitBitmapBand::GTiffSplitBitmapBand( GTiffDataset *poDSIn, int nBandIn )\n        : GTiffBitmapBand( poDSIn, nBandIn )\n\n{\n    nBlockXSize = poDS->GetRasterXSize();\n    nBlockYSize = 1;\n}\n\n/************************************************************************/\n/*                      ~GTiffSplitBitmapBand()                         */\n/************************************************************************/\n\nGTiffSplitBitmapBand::~GTiffSplitBitmapBand() {}\n\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffSplitBitmapBand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBitmapBand::IReadBlock( int /* nBlockXOff */, int nBlockYOff,\n                                         void * pImage )\n\n{\n    m_poGDS->Crystalize();\n\n    if( m_nLastLineValid >= 0 && nBlockYOff > m_nLastLineValid )\n        return CE_Failure;\n\n    if( m_poGDS->m_pabyBlockBuf == nullptr )\n    {\n        m_poGDS->m_pabyBlockBuf =\n            static_cast<GByte *>(\n                VSI_MALLOC_VERBOSE(TIFFScanlineSize(m_poGDS->m_hTIFF)) );\n        if( m_poGDS->m_pabyBlockBuf == nullptr )\n        {\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read through to target scanline.                                */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS->m_nLoadedBlock >= nBlockYOff )\n        m_poGDS->m_nLoadedBlock = -1;\n\n    while( m_poGDS->m_nLoadedBlock < nBlockYOff )\n    {\n        ++m_poGDS->m_nLoadedBlock;\n\n        std::vector<CPLErrorHandlerAccumulatorStruct> aoErrors;\n        CPLInstallErrorHandlerAccumulator(aoErrors);\n        int nRet = TIFFReadScanline( m_poGDS->m_hTIFF, m_poGDS->m_pabyBlockBuf,\n                                     m_poGDS->m_nLoadedBlock, 0 );\n        CPLUninstallErrorHandlerAccumulator();\n\n        for( size_t iError = 0; iError < aoErrors.size(); ++iError )\n        {\n            ReportError( aoErrors[iError].type,\n                      aoErrors[iError].no,\n                      \"%s\",\n                      aoErrors[iError].msg.c_str() );\n            // FAX decoding only handles EOF condition as a warning, so\n            // catch it so as to turn on error when attempting to read\n            // following lines, to avoid performance issues.\n            if(  !m_poGDS->m_bIgnoreReadErrors &&\n                    aoErrors[iError].msg.find(\"Premature EOF\") !=\n                                                    std::string::npos )\n            {\n                m_nLastLineValid = nBlockYOff;\n                nRet = -1;\n            }\n        }\n\n        if( nRet == -1\n            && !m_poGDS->m_bIgnoreReadErrors )\n        {\n            ReportError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadScanline() failed.\" );\n            m_poGDS->m_nLoadedBlock = -1;\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Translate 1bit data to eight bit.                               */\n/* -------------------------------------------------------------------- */\n    int iSrcOffset = 0;\n    int iDstOffset = 0;\n\n    for( int iPixel = 0; iPixel < nBlockXSize; ++iPixel, ++iSrcOffset )\n    {\n        if( m_poGDS->m_pabyBlockBuf[iSrcOffset >>3] & (0x80 >> (iSrcOffset & 0x7)) )\n            static_cast<GByte *>(pImage)[iDstOffset++] = 1;\n        else\n            static_cast<GByte *>(pImage)[iDstOffset++] = 0;\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBitmapBand::IWriteBlock( int /* nBlockXOff */,\n                                          int /* nBlockYOff */,\n                                          void * /* pImage */ )\n\n{\n    ReportError( CE_Failure, CPLE_AppDefined,\n              \"Split bitmap bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                            GTiffDataset                              */\n/* ==================================================================== */\n/************************************************************************/\n\n/************************************************************************/\n/*                            GTiffDataset()                            */\n/************************************************************************/\n\nGTiffDataset::GTiffDataset():\n    m_bStreamingIn(false),\n    m_bStreamingOut(false),\n    m_bScanDeferred(true),\n    m_bSingleIFDOpened(false),\n    m_bLoadedBlockDirty(false),\n    m_bWriteError(false),\n    m_bLookedForProjection(false),\n    m_bLookedForMDAreaOrPoint(false),\n    m_bGeoTransformValid(false),\n    m_bCrystalized(true),\n    m_bGeoTIFFInfoChanged(false),\n    m_bForceUnsetGTOrGCPs(false),\n    m_bForceUnsetProjection(false),\n    m_bNoDataChanged(false),\n    m_bNoDataSet(false),\n    m_bMetadataChanged(false),\n    m_bColorProfileMetadataChanged(false),\n    m_bForceUnsetRPC(false),\n    m_bNeedsRewrite(false),\n    m_bLoadingOtherBands(false),\n    m_bIsOverview(false),\n    m_bWriteEmptyTiles(true),\n    m_bFillEmptyTilesAtClosing(false),\n    m_bTreatAsSplit(false),\n    m_bTreatAsSplitBitmap(false),\n    m_bClipWarn(false),\n    m_bIMDRPCMetadataLoaded(false),\n    m_bEXIFMetadataLoaded(false),\n    m_bICCMetadataLoaded(false),\n    m_bHasWarnedDisableAggressiveBandCaching(false),\n    m_bDontReloadFirstBlock(false),\n    m_bWebPLossless(false),\n    m_bPromoteTo8Bits(false),\n    m_bDebugDontWriteBlocks(CPLTestBool(CPLGetConfigOption(\"GTIFF_DONT_WRITE_BLOCKS\", \"NO\"))),\n    m_bIsFinalized(false),\n    m_bIgnoreReadErrors(CPLTestBool(CPLGetConfigOption(\"GTIFF_IGNORE_READ_ERRORS\", \"NO\"))),\n    m_bDirectIO(CPLTestBool(CPLGetConfigOption(\"GTIFF_DIRECT_IO\", \"NO\"))),\n    m_bReadGeoTransform(false),\n    m_bLoadPam(false),\n    m_bHasGotSiblingFiles(false),\n    m_bHasIdentifiedAuthorizedGeoreferencingSources(false),\n    m_bLayoutIFDSBeforeData(false),\n    m_bBlockOrderRowMajor(false),\n    m_bLeaderSizeAsUInt4(false),\n    m_bTrailerRepeatedLast4BytesRepeated(false),\n    m_bMaskInterleavedWithImagery(false),\n    m_bKnownIncompatibleEdition(false),\n    m_bWriteKnownIncompatibleEdition(false),\n    m_bHasUsedReadEncodedAPI(false),\n    m_bWriteCOGLayout(false)\n{\n    //CPLDebug(\"GDAL\", \"sizeof(GTiffDataset) = %d bytes\", static_cast<int>(\n    //    sizeof(GTiffDataset)));\n\n    const char* pszVirtualMemIO =\n        CPLGetConfigOption(\"GTIFF_VIRTUAL_MEM_IO\", \"NO\");\n    if( EQUAL(pszVirtualMemIO, \"IF_ENOUGH_RAM\") )\n        m_eVirtualMemIOUsage = VirtualMemIOEnum::IF_ENOUGH_RAM;\n    else if( CPLTestBool(pszVirtualMemIO) )\n        m_eVirtualMemIOUsage = VirtualMemIOEnum::YES;\n\n    m_oSRS.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n}\n\n/************************************************************************/\n/*                           ~GTiffDataset()                            */\n/************************************************************************/\n\nGTiffDataset::~GTiffDataset()\n\n{\n    Finalize();\n    if( m_pszTmpFilename )\n    {\n        VSIUnlink(m_pszTmpFilename);\n        CPLFree(m_pszTmpFilename);\n    }\n}\n\n/************************************************************************/\n/*                             Finalize()                               */\n/************************************************************************/\n\nint GTiffDataset::Finalize()\n{\n    if( m_bIsFinalized )\n        return FALSE;\n\n    bool bHasDroppedRef = false;\n\n    Crystalize();\n\n    if( m_bColorProfileMetadataChanged )\n    {\n        SaveICCProfile(this, nullptr, nullptr, 0);\n        m_bColorProfileMetadataChanged = false;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle forcing xml:ESRI data to be written to PAM.              */\n/* -------------------------------------------------------------------- */\n    if( CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n    {\n        char **papszESRIMD = GTiffDataset::GetMetadata(\"xml:ESRI\");\n        if( papszESRIMD )\n        {\n            GDALPamDataset::SetMetadata( papszESRIMD, \"xml:ESRI\");\n        }\n    }\n\n    if( m_psVirtualMemIOMapping )\n        CPLVirtualMemFree( m_psVirtualMemIOMapping );\n    m_psVirtualMemIOMapping = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Fill in missing blocks with empty data.                         */\n/* -------------------------------------------------------------------- */\n    if( m_bFillEmptyTilesAtClosing )\n    {\n/* -------------------------------------------------------------------- */\n/*  Ensure any blocks write cached by GDAL gets pushed through libtiff. */\n/* -------------------------------------------------------------------- */\n        FlushCacheInternal( false /* do not call FlushDirectory */ );\n\n        FillEmptyTiles();\n        m_bFillEmptyTilesAtClosing = false;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Force a complete flush, including either rewriting(moving)      */\n/*      of writing in place the current directory.                      */\n/* -------------------------------------------------------------------- */\n    FlushCacheInternal( true );\n\n    // Destroy compression queue\n    if( m_poCompressQueue )\n    {\n        m_poCompressQueue->WaitCompletion();\n\n        for( int i = 0; i < static_cast<int>(m_asCompressionJobs.size()); ++i )\n        {\n            CPLFree(m_asCompressionJobs[i].pabyBuffer);\n            if( m_asCompressionJobs[i].pszTmpFilename )\n            {\n                VSIUnlink(m_asCompressionJobs[i].pszTmpFilename);\n                CPLFree(m_asCompressionJobs[i].pszTmpFilename);\n            }\n        }\n        CPLDestroyMutex(m_hCompressThreadPoolMutex);\n        m_poCompressQueue.reset();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If there is still changed metadata, then presumably we want     */\n/*      to push it into PAM.                                            */\n/* -------------------------------------------------------------------- */\n    if( m_bMetadataChanged )\n    {\n        PushMetadataToPam();\n        m_bMetadataChanged = false;\n        GDALPamDataset::FlushCache();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews.                                              */\n/* -------------------------------------------------------------------- */\n    if( !m_poBaseDS )\n    {\n        for( int i = 0; i < m_nOverviewCount; ++i )\n        {\n            delete m_papoOverviewDS[i];\n            bHasDroppedRef = true;\n        }\n        m_nOverviewCount = 0;\n\n        for( int i = 0; i < m_nJPEGOverviewCountOri; ++i )\n        {\n            delete m_papoJPEGOverviewDS[i];\n            bHasDroppedRef = true;\n        }\n        m_nJPEGOverviewCount = 0;\n        m_nJPEGOverviewCountOri = 0;\n        CPLFree( m_papoJPEGOverviewDS );\n        m_papoJPEGOverviewDS = nullptr;\n    }\n\n    // If we are a mask dataset, we can have overviews, but we don't\n    // own them. We can only free the array, not the overviews themselves.\n    CPLFree( m_papoOverviewDS );\n    m_papoOverviewDS = nullptr;\n\n    // m_poMaskDS is owned by the main image and the overviews\n    // so because of the latter case, we can delete it even if\n    // we are not the base image.\n    if( m_poMaskDS )\n    {\n        delete m_poMaskDS;\n        m_poMaskDS = nullptr;\n        bHasDroppedRef = true;\n    }\n\n    if( m_poColorTable != nullptr )\n        delete m_poColorTable;\n    m_poColorTable = nullptr;\n\n    if( m_hTIFF )\n    {\n        XTIFFClose( m_hTIFF );\n        m_hTIFF = nullptr;\n    }\n\n    if ( !m_poBaseDS ) \n    {\n        if( m_fpL != nullptr )\n        {\n            if( m_bWriteKnownIncompatibleEdition )\n            {\n                GByte abyHeader[4096];\n                VSIFSeekL( m_fpL, 0, SEEK_SET );\n                VSIFReadL( abyHeader, 1, sizeof(abyHeader), m_fpL );\n                const char* szKeyToLook = \"KNOWN_INCOMPATIBLE_EDITION=NO\\n \"; // trailing space intended\n                for( size_t i = 0; i < sizeof(abyHeader) - strlen(szKeyToLook); i++ )\n                {\n                    if( memcmp(abyHeader + i, szKeyToLook, strlen(szKeyToLook)) == 0 )\n                    {\n                        const char* szNewKey = \"KNOWN_INCOMPATIBLE_EDITION=YES\\n\";\n                        CPLAssert( strlen(szKeyToLook) == strlen(szNewKey) );\n                        memcpy(abyHeader + i, szNewKey, strlen(szNewKey));\n                        VSIFSeekL( m_fpL, 0, SEEK_SET );\n                        VSIFWriteL( abyHeader, 1, sizeof(abyHeader), m_fpL );\n                        break;\n                    }\n                }\n            }\n            if( VSIFCloseL( m_fpL ) != 0 )\n            {\n                ReportError(CE_Failure, CPLE_FileIO, \"I/O error\");\n            }\n            m_fpL = nullptr;\n        }\n    }\n\n    if( m_fpToWrite != nullptr )\n    {\n        if( VSIFCloseL( m_fpToWrite ) != 0 )\n        {\n            ReportError(CE_Failure, CPLE_FileIO, \"I/O error\");\n        }\n        m_fpToWrite = nullptr;\n    }\n\n    if( m_nGCPCount > 0 )\n    {\n        GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n        CPLFree( m_pasGCPList );\n        m_pasGCPList = nullptr;\n        m_nGCPCount = 0;\n    }\n\n    CSLDestroy( m_papszCreationOptions );\n    m_papszCreationOptions = nullptr;\n\n    CPLFree(m_pabyTempWriteBuffer);\n    m_pabyTempWriteBuffer = nullptr;\n\n    m_bIMDRPCMetadataLoaded = false;\n    CSLDestroy(m_papszMetadataFiles);\n    m_papszMetadataFiles = nullptr;\n\n    VSIFree(m_pTempBufferForCommonDirectIO);\n    m_pTempBufferForCommonDirectIO = nullptr;\n\n    CPLFree(m_panMaskOffsetLsb);\n    m_panMaskOffsetLsb = nullptr;\n\n    CPLFree(m_pszVertUnit);\n    m_pszVertUnit = nullptr;\n\n    CPLFree(m_pszFilename);\n    m_pszFilename = nullptr;\n\n    CPLFree(m_pszGeorefFilename);\n    m_pszGeorefFilename = nullptr;\n\n    m_bIsFinalized = true;\n\n    return bHasDroppedRef;\n}\n\n/************************************************************************/\n/*                        CloseDependentDatasets()                      */\n/************************************************************************/\n\nint GTiffDataset::CloseDependentDatasets()\n{\n    if( m_poBaseDS )\n        return FALSE;\n\n    int bHasDroppedRef = GDALPamDataset::CloseDependentDatasets();\n\n    bHasDroppedRef |= Finalize();\n\n    return bHasDroppedRef;\n}\n\n/************************************************************************/\n/*                        GetJPEGOverviewCount()                        */\n/************************************************************************/\n\nint GTiffDataset::GetJPEGOverviewCount()\n{\n    if( m_nJPEGOverviewCount >= 0 )\n        return m_nJPEGOverviewCount;\n\n    m_nJPEGOverviewCount = 0;\n    if( m_poBaseDS || eAccess != GA_ReadOnly || m_nCompression != COMPRESSION_JPEG ||\n        (nRasterXSize < 256 && nRasterYSize < 256) ||\n        !CPLTestBool(CPLGetConfigOption(\"GTIFF_IMPLICIT_JPEG_OVR\", \"YES\")) ||\n        GDALGetDriverByName(\"JPEG\") == nullptr )\n    {\n        return 0;\n    }\n    const char* pszSourceColorSpace =\n        m_oGTiffMDMD.GetMetadataItem( \"SOURCE_COLOR_SPACE\", \"IMAGE_STRUCTURE\" );\n    if( pszSourceColorSpace != nullptr && EQUAL(pszSourceColorSpace, \"CMYK\") )\n    {\n        // We cannot handle implicit overviews on JPEG CMYK datasets converted\n        // to RGBA This would imply doing the conversion in\n        // GTiffJPEGOverviewBand.\n        return 0;\n    }\n\n    // libjpeg-6b only supports 2, 4 and 8 scale denominators.\n    // TODO: Later versions support more.\n    for( signed char i = 2; i >= 0; i-- )\n    {\n        if( nRasterXSize >= (256 << i) || nRasterYSize >= (256 << i) )\n        {\n            m_nJPEGOverviewCount = i + 1;\n            break;\n        }\n    }\n    if( m_nJPEGOverviewCount == 0 )\n        return 0;\n\n    // Get JPEG tables.\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    GByte abyFFD8[] = { 0xFF, 0xD8 };\n    if( TIFFGetField(m_hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize, &pJPEGTable) )\n    {\n        if( pJPEGTable == nullptr ||\n            nJPEGTableSize > INT_MAX ||\n            static_cast<GByte*>(pJPEGTable)[nJPEGTableSize-1] != 0xD9 )\n        {\n            m_nJPEGOverviewCount = 0;\n            return 0;\n        }\n        nJPEGTableSize--;  // Remove final 0xD9.\n    }\n    else\n    {\n        pJPEGTable = abyFFD8;\n        nJPEGTableSize = 2;\n    }\n\n    m_papoJPEGOverviewDS =\n        static_cast<GTiffJPEGOverviewDS **>(\n            CPLMalloc( sizeof(GTiffJPEGOverviewDS*) * m_nJPEGOverviewCount ) );\n    for( int i = 0; i < m_nJPEGOverviewCount; ++i )\n    {\n        m_papoJPEGOverviewDS[i] =\n            new GTiffJPEGOverviewDS(\n                this, i + 1,\n                pJPEGTable, static_cast<int>(nJPEGTableSize) );\n    }\n\n    m_nJPEGOverviewCountOri = m_nJPEGOverviewCount;\n\n    return m_nJPEGOverviewCount;\n}\n\n/************************************************************************/\n/*                           FillEmptyTiles()                           */\n/************************************************************************/\n\nvoid GTiffDataset::FillEmptyTiles()\n\n{\n/* -------------------------------------------------------------------- */\n/*      How many blocks are there in this file?                         */\n/* -------------------------------------------------------------------- */\n    const int nBlockCount =\n        m_nPlanarConfig == PLANARCONFIG_SEPARATE ?\n        m_nBlocksPerBand * nBands :\n        m_nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Fetch block maps.                                               */\n/* -------------------------------------------------------------------- */\n    toff_t *panByteCounts = nullptr;\n\n    if( TIFFIsTiled( m_hTIFF ) )\n        TIFFGetField( m_hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts );\n    else\n        TIFFGetField( m_hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts );\n\n    if( panByteCounts == nullptr )\n    {\n        // Got here with libtiff 3.9.3 and tiff_write_8 test.\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"FillEmptyTiles() failed because panByteCounts == NULL\" );\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Prepare a blank data buffer to write for uninitialized blocks.  */\n/* -------------------------------------------------------------------- */\n    const GPtrDiff_t nBlockBytes =\n        TIFFIsTiled( m_hTIFF ) ?\n        static_cast<GPtrDiff_t>(TIFFTileSize(m_hTIFF)) :\n        static_cast<GPtrDiff_t>(TIFFStripSize(m_hTIFF));\n\n    GByte *pabyData =\n        static_cast<GByte *>( VSI_CALLOC_VERBOSE(nBlockBytes, 1) );\n    if( pabyData == nullptr )\n    {\n        return;\n    }\n\n    // Force tiles completely filled with the nodata value to be written.\n    m_bWriteEmptyTiles = true;\n\n/* -------------------------------------------------------------------- */\n/*      If set, fill data buffer with no data value.                    */\n/* -------------------------------------------------------------------- */\n    if( m_bNoDataSet && m_dfNoDataValue != 0.0 )\n    {\n        const GDALDataType eDataType = GetRasterBand( 1 )->GetRasterDataType();\n        const int nDataTypeSize = GDALGetDataTypeSizeBytes( eDataType );\n        if( nDataTypeSize &&\n            nDataTypeSize * 8 == static_cast<int>(m_nBitsPerSample) )\n        {\n            GDALCopyWords64( &m_dfNoDataValue, GDT_Float64, 0,\n                           pabyData, eDataType,\n                           nDataTypeSize,\n                           nBlockBytes / nDataTypeSize );\n        }\n        else if( nDataTypeSize )\n        {\n            // Handle non power-of-two depths.\n            // Ideally make a packed buffer, but that is a bit tedious,\n            // so use the normal I/O interfaces.\n\n            CPLFree( pabyData );\n\n            pabyData = static_cast<GByte *>(\n                VSI_MALLOC3_VERBOSE(m_nBlockXSize, m_nBlockYSize, nDataTypeSize) );\n            if( pabyData == nullptr )\n                return;\n            GDALCopyWords64( &m_dfNoDataValue, GDT_Float64, 0,\n                           pabyData, eDataType,\n                           nDataTypeSize,\n                           static_cast<GPtrDiff_t>(m_nBlockXSize) * m_nBlockYSize );\n            const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockYSize);\n            for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n            {\n                if( panByteCounts[iBlock] == 0 )\n                {\n                    if( m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBands == 1 )\n                    {\n                        CPL_IGNORE_RET_VAL( GetRasterBand(\n                            1 + iBlock / m_nBlocksPerBand )->WriteBlock(\n                                (iBlock % m_nBlocksPerBand) % nBlocksPerRow,\n                                (iBlock % m_nBlocksPerBand) / nBlocksPerRow,\n                                pabyData ) );\n                    }\n                    else\n                    {\n                        // In contig case, don't directly call WriteBlock(), as\n                        // it could cause useless decompression-recompression.\n                        const int nXOff =\n                            (iBlock % nBlocksPerRow) * m_nBlockXSize;\n                        const int nYOff =\n                            (iBlock / nBlocksPerRow) * m_nBlockYSize;\n                        const int nXSize =\n                            (nXOff + m_nBlockXSize <= nRasterXSize) ?\n                            m_nBlockXSize : nRasterXSize - nXOff;\n                        const int nYSize =\n                            (nYOff + m_nBlockYSize <= nRasterYSize) ?\n                            m_nBlockYSize : nRasterYSize - nYOff;\n                        for( int iBand = 1; iBand <= nBands; ++iBand )\n                        {\n                            CPL_IGNORE_RET_VAL( GetRasterBand( iBand )->\n                                RasterIO(\n                                    GF_Write, nXOff, nYOff, nXSize, nYSize,\n                                    pabyData, nXSize, nYSize,\n                                    eDataType, 0, 0, nullptr ) );\n                        }\n                    }\n                }\n            }\n            CPLFree( pabyData );\n            return;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      When we must fill with zeroes, try to create non-sparse file    */\n/*      w.r.t TIFF spec ... as a sparse file w.r.t filesystem, ie by    */\n/*      seeking to end of file instead of writing zero blocks.          */\n/* -------------------------------------------------------------------- */\n    else if( m_nCompression == COMPRESSION_NONE && (m_nBitsPerSample % 8) == 0 )\n    {\n        // Only use libtiff to write the first sparse block to ensure that it\n        // will serialize offset and count arrays back to disk.\n        int nCountBlocksToZero = 0;\n        for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n        {\n            if( panByteCounts[iBlock] == 0 )\n            {\n                if( nCountBlocksToZero == 0 )\n                {\n                    const bool bWriteEmptyTilesBak = m_bWriteEmptyTiles;\n                    m_bWriteEmptyTiles = true;\n                    const bool bOK =\n                        WriteEncodedTileOrStrip( iBlock, pabyData,\n                                                 FALSE ) == CE_None;\n                    m_bWriteEmptyTiles = bWriteEmptyTilesBak;\n                    if( !bOK )\n                        break;\n                }\n                nCountBlocksToZero++;\n            }\n        }\n        CPLFree( pabyData );\n\n        --nCountBlocksToZero;\n\n        // And then seek to end of file for other ones.\n        if( nCountBlocksToZero > 0 )\n        {\n            toff_t *panByteOffsets = nullptr;\n\n            if( TIFFIsTiled( m_hTIFF ) )\n                TIFFGetField( m_hTIFF, TIFFTAG_TILEOFFSETS, &panByteOffsets );\n            else\n                TIFFGetField( m_hTIFF, TIFFTAG_STRIPOFFSETS, &panByteOffsets );\n\n            if( panByteOffsets == nullptr )\n            {\n                ReportError(\n                    CE_Failure, CPLE_AppDefined,\n                    \"FillEmptyTiles() failed because panByteOffsets == NULL\");\n                return;\n            }\n\n            VSILFILE* fpTIF = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n            VSIFSeekL( fpTIF, 0, SEEK_END );\n            const vsi_l_offset nOffset = VSIFTellL(fpTIF);\n\n            vsi_l_offset iBlockToZero = 0;\n            for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n            {\n                if( panByteCounts[iBlock] == 0 )\n                {\n                    panByteOffsets[iBlock] = static_cast<toff_t>(\n                                        nOffset + iBlockToZero * nBlockBytes);\n                    panByteCounts[iBlock] = nBlockBytes;\n                    iBlockToZero++;\n                }\n            }\n            CPLAssert( iBlockToZero ==\n                       static_cast<vsi_l_offset>(nCountBlocksToZero) );\n\n            if( VSIFTruncateL( fpTIF,\n                               nOffset + iBlockToZero * nBlockBytes ) != 0 )\n            {\n                ReportError(CE_Failure, CPLE_FileIO,\n                         \"Cannot initialize empty blocks\");\n            }\n        }\n\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check all blocks, writing out data for uninitialized blocks.    */\n/* -------------------------------------------------------------------- */\n\n    GByte* pabyRaw = nullptr;\n    vsi_l_offset nRawSize = 0;\n    for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n    {\n        if( panByteCounts[iBlock] == 0 )\n        {\n            if( pabyRaw == nullptr )\n            {\n                if( WriteEncodedTileOrStrip( iBlock, pabyData, FALSE\n                                                                ) != CE_None )\n                    break;\n\n                vsi_l_offset nOffset = 0;\n                bool b = IsBlockAvailable( iBlock, &nOffset, &nRawSize);\n                CPL_IGNORE_RET_VAL(b);\n                CPLAssert(b);\n\n                // When using compression, get back the compressed block\n                // so we can use the raw API to write it faster.\n                if( m_nCompression != COMPRESSION_NONE )\n                {\n                    pabyRaw = static_cast<GByte*>(\n                            VSI_MALLOC_VERBOSE(static_cast<size_t>(nRawSize)));\n                    if( pabyRaw )\n                    {\n                        VSILFILE* fp = VSI_TIFFGetVSILFile(\n                                                    TIFFClientdata( m_hTIFF ));\n                        const vsi_l_offset nCurOffset = VSIFTellL(fp);\n                        VSIFSeekL(fp, nOffset, SEEK_SET);\n                        VSIFReadL(pabyRaw, 1, static_cast<size_t>(nRawSize), fp);\n                        VSIFSeekL(fp, nCurOffset, SEEK_SET);\n                    }\n                }\n            }\n            else\n            {\n                WriteRawStripOrTile( iBlock, pabyRaw,\n                                     static_cast<GPtrDiff_t>(nRawSize) );\n            }\n        }\n    }\n\n    CPLFree( pabyData );\n    VSIFree( pabyRaw );\n}\n\n/************************************************************************/\n/*                         HasOnlyNoData()                              */\n/************************************************************************/\n\ntemplate<class T>\nstatic inline bool IsEqualToNoData( T value, T noDataValue )\n{\n    return value == noDataValue;\n}\n\ntemplate<> bool IsEqualToNoData<float>( float value, float noDataValue )\n{\n    return\n        CPLIsNan(noDataValue) ?\n        CPL_TO_BOOL(CPLIsNan(value)) : value == noDataValue;\n}\n\ntemplate<> bool IsEqualToNoData<double>( double value, double noDataValue )\n{\n    return\n        CPLIsNan(noDataValue) ?\n        CPL_TO_BOOL(CPLIsNan(value)) : value == noDataValue;\n}\n\ntemplate<class T>\nbool GTiffDataset::HasOnlyNoDataT( const T* pBuffer, int nWidth, int nHeight,\n                                   int nLineStride, int nComponents ) const\n{\n    const T noDataValue = static_cast<T>((m_bNoDataSet) ? m_dfNoDataValue : 0.0);\n\n    CPLAssert(m_nBitsPerSample != 1 || noDataValue == 0);\n\n    // Fast test: check the 4 corners and the middle pixel.\n    for( int iBand = 0; iBand < nComponents; iBand++ )\n    {\n        if( !(IsEqualToNoData(pBuffer[iBand], noDataValue) &&\n              IsEqualToNoData(\n                  pBuffer[static_cast<size_t>(nWidth - 1) * nComponents +\n                          iBand],\n                  noDataValue) &&\n              IsEqualToNoData(\n                  pBuffer[(static_cast<size_t>(nHeight-1)/2 * nLineStride +\n                           (nWidth - 1)/2) * nComponents + iBand],\n                  noDataValue) &&\n              IsEqualToNoData(\n                  pBuffer[static_cast<size_t>(nHeight - 1) * nLineStride *\n                          nComponents + iBand], noDataValue) &&\n              IsEqualToNoData(\n                  pBuffer[(static_cast<size_t>(nHeight - 1) * nLineStride +\n                           nWidth - 1) * nComponents + iBand], noDataValue) ) )\n        {\n            return false;\n        }\n    }\n\n    // Test all pixels.\n    for( int iY = 0; iY < nHeight; iY++ )\n    {\n        for( int iX = 0; iX < nWidth * nComponents; iX++ )\n        {\n            if( !IsEqualToNoData(\n                   pBuffer[iY * static_cast<size_t>(nLineStride) * nComponents +\n                           iX], noDataValue) )\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool GTiffDataset::HasOnlyNoData( const void* pBuffer, int nWidth, int nHeight,\n                                  int nLineStride, int nComponents )\n{\n    const GDALDataType eDT = GetRasterBand(1)->GetRasterDataType();\n\n    // In the case where the nodata is 0, we can compare several bytes at\n    // once. Select the largest natural integer type for the architecture.\n#if SIZEOF_VOIDP == 8 || defined(__x86_64__)\n    // We test __x86_64__ for x32 arch where SIZEOF_VOIDP == 4\n    typedef GUInt64 WordType;\n#else\n    typedef unsigned int WordType;\n#endif\n    if( (!m_bNoDataSet || m_dfNoDataValue == 0.0) && nWidth == nLineStride )\n    {\n        const GByte* pabyBuffer = static_cast<const GByte*>(pBuffer);\n        const size_t nSize = (static_cast<size_t>(nWidth) * nHeight *\n                                nComponents * m_nBitsPerSample + 7) / 8;\n        size_t i = 0;\n        const size_t nInitialIters = std::min(\n            sizeof(WordType) -\n                (reinterpret_cast<std::uintptr_t>(pabyBuffer) % sizeof(WordType)),\n            nSize);\n        for( ; i < nInitialIters; i++ )\n        {\n            if( pabyBuffer[i] )\n                return false;\n        }\n        for( ; i + sizeof(WordType) - 1 < nSize; i += sizeof(WordType) )\n        {\n            if( *(reinterpret_cast<const WordType*>(pabyBuffer + i)) )\n                return false;\n        }\n        for( ; i < nSize; i++ )\n        {\n            if( pabyBuffer[i] )\n                return false;\n        }\n        return true;\n    }\n\n    if( m_nBitsPerSample == 8 )\n    {\n        if( m_nSampleFormat == SAMPLEFORMAT_INT )\n        {\n            return HasOnlyNoDataT(static_cast<const signed char*>(pBuffer),\n                                  nWidth, nHeight, nLineStride, nComponents);\n        }\n        return HasOnlyNoDataT(static_cast<const GByte*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 16 && eDT == GDT_UInt16 )\n    {\n        return HasOnlyNoDataT(static_cast<const GUInt16*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 16 && eDT== GDT_Int16 )\n    {\n        return HasOnlyNoDataT(static_cast<const GInt16*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 32 && eDT == GDT_UInt32 )\n    {\n        return HasOnlyNoDataT(static_cast<const GUInt32*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 32 && eDT == GDT_Int32 )\n    {\n        return HasOnlyNoDataT(static_cast<const GInt32*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 32 && eDT == GDT_Float32 )\n    {\n        return HasOnlyNoDataT(static_cast<const float*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 64 && eDT == GDT_Float64 )\n    {\n        return HasOnlyNoDataT(static_cast<const double*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    return false;\n}\n\n/************************************************************************/\n/*                     IsFirstPixelEqualToNoData()                      */\n/************************************************************************/\n\ninline bool GTiffDataset::IsFirstPixelEqualToNoData( const void* pBuffer )\n{\n    const GDALDataType eDT = GetRasterBand(1)->GetRasterDataType();\n    const double dfEffectiveNoData = (m_bNoDataSet) ? m_dfNoDataValue : 0.0;\n    if( m_nBitsPerSample == 8 || (m_nBitsPerSample < 8 && dfEffectiveNoData == 0) )\n    {\n        if( m_nSampleFormat == SAMPLEFORMAT_INT )\n        {\n            return GDALIsValueInRange<signed char>(dfEffectiveNoData) &&\n                   *(static_cast<const signed char*>(pBuffer)) ==\n                        static_cast<signed char>(dfEffectiveNoData);\n        }\n        return GDALIsValueInRange<GByte>(dfEffectiveNoData) &&\n               *(static_cast<const GByte*>(pBuffer)) ==\n                        static_cast<GByte>(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 16 && eDT == GDT_UInt16 )\n    {\n        return GDALIsValueInRange<GUInt16>(dfEffectiveNoData) &&\n               *(static_cast<const GUInt16*>(pBuffer)) ==\n                        static_cast<GUInt16>(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 16 && eDT == GDT_Int16 )\n    {\n        return GDALIsValueInRange<GInt16>(dfEffectiveNoData) &&\n               *(static_cast<const GInt16*>(pBuffer)) ==\n                        static_cast<GInt16>(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 32 && eDT == GDT_UInt32 )\n    {\n        return GDALIsValueInRange<GUInt32>(dfEffectiveNoData) &&\n               *(static_cast<const GUInt32*>(pBuffer)) ==\n                        static_cast<GUInt32>(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 32 && eDT == GDT_Int32 )\n    {\n        return GDALIsValueInRange<GInt32>(dfEffectiveNoData) &&\n               *(static_cast<const GInt32*>(pBuffer)) ==\n                        static_cast<GInt32>(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 32 && eDT == GDT_Float32 )\n    {\n        if( CPLIsNan(m_dfNoDataValue) )\n            return CPL_TO_BOOL(\n                CPLIsNan(*(static_cast<const float*>(pBuffer))));\n        return GDALIsValueInRange<float>(dfEffectiveNoData) &&\n               *(static_cast<const float*>(pBuffer)) ==\n                        static_cast<float>(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 64 && eDT == GDT_Float64 )\n    {\n        if( CPLIsNan(dfEffectiveNoData) )\n            return CPL_TO_BOOL(\n                CPLIsNan(*(static_cast<const double*>(pBuffer))));\n        return *(static_cast<const double*>(pBuffer)) == dfEffectiveNoData;\n    }\n    return false;\n}\n\n/************************************************************************/\n/*                        WriteEncodedTile()                            */\n/************************************************************************/\n\nbool GTiffDataset::WriteEncodedTile( uint32 tile, GByte *pabyData,\n                                     int bPreserveDataBuffer )\n{\n    int iRow = 0;\n    int iColumn = 0;\n    int nBlocksPerRow = 1;\n    int nBlocksPerColumn = 1;\n\n/* -------------------------------------------------------------------- */\n/*      Don't write empty blocks in some cases.                         */\n/* -------------------------------------------------------------------- */\n    if( !m_bWriteEmptyTiles && IsFirstPixelEqualToNoData(pabyData) )\n    {\n        if( !IsBlockAvailable(tile) )\n        {\n            const int nComponents =\n                m_nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n            nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n            nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, m_nBlockYSize);\n\n            iColumn = (tile % m_nBlocksPerBand) % nBlocksPerRow;\n            iRow = (tile % m_nBlocksPerBand) / nBlocksPerRow;\n\n            const int nActualBlockWidth =\n                ( iColumn == nBlocksPerRow - 1 ) ?\n                nRasterXSize - iColumn * m_nBlockXSize : m_nBlockXSize;\n            const int nActualBlockHeight =\n                ( iRow == nBlocksPerColumn - 1 ) ?\n                nRasterYSize - iRow * m_nBlockYSize : m_nBlockYSize;\n\n            if( HasOnlyNoData(pabyData,\n                              nActualBlockWidth, nActualBlockHeight,\n                              m_nBlockXSize, nComponents ) )\n            {\n                return true;\n            }\n        }\n    }\n\n    // Do we need to spread edge values right or down for a partial\n    // JPEG encoded tile?  We do this to avoid edge artifacts.\n    bool bNeedTileFill = false;\n    if( m_nCompression == COMPRESSION_JPEG )\n    {\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n        nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, m_nBlockYSize);\n\n        iColumn = (tile % m_nBlocksPerBand) % nBlocksPerRow;\n        iRow = (tile % m_nBlocksPerBand) / nBlocksPerRow;\n\n        // Is this a partial right edge tile?\n        if( iRow == nBlocksPerRow - 1\n            && nRasterXSize % m_nBlockXSize != 0 )\n            bNeedTileFill = true;\n\n        // Is this a partial bottom edge tile?\n        if( iColumn == nBlocksPerColumn - 1\n            && nRasterYSize % m_nBlockYSize != 0 )\n            bNeedTileFill = true;\n    }\n\n    // If we need to fill out the tile, or if we want to prevent\n    // TIFFWriteEncodedTile from altering the buffer as part of\n    // byte swapping the data on write then we will need a temporary\n    // working buffer.  If not, we can just do a direct write.\n    const GPtrDiff_t cc = static_cast<GPtrDiff_t>(TIFFTileSize( m_hTIFF ));\n\n    if( bPreserveDataBuffer\n        && (TIFFIsByteSwapped(m_hTIFF) || bNeedTileFill || m_panMaskOffsetLsb) )\n    {\n        if( m_pabyTempWriteBuffer == nullptr )\n        {\n            m_pabyTempWriteBuffer = CPLMalloc(cc);\n        }\n        memcpy(m_pabyTempWriteBuffer, pabyData, cc);\n\n        pabyData = static_cast<GByte *>( m_pabyTempWriteBuffer );\n    }\n\n    // Perform tile fill if needed.\n    // TODO: we should also handle the case of nBitsPerSample == 12\n    // but this is more involved.\n    if( bNeedTileFill && m_nBitsPerSample == 8 )\n    {\n        const int nComponents =\n            m_nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n\n        CPLDebug( \"GTiff\", \"Filling out jpeg edge tile on write.\" );\n\n        const int nRightPixelsToFill =\n            iColumn == nBlocksPerRow - 1 ?\n            m_nBlockXSize * (iColumn + 1) - nRasterXSize :\n            0;\n        const int nBottomPixelsToFill =\n            iRow == nBlocksPerColumn - 1 ?\n            m_nBlockYSize * (iRow + 1) - nRasterYSize :\n            0;\n\n        // Fill out to the right.\n        const int iSrcX = m_nBlockXSize - nRightPixelsToFill - 1;\n\n        for( int iX = iSrcX + 1; iX < m_nBlockXSize; ++iX )\n        {\n            for( int iY = 0; iY < m_nBlockYSize; ++iY )\n            {\n                memcpy( pabyData + (static_cast<GPtrDiff_t>(m_nBlockXSize) * iY + iX) * nComponents,\n                        pabyData + (static_cast<GPtrDiff_t>(m_nBlockXSize) * iY + iSrcX) * nComponents,\n                        nComponents );\n            }\n        }\n\n        // Now fill out the bottom.\n        const int iSrcY = m_nBlockYSize - nBottomPixelsToFill - 1;\n        for( int iY = iSrcY + 1; iY < m_nBlockYSize; ++iY )\n        {\n            memcpy( pabyData + static_cast<GPtrDiff_t>(m_nBlockXSize) * nComponents * iY,\n                    pabyData + static_cast<GPtrDiff_t>(m_nBlockXSize) * nComponents * iSrcY,\n                    static_cast<GPtrDiff_t>(m_nBlockXSize) * nComponents );\n        }\n    }\n\n    if( m_panMaskOffsetLsb )\n    {\n        const int iBand =\n            m_nPlanarConfig == PLANARCONFIG_SEPARATE ?\n            static_cast<int>(tile) / m_nBlocksPerBand : -1;\n        DiscardLsb(pabyData, cc, iBand);\n    }\n\n    if( m_bStreamingOut )\n    {\n        if( tile != static_cast<uint32>(m_nLastWrittenBlockId + 1) )\n        {\n            ReportError(CE_Failure, CPLE_NotSupported,\n                     \"Attempt to write block %d whereas %d was expected\",\n                     tile, m_nLastWrittenBlockId + 1);\n            return false;\n        }\n        if( static_cast<GPtrDiff_t>( VSIFWriteL(pabyData, 1, cc, m_fpToWrite) ) != cc )\n        {\n            ReportError( CE_Failure, CPLE_FileIO, \"Could not write \" CPL_FRMT_GUIB \" bytes\",\n                      static_cast<GUIntBig>(cc) );\n            return false;\n        }\n        m_nLastWrittenBlockId = tile;\n        return true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    if( SubmitCompressionJob(tile, pabyData, cc, m_nBlockYSize) )\n        return true;\n\n    // libtiff 4.0.6 or older do not always properly report write errors.\n#if TIFFLIB_VERSION <= 20150912\n    const CPLErr eBefore = CPLGetLastErrorType();\n#endif\n    const bool bRet =\n        TIFFWriteEncodedTile(m_hTIFF, tile, pabyData, cc) == cc;\n#if TIFFLIB_VERSION <= 20150912\n    if( eBefore == CE_None && CPLGetLastErrorType() == CE_Failure )\n        return false;\n#endif\n    return bRet;\n}\n\n/************************************************************************/\n/*                        WriteEncodedStrip()                           */\n/************************************************************************/\n\nbool GTiffDataset::WriteEncodedStrip( uint32 strip, GByte* pabyData,\n                                      int bPreserveDataBuffer )\n{\n    GPtrDiff_t cc = static_cast<GPtrDiff_t>(TIFFStripSize( m_hTIFF ));\n    const auto ccFull = cc;\n\n/* -------------------------------------------------------------------- */\n/*      If this is the last strip in the image, and is partial, then    */\n/*      we need to trim the number of scanlines written to the          */\n/*      amount of valid data we have. (#2748)                           */\n/* -------------------------------------------------------------------- */\n    const int nStripWithinBand = strip % m_nBlocksPerBand;\n    int nStripHeight = m_nRowsPerStrip;\n\n    if( nStripWithinBand * nStripHeight > GetRasterYSize() - nStripHeight )\n    {\n        nStripHeight = GetRasterYSize() - nStripWithinBand * m_nRowsPerStrip;\n        cc = (cc / m_nRowsPerStrip) * nStripHeight;\n        CPLDebug( \"GTiff\", \"Adjusted bytes to write from \" CPL_FRMT_GUIB \" to \" CPL_FRMT_GUIB \".\",\n                  static_cast<GUIntBig>(TIFFStripSize(m_hTIFF)),\n                  static_cast<GUIntBig>(cc) );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Don't write empty blocks in some cases.                         */\n/* -------------------------------------------------------------------- */\n    if( !m_bWriteEmptyTiles && IsFirstPixelEqualToNoData(pabyData) )\n    {\n        if( !IsBlockAvailable(strip) )\n        {\n            const int nComponents =\n                m_nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n\n            if( HasOnlyNoData(pabyData,\n                              m_nBlockXSize, nStripHeight,\n                              m_nBlockXSize, nComponents ) )\n            {\n                return true;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      TIFFWriteEncodedStrip can alter the passed buffer if            */\n/*      byte-swapping is necessary so we use a temporary buffer         */\n/*      before calling it.                                              */\n/* -------------------------------------------------------------------- */\n    if( bPreserveDataBuffer && (TIFFIsByteSwapped(m_hTIFF) || m_panMaskOffsetLsb) )\n    {\n        if( m_pabyTempWriteBuffer == nullptr )\n        {\n            m_pabyTempWriteBuffer = CPLMalloc(ccFull);\n        }\n        memcpy(m_pabyTempWriteBuffer, pabyData, cc);\n        pabyData = static_cast<GByte *>( m_pabyTempWriteBuffer );\n    }\n\n    if( m_panMaskOffsetLsb )\n    {\n        int iBand =\n            m_nPlanarConfig == PLANARCONFIG_SEPARATE ?\n            static_cast<int>(strip) / m_nBlocksPerBand : -1;\n        DiscardLsb(pabyData, cc, iBand);\n    }\n\n    if( m_bStreamingOut )\n    {\n        if( strip != static_cast<uint32>(m_nLastWrittenBlockId + 1) )\n        {\n            ReportError(CE_Failure, CPLE_NotSupported,\n                     \"Attempt to write block %d whereas %d was expected\",\n                     strip, m_nLastWrittenBlockId + 1);\n            return false;\n        }\n        if( static_cast<GPtrDiff_t>(VSIFWriteL(pabyData, 1, cc, m_fpToWrite)) != cc )\n        {\n            ReportError(CE_Failure, CPLE_FileIO, \"Could not write \" CPL_FRMT_GUIB \" bytes\",\n                     static_cast<GUIntBig>(cc));\n            return false;\n        }\n        m_nLastWrittenBlockId = strip;\n        return true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    if( SubmitCompressionJob(strip, pabyData, cc, nStripHeight) )\n        return true;\n\n    // libtiff 4.0.6 or older do not always properly report write errors.\n#if TIFFLIB_VERSION <= 20150912\n    CPLErr eBefore = CPLGetLastErrorType();\n#endif\n    bool bRet = TIFFWriteEncodedStrip( m_hTIFF, strip, pabyData, cc) == cc;\n#if TIFFLIB_VERSION <= 20150912\n    if( eBefore == CE_None && CPLGetLastErrorType() == CE_Failure )\n        bRet = FALSE;\n#endif\n    return bRet;\n}\n\n/************************************************************************/\n/*                        InitCompressionThreads()                      */\n/************************************************************************/\n\nvoid GTiffDataset::InitCompressionThreads( char** papszOptions )\n{\n    // Raster == tile, then no need for threads\n    if( m_nBlockXSize == nRasterXSize && m_nBlockYSize == nRasterYSize )\n        return;\n\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"NUM_THREADS\" );\n    if( pszValue == nullptr )\n        pszValue = CPLGetConfigOption(\"GDAL_NUM_THREADS\", nullptr);\n    if( pszValue )\n    {\n        const int nThreads =\n            EQUAL(pszValue, \"ALL_CPUS\") ? CPLGetNumCPUs() : atoi(pszValue);\n        if( nThreads > 1 )\n        {\n            if( m_nCompression == COMPRESSION_NONE )\n            {\n                CPLDebug( \"GTiff\",\n                          \"NUM_THREADS ignored with uncompressed\" );\n            }\n            else\n            {\n                CPLDebug(\"GTiff\", \"Using %d threads for compression\", nThreads);\n\n                auto poThreadPool = GDALGetGlobalThreadPool(nThreads);\n                if( poThreadPool )\n                    m_poCompressQueue = poThreadPool->CreateJobQueue();\n\n                if( m_poCompressQueue != nullptr )\n                {\n                    // Add a margin of an extra job w.r.t thread number\n                    // so as to optimize compression time (enables the main\n                    // thread to do boring I/O while all CPUs are working).\n                    m_asCompressionJobs.resize(nThreads + 1);\n                    memset(&m_asCompressionJobs[0], 0,\n                           m_asCompressionJobs.size() *\n                           sizeof(GTiffCompressionJob));\n                    for( int i = 0;\n                         i < static_cast<int>(m_asCompressionJobs.size());\n                         ++i )\n                    {\n                        m_asCompressionJobs[i].pszTmpFilename =\n                            CPLStrdup(CPLSPrintf(\"/vsimem/gtiff/thread/job/%p\",\n                                                 &m_asCompressionJobs[i]));\n                        m_asCompressionJobs[i].nStripOrTile = -1;\n                    }\n                    m_hCompressThreadPoolMutex = CPLCreateMutex();\n                    CPLReleaseMutex(m_hCompressThreadPoolMutex);\n\n                    // This is kind of a hack, but basically using\n                    // TIFFWriteRawStrip/Tile and then TIFFReadEncodedStrip/Tile\n                    // does not work on a newly created file, because\n                    // TIFF_MYBUFFER is not set in tif_flags\n                    // (if using TIFFWriteEncodedStrip/Tile first,\n                    // TIFFWriteBufferSetup() is automatically called).\n                    // This should likely rather fixed in libtiff itself.\n                    CPL_IGNORE_RET_VAL(\n                        TIFFWriteBufferSetup(m_hTIFF, nullptr, -1));\n                }\n            }\n        }\n        else if( nThreads < 0 ||\n                 (!EQUAL(pszValue, \"0\") &&\n                  !EQUAL(pszValue, \"1\") &&\n                  !EQUAL(pszValue, \"ALL_CPUS\")) )\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                     \"Invalid value for NUM_THREADS: %s\", pszValue);\n        }\n    }\n}\n\n/************************************************************************/\n/*                       GetGTIFFKeysFlavor()                           */\n/************************************************************************/\n\nstatic GTIFFKeysFlavorEnum GetGTIFFKeysFlavor( char** papszOptions )\n{\n    const char* pszGeoTIFFKeysFlavor =\n        CSLFetchNameValueDef( papszOptions, \"GEOTIFF_KEYS_FLAVOR\", \"STANDARD\" );\n    if( EQUAL(pszGeoTIFFKeysFlavor, \"ESRI_PE\") )\n        return GEOTIFF_KEYS_ESRI_PE;\n    return GEOTIFF_KEYS_STANDARD;\n}\n\n/************************************************************************/\n/*                       GetGeoTIFFVersion()                            */\n/************************************************************************/\n\nstatic GeoTIFFVersionEnum GetGeoTIFFVersion( char** papszOptions )\n{\n    const char* pszVersion =\n        CSLFetchNameValueDef( papszOptions, \"GEOTIFF_VERSION\", \"AUTO\" );\n    if( EQUAL(pszVersion, \"1.0\") )\n        return GEOTIFF_VERSION_1_0;\n    if( EQUAL(pszVersion, \"1.1\") )\n        return GEOTIFF_VERSION_1_1;\n    return GEOTIFF_VERSION_AUTO;\n}\n\n/************************************************************************/\n/*                      InitCreationOrOpenOptions()                     */\n/************************************************************************/\n\nvoid GTiffDataset::InitCreationOrOpenOptions( char** papszOptions )\n{\n    InitCompressionThreads(papszOptions);\n\n    m_eGeoTIFFKeysFlavor = GetGTIFFKeysFlavor(papszOptions);\n    m_eGeoTIFFVersion = GetGeoTIFFVersion(papszOptions);\n}\n\n/************************************************************************/\n/*                      ThreadCompressionFunc()                         */\n/************************************************************************/\n\nvoid GTiffDataset::ThreadCompressionFunc( void* pData )\n{\n    GTiffCompressionJob* psJob = static_cast<GTiffCompressionJob *>(pData);\n    GTiffDataset* poDS = psJob->poDS;\n\n    VSILFILE* fpTmp = VSIFOpenL(psJob->pszTmpFilename, \"wb+\");\n    TIFF* hTIFFTmp = VSI_TIFFOpen(psJob->pszTmpFilename,\n        psJob->bTIFFIsBigEndian ? \"wb+\" : \"wl+\", fpTmp);\n    CPLAssert( hTIFFTmp != nullptr );\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGEWIDTH, poDS->m_nBlockXSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGELENGTH, psJob->nHeight);\n    TIFFSetField(hTIFFTmp, TIFFTAG_BITSPERSAMPLE, poDS->m_nBitsPerSample);\n    TIFFSetField(hTIFFTmp, TIFFTAG_COMPRESSION, poDS->m_nCompression);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, poDS->m_nPhotometric);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLEFORMAT, poDS->m_nSampleFormat);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLESPERPIXEL, poDS->m_nSamplesPerPixel);\n    TIFFSetField(hTIFFTmp, TIFFTAG_ROWSPERSTRIP, poDS->m_nBlockYSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PLANARCONFIG, poDS->m_nPlanarConfig);\n    if( psJob->nPredictor != PREDICTOR_NONE )\n        TIFFSetField(hTIFFTmp, TIFFTAG_PREDICTOR, psJob->nPredictor);\n#if HAVE_LERC\n    if( poDS->m_nCompression == COMPRESSION_LERC )\n    {\n        TIFFSetField(hTIFFTmp, TIFFTAG_LERC_PARAMETERS, 2,\n                    poDS->m_anLercAddCompressionAndVersion);\n    }\n#endif\n\n    TIFFSetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, poDS->m_nPhotometric);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLEFORMAT, poDS->m_nSampleFormat);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLESPERPIXEL, poDS->m_nSamplesPerPixel);\n    TIFFSetField(hTIFFTmp, TIFFTAG_ROWSPERSTRIP, poDS->m_nBlockYSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PLANARCONFIG, poDS->m_nPlanarConfig);\n\n    poDS->RestoreVolatileParameters(hTIFFTmp);\n\n    bool bOK =\n        TIFFWriteEncodedStrip(hTIFFTmp, 0, psJob->pabyBuffer,\n                              psJob->nBufferSize) == psJob->nBufferSize;\n\n    toff_t nOffset = 0;\n    if( bOK )\n    {\n        toff_t* panOffsets = nullptr;\n        toff_t* panByteCounts = nullptr;\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPOFFSETS, &panOffsets);\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts);\n\n        nOffset = panOffsets[0];\n        psJob->nCompressedBufferSize = static_cast<GPtrDiff_t>(panByteCounts[0]);\n    }\n    else\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Error when compressing strip/tile %d\",\n                  psJob->nStripOrTile);\n    }\n\n    XTIFFClose(hTIFFTmp);\n    if( VSIFCloseL(fpTmp) != 0 )\n    {\n        if( bOK )\n        {\n            bOK = false;\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"Error when compressing strip/tile %d\",\n                      psJob->nStripOrTile);\n        }\n    }\n\n    if( bOK )\n    {\n        vsi_l_offset nFileSize = 0;\n        GByte* pabyCompressedBuffer = VSIGetMemFileBuffer(psJob->pszTmpFilename,\n                                                          &nFileSize,\n                                                          FALSE);\n        CPLAssert( static_cast<vsi_l_offset>(nOffset + psJob->nCompressedBufferSize) <= nFileSize );\n        psJob->pabyCompressedBuffer = pabyCompressedBuffer + nOffset;\n    }\n    else\n    {\n        psJob->pabyCompressedBuffer = nullptr;\n        psJob->nCompressedBufferSize = 0;\n    }\n\n    auto mutex = poDS->m_poBaseDS ?\n        poDS->m_poBaseDS->m_hCompressThreadPoolMutex : poDS->m_hCompressThreadPoolMutex;\n    if( mutex )\n    {\n        CPLAcquireMutex(mutex, 1000.0);\n        psJob->bReady = true;\n        CPLReleaseMutex(mutex);\n    }\n}\n\n/************************************************************************/\n/*                        WriteRawStripOrTile()                         */\n/************************************************************************/\n\nvoid GTiffDataset::WriteRawStripOrTile( int nStripOrTile,\n                                        GByte* pabyCompressedBuffer,\n                                        GPtrDiff_t nCompressedBufferSize )\n{\n#ifdef DEBUG_VERBOSE\n    CPLDebug(\"GTIFF\", \"Writing raw strip/tile %d, size \" CPL_FRMT_GUIB,\n             nStripOrTile, static_cast<GUIntBig>(nCompressedBufferSize));\n#endif\n    toff_t *panOffsets = nullptr;\n    toff_t* panByteCounts = nullptr;\n    bool bWriteAtEnd = true;\n    bool bWriteLeader = m_bLeaderSizeAsUInt4;\n    bool bWriteTrailer = m_bTrailerRepeatedLast4BytesRepeated;\n    if( TIFFGetField(\n            m_hTIFF,\n            TIFFIsTiled( m_hTIFF ) ?\n            TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS, &panOffsets ) &&\n            panOffsets != nullptr &&\n            panOffsets[nStripOrTile] != 0 )\n    {\n        // Forces TIFFAppendStrip() to consider if the location of the tile/strip\n        // can be reused or if the strile should be written at end of file.\n        TIFFSetWriteOffset(m_hTIFF, 0);\n\n        if( m_bBlockOrderRowMajor )\n        {\n            if( TIFFGetField(\n                m_hTIFF,\n                TIFFIsTiled( m_hTIFF ) ?\n                TIFFTAG_TILEBYTECOUNTS : TIFFTAG_STRIPBYTECOUNTS, &panByteCounts ) &&\n                panByteCounts != nullptr )\n            {\n                if( static_cast<GUIntBig>(nCompressedBufferSize) >\n                        panByteCounts[nStripOrTile] )\n                {\n                    GTiffDataset* poRootDS = m_poBaseDS ? m_poBaseDS : this;\n                    if( !poRootDS->m_bKnownIncompatibleEdition &&\n                        !poRootDS->m_bWriteKnownIncompatibleEdition )\n                    {\n                        ReportError(CE_Warning, CPLE_AppDefined,\n                            \"A strile cannot be rewritten in place, which \"\n                            \"invalidates the BLOCK_ORDER optimization.\");\n                        poRootDS->m_bKnownIncompatibleEdition = true;\n                        poRootDS->m_bWriteKnownIncompatibleEdition = true;\n                    }\n                }\n                // For mask interleaving, if the size is not exactly the same,\n                // completely give up (we could potentially move the mask in\n                // case the imagery is smaller)\n                else if( m_poMaskDS && m_bMaskInterleavedWithImagery &&\n                         static_cast<GUIntBig>(nCompressedBufferSize) !=\n                            panByteCounts[nStripOrTile] )\n                {\n                    GTiffDataset* poRootDS = m_poBaseDS ? m_poBaseDS : this;\n                    if( !poRootDS->m_bKnownIncompatibleEdition &&\n                        !poRootDS->m_bWriteKnownIncompatibleEdition )\n                    {\n                        ReportError(CE_Warning, CPLE_AppDefined,\n                            \"A strile cannot be rewritten in place, which \"\n                            \"invalidates the MASK_INTERLEAVED_WITH_IMAGERY \"\n                            \"optimization.\");\n                        poRootDS->m_bKnownIncompatibleEdition = true;\n                        poRootDS->m_bWriteKnownIncompatibleEdition = true;\n                    }\n                    bWriteLeader = false;\n                    bWriteTrailer = false;\n                    if( m_bLeaderSizeAsUInt4 )\n                    {\n                        // If there was a valid leader, invalidat it\n                        VSI_TIFFSeek( m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET );\n                        uint32 nOldSize;\n                        VSIFReadL(&nOldSize, 1, 4, VSI_TIFFGetVSILFile(TIFFClientdata(m_hTIFF)));\n                        CPL_LSBPTR32(&nOldSize);\n                        if( nOldSize == panByteCounts[nStripOrTile] )\n                        {\n                            uint32 nInvalidatedSize = 0;\n                            VSI_TIFFSeek( m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET );\n                            VSI_TIFFWrite(m_hTIFF, &nInvalidatedSize, sizeof(nInvalidatedSize));\n                        }\n                    }\n                }\n                else\n                {\n                    bWriteAtEnd = false;\n                }\n            }\n        }\n    }\n    if( bWriteLeader &&\n        static_cast<GUIntBig>(nCompressedBufferSize) <= 0xFFFFFFFFU )\n    {\n        // cppcheck-suppress knownConditionTrueFalse\n        if( bWriteAtEnd )\n        {\n            VSI_TIFFSeek( m_hTIFF, 0, SEEK_END );\n        }\n        else\n        {\n            // If we rewrite an existing strile in place with an existing leader,\n            // check that the leader is valid, before rewriting it.\n            // And if it is not valid, then do not write the trailer, as we\n            // could corrupt other data.\n            VSI_TIFFSeek( m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET );\n            uint32 nOldSize;\n            VSIFReadL(&nOldSize, 1, 4, VSI_TIFFGetVSILFile(TIFFClientdata(m_hTIFF)));\n            CPL_LSBPTR32(&nOldSize);\n            bWriteLeader = panByteCounts && nOldSize == panByteCounts[nStripOrTile];\n            bWriteTrailer = bWriteLeader;\n            VSI_TIFFSeek( m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET );\n        }\n        // cppcheck-suppress knownConditionTrueFalse\n        if( bWriteLeader )\n        {\n            uint32 nSize = static_cast<uint32>(nCompressedBufferSize);\n            CPL_LSBPTR32(&nSize);\n            if( !VSI_TIFFWrite(m_hTIFF, &nSize, sizeof(nSize)) )\n                m_bWriteError = true;\n        }\n    }\n    tmsize_t written;\n    if( TIFFIsTiled( m_hTIFF ) )\n        written = TIFFWriteRawTile( m_hTIFF, nStripOrTile, pabyCompressedBuffer,\n                          nCompressedBufferSize );\n    else\n        written = TIFFWriteRawStrip( m_hTIFF, nStripOrTile, pabyCompressedBuffer,\n                           nCompressedBufferSize );\n    if( written != nCompressedBufferSize )\n        m_bWriteError = true;\n    if( bWriteTrailer &&\n        static_cast<GUIntBig>(nCompressedBufferSize) <= 0xFFFFFFFFU )\n    {\n        GByte abyLastBytes[4] = {};\n        if( nCompressedBufferSize >= 4 )\n            memcpy(abyLastBytes, pabyCompressedBuffer + nCompressedBufferSize - 4, 4);\n        else\n            memcpy(abyLastBytes, pabyCompressedBuffer, nCompressedBufferSize);\n        if( !VSI_TIFFWrite(m_hTIFF, abyLastBytes, 4) )\n            m_bWriteError = true;\n    }\n}\n\n/************************************************************************/\n/*                        WaitCompletionForJobIdx()                     */\n/************************************************************************/\n\nvoid GTiffDataset::WaitCompletionForJobIdx(int i)\n{\n    auto poQueue = m_poBaseDS ?\n        m_poBaseDS->m_poCompressQueue.get() : m_poCompressQueue.get();\n    auto& oQueue = m_poBaseDS ? m_poBaseDS->m_asQueueJobIdx : m_asQueueJobIdx;\n    auto& asJobs = m_poBaseDS ? m_poBaseDS->m_asCompressionJobs : m_asCompressionJobs;\n    auto mutex = m_poBaseDS ? m_poBaseDS->m_hCompressThreadPoolMutex : m_hCompressThreadPoolMutex;\n\n    CPLAssert( i >= 0 && static_cast<size_t>(i) < asJobs.size() );\n    CPLAssert( asJobs[i].nStripOrTile >= 0 );\n    CPLAssert( !oQueue.empty() );\n\n    bool bHasWarned = false;\n    while( true )\n    {\n        CPLAcquireMutex(mutex, 1000.0);\n        const bool bReady = asJobs[i].bReady;\n        CPLReleaseMutex(mutex);\n        if( !bReady )\n        {\n            if( !bHasWarned )\n            {\n                CPLDebug(\"GTIFF\",\n                        \"Waiting for worker job to finish handling block %d\",\n                        asJobs[i].nStripOrTile);\n                bHasWarned = true;\n            }\n            poQueue->GetPool()->WaitEvent();\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    if( asJobs[i].nCompressedBufferSize )\n    {\n        asJobs[i].poDS->WriteRawStripOrTile(asJobs[i].nStripOrTile,\n                        asJobs[i].pabyCompressedBuffer,\n                        asJobs[i].nCompressedBufferSize);\n    }\n    asJobs[i].pabyCompressedBuffer = nullptr;\n    asJobs[i].nBufferSize = 0;\n    asJobs[i].bReady = false;\n    asJobs[i].nStripOrTile = -1;\n    oQueue.pop();\n}\n\n/************************************************************************/\n/*                        WaitCompletionForBlock()                      */\n/************************************************************************/\n\nvoid GTiffDataset::WaitCompletionForBlock(int nBlockId)\n{\n    auto poQueue = m_poBaseDS ?\n        m_poBaseDS->m_poCompressQueue.get() : m_poCompressQueue.get();\n    auto& oQueue = m_poBaseDS ? m_poBaseDS->m_asQueueJobIdx : m_asQueueJobIdx;\n    auto& asJobs = m_poBaseDS ? m_poBaseDS->m_asCompressionJobs : m_asCompressionJobs;\n\n    if( poQueue != nullptr )\n    {\n        for( int i = 0; i < static_cast<int>(asJobs.size()); ++i )\n        {\n            if( asJobs[i].poDS == this && asJobs[i].nStripOrTile == nBlockId )\n            {\n                while( !oQueue.empty() &&\n                       !(asJobs[oQueue.front()].poDS == this &&\n                         asJobs[oQueue.front()].nStripOrTile == nBlockId) )\n                {\n                    WaitCompletionForJobIdx(oQueue.front());\n                }\n                CPLAssert( !oQueue.empty() &&\n                          asJobs[oQueue.front()].poDS == this &&\n                          asJobs[oQueue.front()].nStripOrTile == nBlockId );\n                WaitCompletionForJobIdx(oQueue.front());\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                      SubmitCompressionJob()                          */\n/************************************************************************/\n\nbool GTiffDataset::SubmitCompressionJob( int nStripOrTile, GByte* pabyData,\n                                         GPtrDiff_t cc, int nHeight )\n{\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    auto poQueue = m_poBaseDS ?\n        m_poBaseDS->m_poCompressQueue.get() : m_poCompressQueue.get();\n\n    if( poQueue == nullptr ||\n          !(m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n            m_nCompression == COMPRESSION_LZW ||\n            m_nCompression == COMPRESSION_PACKBITS ||\n            m_nCompression == COMPRESSION_LZMA ||\n            m_nCompression == COMPRESSION_ZSTD ||\n            m_nCompression == COMPRESSION_LERC ||\n            m_nCompression == COMPRESSION_WEBP ||\n            m_nCompression == COMPRESSION_JPEG) )\n    {\n        if( m_bBlockOrderRowMajor || m_bLeaderSizeAsUInt4 ||\n            m_bTrailerRepeatedLast4BytesRepeated )\n        {\n            GTiffCompressionJob sJob;\n            memset(&sJob, 0, sizeof(sJob));\n            sJob.poDS = this;\n            sJob.pszTmpFilename = CPLStrdup(CPLSPrintf(\"/vsimem/gtiff/%p\", this));\n            sJob.bTIFFIsBigEndian = CPL_TO_BOOL( TIFFIsBigEndian(m_hTIFF) );\n            sJob.pabyBuffer =\n                static_cast<GByte*>( CPLRealloc(sJob.pabyBuffer, cc) );\n            memcpy(sJob.pabyBuffer, pabyData, cc);\n            sJob.nBufferSize = cc;\n            sJob.nHeight = nHeight;\n            sJob.nStripOrTile = nStripOrTile;\n            sJob.nPredictor = PREDICTOR_NONE;\n            if( m_nCompression == COMPRESSION_LZW ||\n                m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n                m_nCompression == COMPRESSION_ZSTD )\n            {\n                TIFFGetField( m_hTIFF, TIFFTAG_PREDICTOR, &sJob.nPredictor );\n            }\n\n            ThreadCompressionFunc(&sJob);\n\n            if( sJob.nCompressedBufferSize )\n            {\n                sJob.poDS->\n                    WriteRawStripOrTile(sJob.nStripOrTile,\n                                sJob.pabyCompressedBuffer,\n                                sJob.nCompressedBufferSize);\n            }\n\n            CPLFree(sJob.pabyBuffer);\n            VSIUnlink(sJob.pszTmpFilename);\n            CPLFree(sJob.pszTmpFilename);\n            return sJob.nCompressedBufferSize > 0 && !m_bWriteError;\n        }\n\n        return false;\n    }\n\n    auto& oQueue = m_poBaseDS ? m_poBaseDS->m_asQueueJobIdx : m_asQueueJobIdx;\n    auto& asJobs = m_poBaseDS ? m_poBaseDS->m_asCompressionJobs : m_asCompressionJobs;\n\n    int nNextCompressionJobAvail = -1;\n\n    if( oQueue.size() == asJobs.size() )\n    {\n        CPLAssert( !oQueue.empty() );\n        nNextCompressionJobAvail = oQueue.front();\n        WaitCompletionForJobIdx(nNextCompressionJobAvail);\n    }\n    else\n    {\n        const int nJobs = static_cast<int>(asJobs.size());\n        for( int i = 0; i < nJobs; ++i )\n        {\n            if( asJobs[i].nBufferSize == 0 )\n            {\n                nNextCompressionJobAvail = i;\n                break;\n            }\n        }\n    }\n    CPLAssert(nNextCompressionJobAvail >= 0);\n\n    GTiffCompressionJob* psJob = &asJobs[nNextCompressionJobAvail];\n    psJob->poDS = this;\n    psJob->bTIFFIsBigEndian = CPL_TO_BOOL( TIFFIsBigEndian(m_hTIFF) );\n    psJob->pabyBuffer =\n        static_cast<GByte*>( CPLRealloc(psJob->pabyBuffer, cc) );\n    memcpy(psJob->pabyBuffer, pabyData, cc);\n    psJob->nBufferSize = cc;\n    psJob->nHeight = nHeight;\n    psJob->nStripOrTile = nStripOrTile;\n    psJob->nPredictor = PREDICTOR_NONE;\n    if( m_nCompression == COMPRESSION_LZW ||\n        m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        m_nCompression == COMPRESSION_ZSTD )\n    {\n        TIFFGetField( m_hTIFF, TIFFTAG_PREDICTOR, &psJob->nPredictor );\n    }\n\n    poQueue->SubmitJob(ThreadCompressionFunc, psJob);\n    oQueue.push(nNextCompressionJobAvail);\n\n    return true;\n}\n\n/************************************************************************/\n/*                          DiscardLsb()                                */\n/************************************************************************/\n\ntemplate<class T> static void DiscardLsbT(GByte* pabyBuffer, \n                                         size_t nBytes,\n                                         int iBand,\n                                         int nBands,\n                                         uint16 nPlanarConfig,\n                                         const GTiffDataset::MaskOffset* panMaskOffsetLsb)\n{\n    if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        const int nMask = panMaskOffsetLsb[iBand].nMask;\n        const int nOffset = panMaskOffsetLsb[iBand].nOffset;\n        for( size_t i = 0; i < nBytes/sizeof(T); ++i )\n        {\n            reinterpret_cast<T*>(pabyBuffer)[i] =\n                static_cast<T>(\n                    (reinterpret_cast<T *>(pabyBuffer)[i] & nMask) |\n                    nOffset);\n        }\n    }\n    else\n    {\n        for( size_t i = 0; i < nBytes/sizeof(T); i += nBands )\n        {\n            for( int j = 0; j < nBands; ++j )\n            {\n                reinterpret_cast<T*>(pabyBuffer)[i + j] =\n                    static_cast<T>(\n                        (reinterpret_cast<T*>(pabyBuffer)[i + j] &\n                            panMaskOffsetLsb[j].nMask) |\n                        panMaskOffsetLsb[j].nOffset);\n            }\n        }\n    }\n}\n\nvoid GTiffDataset::DiscardLsb( GByte* pabyBuffer, GPtrDiff_t nBytes, int iBand ) const\n{\n    if( m_nBitsPerSample == 8 )\n    {\n        if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            const int nMask = m_panMaskOffsetLsb[iBand].nMask;\n            const int nOffset = m_panMaskOffsetLsb[iBand].nOffset;\n            for( decltype(nBytes) i = 0; i < nBytes; ++i )\n            {\n                // Keep 255 in case it is alpha.\n                if( pabyBuffer[i] != 255 )\n                    pabyBuffer[i] =\n                        static_cast<GByte>((pabyBuffer[i] & nMask) | nOffset);\n            }\n        }\n        else\n        {\n            for( decltype(nBytes) i = 0; i < nBytes; i += nBands )\n            {\n                for( int j = 0; j < nBands; ++j )\n                {\n                    // Keep 255 in case it is alpha.\n                    if( pabyBuffer[i + j] != 255 )\n                        pabyBuffer[i + j] =\n                            static_cast<GByte>((pabyBuffer[i + j] &\n                                                m_panMaskOffsetLsb[j].nMask) | m_panMaskOffsetLsb[j].nOffset);\n                }\n            }\n        }\n    }\n    else if( m_nBitsPerSample == 16 )\n    {\n        DiscardLsbT<GUInt16>(pabyBuffer, nBytes, iBand, nBands, m_nPlanarConfig,\n                            m_panMaskOffsetLsb);\n    }\n    else if( m_nBitsPerSample == 32 )\n    {\n        DiscardLsbT<GUInt32>(pabyBuffer, nBytes, iBand, nBands, m_nPlanarConfig,\n                            m_panMaskOffsetLsb);\n    }\n}\n\n/************************************************************************/\n/*                  WriteEncodedTileOrStrip()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::WriteEncodedTileOrStrip( uint32 tile_or_strip, void* data,\n                                              int bPreserveDataBuffer )\n{\n    CPLErr eErr = CE_None;\n\n    if( TIFFIsTiled( m_hTIFF ) )\n    {\n        if( !(WriteEncodedTile(\n               tile_or_strip,\n               static_cast<GByte *>(data),\n               bPreserveDataBuffer)) )\n        {\n            eErr = CE_Failure;\n        }\n    }\n    else\n    {\n        if( !(WriteEncodedStrip(\n               tile_or_strip,\n               static_cast<GByte *>(data),\n               bPreserveDataBuffer)) )\n        {\n            eErr = CE_Failure;\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                           FlushBlockBuf()                            */\n/************************************************************************/\n\nCPLErr GTiffDataset::FlushBlockBuf()\n\n{\n    if( m_nLoadedBlock < 0 || !m_bLoadedBlockDirty )\n        return CE_None;\n\n    m_bLoadedBlockDirty = false;\n\n    const CPLErr eErr =\n        WriteEncodedTileOrStrip(m_nLoadedBlock, m_pabyBlockBuf, true);\n    if( eErr != CE_None )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                    \"WriteEncodedTile/Strip() failed.\" );\n        m_bWriteError = true;\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                            LoadBlockBuf()                            */\n/*                                                                      */\n/*      Load working block buffer with request block (tile/strip).      */\n/************************************************************************/\n\nCPLErr GTiffDataset::LoadBlockBuf( int nBlockId, bool bReadFromDisk )\n\n{\n    if( m_nLoadedBlock == nBlockId && m_pabyBlockBuf != nullptr )\n        return CE_None;\n\n/* -------------------------------------------------------------------- */\n/*      If we have a dirty loaded block, flush it out first.            */\n/* -------------------------------------------------------------------- */\n    if( m_nLoadedBlock != -1 && m_bLoadedBlockDirty )\n    {\n        const CPLErr eErr = FlushBlockBuf();\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get block size.                                                 */\n/* -------------------------------------------------------------------- */\n    const GPtrDiff_t nBlockBufSize =\n        static_cast<GPtrDiff_t>(\n            TIFFIsTiled(m_hTIFF) ? TIFFTileSize(m_hTIFF) : TIFFStripSize(m_hTIFF));\n    if( !nBlockBufSize )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"Bogus block size; unable to allocate a buffer.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( m_pabyBlockBuf == nullptr )\n    {\n        m_pabyBlockBuf =\n            static_cast<GByte *>( VSI_CALLOC_VERBOSE( 1, nBlockBufSize ) );\n        if( m_pabyBlockBuf == nullptr )\n        {\n            return CE_Failure;\n        }\n    }\n\n    if( m_nLoadedBlock == nBlockId )\n        return CE_None;\n\n/* -------------------------------------------------------------------- */\n/*  When called from ::IWriteBlock in separate cases (or in single band */\n/*  geotiffs), the ::IWriteBlock will override the content of the buffer*/\n/*  with pImage, so we don't need to read data from disk                */\n/* -------------------------------------------------------------------- */\n    if( !bReadFromDisk || m_bStreamingOut )\n    {\n        m_nLoadedBlock = nBlockId;\n        return CE_None;\n    }\n\n    // libtiff 3.X doesn't like mixing read&write of JPEG compressed blocks\n    // The below hack is necessary due to another hack that consist in\n    // writing zero block to force creation of JPEG tables.\n    if( nBlockId == 0 && m_bDontReloadFirstBlock )\n    {\n        m_bDontReloadFirstBlock = false;\n        memset( m_pabyBlockBuf, 0, nBlockBufSize );\n        m_nLoadedBlock = nBlockId;\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      The bottom most partial tiles and strips are sometimes only     */\n/*      partially encoded.  This code reduces the requested data so     */\n/*      an error won't be reported in this case. (#1179)                */\n/* -------------------------------------------------------------------- */\n    auto nBlockReqSize = nBlockBufSize;\n    const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n    const int nBlockYOff = (nBlockId % m_nBlocksPerBand) / nBlocksPerRow;\n\n    if( nBlockYOff * m_nBlockYSize > nRasterYSize - m_nBlockYSize )\n    {\n        nBlockReqSize = (nBlockBufSize / m_nBlockYSize)\n            * (m_nBlockYSize - static_cast<int>(\n                (static_cast<GIntBig>(nBlockYOff + 1) * m_nBlockYSize) %\n                    nRasterYSize));\n        memset( m_pabyBlockBuf, 0, nBlockBufSize );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have this block already loaded, and we know it      */\n/*      doesn't yet exist on disk, just zero the memory buffer and      */\n/*      pretend we loaded it.                                           */\n/* -------------------------------------------------------------------- */\n    bool bErrOccurred = false;\n    if( !IsBlockAvailable( nBlockId, nullptr, nullptr, &bErrOccurred ) )\n    {\n        memset( m_pabyBlockBuf, 0, nBlockBufSize );\n        m_nLoadedBlock = nBlockId;\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block, if it isn't our current block.                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n    \n    if( !ReadStrile(nBlockId, m_pabyBlockBuf, nBlockReqSize) )\n    {\n        memset( m_pabyBlockBuf, 0, nBlockBufSize );\n        eErr = CE_Failure;\n    }\n\n    if( eErr == CE_None )\n    {\n        m_nLoadedBlock = nBlockId;\n    }\n    else\n    {\n        m_nLoadedBlock = -1;\n    }\n    m_bLoadedBlockDirty = false;\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                   GTiffFillStreamableOffsetAndCount()                */\n/************************************************************************/\n\nstatic void GTiffFillStreamableOffsetAndCount( TIFF* hTIFF, int nSize )\n{\n    uint32 nXSize = 0;\n    uint32 nYSize = 0;\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(hTIFF) );\n    const int nBlockCount =\n        bIsTiled ? TIFFNumberOfTiles(hTIFF) : TIFFNumberOfStrips(hTIFF);\n\n    toff_t *panOffset = nullptr;\n    TIFFGetField( hTIFF, bIsTiled ? TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                  &panOffset );\n    toff_t *panSize = nullptr;\n    TIFFGetField( hTIFF,\n                  bIsTiled ? TIFFTAG_TILEBYTECOUNTS : TIFFTAG_STRIPBYTECOUNTS,\n                  &panSize );\n    toff_t nOffset = nSize;\n    // Trick to avoid clang static analyzer raising false positive about\n    // divide by zero later.\n    int nBlocksPerBand = 1;\n    uint32 nRowsPerStrip = 0;\n    if( !bIsTiled )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP, &nRowsPerStrip);\n        if( nRowsPerStrip > static_cast<uint32>(nYSize) )\n            nRowsPerStrip = nYSize;\n        nBlocksPerBand = DIV_ROUND_UP(nYSize, nRowsPerStrip);\n    }\n    for( int i = 0; i < nBlockCount; ++i )\n    {\n        GPtrDiff_t cc = bIsTiled ? static_cast<GPtrDiff_t>(TIFFTileSize(hTIFF)) :\n                            static_cast<GPtrDiff_t>(TIFFStripSize(hTIFF));\n        if( !bIsTiled )\n        {\n/* -------------------------------------------------------------------- */\n/*      If this is the last strip in the image, and is partial, then    */\n/*      we need to trim the number of scanlines written to the          */\n/*      amount of valid data we have. (#2748)                           */\n/* -------------------------------------------------------------------- */\n            int nStripWithinBand = i % nBlocksPerBand;\n            if( nStripWithinBand * nRowsPerStrip > nYSize - nRowsPerStrip )\n            {\n                cc = (cc / nRowsPerStrip)\n                    * (nYSize - nStripWithinBand * nRowsPerStrip);\n            }\n        }\n        panOffset[i] = nOffset;\n        panSize[i] = cc;\n        nOffset += cc;\n    }\n}\n\n/************************************************************************/\n/*                             Crystalize()                             */\n/*                                                                      */\n/*      Make sure that the directory information is written out for     */\n/*      a new file, require before writing any imagery data.            */\n/************************************************************************/\n\nvoid GTiffDataset::Crystalize()\n\n{\n    if( m_bCrystalized )\n        return;\n\n    // TODO: libtiff writes extended tags in the order they are specified\n    // and not in increasing order.\n    WriteMetadata( this, m_hTIFF, true, m_eProfile, m_pszFilename,\n                   m_papszCreationOptions );\n    WriteGeoTIFFInfo();\n    if( m_bNoDataSet )\n        WriteNoDataValue( m_hTIFF, m_dfNoDataValue );\n\n    m_bMetadataChanged = false;\n    m_bGeoTIFFInfoChanged = false;\n    m_bNoDataChanged = false;\n    m_bNeedsRewrite = false;\n\n    m_bCrystalized = true;\n\n    TIFFWriteCheck( m_hTIFF, TIFFIsTiled(m_hTIFF), \"GTiffDataset::Crystalize\");\n\n    TIFFWriteDirectory( m_hTIFF );\n    if( m_bStreamingOut )\n    {\n        // We need to write twice the directory to be sure that custom\n        // TIFF tags are correctly sorted and that padding bytes have been\n        // added.\n        TIFFSetDirectory( m_hTIFF, 0 );\n        TIFFWriteDirectory( m_hTIFF );\n\n        if( VSIFSeekL( m_fpL, 0, SEEK_END ) != 0 )\n        {\n            ReportError(CE_Failure, CPLE_FileIO, \"Could not seek\");\n        }\n        const int nSize = static_cast<int>( VSIFTellL(m_fpL) );\n\n        TIFFSetDirectory( m_hTIFF, 0 );\n        GTiffFillStreamableOffsetAndCount( m_hTIFF, nSize );\n        TIFFWriteDirectory( m_hTIFF );\n\n        vsi_l_offset nDataLength = 0;\n        void* pabyBuffer =\n            VSIGetMemFileBuffer( m_pszTmpFilename, &nDataLength, FALSE);\n        if( static_cast<int>(\n                VSIFWriteL( pabyBuffer, 1,\n                            static_cast<int>(nDataLength), m_fpToWrite ) ) !=\n            static_cast<int>(nDataLength) )\n        {\n            ReportError( CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                      static_cast<int>(nDataLength) );\n        }\n        // In case of single strip file, there's a libtiff check that would\n        // issue a warning since the file hasn't the required size.\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        TIFFSetDirectory( m_hTIFF, 0 );\n        CPLPopErrorHandler();\n    }\n    else\n    {\n        TIFFSetDirectory( m_hTIFF,\n                      static_cast<tdir_t>(TIFFNumberOfDirectories(m_hTIFF) - 1) );\n    }\n\n    RestoreVolatileParameters( m_hTIFF );\n\n    m_nDirOffset = TIFFCurrentDirOffset( m_hTIFF );\n}\n\n/************************************************************************/\n/*                          IsBlockAvailable()                          */\n/*                                                                      */\n/*      Return true if the indicated strip/tile is available.  We       */\n/*      establish this by testing if the stripbytecount is zero.  If    */\n/*      zero then the block has never been committed to disk.           */\n/************************************************************************/\n\nbool GTiffDataset::IsBlockAvailable( int nBlockId,\n                                     vsi_l_offset* pnOffset,\n                                     vsi_l_offset* pnSize,\n                                     bool *pbErrOccurred )\n\n{\n    if( pbErrOccurred )\n        *pbErrOccurred = false;\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    std::pair<vsi_l_offset, vsi_l_offset> oPair;\n    if( m_oCacheStrileToOffsetByteCount.tryGet(nBlockId, oPair) )\n    {\n        if( pnOffset )\n            *pnOffset = oPair.first;\n        if( pnSize )\n            *pnSize = oPair.second;\n        return oPair.first != 0;\n    }\n#endif\n    \n    WaitCompletionForBlock(nBlockId);\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    // Optimization to avoid fetching the whole Strip/TileCounts and\n    // Strip/TileOffsets arrays.\n    if( eAccess == GA_ReadOnly && !m_bStreamingIn )\n    {\n        int nErrOccurred = 0;\n        auto bytecount = TIFFGetStrileByteCountWithErr(m_hTIFF, nBlockId, &nErrOccurred);\n        if( nErrOccurred && pbErrOccurred )\n            *pbErrOccurred = true;\n        if( pnOffset )\n        {\n            *pnOffset = TIFFGetStrileOffsetWithErr(m_hTIFF, nBlockId, &nErrOccurred);\n            if( nErrOccurred && pbErrOccurred )\n                *pbErrOccurred = true;\n        }\n        if( pnSize )\n            *pnSize = bytecount;\n        return bytecount != 0;\n    }\n#endif\n\n    toff_t *panByteCounts = nullptr;\n    toff_t *panOffsets = nullptr;\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(m_hTIFF) );\n\n    if( ( bIsTiled\n          && TIFFGetField( m_hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts )\n          && (pnOffset == nullptr ||\n              TIFFGetField( m_hTIFF, TIFFTAG_TILEOFFSETS, &panOffsets )) )\n        || ( !bIsTiled\n          && TIFFGetField( m_hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts )\n          && (pnOffset == nullptr ||\n              TIFFGetField( m_hTIFF, TIFFTAG_STRIPOFFSETS, &panOffsets )) ) )\n    {\n        if( panByteCounts == nullptr || (pnOffset != nullptr && panOffsets == nullptr) )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n        const int nBlockCount =\n            bIsTiled ? TIFFNumberOfTiles(m_hTIFF) : TIFFNumberOfStrips(m_hTIFF);\n        if( nBlockId >= nBlockCount )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        if( pnOffset )\n            *pnOffset = panOffsets[nBlockId];\n        if( pnSize )\n            *pnSize = panByteCounts[nBlockId];\n        return panByteCounts[nBlockId] != 0;\n    }\n    else\n    {\n        if( pbErrOccurred )\n            *pbErrOccurred = true;\n    }\n\n    return false;\n}\n\n/************************************************************************/\n/*                             FlushCache()                             */\n/*                                                                      */\n/*      We override this so we can also flush out local tiff strip      */\n/*      cache if need be.                                               */\n/************************************************************************/\n\nvoid GTiffDataset::FlushCache()\n\n{\n    FlushCacheInternal( true );\n}\n\nvoid GTiffDataset::FlushCacheInternal( bool bFlushDirectory )\n{\n    if( m_bIsFinalized )\n        return;\n\n    GDALPamDataset::FlushCache();\n\n    if( m_bLoadedBlockDirty && m_nLoadedBlock != -1 )\n        FlushBlockBuf();\n\n    CPLFree( m_pabyBlockBuf );\n    m_pabyBlockBuf = nullptr;\n    m_nLoadedBlock = -1;\n    m_bLoadedBlockDirty = false;\n\n    // Finish compression\n    auto poQueue = m_poBaseDS ? m_poBaseDS->m_poCompressQueue.get() : m_poCompressQueue.get();\n    if( poQueue )\n    {\n        poQueue->WaitCompletion();\n\n        // Flush remaining data\n        auto& oQueue = m_poBaseDS ? m_poBaseDS->m_asQueueJobIdx : m_asQueueJobIdx;\n        while( !oQueue.empty() )\n        {\n            WaitCompletionForJobIdx(oQueue.front());\n        }\n    }\n\n    if( bFlushDirectory && GetAccess() == GA_Update )\n    {\n        FlushDirectory();\n    }\n}\n\n/************************************************************************/\n/*                           FlushDirectory()                           */\n/************************************************************************/\n\nvoid GTiffDataset::FlushDirectory()\n\n{\n    if( GetAccess() == GA_Update )\n    {\n        if( m_bMetadataChanged )\n        {\n            m_bNeedsRewrite =\n                    WriteMetadata( this, m_hTIFF, true, m_eProfile, m_pszFilename,\n                                   m_papszCreationOptions );\n            m_bMetadataChanged = false;\n\n            if( m_bForceUnsetRPC )\n            {\n                double *padfRPCTag = nullptr;\n                uint16 nCount;\n                if( TIFFGetField( m_hTIFF, TIFFTAG_RPCCOEFFICIENT, &nCount, &padfRPCTag ) )\n                {\n                    std::vector<double> zeroes(92);\n                    TIFFSetField( m_hTIFF, TIFFTAG_RPCCOEFFICIENT, 92, zeroes.data() );\n                    TIFFUnsetField( m_hTIFF, TIFFTAG_RPCCOEFFICIENT );\n                    m_bNeedsRewrite = true;\n                }\n\n                GDALWriteRPCTXTFile( m_pszFilename, nullptr );\n                GDALWriteRPBFile( m_pszFilename, nullptr );\n            }\n        }\n\n        if( m_bGeoTIFFInfoChanged )\n        {\n            WriteGeoTIFFInfo();\n            m_bGeoTIFFInfoChanged = false;\n        }\n\n        if( m_bNoDataChanged )\n        {\n            if( m_bNoDataSet )\n            {\n                WriteNoDataValue( m_hTIFF, m_dfNoDataValue );\n            }\n            else\n            {\n                UnsetNoDataValue( m_hTIFF );\n            }\n            m_bNeedsRewrite = true;\n            m_bNoDataChanged = false;\n        }\n\n        if( m_bNeedsRewrite )\n        {\n            if( !m_bCrystalized)\n            {\n                Crystalize();\n            }\n            else\n            {\n                const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( m_hTIFF );\n\n                m_nDirOffset = pfnSizeProc( TIFFClientdata( m_hTIFF ) );\n                if( (m_nDirOffset % 2) == 1 )\n                    ++m_nDirOffset;\n\n                TIFFRewriteDirectory( m_hTIFF );\n\n                TIFFSetSubDirectory( m_hTIFF, m_nDirOffset );\n\n                if( m_bLayoutIFDSBeforeData &&\n                    m_bBlockOrderRowMajor &&\n                    m_bLeaderSizeAsUInt4 &&\n                    m_bTrailerRepeatedLast4BytesRepeated &&\n                    !m_bKnownIncompatibleEdition &&\n                    !m_bWriteKnownIncompatibleEdition )\n                {\n                    ReportError(CE_Warning, CPLE_AppDefined,\n                                \"The IFD has been rewritten at the end of \"\n                                \"the file, which breaks COG layout.\");\n                    m_bKnownIncompatibleEdition = true;\n                    m_bWriteKnownIncompatibleEdition = true;\n                }\n            }\n            m_bNeedsRewrite = false;\n        }\n    }\n\n    // There are some circumstances in which we can reach this point\n    // without having made this our directory (SetDirectory()) in which\n    // case we should not risk a flush.\n    if( GetAccess() == GA_Update && TIFFCurrentDirOffset(m_hTIFF) == m_nDirOffset )\n    {\n        const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( m_hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( m_hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            ++nNewDirOffset;\n\n        TIFFFlush( m_hTIFF );\n\n        if( m_nDirOffset != TIFFCurrentDirOffset( m_hTIFF ) )\n        {\n            m_nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\",\n                      \"directory moved during flush in FlushDirectory()\" );\n        }\n    }\n\n    SetDirectory();\n}\n\n/************************************************************************/\n/*                           CleanOverviews()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::CleanOverviews()\n\n{\n    CPLAssert( !m_poBaseDS );\n\n    ScanDirectories();\n\n    FlushDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews objects, and get offsets to all overview      */\n/*      directories.                                                    */\n/* -------------------------------------------------------------------- */\n    std::vector<toff_t> anOvDirOffsets;\n\n    for( int i = 0; i < m_nOverviewCount; ++i )\n    {\n        anOvDirOffsets.push_back( m_papoOverviewDS[i]->m_nDirOffset );\n        delete m_papoOverviewDS[i];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Loop through all the directories, translating the offsets       */\n/*      into indexes we can use with TIFFUnlinkDirectory().             */\n/* -------------------------------------------------------------------- */\n    std::vector<uint16> anOvDirIndexes;\n    int iThisOffset = 1;\n\n    TIFFSetDirectory( m_hTIFF, 0 );\n\n    while( true )\n    {\n        for( int i = 0; i < m_nOverviewCount; ++i )\n        {\n            if( anOvDirOffsets[i] == TIFFCurrentDirOffset( m_hTIFF ) )\n            {\n                CPLDebug( \"GTiff\", \"%d -> %d\",\n                          static_cast<int>(anOvDirOffsets[i]), iThisOffset );\n                anOvDirIndexes.push_back( static_cast<uint16>(iThisOffset) );\n            }\n        }\n\n        if( TIFFLastDirectory( m_hTIFF ) )\n            break;\n\n        TIFFReadDirectory( m_hTIFF );\n        ++iThisOffset;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Actually unlink the target directories.  Note that we do        */\n/*      this from last to first so as to avoid renumbering any of       */\n/*      the earlier directories we need to remove.                      */\n/* -------------------------------------------------------------------- */\n    while( !anOvDirIndexes.empty() )\n    {\n        TIFFUnlinkDirectory( m_hTIFF, anOvDirIndexes.back() );\n        anOvDirIndexes.pop_back();\n    }\n\n    CPLFree( m_papoOverviewDS );\n\n    m_nOverviewCount = 0;\n    m_papoOverviewDS = nullptr;\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                   RegisterNewOverviewDataset()                       */\n/************************************************************************/\n\nCPLErr GTiffDataset::RegisterNewOverviewDataset(toff_t nOverviewOffset,\n                                                int l_nJpegQuality,\n                                                int l_nWebPLevel)\n{\n    if( m_nOverviewCount == 127 )\n        return CE_Failure;\n\n    GTiffDataset* poODS = new GTiffDataset();\n    poODS->ShareLockWithParentDataset(this);\n    poODS->m_pszFilename = CPLStrdup(m_pszFilename);\n    poODS->m_nJpegQuality = static_cast<signed char>(l_nJpegQuality);\n    poODS->m_nWebPLevel = static_cast<signed char>(l_nWebPLevel);\n    poODS->m_nZLevel = m_nZLevel;\n    poODS->m_nLZMAPreset = m_nLZMAPreset;\n    poODS->m_nZSTDLevel = m_nZSTDLevel;\n    poODS->m_bWebPLossless = m_bWebPLossless;\n    poODS->m_nJpegTablesMode = m_nJpegTablesMode;\n#if HAVE_LERC\n    poODS->m_dfMaxZError = m_dfMaxZError;\n    memcpy(poODS->m_anLercAddCompressionAndVersion, m_anLercAddCompressionAndVersion,\n           sizeof(m_anLercAddCompressionAndVersion));\n#endif\n\n    if( poODS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nOverviewOffset,\n                            GA_Update ) != CE_None )\n    {\n        delete poODS;\n        return CE_Failure;\n    }\n\n    // Do that now that m_nCompression is set\n    poODS->RestoreVolatileParameters( poODS->m_hTIFF );\n\n    ++m_nOverviewCount;\n    m_papoOverviewDS = static_cast<GTiffDataset **>(\n        CPLRealloc( m_papoOverviewDS,\n                    m_nOverviewCount * (sizeof(void*))) );\n    m_papoOverviewDS[m_nOverviewCount-1] = poODS;\n    poODS->m_poBaseDS = this;\n    poODS->m_bIsOverview = true;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                     CreateTIFFColorTable()                           */\n/************************************************************************/\n\nstatic void CreateTIFFColorTable(GDALColorTable* poColorTable,\n                                 int nBits,\n                                 std::vector<unsigned short>& anTRed,\n                                 std::vector<unsigned short>& anTGreen,\n                                 std::vector<unsigned short>& anTBlue,\n                                 unsigned short*& panRed,\n                                 unsigned short*& panGreen,\n                                 unsigned short*& panBlue)\n{\n    int nColors;\n\n    if( nBits == 8 )\n        nColors = 256;\n    else if( nBits < 8 )\n        nColors = 1 << nBits;\n    else\n        nColors = 65536;\n\n    anTRed.resize(nColors,0);\n    anTGreen.resize(nColors,0);\n    anTBlue.resize(nColors,0);\n\n    for( int iColor = 0; iColor < nColors; ++iColor )\n    {\n        if( iColor < poColorTable->GetColorEntryCount() )\n        {\n            GDALColorEntry sRGB;\n\n            poColorTable->GetColorEntryAsRGB( iColor, &sRGB );\n\n            anTRed[iColor] = static_cast<unsigned short>(257 * sRGB.c1);\n            anTGreen[iColor] = static_cast<unsigned short>(257 * sRGB.c2);\n            anTBlue[iColor] = static_cast<unsigned short>(257 * sRGB.c3);\n        }\n        else\n        {\n            anTRed[iColor] = 0;\n            anTGreen[iColor] = 0;\n            anTBlue[iColor] = 0;\n        }\n    }\n\n    panRed = &(anTRed[0]);\n    panGreen = &(anTGreen[0]);\n    panBlue = &(anTBlue[0]);\n}\n\n/************************************************************************/\n/*                  CreateOverviewsFromSrcOverviews()                   */\n/************************************************************************/\n\n// If poOvrDS is not null, it is used and poSrcDS is ignored.\n\nCPLErr GTiffDataset::CreateOverviewsFromSrcOverviews(GDALDataset* poSrcDS,\n                                                     GDALDataset* poOvrDS)\n{\n    CPLAssert(poSrcDS->GetRasterCount() != 0);\n    CPLAssert(m_nOverviewCount == 0);\n\n    ScanDirectories();\n\n    FlushDirectory();\n\n    int nOvBitsPerSample = m_nBitsPerSample;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed;\n    std::vector<unsigned short> anTGreen;\n    std::vector<unsigned short> anTBlue;\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( m_nPhotometric == PHOTOMETRIC_PALETTE && m_poColorTable != nullptr )\n    {\n        CreateTIFFColorTable(m_poColorTable, nOvBitsPerSample,\n                             anTRed, anTGreen, anTBlue,\n                             panRed, panGreen, panBlue);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( \"NONE\", this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = nullptr;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( m_hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples,\n                      &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew =\n            static_cast<uint16*>(\n                CPLMalloc(nExtraSamples * sizeof(uint16)) );\n        memcpy( panExtraSampleValuesNew, panExtraSampleValues,\n                nExtraSamples * sizeof(uint16));\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = nullptr;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if( m_nCompression == COMPRESSION_LZW ||\n        m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        m_nCompression == COMPRESSION_ZSTD )\n        TIFFGetField( m_hTIFF, TIFFTAG_PREDICTOR, &nPredictor );\n    int nOvrBlockXSize = 0;\n    int nOvrBlockYSize = 0;\n    GTIFFGetOverviewBlockSize(GDALRasterBand::ToHandle(GetRasterBand(1)),\n                              &nOvrBlockXSize, &nOvrBlockYSize);\n\n    int nSrcOverviews = poOvrDS ?\n        poOvrDS->GetRasterBand(1)->GetOverviewCount() + 1:\n        poSrcDS->GetRasterBand(1)->GetOverviewCount();\n    CPLErr eErr = CE_None;\n\n    for( int i = 0; i < nSrcOverviews && eErr == CE_None; ++i )\n    {\n        GDALRasterBand* poOvrBand = poOvrDS ?\n            ((i == 0) ? poOvrDS->GetRasterBand(1) :\n                        poOvrDS->GetRasterBand(1)->GetOverview(i-1)):\n            poSrcDS->GetRasterBand(1)->GetOverview(i);\n\n        int nOXSize = poOvrBand->GetXSize();\n        int nOYSize = poOvrBand->GetYSize();\n\n        int nOvrJpegQuality = m_nJpegQuality;\n        if( m_nCompression == COMPRESSION_JPEG &&\n            CPLGetConfigOption( \"JPEG_QUALITY_OVERVIEW\", nullptr ) != nullptr )\n        {\n            nOvrJpegQuality =\n                atoi(CPLGetConfigOption(\"JPEG_QUALITY_OVERVIEW\",\"75\"));\n        }\n        int nOvrWebpLevel = m_nWebPLevel;\n        if( m_nCompression == COMPRESSION_WEBP &&\n            CPLGetConfigOption( \"WEBP_LEVEL_OVERVIEW\", nullptr ) != nullptr )\n        {\n            nOvrWebpLevel =\n                atoi(CPLGetConfigOption(\"WEBP_LEVEL_OVERVIEW\",\"75\"));\n        }\n\n        CPLString osNoData; // don't move this in inner scope\n        const char* pszNoData = nullptr;\n        if( m_bNoDataSet )\n        {\n            osNoData = GTiffFormatGDALNoDataTagValue(m_dfNoDataValue);\n            pszNoData = osNoData.c_str();\n        }\n\n        toff_t nOverviewOffset =\n                GTIFFWriteDirectory(m_hTIFF, FILETYPE_REDUCEDIMAGE,\n                                    nOXSize, nOYSize,\n                                    nOvBitsPerSample, m_nPlanarConfig,\n                                    m_nSamplesPerPixel,\n                                    nOvrBlockXSize,\n                                    nOvrBlockYSize,\n                                    TRUE,\n                                    m_nCompression, m_nPhotometric, m_nSampleFormat,\n                                    nPredictor,\n                                    panRed, panGreen, panBlue,\n                                    nExtraSamples, panExtraSampleValues,\n                                    osMetadata,\n                                    nOvrJpegQuality >= 0 ?\n                                        CPLSPrintf(\"%d\", nOvrJpegQuality) : nullptr,\n                                    CPLSPrintf(\"%d\", m_nJpegTablesMode),\n                                    pszNoData,\n#ifdef HAVE_LERC\n                                    m_anLercAddCompressionAndVersion,\n#else\n                                    nullptr,\n#endif\n                                    m_bWriteCOGLayout,\n                                    nOvrWebpLevel >= 0 ?\n                                        CPLSPrintf(\"%d\", nOvrWebpLevel) : nullptr\n                                   );\n\n        if( nOverviewOffset == 0 )\n            eErr = CE_Failure;\n        else\n            eErr = RegisterNewOverviewDataset(nOverviewOffset, nOvrJpegQuality, nOvrWebpLevel);\n    }\n\n    // For directory reloading, so that the chaining to the next directory is\n    // reloaded, as well as compression parameters.\n    ReloadDirectory();\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = nullptr;\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                           ReloadDirectory()                          */\n/************************************************************************/\n\nvoid GTiffDataset::ReloadDirectory()\n{\n    TIFFSetSubDirectory( m_hTIFF, 0 );\n    CPL_IGNORE_RET_VAL( SetDirectory() );\n}\n\n/************************************************************************/\n/*                       CreateInternalMaskOverviews()                  */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateInternalMaskOverviews(int nOvrBlockXSize,\n                                                 int nOvrBlockYSize)\n{\n    ScanDirectories();\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    const char* pszInternalMask =\n        CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", nullptr);\n    if( m_poMaskDS != nullptr &&\n        m_poMaskDS->GetRasterCount() == 1 &&\n        (pszInternalMask == nullptr || CPLTestBool(pszInternalMask)) )\n    {\n        int nMaskOvrCompression;\n        if( strstr(GDALGetMetadataItem(GDALGetDriverByName( \"GTiff\" ),\n                                       GDAL_DMD_CREATIONOPTIONLIST, nullptr ),\n                   \"<Value>DEFLATE</Value>\") != nullptr )\n            nMaskOvrCompression = COMPRESSION_ADOBE_DEFLATE;\n        else\n            nMaskOvrCompression = COMPRESSION_PACKBITS;\n\n        for( int i = 0; i < m_nOverviewCount; ++i )\n        {\n            if( m_papoOverviewDS[i]->m_poMaskDS == nullptr )\n            {\n                const toff_t nOverviewOffset =\n                    GTIFFWriteDirectory(\n                        m_hTIFF, FILETYPE_REDUCEDIMAGE | FILETYPE_MASK,\n                        m_papoOverviewDS[i]->nRasterXSize,\n                        m_papoOverviewDS[i]->nRasterYSize,\n                        1, PLANARCONFIG_CONTIG,\n                        1, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                        nMaskOvrCompression, PHOTOMETRIC_MASK,\n                        SAMPLEFORMAT_UINT, PREDICTOR_NONE,\n                        nullptr, nullptr, nullptr, 0, nullptr,\n                        \"\",\n                        nullptr, nullptr, nullptr, nullptr,\n                        m_bWriteCOGLayout,\n                        nullptr );\n\n                if( nOverviewOffset == 0 )\n                {\n                    eErr = CE_Failure;\n                    continue;\n                }\n\n                GTiffDataset *poODS = new GTiffDataset();\n                poODS->ShareLockWithParentDataset(this);\n                poODS->m_pszFilename = CPLStrdup(m_pszFilename);\n                if( poODS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF),\n                                       nOverviewOffset,\n                                       GA_Update ) != CE_None )\n                {\n                    delete poODS;\n                    eErr = CE_Failure;\n                }\n                else\n                {\n                    poODS->m_bPromoteTo8Bits =\n                        CPLTestBool(\n                            CPLGetConfigOption(\n                                \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\" ) );\n                    poODS->m_poBaseDS = this;\n                    poODS->m_poImageryDS = m_papoOverviewDS[i];\n                    m_papoOverviewDS[i]->m_poMaskDS = poODS;\n                    ++m_poMaskDS->m_nOverviewCount;\n                    m_poMaskDS->m_papoOverviewDS = static_cast<GTiffDataset **>(\n                        CPLRealloc(\n                            m_poMaskDS->m_papoOverviewDS,\n                            m_poMaskDS->m_nOverviewCount * (sizeof(void*))) );\n                    m_poMaskDS->m_papoOverviewDS[m_poMaskDS->m_nOverviewCount-1] =\n                        poODS;\n                }\n            }\n        }\n    }\n\n    ReloadDirectory();\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                          IBuildOverviews()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::IBuildOverviews(\n    const char * pszResampling,\n    int nOverviews, int * panOverviewList,\n    int nBandsIn, int * panBandList,\n    GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    ScanDirectories();\n\n    // Make implicit JPEG overviews invisible, but do not destroy\n    // them in case they are already used (not sure that the client\n    // has the right to do that.  Behavior maybe undefined in GDAL API.\n    m_nJPEGOverviewCount = 0;\n\n/* -------------------------------------------------------------------- */\n/*      If RRD or external OVR overviews requested, then invoke         */\n/*      generic handling.                                               */\n/* -------------------------------------------------------------------- */\n    bool bUseGenericHandling = false;\n\n    if( CPLTestBool(CPLGetConfigOption( \"USE_RRD\", \"NO\" ))\n        || CPLTestBool(CPLGetConfigOption( \"TIFF_USE_OVR\", \"NO\" )) )\n    {\n        bUseGenericHandling = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have read access, then create the overviews         */\n/*      externally.                                                     */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() != GA_Update )\n    {\n        CPLDebug( \"GTiff\",\n                  \"File open for read-only accessing, \"\n                  \"creating overviews externally.\" );\n\n        bUseGenericHandling = true;\n    }\n\n    if( bUseGenericHandling )\n    {\n        if( m_nOverviewCount != 0 )\n        {\n            ReportError(\n                CE_Failure, CPLE_NotSupported,\n                \"Cannot add external overviews when there are already \"\n                \"internal overviews\" );\n            return CE_Failure;\n        }\n\n        CPLErr eErr = GDALDataset::IBuildOverviews(\n            pszResampling, nOverviews, panOverviewList,\n            nBandsIn, panBandList, pfnProgress, pProgressData );\n        if( eErr == CE_None && m_poMaskDS )\n        {\n            ReportError(CE_Warning, CPLE_NotSupported,\n                     \"Building external overviews whereas there is an internal \"\n                     \"mask is not fully supported. \"\n                     \"The overviews of the non-mask bands will be created, \"\n                     \"but not the overviews of the mask band.\");\n        }\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Our TIFF overview support currently only works safely if all    */\n/*      bands are handled at the same time.                             */\n/* -------------------------------------------------------------------- */\n    if( nBandsIn != GetRasterCount() )\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"Generation of overviews in TIFF currently only \"\n                  \"supported when operating on all bands.  \"\n                  \"Operation failed.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If zero overviews were requested, we need to clear all          */\n/*      existing overviews.                                             */\n/* -------------------------------------------------------------------- */\n    if( nOverviews == 0 )\n    {\n        if( m_nOverviewCount == 0 )\n            return GDALDataset::IBuildOverviews(\n                pszResampling, nOverviews, panOverviewList,\n                nBandsIn, panBandList, pfnProgress, pProgressData );\n\n        return CleanOverviews();\n    }\n\n    CPLErr eErr = CE_None;\n\n/* -------------------------------------------------------------------- */\n/*      Initialize progress counter.                                    */\n/* -------------------------------------------------------------------- */\n    if( !pfnProgress( 0.0, nullptr, pProgressData ) )\n    {\n        ReportError( CE_Failure, CPLE_UserInterrupt, \"User terminated\" );\n        return CE_Failure;\n    }\n\n    FlushDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      If we are averaging bit data to grayscale we need to create     */\n/*      8bit overviews.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvBitsPerSample = m_nBitsPerSample;\n\n    if( STARTS_WITH_CI(pszResampling, \"AVERAGE_BIT2\") )\n        nOvBitsPerSample = 8;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed;\n    std::vector<unsigned short> anTGreen;\n    std::vector<unsigned short> anTBlue;\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( m_nPhotometric == PHOTOMETRIC_PALETTE && m_poColorTable != nullptr )\n    {\n        CreateTIFFColorTable(m_poColorTable, nOvBitsPerSample,\n                             anTRed, anTGreen, anTBlue,\n                             panRed, panGreen, panBlue);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( pszResampling, this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = nullptr;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( m_hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples,\n                      &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew =\n            static_cast<uint16*>( CPLMalloc(nExtraSamples * sizeof(uint16)) );\n        memcpy( panExtraSampleValuesNew, panExtraSampleValues,\n                nExtraSamples * sizeof(uint16) );\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = nullptr;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if( m_nCompression == COMPRESSION_LZW ||\n        m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        m_nCompression == COMPRESSION_ZSTD )\n        TIFFGetField( m_hTIFF, TIFFTAG_PREDICTOR, &nPredictor );\n\n/* -------------------------------------------------------------------- */\n/*      Establish which of the overview levels we already have, and     */\n/*      which are new.  We assume that band 1 of the file is            */\n/*      representative.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvrBlockXSize = 0;\n    int nOvrBlockYSize = 0;\n    GTIFFGetOverviewBlockSize(GDALRasterBand::ToHandle(GetRasterBand(1)),\n                              &nOvrBlockXSize, &nOvrBlockYSize);\n    std::vector<bool> abRequireNewOverview(nOverviews, true);\n    for( int i = 0; i < nOverviews && eErr == CE_None; ++i )\n    {\n        for( int j = 0; j < m_nOverviewCount && eErr == CE_None; ++j )\n        {\n            GTiffDataset *poODS = m_papoOverviewDS[j];\n\n            const int nOvFactor =\n                GDALComputeOvFactor(poODS->GetRasterXSize(),\n                                    GetRasterXSize(),\n                                    poODS->GetRasterYSize(),\n                                    GetRasterYSize());\n\n            // If we already have a 1x1 overview and this new one would result\n            // in it too, then don't create it.\n            if( poODS->GetRasterXSize() == 1 &&\n                poODS->GetRasterYSize() == 1 &&\n                (GetRasterXSize() + panOverviewList[i] - 1)\n                    / panOverviewList[i] == 1 &&\n                (GetRasterYSize() + panOverviewList[i] - 1)\n                    / panOverviewList[i] == 1 )\n            {\n                abRequireNewOverview[i] = false;\n                break;\n            }\n\n            if( nOvFactor == panOverviewList[i]\n                || nOvFactor == GDALOvLevelAdjust2( panOverviewList[i],\n                                                    GetRasterXSize(),\n                                                    GetRasterYSize() ) )\n            {\n                abRequireNewOverview[i] = false;\n                break;\n            }\n        }\n\n        if( abRequireNewOverview[i] )\n        {\n            if( m_bLayoutIFDSBeforeData && !m_bKnownIncompatibleEdition &&\n                !m_bWriteKnownIncompatibleEdition )\n            {\n                ReportError(CE_Warning, CPLE_AppDefined,\n                         \"Adding new overviews invalidates the \"\n                         \"LAYOUT=IFDS_BEFORE_DATA property\");\n                m_bKnownIncompatibleEdition = true;\n                m_bWriteKnownIncompatibleEdition = true;\n            }\n\n            const int nOXSize =\n                (GetRasterXSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n            const int nOYSize =\n                (GetRasterYSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n\n            int nOvrJpegQuality = m_nJpegQuality;\n            if( m_nCompression == COMPRESSION_JPEG &&\n                CPLGetConfigOption( \"JPEG_QUALITY_OVERVIEW\", nullptr ) != nullptr )\n            {\n                nOvrJpegQuality =\n                    atoi(CPLGetConfigOption(\"JPEG_QUALITY_OVERVIEW\",\"75\"));\n            }\n            int nOvrWebpLevel = m_nWebPLevel;\n            if( m_nCompression == COMPRESSION_WEBP &&\n                CPLGetConfigOption( \"WEBP_LEVEL_OVERVIEW\", nullptr ) != nullptr )\n            {\n                nOvrWebpLevel =\n                    atoi(CPLGetConfigOption(\"WEBP_LEVEL_OVERVIEW\",\"75\"));\n            }\n\n            CPLString osNoData; // don't move this in inner scope\n            const char* pszNoData = nullptr;\n            if( m_bNoDataSet )\n            {\n                osNoData = GTiffFormatGDALNoDataTagValue(m_dfNoDataValue);\n                pszNoData = osNoData.c_str();\n            }\n\n            const toff_t nOverviewOffset =\n                GTIFFWriteDirectory(\n                    m_hTIFF, FILETYPE_REDUCEDIMAGE,\n                    nOXSize, nOYSize,\n                    nOvBitsPerSample, m_nPlanarConfig,\n                    m_nSamplesPerPixel, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                    m_nCompression, m_nPhotometric, m_nSampleFormat,\n                    nPredictor,\n                    panRed, panGreen, panBlue,\n                    nExtraSamples, panExtraSampleValues,\n                    osMetadata,\n                    nOvrJpegQuality >= 0 ?\n                                CPLSPrintf(\"%d\", nOvrJpegQuality) : nullptr,\n                    CPLSPrintf(\"%d\", m_nJpegTablesMode),\n                    pszNoData,\n#ifdef HAVE_LERC\n                    m_anLercAddCompressionAndVersion,\n#else\n                    nullptr,\n#endif\n                    false,\n                    nOvrWebpLevel >= 0 ?\n                                CPLSPrintf(\"%d\", nOvrWebpLevel) : nullptr\n            );\n\n            if( nOverviewOffset == 0 )\n                eErr = CE_Failure;\n            else\n                eErr = RegisterNewOverviewDataset(nOverviewOffset,\n                                                  nOvrJpegQuality,\n                                                  nOvrWebpLevel);\n        }\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = nullptr;\n\n    ReloadDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    if( eErr != CE_None )\n        return eErr;\n\n    eErr = CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n\n/* -------------------------------------------------------------------- */\n/*      Refresh overviews for the mask                                  */\n/* -------------------------------------------------------------------- */\n    if( m_poMaskDS != nullptr &&\n        m_poMaskDS->GetRasterCount() == 1 )\n    {\n        int nMaskOverviews = 0;\n\n        GDALRasterBand **papoOverviewBands = static_cast<GDALRasterBand **>(\n            CPLCalloc(sizeof(void*),m_nOverviewCount) );\n        for( int i = 0; i < m_nOverviewCount; ++i )\n        {\n            if( m_papoOverviewDS[i]->m_poMaskDS != nullptr )\n            {\n                papoOverviewBands[nMaskOverviews++] =\n                        m_papoOverviewDS[i]->m_poMaskDS->GetRasterBand(1);\n            }\n        }\n        eErr = GDALRegenerateOverviews(\n            m_poMaskDS->GetRasterBand(1),\n            nMaskOverviews,\n            reinterpret_cast<GDALRasterBandH *>( papoOverviewBands ),\n            pszResampling, GDALDummyProgress, nullptr );\n        CPLFree(papoOverviewBands);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Refresh old overviews that were listed.                         */\n/* -------------------------------------------------------------------- */\n    if( m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        GDALDataTypeIsComplex(GetRasterBand( panBandList[0] )->\n                              GetRasterDataType()) == FALSE &&\n        GetRasterBand( panBandList[0] )->GetColorTable() == nullptr &&\n        (STARTS_WITH_CI(pszResampling, \"NEAR\") ||\n         EQUAL(pszResampling, \"AVERAGE\") ||\n         EQUAL(pszResampling, \"GAUSS\") ||\n         EQUAL(pszResampling, \"CUBIC\") ||\n         EQUAL(pszResampling, \"CUBICSPLINE\") ||\n         EQUAL(pszResampling, \"LANCZOS\") ||\n         EQUAL(pszResampling, \"BILINEAR\")) )\n    {\n        // In the case of pixel interleaved compressed overviews, we want to\n        // generate the overviews for all the bands block by block, and not\n        // band after band, in order to write the block once and not loose\n        // space in the TIFF file.  We also use that logic for uncompressed\n        // overviews, since GDALRegenerateOverviewsMultiBand() will be able to\n        // trigger cascading overview regeneration even in the presence\n        // of an alpha band.\n\n        int nNewOverviews = 0;\n\n        GDALRasterBand ***papapoOverviewBands =\n            static_cast<GDALRasterBand ***>(CPLCalloc(sizeof(void*),nBandsIn));\n        GDALRasterBand **papoBandList =\n            static_cast<GDALRasterBand **>(CPLCalloc(sizeof(void*),nBandsIn));\n        for( int iBand = 0; iBand < nBandsIn; ++iBand )\n        {\n            GDALRasterBand* poBand = GetRasterBand( panBandList[iBand] );\n\n            papoBandList[iBand] = poBand;\n            papapoOverviewBands[iBand] =\n                static_cast<GDALRasterBand **>( CPLCalloc(\n                    sizeof(void*), poBand->GetOverviewCount()) );\n\n            int iCurOverview = 0;\n            std::vector<bool> abAlreadyUsedOverviewBand(\n                poBand->GetOverviewCount(), false);\n\n            for( int i = 0; i < nOverviews; ++i )\n            {\n                for( int j = 0; j < poBand->GetOverviewCount(); ++j )\n                {\n                    if( abAlreadyUsedOverviewBand[j] )\n                        continue;\n\n                    int    nOvFactor;\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    nOvFactor = GDALComputeOvFactor(poOverview->GetXSize(),\n                                                     poBand->GetXSize(),\n                                                     poOverview->GetYSize(),\n                                                     poBand->GetYSize());\n\n                    int bHasNoData = FALSE;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if( bHasNoData )\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    if( nOvFactor == panOverviewList[i]\n                        || nOvFactor == GDALOvLevelAdjust2(\n                                            panOverviewList[i],\n                                            poBand->GetXSize(),\n                                            poBand->GetYSize() ) )\n                    {\n                        abAlreadyUsedOverviewBand[j] = true;\n                        CPLAssert(iCurOverview < poBand->GetOverviewCount());\n                        papapoOverviewBands[iBand][iCurOverview] = poOverview;\n                        ++iCurOverview ;\n                        break;\n                    }\n                }\n            }\n\n            if( nNewOverviews == 0 )\n            {\n                nNewOverviews = iCurOverview;\n            }\n            else if( nNewOverviews != iCurOverview )\n            {\n                CPLAssert(false);\n                return CE_Failure;\n            }\n        }\n\n        GDALRegenerateOverviewsMultiBand( nBandsIn, papoBandList,\n                                          nNewOverviews, papapoOverviewBands,\n                                          pszResampling, pfnProgress,\n                                          pProgressData );\n\n        for( int iBand = 0; iBand < nBandsIn; ++iBand )\n        {\n            CPLFree(papapoOverviewBands[iBand]);\n        }\n        CPLFree(papapoOverviewBands);\n        CPLFree(papoBandList);\n    }\n    else\n    {\n        GDALRasterBand **papoOverviewBands = static_cast<GDALRasterBand **>(\n            CPLCalloc(sizeof(void*), nOverviews) );\n\n        for( int iBand = 0; iBand < nBandsIn && eErr == CE_None; ++iBand )\n        {\n            GDALRasterBand *poBand = GetRasterBand( panBandList[iBand] );\n            if( poBand == nullptr )\n            {\n                eErr = CE_Failure;\n                break;\n            }\n\n            std::vector<bool> abAlreadyUsedOverviewBand(\n                poBand->GetOverviewCount(), false);\n\n            int nNewOverviews = 0;\n            for( int i = 0; i < nOverviews; ++i )\n            {\n                for( int j = 0; j < poBand->GetOverviewCount(); ++j )\n                {\n                    if( abAlreadyUsedOverviewBand[j] )\n                        continue;\n\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    int bHasNoData = FALSE;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if( bHasNoData )\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    const int nOvFactor =\n                        GDALComputeOvFactor(poOverview->GetXSize(),\n                                            poBand->GetXSize(),\n                                            poOverview->GetYSize(),\n                                            poBand->GetYSize());\n\n                    if( nOvFactor == panOverviewList[i]\n                        || nOvFactor == GDALOvLevelAdjust2(\n                                            panOverviewList[i],\n                                            poBand->GetXSize(),\n                                            poBand->GetYSize() ) )\n                    {\n                        abAlreadyUsedOverviewBand[j] = true;\n                        CPLAssert(nNewOverviews < poBand->GetOverviewCount());\n                        papoOverviewBands[nNewOverviews++] = poOverview;\n                        break;\n                    }\n                }\n            }\n\n            void *pScaledProgressData =\n                GDALCreateScaledProgress(\n                    iBand / static_cast<double>( nBandsIn ),\n                    (iBand + 1) / static_cast<double>( nBandsIn ),\n                    pfnProgress, pProgressData );\n\n            eErr = GDALRegenerateOverviews(\n                poBand,\n                nNewOverviews,\n                reinterpret_cast<GDALRasterBandH *>( papoOverviewBands ),\n                pszResampling,\n                GDALScaledProgress,\n                pScaledProgressData );\n\n            GDALDestroyScaledProgress( pScaledProgressData );\n        }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup                                                         */\n    /* -------------------------------------------------------------------- */\n        CPLFree( papoOverviewBands );\n    }\n\n    pfnProgress( 1.0, nullptr, pProgressData );\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                      GTiffWriteDummyGeokeyDirectory()                */\n/************************************************************************/\n\nstatic void GTiffWriteDummyGeokeyDirectory( TIFF* hTIFF )\n{\n    // If we have existing geokeys, try to wipe them\n    // by writing a dummy geokey directory. (#2546)\n    uint16 *panVI = nullptr;\n    uint16 nKeyCount = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY,\n                        &nKeyCount, &panVI ) )\n    {\n        GUInt16 anGKVersionInfo[4] = { 1, 1, 0, 0 };\n        double adfDummyDoubleParams[1] = { 0.0 };\n        TIFFSetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY,\n                        4, anGKVersionInfo );\n        TIFFSetField( hTIFF, TIFFTAG_GEODOUBLEPARAMS,\n                        1, adfDummyDoubleParams );\n        TIFFSetField( hTIFF, TIFFTAG_GEOASCIIPARAMS, \"\" );\n    }\n}\n\n/************************************************************************/\n/*               GTiffDatasetLibGeotiffErrorCallback()                  */\n/************************************************************************/\n\nstatic void GTiffDatasetLibGeotiffErrorCallback(GTIF*,\n                                                int level,\n                                                const char* pszMsg, ...)\n{\n    va_list ap;\n    va_start(ap, pszMsg);\n    CPLErrorV( (level == LIBGEOTIFF_WARNING ) ? CE_Warning : CE_Failure,\n               CPLE_AppDefined, pszMsg, ap );\n    va_end(ap);\n}\n\n/************************************************************************/\n/*                           GTiffDatasetGTIFNew()                      */\n/************************************************************************/\n\nstatic GTIF* GTiffDatasetGTIFNew( TIFF* hTIFF )\n{\n    GTIF* gtif = GTIFNewEx(hTIFF, GTiffDatasetLibGeotiffErrorCallback, nullptr);\n    if( gtif )\n    {\n        GTIFAttachPROJContext(gtif, OSRGetProjTLSContext());\n    }\n    return gtif;\n}\n\n/************************************************************************/\n/*                          WriteGeoTIFFInfo()                          */\n/************************************************************************/\n\nvoid GTiffDataset::WriteGeoTIFFInfo()\n\n{\n    bool bPixelIsPoint = false;\n    bool bPointGeoIgnore = false;\n\n    const char* pszAreaOrPoint =\n        GTiffDataset::GetMetadataItem( GDALMD_AREA_OR_POINT );\n    if( pszAreaOrPoint && EQUAL(pszAreaOrPoint, GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore =\n            CPLTestBool( CPLGetConfigOption( \"GTIFF_POINT_GEO_IGNORE\",\n                                             \"FALSE\") );\n    }\n\n    if( m_bForceUnsetGTOrGCPs )\n    {\n        m_bNeedsRewrite = true;\n        m_bForceUnsetGTOrGCPs = false;\n\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOPIXELSCALE );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOTIEPOINTS );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOTRANSMATRIX );\n    }\n\n    if( m_bForceUnsetProjection )\n    {\n        m_bNeedsRewrite = true;\n        m_bForceUnsetProjection = false;\n\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOKEYDIRECTORY );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEODOUBLEPARAMS );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOASCIIPARAMS );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write geotransform if valid.                                    */\n/* -------------------------------------------------------------------- */\n    if( m_bGeoTransformValid )\n    {\n        m_bNeedsRewrite = true;\n\n/* -------------------------------------------------------------------- */\n/*      Clear old tags to ensure we don't end up with conflicting       */\n/*      information. (#2625)                                            */\n/* -------------------------------------------------------------------- */\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOPIXELSCALE );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOTIEPOINTS );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOTRANSMATRIX );\n\n/* -------------------------------------------------------------------- */\n/*      Write the transform.  If we have a normal north-up image we     */\n/*      use the tiepoint plus pixelscale otherwise we use a matrix.     */\n/* -------------------------------------------------------------------- */\n        if( m_adfGeoTransform[2] == 0.0 && m_adfGeoTransform[4] == 0.0\n                && m_adfGeoTransform[5] < 0.0 )\n        {\n            double dfOffset = 0.0;\n            if( m_eProfile != GTiffProfile::BASELINE )\n            {\n                // In the case the SRS has a vertical component and we have\n                // a single band, encode its scale/offset in the GeoTIFF tags\n                int bHasScale = FALSE;\n                double dfScale = GetRasterBand(1)->GetScale(&bHasScale);\n                int bHasOffset = FALSE;\n                dfOffset = GetRasterBand(1)->GetOffset(&bHasOffset);\n                const bool bApplyScaleOffset =\n                    m_oSRS.IsVertical() &&\n                    GetRasterCount() == 1;\n                if( bApplyScaleOffset && !bHasScale )\n                    dfScale = 1.0;\n                if( !bApplyScaleOffset || !bHasOffset )\n                    dfOffset = 0.0;\n                const double adfPixelScale[3] = {\n                    m_adfGeoTransform[1], fabs(m_adfGeoTransform[5]),\n                    bApplyScaleOffset ? dfScale  : 0.0 };\n                TIFFSetField( m_hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n            }\n\n            double adfTiePoints[6] = {\n                0.0, 0.0, 0.0, m_adfGeoTransform[0], m_adfGeoTransform[3], dfOffset };\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfTiePoints[3] +=\n                    m_adfGeoTransform[1] * 0.5 + m_adfGeoTransform[2] * 0.5;\n                adfTiePoints[4] +=\n                    m_adfGeoTransform[4] * 0.5 + m_adfGeoTransform[5] * 0.5;\n            }\n\n            if( m_eProfile != GTiffProfile::BASELINE )\n                TIFFSetField( m_hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n        }\n        else\n        {\n            double adfMatrix[16] = {};\n\n            adfMatrix[0] = m_adfGeoTransform[1];\n            adfMatrix[1] = m_adfGeoTransform[2];\n            adfMatrix[3] = m_adfGeoTransform[0];\n            adfMatrix[4] = m_adfGeoTransform[4];\n            adfMatrix[5] = m_adfGeoTransform[5];\n            adfMatrix[7] = m_adfGeoTransform[3];\n            adfMatrix[15] = 1.0;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfMatrix[3] +=\n                    m_adfGeoTransform[1] * 0.5 + m_adfGeoTransform[2] * 0.5;\n                adfMatrix[7] +=\n                    m_adfGeoTransform[4] * 0.5 + m_adfGeoTransform[5] * 0.5;\n            }\n\n            if( m_eProfile != GTiffProfile::BASELINE )\n                TIFFSetField( m_hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n        }\n\n        // Do we need a world file?\n        if( CPLFetchBool( m_papszCreationOptions, \"TFW\", false ) )\n            GDALWriteWorldFile( m_pszFilename, \"tfw\", m_adfGeoTransform );\n        else if( CPLFetchBool( m_papszCreationOptions, \"WORLDFILE\", false ) )\n            GDALWriteWorldFile( m_pszFilename, \"wld\", m_adfGeoTransform );\n    }\n    else if( GetGCPCount() > 0 )\n    {\n        m_bNeedsRewrite = true;\n\n        double *padfTiePoints = static_cast<double *>(\n            CPLMalloc( 6 * sizeof(double) * GetGCPCount() ) );\n\n        for( int iGCP = 0; iGCP < GetGCPCount(); ++iGCP )\n        {\n\n            padfTiePoints[iGCP*6+0] = m_pasGCPList[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = m_pasGCPList[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = m_pasGCPList[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = m_pasGCPList[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = m_pasGCPList[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] += 0.5;\n                padfTiePoints[iGCP*6+1] += 0.5;\n            }\n        }\n\n        if( m_eProfile != GTiffProfile::BASELINE )\n            TIFFSetField( m_hTIFF, TIFFTAG_GEOTIEPOINTS,\n                          6 * GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out projection definition.                                */\n/* -------------------------------------------------------------------- */\n    const bool bHasProjection = !m_oSRS.IsEmpty();\n    if( (bHasProjection || bPixelIsPoint)\n        && m_eProfile != GTiffProfile::BASELINE )\n    {\n        m_bNeedsRewrite = true;\n\n        // If we have existing geokeys, try to wipe them\n        // by writing a dummy geokey directory. (#2546)\n        GTiffWriteDummyGeokeyDirectory(m_hTIFF);\n\n        GTIF *psGTIF = GTiffDatasetGTIFNew( m_hTIFF );\n\n        // Set according to coordinate system.\n        if( bHasProjection )\n        {\n            char* pszProjection = nullptr;\n            {\n                CPLErrorStateBackuper oErrorStateBackuper;\n                CPLErrorHandlerPusher oErrorHandler(CPLQuietErrorHandler);\n                m_oSRS.exportToWkt(&pszProjection);\n            }\n            if( pszProjection && pszProjection[0] &&\n                strstr(pszProjection, \"custom_proj4\") == nullptr )\n            {\n                GTIFSetFromOGISDefnEx( psGTIF, pszProjection,\n                                       m_eGeoTIFFKeysFlavor,\n                                       m_eGeoTIFFVersion );\n            }\n            else\n            {\n                GDALPamDataset::SetSpatialRef(&m_oSRS);\n            }\n            CPLFree(pszProjection);\n        }\n\n        if( bPixelIsPoint )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n}\n\n/************************************************************************/\n/*                         AppendMetadataItem()                         */\n/************************************************************************/\n\nstatic void AppendMetadataItem( CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail,\n                                const char *pszKey, const char *pszValue,\n                                int nBand, const char *pszRole,\n                                const char *pszDomain )\n\n{\n/* -------------------------------------------------------------------- */\n/*      Create the Item element, and subcomponents.                     */\n/* -------------------------------------------------------------------- */\n    CPLXMLNode *psItem = CPLCreateXMLNode( nullptr, CXT_Element, \"Item\" );\n    CPLCreateXMLNode( CPLCreateXMLNode( psItem, CXT_Attribute, \"name\"),\n                      CXT_Text, pszKey );\n\n    if( nBand > 0 )\n    {\n        char szBandId[32] = {};\n        snprintf( szBandId, sizeof(szBandId), \"%d\", nBand - 1 );\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"sample\"),\n                          CXT_Text, szBandId );\n    }\n\n    if( pszRole != nullptr )\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"role\"),\n                          CXT_Text, pszRole );\n\n    if( pszDomain != nullptr && strlen(pszDomain) > 0 )\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"domain\"),\n                          CXT_Text, pszDomain );\n\n    char *pszEscapedItemValue = CPLEscapeString(pszValue,-1,CPLES_XML);\n    CPLCreateXMLNode( psItem, CXT_Text, pszEscapedItemValue );\n    CPLFree( pszEscapedItemValue );\n\n/* -------------------------------------------------------------------- */\n/*      Create root, if missing.                                        */\n/* -------------------------------------------------------------------- */\n    if( *ppsRoot == nullptr )\n        *ppsRoot = CPLCreateXMLNode( nullptr, CXT_Element, \"GDALMetadata\" );\n\n/* -------------------------------------------------------------------- */\n/*      Append item to tail.  We keep track of the tail to avoid        */\n/*      O(nsquared) time as the list gets longer.                       */\n/* -------------------------------------------------------------------- */\n    if( *ppsTail == nullptr )\n        CPLAddXMLChild( *ppsRoot, psItem );\n    else\n        CPLAddXMLSibling( *ppsTail, psItem );\n\n    *ppsTail = psItem;\n}\n\n/************************************************************************/\n/*                         WriteMDMetadata()                            */\n/************************************************************************/\n\nstatic void WriteMDMetadata( GDALMultiDomainMetadata *poMDMD, TIFF *hTIFF,\n                             CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail,\n                             int nBand, GTiffProfile eProfile )\n\n{\n\n/* ==================================================================== */\n/*      Process each domain.                                            */\n/* ==================================================================== */\n    char **papszDomainList = poMDMD->GetDomainList();\n    for( int iDomain = 0;\n         papszDomainList && papszDomainList[iDomain];\n         ++iDomain )\n    {\n        char **papszMD = poMDMD->GetMetadata( papszDomainList[iDomain] );\n        bool bIsXML = false;\n\n        if( EQUAL(papszDomainList[iDomain], \"IMAGE_STRUCTURE\") )\n            continue;  // Ignored.\n        if( EQUAL(papszDomainList[iDomain], \"COLOR_PROFILE\") )\n            continue;  // Ignored.\n        if( EQUAL(papszDomainList[iDomain], MD_DOMAIN_RPC) )\n            continue;  // Handled elsewhere.\n        if( EQUAL(papszDomainList[iDomain], \"xml:ESRI\")\n            && CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n            continue;  // Handled elsewhere.\n        if( EQUAL(papszDomainList[iDomain], \"xml:XMP\") )\n            continue;  // Handled in SetMetadata.\n\n        if( STARTS_WITH_CI(papszDomainList[iDomain], \"xml:\") )\n            bIsXML = true;\n\n/* -------------------------------------------------------------------- */\n/*      Process each item in this domain.                               */\n/* -------------------------------------------------------------------- */\n        for( int iItem = 0; papszMD && papszMD[iItem]; ++iItem )\n        {\n            const char *pszItemValue = nullptr;\n            char *pszItemName = nullptr;\n\n            if( bIsXML )\n            {\n                pszItemName = CPLStrdup(\"doc\");\n                pszItemValue = papszMD[iItem];\n            }\n            else\n            {\n                pszItemValue = CPLParseNameValue( papszMD[iItem], &pszItemName);\n                if( pszItemName == nullptr )\n                {\n                    CPLDebug( \"GTiff\",\n                              \"Invalid metadata item : %s\", papszMD[iItem] );\n                    continue;\n                }\n            }\n\n/* -------------------------------------------------------------------- */\n/*      Convert into XML item or handle as a special TIFF tag.          */\n/* -------------------------------------------------------------------- */\n            if( strlen(papszDomainList[iDomain]) == 0\n                && nBand == 0 &&\n                (STARTS_WITH_CI(pszItemName, \"TIFFTAG_\") ||\n                 (EQUAL(pszItemName, \"GEO_METADATA\") &&\n                  eProfile == GTiffProfile::GDALGEOTIFF) ||\n                 (EQUAL(pszItemName, \"TIFF_RSID\") &&\n                  eProfile == GTiffProfile::GDALGEOTIFF)) )\n            {\n                if( EQUAL(pszItemName, \"TIFFTAG_RESOLUTIONUNIT\") )\n                {\n                    // ResolutionUnit can't be 0, which is the default if\n                    // atoi() fails.  Set to 1=Unknown.\n                    int v = atoi(pszItemValue);\n                    if( !v ) v = RESUNIT_NONE;\n                    TIFFSetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, v);\n                }\n                else\n                {\n                    bool bFoundTag = false;\n                    size_t iTag = 0;  // Used after for.\n                    for( ;\n                         iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n                         ++iTag )\n                    {\n                        if( EQUAL(pszItemName, asTIFFTags[iTag].pszTagName) )\n                        {\n                            bFoundTag = true;\n                            break;\n                        }\n                    }\n\n                    if( bFoundTag &&\n                        asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      pszItemValue );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      CPLAtof(pszItemValue) );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      atoi(pszItemValue) );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING )\n                    {\n                        uint32 nLen = static_cast<uint32>(strlen(pszItemValue));\n                        if( nLen )\n                        {\n                            TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                          nLen,\n                                          pszItemValue );\n                        }\n                    }\n                    else\n                        CPLError(\n                            CE_Warning, CPLE_NotSupported,\n                            \"%s metadata item is unhandled and \"\n                            \"will not be written\",\n                            pszItemName);\n                }\n            }\n            else if( nBand == 0 && EQUAL(pszItemName,GDALMD_AREA_OR_POINT) )\n            {\n                /* Do nothing, handled elsewhere. */;\n            }\n            else\n            {\n                AppendMetadataItem( ppsRoot, ppsTail,\n                                    pszItemName, pszItemValue,\n                                    nBand, nullptr, papszDomainList[iDomain] );\n            }\n\n            CPLFree( pszItemName );\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Remove TIFFTAG_xxxxxx that are already set but no longer in     */\n/*      the metadata list (#5619)                                       */\n/* -------------------------------------------------------------------- */\n        if( strlen(papszDomainList[iDomain]) == 0 && nBand == 0 )\n        {\n            for( size_t iTag = 0;\n                 iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n                 ++iTag )\n            {\n                uint32 nCount = 0;\n                char* pszText = nullptr;\n                int16 nVal = 0;\n                float fVal = 0.0f;\n                const char* pszVal =\n                    CSLFetchNameValue(papszMD, asTIFFTags[iTag].pszTagName);\n                if( pszVal == nullptr &&\n                    ((asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                    &pszText )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &nVal )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &fVal )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &nCount, &pszText ))) )\n                {\n                    TIFFUnsetField( hTIFF, asTIFFTags[iTag].nTagVal );\n                }\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                           WriteRPC()                                 */\n/************************************************************************/\n\nvoid GTiffDataset::WriteRPC( GDALDataset *poSrcDS, TIFF *l_hTIFF,\n                             int bSrcIsGeoTIFF,\n                             GTiffProfile eProfile,\n                             const char *pszTIFFFilename,\n                             char **l_papszCreationOptions,\n                             bool bWriteOnlyInPAMIfNeeded )\n{\n/* -------------------------------------------------------------------- */\n/*      Handle RPC data written to TIFF RPCCoefficient tag, RPB file,   */\n/*      RPCTEXT file or PAM.                                            */\n/* -------------------------------------------------------------------- */\n    char **papszRPCMD = poSrcDS->GetMetadata(MD_DOMAIN_RPC);\n    if( papszRPCMD != nullptr )\n    {\n        bool bRPCSerializedOtherWay = false;\n\n        if( eProfile == GTiffProfile::GDALGEOTIFF )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GTiffDatasetWriteRPCTag( l_hTIFF, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        // Write RPB file if explicitly asked, or if a non GDAL specific\n        // profile is selected and RPCTXT is not asked.\n        bool bRPBExplicitlyAsked =\n            CPLFetchBool( l_papszCreationOptions, \"RPB\", false );\n        bool bRPBExplicitlyDenied =\n            !CPLFetchBool( l_papszCreationOptions, \"RPB\", true );\n        if( (eProfile != GTiffProfile::GDALGEOTIFF &&\n             !CPLFetchBool( l_papszCreationOptions, \"RPCTXT\", false ) &&\n             !bRPBExplicitlyDenied )\n            || bRPBExplicitlyAsked )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GDALWriteRPBFile( pszTIFFFilename, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        if( CPLFetchBool( l_papszCreationOptions, \"RPCTXT\", false ) )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GDALWriteRPCTXTFile( pszTIFFFilename, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        if( !bRPCSerializedOtherWay && bWriteOnlyInPAMIfNeeded &&\n            bSrcIsGeoTIFF )\n            cpl::down_cast<GTiffDataset*>(poSrcDS)->\n                GDALPamDataset::SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n    }\n}\n\n/************************************************************************/\n/*                  IsStandardColorInterpretation()                     */\n/************************************************************************/\n\nstatic bool IsStandardColorInterpretation(GDALDataset* poSrcDS,\n                                          uint16 nPhotometric,\n                                          char** papszCreationOptions)\n{\n    bool bStardardColorInterp = true;\n    if( nPhotometric == PHOTOMETRIC_MINISBLACK )\n    {\n        for( int i = 0; i < poSrcDS->GetRasterCount(); ++i )\n        {\n            const GDALColorInterp eInterp =\n                poSrcDS->GetRasterBand(i + 1)->GetColorInterpretation();\n            if( !(eInterp == GCI_GrayIndex || eInterp == GCI_Undefined ||\n                    (i > 0 && eInterp == GCI_AlphaBand)) )\n            {\n                bStardardColorInterp = false;\n                break;\n            }\n        }\n    }\n    else if( nPhotometric == PHOTOMETRIC_PALETTE )\n    {\n        bStardardColorInterp =\n            poSrcDS->GetRasterBand(1)->GetColorInterpretation() ==\n                GCI_PaletteIndex;\n    }\n    else if( nPhotometric == PHOTOMETRIC_RGB )\n    {\n        int iStart = 0;\n        if( EQUAL(CSLFetchNameValueDef(papszCreationOptions,\n                                       \"PHOTOMETRIC\", \"\"), \"RGB\") )\n        {\n            iStart = 3;\n            if( poSrcDS->GetRasterCount() == 4 &&\n                CSLFetchNameValue(papszCreationOptions, \"ALPHA\") != nullptr )\n            {\n                iStart = 4;\n            }\n        }\n        for( int i = iStart; i < poSrcDS->GetRasterCount(); ++i )\n        {\n            const GDALColorInterp eInterp =\n                poSrcDS->GetRasterBand(i+1)->GetColorInterpretation();\n            if( !((i == 0 && eInterp == GCI_RedBand) ||\n                    (i == 1 && eInterp == GCI_GreenBand) ||\n                    (i == 2 && eInterp == GCI_BlueBand) ||\n                    (i >= 3 && (eInterp == GCI_Undefined ||\n                                eInterp == GCI_AlphaBand))) )\n            {\n                bStardardColorInterp = false;\n                break;\n            }\n        }\n    }\n    else if( nPhotometric == PHOTOMETRIC_YCBCR &&\n             poSrcDS->GetRasterCount() == 3 )\n    {\n        // do nothing\n    }\n    else\n    {\n        bStardardColorInterp = false;\n    }\n    return bStardardColorInterp;\n}\n\n/************************************************************************/\n/*                           WriteMetadata()                            */\n/************************************************************************/\n\nbool GTiffDataset::WriteMetadata( GDALDataset *poSrcDS, TIFF *l_hTIFF,\n                                  bool bSrcIsGeoTIFF,\n                                  GTiffProfile eProfile,\n                                  const char *pszTIFFFilename,\n                                  char **l_papszCreationOptions,\n                                  bool bExcludeRPBandIMGFileWriting)\n\n{\n/* -------------------------------------------------------------------- */\n/*      Convert all the remaining metadata into a simple XML            */\n/*      format.                                                         */\n/* -------------------------------------------------------------------- */\n    CPLXMLNode *psRoot = nullptr;\n    CPLXMLNode *psTail = nullptr;\n\n    if( bSrcIsGeoTIFF )\n    {\n        GTiffDataset* poSrcDSGTiff = cpl::down_cast<GTiffDataset *>(poSrcDS);\n        assert(poSrcDSGTiff);\n        WriteMDMetadata(\n            &poSrcDSGTiff->m_oGTiffMDMD,\n            l_hTIFF, &psRoot, &psTail, 0, eProfile );\n    }\n    else\n    {\n        char **papszMD = poSrcDS->GetMetadata();\n\n        if( CSLCount(papszMD) > 0 )\n        {\n            GDALMultiDomainMetadata l_oMDMD;\n            l_oMDMD.SetMetadata( papszMD );\n\n            WriteMDMetadata( &l_oMDMD, l_hTIFF, &psRoot, &psTail,\n                             0, eProfile );\n        }\n    }\n\n    if( !bExcludeRPBandIMGFileWriting )\n    {\n        WriteRPC(poSrcDS, l_hTIFF, bSrcIsGeoTIFF,\n                 eProfile, pszTIFFFilename,\n                 l_papszCreationOptions);\n\n/* -------------------------------------------------------------------- */\n/*      Handle metadata data written to an IMD file.                    */\n/* -------------------------------------------------------------------- */\n        char **papszIMDMD = poSrcDS->GetMetadata(MD_DOMAIN_IMD);\n        if( papszIMDMD != nullptr )\n        {\n            GDALWriteIMDFile( pszTIFFFilename, papszIMDMD );\n        }\n    }\n\n    uint16 nPhotometric = 0;\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    const bool bStardardColorInterp =\n        IsStandardColorInterpretation(poSrcDS, nPhotometric,\n                                      l_papszCreationOptions);\n\n/* -------------------------------------------------------------------- */\n/*      We also need to address band specific metadata, and special     */\n/*      \"role\" metadata.                                                */\n/* -------------------------------------------------------------------- */\n    for( int nBand = 1; nBand <= poSrcDS->GetRasterCount(); ++nBand )\n    {\n        GDALRasterBand *poBand = poSrcDS->GetRasterBand( nBand );\n\n        if( bSrcIsGeoTIFF )\n        {\n            GTiffRasterBand* poSrcBandGTiff = cpl::down_cast<GTiffRasterBand *>(poBand);\n            assert(poSrcBandGTiff);\n            WriteMDMetadata(\n                &poSrcBandGTiff->m_oGTiffMDMD,\n                l_hTIFF, &psRoot, &psTail, nBand, eProfile );\n        }\n        else\n        {\n            char **papszMD = poBand->GetMetadata();\n\n            if( CSLCount(papszMD) > 0 )\n            {\n                GDALMultiDomainMetadata l_oMDMD;\n                l_oMDMD.SetMetadata( papszMD );\n\n                WriteMDMetadata( &l_oMDMD, l_hTIFF, &psRoot, &psTail, nBand,\n                                 eProfile );\n            }\n        }\n\n        const double dfOffset = poBand->GetOffset();\n        const double dfScale = poBand->GetScale();\n        bool bGeoTIFFScaleOffsetInZ = false;\n        double adfGeoTransform[6];\n        // Check if we have already encoded scale/offset in the GeoTIFF tags\n        if( poSrcDS->GetGeoTransform(adfGeoTransform) == CE_None &&\n            adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0\n            && adfGeoTransform[5] < 0.0 &&\n            poSrcDS->GetSpatialRef() &&\n            poSrcDS->GetSpatialRef()->IsVertical() &&\n            poSrcDS->GetRasterCount() == 1 )\n        {\n            bGeoTIFFScaleOffsetInZ = true;\n        }\n\n        if( (dfOffset != 0.0 || dfScale != 1.0) && !bGeoTIFFScaleOffsetInZ )\n        {\n            char szValue[128] = {};\n\n            CPLsnprintf( szValue, sizeof(szValue), \"%.18g\", dfOffset );\n            AppendMetadataItem( &psRoot, &psTail, \"OFFSET\", szValue, nBand,\n                                \"offset\", \"\" );\n            CPLsnprintf( szValue, sizeof(szValue), \"%.18g\", dfScale );\n            AppendMetadataItem( &psRoot, &psTail, \"SCALE\", szValue, nBand,\n                                \"scale\", \"\" );\n        }\n\n        const char* pszUnitType = poBand->GetUnitType();\n        if( pszUnitType != nullptr && pszUnitType[0] != '\\0' )\n        {\n            bool bWriteUnit = true;\n            auto poSRS = poSrcDS->GetSpatialRef();\n            if( poSRS && poSRS->IsCompound() )\n            {\n                const char* pszVertUnit = nullptr;\n                poSRS->GetTargetLinearUnits(\"COMPD_CS|VERT_CS\", &pszVertUnit);\n                if( pszVertUnit && EQUAL(pszVertUnit, pszUnitType) )\n                {\n                    bWriteUnit = false;\n                }\n            }\n            if( bWriteUnit )\n            {\n                AppendMetadataItem( &psRoot, &psTail, \"UNITTYPE\",\n                                    pszUnitType, nBand,\n                                    \"unittype\", \"\" );\n            }\n        }\n\n        if( strlen(poBand->GetDescription()) > 0 )\n        {\n            AppendMetadataItem( &psRoot, &psTail, \"DESCRIPTION\",\n                                poBand->GetDescription(), nBand,\n                                \"description\", \"\" );\n        }\n\n        if( !bStardardColorInterp &&\n            !(nBand <= 3 &&  EQUAL(CSLFetchNameValueDef(\n                l_papszCreationOptions, \"PHOTOMETRIC\", \"\"), \"RGB\") ) )\n        {\n            AppendMetadataItem( &psRoot, &psTail, \"COLORINTERP\",\n                                GDALGetColorInterpretationName(\n                                    poBand->GetColorInterpretation()),\n                                nBand,\n                                \"colorinterp\", \"\" );\n        }\n    }\n\n    const char* pszTilingSchemeName =\n        CSLFetchNameValue(l_papszCreationOptions, \"@TILING_SCHEME_NAME\");\n    if( pszTilingSchemeName )\n    {\n        AppendMetadataItem( &psRoot, &psTail,\n                            \"NAME\", pszTilingSchemeName,\n                            0, nullptr, \"TILING_SCHEME\" );\n\n        const char* pszZoomLevel = CSLFetchNameValue(\n            l_papszCreationOptions, \"@TILING_SCHEME_ZOOM_LEVEL\");\n        if( pszZoomLevel )\n        {\n            AppendMetadataItem( &psRoot, &psTail,\n                                \"ZOOM_LEVEL\", pszZoomLevel,\n                                0, nullptr, \"TILING_SCHEME\" );\n        }\n\n        const char* pszAlignedLevels = CSLFetchNameValue(\n            l_papszCreationOptions, \"@TILING_SCHEME_ALIGNED_LEVELS\");\n        if( pszAlignedLevels )\n        {\n            AppendMetadataItem( &psRoot, &psTail,\n                                \"ALIGNED_LEVELS\", pszAlignedLevels,\n                                0, nullptr, \"TILING_SCHEME\" );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the generic XML metadata if there is any.             */\n/* -------------------------------------------------------------------- */\n    if( psRoot != nullptr )\n    {\n        bool bRet = true;\n\n        if( eProfile == GTiffProfile::GDALGEOTIFF )\n        {\n            char *pszXML_MD = CPLSerializeXMLTree( psRoot );\n            if( strlen(pszXML_MD) > 32000 )\n            {\n                if( bSrcIsGeoTIFF )\n                {\n                    if( cpl::down_cast<GTiffDataset *>(\n                           poSrcDS)->GetPamFlags() & GPF_DISABLED )\n                    {\n                        ReportError(\n                            pszTIFFFilename, CE_Warning, CPLE_AppDefined,\n                            \"Metadata exceeding 32000 bytes cannot be written \"\n                            \"into GeoTIFF.\" );\n                    }\n                    else\n                    {\n                        cpl::down_cast<GTiffDataset *>(poSrcDS)->\n                            PushMetadataToPam();\n                        ReportError(\n                            pszTIFFFilename, CE_Warning, CPLE_AppDefined,\n                            \"Metadata exceeding 32000 bytes cannot be written \"\n                            \"into GeoTIFF. Transferred to PAM instead.\" );\n                    }\n                }\n                else\n                {\n                    bRet = false;\n                }\n            }\n            else\n            {\n                TIFFSetField( l_hTIFF, TIFFTAG_GDAL_METADATA, pszXML_MD );\n            }\n            CPLFree( pszXML_MD );\n        }\n        else\n        {\n            if( bSrcIsGeoTIFF )\n                cpl::down_cast<GTiffDataset *>(poSrcDS)->PushMetadataToPam();\n            else\n                bRet = false;\n        }\n\n        CPLDestroyXMLNode( psRoot );\n\n        return bRet;\n    }\n\n    // If we have no more metadata but it existed before,\n    // remove the GDAL_METADATA tag.\n    if( eProfile == GTiffProfile::GDALGEOTIFF )\n    {\n        char* pszText = nullptr;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n        {\n            TIFFUnsetField( l_hTIFF, TIFFTAG_GDAL_METADATA );\n        }\n    }\n\n    return true;\n}\n\n/************************************************************************/\n/*                         PushMetadataToPam()                          */\n/*                                                                      */\n/*      When producing a strict profile TIFF or if our aggregate        */\n/*      metadata is too big for a single tiff tag we may end up         */\n/*      needing to write it via the PAM mechanisms.  This method        */\n/*      copies all the appropriate metadata into the PAM level          */\n/*      metadata object but with special care to avoid copying          */\n/*      metadata handled in other ways in TIFF format.                  */\n/************************************************************************/\n\nvoid GTiffDataset::PushMetadataToPam()\n\n{\n    if( GetPamFlags() & GPF_DISABLED )\n        return;\n\n    const bool bStardardColorInterp =\n        IsStandardColorInterpretation(this, m_nPhotometric, m_papszCreationOptions);\n\n    for( int nBand = 0; nBand <= GetRasterCount(); ++nBand )\n    {\n        GDALMultiDomainMetadata *poSrcMDMD = nullptr;\n        GTiffRasterBand *poBand = nullptr;\n\n        if( nBand == 0 )\n        {\n            poSrcMDMD = &(this->m_oGTiffMDMD);\n        }\n        else\n        {\n            poBand = cpl::down_cast<GTiffRasterBand *>(GetRasterBand(nBand));\n            poSrcMDMD = &(poBand->m_oGTiffMDMD);\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Loop over the available domains.                                */\n/* -------------------------------------------------------------------- */\n        char **papszDomainList = poSrcMDMD->GetDomainList();\n        for( int iDomain = 0;\n             papszDomainList && papszDomainList[iDomain];\n             ++iDomain )\n        {\n            char **papszMD = poSrcMDMD->GetMetadata( papszDomainList[iDomain] );\n\n            if( EQUAL(papszDomainList[iDomain],MD_DOMAIN_RPC)\n                || EQUAL(papszDomainList[iDomain],MD_DOMAIN_IMD)\n                || EQUAL(papszDomainList[iDomain],\"_temporary_\")\n                || EQUAL(papszDomainList[iDomain],\"IMAGE_STRUCTURE\")\n                || EQUAL(papszDomainList[iDomain],\"COLOR_PROFILE\") )\n                continue;\n\n            papszMD = CSLDuplicate(papszMD);\n\n            for( int i = CSLCount(papszMD)-1; i >= 0; --i )\n            {\n                if( STARTS_WITH_CI(papszMD[i], \"TIFFTAG_\")\n                    || EQUALN(papszMD[i],GDALMD_AREA_OR_POINT,\n                              strlen(GDALMD_AREA_OR_POINT)) )\n                    papszMD = CSLRemoveStrings( papszMD, i, 1, nullptr );\n            }\n\n            if( nBand == 0 )\n                GDALPamDataset::SetMetadata( papszMD, papszDomainList[iDomain]);\n            else\n                poBand->\n                    GDALPamRasterBand::SetMetadata( papszMD,\n                                                    papszDomainList[iDomain]);\n\n            CSLDestroy( papszMD );\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Handle some \"special domain\" stuff.                             */\n/* -------------------------------------------------------------------- */\n        if( poBand != nullptr )\n        {\n            poBand->GDALPamRasterBand::SetOffset( poBand->GetOffset() );\n            poBand->GDALPamRasterBand::SetScale( poBand->GetScale() );\n            poBand->GDALPamRasterBand::SetUnitType( poBand->GetUnitType() );\n            poBand->\n                GDALPamRasterBand::SetDescription( poBand->GetDescription() );\n            if( !bStardardColorInterp )\n            {\n                poBand->GDALPamRasterBand::SetColorInterpretation(\n                                        poBand->GetColorInterpretation() );\n            }\n        }\n    }\n    MarkPamDirty();\n}\n\n/************************************************************************/\n/*                     GTiffDatasetWriteRPCTag()                        */\n/*                                                                      */\n/*      Format a TAG according to:                                      */\n/*                                                                      */\n/*      http://geotiff.maptools.org/rpc_prop.html                       */\n/************************************************************************/\n\nvoid GTiffDatasetWriteRPCTag( TIFF *hTIFF, char **papszRPCMD )\n\n{\n    GDALRPCInfo sRPC;\n\n    if( !GDALExtractRPCInfo( papszRPCMD, &sRPC ) )\n        return;\n\n    double adfRPCTag[92] = {};\n    adfRPCTag[0] = -1.0;  // Error Bias\n    adfRPCTag[1] = -1.0;  // Error Random\n\n    adfRPCTag[2] = sRPC.dfLINE_OFF;\n    adfRPCTag[3] = sRPC.dfSAMP_OFF;\n    adfRPCTag[4] = sRPC.dfLAT_OFF;\n    adfRPCTag[5] = sRPC.dfLONG_OFF;\n    adfRPCTag[6] = sRPC.dfHEIGHT_OFF;\n    adfRPCTag[7] = sRPC.dfLINE_SCALE;\n    adfRPCTag[8] = sRPC.dfSAMP_SCALE;\n    adfRPCTag[9] = sRPC.dfLAT_SCALE;\n    adfRPCTag[10] = sRPC.dfLONG_SCALE;\n    adfRPCTag[11] = sRPC.dfHEIGHT_SCALE;\n\n    memcpy( adfRPCTag + 12, sRPC.adfLINE_NUM_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 32, sRPC.adfLINE_DEN_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 52, sRPC.adfSAMP_NUM_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 72, sRPC.adfSAMP_DEN_COEFF, sizeof(double) * 20 );\n\n    TIFFSetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, 92, adfRPCTag );\n}\n\n/************************************************************************/\n/*                             ReadRPCTag()                             */\n/*                                                                      */\n/*      Format a TAG according to:                                      */\n/*                                                                      */\n/*      http://geotiff.maptools.org/rpc_prop.html                       */\n/************************************************************************/\n\nchar** GTiffDatasetReadRPCTag(TIFF* hTIFF)\n\n{\n    double *padfRPCTag = nullptr;\n    uint16 nCount;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, &nCount, &padfRPCTag )\n        || nCount != 92 )\n        return nullptr;\n\n    CPLStringList asMD;\n    asMD.SetNameValue(RPC_LINE_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[2]));\n    asMD.SetNameValue(RPC_SAMP_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[3]));\n    asMD.SetNameValue(RPC_LAT_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[4]));\n    asMD.SetNameValue(RPC_LONG_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[5]));\n    asMD.SetNameValue(RPC_HEIGHT_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[6]));\n    asMD.SetNameValue(RPC_LINE_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[7]));\n    asMD.SetNameValue(RPC_SAMP_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[8]));\n    asMD.SetNameValue(RPC_LAT_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[9]));\n    asMD.SetNameValue(RPC_LONG_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[10]));\n    asMD.SetNameValue(RPC_HEIGHT_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[11]));\n\n    CPLString osField;\n    CPLString osMultiField;\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[12+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue(RPC_LINE_NUM_COEFF, osMultiField );\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[32+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_LINE_DEN_COEFF, osMultiField );\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[52+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_SAMP_NUM_COEFF, osMultiField );\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[72+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_SAMP_DEN_COEFF, osMultiField );\n\n    return asMD.StealList();\n}\n\n/************************************************************************/\n/*                  GTiffFormatGDALNoDataTagValue()                     */\n/************************************************************************/\n\nCPLString GTiffFormatGDALNoDataTagValue( double dfNoData )\n{\n    CPLString osVal;\n    if( CPLIsNan(dfNoData) )\n        osVal = \"nan\";\n    else\n        osVal.Printf(\"%.18g\", dfNoData);\n    return osVal;\n}\n\n/************************************************************************/\n/*                         WriteNoDataValue()                           */\n/************************************************************************/\n\nvoid GTiffDataset::WriteNoDataValue( TIFF *l_hTIFF, double dfNoData )\n\n{\n    CPLString osVal( GTiffFormatGDALNoDataTagValue(dfNoData) );\n    TIFFSetField( l_hTIFF, TIFFTAG_GDAL_NODATA, osVal.c_str() );\n}\n\n/************************************************************************/\n/*                         UnsetNoDataValue()                           */\n/************************************************************************/\n\nvoid GTiffDataset::UnsetNoDataValue( TIFF *l_hTIFF )\n\n{\n    TIFFUnsetField( l_hTIFF, TIFFTAG_GDAL_NODATA );\n}\n\n/************************************************************************/\n/*                            SetDirectory()                            */\n/************************************************************************/\n\nbool GTiffDataset::SetDirectory()\n\n{\n    Crystalize();\n\n    if( TIFFCurrentDirOffset(m_hTIFF) == m_nDirOffset )\n    {\n        return true;\n    }\n\n    const int nSetDirResult = TIFFSetSubDirectory( m_hTIFF, m_nDirOffset );\n    if( !nSetDirResult )\n        return false;\n\n    RestoreVolatileParameters( m_hTIFF );\n\n    return true;\n}\n\n/************************************************************************/\n/*                     GTiffSetDeflateSubCodec()                        */\n/************************************************************************/\n\nstatic void GTiffSetDeflateSubCodec(TIFF* hTIFF)\n{\n    (void)hTIFF;\n\n#if defined(TIFFTAG_DEFLATE_SUBCODEC) && defined(LIBDEFLATE_SUPPORT)\n    // Mostly for strict reproducibility purposes\n    if( EQUAL(CPLGetConfigOption(\"GDAL_TIFF_DEFLATE_SUBCODEC\", \"\"), \"ZLIB\") )\n    {\n        TIFFSetField(hTIFF, TIFFTAG_DEFLATE_SUBCODEC,\n                     DEFLATE_SUBCODEC_ZLIB);\n    }\n#endif\n}\n\n/************************************************************************/\n/*                     RestoreVolatileParameters()                      */\n/************************************************************************/\n\nvoid GTiffDataset::RestoreVolatileParameters(TIFF* hTIFF)\n{\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( m_nCompression == COMPRESSION_JPEG\n        && m_nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode = JPEGCOLORMODE_RAW;  // Initialize to 0;\n\n        TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode );\n        if( nColorMode != JPEGCOLORMODE_RGB )\n        {\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n    }\n\n    if( m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        m_nCompression == COMPRESSION_LERC )\n    {\n        GTiffSetDeflateSubCodec(hTIFF);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Propagate any quality settings.                                 */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() == GA_Update )\n    {\n        // Now, reset zip and jpeg quality.\n        if(m_nJpegQuality > 0 && m_nCompression == COMPRESSION_JPEG)\n        {\n#ifdef DEBUG_VERBOSE\n            CPLDebug( \"GTiff\", \"Propagate JPEG_QUALITY(%d) in SetDirectory()\",\n                      m_nJpegQuality );\n#endif\n            TIFFSetField(hTIFF, TIFFTAG_JPEGQUALITY, m_nJpegQuality);\n        }\n        if(m_nJpegTablesMode >= 0 && m_nCompression == COMPRESSION_JPEG)\n            TIFFSetField(hTIFF, TIFFTAG_JPEGTABLESMODE, m_nJpegTablesMode);\n        if(m_nZLevel > 0 && (m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n                           m_nCompression == COMPRESSION_LERC) )\n            TIFFSetField(hTIFF, TIFFTAG_ZIPQUALITY, m_nZLevel);\n        if(m_nLZMAPreset > 0 && m_nCompression == COMPRESSION_LZMA)\n            TIFFSetField(hTIFF, TIFFTAG_LZMAPRESET, m_nLZMAPreset);\n        if( m_nZSTDLevel > 0 && (m_nCompression == COMPRESSION_ZSTD ||\n                               m_nCompression == COMPRESSION_LERC) )\n            TIFFSetField(hTIFF, TIFFTAG_ZSTD_LEVEL, m_nZSTDLevel);\n#if HAVE_LERC\n        if( m_nCompression == COMPRESSION_LERC )\n        {\n            TIFFSetField(hTIFF, TIFFTAG_LERC_MAXZERROR, m_dfMaxZError);\n        }\n#endif\n        if( m_nWebPLevel > 0 && m_nCompression == COMPRESSION_WEBP)\n            TIFFSetField(hTIFF, TIFFTAG_WEBP_LEVEL, m_nWebPLevel);\n        if( m_bWebPLossless && m_nCompression == COMPRESSION_WEBP)\n            TIFFSetField(hTIFF, TIFFTAG_WEBP_LOSSLESS, 1);\n    }\n}\n\n/************************************************************************/\n/*                              Identify()                              */\n/************************************************************************/\n\nint GTiffDataset::Identify( GDALOpenInfo *poOpenInfo )\n\n{\n    const char *pszFilename = poOpenInfo->pszFilename;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        pszFilename += strlen(\"GTIFF_RAW:\");\n        GDALOpenInfo oOpenInfo( pszFilename, poOpenInfo->eAccess );\n        return Identify(&oOpenInfo);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") )\n        return TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      First we check to see if the file has the expected header       */\n/*      bytes.                                                          */\n/* -------------------------------------------------------------------- */\n    if( poOpenInfo->fpL == nullptr || poOpenInfo->nHeaderBytes < 2 )\n        return FALSE;\n\n    if( (poOpenInfo->pabyHeader[0] != 'I' || poOpenInfo->pabyHeader[1] != 'I')\n        && (poOpenInfo->pabyHeader[0] != 'M'\n        || poOpenInfo->pabyHeader[1] != 'M'))\n        return FALSE;\n\n    if( (poOpenInfo->pabyHeader[2] != 0x2A || poOpenInfo->pabyHeader[3] != 0)\n        && (poOpenInfo->pabyHeader[3] != 0x2A || poOpenInfo->pabyHeader[2] != 0)\n        && (poOpenInfo->pabyHeader[2] != 0x2B || poOpenInfo->pabyHeader[3] != 0)\n        && (poOpenInfo->pabyHeader[3] != 0x2B ||\n            poOpenInfo->pabyHeader[2] != 0))\n        return FALSE;\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*                          GTIFFExtendMemoryFile()                     */\n/************************************************************************/\n\nstatic bool GTIFFExtendMemoryFile( const CPLString& osTmpFilename,\n                                   VSILFILE* fpTemp,\n                                   VSILFILE* fpL,\n                                   int nNewLength,\n                                   GByte*& pabyBuffer,\n                                   vsi_l_offset& nDataLength )\n{\n    if( nNewLength <= static_cast<int>(nDataLength) )\n        return true;\n    if( VSIFSeekL(fpTemp, nNewLength - 1, SEEK_SET) != 0 )\n        return false;\n    char ch = 0;\n    if( VSIFWriteL(&ch, 1, 1, fpTemp) != 1 )\n        return false;\n    const int nOldDataLength = static_cast<int>(nDataLength);\n    pabyBuffer = static_cast<GByte*>(\n        VSIGetMemFileBuffer( osTmpFilename, &nDataLength, FALSE) );\n    const int nToRead = nNewLength - nOldDataLength;\n    const int nRead = static_cast<int>(\n        VSIFReadL( pabyBuffer + nOldDataLength, 1, nToRead, fpL) );\n    if( nRead != nToRead )\n    {\n        CPLError(CE_Failure, CPLE_FileIO,\n                 \"Needed to read %d bytes. Only %d got\", nToRead, nRead);\n        return false;\n    }\n    return true;\n}\n\n/************************************************************************/\n/*                         GTIFFMakeBufferedStream()                    */\n/************************************************************************/\n\nstatic bool GTIFFMakeBufferedStream(GDALOpenInfo* poOpenInfo)\n{\n    CPLString osTmpFilename;\n    static int nCounter = 0;\n    osTmpFilename.Printf(\"/vsimem/stream_%d.tif\", ++nCounter);\n    VSILFILE* fpTemp = VSIFOpenL(osTmpFilename, \"wb+\");\n    if( fpTemp == nullptr )\n        return false;\n    // The seek is needed for /vsistdin/ that has some rewind capabilities.\n    if( VSIFSeekL(poOpenInfo->fpL, poOpenInfo->nHeaderBytes, SEEK_SET) != 0 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        return false;\n    }\n    CPLAssert( static_cast<int>( VSIFTellL(poOpenInfo->fpL) ) ==\n               poOpenInfo->nHeaderBytes );\n    if( VSIFWriteL(poOpenInfo->pabyHeader, poOpenInfo->nHeaderBytes,\n                   1, fpTemp) != 1 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        return false;\n    }\n    vsi_l_offset nDataLength = 0;\n    GByte* pabyBuffer =\n        static_cast<GByte*>(\n            VSIGetMemFileBuffer( osTmpFilename, &nDataLength, FALSE) );\n    const bool bLittleEndian = (pabyBuffer[0] == 'I');\n#if CPL_IS_LSB\n    const bool bSwap = !bLittleEndian;\n#else\n    const bool bSwap = bLittleEndian;\n#endif\n    const bool bBigTIFF = pabyBuffer[2] == 43 || pabyBuffer[3] == 43;\n    vsi_l_offset nMaxOffset = 0;\n    if( bBigTIFF )\n    {\n        GUInt64 nTmp = 0;\n        memcpy(&nTmp, pabyBuffer + 8, 8);\n        if( bSwap ) CPL_SWAP64PTR(&nTmp);\n        if( nTmp != 16 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"IFD start should be at offset 16 for a streamed BigTIFF\");\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        memcpy(&nTmp, pabyBuffer + 16, 8);\n        if( bSwap ) CPL_SWAP64PTR(&nTmp);\n        if( nTmp > 1024 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Too many tags : \" CPL_FRMT_GIB, nTmp);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        const int nTags = static_cast<int>(nTmp);\n        const int nSpaceForTags = nTags * 20;\n        if( !GTIFFExtendMemoryFile(osTmpFilename, fpTemp, poOpenInfo->fpL,\n                                    24 + nSpaceForTags,\n                                    pabyBuffer, nDataLength) )\n        {\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        nMaxOffset = 24 + nSpaceForTags + 8;\n        for( int i = 0; i < nTags; ++i )\n        {\n            GUInt16 nTmp16 = 0;\n            memcpy(&nTmp16, pabyBuffer + 24 + i * 20, 2);\n            if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n            const int nTag = nTmp16;\n            memcpy(&nTmp16, pabyBuffer + 24 + i * 20 + 2, 2);\n            if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n            const int nDataType = nTmp16;\n            memcpy(&nTmp, pabyBuffer + 24 + i * 20 + 4, 8);\n            if( bSwap ) CPL_SWAP64PTR(&nTmp);\n            if( nTmp >= 16 * 1024 * 1024 )\n            {\n                CPLError(\n                    CE_Failure, CPLE_NotSupported,\n                    \"Too many elements for tag %d : \" CPL_FRMT_GUIB,\n                    nTag, nTmp );\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                VSIUnlink(osTmpFilename);\n                return false;\n            }\n            const GUInt32 nCount = static_cast<GUInt32>(nTmp);\n            const GUInt32 nTagSize =\n                TIFFDataWidth(static_cast<TIFFDataType>(nDataType)) * nCount;\n            if( nTagSize > 8 )\n            {\n                memcpy(&nTmp, pabyBuffer + 24 + i * 20 + 12, 8);\n                if( bSwap ) CPL_SWAP64PTR(&nTmp);\n                if( nTmp > GUINT64_MAX - nTagSize )\n                {\n                    CPLError(CE_Failure, CPLE_NotSupported,\n                             \"Overflow with tag %d\", nTag);\n                    CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                    VSIUnlink(osTmpFilename);\n                    return false;\n                }\n                if( static_cast<vsi_l_offset>(nTmp + nTagSize) > nMaxOffset )\n                    nMaxOffset = nTmp + nTagSize;\n            }\n        }\n    }\n    else\n    {\n        GUInt32 nTmp = 0;\n        memcpy(&nTmp, pabyBuffer + 4, 4);\n        if( bSwap ) CPL_SWAP32PTR(&nTmp);\n        if( nTmp != 8 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"IFD start should be at offset 8 for a streamed TIFF\");\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        GUInt16 nTmp16 = 0;\n        memcpy(&nTmp16, pabyBuffer + 8, 2);\n        if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n        if( nTmp16 > 1024 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Too many tags : %d\", nTmp16);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        const int nTags = nTmp16;\n        const int nSpaceForTags = nTags * 12;\n        if( !GTIFFExtendMemoryFile(osTmpFilename, fpTemp, poOpenInfo->fpL,\n                                   10 + nSpaceForTags,\n                                   pabyBuffer, nDataLength) )\n        {\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        nMaxOffset = 10 + nSpaceForTags + 4;\n        for( int i = 0; i < nTags; ++i )\n        {\n            memcpy(&nTmp16, pabyBuffer + 10 + i * 12, 2);\n            if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n            const int nTag = nTmp16;\n            memcpy(&nTmp16, pabyBuffer + 10 + i * 12 + 2, 2);\n            if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n            const int nDataType = nTmp16;\n            memcpy(&nTmp, pabyBuffer + 10 + i * 12 + 4, 4);\n            if( bSwap ) CPL_SWAP32PTR(&nTmp);\n            if( nTmp >= 16 * 1024 * 1024 )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"Too many elements for tag %d : %u\", nTag, nTmp);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                VSIUnlink(osTmpFilename);\n                return false;\n            }\n            const GUInt32 nCount = nTmp;\n            const GUInt32 nTagSize =\n                TIFFDataWidth(static_cast<TIFFDataType>(nDataType)) * nCount;\n            if( nTagSize > 4 )\n            {\n                memcpy(&nTmp, pabyBuffer + 10 + i * 12 + 8, 4);\n                if( bSwap ) CPL_SWAP32PTR(&nTmp);\n                if( nTmp > static_cast<GUInt32>(UINT_MAX - nTagSize) )\n                {\n                    CPLError(CE_Failure, CPLE_NotSupported,\n                             \"Overflow with tag %d\", nTag);\n                    CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                    VSIUnlink(osTmpFilename);\n                    return false;\n                }\n                if( nTmp + nTagSize > nMaxOffset )\n                    nMaxOffset = nTmp + nTagSize;\n            }\n        }\n    }\n    if( nMaxOffset > 10 * 1024 * 1024 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        VSIUnlink(osTmpFilename);\n        return false;\n    }\n    if( !GTIFFExtendMemoryFile(\n           osTmpFilename, fpTemp, poOpenInfo->fpL,\n           static_cast<int>(nMaxOffset), pabyBuffer, nDataLength) )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        VSIUnlink(osTmpFilename);\n        return false;\n    }\n    CPLAssert(nDataLength == VSIFTellL(poOpenInfo->fpL));\n    poOpenInfo->fpL = reinterpret_cast<VSILFILE *>(\n        VSICreateBufferedReaderHandle(\n            reinterpret_cast<VSIVirtualHandle*>(poOpenInfo->fpL),\n            pabyBuffer,\n            static_cast<vsi_l_offset>(INT_MAX) << 32 ) );\n    if( VSIFCloseL(fpTemp) != 0 )\n        return false;\n    VSIUnlink(osTmpFilename);\n\n    return true;\n}\n\n/************************************************************************/\n/*                       AssociateExternalMask()                        */\n/************************************************************************/\n\n// Used by GTIFFBuildOverviewsEx() for the COG driver\nbool GTiffDataset::AssociateExternalMask()\n{\n    if( m_poMaskExtOvrDS->GetRasterBand(1)->GetOverviewCount() !=\n        GetRasterBand(1)->GetOverviewCount() )\n        return false;\n    if( m_papoOverviewDS == nullptr )\n        return false;\n    if( m_poMaskDS )\n        return false;\n    if( m_poMaskExtOvrDS->GetRasterXSize() != nRasterXSize ||\n        m_poMaskExtOvrDS->GetRasterYSize() != nRasterYSize )\n        return false;\n    m_poExternalMaskDS = m_poMaskExtOvrDS.get();\n    for(int i = 0; i < m_nOverviewCount; i++ )\n    {\n        if( m_papoOverviewDS[i]->m_poMaskDS )\n            return false;\n        m_papoOverviewDS[i]->m_poExternalMaskDS =\n            m_poMaskExtOvrDS->GetRasterBand(1)->GetOverview(i)->GetDataset();\n        if( !m_papoOverviewDS[i]->m_poExternalMaskDS)\n            return false;\n        auto poOvrBand = m_papoOverviewDS[i]->GetRasterBand(1);\n        if( m_papoOverviewDS[i]->m_poExternalMaskDS->GetRasterXSize() !=\n                poOvrBand->GetXSize() ||\n            m_papoOverviewDS[i]->m_poExternalMaskDS->GetRasterYSize() !=\n                poOvrBand->GetYSize() )\n            return false;\n    }\n    return true;\n}\n\n/************************************************************************/\n/*                                Open()                                */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::Open( GDALOpenInfo * poOpenInfo )\n\n{\n    const char *pszFilename = poOpenInfo->pszFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Check if it looks like a TIFF file.                             */\n/* -------------------------------------------------------------------- */\n    if( !Identify(poOpenInfo) )\n        return nullptr;\n\n    bool bAllowRGBAInterface = true;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") )\n        return OpenDir( poOpenInfo );\n\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    // Disable strip chop for now.\n    bool bStreaming = false;\n    const char* pszReadStreaming =\n        CPLGetConfigOption(\"TIFF_READ_STREAMING\", nullptr);\n    if( poOpenInfo->fpL == nullptr )\n    {\n        poOpenInfo->fpL =\n            VSIFOpenL( pszFilename,\n                       poOpenInfo->eAccess == GA_ReadOnly ? \"rb\" : \"r+b\" );\n        if( poOpenInfo->fpL == nullptr )\n            return nullptr;\n    }\n    else if( !(pszReadStreaming && !CPLTestBool(pszReadStreaming)) &&\n             poOpenInfo->nHeaderBytes >= 24 &&\n             // A pipe has no seeking capability, so its position is 0 despite\n             // having read bytes.\n             (static_cast<int>( VSIFTellL(poOpenInfo->fpL) ) ==\n              poOpenInfo->nHeaderBytes ||\n              strcmp(pszFilename, \"/vsistdin/\") == 0 ||\n              // STARTS_WITH(pszFilename, \"/vsicurl_streaming/\") ||\n              (pszReadStreaming && CPLTestBool(pszReadStreaming))) )\n    {\n        bStreaming = true;\n        if( !GTIFFMakeBufferedStream(poOpenInfo) )\n            return nullptr;\n    }\n\n    // Store errors/warnings and emit them later.\n    std::vector<CPLErrorHandlerAccumulatorStruct> aoErrors;\n    CPLInstallErrorHandlerAccumulator(aoErrors);\n    CPLSetCurrentErrorHandlerCatchDebug( FALSE );\n    const bool bDeferStrileLoading = CPLTestBool(\n        CPLGetConfigOption(\"GTIFF_USE_DEFER_STRILE_LOADING\", \"YES\"));\n    TIFF *l_hTIFF =\n        VSI_TIFFOpen( pszFilename,\n                      poOpenInfo->eAccess == GA_ReadOnly ?\n                        ((bStreaming || !bDeferStrileLoading) ? \"r\" : \"rDO\") :\n                        (!bDeferStrileLoading ? \"r+\" : \"r+D\"),\n                      poOpenInfo->fpL );\n    CPLUninstallErrorHandlerAccumulator();\n\n    // Now emit errors and change their criticality if needed\n    // We only emit failures if we didn't manage to open the file.\n    // Otherwise it makes Python bindings unhappy (#5616).\n    for( size_t iError = 0; iError < aoErrors.size(); ++iError )\n    {\n        ReportError( pszFilename,\n                  (l_hTIFF == nullptr && aoErrors[iError].type == CE_Failure) ?\n                  CE_Failure : CE_Warning,\n                  aoErrors[iError].no,\n                  \"%s\",\n                  aoErrors[iError].msg.c_str() );\n    }\n    aoErrors.resize(0);\n\n    if( l_hTIFF == nullptr )\n        return nullptr;\n\n    uint32 nXSize = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    uint32 nYSize = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n    if( nXSize > INT_MAX || nYSize > INT_MAX )\n    {\n        // GDAL only supports signed 32bit dimensions.\n        ReportError(pszFilename, CE_Failure, CPLE_NotSupported,\n                    \"Too large image size: %u x %u\",\n                    nXSize, nYSize);\n        XTIFFClose( l_hTIFF );\n        return nullptr;\n    }\n\n    uint16 l_nCompression = 0;\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, &(l_nCompression) ) )\n        l_nCompression = COMPRESSION_NONE;\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription( pszFilename );\n    poDS->m_pszFilename = CPLStrdup(pszFilename);\n    poDS->m_fpL = poOpenInfo->fpL;\n    poOpenInfo->fpL = nullptr;\n    poDS->m_bStreamingIn = bStreaming;\n    poDS->m_nCompression = l_nCompression;\n\n    // Check structural metadata (for COG)\n    const int nOffsetOfStructuralMetadata =\n        poOpenInfo->nHeaderBytes &&\n        ((poOpenInfo->pabyHeader[2] == 0x2B ||\n         poOpenInfo->pabyHeader[3] == 0x2B )) ? 16 : 8;\n    if( poOpenInfo->nHeaderBytes > nOffsetOfStructuralMetadata +\n            static_cast<int>(strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\")) &&\n        memcmp(poOpenInfo->pabyHeader + nOffsetOfStructuralMetadata,\n               \"GDAL_STRUCTURAL_METADATA_SIZE=\",\n               strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\")) == 0 )\n    {\n        const char* pszStructuralMD = reinterpret_cast<const char*>(\n            poOpenInfo->pabyHeader + nOffsetOfStructuralMetadata);\n        poDS->m_bLayoutIFDSBeforeData = strstr(pszStructuralMD,\n                            \"LAYOUT=IFDS_BEFORE_DATA\") != nullptr;\n        poDS->m_bBlockOrderRowMajor = strstr(pszStructuralMD,\n                            \"BLOCK_ORDER=ROW_MAJOR\") != nullptr;\n        poDS->m_bLeaderSizeAsUInt4 = strstr(pszStructuralMD,\n                            \"BLOCK_LEADER=SIZE_AS_UINT4\") != nullptr;\n        poDS->m_bTrailerRepeatedLast4BytesRepeated = strstr(pszStructuralMD,\n                            \"BLOCK_TRAILER=LAST_4_BYTES_REPEATED\") != nullptr;\n        poDS->m_bMaskInterleavedWithImagery = strstr(pszStructuralMD,\n                            \"MASK_INTERLEAVED_WITH_IMAGERY=YES\") != nullptr;\n        poDS->m_bKnownIncompatibleEdition = strstr(pszStructuralMD,\n                            \"KNOWN_INCOMPATIBLE_EDITION=YES\") != nullptr;\n        if( poDS->m_bKnownIncompatibleEdition )\n        {\n            poDS->ReportError(CE_Warning, CPLE_AppDefined,\n                     \"This file used to have optimizations in its layout, \"\n                     \"but those have been, at least partly, invalidated by \"\n                     \"later changes\");\n        }\n        else if( poDS->m_bLayoutIFDSBeforeData &&\n                 poDS->m_bBlockOrderRowMajor &&\n                 poDS->m_bLeaderSizeAsUInt4 &&\n                 poDS->m_bTrailerRepeatedLast4BytesRepeated )\n        {\n            poDS->m_oGTiffMDMD.SetMetadataItem(\"LAYOUT\", \"COG\", \"IMAGE_STRUCTURE\");\n        }\n    }\n\n    // In the case of GDAL_DISABLE_READDIR_ON_OPEN = NO / EMPTY_DIR\n    if( poOpenInfo->AreSiblingFilesLoaded() &&\n        CSLCount( poOpenInfo->GetSiblingFiles() ) <= 1 )\n    {\n        poDS->oOvManager.TransferSiblingFiles( CSLDuplicate(\n                                            poOpenInfo->GetSiblingFiles() ) );\n        poDS->m_bHasGotSiblingFiles = true;\n    }\n\n    if( poDS->OpenOffset( l_hTIFF,\n                          TIFFCurrentDirOffset(l_hTIFF),\n                          poOpenInfo->eAccess,\n                          bAllowRGBAInterface, true) != CE_None )\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    // Do we want blocks that are set to zero and that haven't yet being\n    // allocated as tile/strip to remain implicit?\n    if( CPLFetchBool( poOpenInfo->papszOpenOptions, \"SPARSE_OK\", false ) )\n        poDS->m_bWriteEmptyTiles = false;\n\n    if( poOpenInfo->eAccess == GA_Update )\n    {\n        poDS->InitCreationOrOpenOptions(poOpenInfo->papszOpenOptions);\n    }\n\n    poDS->m_bLoadPam = true;\n    poDS->m_bColorProfileMetadataChanged = false;\n    poDS->m_bMetadataChanged = false;\n    poDS->m_bGeoTIFFInfoChanged = false;\n    poDS->m_bNoDataChanged = false;\n    poDS->m_bForceUnsetGTOrGCPs = false;\n    poDS->m_bForceUnsetProjection = false;\n\n    // Used by GTIFFBuildOverviewsEx() for the COG driver\n    const char* pszMaskOverviewDS = CSLFetchNameValue(poOpenInfo->papszOpenOptions,\n                                                      \"MASK_OVERVIEW_DATASET\");\n    if( pszMaskOverviewDS )\n    {\n        poDS->m_poMaskExtOvrDS.reset(GDALDataset::Open(pszMaskOverviewDS,\n                                            GDAL_OF_RASTER | GDAL_OF_INTERNAL));\n        if( !poDS->m_poMaskExtOvrDS || !poDS->AssociateExternalMask() )\n        {\n            CPLDebug(\"GTiff\",\n                     \"Association with external mask overview file failed\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Initialize info for external overviews.                         */\n/* -------------------------------------------------------------------- */\n    poDS->oOvManager.Initialize( poDS, pszFilename );\n    if( poOpenInfo->AreSiblingFilesLoaded() )\n        poDS->oOvManager.TransferSiblingFiles(\n            poOpenInfo->StealSiblingFiles() );\n\n    // For backward compatibility, in case GTIFF_POINT_GEO_IGNORE is defined\n    // load georeferencing right now so as to not require it to be defined\n    // at the GetGeoTransform() time.\n    if( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\", nullptr) != nullptr )\n    {\n        poDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                      GTiffDatasetSetAreaOrPointMD()                  */\n/************************************************************************/\n\nstatic void GTiffDatasetSetAreaOrPointMD( GTIF* hGTIF,\n                                          GDALMultiDomainMetadata& m_oGTiffMDMD )\n{\n    // Is this a pixel-is-point dataset?\n    unsigned short nRasterType = 0;\n\n    if( GDALGTIFKeyGetSHORT(hGTIF, GTRasterTypeGeoKey, &nRasterType,\n                    0, 1 ) == 1 )\n    {\n        if( nRasterType == static_cast<short>(RasterPixelIsPoint) )\n            m_oGTiffMDMD.SetMetadataItem(GDALMD_AREA_OR_POINT, GDALMD_AOP_POINT);\n        else\n            m_oGTiffMDMD.SetMetadataItem(GDALMD_AREA_OR_POINT, GDALMD_AOP_AREA);\n    }\n}\n\n/************************************************************************/\n/*                         LoadMDAreaOrPoint()                          */\n/************************************************************************/\n\n// This is a light version of LookForProjection(), which saves the\n// potential costly cost of GTIFGetOGISDefn(), since we just need to\n// access to a raw GeoTIFF key, and not build the full projection object.\n\nvoid GTiffDataset::LoadMDAreaOrPoint()\n{\n    if( m_bLookedForProjection || m_bLookedForMDAreaOrPoint ||\n        m_oGTiffMDMD.GetMetadataItem( GDALMD_AREA_OR_POINT ) != nullptr )\n        return;\n\n    m_bLookedForMDAreaOrPoint = true;\n\n    GTIF* hGTIF = GTiffDatasetGTIFNew(m_hTIFF);\n\n    if( !hGTIF )\n    {\n        ReportError( CE_Warning, CPLE_AppDefined,\n                  \"GeoTIFF tags apparently corrupt, they are being ignored.\" );\n    }\n    else\n    {\n        GTiffDatasetSetAreaOrPointMD( hGTIF, m_oGTiffMDMD );\n\n        GTIFFree( hGTIF );\n    }\n}\n\n/************************************************************************/\n/*                         LookForProjection()                          */\n/************************************************************************/\n\nvoid GTiffDataset::LookForProjection()\n\n{\n    if( m_bLookedForProjection )\n        return;\n\n    m_bLookedForProjection = true;\n\n    IdentifyAuthorizedGeoreferencingSources();\n    if( m_nINTERNALGeorefSrcIndex < 0 )\n        return;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the GeoTIFF projection, if available.                   */\n/* -------------------------------------------------------------------- */\n    m_oSRS.Clear();\n\n    GTIF *hGTIF = GTiffDatasetGTIFNew(m_hTIFF);\n\n    if( !hGTIF )\n    {\n        ReportError( CE_Warning, CPLE_AppDefined,\n                  \"GeoTIFF tags apparently corrupt, they are being ignored.\" );\n    }\n    else\n    {\n        GTIFDefn *psGTIFDefn = GTIFAllocDefn();\n\n        if( GTIFGetDefn( hGTIF, psGTIFDefn ) )\n        {\n            OGRSpatialReferenceH hSRS = GTIFGetOGISDefnAsOSR( hGTIF, psGTIFDefn );\n            if( hSRS )\n            {\n                m_oSRS = *(OGRSpatialReference::FromHandle(hSRS));\n                OSRDestroySpatialReference(hSRS);\n            }\n\n            if( m_oSRS.IsCompound() )\n            {\n                const char* pszVertUnit = nullptr;\n                m_oSRS.GetTargetLinearUnits(\"COMPD_CS|VERT_CS\", &pszVertUnit);\n                if( pszVertUnit && !EQUAL(pszVertUnit, \"unknown\") )\n                {\n                    CPLFree(m_pszVertUnit);\n                    m_pszVertUnit = CPLStrdup(pszVertUnit);\n                }\n\n                int versions[3];\n                GTIFDirectoryInfo(hGTIF, versions, nullptr);\n\n                // If GeoTIFF 1.0, strip vertical by default\n                const char* pszDefaultReportCompdCS =\n                    ( versions[0] == 1 && versions[1]== 1 && versions[2] == 0 ) ? \"NO\" : \"YES\";\n\n                // Should we simplify away vertical CS stuff?\n                if( !CPLTestBool( CPLGetConfigOption(\"GTIFF_REPORT_COMPD_CS\", \n                                            pszDefaultReportCompdCS) ) )\n                {\n                    CPLDebug( \"GTiff\", \"Got COMPD_CS, but stripping it.\" );\n\n                    m_oSRS.StripVertical();\n                }\n            }\n        }\n\n        // Check the tif linear unit and the CS linear unit.\n#ifdef ESRI_BUILD\n        AdjustLinearUnit(psGTIFDefn.UOMLength);\n#endif\n\n        GTIFFreeDefn(psGTIFDefn);\n\n        GTiffDatasetSetAreaOrPointMD( hGTIF, m_oGTiffMDMD );\n\n        GTIFFree( hGTIF );\n    }\n\n    m_bGeoTIFFInfoChanged = false;\n    m_bForceUnsetGTOrGCPs = false;\n    m_bForceUnsetProjection = false;\n}\n\n/************************************************************************/\n/*                          AdjustLinearUnit()                          */\n/*                                                                      */\n/*      The following code is only used in ESRI Builds and there is     */\n/*      outstanding discussion on whether it is even appropriate        */\n/*      then.                                                           */\n/************************************************************************/\n#ifdef ESRI_BUILD\n\nvoid GTiffDataset::AdjustLinearUnit( short UOMLength )\n{\n    if( !pszProjection || strlen(pszProjection) == 0 )\n        return;\n    if( UOMLength == 9001 )\n    {\n        char* pstr = strstr(pszProjection, \"PARAMETER\");\n        if( !pstr )\n            return;\n        pstr = strstr(pstr, \"UNIT[\");\n        if( !pstr )\n            return;\n        pstr = strchr(pstr, ',') + 1;\n        if( !pstr )\n            return;\n        char* pstr1 = strchr(pstr, ']');\n        if( !pstr1 || pstr1 - pstr >= 128 )\n            return;\n        char csUnitStr[128];\n        strncpy(csUnitStr, pstr, pstr1 - pstr);\n        csUnitStr[pstr1-pstr] = '\\0';\n        const double csUnit = CPLAtof(csUnitStr);\n        if( fabs(csUnit - 1.0) > 0.000001 )\n        {\n            for( long i = 0; i < 6; ++i )\n                adfGeoTransform[i] /= csUnit;\n        }\n    }\n}\n\n#endif  // def ESRI_BUILD\n\n/************************************************************************/\n/*                            ApplyPamInfo()                            */\n/*                                                                      */\n/*      PAM Information, if available, overrides the GeoTIFF            */\n/*      geotransform and projection definition.  Check for them         */\n/*      now.                                                            */\n/************************************************************************/\n\nvoid GTiffDataset::ApplyPamInfo()\n\n{\n    if( m_nPAMGeorefSrcIndex >= 0 &&\n        ((m_bGeoTransformValid &&\n          m_nPAMGeorefSrcIndex < m_nGeoTransformGeorefSrcIndex) ||\n          m_nGeoTransformGeorefSrcIndex < 0 || !m_bGeoTransformValid) )\n    {\n        double adfPamGeoTransform[6] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };\n        if( GDALPamDataset::GetGeoTransform( adfPamGeoTransform ) == CE_None )\n        {\n            if( m_nGeoTransformGeorefSrcIndex == m_nWORLDFILEGeorefSrcIndex )\n            {\n                CPLFree(m_pszGeorefFilename);\n                m_pszGeorefFilename = nullptr;\n            }\n            memcpy(m_adfGeoTransform, adfPamGeoTransform, sizeof(double) * 6);\n            m_bGeoTransformValid = true;\n        }\n    }\n\n    if( m_nPAMGeorefSrcIndex >= 0 )\n    {\n        if( (m_nTABFILEGeorefSrcIndex < 0 ||\n             m_nPAMGeorefSrcIndex < m_nTABFILEGeorefSrcIndex) &&\n            (m_nINTERNALGeorefSrcIndex < 0 ||\n             m_nPAMGeorefSrcIndex < m_nINTERNALGeorefSrcIndex) )\n        {\n            const auto* poPamSRS = GDALPamDataset::GetSpatialRef();\n            if( poPamSRS )\n            {\n                m_oSRS = *poPamSRS;\n                m_bLookedForProjection = true;\n                // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n            }\n        }\n        else\n        {\n            if( m_nINTERNALGeorefSrcIndex >= 0 )\n                LookForProjection();\n            if( m_oSRS.IsEmpty() )\n            {\n                const auto* poPamSRS = GDALPamDataset::GetSpatialRef();\n                if( poPamSRS )\n                {\n                    m_oSRS = *poPamSRS;\n                    m_bLookedForProjection = true;\n                    // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n                }\n            }\n        }\n    }\n\n    int nPamGCPCount;\n    if( m_nPAMGeorefSrcIndex >= 0 &&\n        (nPamGCPCount = GDALPamDataset::GetGCPCount()) > 0 &&\n        ( (m_nGCPCount > 0 &&\n           m_nPAMGeorefSrcIndex < m_nGeoTransformGeorefSrcIndex) ||\n          m_nGeoTransformGeorefSrcIndex < 0 || m_nGCPCount == 0 ) )\n    {\n        if( m_nGCPCount > 0 )\n        {\n            GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n            CPLFree( m_pasGCPList );\n            m_pasGCPList = nullptr;\n        }\n\n        m_nGCPCount = nPamGCPCount;\n        m_pasGCPList = GDALDuplicateGCPs(m_nGCPCount, GDALPamDataset::GetGCPs());\n\n        // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n\n        const auto* poPamGCPSRS = GDALPamDataset::GetGCPSpatialRef();\n        if( poPamGCPSRS )\n            m_oSRS = *poPamGCPSRS;\n        else\n            m_oSRS.Clear();\n\n        m_bLookedForProjection = true;\n    }\n\n    if( m_nPAMGeorefSrcIndex >= 0 )\n    {\n        CPLXMLNode *psValueAsXML = nullptr;\n        CPLXMLNode *psGeodataXform = nullptr;\n        char** papszXML = oMDMD.GetMetadata( \"xml:ESRI\" );\n        if (CSLCount(papszXML) == 1)\n        {\n            psValueAsXML = CPLParseXMLString( papszXML[0] );\n            if( psValueAsXML )\n                psGeodataXform = CPLGetXMLNode(psValueAsXML, \"=GeodataXform\");\n        }\n\n        const char* pszTIFFTagResUnit = GetMetadataItem(\"TIFFTAG_RESOLUTIONUNIT\");\n        const char* pszTIFFTagXRes = GetMetadataItem(\"TIFFTAG_XRESOLUTION\");\n        const char* pszTIFFTagYRes = GetMetadataItem(\"TIFFTAG_YRESOLUTION\");\n        if (psGeodataXform && pszTIFFTagResUnit &&pszTIFFTagXRes &&\n            pszTIFFTagYRes && atoi(pszTIFFTagResUnit) == 2 )\n        {\n            CPLXMLNode* psSourceGCPs = CPLGetXMLNode(psGeodataXform,\n                                                        \"SourceGCPs\");\n            CPLXMLNode* psTargetGCPs = CPLGetXMLNode(psGeodataXform,\n                                                        \"TargetGCPs\");\n            if( psSourceGCPs && psTargetGCPs )\n            {\n                std::vector<double> adfSourceGCPs, adfTargetGCPs;\n                for( CPLXMLNode* psIter = psSourceGCPs->psChild;\n                                    psIter != nullptr;\n                                    psIter = psIter->psNext )\n                {\n                    if( psIter->eType == CXT_Element &&\n                        EQUAL(psIter->pszValue, \"Double\") )\n                    {\n                        adfSourceGCPs.push_back(\n                            CPLAtof( CPLGetXMLValue(psIter, nullptr, \"\") ) );\n                    }\n                }\n                for( CPLXMLNode* psIter = psTargetGCPs->psChild;\n                                    psIter != nullptr;\n                                    psIter = psIter->psNext )\n                {\n                    if( psIter->eType == CXT_Element &&\n                        EQUAL(psIter->pszValue, \"Double\") )\n                    {\n                        adfTargetGCPs.push_back(\n                            CPLAtof( CPLGetXMLValue(psIter, nullptr, \"\") ) );\n                    }\n                }\n                if( adfSourceGCPs.size() == adfTargetGCPs.size() &&\n                    (adfSourceGCPs.size() % 2) == 0 )\n                {\n                    if( m_nGCPCount > 0 )\n                    {\n                        GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n                        CPLFree( m_pasGCPList );\n                        m_pasGCPList = nullptr;\n                        m_nGCPCount = 0;\n                    }\n                    m_nGCPCount = static_cast<int>(\n                                            adfSourceGCPs.size() / 2);\n                    m_pasGCPList = static_cast<GDAL_GCP *>(\n                            CPLCalloc(sizeof(GDAL_GCP), m_nGCPCount) );\n                    for( int i = 0; i < m_nGCPCount; ++i )\n                    {\n                        m_pasGCPList[i].pszId = CPLStrdup(\"\");\n                        m_pasGCPList[i].pszInfo = CPLStrdup(\"\");\n                        // The origin used is the bottom left corner,\n                        // and raw values are in inches!\n                        m_pasGCPList[i].dfGCPPixel = adfSourceGCPs[2*i] *\n                                                        CPLAtof(pszTIFFTagXRes);\n                        m_pasGCPList[i].dfGCPLine = nRasterYSize -\n                                adfSourceGCPs[2*i+1] * CPLAtof(pszTIFFTagYRes);\n                        m_pasGCPList[i].dfGCPX = adfTargetGCPs[2*i];\n                        m_pasGCPList[i].dfGCPY = adfTargetGCPs[2*i+1];\n                    }\n                }\n            }\n        }\n        if( psValueAsXML )\n            CPLDestroyXMLNode(psValueAsXML);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy any PAM metadata into our GeoTIFF context, and with        */\n/*      the PAM info overriding the GeoTIFF context.                    */\n/* -------------------------------------------------------------------- */\n    char **papszPamDomains = oMDMD.GetDomainList();\n\n    for( int iDomain = 0;\n         papszPamDomains && papszPamDomains[iDomain] != nullptr;\n         ++iDomain )\n    {\n        const char *pszDomain = papszPamDomains[iDomain];\n        char **papszGT_MD = CSLDuplicate(m_oGTiffMDMD.GetMetadata( pszDomain ));\n        char **papszPAM_MD = oMDMD.GetMetadata( pszDomain );\n\n        papszGT_MD = CSLMerge( papszGT_MD, papszPAM_MD );\n\n        m_oGTiffMDMD.SetMetadata( papszGT_MD, pszDomain );\n        CSLDestroy( papszGT_MD );\n    }\n\n    for( int i = 1; i <= GetRasterCount(); ++i )\n    {\n        GTiffRasterBand* poBand =\n            cpl::down_cast<GTiffRasterBand *>(GetRasterBand(i));\n        papszPamDomains = poBand->oMDMD.GetDomainList();\n\n        for( int iDomain = 0;\n             papszPamDomains && papszPamDomains[iDomain] != nullptr;\n             ++iDomain )\n        {\n            const char *pszDomain = papszPamDomains[iDomain];\n            char **papszGT_MD =\n                CSLDuplicate(poBand->m_oGTiffMDMD.GetMetadata( pszDomain ));\n            char **papszPAM_MD = poBand->oMDMD.GetMetadata( pszDomain );\n\n            papszGT_MD = CSLMerge( papszGT_MD, papszPAM_MD );\n\n            poBand->m_oGTiffMDMD.SetMetadata( papszGT_MD, pszDomain );\n            CSLDestroy( papszGT_MD );\n        }\n    }\n}\n\n/************************************************************************/\n/*                              OpenDir()                               */\n/*                                                                      */\n/*      Open a specific directory as encoded into a filename.           */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::OpenDir( GDALOpenInfo * poOpenInfo )\n\n{\n    bool bAllowRGBAInterface = true;\n    const char* pszFilename = poOpenInfo->pszFilename;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n    if( !STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") ||\n        pszFilename[strlen(\"GTIFF_DIR:\")] == '\\0' )\n    {\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Split out filename, and dir#/offset.                            */\n/* -------------------------------------------------------------------- */\n    pszFilename += strlen(\"GTIFF_DIR:\");\n    bool bAbsolute = false;\n\n    if( STARTS_WITH_CI(pszFilename, \"off:\") )\n    {\n        bAbsolute = true;\n        pszFilename += 4;\n    }\n\n    toff_t nOffset = atol(pszFilename);\n    pszFilename += 1;\n\n    while( *pszFilename != '\\0' && pszFilename[-1] != ':' )\n        ++pszFilename;\n\n    if( *pszFilename == '\\0' || nOffset == 0 )\n    {\n        ReportError(pszFilename, CE_Failure, CPLE_OpenFailed,\n            \"Unable to extract offset or filename, should take the form:\\n\"\n            \"GTIFF_DIR:<dir>:filename or GTIFF_DIR:off:<dir_offset>:filename\" );\n        return nullptr;\n    }\n\n    if( poOpenInfo->eAccess == GA_Update )\n    {\n        ReportError(\n            pszFilename, CE_Warning, CPLE_AppDefined,\n            \"Opening a specific TIFF directory is not supported in \"\n            \"update mode. Switching to read-only\" );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n    const char* pszFlag = poOpenInfo->eAccess == GA_Update ? \"r+D\" : \"rDO\";\n    VSILFILE* l_fpL = VSIFOpenL(pszFilename, pszFlag);\n    if( l_fpL == nullptr )\n        return nullptr;\n    TIFF *l_hTIFF = VSI_TIFFOpen( pszFilename, pszFlag, l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If a directory was requested by index, advance to it now.       */\n/* -------------------------------------------------------------------- */\n    if( !bAbsolute )\n    {\n        const toff_t nOffsetRequested = nOffset;\n        while( nOffset > 1 )\n        {\n            if( TIFFReadDirectory( l_hTIFF ) == 0 )\n            {\n                XTIFFClose( l_hTIFF );\n                ReportError(\n                    pszFilename, CE_Failure, CPLE_OpenFailed,\n                    \"Requested directory %lu not found.\",\n                    static_cast<long unsigned int>(nOffsetRequested));\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n            nOffset--;\n        }\n\n        nOffset = TIFFCurrentDirOffset( l_hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription( poOpenInfo->pszFilename );\n    poDS->m_pszFilename = CPLStrdup(pszFilename);\n    poDS->m_fpL = l_fpL;\n    poDS->m_hTIFF = l_hTIFF;\n    poDS->m_bSingleIFDOpened = true;\n\n    if( !EQUAL(pszFilename,poOpenInfo->pszFilename)\n        && !STARTS_WITH_CI(poOpenInfo->pszFilename, \"GTIFF_RAW:\") )\n    {\n        poDS->SetPhysicalFilename( pszFilename );\n        poDS->SetSubdatasetName( poOpenInfo->pszFilename );\n    }\n\n    if( poOpenInfo->AreSiblingFilesLoaded() )\n        poDS->oOvManager.TransferSiblingFiles(\n            poOpenInfo->StealSiblingFiles() );\n\n    if( poDS->OpenOffset( l_hTIFF,\n                          nOffset, poOpenInfo->eAccess,\n                          bAllowRGBAInterface, true ) != CE_None )\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                   ConvertTransferFunctionToString()                  */\n/*                                                                      */\n/*      Convert a transfer function table into a string.                */\n/*      Used by LoadICCProfile().                                       */\n/************************************************************************/\nstatic CPLString ConvertTransferFunctionToString( const uint16 *pTable,\n                                                  uint32 nTableEntries )\n{\n    CPLString sValue;\n\n    for( uint32 i = 0; i < nTableEntries; ++i )\n    {\n        if( i == 0 )\n            sValue = sValue.Printf(\"%d\", static_cast<uint32>(pTable[i]));\n        else\n            sValue = sValue.Printf( \"%s, %d\",\n                                    sValue.c_str(),\n                                    static_cast<uint32>(pTable[i]));\n    }\n\n    return sValue;\n}\n\n/************************************************************************/\n/*                             LoadICCProfile()                         */\n/*                                                                      */\n/*      Load ICC Profile or colorimetric data into metadata             */\n/************************************************************************/\n\nvoid GTiffDataset::LoadICCProfile()\n{\n    if( m_bICCMetadataLoaded )\n        return;\n    m_bICCMetadataLoaded = true;\n\n    uint32 nEmbedLen = 0;\n    uint8* pEmbedBuffer = nullptr;\n\n\n    if( TIFFGetField(m_hTIFF, TIFFTAG_ICCPROFILE, &nEmbedLen, &pEmbedBuffer) )\n    {\n        char *pszBase64Profile =\n            CPLBase64Encode(nEmbedLen, reinterpret_cast<const GByte*>(pEmbedBuffer));\n\n        m_oGTiffMDMD.SetMetadataItem( \"SOURCE_ICC_PROFILE\", pszBase64Profile,\n                                    \"COLOR_PROFILE\" );\n\n        CPLFree(pszBase64Profile);\n\n        return;\n    }\n\n    // Check for colorimetric tiff.\n    float* pCHR = nullptr;\n    float* pWP = nullptr;\n    uint16 *pTFR = nullptr;\n    uint16 *pTFG = nullptr;\n    uint16 *pTFB = nullptr;\n    uint16 *pTransferRange = nullptr;\n\n    if( TIFFGetField(m_hTIFF, TIFFTAG_PRIMARYCHROMATICITIES, &pCHR) )\n    {\n        if( TIFFGetField(m_hTIFF, TIFFTAG_WHITEPOINT, &pWP) )\n        {\n            if( !TIFFGetFieldDefaulted( m_hTIFF, TIFFTAG_TRANSFERFUNCTION, &pTFR,\n                                        &pTFG, &pTFB) ||\n                pTFR == nullptr || pTFG == nullptr || pTFB == nullptr )\n            {\n                return;\n            }\n\n            const int TIFFTAG_TRANSFERRANGE = 0x0156;\n            TIFFGetFieldDefaulted( m_hTIFF, TIFFTAG_TRANSFERRANGE,\n                                   &pTransferRange);\n\n            // Set all the colorimetric metadata.\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_RED\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[0]),\n                                    static_cast<double>(pCHR[1]) ),\n                \"COLOR_PROFILE\" );\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_GREEN\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[2]),\n                                    static_cast<double>(pCHR[3]) ),\n                \"COLOR_PROFILE\" );\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_BLUE\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[4]),\n                                    static_cast<double>(pCHR[5]) ),\n                \"COLOR_PROFILE\" );\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_WHITEPOINT\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pWP[0]),\n                                    static_cast<double>(pWP[1]) ),\n                \"COLOR_PROFILE\" );\n\n            // Set transfer function metadata.\n\n            // Get length of table.\n            const uint32 nTransferFunctionLength = 1 << m_nBitsPerSample;\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_RED\",\n                ConvertTransferFunctionToString( pTFR, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n                ConvertTransferFunctionToString( pTFG, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n                ConvertTransferFunctionToString( pTFB, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            // Set transfer range.\n            if( pTransferRange )\n            {\n                m_oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_BLACK\",\n                    CPLString().Printf( \"%d, %d, %d\",\n                                        static_cast<int>(pTransferRange[0]),\n                                        static_cast<int>(pTransferRange[2]),\n                                        static_cast<int>(pTransferRange[4])),\n                    \"COLOR_PROFILE\" );\n                m_oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_WHITE\",\n                    CPLString().Printf( \"%d, %d, %d\",\n                                        static_cast<int>(pTransferRange[1]),\n                                        static_cast<int>(pTransferRange[3]),\n                                        static_cast<int>(pTransferRange[5])),\n                    \"COLOR_PROFILE\" );\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                             SaveICCProfile()                         */\n/*                                                                      */\n/*      Save ICC Profile or colorimetric data into file                 */\n/* pDS:                                                                 */\n/*      Dataset that contains the metadata with the ICC or colorimetric */\n/*      data. If this argument is specified, all other arguments are    */\n/*      ignored. Set them to NULL or 0.                                 */\n/* hTIFF:                                                               */\n/*      Pointer to TIFF handle. Only needed if pDS is NULL or           */\n/*      pDS->m_hTIFF is NULL.                                             */\n/* papszParmList:                                                       */\n/*      Options containing the ICC profile or colorimetric metadata.    */\n/*      Ignored if pDS is not NULL.                                     */\n/* nBitsPerSample:                                                      */\n/*      Bits per sample. Ignored if pDS is not NULL.                    */\n/************************************************************************/\n\nvoid GTiffDataset::SaveICCProfile( GTiffDataset *pDS, TIFF *l_hTIFF,\n                                   char **papszParmList,\n                                   uint32 l_nBitsPerSample )\n{\n    if( (pDS != nullptr) && (pDS->eAccess != GA_Update) )\n        return;\n\n    if( l_hTIFF == nullptr )\n    {\n        if( pDS == nullptr )\n            return;\n\n        l_hTIFF = pDS->m_hTIFF;\n        if( l_hTIFF == nullptr )\n            return;\n    }\n\n    if( (papszParmList == nullptr) && (pDS == nullptr) )\n        return;\n\n    const char *pszValue = nullptr;\n    if( pDS != nullptr )\n        pszValue = pDS->GetMetadataItem(\"SOURCE_ICC_PROFILE\", \"COLOR_PROFILE\");\n    else\n        pszValue = CSLFetchNameValue(papszParmList, \"SOURCE_ICC_PROFILE\");\n    if( pszValue != nullptr )\n    {\n        char *pEmbedBuffer = CPLStrdup(pszValue);\n        int32 nEmbedLen =\n            CPLBase64DecodeInPlace(reinterpret_cast<GByte *>(pEmbedBuffer));\n\n        TIFFSetField(l_hTIFF, TIFFTAG_ICCPROFILE, nEmbedLen, pEmbedBuffer);\n\n        CPLFree(pEmbedBuffer);\n    }\n    else\n    {\n        // Output colorimetric data.\n        float pCHR[6] = {};  // Primaries.\n        uint16 pTXR[6] = {};  // Transfer range.\n        const char* pszCHRNames[] = {\n            \"SOURCE_PRIMARIES_RED\",\n            \"SOURCE_PRIMARIES_GREEN\",\n            \"SOURCE_PRIMARIES_BLUE\"\n        };\n        const char* pszTXRNames[] = {\n            \"TIFFTAG_TRANSFERRANGE_BLACK\",\n            \"TIFFTAG_TRANSFERRANGE_WHITE\"\n        };\n\n        // Output chromacities.\n        bool bOutputCHR = true;\n        for( int i = 0; i < 3 && bOutputCHR; ++i )\n        {\n            if( pDS != nullptr )\n                pszValue =\n                    pDS->GetMetadataItem(pszCHRNames[i], \"COLOR_PROFILE\");\n            else\n                pszValue = CSLFetchNameValue(papszParmList, pszCHRNames[i]);\n            if( pszValue == nullptr )\n            {\n                bOutputCHR = false;\n                break;\n            }\n\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputCHR = false;\n                CSLDestroy( papszTokens );\n                break;\n            }\n\n            for( int j = 0; j < 3; ++j )\n            {\n                float v = static_cast<float>(CPLAtof(papszTokens[j]));\n\n                if( j == 2 )\n                {\n                    // Last term of xyY color must be 1.0.\n                    if( v != 1.0 )\n                    {\n                        bOutputCHR = false;\n                        break;\n                    }\n                }\n                else\n                {\n                    pCHR[i * 2 + j] = v;\n                }\n            }\n\n            CSLDestroy( papszTokens );\n        }\n\n        if( bOutputCHR )\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_PRIMARYCHROMATICITIES, pCHR);\n        }\n\n        // Output whitepoint.\n        if( pDS != nullptr )\n            pszValue =\n                pDS->GetMetadataItem(\"SOURCE_WHITEPOINT\", \"COLOR_PROFILE\");\n        else\n            pszValue = CSLFetchNameValue(papszParmList, \"SOURCE_WHITEPOINT\");\n        if( pszValue != nullptr )\n        {\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            bool bOutputWhitepoint = true;\n            float pWP[2] = { 0.0f, 0.0f };  // Whitepoint\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputWhitepoint = false;\n            }\n            else\n            {\n                for( int j = 0; j < 3; ++j )\n                {\n                    const float v = static_cast<float>(CPLAtof(papszTokens[j]));\n\n                    if( j == 2 )\n                    {\n                        // Last term of xyY color must be 1.0.\n                        if( v != 1.0 )\n                        {\n                            bOutputWhitepoint = false;\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        pWP[j] = v;\n                    }\n                }\n            }\n            CSLDestroy( papszTokens );\n\n            if( bOutputWhitepoint )\n            {\n                TIFFSetField(l_hTIFF, TIFFTAG_WHITEPOINT, pWP);\n            }\n        }\n\n        // Set transfer function metadata.\n        char const *pszTFRed = nullptr;\n        if( pDS != nullptr )\n            pszTFRed =\n                pDS->GetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_RED\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFRed =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_RED\" );\n\n        char const *pszTFGreen = nullptr;\n        if( pDS != nullptr )\n            pszTFGreen =\n                pDS->GetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFGreen =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_GREEN\" );\n\n        char const *pszTFBlue = nullptr;\n        if( pDS != nullptr )\n            pszTFBlue =\n                pDS->GetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFBlue =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_BLUE\" );\n\n        if( (pszTFRed != nullptr) && (pszTFGreen != nullptr) && (pszTFBlue != nullptr) )\n        {\n            // Get length of table.\n            const int nTransferFunctionLength =\n                1 << ((pDS!=nullptr)?pDS->m_nBitsPerSample:l_nBitsPerSample);\n\n            char** papszTokensRed =\n                CSLTokenizeString2(\n                    pszTFRed, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n            char** papszTokensGreen =\n                CSLTokenizeString2(\n                    pszTFGreen, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n            char** papszTokensBlue =\n                CSLTokenizeString2(\n                    pszTFBlue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( (CSLCount( papszTokensRed ) == nTransferFunctionLength) &&\n                (CSLCount( papszTokensGreen ) == nTransferFunctionLength) &&\n                (CSLCount( papszTokensBlue ) == nTransferFunctionLength) )\n            {\n                uint16 *pTransferFuncRed =\n                    static_cast<uint16*>( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n                uint16 *pTransferFuncGreen =\n                    static_cast<uint16*>( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n                uint16 *pTransferFuncBlue =\n                    static_cast<uint16*>( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n\n                // Convert our table in string format into int16 format.\n                for( int i = 0; i < nTransferFunctionLength; ++i )\n                {\n                    pTransferFuncRed[i] =\n                        static_cast<uint16>(atoi(papszTokensRed[i]));\n                    pTransferFuncGreen[i] =\n                        static_cast<uint16>(atoi(papszTokensGreen[i]));\n                    pTransferFuncBlue[i] =\n                        static_cast<uint16>(atoi(papszTokensBlue[i]));\n                }\n\n                TIFFSetField(l_hTIFF, TIFFTAG_TRANSFERFUNCTION,\n                    pTransferFuncRed, pTransferFuncGreen, pTransferFuncBlue);\n\n                CPLFree(pTransferFuncRed);\n                CPLFree(pTransferFuncGreen);\n                CPLFree(pTransferFuncBlue);\n            }\n\n            CSLDestroy( papszTokensRed );\n            CSLDestroy( papszTokensGreen );\n            CSLDestroy( papszTokensBlue );\n        }\n\n        // Output transfer range.\n        bool bOutputTransferRange = true;\n        for( int i = 0; (i < 2) && bOutputTransferRange; ++i )\n        {\n            if( pDS != nullptr )\n                pszValue = pDS->GetMetadataItem( pszTXRNames[i],\n                                                 \"COLOR_PROFILE\" );\n            else\n                pszValue = CSLFetchNameValue(papszParmList, pszTXRNames[i]);\n            if( pszValue == nullptr )\n            {\n                bOutputTransferRange = false;\n                break;\n            }\n\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputTransferRange = false;\n                CSLDestroy( papszTokens );\n                break;\n            }\n\n            for( int j = 0; j < 3; ++j )\n            {\n                pTXR[i + j * 2] = static_cast<uint16>(atoi(papszTokens[j]));\n            }\n\n            CSLDestroy( papszTokens );\n        }\n\n        if( bOutputTransferRange )\n        {\n            const int TIFFTAG_TRANSFERRANGE = 0x0156;\n            TIFFSetField(l_hTIFF, TIFFTAG_TRANSFERRANGE, pTXR);\n        }\n    }\n}\n\n/************************************************************************/\n/*                             OpenOffset()                             */\n/*                                                                      */\n/*      Initialize the GTiffDataset based on a passed in file           */\n/*      handle, and directory offset to utilize.  This is called for    */\n/*      full res, and overview pages.                                   */\n/************************************************************************/\n\nCPLErr GTiffDataset::OpenOffset( TIFF *hTIFFIn,\n                                 toff_t nDirOffsetIn,\n                                 GDALAccess eAccessIn,\n                                 bool bAllowRGBAInterface,\n                                 bool bReadGeoTransform )\n\n{\n    if( !hTIFFIn )\n        return CE_Failure;\n\n    eAccess = eAccessIn;\n\n    m_hTIFF = hTIFFIn;\n\n    m_nDirOffset = nDirOffsetIn;\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some information from the file that is of interest.     */\n/* -------------------------------------------------------------------- */\n    uint32 nXSize = 0;\n    uint32 nYSize = 0;\n    TIFFGetField( m_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( m_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    if( nXSize > INT_MAX || nYSize > INT_MAX )\n    {\n        // GDAL only supports signed 32bit dimensions.\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"Too large image size: %u x %u\",\n                 nXSize, nYSize);\n        return CE_Failure;\n    }\n    nRasterXSize = nXSize;\n    nRasterYSize = nYSize;\n\n    if( !TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &m_nSamplesPerPixel ) )\n        nBands = 1;\n    else\n        nBands = m_nSamplesPerPixel;\n\n    if( !TIFFGetField(m_hTIFF, TIFFTAG_BITSPERSAMPLE, &(m_nBitsPerSample)) )\n        m_nBitsPerSample = 1;\n\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_PLANARCONFIG, &(m_nPlanarConfig) ) )\n        m_nPlanarConfig = PLANARCONFIG_CONTIG;\n\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_PHOTOMETRIC, &(m_nPhotometric) ) )\n        m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_SAMPLEFORMAT, &(m_nSampleFormat) ) )\n        m_nSampleFormat = SAMPLEFORMAT_UINT;\n\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_COMPRESSION, &(m_nCompression) ) )\n        m_nCompression = COMPRESSION_NONE;\n\n    if( m_nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(m_nCompression) )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"Cannot open TIFF file due to missing codec.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( m_nCompression == COMPRESSION_JPEG\n        && m_nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\") ) )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\",\n                                    \"IMAGE_STRUCTURE\" );\n        int nColorMode = 0;\n        if( !TIFFGetField( m_hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n            nColorMode != JPEGCOLORMODE_RGB )\n        {\n            TIFFSetField(m_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get strip/tile layout.                                          */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled(m_hTIFF) )\n    {\n        uint32 l_nBlockXSize = 0;\n        uint32 l_nBlockYSize = 0;\n        TIFFGetField( m_hTIFF, TIFFTAG_TILEWIDTH, &(l_nBlockXSize) );\n        TIFFGetField( m_hTIFF, TIFFTAG_TILELENGTH, &(l_nBlockYSize) );\n        if( l_nBlockXSize > INT_MAX || l_nBlockYSize > INT_MAX )\n        {\n            ReportError(CE_Failure, CPLE_NotSupported,\n                     \"Too large block size: %u x %u\",\n                     l_nBlockXSize, l_nBlockYSize);\n            return CE_Failure;\n        }\n        m_nBlockXSize = static_cast<int>(l_nBlockXSize);\n        m_nBlockYSize = static_cast<int>(l_nBlockYSize);\n    }\n    else\n    {\n        if( !TIFFGetField( m_hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(m_nRowsPerStrip) ) )\n        {\n            ReportError( CE_Warning, CPLE_AppDefined,\n                      \"RowsPerStrip not defined ... assuming all one strip.\" );\n            m_nRowsPerStrip = nYSize;  // Dummy value.\n        }\n\n        // If the rows per strip is larger than the file we will get\n        // confused.  libtiff internally will treat the rowsperstrip as\n        // the image height and it is best if we do too. (#4468)\n        if( m_nRowsPerStrip > static_cast<uint32>(nRasterYSize) )\n            m_nRowsPerStrip = nRasterYSize;\n\n        m_nBlockXSize = nRasterXSize;\n        m_nBlockYSize = m_nRowsPerStrip;\n    }\n\n    const int l_nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, m_nBlockYSize);\n    const int l_nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n    if( l_nBlocksPerColumn > INT_MAX / l_nBlocksPerRow )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"Too many blocks: %d x %d\",\n                  l_nBlocksPerRow, l_nBlocksPerColumn );\n        return CE_Failure;\n    }\n\n    // Note: we could potentially go up to UINT_MAX blocks, but currently\n    // we use a int nBlockId\n    m_nBlocksPerBand = l_nBlocksPerColumn * l_nBlocksPerRow;\n    if( m_nPlanarConfig == PLANARCONFIG_SEPARATE &&\n        m_nBlocksPerBand > INT_MAX / nBands )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"Too many blocks: %d x %d x %d bands\",\n                  l_nBlocksPerRow, l_nBlocksPerColumn, nBands );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we handle this using the GTiffBitmapBand?                */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsBitmap = false;\n\n    if( m_nBitsPerSample == 1 && nBands == 1 )\n    {\n        bTreatAsBitmap = true;\n\n        // Lets treat large \"one row\" bitmaps using the scanline api.\n        if( !TIFFIsTiled(m_hTIFF)\n            && m_nBlockYSize == nRasterYSize\n            && nRasterYSize > 2000\n            // libtiff does not support reading JBIG files with\n            // TIFFReadScanline().\n            && m_nCompression != COMPRESSION_JBIG )\n        {\n            m_bTreatAsSplitBitmap = true;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the RGBA interface?                    */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsRGBA = false;\n    if(\n#ifdef DEBUG\n        CPLTestBool(CPLGetConfigOption(\"GTIFF_FORCE_RGBA\", \"NO\")) ||\n#endif\n        (bAllowRGBAInterface &&\n        !bTreatAsBitmap && !(m_nBitsPerSample > 8)\n        && (m_nPhotometric == PHOTOMETRIC_CIELAB ||\n            m_nPhotometric == PHOTOMETRIC_LOGL ||\n            m_nPhotometric == PHOTOMETRIC_LOGLUV ||\n            m_nPhotometric == PHOTOMETRIC_SEPARATED ||\n            ( m_nPhotometric == PHOTOMETRIC_YCBCR\n              && m_nCompression != COMPRESSION_JPEG ))) )\n    {\n        char szMessage[1024] = {};\n\n        if( TIFFRGBAImageOK( m_hTIFF, szMessage ) == 1 )\n        {\n            const char* pszSourceColorSpace = nullptr;\n            nBands = 4;\n            switch( m_nPhotometric )\n            {\n                case PHOTOMETRIC_CIELAB:\n                    pszSourceColorSpace = \"CIELAB\";\n                    break;\n                case PHOTOMETRIC_LOGL:\n                    pszSourceColorSpace = \"LOGL\";\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    pszSourceColorSpace = \"LOGLUV\";\n                    break;\n                case PHOTOMETRIC_SEPARATED:\n                    pszSourceColorSpace = \"CMYK\";\n                    break;\n                case PHOTOMETRIC_YCBCR:\n                    pszSourceColorSpace = \"YCbCr\";\n                    nBands = 3; // probably true for other photometric values\n                    break;\n            }\n            if( pszSourceColorSpace )\n                m_oGTiffMDMD.SetMetadataItem( \"SOURCE_COLOR_SPACE\",\n                                            pszSourceColorSpace,\n                                            \"IMAGE_STRUCTURE\" );\n            bTreatAsRGBA = true;\n\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"TIFFRGBAImageOK says:\\n%s\", szMessage );\n        }\n    }\n\n    // libtiff has various issues with OJPEG compression and chunky-strip\n    // support with the \"classic\" scanline/strip/tile interfaces, and that\n    // wouldn't work either, so better bail out.\n    if( m_nCompression == COMPRESSION_OJPEG &&\n        !bTreatAsRGBA )\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"Old-JPEG compression only supported through RGBA interface, \"\n                 \"which cannot be used probably because the file is corrupted\");\n        return CE_Failure;\n    }\n\n    // If photometric is YCbCr, scanline/strip/tile interfaces assumes that\n    // we are ready with downsampled data. And we are not.\n    if( m_nCompression != COMPRESSION_JPEG &&\n        m_nCompression != COMPRESSION_OJPEG &&\n        m_nPhotometric == PHOTOMETRIC_YCBCR &&\n        m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        !bTreatAsRGBA )\n    {\n        uint16 nF1, nF2;\n        TIFFGetFieldDefaulted(m_hTIFF,TIFFTAG_YCBCRSUBSAMPLING,&nF1,&nF2);\n        if( nF1 != 1 || nF2 != 1 )\n        {\n            ReportError( CE_Failure, CPLE_AppDefined,\n                      \"Cannot open TIFF file with YCbCr, subsampling and \"\n                      \"BitsPerSample > 8 that is not JPEG compressed\" );\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the split interface?                   */\n/* -------------------------------------------------------------------- */\n    if( !TIFFIsTiled(m_hTIFF)\n        && m_nBitsPerSample == 8\n        && m_nBlockYSize == nRasterYSize\n        && nRasterYSize > 2000\n        && !bTreatAsRGBA\n        && CPLTestBool(CPLGetConfigOption(\"GDAL_ENABLE_TIFF_SPLIT\", \"YES\")) )\n    {\n        // libtiff 4.0.0beta5 (also\n        // 20091104) and older will crash when trying to open a\n        // all-in-one-strip YCbCr JPEG compressed TIFF (see #3259).\n#if (TIFFLIB_VERSION <= 20091104)\n        if( m_nPhotometric == PHOTOMETRIC_YCBCR &&\n            m_nCompression == COMPRESSION_JPEG )\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"Avoid using split band to open all-in-one-strip \"\n                \"YCbCr JPEG compressed TIFF because of older libtiff\" );\n        }\n        else\n#endif\n        {\n            m_bTreatAsSplit = true;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the odd bits interface?                */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsOdd = false;\n    if( m_nSampleFormat == SAMPLEFORMAT_IEEEFP )\n    {\n        if( m_nBitsPerSample == 16 || m_nBitsPerSample == 24 )\n            bTreatAsOdd = true;\n    }\n    else if( !bTreatAsRGBA && !bTreatAsBitmap\n             && m_nBitsPerSample != 8\n             && m_nBitsPerSample != 16\n             && m_nBitsPerSample != 32\n             && m_nBitsPerSample != 64\n             && m_nBitsPerSample != 128 )\n    {\n        bTreatAsOdd = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We can't support 'chunks' bigger than 2GB on 32 bit builds      */\n/* -------------------------------------------------------------------- */\n#if SIZEOF_VOIDP == 4\n    uint64 nChunkSize = 0;\n    if( m_bTreatAsSplit || m_bTreatAsSplitBitmap )\n    {\n        nChunkSize = TIFFScanlineSize64( m_hTIFF );\n    }\n    else\n    {\n        if( TIFFIsTiled(m_hTIFF) )\n            nChunkSize = TIFFTileSize64( m_hTIFF );\n        else\n            nChunkSize = TIFFStripSize64( m_hTIFF );\n    }\n    if( bTreatAsRGBA )\n    {\n        nChunkSize = std::max(nChunkSize,\n                        4 * static_cast<uint64>(m_nBlockXSize) * m_nBlockYSize);\n    }\n    if( nChunkSize > static_cast<uint64>(INT_MAX) )\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"Scanline/tile/strip size bigger than 2GB unsupported \"\n                  \"on 32-bit builds.\" );\n        return CE_Failure;\n    }\n#endif\n\n    const bool bMinIsWhite = m_nPhotometric == PHOTOMETRIC_MINISWHITE;\n\n/* -------------------------------------------------------------------- */\n/*      Check for NODATA                                                */\n/* -------------------------------------------------------------------- */\n    char *pszText = nullptr;\n    if( TIFFGetField( m_hTIFF, TIFFTAG_GDAL_NODATA, &pszText ) &&\n        !EQUAL(pszText, \"\") )\n    {\n        m_bNoDataSet = true;\n        m_dfNoDataValue = CPLAtofM( pszText );\n        if( m_nBitsPerSample == 32 && m_nSampleFormat == SAMPLEFORMAT_IEEEFP )\n        {\n            m_dfNoDataValue = GDALAdjustNoDataCloseToFloatMax(m_dfNoDataValue);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture the color table if there is one.                        */\n/* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( bTreatAsRGBA || m_nBitsPerSample > 16\n        || TIFFGetField( m_hTIFF, TIFFTAG_COLORMAP,\n                         &panRed, &panGreen, &panBlue) == 0 )\n    {\n        // Build inverted palette if we have inverted photometric.\n        // Pixel values remains unchanged.  Avoid doing this for *deep*\n        // data types (per #1882)\n        if( m_nBitsPerSample <= 16 && m_nPhotometric == PHOTOMETRIC_MINISWHITE )\n        {\n            m_poColorTable = new GDALColorTable();\n            const int nColorCount = 1 << m_nBitsPerSample;\n\n            for( int iColor = 0; iColor < nColorCount; ++iColor )\n            {\n                const short nValue =\n                    static_cast<short>(((255 * (nColorCount - 1 - iColor)) /\n                                        (nColorCount - 1)));\n                const GDALColorEntry oEntry =\n                    { nValue, nValue, nValue, static_cast<short>(255) };\n                m_poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n\n            m_nPhotometric = PHOTOMETRIC_PALETTE;\n        }\n        else\n        {\n            m_poColorTable = nullptr;\n        }\n    }\n    else\n    {\n        unsigned short nMaxColor = 0;\n\n        m_poColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 << m_nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            // TODO(schwehr): Ensure the color entries are never negative?\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast<short>(panRed[iColor] / divisor),\n                static_cast<short>(panGreen[iColor] / divisor),\n                static_cast<short>(panBlue[iColor] / divisor),\n                static_cast<short>(\n                    m_bNoDataSet && static_cast<int>(m_dfNoDataValue) == iColor\n                    ? 0\n                    : 255)\n            };\n\n            m_poColorTable->SetColorEntry( iColor, &oEntry );\n\n            nMaxColor = std::max(nMaxColor, panRed[iColor]);\n            nMaxColor = std::max(nMaxColor, panGreen[iColor]);\n            nMaxColor = std::max(nMaxColor, panBlue[iColor]);\n        }\n\n        // Bug 1384 - Some TIFF files are generated with color map entry\n        // values in range 0-255 instead of 0-65535 - try to handle these\n        // gracefully.\n        if( nMaxColor > 0 && nMaxColor < 256 )\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"TIFF ColorTable seems to be improperly scaled, fixing up.\" );\n\n            for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n            {\n                // TODO(schwehr): Ensure the color entries are never negative?\n                const GDALColorEntry oEntry = {\n                    static_cast<short>(panRed[iColor]),\n                    static_cast<short>(panGreen[iColor]),\n                    static_cast<short>(panBlue[iColor]),\n                    m_bNoDataSet &&\n                    static_cast<int>(m_dfNoDataValue) == iColor\n                    ? static_cast<short>(0)\n                    : static_cast<short>(255)\n                };\n\n                m_poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < nBands; ++iBand )\n    {\n        if( bTreatAsRGBA )\n            SetBand( iBand + 1, new GTiffRGBABand( this, iBand + 1 ) );\n        else if( m_bTreatAsSplitBitmap )\n            SetBand( iBand + 1, new GTiffSplitBitmapBand( this, iBand + 1 ) );\n        else if( m_bTreatAsSplit )\n            SetBand( iBand + 1, new GTiffSplitBand( this, iBand + 1 ) );\n        else if( bTreatAsBitmap )\n            SetBand( iBand + 1, new GTiffBitmapBand( this, iBand + 1 ) );\n        else if( bTreatAsOdd )\n            SetBand( iBand + 1, new GTiffOddBitsBand( this, iBand + 1 ) );\n        else\n            SetBand( iBand + 1, new GTiffRasterBand( this, iBand + 1 ) );\n    }\n\n    if( GetRasterBand(1)->GetRasterDataType() == GDT_Unknown )\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"Unsupported TIFF configuration: BitsPerSample(=%d) and \"\n                 \"SampleType(=%d)\",\n                 m_nBitsPerSample,\n                 m_nSampleFormat);\n        return CE_Failure;\n    }\n\n    m_bReadGeoTransform = bReadGeoTransform;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some other potentially interesting information.         */\n/* -------------------------------------------------------------------- */\n    char szWorkMDI[200] = {};\n    uint16 nShort = 0;\n\n    for( size_t iTag = 0;\n         iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n         ++iTag )\n    {\n        if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n        {\n            if( TIFFGetField( m_hTIFF, asTIFFTags[iTag].nTagVal, &pszText ) )\n                m_oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            pszText );\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT )\n        {\n            float fVal = 0.0;\n            if( TIFFGetField( m_hTIFF, asTIFFTags[iTag].nTagVal, &fVal ) )\n            {\n                CPLsnprintf( szWorkMDI, sizeof(szWorkMDI), \"%.8g\", fVal );\n                m_oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            szWorkMDI );\n            }\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT &&\n                 asTIFFTags[iTag].nTagVal != TIFFTAG_RESOLUTIONUNIT )\n        {\n            if( TIFFGetField( m_hTIFF, asTIFFTags[iTag].nTagVal, &nShort ) )\n            {\n                snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort );\n                m_oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            szWorkMDI );\n            }\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING )\n        {\n            uint32 nCount = 0;\n            if( TIFFGetField( m_hTIFF, asTIFFTags[iTag].nTagVal,\n                              &nCount, &pszText ) )\n            {\n                std::string osStr;\n                osStr.assign(pszText, nCount);\n                m_oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            osStr.c_str() );\n            }\n        }\n    }\n\n    if( TIFFGetField( m_hTIFF, TIFFTAG_RESOLUTIONUNIT, &nShort ) )\n    {\n        if( nShort == RESUNIT_NONE )\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d (unitless)\", nShort );\n        else if( nShort == RESUNIT_INCH )\n            snprintf( szWorkMDI, sizeof(szWorkMDI),\n                      \"%d (pixels/inch)\", nShort );\n        else if( nShort == RESUNIT_CENTIMETER )\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d (pixels/cm)\", nShort );\n        else\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort );\n        m_oGTiffMDMD.SetMetadataItem( \"TIFFTAG_RESOLUTIONUNIT\", szWorkMDI );\n    }\n\n    int nTagSize = 0;\n    void* pData = nullptr;\n    if( TIFFGetField( m_hTIFF, TIFFTAG_XMLPACKET, &nTagSize, &pData ) )\n    {\n        char* pszXMP =\n            static_cast<char *>( VSI_MALLOC_VERBOSE(nTagSize + 1) );\n        if( pszXMP )\n        {\n            memcpy(pszXMP, pData, nTagSize);\n            pszXMP[nTagSize] = '\\0';\n\n            char *apszMDList[2] = { pszXMP, nullptr };\n            m_oGTiffMDMD.SetMetadata(apszMDList, \"xml:XMP\");\n\n            CPLFree(pszXMP);\n        }\n    }\n\n    if( m_nCompression == COMPRESSION_NONE )\n        /* no compression tag */;\n    else if( m_nCompression == COMPRESSION_CCITTRLE )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTRLE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_CCITTFAX3 )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTFAX3\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_CCITTFAX4 )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTFAX4\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_LZW )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LZW\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_OJPEG )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"OJPEG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_JPEG )\n    {\n        if( m_nPhotometric == PHOTOMETRIC_YCBCR )\n            m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\",\n                                        \"IMAGE_STRUCTURE\" );\n        else\n            m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JPEG\",\n                                        \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_NEXT )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"NEXT\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_CCITTRLEW )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTRLEW\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_PACKBITS )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PACKBITS\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_THUNDERSCAN )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"THUNDERSCAN\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_PIXARFILM )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PIXARFILM\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_PIXARLOG )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PIXARLOG\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_DEFLATE )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DEFLATE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_ADOBE_DEFLATE )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DEFLATE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_DCS )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DCS\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_JBIG )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JBIG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_SGILOG )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"SGILOG\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_SGILOG24 )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"SGILOG24\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_JP2000 )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JP2000\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_LZMA )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LZMA\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_ZSTD )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"ZSTD\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_LERC )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC\", \"IMAGE_STRUCTURE\" );\n#if HAVE_LERC\n        uint32 nLercParamCount = 0;\n        uint32* panLercParms = nullptr;\n        if( TIFFGetField( m_hTIFF, TIFFTAG_LERC_PARAMETERS, &nLercParamCount,\n                          &panLercParms ) &&\n            nLercParamCount == 2 )\n        {\n            memcpy( m_anLercAddCompressionAndVersion, panLercParms,\n                    sizeof(m_anLercAddCompressionAndVersion) );\n        }\n\n        uint32 nAddVersion = LERC_ADD_COMPRESSION_NONE;\n        if( TIFFGetField( m_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION, &nAddVersion ) &&\n            nAddVersion != LERC_ADD_COMPRESSION_NONE )\n        {\n            if( nAddVersion == LERC_ADD_COMPRESSION_DEFLATE )\n            {\n                m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC_DEFLATE\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n            else if( nAddVersion == LERC_ADD_COMPRESSION_ZSTD )\n            {\n                m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC_ZSTD\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n        }\n        uint32 nLercVersion = LERC_VERSION_2_4;\n        if( TIFFGetField( m_hTIFF, TIFFTAG_LERC_VERSION, &nLercVersion) )\n        {\n            if( nLercVersion == LERC_VERSION_2_4 )\n            {\n                m_oGTiffMDMD.SetMetadataItem( \"LERC_VERSION\", \"2.4\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n            else\n            {\n                ReportError(CE_Warning, CPLE_AppDefined,\n                         \"Unknown Lerc version: %d\", nLercVersion);\n            }\n        }\n#endif\n    }\n    else if( m_nCompression == COMPRESSION_WEBP )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"WEBP\", \"IMAGE_STRUCTURE\" );\n    }\n    else\n    {\n        CPLString oComp;\n        oComp.Printf( \"%d\", m_nCompression);\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", oComp.c_str());\n    }\n\n    if( m_nPlanarConfig == PLANARCONFIG_CONTIG && nBands != 1 )\n        m_oGTiffMDMD.SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        m_oGTiffMDMD.SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    if( (GetRasterBand(1)->GetRasterDataType() == GDT_Byte &&\n         m_nBitsPerSample != 8 ) ||\n        (GetRasterBand(1)->GetRasterDataType() == GDT_UInt16 &&\n         m_nBitsPerSample != 16) ||\n        ((GetRasterBand(1)->GetRasterDataType() == GDT_UInt32 ||\n          GetRasterBand(1)->GetRasterDataType() == GDT_Float32) &&\n         m_nBitsPerSample != 32) )\n    {\n        for( int i = 0; i < nBands; ++i )\n            cpl::down_cast<GTiffRasterBand*>(GetRasterBand(i + 1))->\n                m_oGTiffMDMD.SetMetadataItem(\n                    \"NBITS\",\n                    CPLString().Printf(\n                        \"%d\", static_cast<int>(m_nBitsPerSample) ),\n                    \"IMAGE_STRUCTURE\" );\n    }\n\n    if( bMinIsWhite )\n        m_oGTiffMDMD.SetMetadataItem( \"MINISWHITE\", \"YES\", \"IMAGE_STRUCTURE\" );\n\n    if( TIFFGetField( m_hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n    {\n        CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n        CPLXMLNode *psItem = nullptr;\n\n        if( psRoot != nullptr && psRoot->eType == CXT_Element\n            && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n            psItem = psRoot->psChild;\n\n        for( ; psItem != nullptr; psItem = psItem->psNext )\n        {\n\n            if( psItem->eType != CXT_Element\n                || !EQUAL(psItem->pszValue,\"Item\") )\n                continue;\n\n            const char *pszKey = CPLGetXMLValue( psItem, \"name\", nullptr );\n            const char *pszValue = CPLGetXMLValue( psItem, nullptr, nullptr );\n            int nBand =\n                atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" ));\n            if( nBand < -1 || nBand > 65535 )\n                continue;\n            nBand ++;\n            const char *pszRole = CPLGetXMLValue( psItem, \"role\", \"\" );\n            const char *pszDomain = CPLGetXMLValue( psItem, \"domain\", \"\" );\n\n            if( pszKey == nullptr || pszValue == nullptr )\n                continue;\n            if( EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n                continue;\n\n            bool bIsXML = false;\n\n            if( STARTS_WITH_CI(pszDomain, \"xml:\") )\n                bIsXML = TRUE;\n\n            char *pszUnescapedValue =\n                CPLUnescapeString( pszValue, nullptr, CPLES_XML );\n            if( nBand == 0 )\n            {\n                if( bIsXML )\n                {\n                    char *apszMD[2] = { pszUnescapedValue, nullptr };\n                    m_oGTiffMDMD.SetMetadata( apszMD, pszDomain );\n                }\n                else\n                {\n                    m_oGTiffMDMD.SetMetadataItem( pszKey, pszUnescapedValue,\n                                                pszDomain );\n                }\n            }\n            else\n            {\n                GTiffRasterBand *poBand =\n                    cpl::down_cast<GTiffRasterBand*>(GetRasterBand(nBand));\n                if( poBand != nullptr )\n                {\n                    if( EQUAL(pszRole,\"scale\") )\n                    {\n                        poBand->m_bHaveOffsetScale = true;\n                        poBand->m_dfScale = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if( EQUAL(pszRole,\"offset\") )\n                    {\n                        poBand->m_bHaveOffsetScale = true;\n                        poBand->m_dfOffset = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if( EQUAL(pszRole,\"unittype\") )\n                    {\n                        poBand->m_osUnitType = pszUnescapedValue;\n                    }\n                    else if( EQUAL(pszRole,\"description\") )\n                    {\n                        poBand->m_osDescription = pszUnescapedValue;\n                    }\n                    else if( EQUAL(pszRole, \"colorinterp\") )\n                    {\n                        poBand->m_eBandInterp =\n                            GDALGetColorInterpretationByName(pszUnescapedValue);\n                    }\n                    else\n                    {\n                        if( bIsXML )\n                        {\n                            char *apszMD[2] = { pszUnescapedValue, nullptr };\n                            poBand->m_oGTiffMDMD.SetMetadata( apszMD, pszDomain );\n                        }\n                        else\n                        {\n                            poBand->m_oGTiffMDMD.SetMetadataItem(\n                                pszKey,\n                                pszUnescapedValue,\n                                pszDomain );\n                        }\n                    }\n                }\n            }\n            CPLFree( pszUnescapedValue );\n        }\n\n        CPLDestroyXMLNode( psRoot );\n    }\n\n    if( m_bStreamingIn )\n    {\n        toff_t* panOffsets = nullptr;\n        TIFFGetField( m_hTIFF,\n                      TIFFIsTiled( m_hTIFF ) ?\n                      TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                      &panOffsets );\n        if( panOffsets )\n        {\n            int nBlockCount =\n                TIFFIsTiled(m_hTIFF) ?\n                TIFFNumberOfTiles(m_hTIFF) : TIFFNumberOfStrips(m_hTIFF);\n            for( int i = 1; i < nBlockCount; ++i )\n            {\n                if( panOffsets[i] < panOffsets[i-1] )\n                {\n                    m_oGTiffMDMD.SetMetadataItem( \"UNORDERED_BLOCKS\", \"YES\",\n                                                \"TIFF\");\n                    CPLDebug(\n                        \"GTIFF\",\n                        \"Offset of block %d is lower than previous block. \"\n                        \"Reader must be careful\",\n                        i );\n                    break;\n                }\n            }\n        }\n    }\n\n    if( m_nCompression == COMPRESSION_JPEG && eAccess == GA_Update )\n    {\n        SetJPEGQualityAndTablesModeFromFile();\n    }\n\n    CPLAssert(m_bReadGeoTransform == bReadGeoTransform);\n    CPLAssert(!m_bMetadataChanged);\n    m_bMetadataChanged = false;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                         GetSiblingFiles()                            */\n/************************************************************************/\n\nchar** GTiffDataset::GetSiblingFiles()\n{\n    if( m_bHasGotSiblingFiles )\n    {\n        return oOvManager.GetSiblingFiles();\n    }\n\n    m_bHasGotSiblingFiles = true;\n    const int nMaxFiles =\n        atoi(CPLGetConfigOption(\"GDAL_READDIR_LIMIT_ON_OPEN\", \"1000\"));\n    char** papszSiblingFiles =\n        VSIReadDirEx(CPLGetDirname(m_pszFilename), nMaxFiles);\n    if( nMaxFiles > 0 && CSLCount(papszSiblingFiles) > nMaxFiles )\n    {\n        CPLDebug(\"GTiff\", \"GDAL_READDIR_LIMIT_ON_OPEN reached on %s\",\n                 CPLGetDirname(m_pszFilename));\n        CSLDestroy(papszSiblingFiles);\n        papszSiblingFiles = nullptr;\n    }\n    oOvManager.TransferSiblingFiles( papszSiblingFiles );\n\n    return papszSiblingFiles;\n}\n\n/************************************************************************/\n/*                   IdentifyAuthorizedGeoreferencingSources()          */\n/************************************************************************/\n\nvoid GTiffDataset::IdentifyAuthorizedGeoreferencingSources()\n{\n    if( m_bHasIdentifiedAuthorizedGeoreferencingSources )\n        return;\n    m_bHasIdentifiedAuthorizedGeoreferencingSources = true;\n    CPLString osGeorefSources = CSLFetchNameValueDef( papszOpenOptions,\n        \"GEOREF_SOURCES\",\n        CPLGetConfigOption(\"GDAL_GEOREF_SOURCES\",\n                           \"PAM,INTERNAL,TABFILE,WORLDFILE\") );\n    char** papszTokens = CSLTokenizeString2(osGeorefSources, \",\", 0);\n    m_nPAMGeorefSrcIndex = static_cast<signed char>(CSLFindString(papszTokens, \"PAM\"));\n    m_nINTERNALGeorefSrcIndex = static_cast<signed char>(CSLFindString(papszTokens, \"INTERNAL\"));\n    m_nTABFILEGeorefSrcIndex = static_cast<signed char>(CSLFindString(papszTokens, \"TABFILE\"));\n    m_nWORLDFILEGeorefSrcIndex = static_cast<signed char>(CSLFindString(papszTokens, \"WORLDFILE\"));\n    CSLDestroy(papszTokens);\n}\n\n/************************************************************************/\n/*                     LoadGeoreferencingAndPamIfNeeded()               */\n/************************************************************************/\n\nvoid GTiffDataset::LoadGeoreferencingAndPamIfNeeded()\n\n{\n    if( !m_bReadGeoTransform && !m_bLoadPam )\n        return;\n\n    IdentifyAuthorizedGeoreferencingSources();\n\n/* -------------------------------------------------------------------- */\n/*      Get the transform or gcps from the GeoTIFF file.                */\n/* -------------------------------------------------------------------- */\n    if( m_bReadGeoTransform )\n    {\n        m_bReadGeoTransform = false;\n\n        char *pszTabWKT = nullptr;\n        double *padfTiePoints = nullptr;\n        double *padfScale = nullptr;\n        double *padfMatrix = nullptr;\n        uint16 nCount = 0;\n        bool bPixelIsPoint = false;\n        unsigned short nRasterType = 0;\n        bool bPointGeoIgnore = false;\n\n        std::set<signed char> aoSetPriorities;\n        if( m_nINTERNALGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nINTERNALGeorefSrcIndex);\n        if( m_nTABFILEGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nTABFILEGeorefSrcIndex);\n        if( m_nWORLDFILEGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nWORLDFILEGeorefSrcIndex);\n        for(const auto nIndex: aoSetPriorities )\n        {\n            if( m_nINTERNALGeorefSrcIndex == nIndex )\n            {\n                GTIF *psGTIF = GTiffDatasetGTIFNew( m_hTIFF );  // How expensive this is?\n\n                if( psGTIF )\n                {\n                    if( GDALGTIFKeyGetSHORT(psGTIF, GTRasterTypeGeoKey,\n                                            &nRasterType, 0, 1 ) == 1\n                        && nRasterType ==\n                           static_cast<short>(RasterPixelIsPoint) )\n                    {\n                        bPixelIsPoint = true;\n                        bPointGeoIgnore =\n                            CPLTestBool(\n                                CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                                   \"FALSE\") );\n                    }\n\n                    GTIFFree( psGTIF );\n                }\n\n                m_adfGeoTransform[0] = 0.0;\n                m_adfGeoTransform[1] = 1.0;\n                m_adfGeoTransform[2] = 0.0;\n                m_adfGeoTransform[3] = 0.0;\n                m_adfGeoTransform[4] = 0.0;\n                m_adfGeoTransform[5] = 1.0;\n\n                uint16 nCountScale = 0;\n                if( TIFFGetField(m_hTIFF, TIFFTAG_GEOPIXELSCALE,\n                                 &nCountScale, &padfScale )\n                    && nCountScale >= 2\n                    && padfScale[0] != 0.0 && padfScale[1] != 0.0 )\n                {\n                    m_adfGeoTransform[1] = padfScale[0];\n                    if( padfScale[1] < 0 )\n                    {\n                        const char* pszOptionVal =\n                            CPLGetConfigOption(\"GTIFF_HONOUR_NEGATIVE_SCALEY\",\n                                               nullptr);\n                        if( pszOptionVal == nullptr )\n                        {\n                            ReportError(CE_Warning, CPLE_AppDefined,\n                                \"File with negative value for ScaleY in \"\n                                \"GeoPixelScale tag. This is rather \"\n                                \"unusual. GDAL, contrary to the GeoTIFF \"\n                                \"specification, assumes that the file \"\n                                \"was intended to be north-up, and will \"\n                                \"treat this file as if ScaleY was \"\n                                \"positive. You may override this behavior \"\n                                \"by setting the GTIFF_HONOUR_NEGATIVE_SCALEY \"\n                                \"configuration option to YES\");\n                            m_adfGeoTransform[5] = padfScale[1];\n                        }\n                        else if( CPLTestBool(pszOptionVal) )\n                        {\n                            m_adfGeoTransform[5] = -padfScale[1];\n                        }\n                        else\n                        {\n                            m_adfGeoTransform[5] = padfScale[1];\n                        }\n                    }\n                    else\n                    {\n                        m_adfGeoTransform[5] = -padfScale[1];\n                    }\n\n                    if( TIFFGetField(m_hTIFF, TIFFTAG_GEOTIEPOINTS,\n                                     &nCount, &padfTiePoints )\n                        && nCount >= 6 )\n                    {\n                        m_adfGeoTransform[0] =\n                            padfTiePoints[3] -\n                            padfTiePoints[0] * m_adfGeoTransform[1];\n                        m_adfGeoTransform[3] =\n                            padfTiePoints[4] -\n                            padfTiePoints[1] * m_adfGeoTransform[5];\n\n                        if( bPixelIsPoint && !bPointGeoIgnore )\n                        {\n                            m_adfGeoTransform[0] -=\n                                (m_adfGeoTransform[1] * 0.5 +\n                                 m_adfGeoTransform[2] * 0.5);\n                            m_adfGeoTransform[3] -=\n                                (m_adfGeoTransform[4] * 0.5 +\n                                 m_adfGeoTransform[5] * 0.5);\n                        }\n\n                        m_bGeoTransformValid = true;\n                        m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                        if( nCountScale >= 3 && GetRasterCount() == 1 &&\n                            (padfScale[2] != 0.0 ||\n                             padfTiePoints[2] != 0.0 ||\n                             padfTiePoints[5] != 0.0) )\n                        {\n                            LookForProjection();\n                            if( !m_oSRS.IsEmpty() && m_oSRS.IsVertical() )\n                            {\n                                /* modelTiePointTag = (pixel, line, z0, X, Y, Z0) */\n                                /* thus Z(some_point) = (z(some_point) - z0) * scaleZ + Z0 */\n                                /* equivalently written as */\n                                /* Z(some_point) = z(some_point) * scaleZ + offsetZ with */\n                                /* offsetZ = - z0 * scaleZ + Z0 */\n                                double dfScale = padfScale[2];\n                                double dfOffset =\n                                    -padfTiePoints[2] * dfScale + padfTiePoints[5];\n                                GTiffRasterBand* poBand =\n                                    cpl::down_cast<GTiffRasterBand*>(GetRasterBand(1));\n                                poBand->m_bHaveOffsetScale = true;\n                                poBand->m_dfScale = dfScale;\n                                poBand->m_dfOffset = dfOffset;\n                            }\n                        }\n                    }\n                }\n\n                else if( TIFFGetField(m_hTIFF, TIFFTAG_GEOTRANSMATRIX,\n                                      &nCount, &padfMatrix )\n                        && nCount == 16 )\n                {\n                    m_adfGeoTransform[0] = padfMatrix[3];\n                    m_adfGeoTransform[1] = padfMatrix[0];\n                    m_adfGeoTransform[2] = padfMatrix[1];\n                    m_adfGeoTransform[3] = padfMatrix[7];\n                    m_adfGeoTransform[4] = padfMatrix[4];\n                    m_adfGeoTransform[5] = padfMatrix[5];\n\n                    if( bPixelIsPoint && !bPointGeoIgnore )\n                    {\n                        m_adfGeoTransform[0] -=\n                            m_adfGeoTransform[1] * 0.5 + m_adfGeoTransform[2] * 0.5;\n                        m_adfGeoTransform[3] -=\n                            m_adfGeoTransform[4] * 0.5 + m_adfGeoTransform[5] * 0.5;\n                    }\n\n                    m_bGeoTransformValid = true;\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                }\n                if( m_bGeoTransformValid )\n                    break;\n            }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise try looking for a .tab, .tfw, .tifw or .wld file.     */\n/* -------------------------------------------------------------------- */\n            if( m_nTABFILEGeorefSrcIndex == nIndex )\n            {\n                char* pszGeorefFilename = nullptr;\n\n                char** papszSiblingFiles = GetSiblingFiles();\n\n                // Begin with .tab since it can also have projection info.\n                const int bTabFileOK =\n                    GDALReadTabFile2( m_pszFilename, m_adfGeoTransform,\n                                        &pszTabWKT, &m_nGCPCount, &m_pasGCPList,\n                                        papszSiblingFiles, &pszGeorefFilename );\n\n                if( bTabFileOK )\n                {\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                    // if( pszTabWKT )\n                    // {\n                    //     m_nProjectionGeorefSrcIndex = nIndex;\n                    // }\n                    if( m_nGCPCount == 0 )\n                    {\n                        m_bGeoTransformValid = true;\n                    }\n                }\n\n                if( pszGeorefFilename )\n                {\n                    CPLFree(m_pszGeorefFilename);\n                    m_pszGeorefFilename = pszGeorefFilename;\n                    pszGeorefFilename = nullptr;\n                }\n                if( m_bGeoTransformValid )\n                    break;\n            }\n\n            if( m_nWORLDFILEGeorefSrcIndex == nIndex )\n            {\n                char* pszGeorefFilename = nullptr;\n\n                char** papszSiblingFiles = GetSiblingFiles();\n\n                m_bGeoTransformValid = CPL_TO_BOOL( GDALReadWorldFile2(\n                                m_pszFilename, nullptr, m_adfGeoTransform,\n                                papszSiblingFiles, &pszGeorefFilename) );\n\n                if( !m_bGeoTransformValid )\n                {\n                    m_bGeoTransformValid =\n                        CPL_TO_BOOL( GDALReadWorldFile2(\n                            m_pszFilename, \"wld\", m_adfGeoTransform,\n                            papszSiblingFiles, &pszGeorefFilename ) );\n                }\n                if( m_bGeoTransformValid )\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                if( pszGeorefFilename )\n                {\n                    CPLFree(m_pszGeorefFilename);\n                    m_pszGeorefFilename = pszGeorefFilename;\n                    pszGeorefFilename = nullptr;\n                }\n                if( m_bGeoTransformValid )\n                    break;\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Check for GCPs.                                                 */\n/* -------------------------------------------------------------------- */\n        if( m_nINTERNALGeorefSrcIndex >= 0 &&\n            TIFFGetField(m_hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && !m_bGeoTransformValid )\n        {\n            if( m_nGCPCount > 0 )\n            {\n                GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n                CPLFree( m_pasGCPList );\n            }\n            m_nGCPCount = nCount / 6;\n            m_pasGCPList =\n                static_cast<GDAL_GCP *>(CPLCalloc(sizeof(GDAL_GCP), m_nGCPCount));\n\n            for( int iGCP = 0; iGCP < m_nGCPCount; ++iGCP )\n            {\n                char szID[32] = {};\n\n                snprintf( szID, sizeof(szID), \"%d\", iGCP + 1 );\n                m_pasGCPList[iGCP].pszId = CPLStrdup( szID );\n                m_pasGCPList[iGCP].pszInfo = CPLStrdup(\"\");\n                m_pasGCPList[iGCP].dfGCPPixel = padfTiePoints[iGCP*6+0];\n                m_pasGCPList[iGCP].dfGCPLine = padfTiePoints[iGCP*6+1];\n                m_pasGCPList[iGCP].dfGCPX = padfTiePoints[iGCP*6+3];\n                m_pasGCPList[iGCP].dfGCPY = padfTiePoints[iGCP*6+4];\n                m_pasGCPList[iGCP].dfGCPZ = padfTiePoints[iGCP*6+5];\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    m_pasGCPList[iGCP].dfGCPPixel += 0.5;\n                    m_pasGCPList[iGCP].dfGCPLine += 0.5;\n                }\n            }\n            m_nGeoTransformGeorefSrcIndex = m_nINTERNALGeorefSrcIndex;\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Did we find a tab file?  If so we will use its coordinate       */\n/*      system and give it precedence.                                  */\n/* -------------------------------------------------------------------- */\n        if( pszTabWKT != nullptr && m_oSRS.IsEmpty() )\n        {\n            m_oSRS.SetFromUserInput(pszTabWKT);\n            m_bLookedForProjection = true;\n        }\n\n        CPLFree( pszTabWKT );\n    }\n\n    if( m_bLoadPam && m_nPAMGeorefSrcIndex >= 0 )\n    {\n/* -------------------------------------------------------------------- */\n/*      Initialize any PAM information.                                 */\n/* -------------------------------------------------------------------- */\n        CPLAssert(!m_bColorProfileMetadataChanged);\n        CPLAssert(!m_bMetadataChanged);\n        CPLAssert(!m_bGeoTIFFInfoChanged);\n        CPLAssert(!m_bNoDataChanged);\n\n        // We must absolutely unset m_bLoadPam now, otherwise calling\n        // GetFileList() on a .tif with a .aux will result in an (almost)\n        // endless sequence of calls.\n        m_bLoadPam = false;\n\n        TryLoadXML( GetSiblingFiles() );\n        ApplyPamInfo();\n\n        m_bColorProfileMetadataChanged = false;\n        m_bMetadataChanged = false;\n        m_bGeoTIFFInfoChanged = false;\n        m_bNoDataChanged = false;\n\n        for( int i = 1; i <= nBands; ++i )\n        {\n            GTiffRasterBand* poBand =\n                cpl::down_cast<GTiffRasterBand *>(GetRasterBand(i));\n\n            /* Load scale, offset and unittype from PAM if available */\n            if( !poBand->m_bHaveOffsetScale )\n            {\n                int nHaveOffsetScale = FALSE;\n                poBand->m_dfScale =\n                    poBand->GDALPamRasterBand::GetScale( &nHaveOffsetScale );\n                poBand->m_bHaveOffsetScale = CPL_TO_BOOL(nHaveOffsetScale);\n                poBand->m_dfOffset = poBand->GDALPamRasterBand::GetOffset();\n            }\n            if( poBand->m_osUnitType.empty() )\n            {\n                const char* pszUnitType =\n                    poBand->GDALPamRasterBand::GetUnitType();\n                if( pszUnitType )\n                    poBand->m_osUnitType = pszUnitType;\n            }\n            if( poBand->m_osDescription.empty() )\n                poBand->m_osDescription =\n                    poBand->GDALPamRasterBand::GetDescription();\n\n            GDALColorInterp ePAMColorInterp =\n                poBand->GDALPamRasterBand::GetColorInterpretation();\n            if( ePAMColorInterp != GCI_Undefined )\n                poBand->m_eBandInterp = ePAMColorInterp;\n        }\n    }\n    m_bLoadPam = false;\n}\n\n/************************************************************************/\n/*                   SetStructuralMDFromParent()                        */\n/************************************************************************/\n\nvoid GTiffDataset::SetStructuralMDFromParent(GTiffDataset* poParentDS)\n{\n    m_bBlockOrderRowMajor = poParentDS->m_bBlockOrderRowMajor;\n    m_bLeaderSizeAsUInt4 = poParentDS->m_bLeaderSizeAsUInt4;\n    m_bTrailerRepeatedLast4BytesRepeated = poParentDS->m_bTrailerRepeatedLast4BytesRepeated;\n    m_bMaskInterleavedWithImagery = poParentDS->m_bMaskInterleavedWithImagery;\n    m_bWriteEmptyTiles = poParentDS->m_bWriteEmptyTiles;\n}\n\n/************************************************************************/\n/*                          ScanDirectories()                           */\n/*                                                                      */\n/*      Scan through all the directories finding overviews, masks       */\n/*      and subdatasets.                                                */\n/************************************************************************/\n\nvoid GTiffDataset::ScanDirectories()\n\n{\n/* -------------------------------------------------------------------- */\n/*      We only scan once.  We do not scan for non-base datasets.       */\n/* -------------------------------------------------------------------- */\n    if( !m_bScanDeferred )\n        return;\n\n    m_bScanDeferred = false;\n\n    if( m_poBaseDS )\n        return;\n\n    Crystalize();\n\n    CPLDebug( \"GTiff\", \"ScanDirectories()\" );\n\n/* ==================================================================== */\n/*      Scan all directories.                                           */\n/* ==================================================================== */\n    CPLStringList aosSubdatasets;\n    int iDirIndex = 0;\n\n    FlushDirectory();\n\n    do\n    {\n        // Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if !defined(SUPPORTS_MORE_THAN_32768_DIRECTORIES)\n        if( iDirIndex == 32768 )\n            break;\n#endif\n        toff_t nTopDir = TIFFCurrentDirOffset(m_hTIFF);\n        uint32 nSubType = 0;\n\n        ++iDirIndex;\n\n        toff_t *tmpSubIFDOffsets = nullptr;\n        toff_t *subIFDOffsets = nullptr;\n        uint16 nSubIFDs = 0;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_SUBIFD, &nSubIFDs, &tmpSubIFDOffsets) && iDirIndex == 1)\n        {\n            subIFDOffsets = static_cast<toff_t *>(CPLMalloc(nSubIFDs * sizeof(toff_t)));\n            for (uint16 iSubIFD = 0; iSubIFD < nSubIFDs; iSubIFD++)\n            {\n                subIFDOffsets[iSubIFD] = tmpSubIFDOffsets[iSubIFD];\n            }\n        }\n\n        //early break for backwards compatibility: if the first directory read is also the last, and there are no subIFDs, no use continuing\n        if( iDirIndex==1 && nSubIFDs==0 && TIFFLastDirectory( m_hTIFF )) {\n            CPLFree(subIFDOffsets);\n            break;\n        }\n\n\n        for( uint16 iSubIFD = 0; iSubIFD<=nSubIFDs; iSubIFD++ ) {\n            toff_t nThisDir = nTopDir;\n            if ( iSubIFD > 0 && iDirIndex > 1 ) //don't read subIFDs if we are not in the original directory\n                break;\n            if ( iSubIFD > 0 ) {\n                // make static analyzer happy. subIFDOffsets cannot be null if iSubIFD>0\n                assert(subIFDOffsets != nullptr); \n                nThisDir = subIFDOffsets[iSubIFD-1];\n                //CPLDebug(\"GTiff\", \"Opened subIFD %d/%d at offset %llu.\", iSubIFD, nSubIFDs, nThisDir);\n                if (!TIFFSetSubDirectory(m_hTIFF,nThisDir))\n                    break;\n            }\n\n\n            if( !TIFFGetField(m_hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n                nSubType = 0;\n\n            /* Embedded overview of the main image */\n            if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                (nSubType & FILETYPE_MASK) == 0 &&\n                ((nSubIFDs==0 && iDirIndex != 1) || iSubIFD>0) &&\n                m_nOverviewCount < 30 /* to avoid DoS */ )\n            {\n                GTiffDataset *poODS = new GTiffDataset();\n                poODS->ShareLockWithParentDataset(this);\n                poODS->SetStructuralMDFromParent(this);\n                poODS->m_pszFilename = CPLStrdup(m_pszFilename);\n                if( poODS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                    eAccess ) != CE_None\n                    || poODS->GetRasterCount() != GetRasterCount() )\n                {\n                    delete poODS;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened %dx%d overview.\",\n                            poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                    ++m_nOverviewCount;\n                    m_papoOverviewDS = static_cast<GTiffDataset **>(\n                        CPLRealloc(m_papoOverviewDS,\n                                m_nOverviewCount * (sizeof(void*))) );\n                    m_papoOverviewDS[m_nOverviewCount-1] = poODS;\n                    poODS->m_poBaseDS = this;\n                    poODS->m_bIsOverview = true;\n                }\n            }\n            // Embedded mask of the main image.\n            else if( (nSubType & FILETYPE_MASK) != 0 &&\n                    (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                    ((nSubIFDs==0 && iDirIndex != 1) || iSubIFD>0) &&\n                    m_poMaskDS == nullptr )\n            {\n                m_poMaskDS = new GTiffDataset();\n                m_poMaskDS->ShareLockWithParentDataset(this);\n                m_poMaskDS->SetStructuralMDFromParent(this);\n                m_poMaskDS->m_pszFilename = CPLStrdup(m_pszFilename);\n\n                // The TIFF6 specification - page 37 - only allows 1\n                // SamplesPerPixel and 1 BitsPerSample Here we support either 1 or\n                // 8 bit per sample and we support either 1 sample per pixel or as\n                // many samples as in the main image We don't check the value of\n                // the PhotometricInterpretation tag, which should be set to\n                // \"Transparency mask\" (4) according to the specification (page\n                // 36).  However, the TIFF6 specification allows image masks to\n                // have a higher resolution than the main image, what we don't\n                // support here.\n\n                if( m_poMaskDS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                        eAccess ) != CE_None\n                    || m_poMaskDS->GetRasterCount() == 0\n                    || !(m_poMaskDS->GetRasterCount() == 1\n                        || m_poMaskDS->GetRasterCount() == GetRasterCount())\n                    || m_poMaskDS->GetRasterXSize() != GetRasterXSize()\n                    || m_poMaskDS->GetRasterYSize() != GetRasterYSize()\n                    || m_poMaskDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete m_poMaskDS;\n                    m_poMaskDS = nullptr;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened band mask.\");\n                    m_poMaskDS->m_poBaseDS = this;\n                    m_poMaskDS->m_poImageryDS = this;\n\n                    m_poMaskDS->m_bPromoteTo8Bits =\n                        CPLTestBool(\n                            CPLGetConfigOption( \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                                \"YES\" ) );\n                }\n            }\n\n            // Embedded mask of an overview.  The TIFF6 specification allows the\n            // combination of the FILETYPE_xxxx masks.\n            else if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                    (nSubType & FILETYPE_MASK) != 0 &&\n                    ((nSubIFDs==0 && iDirIndex != 1) || iSubIFD>0))\n            {\n                GTiffDataset* poDS = new GTiffDataset();\n                poDS->ShareLockWithParentDataset(this);\n                poDS->SetStructuralMDFromParent(this);\n                poDS->m_pszFilename = CPLStrdup(m_pszFilename);\n                if( poDS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                    eAccess ) != CE_None\n                    || poDS->GetRasterCount() == 0\n                    || poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poDS;\n                }\n                else\n                {\n                    int i = 0;  // Used after for.\n                    for( ; i < m_nOverviewCount; ++i )\n                    {\n                        auto poOvrDS = cpl::down_cast<GTiffDataset*>(\n                                GDALDataset::FromHandle(m_papoOverviewDS[i]));\n                        if( poOvrDS->m_poMaskDS == nullptr &&\n                            poDS->GetRasterXSize() ==\n                            m_papoOverviewDS[i]->GetRasterXSize() &&\n                            poDS->GetRasterYSize() ==\n                            m_papoOverviewDS[i]->GetRasterYSize() &&\n                            (poDS->GetRasterCount() == 1 ||\n                            poDS->GetRasterCount() == GetRasterCount()))\n                        {\n                            CPLDebug(\n                                \"GTiff\", \"Opened band mask for %dx%d overview.\",\n                                poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                            poDS->m_poImageryDS = poOvrDS;\n                            poOvrDS->m_poMaskDS = poDS;\n                            poDS->m_bPromoteTo8Bits =\n                                CPLTestBool(\n                                    CPLGetConfigOption(\n                                        \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                        \"YES\" ) );\n                            poDS->m_poBaseDS = this;\n                            break;\n                        }\n                    }\n                    if( i == m_nOverviewCount )\n                    {\n                        delete poDS;\n                    }\n                }\n            }\n            else if( !m_bSingleIFDOpened && (nSubType == 0 || nSubType == FILETYPE_PAGE) )\n            {\n                uint32 nXSize = 0;\n                uint32 nYSize = 0;\n\n                TIFFGetField( m_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n                TIFFGetField( m_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n                // For Geodetic TIFF grids (GTG)\n                // (https://proj.org/specifications/geodetictiffgrids.html)\n                // extract the grid_name to put it in the description\n                std::string osFriendlyName;\n                char* pszText = nullptr;\n                if( TIFFGetField( m_hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) &&\n                    strstr(pszText, \"grid_name\") != nullptr )\n                {\n                    CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n                    CPLXMLNode *psItem = nullptr;\n\n                    if( psRoot != nullptr && psRoot->eType == CXT_Element\n                        && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n                        psItem = psRoot->psChild;\n\n                    for( ; psItem != nullptr; psItem = psItem->psNext )\n                    {\n\n                        if( psItem->eType != CXT_Element\n                            || !EQUAL(psItem->pszValue,\"Item\") )\n                            continue;\n\n                        const char *pszKey = CPLGetXMLValue( psItem, \"name\", nullptr );\n                        const char *pszValue = CPLGetXMLValue( psItem, nullptr, nullptr );\n                        int nBand =\n                            atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" ));\n                        if( pszKey && pszValue && nBand <= 0 &&\n                            EQUAL(pszKey, \"grid_name\") )\n                        {\n                            osFriendlyName = \": \";\n                            osFriendlyName += pszValue;\n                            break;\n                        }\n                    }\n\n                    CPLDestroyXMLNode(psRoot);\n                }\n\n                if( nXSize > INT_MAX || nYSize > INT_MAX )\n                {\n                    CPLDebug(\"GTiff\",\n                            \"Skipping directory with too large image: %u x %u\",\n                            nXSize, nYSize);\n                }\n                else\n                {\n                    uint16 nSPP = 0;\n                    if( !TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP ) )\n                        nSPP = 1;\n\n                    CPLString osName, osDesc;\n                    osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\",\n                                iDirIndex, iDirIndex, m_pszFilename );\n                    osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\",\n                                iDirIndex, iDirIndex,\n                                static_cast<int>(nXSize),\n                                static_cast<int>(nYSize),\n                                nSPP );\n                    osDesc += osFriendlyName;\n\n                    aosSubdatasets.AddString(osName);\n                    aosSubdatasets.AddString(osDesc);\n                }\n            }\n        }\n        CPLFree(subIFDOffsets);\n\n        // Make sure we are stepping from the expected directory regardless\n        // of churn done processing the above.\n        if( TIFFCurrentDirOffset(m_hTIFF) != nTopDir )\n            TIFFSetSubDirectory( m_hTIFF, nTopDir );\n    } while( !m_bSingleIFDOpened && !TIFFLastDirectory( m_hTIFF ) && TIFFReadDirectory( m_hTIFF ) != 0 );\n\n\n    ReloadDirectory();\n\n    // If we have a mask for the main image, loop over the overviews, and if\n    // they have a mask, let's set this mask as an overview of the main mask.\n    if( m_poMaskDS != nullptr )\n    {\n        for( int i = 0; i < m_nOverviewCount; ++i )\n        {\n            if( cpl::down_cast<GTiffDataset *>(GDALDataset::FromHandle(\n                   m_papoOverviewDS[i]))->m_poMaskDS != nullptr)\n            {\n                ++m_poMaskDS->m_nOverviewCount;\n                m_poMaskDS->m_papoOverviewDS = static_cast<GTiffDataset **>(\n                    CPLRealloc(m_poMaskDS->m_papoOverviewDS,\n                               m_poMaskDS->m_nOverviewCount * (sizeof(void*))) );\n                m_poMaskDS->m_papoOverviewDS[m_poMaskDS->m_nOverviewCount-1] =\n                    cpl::down_cast<GTiffDataset*>(GDALDataset::FromHandle(\n                        m_papoOverviewDS[i]))->m_poMaskDS;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n    if( aosSubdatasets.size() > 2 )\n    {\n        m_oGTiffMDMD.SetMetadata( aosSubdatasets.List(), \"SUBDATASETS\" );\n    }\n}\n\nstatic signed char GTiffGetLZMAPreset(char** papszOptions)\n{\n    int nLZMAPreset = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"LZMA_PRESET\" );\n    if( pszValue != nullptr )\n    {\n        nLZMAPreset = atoi( pszValue );\n        if( !(nLZMAPreset >= 0 && nLZMAPreset <= 9) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"LZMA_PRESET=%s value not recognised, ignoring.\",\n                      pszValue );\n            nLZMAPreset = -1;\n        }\n    }\n    return static_cast<signed char>(nLZMAPreset);\n}\n\nstatic signed char GTiffGetZSTDPreset(char** papszOptions)\n{\n    int nZSTDLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"ZSTD_LEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nZSTDLevel = atoi( pszValue );\n        if( !(nZSTDLevel >= 1 && nZSTDLevel <= 22) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"ZSTD_LEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nZSTDLevel = -1;\n        }\n    }\n    return static_cast<signed char>(nZSTDLevel);\n}\n\n#if HAVE_LERC\nstatic double GTiffGetLERCMaxZError(char** papszOptions)\n{\n    return CPLAtof(CSLFetchNameValueDef( papszOptions, \"MAX_Z_ERROR\", \"0.0\") );\n}\n#endif\n\nstatic signed char GTiffGetWebPLevel(char** papszOptions)\n{\n    int nWebPLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"WEBP_LEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nWebPLevel = atoi( pszValue );\n        if( !(nWebPLevel >= 1 && nWebPLevel <= 100) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"WEBP_LEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nWebPLevel = -1;\n        }\n    }\n    return static_cast<signed char>(nWebPLevel);\n}\n\nstatic bool GTiffGetWebPLossless(char** papszOptions)\n{\n    return CPLFetchBool( papszOptions, \"WEBP_LOSSLESS\", false);\n}\n\nstatic signed char GTiffGetZLevel(char** papszOptions)\n{\n    int nZLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"ZLEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nZLevel = atoi( pszValue );\n#ifdef TIFFTAG_DEFLATE_SUBCODEC\n        constexpr int nMaxLevel = 12;\n#ifndef LIBDEFLATE_SUPPORT\n        if( nZLevel > 9 && nZLevel <= nMaxLevel )\n        {\n            CPLDebug(\"GTiff\",\n                     \"ZLEVEL=%d not supported in a non-libdeflate enabled \"\n                     \"libtiff build. Capping to 9\",\n                     nZLevel);\n            nZLevel = 9;\n        }\n#endif\n#else\n        constexpr int nMaxLevel = 9;\n#endif\n        if( nZLevel < 1 || nZLevel > nMaxLevel )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"ZLEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nZLevel = -1;\n        }\n    }\n    return static_cast<signed char>(nZLevel);\n}\n\nstatic signed char GTiffGetJpegQuality(char** papszOptions)\n{\n    int nJpegQuality = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"JPEG_QUALITY\" );\n    if( pszValue != nullptr )\n    {\n        nJpegQuality = atoi( pszValue );\n        if( nJpegQuality < 1 || nJpegQuality > 100 )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"JPEG_QUALITY=%s value not recognised, ignoring.\",\n                      pszValue );\n            nJpegQuality = -1;\n        }\n    }\n    return static_cast<signed char>(nJpegQuality);\n}\n\nstatic signed char GTiffGetJpegTablesMode(char** papszOptions)\n{\n    return static_cast<signed char>(\n        atoi(CSLFetchNameValueDef( papszOptions, \"JPEGTABLESMODE\",\n                                      CPLSPrintf(\"%d\",\n                                                knGTIFFJpegTablesModeDefault))));\n}\n\n/************************************************************************/\n/*                        GetDiscardLsbOption()                         */\n/************************************************************************/\n\nvoid GTiffDataset::GetDiscardLsbOption(char** papszOptions)\n{\n    const char* pszBits = CSLFetchNameValue( papszOptions, \"DISCARD_LSB\" );\n    if( pszBits == nullptr)\n        return;\n\n    if( m_nPhotometric == PHOTOMETRIC_PALETTE )\n    {\n        ReportError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored on a paletted image\");\n        return;\n    }\n    if( !(m_nBitsPerSample == 8 || m_nBitsPerSample == 16 || m_nBitsPerSample == 32) )\n    {\n        ReportError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored on non 8, 16 or 32 bits integer images\");\n        return;\n    }\n\n    char** papszTokens = CSLTokenizeString2( pszBits, \",\", 0 );\n    const int nTokens = CSLCount(papszTokens);\n    if( nTokens == 1 || nTokens == nBands )\n    {\n        m_panMaskOffsetLsb = static_cast<MaskOffset*>(CPLCalloc(nBands, sizeof(MaskOffset)));\n        for( int i = 0; i < nBands; ++i )\n        {\n            int nBits = atoi(papszTokens[nTokens == 1 ? 0 : i]);\n            m_panMaskOffsetLsb[i].nMask = ~((1 << nBits)-1);\n            if( nBits > 1 )\n                m_panMaskOffsetLsb[i].nOffset = 1 << (nBits - 1);\n        }\n    }\n    else\n    {\n        ReportError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored: wrong number of components\");\n    }\n    CSLDestroy(papszTokens);\n}\n\n/************************************************************************/\n/*                             GetProfile()                             */\n/************************************************************************/\n\nstatic GTiffProfile GetProfile(const char* pszProfile)\n{\n    GTiffProfile eProfile = GTiffProfile::GDALGEOTIFF;\n    if( pszProfile != nullptr )\n    {\n        if( EQUAL(pszProfile, szPROFILE_BASELINE) )\n            eProfile = GTiffProfile::BASELINE;\n        else if( EQUAL(pszProfile, szPROFILE_GeoTIFF) )\n            eProfile = GTiffProfile::GEOTIFF;\n        else if( !EQUAL(pszProfile, szPROFILE_GDALGeoTIFF) )\n        {\n            CPLError(CE_Warning, CPLE_NotSupported,\n                     \"Unsupported value for PROFILE: %s\", pszProfile);\n        }\n    }\n    return eProfile;\n}\n\n/************************************************************************/\n/*                            GTiffCreate()                             */\n/*                                                                      */\n/*      Shared functionality between GTiffDataset::Create() and         */\n/*      GTiffCreateCopy() for creating TIFF file based on a set of      */\n/*      options and a configuration.                                    */\n/************************************************************************/\n\nTIFF *GTiffDataset::CreateLL( const char * pszFilename,\n                              int nXSize, int nYSize, int l_nBands,\n                              GDALDataType eType,\n                              double dfExtraSpaceForOverviews,\n                              char **papszParmList,\n                              VSILFILE** pfpL,\n                              CPLString& l_osTmpFilename )\n\n{\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Blow on a few errors.                                           */\n/* -------------------------------------------------------------------- */\n    if( nXSize < 1 || nYSize < 1 || l_nBands < 1 )\n    {\n        ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n            \"Attempt to create %dx%dx%d TIFF file, but width, height and bands\"\n            \"must be positive.\",\n            nXSize, nYSize, l_nBands );\n\n        return nullptr;\n    }\n\n    if( l_nBands > 65535 )\n    {\n        ReportError(pszFilename, CE_Failure, CPLE_AppDefined,\n                  \"Attempt to create %dx%dx%d TIFF file, but bands \"\n                  \"must be lesser or equal to 65535.\",\n                  nXSize, nYSize, l_nBands );\n\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Setup values based on options.                                  */\n/* -------------------------------------------------------------------- */\n    const GTiffProfile eProfile = GetProfile(\n        CSLFetchNameValue(papszParmList, \"PROFILE\"));\n\n    const bool bTiled = CPLFetchBool( papszParmList, \"TILED\", false );\n\n    int l_nBlockXSize = 0;\n    const char *pszValue = CSLFetchNameValue(papszParmList, \"BLOCKXSIZE\");\n    if( pszValue != nullptr )\n    {\n        l_nBlockXSize = atoi( pszValue );\n        if( l_nBlockXSize < 0 )\n        {\n            ReportError( pszFilename,CE_Failure, CPLE_IllegalArg,\n                     \"Invalid value for BLOCKXSIZE\");\n            return nullptr;\n        }\n    }\n\n    int l_nBlockYSize = 0;\n    pszValue = CSLFetchNameValue(papszParmList, \"BLOCKYSIZE\");\n    if( pszValue != nullptr )\n    {\n        l_nBlockYSize = atoi( pszValue );\n        if( l_nBlockYSize < 0 )\n        {\n            ReportError( pszFilename, CE_Failure, CPLE_IllegalArg,\n                     \"Invalid value for BLOCKYSIZE\");\n            return nullptr;\n        }\n    }\n\n    if( bTiled )\n    {\n        if( l_nBlockXSize == 0 )\n            l_nBlockXSize = 256;\n\n        if( l_nBlockYSize == 0 )\n            l_nBlockYSize = 256;\n    }\n\n    int nPlanar = 0;\n    pszValue = CSLFetchNameValue(papszParmList, \"INTERLEAVE\");\n    if( pszValue != nullptr )\n    {\n        if( EQUAL( pszValue, \"PIXEL\" ) )\n            nPlanar = PLANARCONFIG_CONTIG;\n        else if( EQUAL( pszValue, \"BAND\" ) )\n        {\n            nPlanar = PLANARCONFIG_SEPARATE;\n        }\n        else\n        {\n            ReportError( pszFilename,CE_Failure, CPLE_IllegalArg, \n                      \"INTERLEAVE=%s unsupported, value must be PIXEL or BAND.\",\n                      pszValue );\n            return nullptr;\n        }\n    }\n    else\n    {\n        nPlanar = PLANARCONFIG_CONTIG;\n    }\n\n    int l_nCompression = COMPRESSION_NONE;\n    pszValue = CSLFetchNameValue( papszParmList, \"COMPRESS\" );\n    if( pszValue != nullptr )\n    {\n        l_nCompression = GTIFFGetCompressionMethod(pszValue, \"COMPRESS\");\n        if( l_nCompression < 0 )\n            return nullptr;\n    }\n\n    int nPredictor = PREDICTOR_NONE;\n    pszValue = CSLFetchNameValue( papszParmList, \"PREDICTOR\" );\n    if( pszValue != nullptr )\n        nPredictor = atoi( pszValue );\n\n    const int l_nZLevel = GTiffGetZLevel(papszParmList);\n    const int l_nLZMAPreset = GTiffGetLZMAPreset(papszParmList);\n    const int l_nZSTDLevel = GTiffGetZSTDPreset(papszParmList);\n    const int l_nWebPLevel = GTiffGetWebPLevel(papszParmList);\n    const bool l_bWebPLossless = GTiffGetWebPLossless(papszParmList);\n    const int l_nJpegQuality = GTiffGetJpegQuality(papszParmList);\n    const int l_nJpegTablesMode = GTiffGetJpegTablesMode(papszParmList);\n#if HAVE_LERC\n    const double l_dfMaxZError = GTiffGetLERCMaxZError(papszParmList);\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Streaming related code                                          */\n/* -------------------------------------------------------------------- */\n    const CPLString osOriFilename(pszFilename);\n    bool bStreaming =\n        strcmp(pszFilename, \"/vsistdout/\") == 0 ||\n        CPLFetchBool(papszParmList, \"STREAMABLE_OUTPUT\", false);\n#ifdef S_ISFIFO\n    if( !bStreaming )\n    {\n        VSIStatBufL sStat;\n        if( VSIStatExL( pszFilename, &sStat,\n                        VSI_STAT_EXISTS_FLAG | VSI_STAT_NATURE_FLAG) == 0 &&\n             S_ISFIFO(sStat.st_mode) )\n        {\n            bStreaming = true;\n        }\n    }\n#endif\n    if( bStreaming &&\n        !EQUAL( \"NONE\",\n                CSLFetchNameValueDef(papszParmList, \"COMPRESS\", \"NONE\")) )\n    {\n        ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n            \"Streaming only supported to uncompressed TIFF\" );\n        return nullptr;\n    }\n    if( bStreaming && CPLFetchBool(papszParmList, \"SPARSE_OK\", false) )\n    {\n        ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n            \"Streaming not supported with SPARSE_OK\" );\n        return nullptr;\n    }\n    const bool bCopySrcOverviews = CPLFetchBool(papszParmList, \"COPY_SRC_OVERVIEWS\", false);\n    if( bStreaming && bCopySrcOverviews )\n    {\n        ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n            \"Streaming not supported with COPY_SRC_OVERVIEWS\" );\n        return nullptr;\n    }\n    if( bStreaming )\n    {\n        static int nCounter = 0;\n        l_osTmpFilename = CPLSPrintf(\"/vsimem/vsistdout_%d.tif\", ++nCounter);\n        pszFilename = l_osTmpFilename.c_str();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Compute the uncompressed size.                                  */\n/* -------------------------------------------------------------------- */\n    const double dfUncompressedImageSize =\n        nXSize * static_cast<double>(nYSize) * l_nBands *\n        GDALGetDataTypeSizeBytes(eType)\n        + dfExtraSpaceForOverviews;\n\n/* -------------------------------------------------------------------- */\n/*      Should the file be created as a bigtiff file?                   */\n/* -------------------------------------------------------------------- */\n    const char *pszBIGTIFF = CSLFetchNameValue(papszParmList, \"BIGTIFF\");\n\n    if( pszBIGTIFF == nullptr )\n        pszBIGTIFF = \"IF_NEEDED\";\n\n    bool bCreateBigTIFF = false;\n    if( EQUAL(pszBIGTIFF, \"IF_NEEDED\") )\n    {\n        if( l_nCompression == COMPRESSION_NONE\n            && dfUncompressedImageSize > 4200000000.0 )\n            bCreateBigTIFF = true;\n    }\n    else if( EQUAL(pszBIGTIFF, \"IF_SAFER\") )\n    {\n        if( dfUncompressedImageSize > 2000000000.0 )\n            bCreateBigTIFF = true;\n    }\n    else\n    {\n        bCreateBigTIFF = CPLTestBool( pszBIGTIFF );\n        if( !bCreateBigTIFF && l_nCompression == COMPRESSION_NONE &&\n             dfUncompressedImageSize > 4200000000.0 )\n        {\n            ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                \"The TIFF file will be larger than 4GB, so BigTIFF is \"\n                \"necessary.  Creation failed.\");\n            return nullptr;\n        }\n    }\n\n    if( bCreateBigTIFF )\n        CPLDebug( \"GTiff\", \"File being created as a BigTIFF.\" );\n\n/* -------------------------------------------------------------------- */\n/*      Sanity check.                                                   */\n/* -------------------------------------------------------------------- */\n    if( bTiled )\n    {\n        unsigned nTileXCount = DIV_ROUND_UP(nXSize, l_nBlockXSize);\n        unsigned nTileYCount = DIV_ROUND_UP(nYSize, l_nBlockYSize);\n        // libtiff implementation limitation\n        if( nTileXCount > 0x80000000U / (bCreateBigTIFF ? 8 : 4) / nTileYCount )\n        {\n            ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                     \"File too large regarding tile size. This would result \"\n                     \"in a file with tile arrays larger than 2GB\");\n            return nullptr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check free space (only for big, non sparse, uncompressed)       */\n/* -------------------------------------------------------------------- */\n    if( l_nCompression == COMPRESSION_NONE &&\n        dfUncompressedImageSize >= 1e9 &&\n        !CPLFetchBool(papszParmList, \"SPARSE_OK\", false) &&\n        osOriFilename != \"/vsistdout/\" &&\n        osOriFilename != \"/vsistdout_redirect/\" &&\n        CPLTestBool(CPLGetConfigOption(\"CHECK_DISK_FREE_SPACE\", \"TRUE\")) )\n    {\n        GIntBig nFreeDiskSpace =\n            VSIGetDiskFreeSpace(CPLGetDirname(pszFilename));\n        if( nFreeDiskSpace >= 0 &&\n            nFreeDiskSpace < dfUncompressedImageSize )\n        {\n            ReportError( pszFilename, CE_Failure, CPLE_FileIO,\n                      \"Free disk space available is \" CPL_FRMT_GIB \" bytes, \"\n                      \"whereas \" CPL_FRMT_GIB \" are at least necessary. \"\n                      \"You can disable this check by defining the \"\n                      \"CHECK_DISK_FREE_SPACE configuration option to FALSE.\",\n                      nFreeDiskSpace,\n                      static_cast<GIntBig>(dfUncompressedImageSize) );\n            return nullptr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check if the user wishes a particular endianness                */\n/* -------------------------------------------------------------------- */\n\n    int eEndianness = ENDIANNESS_NATIVE;\n    pszValue = CSLFetchNameValue(papszParmList, \"ENDIANNESS\");\n    if( pszValue == nullptr )\n        pszValue = CPLGetConfigOption( \"GDAL_TIFF_ENDIANNESS\", nullptr );\n    if( pszValue != nullptr )\n    {\n        if( EQUAL(pszValue, \"LITTLE\") )\n        {\n            eEndianness = ENDIANNESS_LITTLE;\n        }\n        else if( EQUAL(pszValue, \"BIG\") )\n        {\n            eEndianness = ENDIANNESS_BIG;\n        }\n        else if( EQUAL(pszValue, \"INVERTED\") )\n        {\n#ifdef CPL_LSB\n            eEndianness = ENDIANNESS_BIG;\n#else\n            eEndianness = ENDIANNESS_LITTLE;\n#endif\n        }\n        else if( !EQUAL(pszValue, \"NATIVE\") )\n        {\n            ReportError( pszFilename, CE_Warning, CPLE_NotSupported,\n                \"ENDIANNESS=%s not supported. Defaulting to NATIVE\", pszValue );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n\n    const bool bAppend = CPLFetchBool(papszParmList, \"APPEND_SUBDATASET\", false);\n\n    char szOpeningFlag[5] = {};\n    strcpy(szOpeningFlag, bAppend ? \"r+\" : \"w+\");\n    if( bCreateBigTIFF )\n        strcat(szOpeningFlag, \"8\");\n    if( eEndianness == ENDIANNESS_BIG )\n        strcat(szOpeningFlag, \"b\");\n    else if( eEndianness == ENDIANNESS_LITTLE )\n        strcat(szOpeningFlag, \"l\");\n\n    VSILFILE* l_fpL = VSIFOpenL( pszFilename, bAppend ? \"r+b\" : \"w+b\" );\n    if( l_fpL == nullptr )\n    {\n        CPLError( CE_Failure, CPLE_OpenFailed,\n                  \"Attempt to create new tiff file `%s' failed: %s\",\n                  pszFilename, VSIStrerror(errno) );\n        return nullptr;\n    }\n    TIFF *l_hTIFF = VSI_TIFFOpen( pszFilename, szOpeningFlag, l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        if( CPLGetLastErrorNo() == 0 )\n            CPLError( CE_Failure, CPLE_OpenFailed,\n                      \"Attempt to create new tiff file `%s' \"\n                      \"failed in XTIFFOpen().\",\n                      pszFilename );\n        CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n        return nullptr;\n    }\n\n    if( bAppend )\n    {\n        // This is a bit of a hack to cause (*tif->tif_cleanup)(tif); to be called.\n        // See https://trac.osgeo.org/gdal/ticket/2055\n        TIFFSetField( l_hTIFF, TIFFTAG_COMPRESSION, COMPRESSION_NONE );\n        TIFFFreeDirectory( l_hTIFF );\n        TIFFCreateDirectory( l_hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      How many bits per sample?  We have a special case if NBITS      */\n/*      specified for GDT_Byte, GDT_UInt16, GDT_UInt32.                 */\n/* -------------------------------------------------------------------- */\n    int l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n    if( CSLFetchNameValue(papszParmList, \"NBITS\") != nullptr )\n    {\n        int nMinBits = 0;\n        int nMaxBits = 0;\n        l_nBitsPerSample = atoi(CSLFetchNameValue(papszParmList, \"NBITS\"));\n        if( eType == GDT_Byte )\n        {\n            nMinBits = 1;\n            nMaxBits = 8;\n        }\n        else if( eType == GDT_UInt16 )\n        {\n            nMinBits = 9;\n            nMaxBits = 16;\n        }\n        else if( eType == GDT_UInt32 )\n        {\n            nMinBits = 17;\n            nMaxBits = 32;\n        }\n        else if( eType == GDT_Float32 )\n        {\n            if( l_nBitsPerSample != 16 && l_nBitsPerSample != 32 )\n            {\n                ReportError( pszFilename, CE_Warning, CPLE_NotSupported,\n                     \"Only NBITS=16 is supported for data type Float32\");\n                l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n            }\n        }\n        else\n        {\n            ReportError( pszFilename, CE_Warning, CPLE_NotSupported,\n                     \"NBITS is not supported for data type %s\",\n                     GDALGetDataTypeName(eType));\n            l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n        }\n\n        if( nMinBits != 0 )\n        {\n            if( l_nBitsPerSample < nMinBits )\n            {\n                ReportError( pszFilename,CE_Warning, CPLE_AppDefined,\n                         \"NBITS=%d is invalid for data type %s. Using NBITS=%d\",\n                         l_nBitsPerSample, GDALGetDataTypeName(eType),\n                         nMinBits);\n                l_nBitsPerSample = nMinBits;\n            }\n            else if( l_nBitsPerSample > nMaxBits )\n            {\n                ReportError( pszFilename,CE_Warning, CPLE_AppDefined,\n                         \"NBITS=%d is invalid for data type %s. Using NBITS=%d\",\n                         l_nBitsPerSample, GDALGetDataTypeName(eType),\n                         nMaxBits);\n                l_nBitsPerSample = nMaxBits;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a custom pixel type (just used for signed byte now). */\n/* -------------------------------------------------------------------- */\n    const char *pszPixelType = CSLFetchNameValue( papszParmList, \"PIXELTYPE\" );\n    if( pszPixelType == nullptr )\n        pszPixelType = \"\";\n\n/* -------------------------------------------------------------------- */\n/*      Setup some standard flags.                                      */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( l_hTIFF, TIFFTAG_IMAGEWIDTH, nXSize );\n    TIFFSetField( l_hTIFF, TIFFTAG_IMAGELENGTH, nYSize );\n    TIFFSetField( l_hTIFF, TIFFTAG_BITSPERSAMPLE, l_nBitsPerSample );\n\n    uint16 l_nSampleFormat = 0;\n    if( (eType == GDT_Byte && EQUAL(pszPixelType,\"SIGNEDBYTE\"))\n        || eType == GDT_Int16 || eType == GDT_Int32 )\n        l_nSampleFormat = SAMPLEFORMAT_INT;\n    else if( eType == GDT_CInt16 || eType == GDT_CInt32 )\n        l_nSampleFormat = SAMPLEFORMAT_COMPLEXINT;\n    else if( eType == GDT_Float32 || eType == GDT_Float64 )\n        l_nSampleFormat = SAMPLEFORMAT_IEEEFP;\n    else if( eType == GDT_CFloat32 || eType == GDT_CFloat64 )\n        l_nSampleFormat = SAMPLEFORMAT_COMPLEXIEEEFP;\n    else\n        l_nSampleFormat = SAMPLEFORMAT_UINT;\n\n    TIFFSetField( l_hTIFF, TIFFTAG_SAMPLEFORMAT, l_nSampleFormat );\n    TIFFSetField( l_hTIFF, TIFFTAG_SAMPLESPERPIXEL, l_nBands );\n    TIFFSetField( l_hTIFF, TIFFTAG_PLANARCONFIG, nPlanar );\n\n/* -------------------------------------------------------------------- */\n/*      Setup Photometric Interpretation. Take this value from the user */\n/*      passed option or guess correct value otherwise.                 */\n/* -------------------------------------------------------------------- */\n    int nSamplesAccountedFor = 1;\n    bool bForceColorTable = false;\n\n    pszValue = CSLFetchNameValue(papszParmList,\"PHOTOMETRIC\");\n    if( pszValue != nullptr )\n    {\n        if( EQUAL( pszValue, \"MINISBLACK\" ) )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                          PHOTOMETRIC_MINISBLACK );\n        else if( EQUAL( pszValue, \"MINISWHITE\" ) )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                          PHOTOMETRIC_MINISWHITE );\n        }\n        else if( EQUAL( pszValue, \"PALETTE\" ))\n        {\n            if( eType == GDT_Byte || eType == GDT_UInt16 )\n            {\n                TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                              PHOTOMETRIC_PALETTE );\n                nSamplesAccountedFor = 1;\n                bForceColorTable = true;\n            }\n            else\n            {\n                ReportError( pszFilename,CE_Warning, CPLE_AppDefined,\n                    \"PHOTOMETRIC=PALETTE only compatible with Byte or UInt16\" );\n            }\n        }\n        else if( EQUAL( pszValue, \"RGB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"CMYK\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED );\n            nSamplesAccountedFor = 4;\n        }\n        else if( EQUAL( pszValue, \"YCBCR\" ))\n        {\n            // Because of subsampling, setting YCBCR without JPEG compression\n            // leads to a crash currently. Would need to make\n            // GTiffRasterBand::IWriteBlock() aware of subsampling so that it\n            // doesn't overrun buffer size returned by libtiff.\n            if( l_nCompression != COMPRESSION_JPEG )\n            {\n                ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                         \"Currently, PHOTOMETRIC=YCBCR requires COMPRESS=JPEG\");\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            if( nPlanar == PLANARCONFIG_SEPARATE )\n            {\n                ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                         \"PHOTOMETRIC=YCBCR requires INTERLEAVE=PIXEL\");\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            // YCBCR strictly requires 3 bands. Not less, not more Issue an\n            // explicit error message as libtiff one is a bit cryptic:\n            // TIFFVStripSize64:Invalid td_samplesperpixel value.\n            if( l_nBands != 3 )\n            {\n                ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                    \"PHOTOMETRIC=YCBCR not supported on a %d-band raster: \"\n                    \"only compatible of a 3-band (RGB) raster\", l_nBands );\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR );\n            nSamplesAccountedFor = 3;\n\n            // Explicitly register the subsampling so that JPEGFixupTags\n            // is a no-op (helps for cloud optimized geotiffs)\n            TIFFSetField( l_hTIFF, TIFFTAG_YCBCRSUBSAMPLING, 2, 2 );\n        }\n        else if( EQUAL( pszValue, \"CIELAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CIELAB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"ICCLAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ICCLAB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"ITULAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ITULAB );\n            nSamplesAccountedFor = 3;\n        }\n        else\n        {\n            ReportError( pszFilename,CE_Warning, CPLE_IllegalArg,\n                      \"PHOTOMETRIC=%s value not recognised, ignoring.  \"\n                      \"Set the Photometric Interpretation as MINISBLACK.\",\n                      pszValue );\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        }\n\n        if( l_nBands < nSamplesAccountedFor )\n        {\n            ReportError( pszFilename,CE_Warning, CPLE_IllegalArg,\n                      \"PHOTOMETRIC=%s value does not correspond to number \"\n                      \"of bands (%d), ignoring.  \"\n                      \"Set the Photometric Interpretation as MINISBLACK.\",\n                      pszValue, l_nBands );\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        }\n    }\n    else\n    {\n        // If image contains 3 or 4 bands and datatype is Byte then we will\n        // assume it is RGB. In all other cases assume it is MINISBLACK.\n        if( l_nBands == 3 && eType == GDT_Byte )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( l_nBands == 4 && eType == GDT_Byte )\n        {\n            uint16 v[1] = {\n                GTiffGetAlphaValue(CSLFetchNameValue(papszParmList, \"ALPHA\"),\n                                   DEFAULT_ALPHA_TYPE)\n            };\n\n            TIFFSetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 4;\n        }\n        else\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n            nSamplesAccountedFor = 1;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If there are extra samples, we need to mark them with an        */\n/*      appropriate extrasamples definition here.                       */\n/* -------------------------------------------------------------------- */\n    if( l_nBands > nSamplesAccountedFor )\n    {\n        const int nExtraSamples = l_nBands - nSamplesAccountedFor;\n\n        uint16 *v = static_cast<uint16 *>(\n            CPLMalloc( sizeof(uint16) * nExtraSamples ) );\n\n        v[0] = GTiffGetAlphaValue( CSLFetchNameValue(papszParmList, \"ALPHA\"),\n                                   EXTRASAMPLE_UNSPECIFIED );\n\n        for( int i = 1; i < nExtraSamples; ++i )\n            v[i] = EXTRASAMPLE_UNSPECIFIED;\n\n        TIFFSetField(l_hTIFF, TIFFTAG_EXTRASAMPLES, nExtraSamples, v );\n\n        CPLFree(v);\n    }\n\n    // Set the ICC color profile.\n    if( eProfile != GTiffProfile::BASELINE )\n    {\n        SaveICCProfile(nullptr, l_hTIFF, papszParmList, l_nBitsPerSample);\n    }\n\n    // Set the compression method before asking the default strip size\n    // This is useful when translating to a JPEG-In-TIFF file where\n    // the default strip size is 8 or 16 depending on the photometric value.\n    TIFFSetField( l_hTIFF, TIFFTAG_COMPRESSION, l_nCompression );\n\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        const char* pszCompress =\n            CSLFetchNameValueDef( papszParmList, \"COMPRESS\", \"\" );\n        if( EQUAL(pszCompress , \"LERC_DEFLATE\" ) )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION,\n                        LERC_ADD_COMPRESSION_DEFLATE );\n        }\n        else if( EQUAL(pszCompress, \"LERC_ZSTD\" ) )\n        {\n            if( TIFFSetField( l_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION,\n                            LERC_ADD_COMPRESSION_ZSTD ) != 1 )\n            {\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n        }\n    }\n    // TODO later: take into account LERC version\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Setup tiling/stripping flags.                                   */\n/* -------------------------------------------------------------------- */\n    if( bTiled )\n    {\n        if( !TIFFSetField( l_hTIFF, TIFFTAG_TILEWIDTH, l_nBlockXSize ) ||\n            !TIFFSetField( l_hTIFF, TIFFTAG_TILELENGTH, l_nBlockYSize ) )\n        {\n            XTIFFClose(l_hTIFF);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n            return nullptr;\n        }\n    }\n    else\n    {\n        const uint32 l_nRowsPerStrip = std::min(nYSize,\n            l_nBlockYSize == 0\n            ? static_cast<int>(TIFFDefaultStripSize(l_hTIFF,0))\n            : l_nBlockYSize );\n\n        TIFFSetField( l_hTIFF, TIFFTAG_ROWSPERSTRIP, l_nRowsPerStrip );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Set compression related tags.                                   */\n/* -------------------------------------------------------------------- */\n    if( l_nCompression == COMPRESSION_LZW ||\n         l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n         l_nCompression == COMPRESSION_ZSTD )\n        TIFFSetField( l_hTIFF, TIFFTAG_PREDICTOR, nPredictor );\n    if( l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        l_nCompression == COMPRESSION_LERC )\n    {\n        GTiffSetDeflateSubCodec(l_hTIFF);\n\n        if( l_nZLevel != -1 )\n            TIFFSetField( l_hTIFF, TIFFTAG_ZIPQUALITY, l_nZLevel );\n    }\n    if( l_nCompression == COMPRESSION_JPEG && l_nJpegQuality != -1 )\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGQUALITY, l_nJpegQuality );\n    if( l_nCompression == COMPRESSION_LZMA && l_nLZMAPreset != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_LZMAPRESET, l_nLZMAPreset );\n    if( (l_nCompression == COMPRESSION_ZSTD ||\n         l_nCompression == COMPRESSION_LERC) && l_nZSTDLevel != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_ZSTD_LEVEL, l_nZSTDLevel);\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        TIFFSetField( l_hTIFF, TIFFTAG_LERC_MAXZERROR, l_dfMaxZError );\n    }\n#endif\n    if( l_nCompression == COMPRESSION_WEBP && l_nWebPLevel != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LEVEL, l_nWebPLevel);\n    if( l_nCompression == COMPRESSION_WEBP && l_bWebPLossless)\n        TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LOSSLESS, 1);\n\n    if( l_nCompression == COMPRESSION_JPEG )\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGTABLESMODE, l_nJpegTablesMode );\n\n/* -------------------------------------------------------------------- */\n/*      If we forced production of a file with photometric=palette,     */\n/*      we need to push out a default color table.                      */\n/* -------------------------------------------------------------------- */\n    if( bForceColorTable )\n    {\n        const int nColors = eType == GDT_Byte ? 256 : 65536;\n\n        unsigned short *panTRed = static_cast<unsigned short *>(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n        unsigned short *panTGreen = static_cast<unsigned short *>(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n        unsigned short *panTBlue = static_cast<unsigned short *>(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n\n        for( int iColor = 0; iColor < nColors; ++iColor )\n        {\n            if( eType == GDT_Byte )\n            {\n                panTRed[iColor] = static_cast<unsigned short>(257 * iColor);\n                panTGreen[iColor] = static_cast<unsigned short>(257 * iColor);\n                panTBlue[iColor] = static_cast<unsigned short>(257 * iColor);\n            }\n            else\n            {\n                panTRed[iColor] = static_cast<unsigned short>(iColor);\n                panTGreen[iColor] = static_cast<unsigned short>(iColor);\n                panTBlue[iColor] = static_cast<unsigned short>(iColor);\n            }\n        }\n\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP,\n                      panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n\n    // This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n    if( l_nCompression == COMPRESSION_JPEG &&\n        !STARTS_WITH(pszFilename, szJPEGGTiffDatasetTmpPrefix) &&\n        CPLTestBool(\n            CSLFetchNameValueDef(papszParmList, \"WRITE_JPEGTABLE_TAG\", \"YES\")) )\n    {\n        GTiffWriteJPEGTables( l_hTIFF,\n                              CSLFetchNameValue(papszParmList, \"PHOTOMETRIC\"),\n                              CSLFetchNameValue(papszParmList, \"JPEG_QUALITY\"),\n                              CSLFetchNameValue(papszParmList,\n                                                \"JPEGTABLESMODE\") );\n    }\n\n    *pfpL = l_fpL;\n\n    return l_hTIFF;\n}\n\n/************************************************************************/\n/*                      GTiffWriteJPEGTables()                          */\n/*                                                                      */\n/*      Sets the TIFFTAG_JPEGTABLES (and TIFFTAG_REFERENCEBLACKWHITE)   */\n/*      tags immediately, instead of relying on the TIFF JPEG codec     */\n/*      to write them when it starts compressing imagery. This avoids   */\n/*      an IFD rewrite at the end of the file.                          */\n/*      Must be used after having set TIFFTAG_SAMPLESPERPIXEL,          */\n/*      TIFFTAG_BITSPERSAMPLE.                                          */\n/************************************************************************/\n\nvoid GTiffWriteJPEGTables( TIFF* hTIFF,\n                           const char* pszPhotometric,\n                           const char* pszJPEGQuality,\n                           const char* pszJPEGTablesMode )\n{\n    // This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n    uint16 nBands = 0;\n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL,\n                        &nBands ) )\n        nBands = 1;\n\n    uint16 l_nBitsPerSample = 0;\n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE,\n                        &(l_nBitsPerSample)) )\n        l_nBitsPerSample = 1;\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf(\"%s%p\", szJPEGGTiffDatasetTmpPrefix, hTIFF);\n    VSILFILE* fpTmp = nullptr;\n    CPLString osTmp;\n    char** papszLocalParameters = nullptr;\n    const int nInMemImageWidth = 16;\n    const int nInMemImageHeight = 16;\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\" );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEG_QUALITY\",\n                                            pszJPEGQuality );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"PHOTOMETRIC\", pszPhotometric );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"BLOCKYSIZE\",\n                                            CPLSPrintf(\"%u\", nInMemImageHeight)\n                                          );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"NBITS\",\n                                            CPLSPrintf(\"%u\", l_nBitsPerSample));\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEGTABLESMODE\",\n                                            pszJPEGTablesMode );\n\n    TIFF* hTIFFTmp = GTiffDataset::CreateLL(\n                    osTmpFilenameIn, nInMemImageWidth, nInMemImageHeight,\n                    (nBands <= 4) ? nBands : 1,\n                    (l_nBitsPerSample <= 8) ? GDT_Byte : GDT_UInt16, 0.0,\n                    papszLocalParameters, &fpTmp, osTmp );\n    CSLDestroy(papszLocalParameters);\n    if( hTIFFTmp )\n    {\n        uint16 l_nPhotometric = 0;\n        int nJpegTablesModeIn = 0;\n        TIFFGetField( hTIFFTmp, TIFFTAG_PHOTOMETRIC, &(l_nPhotometric) );\n        TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                        &nJpegTablesModeIn );\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now, reset quality and jpegcolormode.\n        const int l_nJpegQuality = pszJPEGQuality ? atoi(pszJPEGQuality) : 0;\n        if(l_nJpegQuality > 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGQUALITY, l_nJpegQuality);\n        if( l_nPhotometric == PHOTOMETRIC_YCBCR\n            && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGCOLORMODE,\n                            JPEGCOLORMODE_RGB);\n        }\n        if( nJpegTablesModeIn >= 0 )\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                            nJpegTablesModeIn);\n\n        GPtrDiff_t nBlockSize = static_cast<GPtrDiff_t>(nInMemImageWidth) * nInMemImageHeight *\n                                        ((nBands <= 4) ? nBands : 1);\n        if( l_nBitsPerSample == 12 )\n            nBlockSize = (nBlockSize * 3) / 2;\n        std::vector<GByte> abyZeroData( nBlockSize, 0 );\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, &abyZeroData[0], nBlockSize);\n\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSize,\n                            &pJPEGTable) )\n            TIFFSetField( hTIFF, TIFFTAG_JPEGTABLES, nJPEGTableSize,\n                            pJPEGTable);\n\n        float *ref = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_REFERENCEBLACKWHITE, &ref) )\n            TIFFSetField(hTIFF, TIFFTAG_REFERENCEBLACKWHITE, ref);\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n    VSIUnlink(osTmpFilenameIn);\n}\n\n/************************************************************************/\n/*                            GuessJPEGQuality()                        */\n/*                                                                      */\n/*      Guess JPEG quality from JPEGTABLES tag.                         */\n/************************************************************************/\n\nstatic const GByte* GTIFFFindNextTable( const GByte* paby, GByte byMarker,\n                                        int nLen, int* pnLenTable )\n{\n    for( int i = 0; i + 1 < nLen; )\n    {\n        if( paby[i] != 0xFF )\n            return nullptr;\n        ++i;\n        if( paby[i] == 0xD8 )\n        {\n            ++i;\n            continue;\n        }\n        if( i + 2 >= nLen )\n            return nullptr;\n        int nMarkerLen = paby[i+1] * 256 + paby[i+2];\n        if( i+1+nMarkerLen >= nLen )\n            return nullptr;\n        if( paby[i] == byMarker )\n        {\n            if( pnLenTable ) *pnLenTable = nMarkerLen;\n            return paby + i + 1;\n        }\n        i += 1 + nMarkerLen;\n    }\n    return nullptr;\n}\n\n// We assume that if there are several quantization tables, they are\n// in the same order. Which is a reasonable assumption for updating\n// a file generated by ourselves.\nstatic bool GTIFFQuantizationTablesEqual( const GByte* paby1, int nLen1,\n                                          const GByte* paby2, int nLen2 )\n{\n    bool bFound = false;\n    while( true )\n    {\n        int nLenTable1 = 0;\n        int nLenTable2 = 0;\n        const GByte* paby1New =\n            GTIFFFindNextTable(paby1, 0xDB, nLen1, &nLenTable1);\n        const GByte* paby2New =\n            GTIFFFindNextTable(paby2, 0xDB, nLen2, &nLenTable2);\n        if( paby1New == nullptr && paby2New == nullptr )\n            return bFound;\n        if( paby1New == nullptr || paby2New == nullptr )\n            return false;\n        if( nLenTable1 != nLenTable2 )\n            return false;\n        if( memcmp(paby1New, paby2New, nLenTable1) != 0 )\n            return false;\n        paby1New += nLenTable1;\n        paby2New += nLenTable2;\n        nLen1 -= static_cast<int>(paby1New - paby1);\n        nLen2 -= static_cast<int>(paby2New - paby2);\n        paby1 = paby1New;\n        paby2 = paby2New;\n        bFound = true;\n    }\n}\n\nint GTiffDataset::GuessJPEGQuality( bool& bOutHasQuantizationTable,\n                                    bool& bOutHasHuffmanTable )\n{\n    CPLAssert( m_nCompression == COMPRESSION_JPEG );\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    if( !TIFFGetField(m_hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize, &pJPEGTable) )\n    {\n        bOutHasQuantizationTable = false;\n        bOutHasHuffmanTable = false;\n        return -1;\n    }\n\n    bOutHasQuantizationTable =\n        GTIFFFindNextTable( static_cast<const GByte*>(pJPEGTable), 0xDB,\n                            nJPEGTableSize, nullptr) != nullptr;\n    bOutHasHuffmanTable =\n        GTIFFFindNextTable( static_cast<const GByte*>(pJPEGTable), 0xC4,\n                            nJPEGTableSize, nullptr) != nullptr;\n    if( !bOutHasQuantizationTable )\n        return -1;\n\n    char** papszLocalParameters = nullptr;\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\");\n    if( m_nPhotometric == PHOTOMETRIC_YCBCR )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"YCBCR\");\n    else if( m_nPhotometric == PHOTOMETRIC_SEPARATED )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"CMYK\");\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"BLOCKYSIZE\", \"16\");\n    if( m_nBitsPerSample == 12 )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                \"NBITS\", \"12\");\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf( \"/vsimem/gtiffdataset_guess_jpeg_quality_tmp_%p\",\n                            this );\n\n    int nRet = -1;\n    for( int nQuality = 0; nQuality <= 100 && nRet < 0; ++nQuality )\n    {\n        VSILFILE* fpTmp = nullptr;\n        if( nQuality == 0 )\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                   \"JPEG_QUALITY\", \"75\");\n        else\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                \"JPEG_QUALITY\", CPLSPrintf(\"%d\", nQuality));\n\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        CPLString osTmp;\n        TIFF* hTIFFTmp =\n            CreateLL( osTmpFilenameIn, 16, 16, (nBands <= 4) ? nBands : 1,\n                      GetRasterBand(1)->GetRasterDataType(), 0.0,\n                      papszLocalParameters, &fpTmp, osTmp );\n        CPLPopErrorHandler();\n        if( !hTIFFTmp )\n        {\n            break;\n        }\n\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now reset jpegcolormode.\n        if( m_nPhotometric == PHOTOMETRIC_YCBCR\n            && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n\n        GByte abyZeroData[(16*16*4*3)/2] = {};\n        const int nBlockSize =\n            (16 * 16 * ((nBands <= 4) ? nBands : 1) * m_nBitsPerSample) / 8;\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, abyZeroData, nBlockSize);\n\n        uint32 nJPEGTableSizeTry = 0;\n        void* pJPEGTableTry = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES,\n                         &nJPEGTableSizeTry, &pJPEGTableTry) )\n        {\n            if( GTIFFQuantizationTablesEqual(\n                   static_cast<GByte *>(pJPEGTable), nJPEGTableSize,\n                   static_cast<GByte *>(pJPEGTableTry), nJPEGTableSizeTry) )\n            {\n                nRet = (nQuality == 0 ) ? 75 : nQuality;\n            }\n        }\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n\n    CSLDestroy(papszLocalParameters);\n    VSIUnlink(osTmpFilenameIn);\n\n    return nRet;\n}\n\n/************************************************************************/\n/*               SetJPEGQualityAndTablesModeFromFile()                  */\n/************************************************************************/\n\nvoid GTiffDataset::SetJPEGQualityAndTablesModeFromFile()\n{\n    bool bHasQuantizationTable = false;\n    bool bHasHuffmanTable = false;\n    int nQuality = GuessJPEGQuality( bHasQuantizationTable,\n                                     bHasHuffmanTable );\n    if( nQuality > 0 )\n    {\n        CPLDebug(\"GTiff\", \"Guessed JPEG quality to be %d\", nQuality);\n        m_nJpegQuality = static_cast<signed char>(nQuality);\n        TIFFSetField( m_hTIFF, TIFFTAG_JPEGQUALITY, nQuality );\n\n        // This means we will use the quantization tables from the\n        // JpegTables tag.\n        m_nJpegTablesMode = JPEGTABLESMODE_QUANT;\n    }\n    else\n    {\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( !TIFFGetField( m_hTIFF, TIFFTAG_JPEGTABLES,\n                            &nJPEGTableSize, &pJPEGTable) )\n        {\n            toff_t *panByteCounts = nullptr;\n            const int nBlockCount =\n                m_nPlanarConfig == PLANARCONFIG_SEPARATE\n                ? m_nBlocksPerBand * nBands\n                : m_nBlocksPerBand;\n            if( TIFFIsTiled( m_hTIFF ) )\n                TIFFGetField( m_hTIFF, TIFFTAG_TILEBYTECOUNTS,\n                                &panByteCounts );\n            else\n                TIFFGetField( m_hTIFF, TIFFTAG_STRIPBYTECOUNTS,\n                                &panByteCounts );\n\n            bool bFoundNonEmptyBlock = false;\n            if( panByteCounts != nullptr )\n            {\n                for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n                {\n                    if( panByteCounts[iBlock] != 0 )\n                    {\n                        bFoundNonEmptyBlock = true;\n                        break;\n                    }\n                }\n            }\n            if( bFoundNonEmptyBlock )\n            {\n                CPLDebug(\"GTiff\", \"Could not guess JPEG quality. \"\n                            \"JPEG tables are missing, so going in \"\n                            \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n                // Write quantization tables in each strile.\n                m_nJpegTablesMode = 0;\n            }\n        }\n        else\n        {\n            if( bHasQuantizationTable )\n            {\n                // FIXME in libtiff: this is likely going to cause issues\n                // since libtiff will reuse in each strile the number of\n                // the global quantization table, which is invalid.\n                CPLDebug(\n                    \"GTiff\", \"Could not guess JPEG quality although JPEG \"\n                    \"quantization tables are present, so going in \"\n                    \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\" );\n            }\n            else\n            {\n                CPLDebug(\"GTiff\", \"Could not guess JPEG quality since JPEG \"\n                        \"quantization tables are not present, so going in \"\n                        \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n            }\n\n            // Write quantization tables in each strile.\n            m_nJpegTablesMode = 0;\n        }\n    }\n    if( bHasHuffmanTable )\n    {\n        // If there are Huffman tables in header use them, otherwise\n        // if we use optimized tables, libtiff will currently reuse\n        // the number of the Huffman tables of the header for the\n        // optimized version of each strile, which is illegal.\n        m_nJpegTablesMode |= JPEGTABLESMODE_HUFF;\n    }\n    if( m_nJpegTablesMode >= 0 )\n        TIFFSetField( m_hTIFF, TIFFTAG_JPEGTABLESMODE,\n                        m_nJpegTablesMode);\n}\n\n/************************************************************************/\n/*                               Create()                               */\n/*                                                                      */\n/*      Create a new GeoTIFF or TIFF file.                              */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::Create( const char * pszFilename,\n                                   int nXSize, int nYSize, int l_nBands,\n                                   GDALDataType eType,\n                                   char **papszParmList )\n\n{\n    VSILFILE* l_fpL = nullptr;\n    CPLString l_osTmpFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Create the underlying TIFF file.                                */\n/* -------------------------------------------------------------------- */\n    TIFF *l_hTIFF = CreateLL(\n        pszFilename,\n        nXSize, nYSize, l_nBands,\n        eType, 0, papszParmList, &l_fpL, l_osTmpFilename );\n    const bool bStreaming = !l_osTmpFilename.empty();\n\n    if( l_hTIFF == nullptr )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Create the new GTiffDataset object.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->m_hTIFF = l_hTIFF;\n    poDS->m_fpL = l_fpL;\n    if( bStreaming )\n    {\n        poDS->m_bStreamingOut = true;\n        poDS->m_pszTmpFilename = CPLStrdup(l_osTmpFilename);\n        poDS->m_fpToWrite = VSIFOpenL( pszFilename, \"wb\" );\n        if( poDS->m_fpToWrite == nullptr )\n        {\n            VSIUnlink(l_osTmpFilename);\n            delete poDS;\n            return nullptr;\n        }\n    }\n    poDS->nRasterXSize = nXSize;\n    poDS->nRasterYSize = nYSize;\n    poDS->eAccess = GA_Update;\n    poDS->m_bCrystalized = false;\n    poDS->m_nSamplesPerPixel = static_cast<uint16>(l_nBands);\n    poDS->m_pszFilename = CPLStrdup(pszFilename);\n\n    // Don't try to load external metadata files (#6597).\n    poDS->m_bIMDRPCMetadataLoaded = true;\n\n    // Avoid premature crystalization that will cause directory re-writing if\n    // GetProjectionRef() or GetGeoTransform() are called on the newly created\n    // GeoTIFF.\n    poDS->m_bLookedForProjection = true;\n\n    TIFFGetField( l_hTIFF, TIFFTAG_SAMPLEFORMAT, &(poDS->m_nSampleFormat) );\n    TIFFGetField( l_hTIFF, TIFFTAG_PLANARCONFIG, &(poDS->m_nPlanarConfig) );\n    // Weird that we need this, but otherwise we get a Valgrind warning on\n    // tiff_write_124.\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, &(poDS->m_nPhotometric) ) )\n        poDS->m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n    TIFFGetField( l_hTIFF, TIFFTAG_BITSPERSAMPLE, &(poDS->m_nBitsPerSample) );\n    TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, &(poDS->m_nCompression) );\n\n    if( TIFFIsTiled(l_hTIFF) )\n    {\n        TIFFGetField( l_hTIFF, TIFFTAG_TILEWIDTH, &(poDS->m_nBlockXSize) );\n        TIFFGetField( l_hTIFF, TIFFTAG_TILELENGTH, &(poDS->m_nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( l_hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(poDS->m_nRowsPerStrip) ) )\n            poDS->m_nRowsPerStrip = 1;  // Dummy value.\n\n        poDS->m_nBlockXSize = nXSize;\n        poDS->m_nBlockYSize =\n            std::min( static_cast<int>(poDS->m_nRowsPerStrip) , nYSize );\n    }\n\n    poDS->m_nBlocksPerBand =\n        DIV_ROUND_UP(nYSize, poDS->m_nBlockYSize)\n        * DIV_ROUND_UP(nXSize, poDS->m_nBlockXSize);\n\n    poDS->m_eProfile = GetProfile(\n        CSLFetchNameValue( papszParmList, \"PROFILE\" ) );\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( poDS->m_nCompression == COMPRESSION_JPEG\n        && poDS->m_nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\") ) )\n    {\n        int nColorMode = 0;\n\n        poDS->SetMetadataItem(\"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\");\n        if( !TIFFGetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n            nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n#ifdef HAVE_LERC\n    if( poDS->m_nCompression == COMPRESSION_LERC )\n    {\n        uint32 nLercParamCount = 0;\n        uint32* panLercParms = nullptr;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_LERC_PARAMETERS, &nLercParamCount,\n                          &panLercParms ) &&\n            nLercParamCount == 2 )\n        {\n            memcpy( poDS->m_anLercAddCompressionAndVersion, panLercParms,\n                    sizeof(poDS->m_anLercAddCompressionAndVersion) );\n        }\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Read palette back as a color table if it has one.               */\n/* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( poDS->m_nPhotometric == PHOTOMETRIC_PALETTE\n        && TIFFGetField( l_hTIFF, TIFFTAG_COLORMAP,\n                         &panRed, &panGreen, &panBlue) )\n    {\n\n        poDS->m_poColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 << poDS->m_nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast<short>(panRed[iColor] / divisor),\n                static_cast<short>(panGreen[iColor] / divisor),\n                static_cast<short>(panBlue[iColor] / divisor),\n                static_cast<short>(255)\n            };\n\n            poDS->m_poColorTable->SetColorEntry( iColor, &oEntry );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we want to ensure all blocks get written out on close to     */\n/*      avoid sparse files?                                             */\n/* -------------------------------------------------------------------- */\n    if( !CPLFetchBool( papszParmList, \"SPARSE_OK\", false ) )\n        poDS->m_bFillEmptyTilesAtClosing = true;\n\n    poDS->m_bWriteEmptyTiles = bStreaming ||\n        (poDS->m_nCompression != COMPRESSION_NONE &&\n         poDS->m_bFillEmptyTilesAtClosing);\n    // Only required for people writing non-compressed striped files in the\n    // right order and wanting all tstrips to be written in the same order\n    // so that the end result can be memory mapped without knowledge of each\n    // strip offset.\n    if( CPLTestBool( CSLFetchNameValueDef( papszParmList,\n                              \"WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) ||\n         CPLTestBool( CSLFetchNameValueDef( papszParmList,\n                              \"@WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) )\n    {\n        poDS->m_bWriteEmptyTiles = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Preserve creation options for consulting later (for instance    */\n/*      to decide if a TFW file should be written).                     */\n/* -------------------------------------------------------------------- */\n    poDS->m_papszCreationOptions = CSLDuplicate( papszParmList );\n\n    poDS->m_nZLevel = GTiffGetZLevel(papszParmList);\n    poDS->m_nLZMAPreset = GTiffGetLZMAPreset(papszParmList);\n    poDS->m_nZSTDLevel = GTiffGetZSTDPreset(papszParmList);\n    poDS->m_nWebPLevel = GTiffGetWebPLevel(papszParmList);\n    poDS->m_bWebPLossless = GTiffGetWebPLossless(papszParmList);\n    poDS->m_nJpegQuality = GTiffGetJpegQuality(papszParmList);\n    poDS->m_nJpegTablesMode = GTiffGetJpegTablesMode(papszParmList);\n#if HAVE_LERC\n    poDS->m_dfMaxZError = GTiffGetLERCMaxZError(papszParmList);\n#endif\n    poDS->InitCreationOrOpenOptions(papszParmList);\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < l_nBands; ++iBand )\n    {\n        if( poDS->m_nBitsPerSample == 8 ||\n            (poDS->m_nBitsPerSample == 16 && eType != GDT_Float32) ||\n            poDS->m_nBitsPerSample == 32 ||\n            poDS->m_nBitsPerSample == 64 ||\n            poDS->m_nBitsPerSample == 128)\n        {\n            poDS->SetBand( iBand + 1, new GTiffRasterBand( poDS, iBand + 1 ) );\n        }\n        else\n        {\n            poDS->SetBand( iBand + 1, new GTiffOddBitsBand( poDS, iBand + 1 ) );\n            poDS->GetRasterBand( iBand + 1 )->\n                SetMetadataItem( \"NBITS\",\n                                 CPLString().Printf(\"%d\",poDS->m_nBitsPerSample),\n                                 \"IMAGE_STRUCTURE\" );\n        }\n    }\n\n    poDS->GetDiscardLsbOption(papszParmList);\n\n    if( poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG && l_nBands != 1 )\n        poDS->SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        poDS->SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    poDS->oOvManager.Initialize( poDS, pszFilename );\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                           CopyImageryAndMask()                       */\n/************************************************************************/\n\nCPLErr GTiffDataset::CopyImageryAndMask(GTiffDataset* poDstDS,\n                                        GDALDataset* poSrcDS,\n                                        GDALRasterBand* poSrcMaskBand,\n                                        GDALProgressFunc pfnProgress,\n                                        void * pProgressData )\n{\n    CPLErr eErr = CE_None;\n\n    const auto eType = poDstDS->GetRasterBand(1)->GetRasterDataType();\n    const int nDataTypeSize = GDALGetDataTypeSizeBytes(eType);\n    const int l_nBands = poDstDS->GetRasterCount();\n    void *pBlockBuffer = VSI_MALLOC3_VERBOSE(\n        poDstDS->m_nBlockXSize, poDstDS->m_nBlockYSize, l_nBands * nDataTypeSize);\n    if( pBlockBuffer == nullptr )\n    {\n        eErr = CE_Failure;\n    }\n    const int nYSize = poDstDS->nRasterYSize;\n    const int nXSize = poDstDS->nRasterXSize;\n    const int nYBlocks = DIV_ROUND_UP(nYSize, poDstDS->m_nBlockYSize);\n    const int nXBlocks = DIV_ROUND_UP(nXSize, poDstDS->m_nBlockXSize);\n    const int nBlocks = nXBlocks * nYBlocks;\n\n    CPLAssert(l_nBands == 1 || poDstDS->m_nPlanarConfig == PLANARCONFIG_CONTIG );\n\n    const bool bIsOddBand =\n        dynamic_cast<GTiffOddBitsBand*>(poDstDS->GetRasterBand(1)) != nullptr;\n\n    if( poDstDS->m_poMaskDS )\n    {\n        CPLAssert( poDstDS->m_poMaskDS->m_nBlockXSize == poDstDS->m_nBlockXSize );\n        CPLAssert( poDstDS->m_poMaskDS->m_nBlockYSize == poDstDS->m_nBlockYSize );\n    }\n\n    int iBlock = 0;\n    for( int iY = 0, nYBlock = 0; iY < nYSize && eErr == CE_None;\n            iY = ((nYSize - iY < poDstDS->m_nBlockYSize) ? nYSize :\n                iY + poDstDS->m_nBlockYSize),\n            nYBlock++ )\n    {\n        const int nReqYSize = std::min(nYSize - iY, poDstDS->m_nBlockYSize);\n        for( int iX = 0, nXBlock = 0; iX < nXSize && eErr == CE_None;\n                iX = ((nXSize - iX < poDstDS->m_nBlockXSize) ? nXSize :\n                    iX + poDstDS->m_nBlockXSize),\n                nXBlock++ )\n        {\n            const int nReqXSize = std::min(nXSize - iX, poDstDS->m_nBlockXSize);\n            if( nReqXSize < poDstDS->m_nBlockXSize ||\n                nReqYSize < poDstDS->m_nBlockYSize )\n            {\n                memset(pBlockBuffer, 0, static_cast<size_t>(\n                    poDstDS->m_nBlockXSize) * poDstDS->m_nBlockYSize *\n                    l_nBands * nDataTypeSize);\n            }\n\n            if( !bIsOddBand )\n            {\n                eErr = poSrcDS->RasterIO( GF_Read,\n                    iX, iY, nReqXSize, nReqYSize,\n                    pBlockBuffer, nReqXSize, nReqYSize,\n                    eType,\n                    l_nBands, nullptr,\n                    nDataTypeSize * l_nBands,\n                    poDstDS->m_nBlockXSize * nDataTypeSize * l_nBands,\n                    nDataTypeSize,\n                    nullptr );\n                if( eErr == CE_None )\n                {\n                    eErr = poDstDS->WriteEncodedTileOrStrip(\n                        iBlock, pBlockBuffer, false);\n                }\n            }\n            else\n            {\n                // In the odd bit case, this is a bit messy to ensure\n                // the strile gets written synchronously.\n                // We load the content of the n-1 bands in the cache,\n                // and for the last band we invoke WriteBlock() directly\n                // We also force FlushBlockBuf()\n                std::vector<GDALRasterBlock*> apoLockedBlocks;\n                for( int i = 0; eErr == CE_None && i < l_nBands - 1; i++ )\n                {\n                    auto poBlock = poDstDS->GetRasterBand(i+1)->GetLockedBlockRef(\n                        nXBlock, nYBlock, TRUE);\n                    if( poBlock )\n                    {\n                        eErr = poSrcDS->GetRasterBand(i+1)->RasterIO(\n                            GF_Read,\n                            iX, iY, nReqXSize, nReqYSize,\n                            poBlock->GetDataRef(), nReqXSize, nReqYSize,\n                            eType,\n                            nDataTypeSize,\n                            nDataTypeSize * poDstDS->m_nBlockXSize, nullptr);\n                        poBlock->MarkDirty();\n                        apoLockedBlocks.emplace_back(poBlock);\n                    }\n                    else\n                    {\n                        eErr = CE_Failure;\n                    }\n                }\n                if( eErr == CE_None )\n                {\n                    eErr = poSrcDS->GetRasterBand(l_nBands)->RasterIO(\n                            GF_Read,\n                            iX, iY, nReqXSize, nReqYSize,\n                            pBlockBuffer, nReqXSize, nReqYSize,\n                            eType,\n                            nDataTypeSize,\n                            nDataTypeSize * poDstDS->m_nBlockXSize, nullptr);\n                }\n                if( eErr == CE_None )\n                {\n                    // Avoid any attempt to load from disk\n                    poDstDS->m_nLoadedBlock = iBlock;\n                    eErr = poDstDS->GetRasterBand(l_nBands)->WriteBlock(\n                        nXBlock, nYBlock, pBlockBuffer);\n                    if( eErr == CE_None )\n                        eErr = poDstDS->FlushBlockBuf();\n                }\n                for( auto poBlock: apoLockedBlocks )\n                {\n                    poBlock->MarkClean();\n                    poBlock->DropLock();\n                }\n            }\n\n            if( eErr == CE_None && poDstDS->m_poMaskDS )\n            {\n                if( nReqXSize < poDstDS->m_nBlockXSize ||\n                    nReqYSize < poDstDS->m_nBlockYSize )\n                {\n                    memset(pBlockBuffer, 0,\n                            static_cast<size_t>(poDstDS->m_nBlockXSize) *\n                            poDstDS->m_nBlockYSize);\n                }\n                eErr = poSrcMaskBand->RasterIO(\n                    GF_Read,\n                    iX, iY, nReqXSize, nReqYSize,\n                    pBlockBuffer, nReqXSize, nReqYSize,\n                    GDT_Byte,\n                    1, poDstDS->m_nBlockXSize, nullptr);\n                if( eErr == CE_None )\n                {\n                    // Avoid any attempt to load from disk\n                    poDstDS->m_poMaskDS->m_nLoadedBlock = iBlock;\n                    eErr = poDstDS->m_poMaskDS->GetRasterBand(1)->\n                        WriteBlock(nXBlock, nYBlock, pBlockBuffer);\n                    if( eErr == CE_None )\n                        eErr = poDstDS->m_poMaskDS->FlushBlockBuf();\n                }\n            }\n            if( poDstDS->m_bWriteError )\n                eErr = CE_Failure;\n\n            iBlock ++;\n            if( pfnProgress && !pfnProgress(\n                static_cast<double>(iBlock) / nBlocks, nullptr, pProgressData) )\n            {\n                eErr = CE_Failure;\n            }\n        }\n    }\n    poDstDS->FlushCache(); // mostly to wait for thread completion\n    VSIFree(pBlockBuffer);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                             CreateCopy()                             */\n/************************************************************************/\n\nGDALDataset *\nGTiffDataset::CreateCopy( const char * pszFilename, GDALDataset *poSrcDS,\n                          int bStrict, char ** papszOptions,\n                          GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    if( poSrcDS->GetRasterCount() == 0 )\n    {\n        ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n                  \"Unable to export GeoTIFF files with zero bands.\" );\n        return nullptr;\n    }\n\n    GDALRasterBand * const poPBand = poSrcDS->GetRasterBand(1);\n    const GDALDataType eType = poPBand->GetRasterDataType();\n\n/* -------------------------------------------------------------------- */\n/*      Check, whether all bands in input dataset has the same type.    */\n/* -------------------------------------------------------------------- */\n    const int l_nBands = poSrcDS->GetRasterCount();\n    for( int iBand = 2; iBand <= l_nBands; ++iBand )\n    {\n        if( eType != poSrcDS->GetRasterBand(iBand)->GetRasterDataType() )\n        {\n            if( bStrict )\n            {\n                ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n                    \"Unable to export GeoTIFF file with different datatypes \"\n                    \"per different bands. All bands should have the same \"\n                    \"types in TIFF.\" );\n                return nullptr;\n            }\n            else\n            {\n                ReportError( pszFilename,CE_Warning, CPLE_AppDefined,\n                    \"Unable to export GeoTIFF file with different datatypes \"\n                    \"per different bands. All bands should have the same \"\n                    \"types in TIFF.\" );\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture the profile.                                            */\n/* -------------------------------------------------------------------- */\n    const GTiffProfile eProfile = GetProfile(\n        CSLFetchNameValue(papszOptions, \"PROFILE\"));\n\n    const bool bGeoTIFF = eProfile != GTiffProfile::BASELINE;\n\n/* -------------------------------------------------------------------- */\n/*      Special handling for NBITS.  Copy from band metadata if found.  */\n/* -------------------------------------------------------------------- */\n    char **papszCreateOptions = CSLDuplicate( papszOptions );\n\n    if( poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" ) != nullptr\n        && atoi(poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" )) > 0\n        && CSLFetchNameValue( papszCreateOptions, \"NBITS\") == nullptr )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"NBITS\",\n                             poPBand->GetMetadataItem( \"NBITS\",\n                                                       \"IMAGE_STRUCTURE\" ) );\n    }\n\n    if( CSLFetchNameValue( papszOptions, \"PIXELTYPE\" ) == nullptr\n        && eType == GDT_Byte\n        && poPBand->GetMetadataItem( \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"PIXELTYPE\",\n                             poPBand->GetMetadataItem(\n                                 \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Color profile.  Copy from band metadata if found.              */\n/* -------------------------------------------------------------------- */\n    if( bGeoTIFF )\n    {\n        const char* pszOptionsMD[] = {\n            \"SOURCE_ICC_PROFILE\",\n            \"SOURCE_PRIMARIES_RED\",\n            \"SOURCE_PRIMARIES_GREEN\",\n            \"SOURCE_PRIMARIES_BLUE\",\n            \"SOURCE_WHITEPOINT\",\n            \"TIFFTAG_TRANSFERFUNCTION_RED\",\n            \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n            \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n            \"TIFFTAG_TRANSFERRANGE_BLACK\",\n            \"TIFFTAG_TRANSFERRANGE_WHITE\",\n            nullptr\n        };\n\n        // Copy all the tags.  Options will override tags in the source.\n        int i = 0;\n        while(pszOptionsMD[i] != nullptr)\n        {\n            char const *pszMD =\n                CSLFetchNameValue(papszOptions, pszOptionsMD[i]);\n            if( pszMD == nullptr )\n                pszMD = poSrcDS->GetMetadataItem( pszOptionsMD[i],\n                                                  \"COLOR_PROFILE\" );\n\n            if( (pszMD != nullptr) && !EQUAL(pszMD, \"\") )\n            {\n                papszCreateOptions =\n                    CSLSetNameValue( papszCreateOptions, pszOptionsMD[i],\n                                     pszMD );\n\n                // If an ICC profile exists, other tags are not needed.\n                if( EQUAL(pszOptionsMD[i], \"SOURCE_ICC_PROFILE\") )\n                    break;\n            }\n\n            ++i;\n        }\n    }\n\n    double dfExtraSpaceForOverviews = 0;\n    const bool bCopySrcOverviews = CPLFetchBool(papszCreateOptions, \"COPY_SRC_OVERVIEWS\", false);\n    std::unique_ptr<GDALDataset> poOvrDS;\n    int nSrcOverviews = 0;\n    if( bCopySrcOverviews )\n    {\n        const char* pszOvrDS = CSLFetchNameValue(papszCreateOptions, \"@OVERVIEW_DATASET\");\n        if( pszOvrDS )\n        {\n            // Empty string is used by COG driver to indicate that we want\n            // to ignore source overviews.\n            if( !EQUAL(pszOvrDS, \"\") )\n            {\n                poOvrDS.reset(GDALDataset::Open(pszOvrDS));\n                if( !poOvrDS )\n                {\n                    CSLDestroy(papszCreateOptions);\n                    return nullptr;\n                }\n                if( poOvrDS->GetRasterCount() != l_nBands )\n                {\n                    CSLDestroy(papszCreateOptions);\n                    return nullptr;\n                }\n                nSrcOverviews = poOvrDS->GetRasterBand(1)->GetOverviewCount() + 1;\n            }\n        }\n        else\n        {\n            nSrcOverviews = poSrcDS->GetRasterBand(1)->GetOverviewCount();\n        }\n        if( nSrcOverviews )\n        {\n            for( int j = 1; j <= l_nBands; ++j )\n            {\n                const int nOtherBandOverviewCount = poOvrDS ?\n                    poOvrDS->GetRasterBand(j)->GetOverviewCount() + 1:\n                    poSrcDS->GetRasterBand(j)->GetOverviewCount();\n                if( nOtherBandOverviewCount != nSrcOverviews )\n                {\n                    ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                        \"COPY_SRC_OVERVIEWS cannot be used when the bands have \"\n                        \"not the same number of overview levels.\" );\n                    CSLDestroy(papszCreateOptions);\n                    return nullptr;\n                }\n                for( int i = 0; i < nSrcOverviews; ++i )\n                {\n                    GDALRasterBand* poOvrBand = poOvrDS ?\n                        (i == 0 ? poOvrDS->GetRasterBand(j) :\n                                  poOvrDS->GetRasterBand(j)->GetOverview(i-1)) :\n                        poSrcDS->GetRasterBand(j)->GetOverview(i);\n                    if( poOvrBand == nullptr )\n                    {\n                        ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                            \"COPY_SRC_OVERVIEWS cannot be used when one \"\n                            \"overview band is NULL.\" );\n                        CSLDestroy(papszCreateOptions);\n                        return nullptr;\n                    }\n                    GDALRasterBand* poOvrFirstBand = poOvrDS ?\n                        (i == 0 ? poOvrDS->GetRasterBand(1) :\n                                  poOvrDS->GetRasterBand(1)->GetOverview(i-1)) :\n                        poSrcDS->GetRasterBand(1)->GetOverview(i);\n                    if( poOvrBand->GetXSize() != poOvrFirstBand->GetXSize() ||\n                        poOvrBand->GetYSize() != poOvrFirstBand->GetYSize() )\n                    {\n                        ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                            \"COPY_SRC_OVERVIEWS cannot be used when the \"\n                            \"overview bands have not the same dimensions \"\n                            \"among bands.\" );\n                        CSLDestroy(papszCreateOptions);\n                        return nullptr;\n                    }\n                }\n            }\n\n            for( int i = 0; i < nSrcOverviews; ++i )\n            {\n                GDALRasterBand* poOvrFirstBand = poOvrDS ?\n                        (i == 0 ? poOvrDS->GetRasterBand(1) :\n                                  poOvrDS->GetRasterBand(1)->GetOverview(i-1)) :\n                        poSrcDS->GetRasterBand(1)->GetOverview(i);\n                dfExtraSpaceForOverviews +=\n                    static_cast<double>(\n                      poOvrFirstBand->GetXSize()) *\n                      poOvrFirstBand->GetYSize();\n            }\n            dfExtraSpaceForOverviews *=\n                                l_nBands * GDALGetDataTypeSizeBytes(eType);\n        }\n        else\n        {\n            CPLDebug(\"GTiff\", \"No source overviews to copy\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we use optimized way of copying from an input JPEG       */\n/*      dataset?                                                        */\n/* -------------------------------------------------------------------- */\n\n// TODO(schwehr): Refactor bDirectCopyFromJPEG to be a const.\n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n    bool bDirectCopyFromJPEG = false;\n#endif\n\n    // Note: JPEG_DIRECT_COPY is not defined by default, because it is mainly\n    // useful for debugging purposes.\n#ifdef JPEG_DIRECT_COPY\n    if( CPLFetchBool(papszCreateOptions, \"JPEG_DIRECT_COPY\", false) &&\n        GTIFF_CanDirectCopyFromJPEG(poSrcDS, papszCreateOptions) )\n    {\n        CPLDebug(\"GTiff\", \"Using special direct copy mode from a JPEG dataset\");\n\n        bDirectCopyFromJPEG = true;\n    }\n#endif\n\n#ifdef HAVE_LIBJPEG\n    bool bCopyFromJPEG = false;\n\n    // When CreateCopy'ing() from a JPEG dataset, and asking for COMPRESS=JPEG,\n    // use DCT coefficients (unless other options are incompatible, like\n    // strip/tile dimensions, specifying JPEG_QUALITY option, incompatible\n    // PHOTOMETRIC with the source colorspace, etc.) to avoid the lossy steps\n    // involved by decompression/recompression.\n    if( !bDirectCopyFromJPEG &&\n        GTIFF_CanCopyFromJPEG(poSrcDS, papszCreateOptions) )\n    {\n        CPLDebug( \"GTiff\", \"Using special copy mode from a JPEG dataset\" );\n\n        bCopyFromJPEG = true;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      If the source is RGB, then set the PHOTOMETRIC=RGB value        */\n/* -------------------------------------------------------------------- */\n\n    const bool bForcePhotometric =\n        CSLFetchNameValue(papszOptions, \"PHOTOMETRIC\") != nullptr;\n\n    if( l_nBands >= 3 && !bForcePhotometric &&\n#ifdef HAVE_LIBJPEG\n        !bCopyFromJPEG &&\n#endif\n        poSrcDS->GetRasterBand(1)->GetColorInterpretation() == GCI_RedBand &&\n        poSrcDS->GetRasterBand(2)->GetColorInterpretation() == GCI_GreenBand &&\n        poSrcDS->GetRasterBand(3)->GetColorInterpretation() == GCI_BlueBand )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"PHOTOMETRIC\", \"RGB\" );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create the file.                                                */\n/* -------------------------------------------------------------------- */\n    VSILFILE* l_fpL = nullptr;\n    CPLString l_osTmpFilename;\n\n    const int nXSize = poSrcDS->GetRasterXSize();\n    const int nYSize = poSrcDS->GetRasterYSize();\n    TIFF *l_hTIFF =\n        CreateLL( pszFilename, nXSize, nYSize, l_nBands,\n                  eType, dfExtraSpaceForOverviews, papszCreateOptions, &l_fpL,\n                  l_osTmpFilename );\n    const bool bStreaming = !l_osTmpFilename.empty();\n\n    CSLDestroy( papszCreateOptions );\n    papszCreateOptions = nullptr;\n\n    if( l_hTIFF == nullptr )\n    {\n        if( bStreaming ) VSIUnlink(l_osTmpFilename);\n        return nullptr;\n    }\n\n    uint16 l_nPlanarConfig = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_PLANARCONFIG, &l_nPlanarConfig );\n\n    uint16 l_nCompression = 0;\n\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, &(l_nCompression) ) )\n        l_nCompression = COMPRESSION_NONE;\n\n/* -------------------------------------------------------------------- */\n/*      Set the alpha channel if it is the last one.                    */\n/* -------------------------------------------------------------------- */\n    if( poSrcDS->GetRasterBand(l_nBands)->GetColorInterpretation() ==\n        GCI_AlphaBand )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            const int nBaseSamples = l_nBands - count;\n            if( l_nBands > nBaseSamples && l_nBands - nBaseSamples - 1 < count )\n            {\n                // We need to allocate a new array as (current) libtiff\n                // versions will not like that we reuse the array we got from\n                // TIFFGetField().\n\n                uint16* pasNewExtraSamples =\n                    static_cast<uint16 *>(\n                        CPLMalloc( count * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v, count * sizeof(uint16) );\n                pasNewExtraSamples[l_nBands - nBaseSamples - 1] =\n                    GTiffGetAlphaValue(\n                        CPLGetConfigOption(\n                            \"GTIFF_ALPHA\",\n                            CSLFetchNameValue(papszOptions,\"ALPHA\") ),\n                        DEFAULT_ALPHA_TYPE);\n\n                TIFFSetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, count,\n                              pasNewExtraSamples);\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the output is jpeg compressed, and the input is RGB make     */\n/*      sure we note that.                                              */\n/* -------------------------------------------------------------------- */\n\n    if( l_nCompression == COMPRESSION_JPEG )\n    {\n        if( l_nBands >= 3\n            && (poSrcDS->GetRasterBand(1)->GetColorInterpretation()\n                == GCI_YCbCr_YBand)\n            && (poSrcDS->GetRasterBand(2)->GetColorInterpretation()\n                == GCI_YCbCr_CbBand)\n            && (poSrcDS->GetRasterBand(3)->GetColorInterpretation()\n                == GCI_YCbCr_CrBand) )\n        {\n            // Do nothing.\n        }\n        else\n        {\n            // Assume RGB if it is not explicitly YCbCr.\n            CPLDebug( \"GTiff\", \"Setting JPEGCOLORMODE_RGB\" );\n            TIFFSetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Does the source image consist of one band, with a palette?      */\n/*      If so, copy over.                                               */\n/* -------------------------------------------------------------------- */\n    if( (l_nBands == 1 || l_nBands == 2) &&\n        poSrcDS->GetRasterBand(1)->GetColorTable() != nullptr\n        && eType == GDT_Byte )\n    {\n        unsigned short anTRed[256] = { 0 };\n        unsigned short anTGreen[256] = { 0 };\n        unsigned short anTBlue[256] = { 0 };\n        GDALColorTable *poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n\n        for( int iColor = 0; iColor < 256; ++iColor )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry sRGB = { 0, 0, 0, 0 };\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = static_cast<unsigned short>(257 * sRGB.c1);\n                anTGreen[iColor] = static_cast<unsigned short>(257 * sRGB.c2);\n                anTBlue[iColor] = static_cast<unsigned short>(257 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = 0;\n                anTGreen[iColor] = 0;\n                anTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP, anTRed, anTGreen, anTBlue );\n    }\n    else if( (l_nBands == 1 || l_nBands == 2)\n             && poSrcDS->GetRasterBand(1)->GetColorTable() != nullptr\n             && eType == GDT_UInt16 )\n    {\n        unsigned short *panTRed = static_cast<unsigned short *>(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n        unsigned short *panTGreen = static_cast<unsigned short *>(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n        unsigned short *panTBlue = static_cast<unsigned short *>(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n\n        GDALColorTable *poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n\n        for( int iColor = 0; iColor < 65536; ++iColor )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry sRGB = { 0, 0, 0, 0 };\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                panTRed[iColor] = static_cast<unsigned short>(257 * sRGB.c1);\n                panTGreen[iColor] = static_cast<unsigned short>(257 * sRGB.c2);\n                panTBlue[iColor] = static_cast<unsigned short>(257 * sRGB.c3);\n            }\n            else\n            {\n                panTRed[iColor] = 0;\n                panTGreen[iColor] = 0;\n                panTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP, panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n    else if( poSrcDS->GetRasterBand(1)->GetColorTable() != nullptr )\n        ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n            \"Unable to export color table to GeoTIFF file.  Color tables \"\n            \"can only be written to 1 band or 2 bands Byte or \"\n            \"UInt16 GeoTIFF files.\" );\n\n    if( l_nCompression == COMPRESSION_JPEG )\n    {\n        uint16 l_nPhotometric = 0;\n        TIFFGetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, &l_nPhotometric);\n        // Check done in tif_jpeg.c later, but not with a very clear error message\n        if( l_nPhotometric == PHOTOMETRIC_PALETTE )\n        {\n            ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                     \"JPEG compression not supported with paletted image\");\n            XTIFFClose( l_hTIFF );\n            VSIUnlink(l_osTmpFilename);\n            CPL_IGNORE_RET_VAL( VSIFCloseL(l_fpL) );\n            return nullptr;\n        }\n    }\n\n    if( l_nBands == 2\n        && poSrcDS->GetRasterBand(1)->GetColorTable() != nullptr\n        && (eType == GDT_Byte || eType == GDT_UInt16) )\n    {\n        uint16 v[1] = { EXTRASAMPLE_UNASSALPHA };\n\n        TIFFSetField(l_hTIFF, TIFFTAG_EXTRASAMPLES, 1, v );\n    }\n\n    const int nMaskFlags = poSrcDS->GetRasterBand(1)->GetMaskFlags();\n    bool bCreateMask = false;\n    CPLString osHiddenStructuralMD;\n    if( (l_nBands == 1 || l_nPlanarConfig == PLANARCONFIG_CONTIG) &&\n        bCopySrcOverviews )\n    {\n        osHiddenStructuralMD += \"LAYOUT=IFDS_BEFORE_DATA\\n\";\n        osHiddenStructuralMD += \"BLOCK_ORDER=ROW_MAJOR\\n\";\n        osHiddenStructuralMD += \"BLOCK_LEADER=SIZE_AS_UINT4\\n\";\n        osHiddenStructuralMD += \"BLOCK_TRAILER=LAST_4_BYTES_REPEATED\\n\";\n        osHiddenStructuralMD += \"KNOWN_INCOMPATIBLE_EDITION=NO\\n \"; // Final space intended, so this can be replaced by YES\n    }\n    if( !(nMaskFlags & (GMF_ALL_VALID|GMF_ALPHA|GMF_NODATA) )\n        && (nMaskFlags & GMF_PER_DATASET) && !bStreaming )\n    {\n        bCreateMask = true;\n        if( GTiffDataset::MustCreateInternalMask() &&\n            !osHiddenStructuralMD.empty() )\n        {\n            osHiddenStructuralMD += \"MASK_INTERLEAVED_WITH_IMAGERY=YES\\n\";\n        }\n    }\n    if( !osHiddenStructuralMD.empty() )\n    {\n        const int nHiddenMDSize = static_cast<int>(osHiddenStructuralMD.size());\n        osHiddenStructuralMD = CPLOPrintf(\n            \"GDAL_STRUCTURAL_METADATA_SIZE=%06d bytes\\n\", nHiddenMDSize) + osHiddenStructuralMD;\n        VSI_TIFFWrite(l_hTIFF, osHiddenStructuralMD.c_str(), osHiddenStructuralMD.size());\n    }\n \n\n    // FIXME? libtiff writes extended tags in the order they are specified\n    // and not in increasing order.\n\n/* -------------------------------------------------------------------- */\n/*      Transfer some TIFF specific metadata, if available.             */\n/*      The return value will tell us if we need to try again later with*/\n/*      PAM because the profile doesn't allow to write some metadata    */\n/*      as TIFF tag                                                     */\n/* -------------------------------------------------------------------- */\n    const bool bHasWrittenMDInGeotiffTAG =\n            GTiffDataset::WriteMetadata( poSrcDS, l_hTIFF, false, eProfile,\n                                         pszFilename, papszOptions );\n\n/* -------------------------------------------------------------------- */\n/*      Write NoData value, if exist.                                   */\n/* -------------------------------------------------------------------- */\n    if( eProfile == GTiffProfile::GDALGEOTIFF )\n    {\n        int bSuccess = FALSE;\n        const double dfNoData =\n            poSrcDS->GetRasterBand(1)->GetNoDataValue( &bSuccess );\n        if( bSuccess )\n            GTiffDataset::WriteNoDataValue( l_hTIFF, dfNoData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Are we addressing PixelIsPoint mode?                            */\n/* -------------------------------------------------------------------- */\n    bool bPixelIsPoint = false;\n    bool bPointGeoIgnore = false;\n\n    if( poSrcDS->GetMetadataItem( GDALMD_AREA_OR_POINT )\n        && EQUAL(poSrcDS->GetMetadataItem(GDALMD_AREA_OR_POINT),\n                 GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore =\n            CPLTestBool( CPLGetConfigOption( \"GTIFF_POINT_GEO_IGNORE\",\n                                             \"FALSE\") );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write affine transform if it is meaningful.                     */\n/* -------------------------------------------------------------------- */\n    const OGRSpatialReference* l_poSRS = nullptr;\n    double l_adfGeoTransform[6] = { 0.0 };\n\n    if( poSrcDS->GetGeoTransform( l_adfGeoTransform ) == CE_None )\n    {\n        if( bGeoTIFF )\n        {\n            l_poSRS = poSrcDS->GetSpatialRef();\n\n            if( l_adfGeoTransform[2] == 0.0 && l_adfGeoTransform[4] == 0.0\n                && l_adfGeoTransform[5] < 0.0 )\n            {\n                double dfOffset = 0.0;\n                {\n                    // In the case the SRS has a vertical component and we have\n                    // a single band, encode its scale/offset in the GeoTIFF tags\n                    int bHasScale = FALSE;\n                    double dfScale =\n                        poSrcDS->GetRasterBand(1)->GetScale(&bHasScale);\n                    int bHasOffset = FALSE;\n                    dfOffset =\n                        poSrcDS->GetRasterBand(1)->GetOffset(&bHasOffset);\n                    const bool bApplyScaleOffset =\n                        l_poSRS && l_poSRS->IsVertical() &&\n                        poSrcDS->GetRasterCount() == 1;\n                    if( bApplyScaleOffset && !bHasScale )\n                        dfScale = 1.0;\n                    if( !bApplyScaleOffset || !bHasOffset )\n                        dfOffset = 0.0;\n                    const double adfPixelScale[3] = {\n                        l_adfGeoTransform[1], fabs(l_adfGeoTransform[5]),\n                        bApplyScaleOffset ? dfScale : 0.0 };\n\n                    TIFFSetField( l_hTIFF, TIFFTAG_GEOPIXELSCALE, 3,\n                                  adfPixelScale );\n                }\n\n                double adfTiePoints[6] = {\n                    0.0,\n                    0.0,\n                    0.0,\n                    l_adfGeoTransform[0],\n                    l_adfGeoTransform[3],\n                    dfOffset\n                };\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfTiePoints[3] +=\n                        l_adfGeoTransform[1] * 0.5 + l_adfGeoTransform[2] * 0.5;\n                    adfTiePoints[4] +=\n                        l_adfGeoTransform[4] * 0.5 + l_adfGeoTransform[5] * 0.5;\n                }\n\n                TIFFSetField( l_hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n            }\n            else\n            {\n                double adfMatrix[16] = { 0.0 };\n\n                adfMatrix[0] = l_adfGeoTransform[1];\n                adfMatrix[1] = l_adfGeoTransform[2];\n                adfMatrix[3] = l_adfGeoTransform[0];\n                adfMatrix[4] = l_adfGeoTransform[4];\n                adfMatrix[5] = l_adfGeoTransform[5];\n                adfMatrix[7] = l_adfGeoTransform[3];\n                adfMatrix[15] = 1.0;\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfMatrix[3] +=\n                        l_adfGeoTransform[1] * 0.5 + l_adfGeoTransform[2] * 0.5;\n                    adfMatrix[7] +=\n                        l_adfGeoTransform[4] * 0.5 + l_adfGeoTransform[5] * 0.5;\n                }\n\n                TIFFSetField( l_hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need a TFW file?                                          */\n/* -------------------------------------------------------------------- */\n        if( CPLFetchBool( papszOptions, \"TFW\", false ) )\n            GDALWriteWorldFile( pszFilename, \"tfw\", l_adfGeoTransform );\n        else if( CPLFetchBool( papszOptions, \"WORLDFILE\", false ) )\n            GDALWriteWorldFile( pszFilename, \"wld\", l_adfGeoTransform );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise write tiepoints if they are available.                */\n/* -------------------------------------------------------------------- */\n    else if( poSrcDS->GetGCPCount() > 0 && bGeoTIFF )\n    {\n        const GDAL_GCP *pasGCPs = poSrcDS->GetGCPs();\n        double *padfTiePoints = static_cast<double *>(\n            CPLMalloc(6 * sizeof(double) * poSrcDS->GetGCPCount()) );\n\n        for( int iGCP = 0; iGCP < poSrcDS->GetGCPCount(); ++iGCP )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPs[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPs[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPs[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPs[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPs[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] -= 0.5;\n                padfTiePoints[iGCP*6+1] -= 0.5;\n            }\n        }\n\n        TIFFSetField( l_hTIFF, TIFFTAG_GEOTIEPOINTS,\n                      6*poSrcDS->GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n\n        l_poSRS = poSrcDS->GetGCPSpatialRef();\n\n        if( CPLFetchBool( papszOptions, \"TFW\", false )\n            || CPLFetchBool( papszOptions, \"WORLDFILE\", false ) )\n        {\n            ReportError( pszFilename,CE_Warning, CPLE_AppDefined,\n                \"TFW=ON or WORLDFILE=ON creation options are ignored when \"\n                \"GCPs are available\" );\n        }\n    }\n    else\n    {\n        l_poSRS = poSrcDS->GetSpatialRef();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy xml:XMP data                                               */\n/* -------------------------------------------------------------------- */\n    char **papszXMP = poSrcDS->GetMetadata(\"xml:XMP\");\n    if( papszXMP != nullptr && *papszXMP != nullptr )\n    {\n        int nTagSize = static_cast<int>(strlen(*papszXMP));\n        TIFFSetField( l_hTIFF, TIFFTAG_XMLPACKET, nTagSize, *papszXMP );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write the projection information, if possible.                  */\n/* -------------------------------------------------------------------- */\n    const bool bHasProjection = l_poSRS != nullptr;\n    bool bExportSRSToPAM = false;\n    if( (bHasProjection || bPixelIsPoint) && bGeoTIFF )\n    {\n        GTIF *psGTIF = GTiffDatasetGTIFNew( l_hTIFF );\n\n        if( bHasProjection )\n        {\n            char* pszWKT = nullptr;\n            OGRErr eErr;\n            {\n                CPLErrorStateBackuper oErrorStateBackuper;\n                CPLErrorHandlerPusher oErrorHandler(CPLQuietErrorHandler);\n                eErr = l_poSRS->exportToWkt(&pszWKT);\n            }\n            if( eErr == OGRERR_NONE && strstr(pszWKT, \"custom_proj4\") == nullptr )\n            {\n                GTIFSetFromOGISDefnEx( psGTIF, pszWKT,\n                                    GetGTIFFKeysFlavor(papszOptions),\n                                    GetGeoTIFFVersion(papszOptions) );\n            }\n            else\n            {\n                bExportSRSToPAM = true;\n            }\n            CPLFree(pszWKT);\n        }\n\n        if( bPixelIsPoint )\n        {\n            GTIFKeySet( psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                        RasterPixelIsPoint );\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n\n    bool l_bDontReloadFirstBlock = false;\n\n#ifdef HAVE_LIBJPEG\n    if( bCopyFromJPEG )\n    {\n        GTIFF_CopyFromJPEG_WriteAdditionalTags(l_hTIFF,\n                                               poSrcDS);\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup                                                         */\n/* -------------------------------------------------------------------- */\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    if( bCopySrcOverviews )\n    {\n        TIFFDeferStrileArrayWriting( l_hTIFF );\n    }\n#endif\n    TIFFWriteCheck( l_hTIFF, TIFFIsTiled(l_hTIFF), \"GTiffCreateCopy()\" );\n    TIFFWriteDirectory( l_hTIFF );\n    if( bStreaming )\n    {\n        // We need to write twice the directory to be sure that custom\n        // TIFF tags are correctly sorted and that padding bytes have been\n        // added.\n        TIFFSetDirectory( l_hTIFF, 0 );\n        TIFFWriteDirectory( l_hTIFF );\n\n        if( VSIFSeekL( l_fpL, 0, SEEK_END ) != 0 )\n            ReportError(pszFilename, CE_Failure, CPLE_FileIO, \"Cannot seek\");\n        const int nSize = static_cast<int>( VSIFTellL(l_fpL) );\n\n        vsi_l_offset nDataLength = 0;\n        VSIGetMemFileBuffer( l_osTmpFilename, &nDataLength, FALSE);\n        TIFFSetDirectory( l_hTIFF, 0 );\n        GTiffFillStreamableOffsetAndCount( l_hTIFF, nSize );\n        TIFFWriteDirectory( l_hTIFF );\n    }\n    TIFFSetDirectory( l_hTIFF,\n                    static_cast<tdir_t>(TIFFNumberOfDirectories(l_hTIFF) - 1) );\n    const toff_t l_nDirOffset = TIFFCurrentDirOffset( l_hTIFF );\n    TIFFFlush( l_hTIFF );\n    XTIFFClose( l_hTIFF );\n\n    VSIFSeekL(l_fpL, 0, SEEK_SET);\n\n    // fpStreaming will assigned to the instance and not closed here.\n    VSILFILE *fpStreaming = nullptr;\n    if( bStreaming )\n    {\n        vsi_l_offset nDataLength = 0;\n        void* pabyBuffer =\n            VSIGetMemFileBuffer( l_osTmpFilename, &nDataLength, FALSE);\n        fpStreaming = VSIFOpenL( pszFilename, \"wb\" );\n        if( fpStreaming == nullptr )\n        {\n            VSIUnlink(l_osTmpFilename);\n            CPL_IGNORE_RET_VAL( VSIFCloseL(l_fpL) );\n            return nullptr;\n        }\n        if( static_cast<vsi_l_offset>(\n                VSIFWriteL( pabyBuffer, 1, static_cast<int>(nDataLength),\n                            fpStreaming ) ) != nDataLength )\n        {\n            ReportError(pszFilename, CE_Failure, CPLE_FileIO,\n                        \"Could not write %d bytes\",\n                        static_cast<int>(nDataLength) );\n            CPL_IGNORE_RET_VAL(VSIFCloseL( fpStreaming ));\n            VSIUnlink(l_osTmpFilename);\n            CPL_IGNORE_RET_VAL( VSIFCloseL(l_fpL) );\n            return nullptr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Re-open as a dataset and copy over missing metadata using       */\n/*      PAM facilities.                                                 */\n/* -------------------------------------------------------------------- */\n    l_hTIFF =\n        VSI_TIFFOpen( bStreaming ? l_osTmpFilename.c_str() : pszFilename,\n                      \"r+\",\n                      l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        if( bStreaming ) VSIUnlink(l_osTmpFilename);\n        CPL_IGNORE_RET_VAL( VSIFCloseL(l_fpL) );\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription( pszFilename );\n    poDS->eAccess = GA_Update;\n    poDS->m_pszFilename = CPLStrdup(pszFilename);\n    poDS->m_fpL = l_fpL;\n    poDS->m_bIMDRPCMetadataLoaded = true;\n\n    const bool bAppend = CPLFetchBool(papszOptions, \"APPEND_SUBDATASET\", false);\n    if( poDS->OpenOffset( l_hTIFF,\n                          bAppend ? l_nDirOffset : TIFFCurrentDirOffset(l_hTIFF),\n                          GA_Update,\n                          false, // bAllowRGBAInterface\n                          true // bReadGeoTransform\n                         ) != CE_None )\n    {\n        delete poDS;\n        if( bStreaming ) VSIUnlink(l_osTmpFilename);\n        return nullptr;\n    }\n    poDS->oOvManager.Initialize( poDS, pszFilename );\n\n    if( bStreaming )\n    {\n        VSIUnlink(l_osTmpFilename);\n        poDS->m_fpToWrite = fpStreaming;\n    }\n    poDS->m_eProfile = eProfile;\n\n    int nCloneInfoFlags = GCIF_PAM_DEFAULT & ~GCIF_MASK;\n\n    // If we explicitly asked not to tag the alpha band as such, do not\n    // reintroduce this alpha color interpretation in PAM.\n    if( poSrcDS->GetRasterBand(l_nBands)->GetColorInterpretation() ==\n        GCI_AlphaBand &&\n        GTiffGetAlphaValue(\n            CPLGetConfigOption(\n                \"GTIFF_ALPHA\",\n                CSLFetchNameValue(papszOptions,\"ALPHA\") ),\n            DEFAULT_ALPHA_TYPE) == EXTRASAMPLE_UNSPECIFIED )\n    {\n        nCloneInfoFlags &= ~GCIF_COLORINTERP;\n    }\n    // Ignore source band color interpretation if requesting PHOTOMETRIC=RGB\n    else if( l_nBands >= 3 &&\n        EQUAL(CSLFetchNameValueDef(papszOptions, \"PHOTOMETRIC\", \"\"), \"RGB\") )\n    {\n        for( int i = 1; i <= 3; i++)\n        {\n            poDS->GetRasterBand(i)->SetColorInterpretation(\n                static_cast<GDALColorInterp>(GCI_RedBand + (i-1)));\n        }\n        nCloneInfoFlags &= ~GCIF_COLORINTERP;\n        if( !(l_nBands == 4 && CSLFetchNameValue(papszOptions, \"ALPHA\") != nullptr) )\n        {\n            for( int i = 4; i <= l_nBands; i++)\n            {\n                poDS->GetRasterBand(i)->SetColorInterpretation(\n                    poSrcDS->GetRasterBand(i)->GetColorInterpretation());\n            }\n        }\n    }\n\n    CPLString osOldGTIFF_REPORT_COMPD_CSVal(\n        CPLGetConfigOption(\"GTIFF_REPORT_COMPD_CS\", \"\"));\n    CPLSetThreadLocalConfigOption(\"GTIFF_REPORT_COMPD_CS\", \"YES\");\n    poDS->CloneInfo( poSrcDS, nCloneInfoFlags );\n    CPLSetThreadLocalConfigOption(\"GTIFF_REPORT_COMPD_CS\",\n        osOldGTIFF_REPORT_COMPD_CSVal.empty() ? nullptr :\n        osOldGTIFF_REPORT_COMPD_CSVal.c_str());\n\n    if( (!bGeoTIFF || bExportSRSToPAM) && (poDS->GetPamFlags() & GPF_DISABLED) == 0 )\n    {\n        // Copy georeferencing info to PAM if the profile is not GeoTIFF\n        poDS->GDALPamDataset::SetSpatialRef(poDS->GetSpatialRef());\n        double adfGeoTransform[6];\n        if( poDS->GetGeoTransform(adfGeoTransform) == CE_None )\n        {\n            poDS->GDALPamDataset::SetGeoTransform(adfGeoTransform);\n        }\n        poDS->GDALPamDataset::SetGCPs(poDS->GetGCPCount(),\n                                      poDS->GetGCPs(),\n                                      poDS->GetGCPSpatialRef());\n    }\n\n    poDS->m_papszCreationOptions = CSLDuplicate( papszOptions );\n    poDS->m_bDontReloadFirstBlock = l_bDontReloadFirstBlock;\n\n/* -------------------------------------------------------------------- */\n/*      CloneInfo() does not merge metadata, it just replaces it        */\n/*      totally.  So we have to merge it.                               */\n/* -------------------------------------------------------------------- */\n\n    char **papszSRC_MD = poSrcDS->GetMetadata();\n    char **papszDST_MD = CSLDuplicate(poDS->GetMetadata());\n\n    papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n    poDS->SetMetadata( papszDST_MD );\n    CSLDestroy( papszDST_MD );\n\n    // Depending on the PHOTOMETRIC tag, the TIFF file may not have the same\n    // band count as the source. Will fail later in GDALDatasetCopyWholeRaster\n    // anyway.\n    for( int nBand = 1;\n         nBand <= std::min(poDS->GetRasterCount(), poSrcDS->GetRasterCount()) ;\n         ++nBand )\n    {\n        GDALRasterBand* poSrcBand = poSrcDS->GetRasterBand(nBand);\n        GDALRasterBand* poDstBand = poDS->GetRasterBand(nBand);\n        papszSRC_MD = poSrcBand->GetMetadata();\n        papszDST_MD = CSLDuplicate(poDstBand->GetMetadata());\n\n        papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n        poDstBand->SetMetadata( papszDST_MD );\n        CSLDestroy( papszDST_MD );\n\n        char** papszCatNames = poSrcBand->GetCategoryNames();\n        if( nullptr != papszCatNames )\n            poDstBand->SetCategoryNames( papszCatNames );\n    }\n\n    l_hTIFF = static_cast<TIFF *>( poDS->GetInternalHandle(nullptr) );\n\n/* -------------------------------------------------------------------- */\n/*      Handle forcing xml:ESRI data to be written to PAM.              */\n/* -------------------------------------------------------------------- */\n    if( CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n    {\n        char **papszESRIMD = poSrcDS->GetMetadata(\"xml:ESRI\");\n        if( papszESRIMD )\n        {\n            poDS->SetMetadata( papszESRIMD, \"xml:ESRI\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Second chance: now that we have a PAM dataset, it is possible   */\n/*      to write metadata that we could not write as a TIFF tag.        */\n/* -------------------------------------------------------------------- */\n    if( !bHasWrittenMDInGeotiffTAG && !bStreaming )\n    {\n        GTiffDataset::WriteMetadata(\n            poDS, l_hTIFF, true, eProfile,\n            pszFilename, papszOptions,\n            true /* don't write RPC and IMD file again */ );\n    }\n\n    if( !bStreaming )\n        GTiffDataset::WriteRPC(\n            poDS, l_hTIFF, true, eProfile,\n            pszFilename, papszOptions,\n            true /* write only in PAM AND if needed */ );\n\n    // Propagate ISIS3 or VICAR metadata, but only as PAM metadata.\n    for( const char* pszMDD: { \"json:ISIS3\", \"json:VICAR\" } )\n    {\n        char **papszMD = poSrcDS->GetMetadata(pszMDD);\n        if( papszMD )\n        {\n            poDS->SetMetadata( papszMD, pszMDD);\n            poDS->PushMetadataToPam();\n        }\n    }\n\n    poDS->m_bWriteCOGLayout = bCopySrcOverviews;\n\n    // To avoid unnecessary directory rewriting.\n    poDS->m_bMetadataChanged = false;\n    poDS->m_bGeoTIFFInfoChanged = false;\n    poDS->m_bNoDataChanged = false;\n    poDS->m_bForceUnsetGTOrGCPs = false;\n    poDS->m_bForceUnsetProjection = false;\n    poDS->m_bStreamingOut = bStreaming;\n\n    // Don't try to load external metadata files (#6597).\n    poDS->m_bIMDRPCMetadataLoaded = true;\n\n    // We must re-set the compression level at this point, since it has been\n    // lost a few lines above when closing the newly create TIFF file The\n    // TIFFTAG_ZIPQUALITY & TIFFTAG_JPEGQUALITY are not store in the TIFF file.\n    // They are just TIFF session parameters.\n\n    poDS->m_nZLevel = GTiffGetZLevel(papszOptions);\n    poDS->m_nLZMAPreset = GTiffGetLZMAPreset(papszOptions);\n    poDS->m_nZSTDLevel = GTiffGetZSTDPreset(papszOptions);\n    poDS->m_nWebPLevel = GTiffGetWebPLevel(papszOptions);\n    poDS->m_bWebPLossless = GTiffGetWebPLossless(papszOptions);\n    poDS->m_nJpegQuality = GTiffGetJpegQuality(papszOptions);\n    poDS->m_nJpegTablesMode = GTiffGetJpegTablesMode(papszOptions);\n    poDS->GetDiscardLsbOption(papszOptions);\n#if HAVE_LERC\n    poDS->m_dfMaxZError = GTiffGetLERCMaxZError(papszOptions);\n#endif\n    poDS->InitCreationOrOpenOptions(papszOptions);\n\n    if( l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        l_nCompression == COMPRESSION_LERC )\n    {\n        GTiffSetDeflateSubCodec(l_hTIFF);\n\n        if( poDS->m_nZLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_ZIPQUALITY, poDS->m_nZLevel );\n        }\n    }\n    if( l_nCompression == COMPRESSION_JPEG )\n    {\n        if( poDS->m_nJpegQuality != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_JPEGQUALITY, poDS->m_nJpegQuality );\n        }\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGTABLESMODE, poDS->m_nJpegTablesMode );\n    }\n    if( l_nCompression == COMPRESSION_LZMA )\n    {\n        if( poDS->m_nLZMAPreset != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_LZMAPRESET, poDS->m_nLZMAPreset );\n        }\n    }\n    if( l_nCompression == COMPRESSION_ZSTD ||\n        l_nCompression == COMPRESSION_LERC )\n    {\n        if( poDS->m_nZSTDLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_ZSTD_LEVEL, poDS->m_nZSTDLevel );\n        }\n    }\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        TIFFSetField( l_hTIFF, TIFFTAG_LERC_MAXZERROR, poDS->m_dfMaxZError );\n    }\n#endif\n    if( l_nCompression == COMPRESSION_WEBP )\n    {\n        if( poDS->m_nWebPLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LEVEL, poDS->m_nWebPLevel );\n        }\n\n        if( poDS->m_bWebPLossless)\n        {\n          TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LOSSLESS, poDS->m_bWebPLossless );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we want to ensure all blocks get written out on close to     */\n/*      avoid sparse files?                                             */\n/* -------------------------------------------------------------------- */\n    if( !CPLFetchBool( papszOptions, \"SPARSE_OK\", false ) )\n        poDS->m_bFillEmptyTilesAtClosing = true;\n\n    poDS->m_bWriteEmptyTiles =\n        (bCopySrcOverviews && poDS->m_bFillEmptyTilesAtClosing) ||\n        bStreaming ||\n        (poDS->m_nCompression != COMPRESSION_NONE &&\n            poDS->m_bFillEmptyTilesAtClosing);\n    // Only required for people writing non-compressed striped files in the\n    // rightorder and wanting all tstrips to be written in the same order\n    // so that the end result can be memory mapped without knowledge of each\n    // strip offset\n    if( CPLTestBool( CSLFetchNameValueDef(\n                            papszOptions,\n                            \"WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) ||\n        CPLTestBool( CSLFetchNameValueDef(\n                            papszOptions,\n                            \"@WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) )\n    {\n        poDS->m_bWriteEmptyTiles = true;\n    }\n\n    // Precreate (internal) mask, so that the IBuildOverviews() below\n    // has a chance to create also the overviews of the mask.\n    CPLErr eErr = CE_None;\n\n    if( bCreateMask )\n    {\n        eErr = poDS->CreateMaskBand( nMaskFlags );\n        if( poDS->m_poMaskDS )\n        {\n            poDS->m_poMaskDS->m_bFillEmptyTilesAtClosing = poDS->m_bFillEmptyTilesAtClosing;\n            poDS->m_poMaskDS->m_bWriteEmptyTiles = poDS->m_bWriteEmptyTiles;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create and then copy existing overviews if requested            */\n/*  We do it such that all the IFDs are at the beginning of the file,   */\n/*  and that the imagery data for the smallest overview is written      */\n/*  first, that way the file is more usable when embedded in a          */\n/*  compressed stream.                                                  */\n/* -------------------------------------------------------------------- */\n\n    // For scaled progress due to overview copying.\n    const int nBandsWidthMask = l_nBands +  (bCreateMask ? 1 : 0);\n    double dfTotalPixels =\n        static_cast<double>(nXSize) * nYSize * nBandsWidthMask;\n    double dfCurPixels = 0;\n\n    if( eErr == CE_None && bCopySrcOverviews )\n    {\n        std::unique_ptr<GDALDataset> poMaskOvrDS;\n        const char* pszMaskOvrDS = CSLFetchNameValue(papszOptions, \"@MASK_OVERVIEW_DATASET\");\n        if( pszMaskOvrDS )\n        {\n            poMaskOvrDS.reset(GDALDataset::Open(pszMaskOvrDS));\n            if( !poMaskOvrDS )\n            {\n                delete poDS;\n                return nullptr;\n            }\n            if( poMaskOvrDS->GetRasterCount() != 1 )\n            {\n                delete poDS;\n                return nullptr;\n            }\n        }\n        if( nSrcOverviews )\n        {\n            eErr = poDS->CreateOverviewsFromSrcOverviews(poSrcDS, poOvrDS.get());\n\n            if( eErr == CE_None &&\n                (poMaskOvrDS != nullptr ||\n                 (poSrcDS->GetRasterBand(1)->GetOverview(0) &&\n                  poSrcDS->GetRasterBand(1)->GetOverview(0)->GetMaskFlags() == GMF_PER_DATASET)) )\n            {\n                int nOvrBlockXSize = 0;\n                int nOvrBlockYSize = 0;\n                GTIFFGetOverviewBlockSize(\n                    GDALRasterBand::ToHandle(poDS->GetRasterBand(1)),\n                    &nOvrBlockXSize, &nOvrBlockYSize);\n                eErr = poDS->CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n            }\n        }\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n        TIFFForceStrileArrayWriting( poDS->m_hTIFF );\n\n        if( poDS->m_poMaskDS )\n        {\n            TIFFForceStrileArrayWriting( poDS->m_poMaskDS->m_hTIFF );\n        }\n\n        for( int i = 0; i < poDS->m_nOverviewCount; i++)\n        {\n            TIFFForceStrileArrayWriting( poDS->m_papoOverviewDS[i]->m_hTIFF );\n\n            if( poDS->m_papoOverviewDS[i]->m_poMaskDS )\n            {\n                TIFFForceStrileArrayWriting(\n                    poDS->m_papoOverviewDS[i]->m_poMaskDS->m_hTIFF );\n            }\n        }\n#endif\n\n        if( eErr == CE_None && nSrcOverviews )\n        {\n            if( poDS->m_nOverviewCount != nSrcOverviews )\n            {\n                ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n                        \"Did only manage to instantiate %d overview levels, \"\n                        \"whereas source contains %d\",\n                        poDS->m_nOverviewCount, nSrcOverviews);\n                eErr = CE_Failure;\n            }\n\n            for( int i = 0; eErr == CE_None && i < nSrcOverviews; ++i )\n            {\n                GDALRasterBand* poOvrBand = poOvrDS ?\n                    (i == 0 ? poOvrDS->GetRasterBand(1) : poOvrDS->GetRasterBand(1)->GetOverview(i-1)) :\n                    poSrcDS->GetRasterBand(1)->GetOverview(i);\n                const double dfOvrPixels =\n                    static_cast<double>(poOvrBand->GetXSize()) *\n                                poOvrBand->GetYSize();\n                dfTotalPixels += dfOvrPixels * l_nBands;\n                if( poOvrBand->GetMaskFlags() == GMF_PER_DATASET ||\n                    poMaskOvrDS != nullptr )\n                {\n                    dfTotalPixels += dfOvrPixels;\n                }\n                else if( i == 0 &&\n                         poDS->GetRasterBand(1)->GetMaskFlags() == GMF_PER_DATASET )\n                {\n                    ReportError( pszFilename, CE_Warning, CPLE_AppDefined,\n                             \"Source dataset has a mask band on full \"\n                             \"resolution, overviews on the regular bands, \"\n                             \"but lacks overviews on the mask band.\");\n                }\n            }\n\n            char* papszCopyWholeRasterOptions[2] = { nullptr, nullptr };\n            if( l_nCompression != COMPRESSION_NONE )\n                papszCopyWholeRasterOptions[0] =\n                    const_cast<char*>( \"COMPRESSED=YES\" );\n            // Now copy the imagery.\n            // Begin with the smallest overview.\n            for( int iOvrLevel = nSrcOverviews - 1;\n                    eErr == CE_None && iOvrLevel >= 0; --iOvrLevel )\n            {\n                auto poDstDS = poDS->m_papoOverviewDS[iOvrLevel];\n\n                // Create a fake dataset with the source overview level so that\n                // GDALDatasetCopyWholeRaster can cope with it.\n                GDALDataset* poSrcOvrDS = poOvrDS ?\n                    (iOvrLevel == 0 ? poOvrDS.get() :\n                        GDALCreateOverviewDataset(poOvrDS.get(), iOvrLevel - 1, TRUE)) :\n                    GDALCreateOverviewDataset(poSrcDS, iOvrLevel, TRUE);\n                GDALRasterBand* poSrcOvrBand = poOvrDS ?\n                    (iOvrLevel == 0 ? poOvrDS->GetRasterBand(1):\n                        poOvrDS->GetRasterBand(1)->GetOverview(iOvrLevel - 1)) :\n                    poSrcDS->GetRasterBand(1)->GetOverview(iOvrLevel);\n                double dfNextCurPixels =\n                    dfCurPixels +\n                    static_cast<double>(poSrcOvrBand->GetXSize()) *\n                    poSrcOvrBand->GetYSize() * l_nBands;\n\n                poDstDS->m_bBlockOrderRowMajor = true;\n                poDstDS->m_bLeaderSizeAsUInt4 = true;\n                poDstDS->m_bTrailerRepeatedLast4BytesRepeated = true;\n                poDstDS->m_bFillEmptyTilesAtClosing = poDS->m_bFillEmptyTilesAtClosing;\n                poDstDS->m_bWriteEmptyTiles = poDS->m_bWriteEmptyTiles;\n                GDALRasterBand* poSrcMaskBand = nullptr;\n                if( poDstDS->m_poMaskDS )\n                {\n                    poDstDS->m_poMaskDS->m_bBlockOrderRowMajor = true;\n                    poDstDS->m_poMaskDS->m_bLeaderSizeAsUInt4 = true;\n                    poDstDS->m_poMaskDS->m_bTrailerRepeatedLast4BytesRepeated = true;\n                    poDstDS->m_poMaskDS->m_bFillEmptyTilesAtClosing = poDS->m_bFillEmptyTilesAtClosing;\n                    poDstDS->m_poMaskDS->m_bWriteEmptyTiles = poDS->m_bWriteEmptyTiles;\n\n                    poSrcMaskBand = poMaskOvrDS ?\n                        (iOvrLevel == 0 ? poMaskOvrDS->GetRasterBand(1) :\n                            poMaskOvrDS->GetRasterBand(1)->GetOverview(iOvrLevel - 1)) :\n                        poSrcOvrBand->GetMaskBand();\n                }\n\n                if( l_nBands == 1 || poDstDS->m_nPlanarConfig == PLANARCONFIG_CONTIG)\n                {\n                    if( poDstDS->m_poMaskDS )\n                    {\n                        dfNextCurPixels +=\n                            static_cast<double>(poSrcOvrBand->GetXSize()) *\n                                                poSrcOvrBand->GetYSize();\n                    }\n                    void* pScaledData =\n                        GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                                  dfNextCurPixels / dfTotalPixels,\n                                                  pfnProgress, pProgressData );\n\n                    eErr = CopyImageryAndMask(poDstDS, poSrcOvrDS,\n                                      poSrcMaskBand,\n                                      GDALScaledProgress, pScaledData);\n\n\n                    dfCurPixels = dfNextCurPixels;\n                    GDALDestroyScaledProgress(pScaledData);\n                }\n                else\n                {\n                    void* pScaledData =\n                        GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                                dfNextCurPixels / dfTotalPixels,\n                                                pfnProgress, pProgressData );\n\n                    eErr =\n                        GDALDatasetCopyWholeRaster(\n                            GDALDataset::ToHandle(poSrcOvrDS),\n                            GDALDataset::ToHandle(poDstDS),\n                            papszCopyWholeRasterOptions,\n                            GDALScaledProgress, pScaledData );\n\n                    dfCurPixels = dfNextCurPixels;\n                    GDALDestroyScaledProgress(pScaledData);\n\n                    poDstDS->FlushCache();\n\n                    // Copy mask of the overview.\n                    if( eErr == CE_None &&\n                        (poMaskOvrDS ||\n                         poSrcOvrBand->GetMaskFlags() == GMF_PER_DATASET) &&\n                        poDstDS->m_poMaskDS != nullptr )\n                    {\n                        dfNextCurPixels +=\n                            static_cast<double>(poSrcOvrBand->GetXSize()) *\n                                                poSrcOvrBand->GetYSize();\n                        pScaledData =\n                            GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                                dfNextCurPixels / dfTotalPixels,\n                                                pfnProgress, pProgressData );\n                        eErr =\n                            GDALRasterBandCopyWholeRaster(\n                                poSrcMaskBand,\n                                poDstDS->m_poMaskDS->GetRasterBand(1),\n                                papszCopyWholeRasterOptions,\n                                GDALScaledProgress, pScaledData );\n                        dfCurPixels = dfNextCurPixels;\n                        GDALDestroyScaledProgress(pScaledData);\n                        poDstDS->m_poMaskDS->FlushCache();\n                    }\n                }\n\n                if( poSrcOvrDS != poOvrDS.get() )\n                    delete poSrcOvrDS;\n                poSrcOvrDS = nullptr;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy actual imagery.                                            */\n/* -------------------------------------------------------------------- */\n    double dfNextCurPixels =\n        dfCurPixels + static_cast<double>(nXSize) * nYSize * l_nBands;\n    void* pScaledData = GDALCreateScaledProgress(\n        dfCurPixels / dfTotalPixels,\n        dfNextCurPixels / dfTotalPixels,\n        pfnProgress, pProgressData);\n\n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n    bool bTryCopy = true;\n#endif\n\n#ifdef HAVE_LIBJPEG\n    if( bCopyFromJPEG )\n    {\n        eErr = GTIFF_CopyFromJPEG( poDS, poSrcDS,\n                                   pfnProgress, pProgressData,\n                                   bTryCopy );\n\n        // In case of failure in the decompression step, try normal copy.\n        if( bTryCopy )\n            eErr = CE_None;\n    }\n#endif\n\n#ifdef JPEG_DIRECT_COPY\n    if( bDirectCopyFromJPEG )\n    {\n        eErr = GTIFF_DirectCopyFromJPEG(poDS, poSrcDS,\n                                        pfnProgress, pProgressData,\n                                        bTryCopy);\n\n        // In case of failure in the reading step, try normal copy.\n        if( bTryCopy )\n            eErr = CE_None;\n    }\n#endif\n\n    bool bWriteMask = true;\n    if( \n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n        bTryCopy &&\n#endif\n        (poDS->m_bTreatAsSplit || poDS->m_bTreatAsSplitBitmap) )\n    {\n        // For split bands, we use TIFFWriteScanline() interface.\n        CPLAssert(poDS->m_nBitsPerSample == 8 || poDS->m_nBitsPerSample == 1);\n\n        if( poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG && poDS->nBands > 1 )\n        {\n            GByte* pabyScanline =\n                static_cast<GByte *>(\n                    VSI_MALLOC_VERBOSE(TIFFScanlineSize(l_hTIFF)) );\n            if( pabyScanline == nullptr )\n                eErr = CE_Failure;\n            for( int j = 0; j < nYSize && eErr == CE_None; ++j )\n            {\n                eErr =\n                    poSrcDS->RasterIO(\n                        GF_Read, 0, j, nXSize, 1,\n                        pabyScanline, nXSize, 1,\n                        GDT_Byte, l_nBands, nullptr, poDS->nBands, 0, 1,\n                        nullptr );\n                if( eErr == CE_None &&\n                    TIFFWriteScanline( l_hTIFF, pabyScanline, j, 0) == -1 )\n                {\n                    ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n                              \"TIFFWriteScanline() failed.\" );\n                    eErr = CE_Failure;\n                }\n                if( !GDALScaledProgress( (j + 1) * 1.0 / nYSize,\n                                         nullptr, pScaledData ) )\n                    eErr = CE_Failure;\n            }\n            CPLFree( pabyScanline );\n        }\n        else\n        {\n            GByte* pabyScanline = static_cast<GByte *>(\n                VSI_MALLOC_VERBOSE(nXSize) );\n            if( pabyScanline == nullptr )\n                eErr = CE_Failure;\n            else\n                eErr = CE_None;\n            for( int iBand = 1; iBand <= l_nBands && eErr == CE_None; ++iBand )\n            {\n                for( int j = 0; j < nYSize && eErr == CE_None; ++j )\n                {\n                    eErr = poSrcDS->GetRasterBand(iBand)->RasterIO(\n                        GF_Read, 0, j, nXSize, 1,\n                        pabyScanline, nXSize, 1,\n                        GDT_Byte, 0, 0, nullptr );\n                    if( poDS->m_bTreatAsSplitBitmap )\n                    {\n                        for( int i = 0; i < nXSize; ++i )\n                        {\n                            const GByte byVal = pabyScanline[i];\n                            if( (i & 0x7) == 0 )\n                                pabyScanline[i >> 3] = 0;\n                            if( byVal )\n                                pabyScanline[i >> 3] |= 0x80 >> (i & 0x7);\n                        }\n                    }\n                    if( eErr == CE_None &&\n                        TIFFWriteScanline(\n                            l_hTIFF, pabyScanline, j,\n                            static_cast<uint16>(iBand - 1)) == -1 )\n                    {\n                        ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n                                  \"TIFFWriteScanline() failed.\" );\n                        eErr = CE_Failure;\n                    }\n                    if( !GDALScaledProgress(\n                           (j + 1 + (iBand - 1) * nYSize) * 1.0 /\n                           (l_nBands * nYSize),\n                           nullptr, pScaledData ) )\n                        eErr = CE_Failure;\n                }\n            }\n            CPLFree(pabyScanline);\n        }\n\n        // Necessary to be able to read the file without re-opening.\n        TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( l_hTIFF );\n\n        TIFFFlushData( l_hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( l_hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            ++nNewDirOffset;\n\n        TIFFFlush( l_hTIFF );\n\n        if( poDS->m_nDirOffset != TIFFCurrentDirOffset( l_hTIFF ) )\n        {\n            poDS->m_nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\", \"directory moved during flush.\" );\n        }\n    }\n    else if( \n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n        bTryCopy &&\n#endif\n        eErr == CE_None )\n    {\n        const char* papszCopyWholeRasterOptions[3] = { nullptr, nullptr, nullptr };\n        int iNextOption = 0;\n        papszCopyWholeRasterOptions[iNextOption++] =\n                \"SKIP_HOLES=YES\" ;\n        if( l_nCompression != COMPRESSION_NONE )\n        {\n            papszCopyWholeRasterOptions[iNextOption++] =\n                \"COMPRESSED=YES\";\n        }\n        // For streaming with separate, we really want that bands are written\n        // after each other, even if the source is pixel interleaved.\n        else if( bStreaming && poDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            papszCopyWholeRasterOptions[iNextOption++] =\n                \"INTERLEAVE=BAND\";\n        }\n\n        if( bCopySrcOverviews &&\n            (l_nBands == 1 || poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG) )\n        {\n            poDS->m_bBlockOrderRowMajor = true;\n            poDS->m_bLeaderSizeAsUInt4 = true;\n            poDS->m_bTrailerRepeatedLast4BytesRepeated = true;\n            if( poDS->m_poMaskDS )\n            {\n                poDS->m_poMaskDS->m_bBlockOrderRowMajor = true;\n                poDS->m_poMaskDS->m_bLeaderSizeAsUInt4 = true;\n                poDS->m_poMaskDS->m_bTrailerRepeatedLast4BytesRepeated = true;\n            }\n\n            if( poDS->m_poMaskDS )\n            {\n                GDALDestroyScaledProgress(pScaledData);\n                pScaledData = GDALCreateScaledProgress(\n                                dfCurPixels / dfTotalPixels,\n                                1.0,\n                                pfnProgress, pProgressData);\n            }\n\n            eErr = CopyImageryAndMask(poDS, poSrcDS,\n                              poSrcDS->GetRasterBand(1)->GetMaskBand(),\n                              GDALScaledProgress, pScaledData);\n            if( poDS->m_poMaskDS )\n            {\n                bWriteMask = false;\n            }\n        }\n        else\n        {\n            eErr = GDALDatasetCopyWholeRaster(\n                /* (GDALDatasetH) */ poSrcDS,\n                /* (GDALDatasetH) */ poDS,\n                papszCopyWholeRasterOptions,\n                GDALScaledProgress, pScaledData );\n        }\n    }\n\n    GDALDestroyScaledProgress(pScaledData);\n\n    if( eErr == CE_None && !bStreaming && bWriteMask )\n    {\n        pScaledData = GDALCreateScaledProgress(\n            dfNextCurPixels / dfTotalPixels,\n            1.0,\n            pfnProgress, pProgressData);\n        if( poDS->m_poMaskDS )\n        {\n            const char* l_papszOptions[2] = { \"COMPRESSED=YES\", nullptr };\n            eErr = GDALRasterBandCopyWholeRaster(\n                                    poSrcDS->GetRasterBand(1)->GetMaskBand(),\n                                    poDS->GetRasterBand(1)->GetMaskBand(),\n                                    const_cast<char **>(l_papszOptions),\n                                    GDALScaledProgress, pScaledData );\n        }\n        else\n        {\n            eErr = GDALDriver::DefaultCopyMasks( poSrcDS, poDS, bStrict,\n                                                 nullptr,\n                                                 GDALScaledProgress, pScaledData );\n        }\n        GDALDestroyScaledProgress(pScaledData);\n    }\n\n    poDS->m_bWriteCOGLayout = false;\n\n    if( eErr == CE_Failure )\n    {\n        delete poDS;\n        poDS = nullptr;\n\n        if( CPLTestBool(CPLGetConfigOption(\"GTIFF_DELETE_ON_ERROR\", \"YES\")) )\n        {\n            if( !bStreaming )\n            {\n                // Should really delete more carefully.\n                VSIUnlink( pszFilename );\n            }\n        }\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                          GetSpatialRef()                             */\n/************************************************************************/\n\nconst OGRSpatialReference* GTiffDataset::GetSpatialRef() const\n\n{\n    if( m_nGCPCount == 0 )\n    {\n        const_cast<GTiffDataset*>(this)->LoadGeoreferencingAndPamIfNeeded();\n        const_cast<GTiffDataset*>(this)->LookForProjection();\n\n        return m_oSRS.IsEmpty() ? nullptr : &m_oSRS;\n    }\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                           SetSpatialRef()                            */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetSpatialRef( const OGRSpatialReference * poSRS )\n\n{\n    if( m_bStreamingOut && m_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify projection at that point in \"\n            \"a streamed output file\" );\n        return CE_Failure;\n    }\n\n    LoadGeoreferencingAndPamIfNeeded();\n    LookForProjection();\n\n    if( poSRS == nullptr || poSRS->IsEmpty() )\n    {\n        if( !m_oSRS.IsEmpty() )\n        {\n            m_bForceUnsetProjection = true;\n        }\n        m_oSRS.Clear();\n    }\n    else\n    {\n        m_oSRS = *poSRS;\n        m_oSRS.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n    }\n\n    m_bGeoTIFFInfoChanged = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                          GetGeoTransform()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::GetGeoTransform( double * padfTransform )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    memcpy( padfTransform, m_adfGeoTransform, sizeof(double) * 6 );\n\n    if( !m_bGeoTransformValid )\n        return CE_Failure;\n\n    // Same logic as in the .gtx driver, for the benefit of GDALOpenVerticalShiftGrid()\n    // when used with PROJ-data's US geoids.\n    if( CPLFetchBool(papszOpenOptions,\n                                \"SHIFT_ORIGIN_IN_MINUS_180_PLUS_180\", false) )\n    {\n        if( padfTransform[0] < -180.0 - padfTransform[1] )\n            padfTransform[0] += 360.0;\n        else if( padfTransform[0] > 180.0 )\n            padfTransform[0] -= 360.0;\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                          SetGeoTransform()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetGeoTransform( double * padfTransform )\n\n{\n    if( m_bStreamingOut && m_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify geotransform at that point in a \"\n            \"streamed output file\" );\n        return CE_Failure;\n    }\n\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( GetAccess() == GA_Update )\n    {\n        if( m_nGCPCount > 0 )\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                     \"GCPs previously set are going to be cleared \"\n                     \"due to the setting of a geotransform.\");\n            m_bForceUnsetGTOrGCPs = true;\n            GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n            CPLFree( m_pasGCPList );\n            m_nGCPCount = 0;\n            m_pasGCPList = nullptr;\n        }\n        else if( padfTransform[0] == 0.0 &&\n                 padfTransform[1] == 0.0 &&\n                 padfTransform[2] == 0.0 &&\n                 padfTransform[3] == 0.0 &&\n                 padfTransform[4] == 0.0 &&\n                 padfTransform[5] == 0.0 )\n        {\n            if( m_bGeoTransformValid )\n            {\n                m_bForceUnsetGTOrGCPs = true;\n                m_bGeoTIFFInfoChanged = true;\n            }\n            m_bGeoTransformValid = false;\n            memcpy( m_adfGeoTransform, padfTransform, sizeof(double)*6 );\n            return CE_None;\n        }\n\n        memcpy( m_adfGeoTransform, padfTransform, sizeof(double)*6 );\n        m_bGeoTransformValid = true;\n        m_bGeoTIFFInfoChanged = true;\n\n        return CE_None;\n    }\n    else\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Attempt to call SetGeoTransform() on a read-only GeoTIFF file.\" );\n        return CE_Failure;\n    }\n}\n\n/************************************************************************/\n/*                            GetGCPCount()                             */\n/************************************************************************/\n\nint GTiffDataset::GetGCPCount()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    return m_nGCPCount;\n}\n\n/************************************************************************/\n/*                          GetGCPSpatialRef()                          */\n/************************************************************************/\n\nconst OGRSpatialReference *GTiffDataset::GetGCPSpatialRef() const\n\n{\n    const_cast<GTiffDataset*>(this)->LoadGeoreferencingAndPamIfNeeded();\n\n    if( m_nGCPCount > 0 )\n    {\n        const_cast<GTiffDataset*>(this)->LookForProjection();\n    }\n    if( !m_oSRS.IsEmpty() )\n        return &m_oSRS;\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                               GetGCPs()                              */\n/************************************************************************/\n\nconst GDAL_GCP *GTiffDataset::GetGCPs()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    return m_pasGCPList;\n}\n\n/************************************************************************/\n/*                               SetGCPs()                              */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetGCPs( int nGCPCountIn, const GDAL_GCP *pasGCPListIn,\n                              const OGRSpatialReference *poGCPSRS )\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( GetAccess() == GA_Update )\n    {\n        LookForProjection();\n\n        if( m_nGCPCount > 0 && nGCPCountIn == 0 )\n        {\n            m_bForceUnsetGTOrGCPs = true;\n        }\n        else if( nGCPCountIn > 0 &&\n                 m_bGeoTransformValid )\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                     \"A geotransform previously set is going to be cleared \"\n                     \"due to the setting of GCPs.\");\n            m_adfGeoTransform[0] = 0.0;\n            m_adfGeoTransform[1] = 1.0;\n            m_adfGeoTransform[2] = 0.0;\n            m_adfGeoTransform[3] = 0.0;\n            m_adfGeoTransform[4] = 0.0;\n            m_adfGeoTransform[5] = 1.0;\n            m_bGeoTransformValid = false;\n            m_bForceUnsetGTOrGCPs = true;\n        }\n\n        if( poGCPSRS == nullptr || poGCPSRS->IsEmpty() )\n        {\n            if( !m_oSRS.IsEmpty() )\n            {\n                m_bForceUnsetProjection = true;\n            }\n            m_oSRS.Clear();\n        }\n        else\n        {\n            m_oSRS = *poGCPSRS;\n            m_oSRS.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n        }\n\n        if( m_nGCPCount > 0 )\n        {\n            GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n            CPLFree( m_pasGCPList );\n        }\n\n        m_nGCPCount = nGCPCountIn;\n        m_pasGCPList = GDALDuplicateGCPs(m_nGCPCount, pasGCPListIn);\n\n        m_bGeoTIFFInfoChanged = true;\n\n        return CE_None;\n    }\n    else\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"SetGCPs() is only supported on newly created GeoTIFF files.\");\n        return CE_Failure;\n    }\n}\n\n/************************************************************************/\n/*                      GetMetadataDomainList()                         */\n/************************************************************************/\n\nchar **GTiffDataset::GetMetadataDomainList()\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    char **papszDomainList = CSLDuplicate(m_oGTiffMDMD.GetDomainList());\n    char **papszBaseList = GDALDataset::GetMetadataDomainList();\n\n    const int nbBaseDomains = CSLCount(papszBaseList);\n\n    for( int domainId = 0; domainId < nbBaseDomains; ++domainId )\n    {\n        if( CSLFindString(papszDomainList, papszBaseList[domainId]) < 0 )\n        {\n            papszDomainList = CSLAddString(papszDomainList,papszBaseList[domainId]);\n        }\n    }\n\n    CSLDestroy(papszBaseList);\n\n    return BuildMetadataDomainList(\n        papszDomainList,\n        TRUE,\n        \"\", \"ProxyOverviewRequest\", MD_DOMAIN_RPC, MD_DOMAIN_IMD,\n        \"SUBDATASETS\", \"EXIF\",\n        \"xml:XMP\", \"COLOR_PROFILE\", nullptr);\n}\n\n/************************************************************************/\n/*                            GetMetadata()                             */\n/************************************************************************/\n\nchar **GTiffDataset::GetMetadata( const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain, \"ProxyOverviewRequest\") )\n        return GDALPamDataset::GetMetadata( pszDomain );\n\n    if( pszDomain != nullptr && EQUAL(pszDomain, \"DERIVED_SUBDATASETS\"))\n    {\n        return GDALDataset::GetMetadata(pszDomain);\n    }\n\n    else if( pszDomain != nullptr && (EQUAL(pszDomain, MD_DOMAIN_RPC) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMD) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMAGERY)) )\n        LoadMetadata();\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"SUBDATASETS\") )\n        ScanDirectories();\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"EXIF\") )\n        LoadEXIFMetadata();\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"COLOR_PROFILE\") )\n        LoadICCProfile();\n\n    else if( pszDomain == nullptr || EQUAL(pszDomain, \"\") )\n        LoadMDAreaOrPoint();  // To set GDALMD_AREA_OR_POINT.\n\n    return m_oGTiffMDMD.GetMetadata( pszDomain );\n}\n\n/************************************************************************/\n/*                            SetMetadata()                             */\n/************************************************************************/\nCPLErr GTiffDataset::SetMetadata( char ** papszMD, const char *pszDomain )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( m_bStreamingOut && m_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify metadata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain, MD_DOMAIN_RPC) )\n    {\n        // So that a subsequent GetMetadata() wouldn't override our new values\n        LoadMetadata();\n        m_bForceUnsetRPC = (CSLCount(papszMD) == 0);\n    }\n\n    if( (papszMD != nullptr) &&\n        (pszDomain != nullptr) &&\n        EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        m_bColorProfileMetadataChanged = true;\n    }\n    else if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        m_bMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update &&\n            GDALPamDataset::GetMetadata(pszDomain) != nullptr )\n            GDALPamDataset::SetMetadata(nullptr, pszDomain);\n    }\n\n    if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) &&\n        CSLFetchNameValue(papszMD, GDALMD_AREA_OR_POINT) != nullptr )\n    {\n        const char* pszPrevValue =\n                GetMetadataItem(GDALMD_AREA_OR_POINT);\n        const char* pszNewValue =\n                CSLFetchNameValue(papszMD, GDALMD_AREA_OR_POINT);\n        if( pszPrevValue == nullptr || pszNewValue == nullptr ||\n            !EQUAL(pszPrevValue, pszNewValue) )\n        {\n            LookForProjection();\n            m_bGeoTIFFInfoChanged = true;\n        }\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain, \"xml:XMP\") )\n    {\n        if( papszMD != nullptr && *papszMD != nullptr )\n        {\n            int nTagSize = static_cast<int>(strlen(*papszMD));\n            TIFFSetField( m_hTIFF, TIFFTAG_XMLPACKET, nTagSize, *papszMD );\n        }\n        else\n        {\n            TIFFUnsetField( m_hTIFF, TIFFTAG_XMLPACKET );\n        }\n    }\n\n    return m_oGTiffMDMD.SetMetadata( papszMD, pszDomain );\n}\n\n/************************************************************************/\n/*                          GetMetadataItem()                           */\n/************************************************************************/\n\nconst char *GTiffDataset::GetMetadataItem( const char *pszName,\n                                           const char *pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain,\"ProxyOverviewRequest\") )\n    {\n        return GDALPamDataset::GetMetadataItem( pszName, pszDomain );\n    }\n    else if( pszDomain != nullptr && (EQUAL(pszDomain, MD_DOMAIN_RPC) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMD) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMAGERY)) )\n    {\n        LoadMetadata();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"SUBDATASETS\") )\n    {\n        ScanDirectories();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"EXIF\") )\n    {\n        LoadEXIFMetadata();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        LoadICCProfile();\n    }\n    else if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) &&\n        pszName != nullptr && EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LoadMDAreaOrPoint();  // To set GDALMD_AREA_OR_POINT.\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"_DEBUG_\") &&\n             pszName != nullptr )\n    {\n#ifdef DEBUG_REACHED_VIRTUAL_MEM_IO\n        if( EQUAL(pszName, \"UNREACHED_VIRTUALMEMIO_CODE_PATH\") )\n        {\n            CPLString osMissing;\n            for( int i = 0; i < static_cast<int>(\n                                    CPL_ARRAYSIZE(anReachedVirtualMemIO)); ++i )\n            {\n                if( !anReachedVirtualMemIO[i] )\n                {\n                    if( !osMissing.empty() ) osMissing += \",\";\n                    osMissing += CPLSPrintf(\"%d\", i);\n                }\n            }\n            return (osMissing.size()) ? CPLSPrintf(\"%s\", osMissing.c_str()) : nullptr;\n        }\n        else\n#endif\n        if( EQUAL(pszName, \"TIFFTAG_EXTRASAMPLES\") )\n        {\n            CPLString osRet;\n            uint16 *v = nullptr;\n            uint16 count = 0;\n\n            if( TIFFGetField( m_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n            {\n                for( int i = 0; i < static_cast<int>(count); ++i )\n                {\n                    if( i > 0 ) osRet += \",\";\n                    osRet += CPLSPrintf(\"%d\", v[i]);\n                }\n            }\n            return (osRet.size()) ? CPLSPrintf(\"%s\", osRet.c_str()) : nullptr;\n        }\n        else if( EQUAL(pszName, \"TIFFTAG_PHOTOMETRIC\") )\n        {\n            return CPLSPrintf(\"%d\", m_nPhotometric);\n        }\n\n        else if( EQUAL( pszName, \"TIFFTAG_GDAL_METADATA\") )\n        {\n            char* pszText = nullptr;\n            if( !TIFFGetField( m_hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n                return nullptr;\n\n            return CPLSPrintf(\"%s\", pszText);\n        }\n        else if( EQUAL( pszName, \"HAS_USED_READ_ENCODED_API\") )\n        {\n            return m_bHasUsedReadEncodedAPI ? \"1\" : \"0\";\n        }\n        return nullptr;\n    }\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"TIFF\") &&\n             pszName != nullptr )\n    {\n        if( EQUAL(pszName, \"GDAL_STRUCTURAL_METADATA\") )\n        {\n            const auto nOffset = VSIFTellL(m_fpL);\n            VSIFSeekL( m_fpL, 0, SEEK_SET );\n            GByte abyData[1024];\n            size_t nRead = VSIFReadL(abyData, 1, sizeof(abyData)-1, m_fpL);\n            abyData[nRead] = 0;\n            VSIFSeekL( m_fpL, nOffset, SEEK_SET );\n            if( nRead > 4 )\n            {\n                const int nOffsetOfStructuralMetadata =\n                    (abyData[2] == 0x2B || abyData[3] == 0x2B ) ? 16 : 8;\n                const int nSizePatternLen = static_cast<int>(strlen(\"XXXXXX bytes\\n\"));\n                if( nRead > nOffsetOfStructuralMetadata +\n                            strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\") + nSizePatternLen &&\n                    memcmp(abyData + nOffsetOfStructuralMetadata,\n                            \"GDAL_STRUCTURAL_METADATA_SIZE=\",\n                            strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\")) == 0 )\n                {\n                    char* pszStructuralMD = reinterpret_cast<char*>(\n                        abyData + nOffsetOfStructuralMetadata);\n                    const int nLenMD = atoi(pszStructuralMD +\n                                    strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\"));\n                    if( nOffsetOfStructuralMetadata +\n                        strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\") +\n                        nSizePatternLen + nLenMD <= nRead )\n                    {\n                        pszStructuralMD[\n                            strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\") +\n                            nSizePatternLen + nLenMD] = 0;\n                        return CPLSPrintf(\"%s\", pszStructuralMD);\n                    }\n                }\n            }\n            return nullptr;\n        }\n    }\n\n    return m_oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}\n\n/************************************************************************/\n/*                          SetMetadataItem()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetMetadataItem( const char *pszName,\n                                      const char *pszValue,\n                                      const char *pszDomain )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( m_bStreamingOut && m_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify metadata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    if( (pszDomain != nullptr) && EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        m_bColorProfileMetadataChanged = true;\n    }\n    else if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        m_bMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update &&\n            GDALPamDataset::GetMetadataItem(pszName, pszDomain) != nullptr )\n            GDALPamDataset::SetMetadataItem(pszName, nullptr, pszDomain);\n    }\n\n    if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) &&\n        pszName != nullptr && EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LookForProjection();\n        m_bGeoTIFFInfoChanged = true;\n    }\n\n    return m_oGTiffMDMD.SetMetadataItem( pszName, pszValue, pszDomain );\n}\n\n/************************************************************************/\n/*                         GetInternalHandle()                          */\n/************************************************************************/\n\nvoid *GTiffDataset::GetInternalHandle( const char * /* pszHandleName */ )\n\n{\n    return m_hTIFF;\n}\n\n/************************************************************************/\n/*                         LoadEXIFMetadata()                           */\n/************************************************************************/\n\nvoid GTiffDataset::LoadEXIFMetadata()\n{\n    if( m_bEXIFMetadataLoaded )\n        return;\n    m_bEXIFMetadataLoaded = true;\n\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n\n    GByte abyHeader[2] = { 0 };\n    if( VSIFSeekL(fp, 0, SEEK_SET) != 0 ||\n        VSIFReadL(abyHeader, 1, 2, fp) != 2 )\n        return;\n\n    const bool bLittleEndian = abyHeader[0] == 'I' && abyHeader[1] == 'I';\n    const bool bLeastSignificantBit = CPL_IS_LSB != 0;\n    const bool bSwabflag = bLittleEndian != bLeastSignificantBit;  // != is XOR.\n\n    char** papszMetadata = nullptr;\n    toff_t nOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n\n    if( TIFFGetField(m_hTIFF, TIFFTAG_EXIFIFD, &nOffset) )\n    {\n        int nExifOffset = static_cast<int>(nOffset);\n        int nInterOffset = 0;\n        int nGPSOffset = 0;\n        EXIFExtractMetadata( papszMetadata,\n                             fp, static_cast<int>(nOffset),\n                             bSwabflag, 0,\n                             nExifOffset, nInterOffset, nGPSOffset);\n    }\n\n    if( TIFFGetField(m_hTIFF, TIFFTAG_GPSIFD, &nOffset) )\n    {\n        int nExifOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n        int nInterOffset = 0;\n        int nGPSOffset = static_cast<int>(nOffset);\n        EXIFExtractMetadata( papszMetadata,\n                             fp, static_cast<int>(nOffset),\n                             bSwabflag, 0,\n                             nExifOffset, nInterOffset, nGPSOffset );\n    }\n\n    if( papszMetadata )\n    {\n        m_oGTiffMDMD.SetMetadata( papszMetadata, \"EXIF\" );\n        CSLDestroy( papszMetadata );\n    }\n}\n\n/************************************************************************/\n/*                           LoadMetadata()                             */\n/************************************************************************/\nvoid GTiffDataset::LoadMetadata()\n{\n    if( m_bIMDRPCMetadataLoaded )\n        return;\n    m_bIMDRPCMetadataLoaded = true;\n\n    GDALMDReaderManager mdreadermanager;\n    GDALMDReaderBase* mdreader =\n        mdreadermanager.GetReader(m_pszFilename,\n                                  oOvManager.GetSiblingFiles(), MDR_ANY);\n\n    if( nullptr != mdreader )\n    {\n        mdreader->FillMetadata(&m_oGTiffMDMD);\n\n        if(mdreader->GetMetadataDomain(MD_DOMAIN_RPC) == nullptr)\n        {\n            char** papszRPCMD = GTiffDatasetReadRPCTag(m_hTIFF);\n            if( papszRPCMD )\n            {\n                m_oGTiffMDMD.SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n                CSLDestroy( papszRPCMD );\n            }\n        }\n\n        m_papszMetadataFiles = mdreader->GetMetadataFiles();\n    }\n    else\n    {\n        char** papszRPCMD = GTiffDatasetReadRPCTag(m_hTIFF);\n        if( papszRPCMD )\n        {\n            m_oGTiffMDMD.SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n            CSLDestroy( papszRPCMD );\n        }\n    }\n}\n\n/************************************************************************/\n/*                            GetFileList()                             */\n/************************************************************************/\n\nchar **GTiffDataset::GetFileList()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    char **papszFileList = GDALPamDataset::GetFileList();\n\n    LoadMetadata();\n    if(nullptr != m_papszMetadataFiles)\n    {\n        for( int i = 0; m_papszMetadataFiles[i] != nullptr; ++i )\n        {\n            if( CSLFindString( papszFileList, m_papszMetadataFiles[i] ) < 0 )\n            {\n                papszFileList =\n                    CSLAddString( papszFileList, m_papszMetadataFiles[i] );\n            }\n        }\n    }\n\n    if( m_pszGeorefFilename &&\n        CSLFindString(papszFileList, m_pszGeorefFilename) == -1 )\n    {\n        papszFileList = CSLAddString( papszFileList, m_pszGeorefFilename );\n    }\n\n    return papszFileList;\n}\n\n/************************************************************************/\n/*                         CreateMaskBand()                             */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateMaskBand(int nFlagsIn)\n{\n    ScanDirectories();\n\n    if( m_poMaskDS != nullptr )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"This TIFF dataset has already an internal mask band\" );\n        return CE_Failure;\n    }\n    else if( MustCreateInternalMask() )\n    {\n        if( nFlagsIn != GMF_PER_DATASET )\n        {\n            ReportError(\n                CE_Failure, CPLE_AppDefined,\n                \"The only flag value supported for internal mask is \"\n                \"GMF_PER_DATASET\" );\n            return CE_Failure;\n        }\n\n        int l_nCompression = COMPRESSION_PACKBITS;\n        if( strstr(GDALGetMetadataItem(GDALGetDriverByName( \"GTiff\" ),\n                                       GDAL_DMD_CREATIONOPTIONLIST, nullptr ),\n                   \"<Value>DEFLATE</Value>\") != nullptr )\n            l_nCompression = COMPRESSION_ADOBE_DEFLATE;\n\n    /* -------------------------------------------------------------------- */\n    /*      If we don't have read access, then create the mask externally.  */\n    /* -------------------------------------------------------------------- */\n        if( GetAccess() != GA_Update )\n        {\n            ReportError( CE_Warning, CPLE_AppDefined,\n                      \"File open for read-only accessing, \"\n                      \"creating mask externally.\" );\n\n            return GDALPamDataset::CreateMaskBand(nFlagsIn);\n        }\n\n        if( m_bLayoutIFDSBeforeData && !m_bKnownIncompatibleEdition &&\n            !m_bWriteKnownIncompatibleEdition )\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                        \"Adding a mask invalidates the \"\n                        \"LAYOUT=IFDS_BEFORE_DATA property\");\n            m_bKnownIncompatibleEdition = true;\n            m_bWriteKnownIncompatibleEdition = true;\n        }\n\n        bool bIsOverview = false;\n        uint32 nSubType = 0;\n        if( TIFFGetField(m_hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n        {\n            bIsOverview = (nSubType & FILETYPE_REDUCEDIMAGE) != 0;\n\n            if( (nSubType & FILETYPE_MASK) != 0 )\n            {\n                ReportError( CE_Failure, CPLE_AppDefined,\n                          \"Cannot create a mask on a TIFF mask IFD !\" );\n                return CE_Failure;\n            }\n        }\n\n        const int bIsTiled = TIFFIsTiled(m_hTIFF);\n\n        FlushDirectory();\n\n        const toff_t nOffset =\n            GTIFFWriteDirectory(\n                m_hTIFF,\n                bIsOverview ?\n                FILETYPE_REDUCEDIMAGE | FILETYPE_MASK : FILETYPE_MASK,\n                nRasterXSize, nRasterYSize,\n                1, PLANARCONFIG_CONTIG, 1,\n                m_nBlockXSize, m_nBlockYSize,\n                bIsTiled, l_nCompression,\n                PHOTOMETRIC_MASK, PREDICTOR_NONE,\n                SAMPLEFORMAT_UINT, nullptr, nullptr, nullptr, 0, nullptr, \"\", nullptr, nullptr,\n                nullptr, nullptr, m_bWriteCOGLayout, nullptr );\n\n        ReloadDirectory();\n\n        if( nOffset == 0 )\n            return CE_Failure;\n\n        m_poMaskDS = new GTiffDataset();\n        m_poMaskDS->m_poBaseDS = this;\n        m_poMaskDS->m_poImageryDS = this;\n        m_poMaskDS->ShareLockWithParentDataset(this);\n        m_poMaskDS->m_bPromoteTo8Bits =\n            CPLTestBool(\n                CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n        if( m_poMaskDS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nOffset,\n                                  GA_Update ) != CE_None)\n        {\n            delete m_poMaskDS;\n            m_poMaskDS = nullptr;\n            return CE_Failure;\n        }\n\n        return CE_None;\n    }\n\n    return GDALPamDataset::CreateMaskBand(nFlagsIn);\n}\n\n/************************************************************************/\n/*                        MustCreateInternalMask()                      */\n/************************************************************************/\n\nbool GTiffDataset::MustCreateInternalMask()\n{\n    return CPLTestBool(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\"));\n}\n\n/************************************************************************/\n/*                         CreateMaskBand()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::CreateMaskBand( int nFlagsIn )\n{\n    m_poGDS->ScanDirectories();\n\n    if( m_poGDS->m_poMaskDS != nullptr )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"This TIFF dataset has already an internal mask band\" );\n        return CE_Failure;\n    }\n\n    if( CPLTestBool( CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\") ) )\n    {\n        return m_poGDS->CreateMaskBand(nFlagsIn);\n    }\n\n    return GDALPamRasterBand::CreateMaskBand(nFlagsIn);\n}\n\n/************************************************************************/\n/*                        GetRawBinaryLayout()                          */\n/************************************************************************/\n\nbool GTiffDataset::GetRawBinaryLayout(GDALDataset::RawBinaryLayout& sLayout)\n{\n    if( eAccess == GA_Update )\n    {\n        FlushCache();\n        Crystalize();\n    }\n\n    if( m_nCompression != COMPRESSION_NONE )\n        return false;\n    if( !CPLIsPowerOfTwo(m_nBitsPerSample) || m_nBitsPerSample < 8 )\n        return false;\n    const auto eDT = GetRasterBand(1)->GetRasterDataType();\n    if( GDALDataTypeIsComplex( eDT ) )\n        return false;\n\n    toff_t *panByteCounts = nullptr;\n    toff_t *panOffsets = nullptr;\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(m_hTIFF) );\n\n    if( !(( bIsTiled\n            && TIFFGetField( m_hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts )\n            && TIFFGetField( m_hTIFF, TIFFTAG_TILEOFFSETS, &panOffsets ) )\n            || ( !bIsTiled\n            && TIFFGetField( m_hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts )\n            && TIFFGetField( m_hTIFF, TIFFTAG_STRIPOFFSETS, &panOffsets ) )) )\n    {\n        return false;\n    }\n\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDT);\n    vsi_l_offset        nImgOffset = panOffsets[0];\n    GIntBig             nPixelOffset = ( m_nPlanarConfig == PLANARCONFIG_CONTIG ) ? static_cast<GIntBig>(nDTSize) * nBands : nDTSize;\n    GIntBig             nLineOffset = nPixelOffset * nRasterXSize;\n    GIntBig             nBandOffset = ( m_nPlanarConfig == PLANARCONFIG_CONTIG && nBands > 1 ) ? nDTSize : 0;\n    RawBinaryLayout::Interleaving eInterleaving =\n        (nBands == 1) ?                             RawBinaryLayout::Interleaving::UNKNOWN :\n        (m_nPlanarConfig == PLANARCONFIG_CONTIG ) ? RawBinaryLayout::Interleaving::BIP :\n                                                    RawBinaryLayout::Interleaving::BSQ;\n    if( bIsTiled )\n    {\n        // Only a single block tiled file with same dimension as the raster\n        // might be acceptable\n        if( m_nBlockXSize != nRasterXSize || m_nBlockYSize != nRasterYSize )\n            return false;\n        if( nBands > 1 && m_nPlanarConfig != PLANARCONFIG_CONTIG )\n        {\n            nBandOffset = static_cast<GIntBig>(panOffsets[1]) - static_cast<GIntBig>(panOffsets[0]);\n            for( int i = 2; i < nBands; i++ )\n            {\n                if( static_cast<GIntBig>(panOffsets[i]) - static_cast<GIntBig>(panOffsets[i - 1]) != nBandOffset )\n                    return false;\n            }\n        }\n    }\n    else\n    {\n        const int nStrips = DIV_ROUND_UP(nRasterYSize, m_nRowsPerStrip);\n        if( nBands == 1 || m_nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            vsi_l_offset nLastStripEnd = panOffsets[0] + panByteCounts[0];\n            for( int iStrip = 1; iStrip < nStrips; iStrip++ )\n            {\n                if( nLastStripEnd != panOffsets[iStrip] )\n                    return false;\n                nLastStripEnd = panOffsets[iStrip] + panByteCounts[iStrip];\n            }\n        }\n        else\n        {\n            // Note: we could potentially have BIL order with m_nRowsPerStrip == 1\n            // and if strips are ordered strip_line_1_band_1, ..., strip_line_1_band_N, strip_line2_band1, ... strip_line2_band_N, etc....\n            // but that'd be faily exotic !\n            // So only detect BSQ layout here\n            nBandOffset = static_cast<GIntBig>(panOffsets[nStrips]) - static_cast<GIntBig>(panOffsets[0]);\n            for( int i = 0; i < nBands; i++ )\n            {\n                uint32 iStripOffset = nStrips * i;\n                vsi_l_offset nLastStripEnd = panOffsets[iStripOffset] + panByteCounts[iStripOffset];\n                for( int iStrip = 1; iStrip < nStrips; iStrip++ )\n                {\n                    if( nLastStripEnd != panOffsets[iStripOffset + iStrip] )\n                        return false;\n                    nLastStripEnd = panOffsets[iStripOffset + iStrip] + panByteCounts[iStripOffset + iStrip];\n                }\n                if( i >= 2 &&\n                     static_cast<GIntBig>(panOffsets[iStripOffset]) -\n                        static_cast<GIntBig>(panOffsets[iStripOffset - nStrips]) != nBandOffset )\n                {\n                    return false;\n                }\n            }\n        }\n    }\n\n    sLayout.osRawFilename = m_pszFilename;\n    sLayout.eInterleaving = eInterleaving;\n    sLayout.eDataType = eDT;\n#ifdef CPL_LSB\n    sLayout.bLittleEndianOrder = !TIFFIsByteSwapped(m_hTIFF);\n#else\n    sLayout.bLittleEndianOrder = TIFFIsByteSwapped(m_hTIFF);\n#endif\n    sLayout.nImageOffset = nImgOffset;\n    sLayout.nPixelOffset = nPixelOffset;\n    sLayout.nLineOffset = nLineOffset;\n    sLayout.nBandOffset = nBandOffset;\n\n    return true;\n}\n\n/************************************************************************/\n/*                       PrepareTIFFErrorFormat()                       */\n/*                                                                      */\n/*      sometimes the \"module\" has stuff in it that has special         */\n/*      meaning in a printf() style format, so we try to escape it.     */\n/*      For now we hope the only thing we have to escape is %'s.        */\n/************************************************************************/\n\nstatic char *PrepareTIFFErrorFormat( const char *module, const char *fmt )\n\n{\n    const size_t nModuleSize = strlen(module);\n    const size_t nModFmtSize = nModuleSize * 2 + strlen(fmt) + 2;\n    char *pszModFmt = static_cast<char *>( CPLMalloc( nModFmtSize ) );\n\n    size_t iOut = 0;  // Used after for.\n\n    for( size_t iIn = 0; iIn < nModuleSize; ++iIn )\n    {\n        if( module[iIn] == '%' )\n        {\n            CPLAssert(iOut < nModFmtSize - 2);\n            pszModFmt[iOut++] = '%';\n            pszModFmt[iOut++] = '%';\n        }\n        else\n        {\n            CPLAssert(iOut < nModFmtSize - 1);\n            pszModFmt[iOut++] = module[iIn];\n        }\n    }\n    CPLAssert(iOut < nModFmtSize);\n    pszModFmt[iOut] = '\\0';\n    strcat( pszModFmt, \":\" );\n    strcat( pszModFmt, fmt );\n\n    return pszModFmt;\n}\n\n/************************************************************************/\n/*                        GTiffWarningHandler()                         */\n/************************************************************************/\nstatic void\nGTiffWarningHandler(const char* module, const char* fmt, va_list ap )\n{\n    if( strstr(fmt,\"nknown field\") != nullptr )\n        return;\n\n    char *pszModFmt = PrepareTIFFErrorFormat( module, fmt );\n    if( strstr(fmt, \"does not end in null byte\") != nullptr )\n    {\n        CPLString osMsg;\n        osMsg.vPrintf(pszModFmt, ap);\n        CPLDebug( \"GTiff\", \"%s\", osMsg.c_str() );\n    }\n    else\n    {\n        CPLErrorV( CE_Warning, CPLE_AppDefined, pszModFmt, ap );\n    }\n    CPLFree( pszModFmt );\n}\n\n/************************************************************************/\n/*                         GTiffErrorHandler()                          */\n/************************************************************************/\nstatic void\nGTiffErrorHandler( const char* module, const char* fmt, va_list ap )\n{\n    if( strcmp(fmt, \"Maximum TIFF file size exceeded\") == 0 )\n    {\n        // Ideally there would be a thread-safe way of setting this flag,\n        // but we cannot really use the extended error handler, since the\n        // handler is for all TIFF handles, and not necessarily the ones of\n        // this driver.\n        if( bGlobalInExternalOvr )\n            fmt =\n                \"Maximum TIFF file size exceeded. \"\n                \"Use --config BIGTIFF_OVERVIEW YES configuration option.\";\n        else\n            fmt =\n                \"Maximum TIFF file size exceeded. \"\n                \"Use BIGTIFF=YES creation option.\";\n    }\n\n    char* pszModFmt = PrepareTIFFErrorFormat( module, fmt );\n    CPLErrorV( CE_Failure, CPLE_AppDefined, pszModFmt, ap );\n    CPLFree( pszModFmt );\n}\n\n/************************************************************************/\n/*                          GTiffTagExtender()                          */\n/*                                                                      */\n/*      Install tags specially known to GDAL.                           */\n/************************************************************************/\n\nstatic TIFFExtendProc _ParentExtender = nullptr;\n\nstatic void GTiffTagExtender(TIFF *tif)\n\n{\n    const TIFFFieldInfo xtiffFieldInfo[] = {\n        { TIFFTAG_GDAL_METADATA, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast<char *>( \"GDALMetadata\" ) },\n        { TIFFTAG_GDAL_NODATA, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast<char*>( \"GDALNoDataValue\" ) },\n        { TIFFTAG_RPCCOEFFICIENT, -1, -1, TIFF_DOUBLE, FIELD_CUSTOM,\n          TRUE, TRUE, const_cast<char *>( \"RPCCoefficient\" ) },\n        { TIFFTAG_TIFF_RSID, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast<char *>( \"TIFF_RSID\" ) },\n        { TIFFTAG_GEO_METADATA, TIFF_VARIABLE2, TIFF_VARIABLE2, TIFF_BYTE, FIELD_CUSTOM,\n          TRUE, TRUE, const_cast<char *>( \"GEO_METADATA\" ) }\n    };\n\n    if( _ParentExtender )\n        (*_ParentExtender)(tif);\n\n    TIFFMergeFieldInfo( tif, xtiffFieldInfo,\n                        sizeof(xtiffFieldInfo) / sizeof(xtiffFieldInfo[0]) );\n}\n\n/************************************************************************/\n/*                          GTiffOneTimeInit()                          */\n/*                                                                      */\n/*      This is stuff that is initialized for the TIFF library just     */\n/*      once.  We deliberately defer the initialization till the        */\n/*      first time we are likely to call into libtiff to avoid          */\n/*      unnecessary paging in of the library for GDAL apps that         */\n/*      don't use it.                                                   */\n/************************************************************************/\n#if defined(HAVE_DLFCN_H) && !defined(WIN32)\n#include <dlfcn.h>\n#endif\n\nstatic std::mutex oDeleteMutex;\n#ifdef HAVE_LERC\nstatic TIFFCodec* pLercCodec = nullptr;\n#endif\n\nint GTiffOneTimeInit()\n\n{\n    std::lock_guard<std::mutex> oLock(oDeleteMutex);\n \n#ifdef HAVE_LERC\n    if( pLercCodec == nullptr )\n    {\n        pLercCodec = TIFFRegisterCODEC(COMPRESSION_LERC, \"LERC\", TIFFInitLERC);\n    }\n#endif\n\n    static bool bOneTimeInitDone = false;\n    if( bOneTimeInitDone )\n        return TRUE;\n\n    bOneTimeInitDone = true;\n\n    // This is a frequent configuration error that is difficult to track down\n    // for people unaware of the issue : GDAL built against internal libtiff\n    // (4.X), but used by an application that links with external libtiff (3.X)\n    // Note: on my conf, the order that cause GDAL to crash - and that is\n    // detected by the following code - is \"-ltiff -lgdal\". \"-lgdal -ltiff\"\n    // works for the GTiff driver but probably breaks the application that\n    // believes it uses libtiff 3.X but we cannot detect that.\n#if !defined(RENAME_INTERNAL_LIBTIFF_SYMBOLS)\n#if defined(HAVE_DLFCN_H) && !defined(WIN32)\n    const char* (*pfnVersion)(void);\n#ifdef HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n#endif\n    pfnVersion = reinterpret_cast<const char* (*)(void)>(dlsym(RTLD_DEFAULT, \"TIFFGetVersion\"));\n#ifdef HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT\n#pragma GCC diagnostic pop\n#endif\n    if( pfnVersion )\n    {\n        const char* pszVersion = pfnVersion();\n        if( pszVersion && strstr(pszVersion, \"Version 3.\") != nullptr )\n        {\n            CPLError(\n                CE_Warning, CPLE_AppDefined,\n                \"libtiff version mismatch: You're linking against libtiff 3.X, \"\n                \"but GDAL has been compiled against libtiff >= 4.0.0\" );\n        }\n    }\n#endif  // HAVE_DLFCN_H\n#endif // !defined(RENAME_INTERNAL_LIBTIFF_SYMBOLS)\n\n    _ParentExtender = TIFFSetTagExtender(GTiffTagExtender);\n\n    TIFFSetWarningHandler( GTiffWarningHandler );\n    TIFFSetErrorHandler( GTiffErrorHandler );\n\n    LibgeotiffOneTimeInit();\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*                        GDALDeregister_GTiff()                        */\n/************************************************************************/\n\nstatic\nvoid GDALDeregister_GTiff( GDALDriver * )\n\n{\n#ifdef HAVE_LERC\n    if( pLercCodec )\n        TIFFUnRegisterCODEC(pLercCodec);\n    pLercCodec = nullptr;\n#endif\n}\n\n/************************************************************************/\n/*                   GTIFFGetCompressionMethod()                        */\n/************************************************************************/\n\nint GTIFFGetCompressionMethod(const char* pszValue, const char* pszVariableName)\n{\n    int nCompression = COMPRESSION_NONE;\n    if( EQUAL( pszValue, \"NONE\" ) )\n        nCompression = COMPRESSION_NONE;\n    else if( EQUAL( pszValue, \"JPEG\" ) )\n        nCompression = COMPRESSION_JPEG;\n    else if( EQUAL( pszValue, \"LZW\" ) )\n        nCompression = COMPRESSION_LZW;\n    else if( EQUAL( pszValue, \"PACKBITS\" ))\n        nCompression = COMPRESSION_PACKBITS;\n    else if( EQUAL( pszValue, \"DEFLATE\" ) || EQUAL( pszValue, \"ZIP\" ))\n        nCompression = COMPRESSION_ADOBE_DEFLATE;\n    else if( EQUAL( pszValue, \"FAX3\" )\n             || EQUAL( pszValue, \"CCITTFAX3\" ))\n        nCompression = COMPRESSION_CCITTFAX3;\n    else if( EQUAL( pszValue, \"FAX4\" )\n             || EQUAL( pszValue, \"CCITTFAX4\" ))\n        nCompression = COMPRESSION_CCITTFAX4;\n    else if( EQUAL( pszValue, \"CCITTRLE\" ) )\n        nCompression = COMPRESSION_CCITTRLE;\n    else if( EQUAL( pszValue, \"LZMA\" ) )\n        nCompression = COMPRESSION_LZMA;\n    else if( EQUAL( pszValue, \"ZSTD\" ) )\n        nCompression = COMPRESSION_ZSTD;\n#ifdef HAVE_LERC\n    else if( EQUAL( pszValue, \"LERC\" ) ||\n             EQUAL( pszValue, \"LERC_DEFLATE\" ) ||\n             EQUAL( pszValue, \"LERC_ZSTD\" ) )\n    {\n        nCompression = COMPRESSION_LERC;\n    }\n#endif\n    else if( EQUAL( pszValue, \"WEBP\" ) )\n        nCompression = COMPRESSION_WEBP;\n    else\n        CPLError( CE_Warning, CPLE_IllegalArg,\n                  \"%s=%s value not recognised, ignoring.\",\n                  pszVariableName,pszValue );\n\n    if( nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(static_cast<uint16>(nCompression)) )\n    {\n        CPLError(\n            CE_Failure, CPLE_AppDefined,\n            \"Cannot create TIFF file due to missing codec for %s.\", pszValue );\n        return -1;\n    }\n\n    return nCompression;\n}\n\n/************************************************************************/\n/*                     GTiffGetCompressValues()                         */\n/************************************************************************/\n\nCPLString GTiffGetCompressValues(bool& bHasLZW,\n                                 bool& bHasDEFLATE,\n                                 bool& bHasLZMA,\n                                 bool& bHasZSTD,\n                                 bool& bHasJPEG,\n                                 bool& bHasWebP,\n                                 bool bForCOG)\n{\n\n/* -------------------------------------------------------------------- */\n/*      Determine which compression codecs are available that we        */\n/*      want to advertise.  If we are using an old libtiff we won't     */\n/*      be able to find out so we just assume all are available.        */\n/* -------------------------------------------------------------------- */\n    CPLString osCompressValues = \"       <Value>NONE</Value>\";\n\n    TIFFCodec *codecs = TIFFGetConfiguredCODECs();\n\n    for( TIFFCodec *c = codecs; c->name; ++c )\n    {\n        if( c->scheme == COMPRESSION_PACKBITS && !bForCOG )\n        {\n            osCompressValues +=\n                    \"       <Value>PACKBITS</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_JPEG )\n        {\n            bHasJPEG = true;\n            osCompressValues +=\n                    \"       <Value>JPEG</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_LZW )\n        {\n            bHasLZW = true;\n            osCompressValues +=\n                    \"       <Value>LZW</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_ADOBE_DEFLATE )\n        {\n            bHasDEFLATE = true;\n            osCompressValues +=\n                    \"       <Value>DEFLATE</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_CCITTRLE && !bForCOG )\n        {\n            osCompressValues +=\n                    \"       <Value>CCITTRLE</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_CCITTFAX3 && !bForCOG )\n        {\n            osCompressValues +=\n                    \"       <Value>CCITTFAX3</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_CCITTFAX4 && !bForCOG )\n        {\n            osCompressValues +=\n                    \"       <Value>CCITTFAX4</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_LZMA && !bForCOG )\n        {\n            bHasLZMA = true;\n            osCompressValues +=\n                    \"       <Value>LZMA</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_ZSTD )\n        {\n            bHasZSTD = true;\n            osCompressValues +=\n                    \"       <Value>ZSTD</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_WEBP )\n        {\n            bHasWebP = true;\n            osCompressValues +=\n                    \"       <Value>WEBP</Value>\";\n        }\n    }\n#ifdef HAVE_LERC\n    osCompressValues +=\n                    \"       <Value>LERC</Value>\";\n    osCompressValues +=\n                    \"       <Value>LERC_DEFLATE</Value>\";\n    if( bHasZSTD )\n    {\n        osCompressValues +=\n                    \"       <Value>LERC_ZSTD</Value>\";\n    }\n#endif\n    _TIFFfree( codecs );\n\n    return osCompressValues;\n}\n\n/************************************************************************/\n/*                          GDALRegister_GTiff()                        */\n/************************************************************************/\n\nvoid GDALRegister_GTiff()\n\n{\n    if( GDALGetDriverByName( \"GTiff\" ) != nullptr )\n        return;\n\n    CPLString osOptions;\n\n    bool bHasLZW = false;\n    bool bHasDEFLATE = false;\n    bool bHasLZMA = false;\n    bool bHasZSTD = false;\n    bool bHasJPEG = false;\n    bool bHasWebP = false;\n    CPLString osCompressValues(GTiffGetCompressValues(\n        bHasLZW, bHasDEFLATE, bHasLZMA, bHasZSTD, bHasJPEG, bHasWebP,\n        false /* bForCOG */));\n\n    GDALDriver *poDriver = new GDALDriver();\n\n/* -------------------------------------------------------------------- */\n/*      Build full creation option list.                                */\n/* -------------------------------------------------------------------- */\n    osOptions = \"<CreationOptionList>\"\n              \"   <Option name='COMPRESS' type='string-select'>\";\n    osOptions += osCompressValues;\n    osOptions += \"   </Option>\";\n    if( bHasLZW || bHasDEFLATE || bHasZSTD )\n        osOptions += \"\"\n\"   <Option name='PREDICTOR' type='int' description='Predictor Type (1=default, 2=horizontal differencing, 3=floating point prediction)'/>\";\n    osOptions += \"\"\n\"   <Option name='DISCARD_LSB' type='string' description='Number of least-significant bits to set to clear as a single value or comma-separated list of values for per-band values'/>\";\n    if( bHasJPEG )\n    {\n        osOptions += \"\"\n\"   <Option name='JPEG_QUALITY' type='int' description='JPEG quality 1-100' default='75'/>\"\n\"   <Option name='JPEGTABLESMODE' type='int' description='Content of JPEGTABLES tag. 0=no JPEGTABLES tag, 1=Quantization tables only, 2=Huffman tables only, 3=Both' default='1'/>\";\n#ifdef JPEG_DIRECT_COPY\n        osOptions += \"\"\n\"   <Option name='JPEG_DIRECT_COPY' type='boolean' description='To copy without any decompression/recompression a JPEG source file' default='NO'/>\";\n#endif\n    }\n    if( bHasDEFLATE )\n    {\n#ifdef LIBDEFLATE_SUPPORT\n        osOptions += \"\"\n\"   <Option name='ZLEVEL' type='int' description='DEFLATE compression level 1-12' default='6'/>\";\n#else\n        osOptions += \"\"\n\"   <Option name='ZLEVEL' type='int' description='DEFLATE compression level 1-9' default='6'/>\";\n#endif\n    }\n    if( bHasLZMA )\n        osOptions += \"\"\n\"   <Option name='LZMA_PRESET' type='int' description='LZMA compression level 0(fast)-9(slow)' default='6'/>\";\n    if( bHasZSTD )\n        osOptions += \"\"\n\"   <Option name='ZSTD_LEVEL' type='int' description='ZSTD compression level 1(fast)-22(slow)' default='9'/>\";\n#ifdef HAVE_LERC\n    osOptions += \"\"\n\"   <Option name='MAX_Z_ERROR' type='float' description='Maximum error for LERC compression' default='0'/>\";\n#endif\n    if ( bHasWebP )\n    {\n      osOptions += \"\"\n#if WEBP_ENCODER_ABI_VERSION >= 0x0100\n\"   <Option name='WEBP_LOSSLESS' type='boolean' description='Whether lossless compression should be used' default='FALSE'/>\"\n#endif\n\"   <Option name='WEBP_LEVEL' type='int' description='WEBP quality level. Low values result in higher compression ratios' default='75'/>\";\n    }\n    osOptions += \"\"\n\"   <Option name='NUM_THREADS' type='string' description='Number of worker threads for compression. Can be set to ALL_CPUS' default='1'/>\"\n\"   <Option name='NBITS' type='int' description='BITS for sub-byte files (1-7), sub-uint16 (9-15), sub-uint32 (17-31), or float32 (16)'/>\"\n\"   <Option name='INTERLEAVE' type='string-select' default='PIXEL'>\"\n\"       <Value>BAND</Value>\"\n\"       <Value>PIXEL</Value>\"\n\"   </Option>\"\n\"   <Option name='TILED' type='boolean' description='Switch to tiled format'/>\"\n\"   <Option name='TFW' type='boolean' description='Write out world file'/>\"\n\"   <Option name='RPB' type='boolean' description='Write out .RPB (RPC) file'/>\"\n\"   <Option name='RPCTXT' type='boolean' description='Write out _RPC.TXT file'/>\"\n\"   <Option name='BLOCKXSIZE' type='int' description='Tile Width'/>\"\n\"   <Option name='BLOCKYSIZE' type='int' description='Tile/Strip Height'/>\"\n\"   <Option name='PHOTOMETRIC' type='string-select'>\"\n\"       <Value>MINISBLACK</Value>\"\n\"       <Value>MINISWHITE</Value>\"\n\"       <Value>PALETTE</Value>\"\n\"       <Value>RGB</Value>\"\n\"       <Value>CMYK</Value>\"\n\"       <Value>YCBCR</Value>\"\n\"       <Value>CIELAB</Value>\"\n\"       <Value>ICCLAB</Value>\"\n\"       <Value>ITULAB</Value>\"\n\"   </Option>\"\n\"   <Option name='SPARSE_OK' type='boolean' description='Should empty blocks be omitted on disk?' default='FALSE'/>\"\n\"   <Option name='ALPHA' type='string-select' description='Mark first extrasample as being alpha'>\"\n\"       <Value>NON-PREMULTIPLIED</Value>\"\n\"       <Value>PREMULTIPLIED</Value>\"\n\"       <Value>UNSPECIFIED</Value>\"\n\"       <Value aliasOf='NON-PREMULTIPLIED'>YES</Value>\"\n\"       <Value aliasOf='UNSPECIFIED'>NO</Value>\"\n\"   </Option>\"\n\"   <Option name='PROFILE' type='string-select' default='GDALGeoTIFF'>\"\n\"       <Value>GDALGeoTIFF</Value>\"\n\"       <Value>GeoTIFF</Value>\"\n\"       <Value>BASELINE</Value>\"\n\"   </Option>\"\n\"   <Option name='PIXELTYPE' type='string-select'>\"\n\"       <Value>DEFAULT</Value>\"\n\"       <Value>SIGNEDBYTE</Value>\"\n\"   </Option>\"\n\"   <Option name='BIGTIFF' type='string-select' description='Force creation of BigTIFF file'>\"\n\"     <Value>YES</Value>\"\n\"     <Value>NO</Value>\"\n\"     <Value>IF_NEEDED</Value>\"\n\"     <Value>IF_SAFER</Value>\"\n\"   </Option>\"\n\"   <Option name='ENDIANNESS' type='string-select' default='NATIVE' description='Force endianness of created file. For DEBUG purpose mostly'>\"\n\"       <Value>NATIVE</Value>\"\n\"       <Value>INVERTED</Value>\"\n\"       <Value>LITTLE</Value>\"\n\"       <Value>BIG</Value>\"\n\"   </Option>\"\n\"   <Option name='COPY_SRC_OVERVIEWS' type='boolean' default='NO' description='Force copy of overviews of source dataset (CreateCopy())'/>\"\n\"   <Option name='SOURCE_ICC_PROFILE' type='string' description='ICC profile'/>\"\n\"   <Option name='SOURCE_PRIMARIES_RED' type='string' description='x,y,1.0 (xyY) red chromaticity'/>\"\n\"   <Option name='SOURCE_PRIMARIES_GREEN' type='string' description='x,y,1.0 (xyY) green chromaticity'/>\"\n\"   <Option name='SOURCE_PRIMARIES_BLUE' type='string' description='x,y,1.0 (xyY) blue chromaticity'/>\"\n\"   <Option name='SOURCE_WHITEPOINT' type='string' description='x,y,1.0 (xyY) whitepoint'/>\"\n\"   <Option name='TIFFTAG_TRANSFERFUNCTION_RED' type='string' description='Transfer function for red'/>\"\n\"   <Option name='TIFFTAG_TRANSFERFUNCTION_GREEN' type='string' description='Transfer function for green'/>\"\n\"   <Option name='TIFFTAG_TRANSFERFUNCTION_BLUE' type='string' description='Transfer function for blue'/>\"\n\"   <Option name='TIFFTAG_TRANSFERRANGE_BLACK' type='string' description='Transfer range for black'/>\"\n\"   <Option name='TIFFTAG_TRANSFERRANGE_WHITE' type='string' description='Transfer range for white'/>\"\n\"   <Option name='STREAMABLE_OUTPUT' type='boolean' default='NO' description='Enforce a mode compatible with a streamable file'/>\"\n\"   <Option name='GEOTIFF_KEYS_FLAVOR' type='string-select' default='STANDARD' description='Which flavor of GeoTIFF keys must be used'>\"\n\"       <Value>STANDARD</Value>\"\n\"       <Value>ESRI_PE</Value>\"\n\"   </Option>\"\n#if LIBGEOTIFF_VERSION >= 1600\n\"   <Option name='GEOTIFF_VERSION' type='string-select' default='AUTO' description='Which version of GeoTIFF must be used'>\"\n\"       <Value>AUTO</Value>\"\n\"       <Value>1.0</Value>\"\n\"       <Value>1.1</Value>\"\n\"   </Option>\"\n#endif\n\"</CreationOptionList>\";\n\n/* -------------------------------------------------------------------- */\n/*      Set the driver details.                                         */\n/* -------------------------------------------------------------------- */\n    poDriver->SetDescription( \"GTiff\" );\n    poDriver->SetMetadataItem( GDAL_DCAP_RASTER, \"YES\" );\n    poDriver->SetMetadataItem( GDAL_DMD_LONGNAME, \"GeoTIFF\" );\n    poDriver->SetMetadataItem( GDAL_DMD_HELPTOPIC, \"drivers/raster/gtiff.html\" );\n    poDriver->SetMetadataItem( GDAL_DMD_MIMETYPE, \"image/tiff\" );\n    poDriver->SetMetadataItem( GDAL_DMD_EXTENSION, \"tif\" );\n    poDriver->SetMetadataItem( GDAL_DMD_EXTENSIONS, \"tif tiff\" );\n    poDriver->SetMetadataItem( GDAL_DMD_CREATIONDATATYPES,\n                               \"Byte UInt16 Int16 UInt32 Int32 Float32 \"\n                               \"Float64 CInt16 CInt32 CFloat32 CFloat64\" );\n    poDriver->SetMetadataItem( GDAL_DMD_CREATIONOPTIONLIST, osOptions );\n    poDriver->SetMetadataItem( GDAL_DMD_OPENOPTIONLIST,\n\"<OpenOptionList>\"\n\"   <Option name='NUM_THREADS' type='string' description='Number of worker threads for compression. Can be set to ALL_CPUS' default='1'/>\"\n\"   <Option name='GEOTIFF_KEYS_FLAVOR' type='string-select' default='STANDARD' description='Which flavor of GeoTIFF keys must be used (for writing)'>\"\n\"       <Value>STANDARD</Value>\"\n\"       <Value>ESRI_PE</Value>\"\n\"   </Option>\"\n\"   <Option name='GEOREF_SOURCES' type='string' description='Comma separated list made with values INTERNAL/TABFILE/WORLDFILE/PAM/NONE that describe the priority order for georeferencing' default='PAM,INTERNAL,TABFILE,WORLDFILE'/>\"\n\"   <Option name='SPARSE_OK' type='boolean' description='Should empty blocks be omitted on disk?' default='FALSE'/>\"\n\"</OpenOptionList>\" );\n    poDriver->SetMetadataItem( GDAL_DMD_SUBDATASETS, \"YES\" );\n    poDriver->SetMetadataItem( GDAL_DCAP_VIRTUALIO, \"YES\" );\n\n#ifdef INTERNAL_LIBTIFF\n    poDriver->SetMetadataItem( \"LIBTIFF\", \"INTERNAL\" );\n#else\n    poDriver->SetMetadataItem( \"LIBTIFF\", TIFFLIB_VERSION_STR );\n#endif\n\n#define STRINGIFY(x) #x\n#define XSTRINGIFY(x) STRINGIFY(x)\n    poDriver->SetMetadataItem( \"LIBGEOTIFF\", XSTRINGIFY(LIBGEOTIFF_VERSION) );\n\n    poDriver->pfnOpen = GTiffDataset::Open;\n    poDriver->pfnCreate = GTiffDataset::Create;\n    poDriver->pfnCreateCopy = GTiffDataset::CreateCopy;\n    poDriver->pfnUnloadDriver = GDALDeregister_GTiff;\n    poDriver->pfnIdentify = GTiffDataset::Identify;\n\n    GetGDALDriverManager()->RegisterDriver( poDriver );\n}\n",
                "name": "geotiff.cpp",
                "path": "deps/libgdal/gdal/frmts/gtiff/geotiff.cpp",
                "url": "/github.com/yocontra/node-gdal-next/-/blob/deps/libgdal/gdal/frmts/gtiff/geotiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 6341,
                    "offsetAndLengths": [
                        [
                            16,
                            19
                        ]
                    ],
                    "preview": "            if( TIFFReadRGBATileExt("
                }
            ],
            "repository": {
                "name": "github.com/yocontra/node-gdal-next",
                "url": "/github.com/yocontra/node-gdal-next"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "757df93e6f42f021e801d818970e9f19215df35f"
                },
                "content": "/******************************************************************************\n *\n * Project:  GeoTIFF Driver\n * Purpose:  GDAL GeoTIFF support.\n * Author:   Frank Warmerdam, warmerdam@pobox.com\n *\n ******************************************************************************\n * Copyright (c) 1998, 2002, Frank Warmerdam <warmerdam@pobox.com>\n * Copyright (c) 2007-2015, Even Rouault <even dot rouault at spatialys dot com>\n *\n * SPDX-License-Identifier: MIT\n ****************************************************************************/\n\n#include \"gtiffrgbaband.h\"\n#include \"gtiffdataset.h\"\n\n#include \"tiffio.h\"\n\n/************************************************************************/\n/*                           GTiffRGBABand()                            */\n/************************************************************************/\n\nGTiffRGBABand::GTiffRGBABand(GTiffDataset *poDSIn, int nBandIn)\n    : GTiffRasterBand(poDSIn, nBandIn)\n{\n    eDataType = GDT_Byte;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRGBABand::IGetDataCoverageStatus(int, int, int, int, int, double *)\n{\n    return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n           GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IWriteBlock(int, int, void *)\n\n{\n    ReportError(CE_Failure, CPLE_AppDefined,\n                \"RGBA interpreted raster bands are read-only.\");\n    return CE_Failure;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IReadBlock(int nBlockXOff, int nBlockYOff, void *pImage)\n\n{\n    m_poGDS->Crystalize();\n\n    const auto nBlockBufSize =\n        4 * static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if (m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE)\n    {\n        for (int iBand = 0; iBand < m_poGDS->m_nSamplesPerPixel; iBand++)\n        {\n            int nBlockIdBand = nBlockId + iBand * m_poGDS->m_nBlocksPerBand;\n            if (!m_poGDS->IsBlockAvailable(nBlockIdBand, nullptr, nullptr,\n                                           nullptr))\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if (!m_poGDS->IsBlockAvailable(nBlockId, nullptr, nullptr, nullptr))\n            return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Allocate a temporary buffer for this strip.                     */\n    /* -------------------------------------------------------------------- */\n    if (m_poGDS->m_pabyBlockBuf == nullptr)\n    {\n        m_poGDS->m_pabyBlockBuf = static_cast<GByte *>(\n            VSI_MALLOC3_VERBOSE(4, nBlockXSize, nBlockYSize));\n        if (m_poGDS->m_pabyBlockBuf == nullptr)\n            return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Read the strip                                                  */\n    /* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if (m_poGDS->m_nLoadedBlock != nBlockId)\n    {\n        if (TIFFIsTiled(m_poGDS->m_hTIFF))\n        {\n            if (TIFFReadRGBATileExt(\n                    m_poGDS->m_hTIFF, nBlockXOff * nBlockXSize,\n                    nBlockYOff * nBlockYSize,\n                    reinterpret_cast<uint32_t *>(m_poGDS->m_pabyBlockBuf),\n                    !m_poGDS->m_bIgnoreReadErrors) == 0 &&\n                !m_poGDS->m_bIgnoreReadErrors)\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError(CE_Failure, CPLE_AppDefined,\n                            \"TIFFReadRGBATile() failed.\");\n\n                memset(m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize);\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n            if (TIFFReadRGBAStripExt(\n                    m_poGDS->m_hTIFF, nBlockId * nBlockYSize,\n                    reinterpret_cast<uint32_t *>(m_poGDS->m_pabyBlockBuf),\n                    !m_poGDS->m_bIgnoreReadErrors) == 0 &&\n                !m_poGDS->m_bIgnoreReadErrors)\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError(CE_Failure, CPLE_AppDefined,\n                            \"TIFFReadRGBAStrip() failed.\");\n\n                memset(m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize);\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    m_poGDS->m_nLoadedBlock = eErr == CE_None ? nBlockId : -1;\n\n    /* -------------------------------------------------------------------- */\n    /*      Handle simple case of eight bit data, and pixel interleaving.   */\n    /* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if (nBlockYOff * nBlockYSize > GetYSize() - nBlockYSize &&\n        !TIFFIsTiled(m_poGDS->m_hTIFF))\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for (int iDestLine = 0; iDestLine < nThisBlockYSize; ++iDestLine)\n    {\n        const auto nSrcOffset =\n            static_cast<GPtrDiff_t>(nThisBlockYSize - iDestLine - 1) *\n            nBlockXSize * 4;\n\n        GDALCopyWords(m_poGDS->m_pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n                      static_cast<GByte *>(pImage) +\n                          static_cast<GPtrDiff_t>(iDestLine) * nBlockXSize,\n                      GDT_Byte, 1, nBlockXSize);\n    }\n\n    if (eErr == CE_None)\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRGBABand::GetColorInterpretation()\n\n{\n    if (nBand == 1)\n        return GCI_RedBand;\n    if (nBand == 2)\n        return GCI_GreenBand;\n    if (nBand == 3)\n        return GCI_BlueBand;\n\n    return GCI_AlphaBand;\n}\n",
                "name": "gtiffrgbaband.cpp",
                "path": "frmts/gtiff/gtiffrgbaband.cpp",
                "url": "/github.com/OSGeo/gdal/-/blob/frmts/gtiff/gtiffrgbaband.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 99,
                    "offsetAndLengths": [
                        [
                            16,
                            19
                        ]
                    ],
                    "preview": "            if (TIFFReadRGBATileExt("
                }
            ],
            "repository": {
                "name": "github.com/OSGeo/gdal",
                "url": "/github.com/OSGeo/gdal"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "94700bd96ffbe6160b1d0a1e98ff91d24a997208"
                },
                "content": "/******************************************************************************\n *\n * Project:  GeoTIFF Driver\n * Purpose:  GDAL GeoTIFF support.\n * Author:   Frank Warmerdam, warmerdam@pobox.com\n *\n ******************************************************************************\n * Copyright (c) 1998, 2002, Frank Warmerdam <warmerdam@pobox.com>\n * Copyright (c) 2007-2015, Even Rouault <even dot rouault at spatialys dot com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ****************************************************************************/\n\n#include \"gtiffrgbaband.h\"\n#include \"gtiffdataset.h\"\n\n#include \"tiffio.h\"\n\n/************************************************************************/\n/*                           GTiffRGBABand()                            */\n/************************************************************************/\n\nGTiffRGBABand::GTiffRGBABand(GTiffDataset *poDSIn, int nBandIn)\n    : GTiffRasterBand(poDSIn, nBandIn)\n{\n    eDataType = GDT_Byte;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRGBABand::IGetDataCoverageStatus(int, int, int, int, int, double *)\n{\n    return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n           GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IWriteBlock(int, int, void *)\n\n{\n    ReportError(CE_Failure, CPLE_AppDefined,\n                \"RGBA interpreted raster bands are read-only.\");\n    return CE_Failure;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IReadBlock(int nBlockXOff, int nBlockYOff, void *pImage)\n\n{\n    m_poGDS->Crystalize();\n\n    const auto nBlockBufSize =\n        4 * static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if (m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE)\n    {\n        for (int iBand = 0; iBand < m_poGDS->m_nSamplesPerPixel; iBand++)\n        {\n            int nBlockIdBand = nBlockId + iBand * m_poGDS->m_nBlocksPerBand;\n            if (!m_poGDS->IsBlockAvailable(nBlockIdBand))\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if (!m_poGDS->IsBlockAvailable(nBlockId))\n            return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Allocate a temporary buffer for this strip.                     */\n    /* -------------------------------------------------------------------- */\n    if (m_poGDS->m_pabyBlockBuf == nullptr)\n    {\n        m_poGDS->m_pabyBlockBuf = static_cast<GByte *>(\n            VSI_MALLOC3_VERBOSE(4, nBlockXSize, nBlockYSize));\n        if (m_poGDS->m_pabyBlockBuf == nullptr)\n            return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Read the strip                                                  */\n    /* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if (m_poGDS->m_nLoadedBlock != nBlockId)\n    {\n        if (TIFFIsTiled(m_poGDS->m_hTIFF))\n        {\n            if (TIFFReadRGBATileExt(\n                    m_poGDS->m_hTIFF, nBlockXOff * nBlockXSize,\n                    nBlockYOff * nBlockYSize,\n                    reinterpret_cast<uint32_t *>(m_poGDS->m_pabyBlockBuf),\n                    !m_poGDS->m_bIgnoreReadErrors) == 0 &&\n                !m_poGDS->m_bIgnoreReadErrors)\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError(CE_Failure, CPLE_AppDefined,\n                            \"TIFFReadRGBATile() failed.\");\n\n                memset(m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize);\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n            if (TIFFReadRGBAStripExt(\n                    m_poGDS->m_hTIFF, nBlockId * nBlockYSize,\n                    reinterpret_cast<uint32_t *>(m_poGDS->m_pabyBlockBuf),\n                    !m_poGDS->m_bIgnoreReadErrors) == 0 &&\n                !m_poGDS->m_bIgnoreReadErrors)\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError(CE_Failure, CPLE_AppDefined,\n                            \"TIFFReadRGBAStrip() failed.\");\n\n                memset(m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize);\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    m_poGDS->m_nLoadedBlock = eErr == CE_None ? nBlockId : -1;\n\n    /* -------------------------------------------------------------------- */\n    /*      Handle simple case of eight bit data, and pixel interleaving.   */\n    /* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if (nBlockYOff * nBlockYSize > GetYSize() - nBlockYSize &&\n        !TIFFIsTiled(m_poGDS->m_hTIFF))\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for (int iDestLine = 0; iDestLine < nThisBlockYSize; ++iDestLine)\n    {\n        const auto nSrcOffset =\n            static_cast<GPtrDiff_t>(nThisBlockYSize - iDestLine - 1) *\n            nBlockXSize * 4;\n\n        GDALCopyWords(m_poGDS->m_pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n                      static_cast<GByte *>(pImage) +\n                          static_cast<GPtrDiff_t>(iDestLine) * nBlockXSize,\n                      GDT_Byte, 1, nBlockXSize);\n    }\n\n    if (eErr == CE_None)\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRGBABand::GetColorInterpretation()\n\n{\n    if (nBand == 1)\n        return GCI_RedBand;\n    if (nBand == 2)\n        return GCI_GreenBand;\n    if (nBand == 3)\n        return GCI_BlueBand;\n\n    return GCI_AlphaBand;\n}\n",
                "name": "gtiffrgbaband.cpp",
                "path": "3rdParty/Harlinn.gdal/frmts/gtiff/gtiffrgbaband.cpp",
                "url": "/github.com/Harlinn/Harlinn.Windows/-/blob/3rdParty/Harlinn.gdal/frmts/gtiff/gtiffrgbaband.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 114,
                    "offsetAndLengths": [
                        [
                            16,
                            19
                        ]
                    ],
                    "preview": "            if (TIFFReadRGBATileExt("
                }
            ],
            "repository": {
                "name": "github.com/Harlinn/Harlinn.Windows",
                "url": "/github.com/Harlinn/Harlinn.Windows"
            }
        }
    ],
    "LimitHit": false,
    "Cloning": [],
    "Missing": [],
    "Timedout": [],
    "ResultCount": 10,
    "ElapsedMilliseconds": 1466,
    "Alert": {
        "Title": "",
        "Description": "",
        "ProposedQueries": null
    }
}